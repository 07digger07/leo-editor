#@+leo-ver=5-thin
#@+node:ekr.20170302123956.1: * @file ../doc/leoAttic.txt
# This is Leo's final resting place for dead code.
# Much easier to access than a git repo.

#@@language python
#@@killbeautify
#@+all
#@+node:ekr.20190412154439.1: **  Abandoned projects
#@+node:ekr.20170203080350.1: *3* Abandoned #396: Show images in Leo's body pane
https://github.com/leo-editor/leo-editor/issues/396

#@+node:ekr.20170302151109.1: *4* ** Notes
@language rest
@wrap

Unicode 'object replacement character': u+FFFC

QTextDocument may be helpful: http://doc.qt.io/qt-5/qtextdocument.html
See QTextDocument.MetaInformation: http://doc.qt.io/qt-5/qtextdocument.html#MetaInformation-enum

http://stackoverflow.com/questions/3254652/
several-ways-of-placing-an-image-in-a-qtextedit

http://doc.qt.io/qt-5/qtextdocument.html#resource

QVariant QTextDocument::resource(int type, const QUrl &name) const

Returns data of the specified type from the resource with the given name.

This function is called by the rich text engine to request data that isn't directly stored by QTextDocument, but still associated with it. For example, images are referenced indirectly by the name attribute of a QTextImageFormat object.

Resources are cached internally in the document. If a resource can not be found in the cache, loadResource is called to try to load the resource. loadResource should then use addResource to add the resource to the cache.
#@+node:ekr.20170203105538.1: *4* Test inserting picture (new)
# https://github.com/leo-editor/leo-editor/issues/396
g.cls()
images = [i for i in range(len(p.b)) if ord(p.b[i]) > 128]
if images:
    print('images at', images)
else:
    table = (
        'application-x-leo-outline.png',
        'LeoDoc.ico',
    )    
    for image in table:
        path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', image)
        assert g.os_path_exists(path), repr(path)
        c.frame.body.wrapper.setInsertPoint(len(p.b))
        if 0:
            format = QtGui.QTextImageFormat()
            format.setName(path)
            cursor = cursor = body.widget.textCursor()
            cursor.insertImage(format)
        c.frame.body.widget.insertHtml('<img src="%s">' % path)
            # style="width:40px;height:80px;"
    for i, ch in enumerate(p.b):
        if ord(ch) > 128: print('new', i, ord(ch))
#
#￼￼
#@+node:ekr.20170204110006.1: *4* test3 insert an image
g.cls()
from leo.core.leoQt import QtGui
body = c.frame.body
table = ('box01.bmp','box02.bmp','box03.bmp',)
d = g.app.permanentScriptDict
images = d.get('images', [])
for image in table:
    path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', image)
    assert g.os_path_exists(path), repr(path)
    image = QtGui.QImage(path)
    images.append(image)
    body.wrapper.setInsertPoint(len(p.b))
    cursor = body.widget.textCursor()
    cursor.insertImage(image)
for i, ch in enumerate(p.b):
    if ord(ch) > 128: print('new', i, ord(ch))
d ['images'] = images
#
#
#@+node:ekr.20170204140521.1: *4* clear g.app.permanentScriptDict
g.printDict(g.app.permanentScriptDict)
g.app.permanentScriptDict = {}
#@+node:ekr.20170204135338.1: *4* @@button show-images
from leo.core.leoQt import QtCore
d = g.app.permanentScriptDict
name_index = d.get('name_index', 0)
names = ['leo_image%s' % (i) for i in range(name_index)]
# print('image names', names)
widget = c.frame.body.widget
doc = widget.document()
for i, name in enumerate(names):
    image = doc.resource(doc.ImageResource, QtCore.QUrl(name))
    print(name, image)
#@+node:ekr.20170204105958.1: *4* test2 insert an image
g.cls()
from leo.core.leoQt import QtGui
body = c.frame.body
table = (
    'application-x-leo-outline.png',
    'LeoDoc.ico',
)
g.app.permanentScriptDict = {}
d = g.app.permanentScriptDict
images = d.get('images', [])
cursors = d.get('cursors', [])
name_index = d.get('name_index', 0)
for image in table:
    path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', image)
    assert g.os_path_exists(path), repr(path)
    image = QtGui.QImage(path)
    print(image.format().name())
    images.append(image)
    body.wrapper.setInsertPoint(len(p.b))
    cursor = body.widget.textCursor()
    #name = 'leo_image%s' % name_index
    #name_index += 1
    cursor.insertImage(image)
    cursors.append(cursor)
for i, ch in enumerate(p.b):
    if ord(ch) > 128: print('new', i, ord(ch))
d ['images'] = images
d ['cursors'] = cursors
d ['name_index'] = name_index
g.app.permanentScriptDict = d
g.printDict(d)
#
#￼￼￼
#￼
#@+node:ekr.20190910020834.1: *3* black
#@+node:ekr.20190910023018.1: *4* imports
try:
    # pylint: disable=import-error
        # We can't assume the user has this.
    import black
except Exception:
    black = None
#@+node:ekr.20150531042746.1: *4* munging leo directives
#@+node:ekr.20150529084212.1: *5* comment_leo_lines (leoBeautifier.py)
def comment_leo_lines(p):
    '''Replace lines with Leonine syntax with special comments.'''
    # Choose the comment string so it appears nowhere in s.
    s0 = p.b
    n = 5
    while s0.find('#' + ('!' * n)) > -1:
        n += 1
    comment = '#' + ('!' * n)
    # Create a dict of directives.
    d = {}
    for z in g.globalDirectiveList:
        d[z] = True
    # Convert all Leonine lines to special comments.
    i, lines, result = 0, g.splitLines(s0), []
    while i < len(lines):
        progress = i
        s = lines[i]
        # Comment out any containing a section reference.
        j = s.find('<<')
        k = s.find('>>') if j > -1 else -1
        if -1 < j < k:
            result.append(comment + s)
            # Generate a properly-indented pass line.
            j2 = g.skip_ws(s, 0)
            result.append('%spass\n' % (' ' * j2))
        elif s.lstrip().startswith('@'):
            # Comment out all other Leonine constructs.
            if starts_doc_part(s):
                # Comment the entire doc part, until @c or @code.
                result.append(comment + s)
                i += 1
                while i < len(lines):
                    s = lines[i]
                    result.append(comment + s)
                    i += 1
                    if ends_doc_part(s):
                        break
            else:
                j = g.skip_ws(s, 0)
                assert s[j] == '@'
                j += 1
                k = g.skip_id(s, j, chars='-')
                if k > j:
                    word = s[j: k]
                    if word == 'others':
                        # Remember the original @others line.
                        result.append(comment + s)
                        # Generate a properly-indented pass line.
                        result.append('%spass\n' % (' ' * (j - 1)))
                    else:
                        # Comment only Leo directives, not decorators.
                        result.append(comment + s if word in d else s)
                else:
                    result.append(s)
        else:
            # A plain line.
            result.append(s)
        if i == progress:
            i += 1
    return comment, ''.join(result)
#@+node:ekr.20150531042830.1: *5* starts_doc_part & ends_doc_part
def starts_doc_part(s):
    '''Return True if s word matches @ or @doc.'''
    for delim in ('@\n', '@doc\n', '@ ', '@doc '):
        if s.startswith(delim):
            return True
    return False

def ends_doc_part(s):
    '''Return True if s word matches @c or @code.'''
    for delim in ('@c\n', '@code\n', '@c ', '@code '):
        if s.startswith(delim):
            return True
    return False
#@+node:ekr.20150529095117.1: *5* uncomment_leo_lines
def uncomment_leo_lines(comment, p, s0):
    '''Reverse the effect of comment_leo_lines.'''
    lines = g.splitLines(s0)
    i, result = 0, []
    while i < len(lines):
        progress = i
        s = lines[i]
        i += 1
        if s.find(comment) == -1:
            # A regular line.
            result.append(s)
        else:
            # One or more special lines.
            i = uncomment_special_lines(comment, i, lines, p, result, s)
        assert progress < i
    return ''.join(result).rstrip() + '\n'
#@+node:ekr.20150531041720.1: *5* uncomment_special_line & helpers
def uncomment_special_lines(comment, i, lines, p, result, s):
    '''
    s is a line containing the comment delim.
    i points at the *next* line.
    Handle one or more lines, appending stripped lines to result.
    '''
    s = s.lstrip().lstrip(comment)
    if starts_doc_part(s):
        result.append(s)
        while i < len(lines):
            s = lines[i].lstrip().lstrip(comment)
            i += 1
            result.append(s)
            if ends_doc_part(s):
                break
        return i
    j = s.find('<<')
    k = s.find('>>') if j > -1 else -1
    if -1 < j < k or s.find('@others') > -1:
        # A section reference line or an @others line.
        # Such lines are followed by a pass line.
        # The beautifier may insert blank lines before the pass line.
        kind = 'section ref' if -1 < j < k else '@others'
        # Restore the original line, including leading whitespace.
        result.append(s)
        # Skip blank lines.
        while i < len(lines) and not lines[i].strip():
            i += 1
        # Skip the pass line.
        if i < len(lines) and lines[i].lstrip().startswith('pass'):
            i += 1
        else:
            g.trace('*** no pass after %s: %s' % (kind, p.h))
    else:
        # A directive line.
        result.append(s)
    return i
#@+node:ekr.20180328065332.1: *3* Check conventions stuff
#@+node:ekr.20171208042251.1: *4* @@button check-conventions (no longer used)
g.cls()
if c.changed: c.save()

import imp
import leo.core.leoCheck as leoCheck
imp.reload(leoCheck)

do_all = True
do_string = True

fails = []
    # All of Leo's core files pass!
fn = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoTest.py')
<< define s >>
<< old tests >>
if do_all:
    utils = leoCheck.ProjectUtils()
    aList = utils.project_files('leo', force_all=False)
    # g.printList(aList)
    for fn in aList:
        sfn = g.shortFileName(fn)
        if sfn in fails:
            print('===== skipping', sfn)
        else:
            print('==== fn', sfn)
            leoCheck.ConventionChecker(c).check(fn=fn)
elif do_string: # Test string s.
    leoCheck.ConventionChecker(c).check(s=s)
else: # Test an actual file.
    leoCheck.ConventionChecker(c).check(fn=fn)
#@+node:ekr.20171208105236.1: *5* << define s >>
s = '''\
class T:
    
    def __init__(self, tempNode):
        self.tempNode = tempNode.copy()
    
    def setUp(self):
        tempNode = self.tempNode
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()
'''

s_ok2 = '''
class Context(object):
    def __init__ (self, parent_context):
        self.parent_context = parent_context
        if parent_context:
            parent_context.inner_contexts_list.append(self)
'''

s_ok= '''
class TC:
    def __init__(self, c):
        c.tc = self
    def add_tag(self, p):
        print(p.v) # AttributeError if p is a vnode.

class Test:
    def __init__(self,c):
        self.c = c
        self.tc = self.c.tc
    def add_tag(self):
        p = self.c.p
        self.tc.add_tag(p.v) # WRONG: arg should be p.
'''

#@+node:ekr.20171210062719.1: *5* << old tests >>
s_passes_1 = '''\
class C1:
        
    def f1(self, p):
        print(p.v)
        
    def f2(self, p):
        self.f1(p.v) # WRONG

'''


s_1 = '''\
class C1:

    def __init__(self, c):
        self.c = c
        c.theTagController = self
        
    def add_tag(self, p):
        pass

class C2:

    def oops(self, p):
        c.tagController.add_tag(p.v,tag)
            # WRONG: should be p.

'''


s_2 = '''\
class TagController:

    def __init__(self, c):
        self.c = c
        c.theTagController = self

    def add_tag(self, p, tag):
        # Will fail if p is a vnode
        tags = set(p.v.u.get('__node_tags', set([])))

class LeoTagWidget(QtWidgets.QWidget):

    def __init__(self,c,parent=None):
        self.c = c
        self.tc = self.c.theTagController

    def add_tag(self, event=None):
        p = self.c.p
        self.tc.add_tag(p.v,tag) # WRONG: should be p.

'''
#@+node:ekr.20160109150703.1: *4* class Stats (old & stupid, from )
class Stats(object):
    '''A class containing global statistics & other data'''
    @others
#@+node:ekr.20160109150703.2: *5*  sd.ctor
def __init__ (self):

    # Files...
    # self.completed_files = [] # Files handled by do_files.
    # self.failed_files = [] # Files that could not be opened.
    # self.files_list = [] # Files given by user or by import statements.
    # self.module_names = [] # Module names corresponding to file names.

    # Contexts.
    # self.context_list = {}
        # Keys are fully qualified context names; values are contexts.
    # self.modules_dict = {}
        # Keys are full file names; values are ModuleContext's.

    # Statistics...
    # self.n_chains = 0
    self.n_contexts = 0
    # self.n_errors = 0
    self.n_lambdas = 0
    self.n_modules = 0
    # self.n_relinked_pointers = 0
    # self.n_resolvable_names = 0
    # self.n_resolved_contexts = 0
    # self.n_relinked_names = 0

    # Names...
    self.n_attributes = 0
    self.n_expressions = 0
    self.n_ivars = 0
    self.n_names = 0        # Number of symbol table entries.
    self.n_del_names = 0
    self.n_load_names = 0
    self.n_param_names = 0
    self.n_param_refs = 0
    self.n_store_names = 0

    # Statements...
    self.n_assignments = 0
    self.n_calls = 0
    self.n_classes = 0
    self.n_defs = 0
    self.n_fors = 0
    self.n_globals = 0
    self.n_imports = 0
    self.n_lambdas = 0
    self.n_list_comps = 0
    self.n_returns = 0
    self.n_withs = 0

    # Times...
    self.parse_time = 0.0
    self.pass1_time = 0.0
    self.pass2_time = 0.0
    self.total_time = 0.0
#@+node:ekr.20160109150703.6: *5* sd.print_times
def print_times (self):

    sd = self
    times = (
        'parse_time',
        'pass1_time',
        # 'pass2_time', # the resolve_names pass is no longer used.
        'total_time',
    )
    max_n = 5
    for s in times:
        max_n = max(max_n,len(s))
    print('\nScan times...\n')
    for s in times:
        pad = ' ' * (max_n - len(s))
        print('%s%s: %2.2f' % (pad,s,getattr(sd,s)))
    print('')
#@+node:ekr.20160109150703.7: *5* sd.print_stats
def print_stats (self):

    sd = self
    table = (
        '*', 'errors',

        '*Contexts',
        'classes','contexts','defs','modules',

        '*Statements',
        'assignments','calls','fors','globals','imports',
        'lambdas','list_comps','returns','withs',

        '*Names',
        'attributes','del_names','load_names','names',
        'param_names','param_refs','store_names',
        #'resolvable_names','relinked_names','relinked_pointers',
        # 'ivars',
        # 'resolved_contexts',
    )
    max_n = 5
    for s in table:
        max_n = max(max_n,len(s))
    print('\nStatistics...\n')
    for s in table:
        var = 'n_%s' % s
        pad = ' ' * (max_n - len(s))
        if s.startswith('*'):
            if s[1:].strip():
                print('\n%s\n' % s[1:])
            else:
                pass # print('')
        else:
            pad = ' ' * (max_n - len(s))
            print('%s%s: %s' % (pad,s,getattr(sd,var)))
    print('')
#@+node:ekr.20171211054600.1: *4* OLD checkConventions (leoCheck.py)
def checkConventions(c):
    '''
    A stand-alone version of the @button node that tested the
    ConventionChecker class.
    
    The check-conventions command in checkerCommands.py saves c and reloads
    the leoCheck module before calling this function.
    '''
    g.cls()
    kind = 'all'
    project_name = 'leo'  # 'coverage', 'leo', 'lib2to3', 'pylint', 'rope'
    assert kind in ('all', 'file', 'production', 'string'), repr(kind)
    fn = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins', 'qt_tree.py')
    report_stats = True # and kind != 'production'
    trace_fn = True
    trace_skipped = False
    fails_dict = {
        'coverage': ['cmdline.py',],
        'lib2to3': ['fixer_util.py', 'fix_dict.py', 'patcomp.py', 'refactor.py'],
        'leo': [], # All of Leo's core files pass.
        'pylint': [
            'base.py', 'classes.py', 'format.py',
            'logging.py', 'python3.py', 'stdlib.py', 
            'docparams.py', 'lint.py',
        ],
        'rope': ['objectinfo.py', 'objectdb.py', 'runmod.py',],
    }
    fails = fails_dict.get(project_name, [])
    << define s >>
    s = g.adjustTripleString(s, c.tab_width)
    << old tests >>
    stats = Stats()
    if kind == 'production':
        for p in g.findRootsWithPredicate(c, c.p, predicate=None):
            x = ConventionChecker(c, stats)
            x.check(fn=g.fullPath(c, p), trace_fn=trace_fn)
    elif kind == 'all':
        utils = ProjectUtils()
        aList = utils.project_files(project_name, force_all=False)
        if aList:
            t1 = time.clock()
            for fn in aList:
                sfn = g.shortFileName(fn)
                if sfn in fails or fn in fails:
                    if trace_skipped: print('===== skipping', sfn)
                else:
                    ConventionChecker(c, stats).check(fn=fn, trace_fn=trace_fn)
            t2 = time.clock()
            print('%s files in %4.2f sec.' % (len(aList), (t2-t1)))
        else:
            print('no files for project: %s' % (project_name))
    elif kind == 'string':
        ConventionChecker(c, stats).check(s=s)
    else:
        assert kind == 'file', repr(kind)
        ConventionChecker(c, stats).check(fn=fn)
    if report_stats:
        stats.report()
#@+node:ekr.20171211054736.2: *5* << define s >>
s = '''\
class T:
    
    def __init__(self, tempNode):
        self.tempNode = tempNode.copy()
    
    def setUp(self):
        tempNode = self.tempNode
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()
'''

s_ok2 = '''
class Context(object):
    def __init__ (self, parent_context):
        self.parent_context = parent_context
        if parent_context:
            parent_context.inner_contexts_list.append(self)
'''
assert s_ok2

s_ok= '''
class TC:
    def __init__(self, c):
        c.tc = self
    def add_tag(self, p):
        print(p.v) # AttributeError if p is a vnode.

class Test:
    def __init__(self,c):
        self.c = c
        self.tc = self.c.tc
    def add_tag(self):
        p = self.c.p
        self.tc.add_tag(p.v) # WRONG: arg should be p.
'''
assert s_ok

#@+node:ekr.20171211054736.3: *5* << old tests >>
s_passes_1 = '''\
class C1:
        
    def f1(self, p):
        print(p.v)
        
    def f2(self, p):
        self.f1(p.v) # WRONG

'''
assert s_passes_1

s_1 = '''\
class C1:

    def __init__(self, c):
        self.c = c
        c.theTagController = self
        
    def add_tag(self, p):
        pass

class C2:

    def oops(self, p):
        c.tagController.add_tag(p.v,tag)
            # WRONG: should be p.

'''
assert s_1


s_2 = '''\
class TagController:

    def __init__(self, c):
        self.c = c
        c.theTagController = self

    def add_tag(self, p, tag):
        # Will fail if p is a vnode
        tags = set(p.v.u.get('__node_tags', set([])))

class LeoTagWidget(QtWidgets.QWidget):

    def __init__(self,c,parent=None):
        self.c = c
        self.tc = self.c.theTagController

    def add_tag(self, event=None):
        p = self.c.p
        self.tc.add_tag(p.v,tag) # WRONG: should be p.

'''
assert s_2
#@+node:ekr.20180813063846.1: *3* Fast-draw branches
#@+node:ekr.20180808075509.1: *4* qtree.partialDraw & helpers (never used)
def partialDraw(self, p):

    trace = True and not g.unitTesting
    c = self.c
    if 1:
        self.drawVisible()
    else:
        first_p = c.hoistStack[-1].p if c.hoistStack else c.rootPosition()
        aList1 = self.countVisible(first_p=first_p, target_p=p)
        aList2 = self.countVisible(first_p=p, target_p=None)
        if trace:
            n1, n2 = len(aList1), len(aList2)
            g.trace('%s + %s = %s' % (n1, n2, n1+n2))
        if 1:
            # Draw everything.
            self.drawList(aList1 + aList2)
        else:
            aList = self.computeVisiblePositions(aList1, aList2, p)
            self.drawList(aList)
#@+node:ekr.20180809110957.1: *5* qtree.computeVisiblePositions
def computeVisiblePositions(self, aList1, aList2, p):
    '''
    Compute the list of *visible* positions to be drawn.
    
    This is tricky.  We don't want to scroll the screen unnecessarily.
    '''
    # Show everything if possible.
    if len(aList1) + len(aList2) <= self.size:
        return aList1 + aList2
    c = self.c
    while p.hasParent():
        p.moveToParent()
    aList = []
    for i in range(self.size):
        aList.append(p.copy())
        p.moveToVisNext(c)
        if not p:
            break
    return aList
#@+node:ekr.20180809123937.1: *5* qtree.countVisible
def countVisible(self, first_p, target_p):
    """
    Return the number of visible positions from first_p to target_p.
    """
    c = self.c
    aList, p = [first_p.copy()], first_p.copy()
    while p:
        if p == target_p:
            return aList[:-1]
        v = p.v
        # if v.isExpanded() and v.hasChildren():
        if (v.statusBits & v.expandedBit) != 0 and v.children:
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            aList.append(p.copy())
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 < len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            aList.append(p.copy())
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 < len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break # Found: moveToThreadNext()
        else:
            break # Not found.
        # Found moveToThreadNext()
        aList.append(p.copy())
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
    return aList
#@+node:ekr.20180809115019.1: *5* qtree.drawList
def drawList(self, aList):
    
    trace = False
    c = self.c
    parents = []
    # Clear the widget.
    w = self.treeWidget
    w.clear()
    # Clear the dicts.
    self.initData()
    for p in aList:
        level = p.level()
        parent_item = w if level == 0 else parents[level-1]
        item = QtWidgets.QTreeWidgetItem(parent_item)
        item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
        item.setChildIndicatorPolicy(
            item.ShowIndicator if p.hasChildren()
            else item.DontShowIndicator)
        item.setExpanded(bool(p.hasChildren() and p.isExpanded()))
        self.items.append(item)
        if trace:
            print('')
            g.trace('===== level', level, p.h)
            g.trace('parent', id(parent_item), parent_item.__class__.__name__)
            g.trace('item  ', id(item), item.__class__.__name__)
            self.print_parents(parents, 1)
        # Update parents.
        if level == 0:
            parents = []
        else:
            parents = parents[:level]
        parents.append(item)
        if trace:
            self.print_parents(parents, 2)
        # Update the dicts.  Like rememberItem.
        itemHash = self.itemHash(item)
        self.item2positionDict[itemHash] = p.copy()
        self.item2vnodeDict[itemHash] = p.v
        self.position2itemDict[p.key()] = item
        d = self.vnode2itemsDict
        v = p.v
        aList = d.get(v, [])
        aList.append(item)
        d[v] = aList
        # Enter the headline.
        item.setText(0, p.h)
        # Set current item.
        if p == c.p:
            w.setCurrentItem(item)
#@+node:ekr.20180809111725.1: *5* qtree.printParents
def print_parents(self, parents, tag):
    print(tag)
    g.printObj([
        '%10s %s' % (id(z), z.__class__.__name__)
            for z in parents])
#@+node:ekr.20180810060655.1: *4* test vieldVisible
g.cls()
import time
tree = c.frame.tree
if 1: # works
    for p in c.all_positions():
        p.expand()
elif 1:
    for p in c.all_positions():
        p.v.expandedPositions = []
    for p in c.all_positions():
        p.v.expand()
        p.v.expandedPositions.append(p.copy())
else: # Doesn't work
    for v in c.all_nodes():
        v.expand()
    c.redraw() # This would be wrong.
if 1:
    t1 = time.clock()
    for i in range(1):
        aList1 = [z.copy() for z in tree.slowYieldVisible(c.rootPosition())]
    t2 = time.clock()
    print('slow: %6.3f' % (t2-t1))
if 1:
    t1 = time.clock()
    for i in range(1):
        aList2 = [z.copy() for z in tree.yieldVisible(c.rootPosition())]
    t2 = time.clock()
    print('fast: %6.3f' % (t2-t1))
v1 = [z.v for z in aList1]
v2 = [z.v for z in aList2]
try:
    i = 0
    while i < min(len(aList1), len(aList2)) and aList1[i] == aList2[i]:
        # print(i, aList1[i].h)
        i += 1
    if i == len(aList1) == len(aList2):
        print('OK')
    else:
        print('FAIL', i, len(aList1), len(aList2))
    assert aList1 == aList2, (len(aList1), len(aList2))
    assert v1 == v2, (len(v1), len(v2))
finally:
    for v in c.all_nodes():
        v.contract()
    c.redraw()
#@+node:ekr.20180810111515.1: *4* benchmark
import time
t1 = time.clock()
c.expandAllHeadlines()
t2 = time.clock()
print('expand: %5.2f sec' % (t2-t1))
t3 = time.clock()
tree = c.frame.tree
w = tree.treeWidget
n = 0
for p in tree.yieldVisible(c.rootPosition()):
    n += 1
    # c.selectPosition(p)
    item = tree.position2itemDict.get(c.p.key())
    if item:
        w.setCurrentItem(item)
t4 = time.clock()
print('%s nodes in %5.2f sec' % (n, t4-t3))
#@+node:ekr.20110605121601.17879: *4* qtree.rememberItem
def rememberItem(self, p, item):

    v = p.v
    # Update position dicts.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item
    # Update item2vnodeDict.
    self.item2vnodeDict[itemHash] = v # was item
    # Update vnode2itemsDict.
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item in aList:
        g.trace('*** ERROR *** item already in list: %s, %s' % (item, aList))
    else:
        aList.append(item)
    d[v] = aList
#@+node:ekr.20120219154958.10488: *4* LM.initFocusAndDraw (not used)
def initFocusAndDraw(self, c, fileName):

    def init_focus_handler(timer, c=c, p=c.p):
        '''Idle-time handler for initFocusAndDraw'''
        c.initialFocusHelper()
        c.outerUpdate()
        timer.stop()

    # This must happen after the code in getLeoFile.
    timer = g.IdleTime(init_focus_handler, delay=0.1, tag='getLeoFile')
    if timer:
        timer.start()
    else:
        # Default code.
        c.selectPosition(c.p)
        c.initialFocusHelper()
        c.k.showStateAndMode()
        c.outerUpdate()
#@+node:ekr.20150312225028.29: *3* leoViews project
This was a major project, now abandoned.
#@+node:ekr.20150312225028.31: *4* class OrganizerData
class OrganizerData:
    '''A class containing all data for a particular organizer node.'''
    def __init__ (self,h,unl,unls):
        self.anchor = None # The anchor position of this od node.
        self.children = [] # The direct child od nodes of this od node.
        self.closed = False # True: this od node no longer accepts new child od nodes.
        self.drop = True # Drop the unl for this od node when associating positions with unls.
        self.descendants = None # The descendant od nodes of this od node.
        self.exists = False # True: this od was created by @existing-organizer:
        self.h = h # The headline of this od node.
        self.moved = False # True: the od node has been moved to a global move list.
        self.opened = False # True: the od node has been opened.
        self.organized_nodes = [] # The list of positions organized by this od node.
        self.parent_od = None # The parent od node of this od node. (None is valid.)
        self.p = None # The position of this od node.
        self.parent = None # The original parent position of all nodes organized by this od node.
            # If parent_od is None, this will be the parent position of the od node.
        self.source_unl = None # The unl of self.parent.
        self.unl = unl # The unl of this od node.
        self.unls = unls # The unls contained in this od node.
        self.visited = False # True: demote_helper has already handled this od node.
    def __repr__(self):
        return 'OrganizerData: %s' % (self.h or '<no headline>')
    __str__ = __repr__
#@+node:ekr.20150312225028.32: *4* class ViewController
class ViewController:
    << docstring >>
    @others
#@+node:ekr.20150312225028.33: *5*  << docstring >> (class ViewController)
'''
A class to handle @views trees and related operations.
Such trees have the following structure:

- @views
  - @auto-view <unl of @auto node>
    - @organizers
      - @organizer <headline>
    - @clones
    
The body text of @organizer and @clones consists of unl's, one per line.
'''
#@+node:ekr.20150312225028.34: *5*  vc.ctor & vc.init
def __init__ (self,c):
    '''Ctor for ViewController class.'''
    self.c = c
    self.headline_ivar = '_imported_headline'
    self.init()
    
def init(self):
    '''
    Init all ivars of this class.
    Unit tests may call this method to ensure that this class is re-inited properly.
    '''
    self.all_ods = []
        # List of all od nodes.
    self.anchors_d = {}
        # Keys are anchoring positions, values are sorted lists of ods.
    self.anchor_offset_d = {}
        # Keys are anchoring positions, values are ints.
    self.existing_ods = []
        # List of od instances corresponding to @existing-organizer: nodes.
    self.global_bare_organizer_node_list = []
        # List of organizers that have no parent organizer node.
        # This list excludes existing organizer nodes.
    self.headlines_dict = {}
        # Keys are vnodes; values are list of child headlines.
    self.imported_organizers_list = []
        # The list of nodes that have children on entry, such as class nodes.
    self.n_nodes_scanned = 0
        # Number of nodes scanned by demote.
    self.organizer_ods = []
        # List of od instances corresponding to @organizer: nodes.
    self.organizer_unls = []
        # The list of od.unl for all od instances in self.organizer_ods.
    self.root = None
        # The position of the @auto node.
    self.pending = []
        # The list of nodes pending to be added to an organizer.
    self.stack = []
        # The stack containing real and virtual parent nodes during the main loop.
    self.temp_node = None
        # The parent position of all holding cells.
    self.trail_write_1 = None
        # The trial write on entry.
    self.views_node = None
        # The position of the @views node.
    self.work_list = []
        # A gloal list of (parent,child) tuples for all nodes that are
        # to be moved to **non-existing** organizer nodes.
        # **Important**: Nodes are moved in the order they appear in this list:
        # the tuples contain no childIndex component!
        # This list is the "backbone" of this class:
        # - The front end (demote and its helpers) adds items to this list.
        # - The back end (move_nodes and its helpers) moves nodes using this list.
#@+node:ekr.20150312225028.35: *5* vc.Entry points
#@+node:ekr.20150312225028.36: *6* vc.convert_at_file_to_at_auto
def convert_at_file_to_at_auto(self,root):
    # Define class ConvertController.
    @others
    vc = self
    c = vc.c
    if root.isAtFileNode():
        ConvertController(c,root).run()
    else:
        g.es_print('not an @file node:',root.h)
#@+node:ekr.20150312225028.37: *7* class ConvertController
class ConvertController:
    def __init__ (self,c,p):
        self.c = c
        # self.ic = c.importCommands
        self.vc = c.viewController
        self.root = p.copy()
    @others
#@+node:ekr.20150312225028.38: *8* cc.delete_at_auto_view_nodes
def delete_at_auto_view_nodes(self,root):
    '''Delete all @auto-view nodes pertaining to root.'''
    cc = self
    vc = cc.vc
    while True:
        p = vc.has_at_auto_view_node(root)
        if not p: break
        p.doDelete()
#@+node:ekr.20150312225028.39: *8* cc.import_from_string
def import_from_string(self,s):
    '''Import from s into a temp outline.'''
    cc = self # (ConvertController)
    c = cc.c
    ic = c.importCommands
    root = cc.root
    language = g.scanForAtLanguage(c,root) 
    ext = '.'+g.app.language_extension_dict.get(language)
    scanner = ic.scanner_for_ext(ext)
    # g.trace(language,ext,scanner.__name__)
    p = root.insertAfter()
    ok = scanner(atAuto=True,parent=p,s=s)
    p.h = root.h.replace('@file','@auto' if ok else '@@auto')
    return ok,p
#@+node:ekr.20150312225028.40: *8* cc.run
def run(self):
    '''Convert an @file tree to @auto tree.'''
    trace = True and not g.unitTesting
    trace_s = False
    cc = self
    c = cc.c
    root,vc = cc.root,c.viewController
    # set the headline_ivar for all vnodes.
    t1 = time.clock()
    cc.set_expected_imported_headlines(root)
    t2 = time.clock()
    # Delete all previous @auto-view nodes for this tree.
    cc.delete_at_auto_view_nodes(root)
    t3 = time.clock()
    # Ensure that all nodes of the tree are regularized.
    ok = vc.prepass(root)
    t4 = time.clock()
    if not ok:
        g.es_print('Can not convert',root.h,color='red')
        if trace: g.trace(
            '\n  set_expected_imported_headlines: %4.2f sec' % (t2-t1),
            # '\n  delete_at_auto_view_nodes:     %4.2f sec' % (t3-t2),
            '\n  prepass:                         %4.2f sec' % (t4-t3),
            '\n  total:                           %4.2f sec' % (t4-t1))
        return
    # Create the appropriate @auto-view node.
    at_auto_view = vc.update_before_write_at_auto_file(root)
    t5 = time.clock()
    # Write the @file node as if it were an @auto node.
    s = cc.strip_sentinels()
    t6 = time.clock()
    if trace and trace_s:
        g.trace('source file...\n',s)
    # Import the @auto string.
    ok,p = cc.import_from_string(s)
    t7 = time.clock()
    if ok:
        # Change at_auto_view.b so it matches p.gnx.
        at_auto_view.b = vc.at_auto_view_body(p)
        # Recreate the organizer nodes, headlines, etc.
        ok = vc.update_after_read_at_auto_file(p)
        t8 = time.clock()
        if not ok:
            p.h = '@@' + p.h
            g.trace('restoring original @auto file')
            ok,p = cc.import_from_string(s)
            if ok:
                p.h = '@@' + p.h + ' (restored)'
                if p.next():
                    p.moveAfter(p.next())
        t9 = time.clock()
    else:
        t8 = t9 = time.clock()
    if trace: g.trace(
        '\n  set_expected_imported_headlines: %4.2f sec' % (t2-t1),
        # '\n  delete_at_auto_view_nodes:     %4.2f sec' % (t3-t2),
        '\n  prepass:                         %4.2f sec' % (t4-t3),
        '\n  update_before_write_at_auto_file:%4.2f sec' % (t5-t4),
        '\n  strip_sentinels:                 %4.2f sec' % (t6-t5),
        '\n  import_from_string:              %4.2f sec' % (t7-t6),
        '\n  update_after_read_at_auto_file   %4.2f sec' % (t8-t7),
        '\n  import_from_string (restore)     %4.2f sec' % (t9-t8),
        '\n  total:                           %4.2f sec' % (t9-t1))
    if p:
        c.selectPosition(p)
    c.redraw()
#@+node:ekr.20150312225028.41: *8* cc.set_expected_imported_headlines
def set_expected_imported_headlines(self,root):
    '''Set the headline_ivar for all vnodes.'''
    trace = False and not g.unitTesting
    cc = self
    c = cc.c
    ic = cc.c.importCommands
    language = g.scanForAtLanguage(c,root) 
    ext = '.'+g.app.language_extension_dict.get(language)
    aClass = ic.classDispatchDict.get(ext)
    scanner = aClass(importCommands=ic,atAuto=True)
    # Duplicate the fn logic from ic.createOutline.
    theDir = g.setDefaultDirectory(c,root,importing=True)
    fn = c.os_path_finalize_join(theDir,root.h)
    fn = root.h.replace('\\','/')
    junk,fn = g.os_path_split(fn)
    fn,junk = g.os_path_splitext(fn)
    if aClass and hasattr(scanner,'headlineForNode'):
        ivar = cc.vc.headline_ivar
        for p in root.subtree():
            if not hasattr(p.v,ivar):
                h = scanner.headlineForNode(fn,p)
                setattr(p.v,ivar,h)
                if trace and h != p.h:
                    g.trace('==>',h) # p.h,'==>',h
#@+node:ekr.20150312225028.42: *8* cc.strip_sentinels
def strip_sentinels(self):
    '''Write the file to a string without headlines or sentinels.'''
    trace = False and not g.unitTesting
    cc = self
    at = cc.c.atFileCommands
    # ok = at.writeOneAtAutoNode(cc.root,
        # toString=True,force=True,trialWrite=True)
    at.errors = 0
    at.write(cc.root,
        kind = '@file',
        nosentinels = True,
        perfectImportFlag = False,
        scriptWrite = False,
        thinFile = True,
        toString = True)
    ok = at.errors == 0
    s = at.stringOutput
    if trace: g.trace('ok:',ok,'s:...\n'+s)
    return s
#@+node:ekr.20150312225028.43: *6* vc.pack & helper
def pack(self):
    '''
    Undoably convert c.p to a packed @view node, replacing all cloned
    children of c.p by unl lines in c.p.b.
    '''
    vc = self
    c,u = vc.c,vc.c.undoer
    vc.init()
    changed = False
    root = c.p
    # Create an undo group to handle changes to root and @views nodes.
    # Important: creating the @views node does *not* invalidate any positions.'''
    u.beforeChangeGroup(root,'view-pack')
    if not vc.has_at_views_node():
        changed = True
        bunch = u.beforeInsertNode(c.rootPosition())
        views = vc.find_at_views_node()
            # Creates the @views node as the *last* top-level node
            # so that no positions become invalid as a result.
        u.afterInsertNode(views,'create-views-node',bunch)
    # Prepend @view if need.
    if not root.h.strip().startswith('@'):
        changed = True
        bunch = u.beforeChangeNodeContents(root)
        root.h = '@view ' + root.h.strip()
        u.afterChangeNodeContents(root,'view-pack-update-headline',bunch)
    # Create an @view node as a clone of the @views node.
    bunch = u.beforeInsertNode(c.rootPosition())
    new_clone = vc.create_view_node(root)
    if new_clone:
        changed = True
        u.afterInsertNode(new_clone,'create-view-node',bunch)
    # Create a list of clones that have a representative node
    # outside of the root's tree.
    reps = [vc.find_representative_node(root,p)
        for p in root.children()
            if vc.is_cloned_outside_parent_tree(p)]
    reps = [z for z in reps if z is not None]
    if reps:
        changed = True
        bunch = u.beforeChangeTree(root)
        c.setChanged(True)
        # Prepend a unl: line for each cloned child.
        unls = ['unl: %s\n' % (vc.unl(p)) for p in reps]
        root.b = ''.join(unls) + root.b
        # Delete all child clones in the reps list.
        v_reps = set([p.v for p in reps])
        while True:
            for child in root.children():
                if child.v in v_reps:
                    child.doDelete()
                    break
            else: break
        u.afterChangeTree(root,'view-pack-tree',bunch)
    if changed:
        u.afterChangeGroup(root,'view-pack')
        c.selectPosition(root)
        c.redraw()
#@+node:ekr.20150312225028.44: *7* vc.create_view_node
def create_view_node(self,root):
    '''
    Create a clone of root as a child of the @views node.
    Return the *newly* cloned node, or None if it already exists.
    '''
    vc = self
    c = vc.c
    # Create a cloned child of the @views node if it doesn't exist.
    views = vc.find_at_views_node()
    for p in views.children():
        if p.v == c.p.v:
            return None
    p = root.clone()
    p.moveToLastChildOf(views)
    return p
#@+node:ekr.20150312225028.45: *6* vc.unpack
def unpack(self):
    '''
    Undoably unpack nodes corresponding to leading unl lines in c.p to child clones.
    Return True if the outline has, in fact, been changed.
    '''
    vc = self
    c,root,u = vc.c,vc.c.p,vc.c.undoer
    vc.init()
    # Find the leading unl: lines.
    i,lines,tag = 0,g.splitLines(root.b),'unl:'
    for s in lines:
        if s.startswith(tag): i += 1
        else: break
    changed = i > 0
    if changed:
        bunch = u.beforeChangeTree(root)
        # Restore the body
        root.b = ''.join(lines[i:])
        # Create clones for each unique unl.
        unls = list(set([s[len(tag):].strip() for s in lines[:i]]))
        for unl in unls:
            p = vc.find_absolute_unl_node(unl)
            if p: p.clone().moveToLastChildOf(root)
            else: g.trace('not found: %s' % (unl))
        c.setChanged(True)
        c.undoer.afterChangeTree(root,'view-unpack',bunch)
        c.redraw()
    return changed
#@+node:ekr.20150312225028.46: *6* vc.update_before_write_at_auto_file
def update_before_write_at_auto_file(self,root):
    '''
    Update the @auto-view node for root, an @auto node. Create @organizer,
    @existing-organizer, @clones and @headlines nodes as needed.
    This *must not* be called for trial writes.
    '''
    trace = False and not g.unitTesting
    vc = self
    c = vc.c
    changed = False
    t1 = time.clock()
    # Create lists of cloned and organizer nodes.
    clones,existing_organizers,organizers = \
        vc.find_special_nodes(root)
    # Delete all children of the @auto-view node for this @auto node.
    at_auto_view = vc.find_at_auto_view_node(root)
    if at_auto_view.hasChildren():
        changed = True
        at_auto_view.deleteAllChildren()
    # Create the single @clones node.
    if clones:
        at_clones = vc.find_at_clones_node(root)
        at_clones.b = ''.join(
            ['gnx: %s\nunl: %s\n' % (z[0],z[1]) for z in clones])
    # Create the single @organizers node.
    if organizers or existing_organizers:
        at_organizers = vc.find_at_organizers_node(root)
    # Create one @organizers: node for each organizer node.
    for p in organizers:
        # g.trace('organizer',p.h)
        at_organizer = at_organizers.insertAsLastChild()
        at_organizer.h = '@organizer: %s' % p.h
        # The organizer node's unl is implicit in each child's unl.
        at_organizer.b = '\n'.join([
            'unl: '+vc.relative_unl(z,root) for z in p.children()])
    # Create one @existing-organizer node for each existing organizer.
    ivar = vc.headline_ivar
    for p in existing_organizers:
        at_organizer = at_organizers.insertAsLastChild()
        h = getattr(p.v,ivar,p.h)
        if trace and h != p.h: g.trace('==>',h) # p.h,'==>',h
        at_organizer.h = '@existing-organizer: %s' % h
        # The organizer node's unl is implicit in each child's unl.
        at_organizer.b = '\n'.join([
            'unl: '+vc.relative_unl(z,root) for z in p.children()])
    # Create the single @headlines node.
    vc.create_at_headlines(root)
    if changed and not g.unitTesting:
        g.es_print('updated @views node in %4.2f sec.' % (
            time.clock()-t1))
    if changed:
        c.redraw()
    return at_auto_view # For at-file-to-at-auto command.
#@+node:ekr.20150312225028.47: *7* vc.create_at_headlines
def create_at_headlines(self,root):
    '''Create the @headlines node for root, an @auto file.'''
    vc = self
    c = vc.c
    result = []
    ivar = vc.headline_ivar
    for p in root.subtree():
        h = getattr(p.v,ivar,None)
        if h is not None and p.h != h:
            # g.trace('custom:',p.h,'imported:',h)
            unl = vc.relative_unl(p,root)
            aList = unl.split('-->')
            aList[-1] = h
            unl = '-->'.join(aList)
            result.append('imported unl: %s\nhead: %s\n' % (
                unl,p.h))
            delattr(p.v,ivar)
    if result:
        p = vc.find_at_headlines_node(root)
        p.b = ''.join(result)
#@+node:ekr.20150312225028.48: *7* vc.find_special_nodes
def find_special_nodes(self,root):
    '''
    Scan root's tree, looking for organizer and cloned nodes.
    Exclude organizers on imported organizers list.
    '''
    trace = False and not g.unitTesting
    verbose = False
    vc = self
    clones,existing_organizers,organizers = [],[],[]
    if trace: g.trace('imported existing',
        [v.h for v in vc.imported_organizers_list])
    for p in root.subtree():
        if p.isCloned():
            rep = vc.find_representative_node(root,p)
            if rep:
                unl = vc.relative_unl(p,root)
                gnx = rep.v.gnx
                clones.append((gnx,unl),)
        if p.v in vc.imported_organizers_list:
            # The node had children created by the importer.
            if trace and verbose: g.trace('ignore imported existing',p.h)
        elif vc.is_organizer_node(p,root):
            # p.hasChildren and p.b is empty, except for comments.
            if trace and verbose: g.trace('organizer',p.h)
            organizers.append(p.copy())
        elif p.hasChildren():
            if trace and verbose: g.trace('existing',p.h)
            existing_organizers.append(p.copy())
    return clones,existing_organizers,organizers
#@+node:ekr.20150312225028.49: *6* vc.update_after_read_at_auto_file & helpers
def update_after_read_at_auto_file(self,root):
    '''
    Recreate all organizer nodes and clones for a single @auto node
    using the corresponding @organizer: and @clones nodes.
    '''
    trace = True and not g.unitTesting
    vc = self
    c = vc.c
    if not vc.is_at_auto_node(root):
        return # Not an error: it might be and @auto-rst node.
    old_changed = c.isChanged()
    try:
        vc.init()
        vc.root = root.copy()
        t1 = time.clock()
        vc.trial_write_1 = vc.trial_write(root)
        t2 = time.clock()
        at_organizers = vc.has_at_organizers_node(root)
        t3 = time.clock()
        if at_organizers:
            vc.create_organizer_nodes(at_organizers,root)
        t4 = time.clock()
        at_clones = vc.has_at_clones_node(root)
        if at_clones:
            vc.create_clone_links(at_clones,root)
        t5 = time.clock()
        n = len(vc.work_list)
        ok = vc.check(root)
        t6 = time.clock()
        if ok:
            vc.update_headlines_after_read(root)
        t7 = time.clock()
        c.setChanged(old_changed if ok else False)
            # To do: revert if not ok.
    except Exception:
        g.es_exception()
        n = 0
        ok = False
    if trace:
        if t7-t1 > 0.5: g.trace(
            '\n  trial_write:                 %4.2f sec' % (t2-t1),
            # '\n  has_at_organizers_node:    %4.2f sec' % (t3-t2),
            '\n  create_organizer_nodes:      %4.2f sec' % (t4-t3),
            '\n  create_clone_links:          %4.2f sec' % (t5-t4),
            '\n  check:                       %4.2f sec' % (t6-t5),
            '\n  update_headlines_after_read: %4.2f sec' % (t7-t6),
            '\n  total:                       %4.2f sec' % (t7-t1))
            # '\n  file:',root.h)
        # else: g.trace('total: %4.2f sec' % (t7-t1),root.h)
    if ok and n > 0:
        g.es('rearragned: %s' % (root.h),color='blue')
        g.es('moved %s nodes in %4.2f sec.' % (n,t7-t1))
        g.trace('@auto-view moved %s nodes in %4.2f sec. for' % (
            n,t2),root.h,noname=True)
    c.selectPosition(root)
    c.redraw()
    return ok
#@+node:ekr.20150312225028.50: *7* vc.check
def check (self,root):
    '''
    Compare a trial write or root with the vc.trail_write_1.
    Unlike the perfect-import checks done by the importer,
    we expecct an *exact* match, regardless of language.
    '''
    trace = True # and not g.unitTesting
    vc = self
    trial1 = vc.trial_write_1
    trial2 = vc.trial_write(root)
    if trial1 != trial2:
        g.pr('') # Don't use print: it does not appear with the traces.
        g.es_print('perfect import check failed for:',color='red')
        g.es_print(root.h,color='red')
        if trace:
            vc.compare_trial_writes(trial1,trial2)
            g.pr('')
    return trial1 == trial2
#@+node:ekr.20150312225028.51: *7* vc.create_clone_link
def create_clone_link(self,gnx,root,unl):
    '''
    Replace the node in the @auto tree with the given unl by a
    clone of the node outside the @auto tree with the given gnx.
    '''
    trace = False and not g.unitTesting
    vc = self
    p1 = vc.find_position_for_relative_unl(root,unl)
    p2 = vc.find_gnx_node(gnx)
    if p1 and p2:
        if trace: g.trace('relink',gnx,p2.h,'->',p1.h)
        if p1.b == p2.b:
            p2._relinkAsCloneOf(p1)
            return True
        else:
            g.es('body text mismatch in relinked node',p1.h)
            return False
    else:
        if trace: g.trace('relink failed',gnx,root.h,unl)
        return False
#@+node:ekr.20150312225028.52: *7* vc.create_clone_links
def create_clone_links(self,at_clones,root):
    '''
    Recreate clone links from an @clones node.
    @clones nodes contain pairs of lines (gnx,unl)
    '''
    vc = self
    lines = g.splitLines(at_clones.b)
    gnxs = [s[4:].strip() for s in lines if s.startswith('gnx:')]
    unls = [s[4:].strip() for s in lines if s.startswith('unl:')]
    # g.trace('at_clones.b',at_clones.b)
    if len(gnxs) == len(unls):
        vc.headlines_dict = {} # May be out of date.
        ok = True
        for gnx,unl in zip(gnxs,unls):
            ok = ok and vc.create_clone_link(gnx,root,unl)
        return ok
    else:
        g.trace('bad @clones contents',gnxs,unls)
        return False
#@+node:ekr.20150312225028.53: *7* vc.create_organizer_nodes & helpers
def create_organizer_nodes(self,at_organizers,root):
    '''
    root is an @auto node. Create an organizer node in root's tree for each
    child @organizer: node of the given @organizers node.
    '''
    vc = self
    c = vc.c
    trace = False and not g.unitTesting
    t1 = time.clock()
    vc.pre_move_comments(root)
        # Merge comment nodes with the next node.
    t2 = time.clock()
    vc.precompute_all_data(at_organizers,root)
        # Init all data required for reading.
    t3 = time.clock()
    vc.demote(root)
        # Traverse root's tree, adding nodes to vc.work_list.
    t4 = time.clock()
    vc.move_nodes()
        # Move nodes on vc.work_list to their final locations.
    t5 = time.clock()
    vc.post_move_comments(root)
        # Move merged comments to parent organizer nodes.
    t6 = time.clock()
    if trace: g.trace(
        '\n  pre_move_comments:   %4.2f sec' % (t2-t1),
        '\n  precompute_all_data: %4.2f sec' % (t3-t2),
        '\n  demote:              %4.2f sec' % (t4-t3),
        '\n  move_nodes:          %4.2f sec' % (t5-t4),
        '\n  post_move_comments:  %4.2f sec' % (t6-t5))
#@+node:ekr.20150312225028.54: *7* vc.update_headlines_after_read
def update_headlines_after_read(self,root):
    '''Handle custom headlines for all imported nodes.'''
    trace = False and not g.unitTesting
    vc = self
    # Remember the original imported headlines.
    ivar = vc.headline_ivar
    for p in root.subtree():
        if not hasattr(p.v,ivar):
            setattr(p.v,ivar,p.h)
    # Update headlines from @headlines nodes.
    at_headlines = vc.has_at_headlines_node(root)
    tag1,tag2 = 'imported unl: ','head: '
    n1,n2 = len(tag1),len(tag2)
    if at_headlines:
        lines = g.splitLines(at_headlines.b)
        unls  = [s[n1:].strip() for s in lines if s.startswith(tag1)]
        heads = [s[n2:].strip() for s in lines if s.startswith(tag2)]
    else:
        unls,heads = [],[]
    if len(unls) == len(heads):
        vc.headlines_dict = {} # May be out of date.
        for unl,head in zip(unls,heads):
            p = vc.find_position_for_relative_unl(root,unl)
            if p:
                if trace: g.trace('unl:',unl,p.h,'==>',head)
                p.h = head
    else:
        g.trace('bad @headlines body',at_headlines.b)
#@+node:ekr.20150312225028.55: *5* vc.Main Lines
#@+node:ekr.20150312225028.56: *6* vc.precompute_all_data & helpers
def precompute_all_data(self,at_organizers,root):
    '''Precompute all data needed to reorganize nodes.'''
    trace = False and not g.unitTesting
    vc = self
    t1 = time.clock() 
    vc.find_imported_organizer_nodes(root)
        # Put all nodes with children on vc.imported_organizer_node_list
    t2 = time.clock()
    vc.create_organizer_data(at_organizers,root)
        # Create OrganizerData objects for all @organizer:
        # and @existing-organizer: nodes.
    t3 = time.clock()
    vc.create_actual_organizer_nodes()
        # Create the organizer nodes in holding cells so positions remain valid.
    t4 = time.clock()
    vc.create_tree_structure(root)
        # Set od.parent_od, od.children & od.descendants for all ods.
    t5 = time.clock()
    vc.compute_all_organized_positions(root)
        # Compute the positions organized by each organizer.
        # ** Most of the time is spent here **.
    t6 = time.clock()
    vc.create_anchors_d()
        # Create the dictionary that associates positions with ods.
    t7 = time.clock()
    if trace: g.trace(
        '\n  find_imported_organizer_nodes:   %4.2f sec' % (t2-t1),
        '\n  create_organizer_data:           %4.2f sec' % (t3-t2),
        '\n  create_actual_organizer_nodes:   %4.2f sec' % (t4-t3),
        '\n  create_tree_structure:           %4.2f sec' % (t5-t4),
        '\n  compute_all_organized_positions: %4.2f sec' % (t6-t5),
        '\n  create_anchors_d:                %4.2f sec' % (t7-t6))
#@+node:ekr.20150312225028.57: *7* 1: vc.find_imported_organizer_nodes
def find_imported_organizer_nodes(self,root):
    '''
    Put the VNode of all imported nodes with children on
    vc.imported_organizers_list.
    '''
    trace = False # and not g.unitTesting
    vc = self
    aList = []
    for p in root.subtree():
        if p.hasChildren():
            aList.append(p.v)
    vc.imported_organizers_list = list(set(aList))
    if trace: g.trace([z.h for z in vc.imported_organizers_list])
#@+node:ekr.20150312225028.58: *7* 2: vc.create_organizer_data (od.p & od.parent)
def create_organizer_data(self,at_organizers,root):
    '''
    Create OrganizerData nodes for all @organizer: and @existing-organizer:
    nodes in the given @organizers node.
    '''
    vc = self
    vc.create_ods(at_organizers)
    vc.finish_create_organizers(root)
    vc.finish_create_existing_organizers(root)
    for od in vc.all_ods:
        assert od.parent,(od.exists,od.h)
#@+node:ekr.20150312225028.59: *8* vc.create_ods
def create_ods(self,at_organizers):
    '''Create all organizer nodes and the associated lists.'''
    # Important: we must completely reinit all data here.
    vc = self
    tag1 = '@organizer:'
    tag2 = '@existing-organizer:'
    vc.all_ods,vc.existing_ods,vc.organizer_ods = [],[],[]
    for at_organizer in at_organizers.children():
        h = at_organizer.h
        for tag in (tag1,tag2):
            if h.startswith(tag):
                unls = vc.get_at_organizer_unls(at_organizer)
                if unls:
                    organizer_unl = vc.drop_unl_tail(unls[0])
                    h = h[len(tag):].strip()
                    od = OrganizerData(h,organizer_unl,unls)
                    vc.all_ods.append(od)
                    if tag == tag1:
                        vc.organizer_ods.append(od)
                        vc.organizer_unls.append(organizer_unl)
                    else:
                        vc.existing_ods.append(od)
                        # Do *not* append organizer_unl to the unl list.
                else:
                    g.trace('===== no unls:',at_organizer.h)
#@+node:ekr.20150312225028.60: *8* vc.finish_create_organizers
def finish_create_organizers(self,root):
    '''Finish creating all organizers.'''
    trace = False # and not g.unitTesting
    vc = self
    # Careful: we may delete items from this list.
    for od in vc.organizer_ods[:]: 
        od.source_unl = vc.source_unl(vc.organizer_unls,od.unl)
        od.parent = vc.find_position_for_relative_unl(root,od.source_unl)
        if od.parent:
            od.anchor = od.parent
            if trace: g.trace(od.h,
                # '\n  exists:',od.exists,
                # '\n  unl:',od.unl,
                # '\n  source (unl):',od.source_unl or repr(''),
                # '\n  anchor (pos):',od.anchor.h,
                # '\n  parent (pos):',od.parent.h,
            )
        else:
            # This is, most likely, a true error.
            g.trace('===== removing od:',od.h)
            vc.organizer_ods.remove(od)
            vc.all_ods.remove(od)
            assert od not in vc.existing_ods
            assert od not in vc.all_ods
#@+node:ekr.20150312225028.61: *8* vc.finish_create_existing_organizers
def finish_create_existing_organizers(self,root):
    '''Finish creating existing organizer nodes.'''
    trace = False # and not g.unitTesting
    vc = self
    # Careful: we may delete items from this list.
    for od in vc.existing_ods[:]:
        od.exists = True
        assert od.unl not in vc.organizer_unls
        od.source_unl = vc.source_unl(vc.organizer_unls,od.unl)
        od.p = vc.find_position_for_relative_unl(root,od.source_unl)
        if od.p:
            od.anchor = od.p
            assert od.p.h == od.h,(od.p.h,od.h)  
            od.parent = od.p # Here, od.parent represents the "source" p.
            if trace: g.trace(od.h,
                # '\n  exists:',od.exists,
                # '\n  unl:',od.unl,
                # '\n  source (unl):',od.source_unl or repr(''),
                # '\n  anchor (pos):',od.anchor.h,
                # '\n  parent (pos):',od.parent.h,
            )
        else:
            # This arises when the imported node name doesn't match.
            g.trace('===== removing existing organizer:',od.h)
            vc.existing_ods.remove(od)
            vc.all_ods.remove(od)
            assert od not in vc.existing_ods
            assert od not in vc.all_ods

#@+node:ekr.20150312225028.62: *7* 3: vc.create_actual_organizer_nodes
def create_actual_organizer_nodes(self):
    '''
    Create all organizer nodes as children of holding cells. These holding
    cells ensure that moving an organizer node leaves all other positions
    unchanged.
    '''
    vc = self
    c = vc.c
    last = c.lastTopLevel()
    temp = vc.temp_node = last.insertAfter()
    temp.h = 'ViewController.temp_node'
    for od in vc.organizer_ods:
        holding_cell = temp.insertAsLastChild()
        holding_cell.h = 'holding cell for ' + od.h
        od.p = holding_cell.insertAsLastChild()
        od.p.h = od.h
#@+node:ekr.20150312225028.63: *7* 4: vc.create_tree_structure & helper
def create_tree_structure(self,root):
    '''Set od.parent_od, od.children & od.descendants for all ods.'''
    trace = False and not g.unitTesting
    vc = self
    # if trace: g.trace([z.h for z in data_list],g.callers())
    organizer_unls = [z.unl for z in vc.all_ods]
    for od in vc.all_ods:
        for unl in od.unls:
            if unl in organizer_unls:
                i = organizer_unls.index(unl)
                d2 = vc.all_ods[i]
                # if trace: g.trace('found organizer unl:',od.h,'==>',d2.h)
                od.children.append(d2)
                d2.parent_od = od
    # create_organizer_data now ensures od.parent is set.
    for od in vc.all_ods:
        assert od.parent,od.h
    # Extend the descendant lists.
    for od in vc.all_ods:
        vc.compute_descendants(od)
        assert od.descendants is not None
    if trace:
        def tail(head,unl):
            return str(unl[len(head):]) if unl.startswith(head) else str(unl)
        for od in vc.all_ods:
            g.trace(
                '\n  od:',od.h,
                '\n  unl:',od.unl,
                '\n  unls:', [tail(od.unl,z) for z in od.unls],
                '\n  source (unl):',od.source_unl or repr(''),
                '\n  parent (pos):', od.parent.h,
                '\n  children:',[z.h for z in od.children],
                '\n  descendants:',[str(z.h) for z in od.descendants])
#@+node:ekr.20150312225028.64: *8* vc.compute_descendants
def compute_descendants(self,od,level=0,result=None):
    '''Compute the descendant od nodes of od.'''
    trace = False # and not g.unitTesting
    vc = self
    if level == 0:
        result = []
    if od.descendants is None:
        for child in od.children:
            result.append(child)
            result.extend(vc.compute_descendants(child,level+1,result))
            result = list(set(result))
        if level == 0:
            od.descendants = result
            if trace: g.trace(od.h,[z.h for z in result])
        return result
    else:
        if trace: g.trace('cached',od.h,[z.h for z in od.descendants])
        return od.descendants
#@+node:ekr.20150312225028.65: *7* 5: vc.compute_all_organized_positions
def compute_all_organized_positions(self,root):
    '''Compute the list of positions organized by every od.'''
    trace = False and not g.unitTesting
    vc = self
    for od in vc.all_ods:
        if od.unls:
            # Do a full search only for the first unl.
            # parent = vc.find_position_for_relative_unl(root,od.unls[0])
            if True: # parent:
                for unl in od.unls:
                    p = vc.find_position_for_relative_unl(root,unl)
                    # p = vc.find_position_for_relative_unl(parent,vc.unl_tail(unl))
                    if p:
                        od.organized_nodes.append(p.copy())
                    if trace: g.trace('exists:',od.exists,
                        'od:',od.h,'unl:',unl,
                        'p:',p and p.h or '===== None')
            else:
                g.trace('fail',od.unls[0])
#@+node:ekr.20150312225028.66: *7* 6: vc.create_anchors_d
def create_anchors_d (self):
    '''
    Create vc.anchors_d.
    Keys are positions, values are lists of ods having that anchor.
    '''
    trace = False # and not g.unitTesting
    vc = self
    d = {}
    if trace: g.trace('all_ods',[z.h for z in vc.all_ods])
    for od in vc.all_ods:
        # Compute the anchor if it does not yet exists.
        # Valid now that p.__hash__ exists.
        key = od.anchor
        # key = '.'.join([str(z) for z in od.anchor.sort_key(od.anchor)])
        # key = '%s (%s)' % (key,od.anchor.h)
        aList = d.get(key,[])
        # g.trace(od.h,od.anchor.h,key,aList)
        aList.append(od)
        d[key] = aList
    if trace:
        for key in sorted(d.keys()):
            g.trace('od.anchor: %s ods: [%s]' % (key.h,','.join(z.h for z in d.get(key))))
    vc.anchors_d = d
#@+node:ekr.20150312225028.67: *6* vc.demote & helpers
def demote(self,root):
    '''
    The main line of the @auto-view algorithm. Traverse root's entire tree,
    placing items on the global work list.
    '''
    trace = False # and not g.unitTesting
    trace_loop = True
    vc = self
    active = None # The active od.
    vc.pending = [] # Lists of pending demotions.
    d = vc.anchor_offset_d # For traces.
    for p in root.subtree():
        parent = p.parent()
        if trace and trace_loop:
            if 1:
                g.trace('-----',p.childIndex(),p.h)
            else:
                g.trace(
                    '=====\np:',p.h,
                    'childIndex',p.childIndex(),
                    '\nparent:',parent.h,
                    'parent:offset',d.get(parent,0))
        vc.n_nodes_scanned += 1
        vc.terminate_organizers(active,parent)
        found = vc.find_organizer(parent,p)
        if found:
            pass # vc.enter_organizers(found,p)
        else:
            pass # vc.terminate_all_open_organizers()
        if trace and trace_loop:
            g.trace(
                'active:',active and active.h or 'None',
                'found:',found and found.h or 'None')
        # The main case statement...
        if found is None and active:
            vc.add_to_pending(active,p)
        elif found is None and not active:
            # Pending nodes will *not* be organized.
            vc.clear_pending(None,p)
        elif found and found == active:
            # Pending nodes *will* be organized.
            for z in vc.pending:
                active2,child2 = z
                vc.add(active2,child2,'found==active:pending')
            vc.pending = []
            vc.add(active,p,'found==active')
        elif found and found != active:
            # Pending nodes will *not* be organized.
            vc.clear_pending(found,p)
            active = found
            vc.enter_organizers(found,p)
            vc.add(active,p,'found!=active')
        else: assert False,'can not happen'
#@+node:ekr.20150312225028.68: *7* vc.add
def add(self,active,p,tag):
    '''
    Add p, an existing (imported) node to the global work list.
    Subtract 1 from the vc.anchor_offset_d entry for p.parent().
    
    Exception: do *nothing* if p is a child of an existing organizer node.
    '''
    trace = False # and not g.unitTesting
    verbose = False
    vc = self
    # g.trace(active,g.callers())
    if active.p == p.parent() and active.exists:
        if trace and verbose: g.trace('===== do nothing',active.h,p.h)
    else:
        data = active.p,p.copy()
        vc.add_to_work_list(data,tag)
        vc.anchor_decr(anchor=p.parent(),p=p)
        
#@+node:ekr.20150312225028.69: *7* vc.add_organizer_node
def add_organizer_node (self,od,p):
    '''
    Add od to the appropriate move list.
    p is the existing node that caused od to be added.
    '''
    trace = True # and not g.unitTesting
    verbose = False
    vc = self
    # g.trace(od.h,'parent',od.parent_od and od.parent_od.h or 'None')
    if od.parent_od:
        # Not a bare organizer: a child of another organizer node.
        # If this is an existing organizer, it's *position* may have
        # been moved without active.moved being set.
        data = od.parent_od.p,od.p
        if data in vc.work_list:
            if trace and verbose: g.trace(
                '**** duplicate 1: setting moved bit.',od.h)
            od.moved = True
        elif od.parent_od.exists:    
            anchor = od.parent_od.p
            n = vc.anchor_incr(anchor,p) + p.childIndex()
            data = anchor,od.p,n
            # g.trace('anchor:',anchor.h,'p:',p.h,'childIndex',p.childIndex())
            vc.add_to_bare_list(data,'non-bare existing')
        else:
            vc.add_to_work_list(data,'non-bare')
    elif od.p == od.anchor:
        if trace and verbose: g.trace(
            '***** existing organizer: do not move:',od.h)
    else:
        # This can be pre-computed?
        bare_list = [p for parent,p,n in vc.global_bare_organizer_node_list]
        if od.p in bare_list:
            if trace and verbose: g.trace(
                '**** duplicate 2: setting moved bit.',od.h)
            od.moved = True
        else:
            # A bare organizer node: a child of an *ordinary* node.
            anchor = p.parent()
            n = vc.anchor_incr(anchor,p) + p.childIndex()
            data = anchor,od.p,n
            vc.add_to_bare_list(data,'bare')
#@+node:ekr.20150312225028.70: *7* vc.add_to_bare_list
def add_to_bare_list(self,data,tag):
    '''Add data to the bare organizer list, with tracing.'''
    trace = False # and not g.unitTesting
    vc = self
    # Prevent duplicagtes.
    anchor,p,n = data
    for data2 in vc.global_bare_organizer_node_list:
        a2,p2,n2 = data2
        if p == p2:
            if trace: g.trace('ignore duplicate',
                'n:',n,anchor.h,'==>',p.h)
            return
    vc.global_bare_organizer_node_list.append(data)
    if trace:
        anchor,p,n = data
        g.trace('=====',tag,'n:',n,anchor.h,'==>',p.h)
            # '\n  anchor:',anchor.h,
            # '\n  p:',p.h)
#@+node:ekr.20150312225028.71: *7* vc.add_to_pending
def add_to_pending(self,active,p):
    trace = False # and not g.unitTesting
    vc = self
    if trace: g.trace(active.p.h,'==>',p.h)
    vc.pending.append((active,p.copy()),)
#@+node:ekr.20150312225028.72: *7* vc.add_to_work_list
def add_to_work_list(self,data,tag):
    '''Append the data to the work list, with tracing.'''
    trace = False # and not g.unitTesting
    vc = self
    vc.work_list.append(data)
    if trace:
        active,p = data
        g.trace('=====',tag,active.h,'==>',p.h)
#@+node:ekr.20150312225028.73: *7* vc.anchor_decr
def anchor_decr(self,anchor,p): # p is only for traces.
    '''
    Decrement the anchor dict for the given anchor node.
    Return the *previous* value.
    '''
    trace = False # and not g.unitTesting
    vc = self
    d = vc.anchor_offset_d
    n = d.get(anchor,0)
    d[anchor] = n - 1
    if trace: g.trace(n-1,anchor.h,'==>',p.h)
    return n
#@+node:ekr.20150312225028.74: *7* vc.anchor_incr
def anchor_incr(self,anchor,p): # p is only for traces.
    '''
    Increment the anchor dict for the given anchor node.
    Return the *previous* value.
    '''
    trace = False # and not g.unitTesting
    vc = self
    d = vc.anchor_offset_d
    n = d.get(anchor,0)
    d[anchor] = n + 1
    if trace: g.trace(n+1,anchor.h,'==>',p.h)
    return n
#@+node:ekr.20150312225028.75: *7* vc.clear_pending
def clear_pending(self,active,p):
    '''Clear the appropriate entries from the pending list.'''
    trace = False # and not g.unitTesting
    vc = self
    if trace: g.trace('===== clear pending',len(vc.pending))
    if False: # active and active.parent_od:
        for data in vc.pending:
            data = active.parent_od.p,data[1]
            vc.add_to_work_list(data,'clear-pending-to-active')
    vc.pending = []
#@+node:ekr.20150312225028.76: *7* vc.enter_organizers
def enter_organizers(self,od,p):
    '''Enter all organizers whose anchors are p.'''
    vc = self
    ods = []
    while od:
        ods.append(od)
        od = od.parent_od
    if ods:
        for od in reversed(ods):
            vc.add_organizer_node(od,p)
#@+node:ekr.20150312225028.77: *7* vc.find_organizer
def find_organizer(self,parent,p):
    '''Return the organizer that organizers p, if any.'''
    trace = False # and not g.unitTesting
    vc = self
    anchor = parent
    ods = vc.anchors_d.get(anchor,[])
    for od in ods:
        if p in od.organized_nodes:
            if trace: g.trace('found:',od.h,'for',p.h)
            return od
    return None
#@+node:ekr.20150312225028.78: *7* vc.terminate_organizers
def terminate_organizers(self,active,p):
    '''Terminate all organizers whose anchors are not ancestors of p.'''
    trace = False # and not g.unitTesting
    od = active
    while od and od.anchor != p and od.anchor.isAncestorOf(p):
        if not od.closed:
            if trace: g.trace('===== closing',od.h)
            od.closed = True
        od = od.parent_od
#@+node:ekr.20150312225028.79: *7* vc.terminate_all_open_organizers
def terminate_all_open_organizers(self):
    '''Terminate all open organizers.'''
    trace = True # and not g.unitTesting
    if 0:
        g.trace()
        for od in self.all_ods:
            if od.opened and not od.closed:
                if trace: g.trace('===== closing',od.h)
                od.closed = True
#@+node:ekr.20150312225028.80: *6* vc.move_nodes & helpers
def move_nodes(self):
    '''Move nodes to their final location and delete the temp node.'''
    trace = False # and not g.unitTesting
    vc = self
    vc.move_nodes_to_organizers(trace)
    vc.move_bare_organizers(trace)
    vc.temp_node.doDelete()
#@+node:ekr.20150312225028.81: *7* vc.move_nodes_to_organizers
def move_nodes_to_organizers(self,trace):
    '''Move all nodes in the work_list.'''
    trace = False # and not g.unitTesting
    trace_dict = False
    trace_moves = False
    trace_deletes = False
    vc = self
    if trace: # A highly useful trace!
        g.trace('\n\nunsorted_list...\n%s' % (
            '\n'.join(['%40s ==> %s' % (parent.h,p.h)
                for parent,p in vc.work_list])))
    # Create a dictionary of each organizers children.
    d = {}
    for parent,p in vc.work_list:
        # This key must remain stable if parent moves.
        key = parent
        aList = d.get(key,[])
        aList.append(p)
        # g.trace(key,[z.h for z in aList])
        d[key] = aList
    if trace and trace_dict:
        # g.trace('d...',sorted([z.h for z in d.keys()]))
        g.trace('d{}...')
        for key in sorted(d.keys()):
            aList = [z.h for z in d.get(key)]
            g.trace('%s %-20s %s' % (id(key),key.h,vc.dump_list(aList,indent=29)))
    # Move *copies* of non-organizer nodes to each organizer.
    organizers = list(d.keys())
    existing_organizers = [z.p.copy() for z in vc.existing_ods]
    moved_existing_organizers = {} # Keys are vnodes, values are positions.
    for parent in organizers:
        aList = d.get(parent,[])
        if trace and trace_moves:
            g.trace('===== moving/copying:',parent.h,
                'with %s children:' % (len(aList)),
                '\n  '+'\n  '.join([z.h for z in aList]))
        for p in aList:
            if p in existing_organizers:
                if trace and trace_moves:
                    g.trace('copying existing organizer:',p.h)
                    g.trace('children:',
                    '\n  '+'\n  '.join([z.h for z in p.children()]))
                copy = vc.copy_tree_to_last_child_of(p,parent)
                old = moved_existing_organizers.get(p.v)
                if old and trace_moves:
                    g.trace('*********** overwrite',p.h)
                moved_existing_organizers[p.v] = copy
            elif p in organizers:
                if trace and trace_moves:
                    g.trace('moving organizer:',p.h)
                aList = d.get(p)
                if aList:
                    if trace and trace_moves: g.trace('**** relocating',
                        p.h,'children:',
                        '\n  '+'\n  '.join([z.h for z in p.children()]))
                    del d[p]
                p.moveToLastChildOf(parent)
                if aList:
                    d[p] = aList
            else:
                parent2 = moved_existing_organizers.get(parent.v)
                if parent2:
                    if trace and trace_moves:
                        g.trace('***** copying to relocated parent:',p.h)
                    vc.copy_tree_to_last_child_of(p,parent2)
                else:
                    if trace and trace_moves: g.trace('copying:',p.h)
                    vc.copy_tree_to_last_child_of(p,parent)
    # Finally, delete all the non-organizer nodes, in reverse outline order.
    def sort_key(od):
        parent,p = od
        return p.sort_key(p)
    sorted_list = sorted(vc.work_list,key=sort_key)
    if trace and trace_deletes:
        g.trace('===== deleting nodes in reverse outline order...')
    for parent,p in reversed(sorted_list):
        if p.v in moved_existing_organizers:
            if trace and trace_deletes:
                g.trace('deleting moved existing organizer:',p.h)
            p.doDelete()
        elif p not in organizers:
            if trace and trace_deletes:
                g.trace('deleting non-organizer:',p.h)
            p.doDelete()
#@+node:ekr.20150312225028.82: *7* vc.move_bare_organizers
def move_bare_organizers(self,trace):
    '''Move all nodes in global_bare_organizer_node_list.'''
    trace = False # and not g.unitTesting
    trace_data = True
    trace_move = True
    vc = self
    # For each parent, sort nodes on n.
    d = {} # Keys are vnodes, values are lists of tuples (n,parent,p)
    existing_organizers = [od.p for od in vc.existing_ods]
    if trace: g.trace('ignoring existing organizers:',
        [p.h for p in existing_organizers])
    for parent,p,n in vc.global_bare_organizer_node_list:
        if p not in existing_organizers:
            key = parent.v
            aList = d.get(key,[])
            if (parent,p,n) not in aList:
                aList.append((parent,p,n),)
                d[key] = aList
    # For each parent, add nodes in childIndex order.
    def key_func(obj):
        return obj[0]
    for key in d.keys():
        aList = d.get(key)
        for data in sorted(aList,key=key_func):
            parent,p,n = data
            n2 = parent.numberOfChildren()
            if trace and trace_data:
                g.trace(n,parent.h,'==>',p.h)
            if trace and trace_move: g.trace(
                'move: %-20s:' % (p.h),
                'to child: %2s' % (n),
                'of: %-20s' % (parent.h),
                'with:',n2,'children')
            p.moveToNthChildOf(parent,n)
#@+node:ekr.20150312225028.83: *7* vc.copy_tree_to_last_child_of
def copy_tree_to_last_child_of(self,p,parent):
    '''Copy p's tree to the last child of parent.'''
    vc = self
    assert p != parent,p
        # A failed assert leads to unbounded recursion.
    # print('copy_tree_to_last_child_of',p.h,parent.h)
    root = parent.insertAsLastChild()
    root.b,root.h = p.b,p.h
    root.v.u = copy.deepcopy(p.v.u)
    for child in p.children():
        vc.copy_tree_to_last_child_of(child,root)
    return root
#@+node:ekr.20150312225028.84: *5* vc.Helpers
#@+node:ekr.20150312225028.85: *6* vc.at_auto_view_body and match_at_auto_body
def at_auto_view_body(self,p):
    '''Return the body text for the @auto-view node for p.'''
    # Note: the unl of p relative to p is simply p.h,
    # so it is pointless to add that to the @auto-view node.
    return 'gnx: %s\n' % p.v.gnx

def match_at_auto_body(self,p,auto_view):
    '''Return True if any line of auto_view.b matches the expected gnx line.'''
    if 0: g.trace(p.b == 'gnx: %s\n' % auto_view.v.gnx,
        g.shortFileName(p.h),auto_view.v.gnx,p.b.strip())
    return p.b == 'gnx: %s\n' % auto_view.v.gnx
#@+node:ekr.20150312225028.86: *6* vc.clean_nodes (not used)
def clean_nodes(self):
    '''Delete @auto-view nodes with no corresponding @auto nodes.'''
    vc = self
    c = vc.c
    views = vc.has_at_views_node()
    if not views:
        return
    # Remember the gnx of all @auto nodes.
    d = {}
    for p in c.all_unique_positions():
        if vc.is_at_auto_node(p):
            d[p.v.gnx] = True
    # Remember all unused @auto-view nodes.
    delete = []
    for child in views.children():
        s = child.b and g.splitlines(child.b)
        gnx = s[len('gnx'):].strip()
        if gnx not in d:
            g.trace(child.h,gnx)
            delete.append(child.copy())
    for p in reversed(delete):
        p.doDelete()
    c.selectPosition(views)
#@+node:ekr.20150312225028.87: *6* vc.comments...
#@+node:ekr.20150312225028.88: *7* vc.comment_delims
def comment_delims(self,p):
    '''Return the comment delimiter in effect at p, an @auto node.'''
    vc = self
    c = vc.c
    d = g.get_directives_dict(p)
    s = d.get('language') or c.target_language
    language,single,start,end = g.set_language(s,0)
    return single,start,end
#@+node:ekr.20150312225028.89: *7* vc.delete_leading_comments
def delete_leading_comments(self,delims,p):
    '''
    Scan for leading comments from p and return them.
    At present, this only works for single-line comments.
    '''
    single,start,end = delims
    if single:
        lines = g.splitLines(p.b)
        result = []
        for s in lines:
            if s.strip().startswith(single):
                result.append(s)
            else: break
        if result:
            p.b = ''.join(lines[len(result):])
            # g.trace('len(result)',len(result),p.h)
            return ''.join(result)
    return None
#@+node:ekr.20150312225028.90: *7* vc.is_comment_node
def is_comment_node(self,p,root,delims=None):
    '''Return True if p.b contains nothing but comments or blank lines.'''
    vc = self
    if not delims:
        delims = vc.comment_delims(root)
    # pylint: disable=unpacking-non-sequence
    single,start,end = delims
    assert single or start and end,'bad delims: %r %r %r' % (single,start,end)
    if single:
        for s in g.splitLines(p.b):
            s = s.strip()
            if s and not s.startswith(single) and not g.isDirective(s):
                return False
        return True
    else:
        def check_comment(s):
            done,in_comment = False,True
            i = s.find(end)
            if i > -1:
                tail = s[i+len(end):].strip()
                if tail: done = True
                else: in_comment = False
            return done,in_comment
        
        done,in_comment = False,False
        for s in g.splitLines(p.b):
            s = s.strip()
            if not s:
                pass
            elif in_comment:
                done,in_comment = check_comment(s)
            elif g.isDirective(s):
                pass
            elif s.startswith(start):
                done,in_comment = check_comment(s[len(start):])
            else:
                # g.trace('fail 1: %r %r %r...\n%s' % (single,start,end,s)
                return False
            if done:
                return False
        # All lines pass.
        return True
#@+node:ekr.20150312225028.91: *7* vc.is_comment_organizer_node
# def is_comment_organizer_node(self,p,root):
    # '''
    # Return True if p is an organizer node in the given @auto tree.
    # '''
    # return p.hasChildren() and vc.is_comment_node(p,root)
#@+node:ekr.20150312225028.92: *7* vc.post_move_comments
def post_move_comments(self,root):
    '''Move comments from the start of nodes to their parent organizer node.'''
    vc = self
    c = vc.c
    delims = vc.comment_delims(root)
    for p in root.subtree():
        if p.hasChildren() and not p.b:
            s = vc.delete_leading_comments(delims,p.firstChild())
            if s:
                p.b = s
                # g.trace(p.h)
#@+node:ekr.20150312225028.93: *7* vc.pre_move_comments
def pre_move_comments(self,root):
    '''
    Move comments from comment nodes to the next node.
    This must be done before any other processing.
    '''
    vc = self
    c = vc.c
    delims = vc.comment_delims(root)
    aList = []
    for p in root.subtree():
        if p.hasNext() and vc.is_comment_node(p,root,delims=delims):
            aList.append(p.copy())
            next = p.next()
            if p.b: next.b = p.b + next.b
    # g.trace([z.h for z in aList])
    c.deletePositionsInList(aList)
        # This sets c.changed.
#@+node:ekr.20150312225028.94: *6* vc.find...
# The find commands create the node if not found.
#@+node:ekr.20150312225028.95: *7* vc.find_absolute_unl_node
def find_absolute_unl_node(self,unl,priority_header=False):
    '''Return a node matching the given absolute unl.
    If priority_header == True and the node is not found, it will return the longest matching UNL starting from the tail
    '''
    import re
    pos_pattern = re.compile(r':(\d+),?(\d+)?$')
    vc = self
    aList = unl.split('-->')
    if aList:
        first,rest = aList[0],'-->'.join(aList[1:])
        count = 0
        pos = re.findall(pos_pattern,first)
        nth_sib,pos = pos[0] if pos else (0,0)
        pos = int(pos) if pos else 0
        nth_sib = int(nth_sib)
        first = re.sub(pos_pattern,"",first).replace('--%3E','-->')
        for parent in vc.c.rootPosition().self_and_siblings():
            if parent.h.strip() == first.strip():
                if pos == count:
                    if rest:
                        return vc.find_position_for_relative_unl(parent,rest,priority_header=priority_header)
                    else:
                        return parent
                count = count+1
        #Here we could find and return the nth_sib if an exact header match was not found
    return None
#@+node:ekr.20150312225028.96: *7* vc.find_at_auto_view_node & helper
def find_at_auto_view_node (self,root):
    '''
    Return the @auto-view node for root, an @auto node.
    Create the node if it does not exist.
    '''
    vc = self
    views = vc.find_at_views_node()
    p = vc.has_at_auto_view_node(root)
    if not p:
        p = views.insertAsLastChild()
        p.h = '@auto-view:' + root.h[len('@auto'):].strip()
        p.b = vc.at_auto_view_body(root)
    return p
#@+node:ekr.20150312225028.97: *7* vc.find_clones_node
def find_at_clones_node(self,root):
    '''
    Find the @clones node for root, an @auto node.
    Create the @clones node if it does not exist.
    '''
    vc = self
    c = vc.c
    h = '@clones'
    auto_view = vc.find_at_auto_view_node(root)
    p = g.findNodeInTree(c,auto_view,h)
    if not p:
        p = auto_view.insertAsLastChild()
        p.h = h
    return p
#@+node:ekr.20150312225028.98: *7* vc.find_at_headlines_node
def find_at_headlines_node(self,root):
    '''
    Find the @headlines node for root, an @auto node.
    Create the @headlines node if it does not exist.
    '''
    vc = self
    c = vc.c
    h = '@headlines'
    auto_view = vc.find_at_auto_view_node(root)
    p = g.findNodeInTree(c,auto_view,h)
    if not p:
        p = auto_view.insertAsLastChild()
        p.h = h
    return p
#@+node:ekr.20150312225028.99: *7* vc.find_gnx_node
def find_gnx_node(self,gnx):
    '''Return the first position having the given gnx.'''
    # This is part of the read logic, so newly-imported
    # nodes will never have the given gnx.
    vc = self
    for p in vc.c.all_unique_positions():
        if p.v.gnx == gnx:
            return p
    return None
#@+node:ekr.20150312225028.100: *7* vc.find_organizers_node
def find_at_organizers_node(self,root):
    '''
    Find the @organizers node for root, and @auto node.
    Create the @organizers node if it doesn't exist.
    '''
    vc = self
    c = vc.c
    h = '@organizers'
    auto_view = vc.find_at_auto_view_node(root)
    p = g.findNodeInTree(c,auto_view,h)
    if not p:
        p = auto_view.insertAsLastChild()
        p.h = h
    return p
#@+node:ekr.20150312225028.101: *7* vc.find_position_for_relative_unl
def find_position_for_relative_unl(self,parent,unl,priority_header=False):
    '''
    Return the node in parent's subtree matching the given unl.
    The unl is relative to the parent position.
    If priority_header == True and the node is not found, it will return the longest matching UNL starting from the tail
    '''
    # This is called from finish_create_organizers & compute_all_organized_positions.
    trace = False # and not g.unitTesting
    trace_loop = True
    trace_success = False
    vc = self
    if not unl:
        if trace and trace_success:
            g.trace('return parent for empty unl:',parent.h)
        return parent
    # The new, simpler way: drop components of the unl automatically.
    drop,p = [],parent # for debugging.
    # if trace: g.trace('p:',p.h,'unl:',unl)
    import re
    pos_pattern = re.compile(r':(\d+),?(\d+)?$')
    for s in unl.split('-->'):
        found = False # The last part must match.
        if 1:
            # Create the list of children on the fly.
            aList = vc.headlines_dict.get(p.v)
            if aList is None:
                aList = [z.h for z in p.children()]
                vc.headlines_dict[p.v] = aList
            try:
                pos = re.findall(pos_pattern,s)
                nth_sib,pos = pos[0] if pos else (0,0)
                pos = int(pos) if pos else 0
                nth_sib = int(nth_sib)
                s = re.sub(pos_pattern,"",s).replace('--%3E','-->')
                indices = [i for i, x in enumerate(aList) if x == s]
                if len(indices)>pos:
                    #First we try the nth node with same header
                    n = indices[pos]
                    p = p.nthChild(n)
                    found = True
                elif len(indices)>0:
                    #Then we try any node with same header
                    n = indices[-1]
                    p = p.nthChild(n)
                    found = True
                elif not priority_header:
                    #Then we go for the child index if return_pos is true
                    if len(aList)>nth_sib:
                        n = nth_sib
                    else:
                        n = len(aList)-1
                    if n>-1:
                        p = p.nthChild(n)
                    else:
                        g.es('Partial UNL match: Referenced level is higher than '+str(p.level()))
                    found = True
                if trace and trace_loop: g.trace('match:',s)
            except ValueError: # s not in aList.
                if trace and trace_loop: g.trace('drop:',s)
                drop.append(s)
        else: # old code.
            for child in p.children():
                if child.h == s:
                    p = child
                    found = True
                    if trace and trace_loop: g.trace('match:',s)
                    break
                # elif trace and trace_loop: g.trace('no match:',child.h)
            else:
                if trace and trace_loop: g.trace('drop:',s)
                drop.append(s)
    if not found and priority_header:
        aList = []
        for p in vc.c.all_unique_positions():
            if p.h.replace('--%3E','-->') in unl:
                aList.append((p.copy(),p.get_UNL(False,False,True)))
        unl_list = [re.sub(pos_pattern,"",x).replace('--%3E','-->') for x in unl.split('-->')]
        for iter_unl in aList:
            maxcount = 0
            count = 0
            compare_list = unl_list[:]
            for header in reversed(iter_unl[1].split('-->')):
                if re.sub(pos_pattern,"",header).replace('--%3E','-->') == compare_list[-1]:
                    count = count+1
                    compare_list.pop(-1)
                else:
                    break
            if count > maxcount:
                p = iter_unl[0]
                found = True
    if found:
        if trace and trace_success:
            g.trace('found unl:',unl,'parent:',p.h,'drop',drop)
    else:
        if trace: g.trace('===== unl not found:',unl,'parent:',p.h,'drop',drop)
    return p if found else None
#@+node:ekr.20150312225028.102: *7* vc.find_representative_node
def find_representative_node (self,root,target):
    '''
    root is an @auto node. target is a clones node within root's tree.
    Return a node *outside* of root's tree that is cloned to target,
    preferring nodes outside any @<file> tree.
    Never return any node in any @views or @view tree.
    '''
    trace = False and not g.unitTesting
    assert target
    assert root
    vc = self
    # Pass 1: accept only nodes outside any @file tree.
    p = vc.c.rootPosition()
    while p:
        if p.h.startswith('@view'):
            p.moveToNodeAfterTree()
        elif p.isAnyAtFileNode():
            p.moveToNodeAfterTree()
        elif p.v == target.v:
            if trace: g.trace('success 1:',p,p.parent())
            return p
        else:
            p.moveToThreadNext()
    # Pass 2: accept any node outside the root tree.
    p = vc.c.rootPosition()
    while p:
        if p.h.startswith('@view'):
            p.moveToNodeAfterTree()
        elif p == root:
            p.moveToNodeAfterTree()
        elif p.v == target.v:
            if trace: g.trace('success 2:',p,p.parent())
            return p
        else:
            p.moveToThreadNext()
    g.trace('no representative node for:',target,'parent:',target.parent())
    return None
#@+node:ekr.20150312225028.103: *7* vc.find_views_node
def find_at_views_node(self):
    '''
    Find the first @views node in the outline.
    If it does not exist, create it as the *last* top-level node,
    so that no existing positions become invalid.
    '''
    vc = self
    c = vc.c
    p = g.findNodeAnywhere(c,'@views')
    if not p:
        last = c.rootPosition()
        while last.hasNext():
            last.moveToNext()
        p = last.insertAfter()
        p.h = '@views'
        # c.selectPosition(p)
        # c.redraw()
    return p
#@+node:ekr.20150312225028.104: *6* vc.has...
# The has commands return None if the node does not exist.
#@+node:ekr.20150312225028.105: *7* vc.has_at_auto_view_node
def has_at_auto_view_node(self,root):
    '''
    Return the @auto-view node corresponding to root, an @root node.
    Return None if no such node exists.
    '''
    vc = self
    c = vc.c
    assert vc.is_at_auto_node(root) or vc.is_at_file_node(root),root
    views = g.findNodeAnywhere(c,'@views')
    if views:
        # Find a direct child of views with matching headline and body.
        for p in views.children():
            if vc.match_at_auto_body(p,root):
                return p
    return None
#@+node:ekr.20150312225028.106: *7* vc.has_clones_node
def has_at_clones_node(self,root):
    '''
    Find the @clones node for an @auto node with the given unl.
    Return None if it does not exist.
    '''
    vc = self
    p = vc.has_at_auto_view_node(root)
    return p and g.findNodeInTree(vc.c,p,'@clones')
#@+node:ekr.20150312225028.107: *7* vc.has_at_headlines_node
def has_at_headlines_node(self,root):
    '''
    Find the @clones node for an @auto node with the given unl.
    Return None if it does not exist.
    '''
    vc = self
    p = vc.has_at_auto_view_node(root)
    return p and g.findNodeInTree(vc.c,p,'@headlines')
#@+node:ekr.20150312225028.108: *7* vc.has_organizers_node
def has_at_organizers_node(self,root):
    '''
    Find the @organizers node for root, an @auto node.
    Return None if it does not exist.
    '''
    vc = self
    p = vc.has_at_auto_view_node(root)
    return p and g.findNodeInTree(vc.c,p,'@organizers')
#@+node:ekr.20150312225028.109: *7* vc.has_views_node
def has_at_views_node(self):
    '''Return the @views or None if it does not exist.'''
    vc = self
    return g.findNodeAnywhere(vc.c,'@views')
#@+node:ekr.20150312225028.110: *6* vc.is...
#@+node:ekr.20150312225028.111: *7* vc.is_at_auto_node
def is_at_auto_node(self,p):
    '''Return True if p is an @auto node.'''
    return g.match_word(p.h,0,'@auto') and not g.match(p.h,0,'@auto-')
        # Does not match @auto-rst, etc.

def is_at_file_node(self,p):
    '''Return True if p is an @file node.'''
    return g.match_word(p.h,0,'@file')
#@+node:ekr.20150312225028.112: *7* vc.is_cloned_outside_parent_tree
def is_cloned_outside_parent_tree(self,p):
    '''Return True if a clone of p exists outside the tree of p.parent().'''
    return len(list(set(p.v.parents))) > 1
#@+node:ekr.20150312225028.113: *7* vc.is_organizer_node
def is_organizer_node(self,p,root):
    '''
    Return True if p is an organizer node in the given @auto tree.
    '''
    vc = self
    return p.hasChildren() and vc.is_comment_node(p,root)

#@+node:ekr.20150312225028.114: *6* vc.testing...
#@+node:ekr.20150312225028.115: *7* vc.compare_test_trees
def compare_test_trees(self,root1,root2):
    '''
    Compare the subtrees whose roots are given.
    This is called only from unit tests.
    '''
    vc = self
    s1,s2 = vc.trial_write(root1),vc.trial_write(root2)
    if s1 == s2:
        return True
    g.trace('Compare:',root1.h,root2.h)
    p2 = root2.copy().moveToThreadNext()
    for p1 in root1.subtree():
        if p1.h == p2.h:
            g.trace('Match:',p1.h)
        else:
            g.trace('Fail: %s != %s' % (p1.h,p2.h))
            break
        p2.moveToThreadNext()
    return False
#@+node:ekr.20150312225028.116: *7* vc.compare_trial_writes
def compare_trial_writes(self,s1,s2):
    '''
    Compare the two strings, the results of trial writes.
    Stop the comparison after the first mismatch.
    '''
    trace_matches = False
    full_compare = False
    lines1,lines2 = g.splitLines(s1),g.splitLines(s2)
    i,n1,n2 = 0,len(lines1),len(lines2)
    while i < n1 and i < n2:
        s1,s2 = lines1[i].rstrip(),lines2[i].rstrip()
        i += 1
        if s1 == s2:
            if trace_matches: g.trace('Match:',s1)
        else:
            g.trace('Fail:  %s != %s' % (s1,s2))
            if not full_compare: return
    if i < n1:
        g.trace('Extra line 1:',lines1[i])
    if i < n2:
        g.trace('Extra line 2:',lines2[i])
#@+node:ekr.20150312225028.117: *7* vc.dump_list
def dump_list(self,aList,indent=4):
    '''Dump a list, one item per line.'''
    lead = '\n' + ' '*indent
    return lead+lead.join(sorted(aList))
#@+node:ekr.20150312225028.118: *7* vc.trial_write
def trial_write(self,root):
    '''
    Return a trial write of outline whose root is given.
    
    **Important**: the @auto import and write code end all nodes with
    newlines. Because no imported nodes are empty, the code below is
    *exactly* equivalent to the @auto write code as far as trailing
    newlines are concerned. Furthermore, we can treat Leo directives as
    ordinary text here.
    '''
    vc = self
    if 1:
        # Do a full trial write, exactly as will be done later.
        at = vc.c.atFileCommands
        ok = at.writeOneAtAutoNode(root,
            toString=True,force=True,trialWrite=True)
        if ok:
            return at.stringOutput
        else:
            g.trace('===== can not happen')
            return ''
    elif 1:
        # Concatenate all body text.  Close, but not exact.
        return ''.join([p.b for p in root.self_and_subtree()])
    else:
        # Compare headlines, ignoring nodes without body text and comment nodes.
        # This was handy during early development.
        return '\n'.join([p.h for p in root.self_and_subtree()
            if p.b and not p.h.startswith('#')])
#@+node:ekr.20150312225028.119: *6* vc.unls...
#@+node:ekr.20150312225028.120: *7* vc.drop_all_organizers_in_unl
def drop_all_organizers_in_unl(self,organizer_unls,unl):
    '''Drop all organizer unl's in unl, recreating the imported unl.'''
    vc = self
    def unl_sort_key(s):
        return s.count('-->')
    for s in reversed(sorted(organizer_unls,key=unl_sort_key)):
        if unl.startswith(s):
            s2 = vc.drop_unl_tail(s)
            unl = s2 + unl[len(s):]
    return unl[3:] if unl.startswith('-->') else unl
#@+node:ekr.20150312225028.121: *7* vc.drop_unl_tail & vc.drop_unl_parent
def drop_unl_tail(self,unl):
    '''Drop the last part of the unl.'''
    return '-->'.join(unl.split('-->')[:-1])

def drop_unl_parent(self,unl):
    '''Drop the penultimate part of the unl.'''
    aList = unl.split('-->')
    return '-->'.join(aList[:-2] + aList[-1:])
#@+node:ekr.20150312225028.122: *7* vc.get_at_organizer_unls
def get_at_organizer_unls(self,p):
    '''Return the unl: lines in an @organizer: node.'''
    return [s[len('unl:'):].strip()
        for s in g.splitLines(p.b)
            if s.startswith('unl:')]

#@+node:ekr.20150312225028.123: *7* vc.relative_unl & unl
def relative_unl(self,p,root):
    '''Return the unl of p relative to the root position.'''
    vc = self
    result = []
    ivar = vc.headline_ivar
    for p in p.self_and_parents():
        if p == root:
            break
        else:
            h = getattr(p.v,ivar,p.h)
            result.append(h)
    return '-->'.join(reversed(result))

def unl(self,p):
    '''Return the unl corresponding to the given position.'''
    vc = self
    return '-->'.join(reversed([
        getattr(p.v,vc.headline_ivar,p.h)
            for p in p.self_and_parents()]))
    # return '-->'.join(reversed([p.h for p in p.self_and_parents()]))
#@+node:ekr.20150312225028.124: *7* vc.source_unl
def source_unl(self,organizer_unls,organizer_unl):
    '''Return the unl of the source node for the given organizer_unl.'''
    vc = self
    return vc.drop_all_organizers_in_unl(organizer_unls,organizer_unl)
#@+node:ekr.20150312225028.125: *7* vc.unl_tail
def unl_tail(self,unl):
    '''Return the last part of a unl.'''
    return unl.split('-->')[:-1][0]
#@+node:ekr.20150312225028.126: *4* vc.Commands
@g.command('view-pack')
def view_pack_command(event):
    c = event.get('c')
    if c and c.viewController:
        c.viewController.pack()

@g.command('view-unpack')
def view_unpack_command(event):
    c = event.get('c')
    if c and c.viewController:
        c.viewController.unpack()
        
@g.command('at-file-to-at-auto')
def at_file_to_at_auto_command(event):
    c = event.get('c')
    if c and c.viewController:
        c.viewController.convert_at_file_to_at_auto(c.p)
#@+node:ekr.20140711111623.17795: *4* class ConvertController (leoPersistence.py)
class ConvertController(object):
    '''A class to convert @file trees to @auto trees.'''

    def __init__(self, c, p):
        self.c = c
        self.pd = c.persistenceController
        self.root = p.copy()
    @others
#@+node:ekr.20140711111623.17796: *5* convert.delete_at_data_nodes
def delete_at_data_nodes(self, root):
    '''Delete all @data nodes pertaining to root.'''
    cc = self
    pd = cc.pd
    while True:
        p = pd.has_at_data_node(root)
        if not p: break
        p.doDelete()
#@+node:ekr.20140711111623.17797: *5* convert.import_from_string
def import_from_string(self, s):
    '''Import from s into a temp outline.'''
    cc = self # (ConvertController)
    c = cc.c
    # ic = c.importCommands
    root = cc.root
    language = g.scanForAtLanguage(c, root)
    ext = '.' + g.app.language_extension_dict.get(language)
    scanner = g.app.scanner_for_ext(c, ext)
    # g.trace(language,ext,scanner.__name__)
    p = root.insertAfter()
    ok = scanner(atAuto=True, c=c, parent=p, s=s)
    p.h = root.h.replace('@file', '@auto' if ok else '@@auto')
    return ok, p
#@+node:ekr.20140711111623.17798: *5* convert.run
def run(self):
    '''Convert an @file tree to @auto tree.'''
    trace = True and not g.unitTesting
    trace_s = False
    cc = self
    c = cc.c
    root, pd = cc.root, c.persistenceController
    # set the expected imported headline for all vnodes.
    t1 = time.time()
    cc.set_expected_imported_headlines(root)
    t2 = time.time()
    # Delete all previous @data nodes for this tree.
    cc.delete_at_data_nodes(root)
    t3 = time.time()
    # Ensure that all nodes of the tree are regularized.
    ok = pd.prepass(root)
    t4 = time.time()
    if not ok:
        g.es_print('Can not convert', root.h, color='red')
        if trace: g.trace(
            '\n  set_expected_imported_headlines: %4.2f sec' % (t2 - t1),
            # '\n  delete_at_data_nodes:          %4.2f sec' % (t3-t2),
            '\n  prepass:                         %4.2f sec' % (t4 - t3),
            '\n  total:                           %4.2f sec' % (t4 - t1))
        return
    # Create the appropriate @data node.
    at_auto_view = pd.update_before_write_foreign_file(root)
    t5 = time.time()
    # Write the @file node as if it were an @auto node.
    s = cc.strip_sentinels()
    t6 = time.time()
    if trace and trace_s:
        g.trace('source file...\n', s)
    # Import the @auto string.
    ok, p = cc.import_from_string(s)
    t7 = time.time()
    if ok:
        # Change at_auto_view.b so it matches p.gnx.
        at_auto_view.b = pd.at_data_body(p)
        # Recreate the organizer nodes, headlines, etc.
        pd.update_after_read_foreign_file(p)
        t8 = time.time()
        # if not ok:
            # p.h = '@@' + p.h
            # g.trace('restoring original @auto file')
            # ok,p = cc.import_from_string(s)
            # if ok:
                # p.h = '@@' + p.h + ' (restored)'
                # if p.next():
                    # p.moveAfter(p.next())
        t9 = time.time()
    else:
        t8 = t9 = time.time()
    if trace: g.trace(
        '\n  set_expected_imported_headlines: %4.2f sec' % (t2 - t1),
        # '\n  delete_at_data_nodes:          %4.2f sec' % (t3-t2),
        '\n  prepass:                         %4.2f sec' % (t4 - t3),
        '\n  update_before_write_foreign_file:%4.2f sec' % (t5 - t4),
        '\n  strip_sentinels:                 %4.2f sec' % (t6 - t5),
        '\n  import_from_string:              %4.2f sec' % (t7 - t6),
        '\n  update_after_read_foreign_file   %4.2f sec' % (t8 - t7),
        '\n  import_from_string (restore)     %4.2f sec' % (t9 - t8),
        '\n  total:                           %4.2f sec' % (t9 - t1))
    if p:
        c.selectPosition(p)
    c.redraw()
#@+node:ekr.20140711111623.17799: *5* convert.set_expected_imported_headlines
def set_expected_imported_headlines(self, root):
    '''Set v._imported_headline for every vnode.'''
    trace = False and not g.unitTesting
    cc = self
    c = cc.c
    ic = cc.c.importCommands
    language = g.scanForAtLanguage(c, root)
    ext = '.' + g.app.language_extension_dict.get(language)
    aClass = g.app.classDispatchDict.get(ext)
    scanner = aClass(importCommands=ic, atAuto=True)
    # Duplicate the fn logic from ic.createOutline.
    theDir = g.setDefaultDirectory(c, root, importing=True)
    fn = c.os_path_finalize_join(theDir, root.h)
    fn = root.h.replace('\\', '/')
    junk, fn = g.os_path_split(fn)
    fn, junk = g.os_path_splitext(fn)
    if aClass and hasattr(scanner, 'headlineForNode'):
        for p in root.subtree():
            if not hasattr(p.v, '_imported_headline'):
                h = scanner.headlineForNode(fn, p)
                setattr(p.v, '_imported_headline', h)
                if trace and h != p.h:
                    g.trace('==>', h) # p.h,'==>',h
#@+node:ekr.20140711111623.17800: *5* convert.strip_sentinels
def strip_sentinels(self):
    '''Write the file to a string without headlines or sentinels.'''
    trace = False and not g.unitTesting
    cc = self
    at = cc.c.atFileCommands
    # ok = at.writeOneAtAutoNode(cc.root,
        # toString=True,force=True,trialWrite=True)
    at.errors = 0
    at.write(cc.root,
        kind='@file',
        nosentinels=True,
        perfectImportFlag=False,
        scriptWrite=False,
        thinFile=True,
        toString=True)
    ok = at.errors == 0
    s = at.stringOutput
    if trace: g.trace('ok:', ok, 's:...\n' + s)
    return s
#@+node:ekr.20140711111623.17794: *4* pd.convert_at_file_to_at_auto
def convert_at_file_to_at_auto(self, root):
    if root.isAtFileNode():
        ConvertController(self.c, root).run()
    else:
        g.es_print('not an @file node:', root.h)
#@+node:ekr.20140131101641.15495: *4* pd.prepass & helper
def prepass(self, root):
    '''Make sure root's tree has no hard-to-handle nodes.'''
    c, pd = self.c, self
    ic = c.importCommands
    ic.tab_width = c.getTabWidth(root)
    language = g.scanForAtLanguage(c, root)
    ext = g.app.language_extension_dict.get(language)
    if not ext: return
    if not ext.startswith('.'): ext = '.' + ext
    scanner = g.app.scanner_for_ext(c, ext)
    if not scanner:
        g.trace('no scanner for', root.h)
        return True # Pretend all went well.
    # Pass 1: determine the nodes to be inserted.
    ok = True
    # parts_list = []
    for p in root.subtree():
        ok2 = pd.regularize_node(p, scanner)
        ok = ok and ok2
    return ok
#@+node:ekr.20140131101641.15496: *5* pd.regularize_node
def regularize_node(self, p, scanner):
    '''Regularize node p so that it will not cause problems.'''
    c = self.c
    ok = scanner(atAuto=True, c=c, parent=p, s=p.b)
        # The scanner is a callback returned by g.app.scanner_for_ext.
        # It must have a c argument.
    if not ok:
        g.es_print('please regularize:', p.h)
    return ok
#@+node:ekr.20150312225028.6: *3* class LogManager (not used yet)
class LogManager:

    '''A class to handle the global log, and especially
    switching the log from commander to commander.'''

    def __init__ (self):

        trace = (False or g.trace_startup) and not g.unitTesting
        if trace: g.es_debug('(LogManager)')

        self.log = None             # The LeoFrame containing the present log.
        self.logInited = False      # False: all log message go to logWaiting list.
        self.logIsLocked = False    # True: no changes to log are allowed.
        self.logWaiting = []        # List of messages waiting to go to a log.
        self.printWaiting = []      # Queue of messages to be sent to the printer.
        self.signon_printed = False # True: the global signon has been printed.

    @others
#@+node:ekr.20150312225028.7: *4* LogM.setLog, lockLog, unlocklog
def setLog (self,log):

    """set the frame to which log messages will go"""

    # print("app.setLog:",log,g.callers())
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True

def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False
#@+node:ekr.20150312225028.8: *4* LogM.writeWaitingLog
def writeWaitingLog (self,c):
    '''Write all waiting lines to the log.'''
    trace = True
    lm = self
    if trace:
        # Do not call g.es, g.es_print, g.pr or g.trace here!
        print('** writeWaitingLog','silent',g.app.silentMode,c.shortFileName())
        # print('writeWaitingLog',g.callers())
        # import sys ; print('writeWaitingLog: argv',sys.argv)
    if not c or not c.exists:
        return
    if g.unitTesting:
        lm.printWaiting = []
        lm.logWaiting = []
        g.app.setLog(None) # Prepare to requeue for other commanders.
        return
    table = [
        ('Leo Log Window','red'),
        (g.app.signon,'black'),
        (g.app.signon2,'black'),
    ]
    table.reverse()
    c.setLog()
    lm.logInited = True # Prevent recursive call.
    if not lm.signon_printed:
        lm.signon_printed = True
        if not g.app.silentMode:
            print('')
            print('** isPython3: %s' % g.isPython3)
            if not g.enableDB:
                print('** caching disabled')
            print(g.app.signon)
            print(g.app.signon2)
    if not g.app.silentMode:
        for s in lm.printWaiting:
            print(s)
    lm.printWaiting = []
    if not g.app.silentMode:
        for s,color in table:
            lm.logWaiting.insert(0,(s+'\n',color),)
        for s,color in lm.logWaiting:
            g.es('',s,color=color,newline=0)
                # The caller must write the newlines.
    lm.logWaiting = []
    # Essential when opening multiple files...
    lm.setLog(None)
#@+node:ekr.20200209055601.1: **  Archived test stuff
#@+node:ekr.20200209055610.1: *3* @@button test
g.cls()
import os
leo_editor_dir = os.path.join(g.app.loadDir, '..', '..')
os.chdir(leo_editor_dir)
if 0: # Run all tests
    commands = f"python -m unittest leo.core.leoAst"
    g.execute_shell_commands(commands, trace=False)
else:
    file_ = '.leoAst'
    class_, test = '', ''
    class_, test = '.TestOrange', '.test_join_leading_whitespace'
    # class_, test = '.TestOrange', '.test_leo_sentinels'
    # class_, test = '.TestOrange', '.test_start_of_line_whitespace'
    # class_, test = '.TestOrange', '.test_join_lines'
    #
    # Older
    #
    # file_ = '.leoAst'
    # class_, test = '.TestTOG', ''
    # class_, test = '.TestFiles', '.compare_tog_vs_asttokens'
    # class_, test = '.TestFiles', '.optional_file_tests'
    # class_, test = '.TestTokens', '.show_asttokens_script'
    # class_, test = '.TestFstringify', '.test_call_with_comments'
        # # 'test_call_in_rhs' # '.test_braces'
    # class_, test = '.TestOrange','.test_join_lines'
        # # 'test_sync_tokens' # '.test_multi_line_pet_peeves'
    # class_, test = '.TestTokens', '.show_example_dump'
        # # 'test_line_links'
    # class_, test = '.TestTopLevelFunctions', '.test_get_encoding_directive'
    # class_, test = '.TestReassignTokens', ''
    # class_, test = '.TestTOT', ''
    commands = f"python -m unittest leo.core{file_}{class_}{test}"
    g.execute_shell_commands(commands, trace=False)
#@+node:ekr.20200209055640.1: *3* @@button pt
# Run pytest coverage tests.
g.cls()
import os
leo_editor_dir = os.path.join(g.app.loadDir, '..', '..')
os.chdir(leo_editor_dir)
commands = "pytest --cov-report html --cov-report term-missing --cov leo.core.leoAst leo/core/leoAst.py"
g.execute_shell_commands(commands, trace=False)
#@+node:ekr.20191028161708.1: *3*  Old test runners
#@+node:ekr.20191101150059.1: *4* function: check_roundtrip 
import unittest
# from tokenize import tokenize, untokenize

def check_roundtrip(f, expect_failure=False):
    """
    Called from unit tests in unitTest.leo.
    
    Test python's token.untokenize method and Leo's Untokenize class.
    """
    check_python_roundtrip(f, expect_failure)
    check_leo_roundtrip(f)

def check_leo_roundtrip(code, trace=False):
    """Check Leo's Untokenize class"""
    # pylint: disable=import-self
    import leo.core.leoBeautify as leoBeautify
    assert isinstance(code, str), repr(code)
    tokens = tokenize.tokenize(io.BytesIO(code.encode('utf-8')).readline)
    u = leoBeautify.InputTokenizer()
    u.trace=False and not g.unitTesting
    result_tokens = u.create_input_tokens(code, tokens)
    result = ''.join([z.to_string() for z in result_tokens])
    unittest.TestCase().assertEqual(code, result)

def check_python_roundtrip(f, expect_failure):
    """
    This is tokenize.TestRoundtrip.check_roundtrip, without the wretched fudges.
    """
    if isinstance(f, str):
        code = f.encode('utf-8')
    else:
        code = f.read()
        f.close()
    readline = iter(code.splitlines(keepends=True)).__next__
    tokens = list(tokenize.tokenize(readline))
    bytes = tokenize.untokenize(tokens)
    readline5 = iter(bytes.splitlines(keepends=True)).__next__
    result_tokens = list(tokenize.tokenize(readline5))
    if expect_failure:
        unittest.TestCase().assertNotEqual(result_tokens, tokens)
    else:
        unittest.TestCase().assertEqual(result_tokens, tokens)
#@+node:ekr.20191102062105.1: *4* @@command show tokens @key=Ctrl-1
g.cls()
import io
import tokenize
import imp
import leo.core.leoBeautify as leoBeautify
imp.reload(leoBeautify)

contents = r'''
print('hi')
'''
print("Ctrl-1: Round trip tests...\n")
leoBeautify.show(contents, 'Contents', dump=False)
contents = contents.strip() + '\n'
tokens = tokenize.tokenize(io.BytesIO(contents.encode('utf-8')).readline)
# Untokenize the tokens.
x = leoBeautify.InputTokenizer()
result_tokens = list(x.create_input_tokens(contents, tokens))
result = ''.join([z.to_string() for z in result_tokens])
if result == contents:
     print("\nPASS Ctrl-1: Round trip tests")
else:
    g.printObj(result)
    print(result)
    print('FAIL')
    print("FAIL Ctrl-1: Round trip tests")
#@+node:ekr.20191107160414.1: *5* Old tests
a = "b\
c\
d"
print ( 'aa \
bb')
print('xx \
yy')
#@+node:ekr.20191028095948.1: *4* @@command test FstringifyTokens @key=Ctrl-2
g.cls()
import imp
import leo.core.leoBeautify as leoBeautify
imp.reload(leoBeautify)

contents = r'''
return ''.join(['\n  %s' % z for z in result])
'''

print("Ctrl-2: Test of FStringifyTokens...\n")
contents = contents.strip() + '\n'
leoBeautify.test_FstringifyTokens(c, contents,
    dump=False,
    dump_input_tokens=False,
    dump_output_tokens=False)
print("\nEnd Ctrl-2: Test of FStringifyTokens")
#@+node:ekr.20191106073220.1: *5* Former fails that pass
g.es('%s blah blah' % (
    g.angleBrackets('*')))
    
mods = ''.join(['%s+' % z.capitalize() for z in self.mods])

args = '(%s)' % self.get_args(frame1) if self.show_args else ''
print(f"{path}{dots}{leadin}{full_name}{args}")

return '[%s]' % ' '.join(result).strip()

ret = '[\n%s]' % ('\n,'.join([self.show(z) for z in arg]))
#@+node:ekr.20191106074238.1: *5* Test that pass
#@+node:ekr.20191029072408.1: *6* fstringify tests
contents = r'''
print(
    'scanned %s node%s,' % (total, g.plural(total)),
    'changed %s node%s,' % (changed, g.plural(changed)),
    'in %4.2f sec.' % (t2-t1),
)
'''
#@+node:ekr.20191106024827.1: *6* fstringify tests 2
# These all pass
print('%2s' % a)
print('%2r' % b)
'%2.4f'%0.1
'%2.5f' % 0.2
'%s+' % z.capitalize()
''.join(['%s+' % z.capitalize() for z in self.mods])
#@+node:ekr.20191104221335.1: *6* fstring indentation tests
if 1:
  # Input:
    mods = ''.join(['%s+' % z.capitalize() for z in self.mods])
  # Results should be:
  # mods = ''.join([f'{z.capitalize()}+' for z in self.mods])
    mods = ''.join(['%s+' % z.capitalize() for z in self.mods])

# Single-line comment 2.
print('hi')
print(
    'thing 1',
    'thing 2',
)
print(
    'thing 3\
    thing4'
)
print \
    ('done')
#@+node:ekr.20191106064649.1: *6* fstring bs-nl tests
# backslash test.
a = "b\
c\
d"
print\
(
    'thing 3\
    thing4'
)
#@+node:ekr.20191106142223.1: *5* To do (small problems)
g.es('%s blah blah' % (g.angleBrackets('*')))

ret = '[%s]' % ','.join([self.show(z) for z in arg])

return ''.join(['\n  %s' % z for z in result])

g.trace('done: %5s page: %3s found: %s label: %s' % (
    done, page, n, label))
    
result = ['g.Bunch(%s)' % (tag or '')]
#@+node:ekr.20191106064850.1: *5* FAIL: missing ws
ret = '[%s]' % ','.join([self.show(z) for z in arg])

return ''.join(['\n  %s' % z for z in result])

g.trace('done: %5s page: %3s found: %s label: %s' % (
    done, page, n, label))
    
result = ['g.Bunch(%s)' % (tag or '')]
#@+node:ekr.20191026103522.1: *4* @@command test NullTokenBeautifier @key=Ctrl-3
"""Test NullTokenBeautifier on the given contents."""
g.cls()
import imp
import leo.core.leoBeautify as leoBeautify
imp.reload(leoBeautify)
# Between-token whitespace, w/o bs-nl
contents = r'''
# Backslash-newline
a = "b\
c\
d"
print(
    'thing 3\
    thing4'
)
# String concatenation, w/ trailing ws
'a' 'b' 
# String concatenation, w/ trailing ws at eof
'c', 'd' 
'''
print("Ctrl-3: Test of NullTokenBeautifier...\n")
contents = contents.strip() + '\n'
ok = leoBeautify.test_NullTokenBeautifier(c, contents,
    dump=False, dump_input_tokens=True, dump_output_tokens=False)
status = 'PASS' if ok else 'FAIL'
print(f"{status} End Ctrl-3: Test of NullTokenBeautifier")
#@+node:ekr.20191102055312.1: *5* << define contents >>
#@+node:ekr.20191029072313.1: *5* old test 1 (long)
if 1:
    # Single-line comment.
    print ( "hello" )
    if 0:
        print("bs-nl\
            continued\
            again")
    print(
        f"scanned {total} node{g.plural(total)}, "
        f"changed {changed} node{g.plural(changed)}, "
                # f"{errors} error{g.plural(errors)} "
        f"in {t2-t1:4.2f} sec."
    )
    print(
        'scanned %s node%s,' % (total, g.plural(total)),
        'changed %s node%s,' % (changed, g.plural(changed)),
        'in %4.2f sec.' % (t2-t1),
    )
print(a[1 : 2])
#@+node:ekr.20191030164855.1: *5* old test 2 (short)
if 1:
    # Single-line comment.
    print ( "hello" )
print('done')
#@+node:ekr.20191031091233.1: *5* old test 3
if 1:
    # Single-line comment.
    print ( "hello" )
    if 0:
        print("bs-nl\
            continued \
            again")
        print\
            ('next')
    print(
        f"scanned {total} node{g.plural(total)}, "
        f"changed {changed} node{g.plural(changed)}, "
                # f"{errors} error{g.plural(errors)} "
        f"in {t2-t1:4.2f} sec."
    )
    print(
        'scanned %s node%s,' % (total, g.plural(total)),
        'changed %s node%s,' % (changed, g.plural(changed)),
        'in %4.2f sec.' % (t2-t1),
    )
print(a[1 : 2])
#@+node:ekr.20191102055214.1: *5* old test: python bug
# Python bug: space after 'print' not round-tripped properly.
a = "b\
    c\
    d"
    
print\
    (\
    a,\
    b\
#@+node:ekr.20191029184302.1: *4* @@command test PythonTokenBeautifier @key=Ctrl-4
g.cls()
import imp
import leo.core.leoBeautify as leoBeautify
imp.reload(leoBeautify)

table = (
# New fail 1 from leoAst.py
r'''
def get_fields(self, node):
    return (
        (a, b) for a, b in ast.iter_fields(node)
            if a not in self.disabled_fields and b not in (None, [])
    )
''',
# Fail 1 from leoAst.py
r'''
raise AstNotEqual(
    f"node1.__class__.__name__: {node1.__class__.__name__}\n"
    f"node2.__class__.__name__: {node2.__class__.__name_}"
)
''',
# Fail 2 from leoAst.py
r'''
remove = [
    'Interactive', 'Suite',  # Not necessary.
    'PyCF_ONLY_AST',  # A constant,
    'AST',  # The base class,
]
''',
# Fail 3 from leoAst.py.
'''
table = (
    AstFullTraverser,
    AstFormatter,
    AstPatternFormatter,
    HTMLReportTraverser,
)
''',
# Basic indentation test.
r'''
def foo(a, b):
    foo()
    bar()
''',
# Backslash-newline tests.
# There must be a single blank before the bs-nl
# because *regularizes* whitespace before bs-nl.
r'''
print \
    ( \
    a, \
    b \
)
a = "b \
c \
d"
print \
    ('done')
''',
# Indentation test.
# Note: ptb retains the exact spelling of all strings.
r'''
print('hi')
print(
    'thing 1',
    'thing 2',
)
print(
    'thing 3\
    thing 4 \
    thing5'
)
''',
)
print("Ctrl-4: Test of PythonTokenBeautifier...\n")
ok = True
for test in table:
    contents = test.strip() + '\n'
    same = leoBeautify.test_PythonTokenBeautifier(c, contents,
        dump=False, # Use g.printObj to show results.
        dump_input_tokens=False,
        dump_output_tokens=False,
    )
    if not same:
        ok = False
        if 0: # Possible.
            g.cls()
            leoBeautify.test_PythonTokenBeautifier(c, contents,
                dump=True, # Use g.printObj to show results.
                dump_input_tokens=True,
                dump_output_tokens=True,
            )
        break #
print(
    f"{'PASS' if ok else 'FAIL'} "
    f"Ctrl-4: Test of PythonTokenBeautifier")
#@+node:ekr.20191029184302.2: *5* fstring test
contents = r'''
print('abc\
   xyz')
print("hello %s" % 'world')
print(
    f"scanned {total} node{g.plural(total)}, "
    f"changed {changed} node{g.plural(changed)}, "
            # f"{errors} error{g.plural(errors)} "
    f"in {t2-t1:4.2f} sec."
)
print(
    'scanned %s node%s,' % (total, g.plural(total)),
    'changed %s node%s,' % (changed, g.plural(changed)),
    'in %4.2f sec.' % (t2-t1),
)
'''
#@+node:ekr.20191030195606.1: *5* comment indent test
verbatim = False
# Single-line comment.
if self.test: # not single-line comment.
    pass
    # This comment ruins the indentation!
else:
    pass # not a single-line comment.
# Single-line comment.
# Single-line comment 2
#@+node:ekr.20191031170857.1: *5* backslash test
if 1:
    pass
while(a or \
    b or \
    c):
    pass
print \
    ('hi')
print(
    "abc"
    "xyz"
)
#@+node:ekr.20191105090751.1: *5* full test
@language python
@
This is a doc part.
@c

def spam():
    if 1:
        # Regular comment.
        print('-----')
            # Indented comment.
    else:
        pass
#@+node:ekr.20200219073857.1: *3* @@suite run all doctests
tm = c.testManager
path = g.os_path_join(g.app.loadDir,"..","core")
exclude = ['leoIPython.py',]
    # leoIPython.py will give an annoying error if IPython can't be imported.
modules = tm.importAllModulesInPath(path,exclude=exclude)
suite   = tm.createUnitTestsFromDoctests(modules)
#@+node:ekr.20191224054725.1: **  Retired plugins & commands
#@+node:ekr.20191224054733.1: *3* Retired plugin: scripts_menu.py
"""Creates a Scripts menu for LeoPy.leo."""

# The new Execute Script command seems much safer and more convenient.

@language python
@tabwidth -4

import leo.core.leoGlobals as g
import glob
import os

__version__ = "1.5"

@others
#@+node:ekr.20191224054733.2: *4*  init
def init():
    '''Return True if the plugin has loaded successfully.'''
    # Ok for unit testing: creates menu.
    g.registerHandler("create-optional-menus",create_scripts_menu)
    g.plugin_signon(__name__)
    return True
#@+node:ekr.20191224054733.3: *4* create_scripts_menu & helpers
def create_scripts_menu (tag,keywords):
    """
    Populate a new Scripts menu with all .py files
    in leo/scripts and subdirectories.
    """
    c = keywords.get("c")
    if not c:
        return
    # finalize = g.os_path_finalize
    join = g.os_path_finalize_join
    path = join(g.app.loadDir,"..","scripts")
    if not os.path.exists(path):
        return
    # Get all files and directories.
    entries = glob.glob(join(path, "*"))
    # Get all top-level modules.
    top_mods = glob.glob(join(path, "*.py"))
    top_mods = [z for z in top_mods
        if not z.endswith('__init__.py')]
    # Get all inner modules.
    dirs = [f for f in entries if os.path.isdir(f)]
    inner_mods = [glob.glob(join(z, "*.py")) for z in dirs]
    inner_mods = [z for z in inner_mods if z]
    # g.printObj(top_mods, tag='top_mods')
    # g.printObj(inner_mods, tag='inner_mods')
    if not top_mods and not inner_mods:
        return
    # Create the top-level scripts menu.
    scriptsMenu = c.frame.menu.createNewMenu("&Scripts")
    create_top_level_scripts(c, scriptsMenu, top_mods)
    for directory in dirs:
        files = glob.glob(join(directory, "*.py"))
        if files:
            create_inner_scripts(c, directory, files)
#@+node:ekr.20191224054733.4: *5* create_inner_scripts
def create_inner_scripts(c, directory, files):
    """Create a submenu of the Scripts menu."""
    name = os.path.join("scripts", g.shortFileName(directory))
    menu = c.frame.menu.createNewMenu(name,"&Scripts")
    
    # Populate the submenu.
    table = []
    for filename in files:
        if filename.endswith('__init__.py'):
            continue
        prefix = g.os_path_finalize_join(g.app.loadDir, "..", "..")
        name = filename[len(prefix)+1:-3]
        name = name.replace('\\','.').replace('/','.')
        
        def inner_script_callback(event=None, name=name):
            g.import_module(name)

        table.append((name, None, inner_script_callback))
    c.frame.menu.createMenuEntries(menu, table, dynamicMenu=True)
#@+node:ekr.20191224054733.5: *5* create_top_level_scripts
def create_top_level_scripts(c, scriptsMenu, top_scripts):
 
    table = []
    for script in sorted(top_scripts):
        name = g.shortFileName(script)[:-3]

        def script_callback(event=None, name=name):
            g.import_module(f"leo.scripts.{name}")

        table.append((name, None, script_callback))
    c.frame.menu.createMenuEntries(
        scriptsMenu, table, dynamicMenu=True)
#@+node:ekr.20200304065045.1: *3* 'equal-sized-editors'
@g.command('equal-sized-editors')
def equal_sized_editors(event):
    c = event.get('c')
    if 1:
        g.es_print('not ready yet', color='red')
        return
    if not c:
        return
    if not g.app.dock:
        return
    dw = c.frame.top
    if not isinstance(dw, QtWidgets.QMainWindow):
        return
    n = len(dw.leo_docks)
    if n < 2:
        return
    # Process events, to calculate new sizes.
    g.app.gui.qtApp.processEvents()
    # Calculate the desired widths.
    layout = dw.layout()
    geom = layout.geometry()
    left, right = geom.left(), geom.right()
    width = right - left
    w = int(width / n)
    # g.trace('docks:', n, 'left:', left, 'width:', width, 'w', w)
    # Set the desired geometries.
    for dock in dw.leo_docks:
        dock.setFixedWidth(w)
#@+node:ekr.20200303071111.1: ** ----- Macros
# Most of this code dates from Leo 5.5.
#@+node:ekr.20200303061541.113: *3* 5.0 COPY ga.get_arg (entry) & helpers
def get_arg (ga,event,
    returnKind=None,returnState=None,handler=None,
    tabList=[],completion=True,oneCharacter=False,
    stroke=None,useMinibuffer=True
):
    << ga.get_arg docstring >>
    # pylint: disable=unpacking-non-sequence
    trace = False and not g.app.unitTesting
    c,k = ga.c,ga.k
    state = k.getState('getArg')
    c.check_event(event)
    # Remember these events also.
    if c.macroCommands.recordingMacro and state > 0:
        c.macroCommands.startRecordingMacro(event)
    char = event and event.char or ''
    if state > 0:
        k.setLossage(char,stroke)
    if state == 0:
        ga.do_state_zero(completion,event,handler,oneCharacter,
            returnKind,returnState,tabList,useMinibuffer)
        if trace: ga.trace_state(char,completion,handler,state,stroke)
    else:
        if trace: ga.trace_state(char,completion,handler,state,stroke)
        if char == 'Escape':
            k.keyboardQuit()
        elif ga.should_end(char,stroke):
            ga.do_end(event,char,stroke)
        elif char in('\t','Tab'):
            if trace: g.trace('***tab***')
            ga.do_tab(ga.tabList,ga.arg_completion)
        elif char in ('\b','BackSpace'):
            ga.do_back_space(ga.tabList,ga.arg_completion)
            c.minibufferWantsFocus()
        elif k.isFKey(stroke):
            # Ignore only F-keys. Ignoring all except plain keys would kill unicode searches.
            pass
        else:
            ga.do_char(event,char)
#@+node:ekr.20200303061541.114: *4* << ga.get_arg docstring >>
'''
Accumulate an argument. Enter the given return state when done.

Ctrl-G will abort this processing at any time.

All commands needing user input call k.getArg, which just calls ga.get_arg.

The arguments to ga.get_arg are as follows:
    
event:              The event passed to the command.
    
returnKind=None:    A string.
returnState=None,   An int.
handler=None,       A function.

    When the argument is complete, ga.do_end does::

        if kind: k.setState(kind,n,handler)

tabList=[]:         A list of possible completions.
      
completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

'''
#@+node:ekr.20200303061541.115: *4* ga.do_char
def do_char (ga,event,char):
    '''Handle a non-special character.'''
    k = ga.k
    k.updateLabel(event)
    # Any plain key resets tab cycling.
    ga.reset_tab_cycling()
#@+node:ekr.20200303061541.116: *4* ga.do_end
def do_end(ga,event,char,stroke):
    '''A return or escape has been seen.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    if trace:
        g.trace('char',repr(char),stroke,k.getArgEscapes)
        if ga.after_get_arg_state:
            kind,n,handler = ga.after_get_arg_state
            g.trace('after state',kind,n,handler and handler.__name__ or 'None')
    if char == '\t' and char in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if stroke and stroke in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if k.oneCharacterArg:
        k.arg = char
    else:
        k.arg = ga.get_label()
        if trace: g.trace('k.mb_prefix',k.mb_prefix,'k.arg',k.arg)
    kind,n,handler = ga.after_get_arg_state
    if kind: k.setState(kind,n,handler)
    ga.log.deleteTab('Completion')
    if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
    # pylint: disable=not-callable
    ga.reset_tab_cycling()
    if handler: handler(event)
#@+node:ekr.20200303061541.117: *4* ga.do_state_zero
def do_state_zero(ga,completion,event,handler,oneCharacter,
    returnKind,returnState,tabList,useMinibuffer
):
    '''Do state 0 processing.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    # Set the ga globals...
    ga.after_get_arg_state=returnKind,returnState,handler
    ga.arg_completion = completion
    ga.cycling_prefix = None
    ga.handler = handler
    ga.tabList = tabList[:] if tabList else []
    # Set the k globals...
    k.argSelectedText = c.frame.body.wrapper.getSelectedText()
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg',1,k.getArg)
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
#@+node:ekr.20200303061541.118: *4* ga.should_end
def should_end(ga,char,stroke):
    '''Return True if ga.get_arg should return.'''
    k = ga.k
    return (
        char in ('\n','Return',) or
        k.oneCharacterArg or 
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes
            # The Find Easter Egg.
    )
#@+node:ekr.20200303061541.119: *4* ga.trace_state
def trace_state(ga,char,completion,handler,state,stroke):
    '''Trace the vars and ivars.'''
    k = ga.c.k
    g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        # 'isPlain',k.isPlainKey(stroke),
        '\n',
        'escapes',k.getArgEscapes,
        'completion',ga.arg_completion,
        'handler',ga.handler and ga.handler.__name__ or 'None',
    )
#@+node:ekr.20200303061541.120: *3* 5.0 COPY k.fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):
    '''Handle 'full-command' (alt-x) mode.'''
    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None
    if trace and verbose: g.trace(g.callers())
    if trace:
        g.trace('recording',recording,'state',state,char)
    if recording:
        c.macroCommands.startRecordingMacro(event)
    if state > 0:
        k.setLossage(char,stroke)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = helpPrompt if help else k.altX_prompt
        k.setLabelBlue(prompt)
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('Down','Up'):
        # Do command history.
        h,i = k.commandHistory,k.commandIndex
        if h:
            i = min(i+1,len(h)-1) if char == 'Up' else max(0,i-1)
            commandName = h[i]
            k.commandIndex = i
            # g.trace(char,i,h,h[i])
            k.setLabel(k.mb_prefix + commandName)
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            s = k.getLabel(ignorePrompt=True)
            commandName = s.strip()
            ok = k.callAltXFunction(k.mb_event)
            if ok:
                # Update command history if the command exists.
                h,i = k.commandHistory,k.commandIndex
                if commandName in h:
                    h.remove(commandName)
                    k.commandIndex = max(0,i-1)
                h.append(commandName)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)
#@+node:ekr.20200303061541.121: *4* callAltXFunction
def callAltXFunction (self,event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName,tail = k.getMinibufferCommandName()
    if trace: g.trace('command:',commandName,'tail:',tail)
    k.functionTail = tail
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            # In a headline that is being edited.
            ### g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            func(event)
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
        return True
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
        return False
#@+node:ekr.20050710142719: *3* COPY 5.5: leoEditCommands.py
@first # -*- coding: utf-8 -*-
'''
Basic editor commands for Leo.

Modelled after Emacs and Vim commands.
'''
# pylint: disable=eval-used
<< imports >>
<< define class BaseEditCommandsClass >>
@others
#@+node:ekr.20050710151017: *4* << imports >> (leoEditCommands)
import leo.core.leoGlobals as g
# import leo.core.LeoFind as LeoFind
import difflib   
docutils = g.importExtension('docutils',pluginName='leoEditCommands.py')
try:
    import enchant
except ImportError:
    enchant = None
import os
import re
if g.isPython3:
    from functools import reduce
import shlex
import string
import subprocess # Always exists in Python 2.6 and above.
import sys
#@+node:ekr.20050920084036.1: *4* << define class BaseEditCommandsClass >>
class BaseEditCommandsClass:

    '''The base class for all edit command classes'''

    @others
#@+node:ekr.20050920084036.2: *5*  Birth (BaseEditCommandsClass)
def __init__ (self,c):

    self.c = c
    self.k = None
    self.registers = {} # To keep pychecker happy.
    self.undoData = None
    self.w = None

def finishCreate(self):

    self.k = self.c.k
    try:
        self.w = self.c.frame.body.wrapper # New in 4.4a4.
    except AttributeError:
        self.w = None

def init (self):
    '''Called from k.keyboardQuit to init all classes.'''
    pass
#@+node:ekr.20051214132256: *5* begin/endCommand (baseEditCommands)
#@+node:ekr.20051214133130: *6* beginCommand  & beginCommandWithEvent
def beginCommand (self,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(
        ch=event and event.char or '',
        undoType=undoType,w=event.widget)
#@+node:ekr.20051215102349: *7* beingCommandHelper
# New in Leo 4.4b4: calling beginCommand is valid for all widgets,
# but does nothing unless we are in the body pane.

def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.p
    name = c.widget_name(w)

    if name.startswith('body'):
        oldSel =  w.getSelectionRange()
        oldText = p.b
        self.undoData = b = g.Bunch()
        # To keep pylint happy.
        b.ch=ch
        b.name=name
        b.oldSel=oldSel
        b.oldText=oldText
        b.w=w
        b.undoType=undoType
    else:
        self.undoData = None

    return w
#@+node:ekr.20051214133130.1: *6* endCommand (baseEditCommand)
# New in Leo 4.4b4: calling endCommand is valid for all widgets,
# but handles undo only if we are in body pane.

def endCommand(self,label=None,changed=True,setLabel=True):

    '''Do the common processing at the end of each command.'''

    trace =  False and not g.unitTesting
    c = self.c ; b = self.undoData ; k = self.k

    if trace: g.trace('changed',changed)

    if b and b.name.startswith('body') and changed:
        c.frame.body.onBodyChanged(undoType=b.undoType,
            oldSel=b.oldSel,oldText=b.oldText,oldYview=None)

    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()

    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()
#@+node:ekr.20061007105001: *5* editWidget (BaseEditCommandsClass)
def editWidget (self,event,forceFocus=True):
    '''Return the edit widget for the event.'''
    trace = False and not g.unitTesting
    c = self.c
    w = event and event.widget
    wname = (w and c.widget_name(w)) or '<no widget>'
    isTextWrapper = g.isTextWrapper(w)
    # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
    if w and isTextWrapper:
        self.w = w
    else:
        self.w = self.c.frame.body and self.c.frame.body.wrapper
    if trace: g.trace(isTextWrapper,wname,w)
    if self.w and forceFocus:
        c.widgetWantsFocusNow(self.w)
    return self.w
#@+node:ekr.20050920084036.5: *5* getPublicCommands & getStateCommands
def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
#@+node:ekr.20050920084036.6: *5* getWSString
def getWSString (self,s):

    return ''.join([ch if ch=='\t' else ' ' for ch in s])
#@+node:ekr.20050920084036.7: *5* oops
def oops (self):

    g.pr("BaseEditCommandsClass oops:",
        g.callers(),
        "must be overridden in subclass")
#@+node:ekr.20050929161635: *5* Helpers
#@+node:ekr.20050920084036.249: *6* _chckSel
def _chckSel (self,event,warning='no selection'):

    k = self.k
    w = self.editWidget(event)
    val = w and w.hasSelection()
    if warning and not val:
        k.setLabelGrey(warning)
    return val
#@+node:ekr.20050920084036.250: *6* _checkIfRectangle
def _checkIfRectangle (self,event):

    c,k = self.c,self.k

    key = event and event.char.lower() or ''

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
#@+node:ekr.20050920084036.233: *6* getRectanglePoints
def getRectanglePoints (self,w):

    c = self.c
    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    i,j = w.getSelectionRange()
    r1,r2 = g.convertPythonIndexToRowCol(s,i)
    r3,r4 = g.convertPythonIndexToRowCol(s,j)

    return r1+1,r2,r3+1,r4
#@+node:ekr.20051002090441: *6* keyboardQuit
def keyboardQuit (self,event=None):

    '''Clear the state and the minibuffer label.'''

    return self.k.keyboardQuit()
#@+node:ekr.20120315062642.9746: *4*  Commands defined by @g.command
#@+node:ekr.20120315062642.9745: *5* ctrl-click-at-cursor
@g.command('ctrl-click-at-cursor')
def ctrlClickAtCursor(event):
    c = event.get('c')
    if c:
        g.openUrlOnClick(event)
#@+node:ekr.20140701101218.16740: *5* enable/disable/toggle-idle-time-events
@g.command('disable-idle-time-events')
def disable_idle_time_events(event):
    g.disableIdleTimeHook()
    
@g.command('enable-idle-time-events')
def enable_idle_time_events(event):
    g.enableIdleTimeHook()
    
@g.command('toggle-idle-time-events')
def toggle_idle_time_events(event):
    if g.app.idleTimeHook:
        g.disableIdleTimeHook()
    else:
        g.enableIdleTimeHook()
#@+node:ekr.20140701093157.16738: *5* enable/disable/toggle-idle-time-tracing
@g.command('disable-idle-time-tracing')
def disable_idle_time_tracing(event):
    g.app.trace_idle_time = False
    
@g.command('enable-idle-time-tracing')
def enable_idle_time_tracing(event):
    g.app.trace_idle_time = True
    
@g.command('toggle-idle-time-tracing')
def toggle_idle_time_tracing(event):
    g.app.trace_idle_time = not g.app.trace_idle_time
#@+node:ekr.20131120115900.16323: *5* join-leo-irc
@g.command('join-leo-irc')
def join_leo_irc(event=None):
    import webbrowser
    webbrowser.open("http://webchat.freenode.net/?channels=%23leo&uio=d4")
#@+node:ekr.20120315062642.9742: *5* open-url
@g.command('open-url')
def openUrl(event=None):
    c = event.get('c')
    if c:
        g.openUrl(c.p)

#@+node:ekr.20131120115900.16324: *5* open-url-under-cursor
@g.command('open-url-under-cursor')
def openUrlUnderCursor(event=None):
    return g.openUrlOnClick(event)
#@+node:ekr.20140718105559.17735: *5* pylint command
@g.command('pylint')
def pylint_command(event):
    << class PylintCommand >>
    c = event.get('c')
    if c:
        PylintCommand(c).run()
#@+node:ekr.20140718105559.17736: *6* << class PylintCommand >>
class PylintCommand:
    '''A class to run pylint on all Python @<file> nodes in c.p's tree.'''
    def __init__(self,c):
        '''ctor for PylintCommand class.'''
        self.c = c
        self.seen = [] # List of checked vnodes.
        self.wait = True
            # The no-wait code doesn't seem to work.
    @others
#@+node:ekr.20140718114031.17742: *7* check
def check(self,p,rc_fn):
    '''Check a single node.  Return True if it is a Python @<file> node.'''
    found = False
    if p.isAnyAtFileNode():
        # Fix bug: https://github.com/leo-editor/leo-editor/issues/67
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.anyAtFileNodeName()
        if fn.endswith('.py'):
            fn = g.os_path_finalize_join(path,fn)
            if p.v not in self.seen:
                self.seen.append(p.v)
                self.run_pylint(fn,rc_fn)
                found = True
    return found
#@+node:ekr.20140719051145.17727: *7* get_rc_file
def get_rc_file(self):
    '''Return the path to the pylint configuration file.'''
    trace = False and not g.unitTesting
    base = 'pylint-leo-rc.txt'
    table = (
        g.os_path_finalize_join(g.app.homeDir,'.leo',base),
            # In ~/.leo
        g.os_path_finalize_join(g.app.loadDir,'..','..','leo','test',base),
            # In leo/test
    )
    for fn in table:
        fn = g.os_path_abspath(fn)
        if g.os_path_exists(fn):
            if trace: g.trace('found:',fn)
            return fn
    g.es_print('no pylint configuration file found in\n%s' % (
        '\n'.join(table)))
    return None
#@+node:ekr.20140718105559.17737: *7* run
def run(self):
    '''Run Pylint on all Python @<file> nodes in c.p's tree.'''
    c,root = self.c,self.c.p
    try:
        import time
        from pylint import lint
        # in pythonN/Lib/site-packages.
    except ImportError:
        g.warning('can not import pylint')
        return
    rc_fn = self.get_rc_file()
    if not rc_fn:
        return
    # Run lint on all Python @<file> nodes in root's tree.
    t1 = time.clock()
    found = False
    for p in root.self_and_subtree():
        found |= self.check(p,rc_fn)
    # Look up the tree if no @<file> nodes were found.
    if not found:
        for p in root.parents():
            if self.check(p,rc_fn):
                found = True
                break
    # If still not found, expand the search if root is a clone.
    if not found:
        isCloned = any([p.isCloned() for p in root.self_and_parents()])
        # g.trace(isCloned,root.h)
        if isCloned:
            for p in c.all_positions():
                if p.isAnyAtFileNode():
                    isAncestor = any([z.v == root.v for z in p.self_and_subtree()])
                    # g.trace(isAncestor,p.h)
                    if isAncestor and self.check(p,rc_fn):
                        break
    if self.wait:
        g.es_print('pylint: done %s' % g.timeSince(t1))
#@+node:ekr.20140718105559.17741: *7* run_pylint
def run_pylint(self,fn,rc_fn):
    '''Run pylint on fn with the given pylint configuration file.'''
    if not os.path.exists(fn):
        print('file not found:',fn)
        return
    # Report the file name.
    if self.wait:
        print('pylint: %s' % (g.shortFileName(fn)))
    # Create the required args.
    args = ','.join([
        "fn=r'%s'" % (fn),
        "rc=r'%s'" % (rc_fn),
    ])
    # Execute the command in a separate process.
    command = '%s -c "import leo.core.leoGlobals as g; g.run_pylint(%s)"' % (
        sys.executable,args)
    if not self.wait:
        command = '&' + command
    g.execute_shell_commands(command)   
#@+node:ekr.20120211121736.10817: *4* class EditCommandsManager
class EditCommandsManager:

    '''A class to init all edit commands properly.

    This class eliminates the circular dependencies that otherwise
    would arise from the module-level classesList.
    '''


    @others
#@+node:ekr.20120211121736.10830: *5*  ecm.ctor
def __init__ (self,c):

    self.c = c

    self.classesList = (
        ('abbrevCommands',      AbbrevCommandsClass),
        ('bufferCommands',      BufferCommandsClass),
        ('editCommands',        EditCommandsClass),
        ('chapterCommands',     ChapterCommandsClass),
        ('controlCommands',     ControlCommandsClass),
        ('debugCommands',       DebugCommandsClass),
        ('editFileCommands',    EditFileCommandsClass),
        ('helpCommands',        HelpCommandsClass),
        ('keyHandlerCommands',  KeyHandlerCommandsClass),
        ('killBufferCommands',  KillBufferCommandsClass),
        ('leoCommands',         LeoCommandsClass),
        ('macroCommands',       MacroCommandsClass),
        # ('queryReplaceCommands',QueryReplaceCommandsClass),
        ('recTangleCommands',   RecTangleCommandsClass),
        ('registerCommands',    RegisterCommandsClass),
        ('searchCommands',      SearchCommandsClass),
        ('spellCommands',       SpellCommandsClass),
    )


#@+node:ekr.20120211121736.10827: *5* ecm.createEditCommanders
def createEditCommanders (self):

    '''Create edit classes in the commander.'''

    c = self.c

    for name, theClass in self.classesList:
        theInstance = theClass(c)# Create the class.
        setattr(c,name,theInstance)
        # g.trace(name,theInstance)
#@+node:ekr.20120211121736.10828: *5* ecm.getPublicCommands
def getPublicCommands (self):
    '''Add the names of commands defined in this file to c.commandsDict.'''
    c,d = self.c,{}
    for name, theClass in self.classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                g.pr('----- %s' % name)
                for key in sorted(d2): g.pr(key)
    c.commandsDict.update(d)
#@+node:ekr.20120211121736.10829: *5* ecm.initAllEditCommanders
def initAllEditCommanders (self):

    '''Re-init classes in the commander.'''

    c = self.c

    for name, theClass in self.classesList:
        theInstance = getattr(c,name)
        theInstance.init()
#@+node:ekr.20050920084036.13: *4* abbrevCommandsClass
class AbbrevCommandsClass (BaseEditCommandsClass):

    '''A class to handle user-defined abbreviations.

    See apropos-abbreviations for details.'''

    @others
#@+node:ekr.20100901080826.6002: *5*  Birth
#@+node:ekr.20100901080826.6003: *6* ctor (abbrevCommandsClass
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c)
        # init the base class.
    # Set local ivars.
    self.abbrevs = {} # Keys are names, values are (abbrev,tag).
    self.daRanges = []
    self.dynaregex = re.compile( # For dynamic abbreviations
        r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # Not a unicode problem.
    self.event = None
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    self.last_hit = None # Distinguish between text and tree abbreviations.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.tree_abbrevs_d = {} # Keys are names, values are (tree,tag).
    self.w = None
#@+node:ekr.20100901080826.6004: *6* finishCreate (abbrevClass) & helpers
def finishCreate(self):
    
    c,k = self.c,self.c.k
    BaseEditCommandsClass.finishCreate(self)
    self.init_settings()
    self.init_abbrev()
    self.init_tree_abbrev()
    self.init_env()
    if 0: # Annoying.
        if (not g.app.initing and not g.unitTesting and
            not g.app.batchMode and not c.gui.isNullGui
        ):
            g.red('Abbreviations %s' % ('on' if c.k.abbrevOn else 'off'))
#@+node:ekr.20130924110246.13738: *7* init_abbrev
def init_abbrev(self):
    '''
    Init the user abbreviations from @data global-abbreviations
    and @data abbreviations nodes.
    '''
    c = self.c
    table = (
        ('global-abbreviations','global'),
        ('abbreviations','local'),
    )
    for source,tag in table:
        aList = c.config.getData(source,strip_data=False) or []
        abbrev,result = [],[]
        for s in aList:
            if s.startswith('\\:'):
                # Continue the previous abbreviation.
                abbrev.append(s[2:])
            else:
                # End the previous abbreviation.
                if abbrev:
                    result.append(''.join(abbrev))
                    abbrev = []
                # Start the new abbreviation.
                if s.strip():
                    abbrev.append(s)
        # End any remaining abbreviation.
        if abbrev:
            result.append(''.join(abbrev))
        for s in result:
            self.addAbbrevHelper(s,tag)
#@+node:ekr.20130924110246.13748: *7* init_env
def init_env(self):
    '''
    Init c.abbrev_subst_env by executing the contents of the
    @data abbreviations-subst-env node.
    '''
    
    c = self.c
    if c.abbrev_place_start and self.enabled:
        aList = self.subst_env
        result = []
        for z in aList:
            # Compatibility with original design.
            if z.startswith('\\:'):
                result.append(z[2:])
            else:
                result.append(z)
        result = ''.join(result)
        try:
            exec(result,c.abbrev_subst_env,c.abbrev_subst_env)
        except Exception:
            g.es('Error exec\'ing @data abbreviations-subst-env')
            g.es_exception()
    else:
        c.abbrev_subst_start = False
        # if c.config.getString('abbreviations-subst-start'):
            # g.es("Note: @abbreviations-subst-start found, but no substitutions "
                 # "without @scripting-at-script-nodes = True")
#@+node:ekr.20130924110246.13749: *7* init_settings
def init_settings(self):
    
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations',default=False)
    # Init these here for k.masterCommand.
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c,'g': g,'_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.subst_env = c.config.getData('abbreviations-subst-env',strip_data=False)
    
#@+node:ekr.20131113150347.17255: *7* init_tree_abbrev
def init_tree_abbrev (self):
    '''Init tree_abbrevs_d from @data tree-abbreviations nodes.'''
    trace = False ; verbose = True
    c = self.c
    fn = c.shortFileName()
    d = {} # Keys are abbreviation names; Values are (xml) strings.
    # Careful. This happens early in startup.
    root = c.rootPosition()
    if not root:
        # if trace and verbose: g.trace('no root',fn)
        return
    if not c.p:
        c.selectPosition(root)
    if not c.p:
        if trace and verbose: g.trace('no c.p',fn)
        return
    tree_s = c.config.getOutlineData('tree-abbreviations')
    if not tree_s:
        if trace and verbose: g.trace('no tree_s',fn)
        return
    if trace and verbose: g.trace(fn,len(tree_s or ''))
    # Expand the tree so we can traverse it.
    if not c.canPasteOutline(tree_s):
        if trace and verbose: g.trace('bad copied outline',fn)
        return
    c.fileCommands.leo_file_encoding='utf-8'
    old_p = c.p.copy()
    p = c.pasteOutline(s=tree_s,redrawFlag=False,undoFlag=False,tempOutline=True)
    if not p: return g.trace('no pasted node')
    for s in g.splitLines(p.b):
        if s.strip() and not s.startswith('#'):
            abbrev_name = s.strip()
            for child in p.children():
                if child.h.strip() == abbrev_name:
                    c.selectPosition(child)
                    abbrev_s = c.fileCommands.putLeoOutline()
                    if trace and verbose:
                        g.trace('define',abbrev_name,len(abbrev_s))
                        # g.trace('define',abbrev_name,'\n\n',abbrev_s)
                    d[abbrev_name] = abbrev_s
                    break
            else:
                g.trace('no definition for %s' % abbrev_name)
    p.doDelete(newNode=old_p)
    c.selectPosition(old_p)
    if trace and (d or verbose):
        if verbose:
            g.trace(fn)
            for key in sorted(d.keys()):
                g.trace(key,'...\n\n',d.get(key))
        else:
            g.trace(fn,sorted(d.keys()))
    self.tree_abbrevs_d = d
#@+node:ekr.20050920084036.15: *6* getPublicCommands & getStateCommands
def getPublicCommands (self):
    '''Return a dict: keys are command names and whose values are methods.'''
    return {
        # Reload.
        # 'reload-abbreviations': self.reloadAbbreviations,
        # Non-prefixed commands.
        'toggle-abbrev-mode':   self.toggleAbbrevMode,
        # Dynamic...
        'dabbrev-completion':   self.dynamicCompletion,
        'dabbrev-expands':      self.dynamicExpansion,
        # Static...
        'abbrev-add-global':        self.addAbbreviation,
        # 'abbrev-expand-region':   self.regionalExpandAbbrev,
        'abbrev-inverse-add-global':self.addInverseAbbreviation,
        'abbrev-kill-all':          self.killAllAbbrevs,
        'abbrev-list':              self.listAbbrevs,
        'abbrev-read':              self.readAbbreviations,
        'abbrev-write':             self.writeAbbreviations,
    }
#@+node:ekr.20140104063158.17234: *6* reloadAbbreviations
def reloadAbbreviations(self):
    '''Reload all abbreviations from all files.'''
#@+node:ekr.20050920084036.27: *5* expandAbbrev & helpers (entry point)
def expandAbbrev (self,event,stroke):
    '''
    Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''
    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    ch = event and event.char or ''
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    assert g.isStrokeOrNone(stroke),stroke
    if stroke in ('BackSpace','Delete'):
        if trace and verbose: g.trace(stroke)
        return False
    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke.s,stroke.s)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event and event.char or ''
    else:
        ch = event.char
    if trace and verbose: g.trace('ch',repr(ch),'stroke',repr(stroke))
    # New code allows *any* sequence longer than 1 to be an abbreviation.
    # Any whitespace stops the search.
    s = w.getAllText()
    j = w.getInsertPoint()
    i = j-1
    while len(s) > i >= 0 and s[i] not in ' \t\n':
        prefix = s[i:j]
        word = prefix+ch
        val,tag = self.tree_abbrevs_d.get(word),'tree'
        # if val: g.trace('*****',word,'...\n\n',len(val))
        if not val:
            val,tag = self.abbrevs.get(word,(None,None))
        if val:
            if trace and verbose: g.trace(repr(word),'val',val,'tag',tag)
            # Require a word match if the abbreviation is itself a word.
            if ch in ' \t\n': word = word.rstrip()
            if word.isalnum() and word[0].isalpha():
                if i == 0 or s[i-1] in ' \t\n':
                    break
                else:
                    i -= 1
            else:
                break
        else: i -= 1
    else:
        return False
    c.abbrev_subst_env['_abr'] = word
    if tag == 'tree':
        self.last_hit = c.p.copy()
        self.expand_tree(w,i,j,val,word)
    else:
        # Never expand a search for text matches.
        place_holder = '__NEXT_PLACEHOLDER' in val
        if place_holder:
            expand_search = bool(self.last_hit)
        else:
            self.last_hit = None
            expand_search = False
        if trace: g.trace('expand_search',expand_search,'last_hit',self.last_hit)
        self.expand_text(w,i,j,val,word,expand_search)
    c.frame.body.forceFullRecolor()
    c.bodyWantsFocusNow()
    return True
#@+node:ekr.20131113150347.17257: *6* expand_text
def expand_text(self,w,i,j,val,word,expand_search=False):
    '''Make a text expansion at location i,j of widget w.'''
    c = self.c
    # g.trace(i,j,word,g.callers())
    val,do_placeholder = self.make_script_substitutions(i,j,val)
    self.replace_abbrev_name(w,i,j,val)
    # Search to the end.  We may have been called via a tree abbrev.
    p = c.p.copy()
    if expand_search:
        while p:
            if self.find_place_holder(p,do_placeholder):
                return
            else:
                p.moveToThreadNext()
    else:
        self.find_place_holder(p,do_placeholder)
#@+node:ekr.20131113150347.17258: *6* expand_tree & helper
def expand_tree(self,w,i,j,tree_s,word):
    '''Paste tree_s as children of c.p.'''
    c,u = self.c,self.c.undoer
    if not c.canPasteOutline(tree_s):
        return g.trace('bad copied outline: %s' % tree_s)
    old_p = c.p.copy()
    bunch = u.beforeChangeTree(old_p)
    self.replace_abbrev_name(w,i,j,None)
    self.paste_tree(old_p,tree_s)
    # Make all script substitutions first.
    for p in old_p.subtree():
        # Search for the next place-holder.
        val,do_placeholder = self.make_script_substitutions(0,0,p.b)
        if not do_placeholder: p.b = val
    # Now search for all place-holders.
    for p in old_p.subtree():
        if self.find_place_holder(p,do_placeholder):
            break
    u.afterChangeTree(old_p,'tree-abbreviation',bunch)
#@+node:ekr.20131114051702.22732: *6* find_place_holder
def find_place_holder(self,p,do_placeholder):
    '''
    Search for the next place-holder.
    If found, select the place-holder (without the delims).
    '''
    c = self.c
    s = p.b
    if do_placeholder or c.abbrev_place_start and c.abbrev_place_start in s:
        new_s,i,j = self.next_place(s,offset=0)
        if i is None:
            return False
        w = c.frame.body.wrapper
        switch = p != c.p
        if switch:
            c.selectPosition(p)
        else:
            scroll = w.getYScrollPosition()
        oldSel = w.getSelectionRange()
        w.setAllText(new_s)
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        c.p.b = new_s
        if switch:
            c.redraw()
        w.setSelectionRange(i,j,insert=j)
        if switch:
            w.seeInsertPoint()
        else:
            # Keep the scroll point if possible.
            w.setYScrollPosition(scroll)
            w.seeInsertPoint()
        return True
    else:
        return False
#@+node:ekr.20131114051702.22731: *6* make_script_substitutions
def make_script_substitutions(self,i,j,val):
    '''Make scripting substitutions in node p.'''
    trace = False and not g.unitTesting
    c = self.c
    if not c.abbrev_subst_start:
        if trace: g.trace('no subst_start')
        return val,False
    # Nothing to undo.
    if c.abbrev_subst_start not in val:
        return val,False
    # Perform all scripting substitutions.
    while c.abbrev_subst_start in val:
        prefix,rest = val.split(c.abbrev_subst_start,1)
        content = rest.split(c.abbrev_subst_end,1)
        if len(content) != 2:
            break
        content,rest = content
        if trace: g.trace('**content',content)
        exec(content,c.abbrev_subst_env,c.abbrev_subst_env)
        val = "%s%s%s" % (prefix,c.abbrev_subst_env['x'],rest)
    if val == "__NEXT_PLACEHOLDER":
        # user explicitly called for next placeholder in an abbrev.
        # inserted previously
        val = ''
        do_placeholder = True
    else:
        do_placeholder = False
        # Huh?
        oldSel = i,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
    if trace: g.trace(do_placeholder,val)
    return val,do_placeholder
#@+node:tbrown.20130326094709.25669: *6* next_place
def next_place(self,s,offset=0):
    """
    Given string s containing a placeholder like <| block |>,
    return (s2,start,end) where s2 is s without the <| and |>,
    and start, end are the positions of the beginning and end of block.
    """
    trace = False
    c = self.c
    new_pos = s.find(c.abbrev_place_start,offset)
    new_end = s.find(c.abbrev_place_end,offset)
    if (new_pos < 0 or new_end < 0) and offset:
        new_pos = s.find(c.abbrev_place_start)
        new_end = s.find(c.abbrev_place_end)
        if not(new_pos < 0 or new_end < 0):
            g.es("Found placeholder earlier in body")
    if new_pos < 0 or new_end < 0:
        if trace: g.trace('new_pos',new_pos,'new_end',new_end)
        return s,None,None
    start = new_pos
    place_holder_delim = s[new_pos:new_end+len(c.abbrev_place_end)]
    place_holder = place_holder_delim[
        len(c.abbrev_place_start):-len(c.abbrev_place_end)]
    s2 = s[:start]+place_holder+s[start+len(place_holder_delim):]
    end = start+len(place_holder)
    if trace: g.trace(start,end,g.callers())
    return s2,start,end
#@+node:ekr.20131114124839.16666: *6* paste_tree
def paste_tree(self,old_p,s):
    '''Paste the tree corresponding to s (xml) into the tree.'''
    c = self.c
    c.fileCommands.leo_file_encoding='utf-8'
    p = c.pasteOutline(s=s,redrawFlag=False,undoFlag=False)
    if p:
        # Promote the name node, then delete it.
        p.moveToLastChildOf(old_p)
        c.selectPosition(p)
        c.promote(undoFlag=False)
        p.doDelete()
    else:
        g.trace('paste failed')
#@+node:ekr.20131114124839.17398: *6* replace_abbrev_name
def replace_abbrev_name(self,w,i,j,s):
    '''Replace the abbreviation name by s.'''
    c = self.c
    if i != j:
        w.delete(i,j)
    if s is not None:
        w.insert(i,s)
    oldSel = j,j
    c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)
#@+node:ekr.20050920084036.58: *5* dynamic abbreviation...
#@+node:ekr.20050920084036.60: *6* dynamicCompletion C-M-/
def dynamicCompletion (self,event=None):

    '''dabbrev-completion
    Insert the common prefix of all dynamic abbrev's matching the present word.
    This corresponds to C-M-/ in Emacs.'''

    c,p,u = self.c,self.c.p,self.c.p.v.u
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    if 0 < ins < len(s) and not g.isWordChar(s[ins]): ins -= 1
    i,j = g.getWord(s,ins)
    word = w.get(i,j)
    aList = self.getDynamicList(w,word)
    if not aList: return
    # Bug fix: remove s itself, otherwise we can not extend beyond it.
    if word in aList and len(aList) > 1: aList.remove(word)
    prefix = reduce(g.longestCommonPrefix,aList)
    if prefix.strip():
        ypos = w.getYScrollPosition()
        b = c.undoer.beforeChangeNodeContents(p,oldYScroll=ypos)
        p.b = p.b[:i] + prefix + p.b[j:]
        w.setAllText(p.b)
        w.setInsertPoint(i+len(prefix))
        w.setYScrollPosition(ypos)
        c.undoer.afterChangeNodeContents(p,
            command='dabbrev-completion',bunch=b,dirtyVnodeList=[]) 
#@+node:ekr.20050920084036.59: *6* dynamicExpansion M-/
def dynamicExpansion (self,event=None):

    '''dabbrev-expands (M-/ in Emacs).
    Inserts the longest common prefix of the word at the cursor. Displays
    all possible completions if the prefix is the same as the word.
    '''

    c = self.c
    p = c.p
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    if 0 < ins < len(s) and not g.isWordChar(s[ins]): ins -= 1
    i,j = g.getWord(s,ins)
    word = w.get(i,j)
    aList = self.getDynamicList(w,word)
    if not aList: return
    if word in aList and len(aList) > 1: aList.remove(word)
    prefix = reduce(g.longestCommonPrefix,aList)
    prefix = prefix.strip()
    # g.trace(word,prefix,aList)
    if False and prefix and prefix != word and len(aList) == 1:
        s = w.getAllText()
        ypos = w.getYScrollPosition()
        b = c.undoer.beforeChangeNodeContents(p,oldYScroll=ypos)
        p.b = p.b[:i] + prefix + p.b[j:]
        w.setAllText(p.b)
        w.setInsertPoint(i+len(prefix))
        w.setYScrollPosition(ypos)
        c.undoer.afterChangeNodeContents(p,
            command='dabbrev-expands',bunch=b,dirtyVnodeList=[])
    else:
        self.dynamicExpandHelper(event,prefix,aList,w)
#@+node:ekr.20070605110441: *7* dynamicExpandHelper (added event arg)
def dynamicExpandHelper (self,event,prefix=None,aList=None,w=None):

    c = self.c ; k = c.k ; p = c.p
    tag = 'dabbrev-expand'
    state = k.getState(tag)
    if state == 0:
        self.w = w
        prefix2 = 'dabbrev-expand: '
        c.frame.log.deleteTab('Completion')
        g.es('','\n'.join(aList),tabName='Completion')
        k.setLabelBlue(prefix2+prefix)
        k.getArg(event,tag,1,self.dynamicExpandHelper,tabList=aList)
    else:
        c.frame.log.deleteTab('Completion')
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ypos = w.getYScrollPosition()
            b = c.undoer.beforeChangeNodeContents(p,oldYScroll=ypos)
            ins = w.getInsertPoint()
            if 0 < ins < len(s) and not g.isWordChar(s[ins]): ins -= 1
            i,j = g.getWord(s,ins)
            p.b = p.b[:i] + k.arg + p.b[j:]
            w.setAllText(p.b)
            w.setInsertPoint(i+len(k.arg))
            w.setYScrollPosition(ypos)
            c.undoer.afterChangeNodeContents(p,
                command=tag,bunch=b,dirtyVnodeList=[]) 
#@+node:ekr.20050920084036.61: *6* getDynamicList (helper)
def getDynamicList (self,w,s):

    if self.globalDynamicAbbrevs:
        # Look in all nodes.h
        items = []
        for p in self.c.all_unique_positions():
            items.extend(self.dynaregex.findall(p.b))
    else:
        # Just look in this node.
        items = self.dynaregex.findall(w.getAllText())

    items = sorted(set([z for z in items if z.startswith(s)]))

    # g.trace(repr(s),repr(sorted(items)))
    return items
#@+node:ekr.20070531103114: *5* static abbrevs
#@+node:ekr.20100901080826.6001: *6* addAbbrevHelper
def addAbbrevHelper (self,s,tag=''):

    '''Enter the abbreviation 's' into the self.abbrevs dict.'''

    if not s.strip(): return

    try:
        d = self.abbrevs
        data = s.split('=')
        # name = data[0].strip()
        # 2012/02/29: Do *not* strip ws, and allow the user to specify ws.
        name = data[0].replace('\\t','\t').replace('\\n','\n')
        val = '='.join(data[1:])
        if val.endswith('\n'): val = val[:-1]
        val = val.replace('\\n','\n')
        old,tag = d.get(name,(None,None),)
        if old and old != val and not g.unitTesting:
            g.es_print('redefining abbreviation',name,
                '\nfrom',repr(old),'to',repr(val))
        d [name] = val,tag

    except ValueError:
        g.es_print('bad abbreviation: %s' % s)
#@+node:ekr.20050920084036.25: *6* addAbbreviation
def addAbbreviation (self,event):

    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''

    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ')
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        value = k.argSelectedText # 2010/09/01.
        if k.arg.strip():
            self.abbrevs [k.arg] = value,'dynamic'
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviation (on): '%s' = '%s'" % (
                    k.arg,value))
#@+node:ekr.20051004080550: *6* addInverseAbbreviation
def addInverseAbbreviation (self,event):

    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''

    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ')
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg,'add-inverse-abbr'
#@+node:ekr.20050920084036.18: *6* killAllAbbrevs
def killAllAbbrevs (self,event):

    '''Delete all abbreviations.'''

    self.abbrevs = {}
#@+node:ekr.20050920084036.19: *6* listAbbrevs
def listAbbrevs (self,event=None):

    '''List all abbreviations.'''

    d = self.abbrevs
    if d:
        g.es('Abbreviations...')
        keys = list(d.keys())
        keys.sort()
        for name in keys:
            val,tag = d.get(name)
            val = val.replace('\n','\\n')
            tag = tag or ''
            tag = tag+': ' if tag else ''
            g.es('','%s%s=%s' % (tag,name,val))
    else:
        g.es('No present abbreviations')
#@+node:ekr.20050920084036.20: *6* readAbbreviations & helper
def readAbbreviations (self,event=None):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if fileName:
        self.readAbbreviationsFromFile(fileName)
#@+node:ekr.20100901080826.6156: *7* readAbbreviationsFromFile
def readAbbreviationsFromFile(self,fileName):

    k = self.c.k

    try:
        f = open(fileName)
        for s in f:
            self.addAbbrevHelper(s,'file')
        f.close()
        k.abbrevOn = True
        g.es("Abbreviations on")
        # self.listAbbrevs()
    except IOError:
        g.es('can not open',fileName)
#@+node:ekr.20050920084036.23: *6* toggleAbbrevMode
def toggleAbbrevMode (self,event=None):

    '''Toggle abbreviation mode.'''

    k = self.k
    k.abbrevOn = not k.abbrevOn
    k.keyboardQuit()
    if not g.unitTesting and not g.app.batchMode:
        g.es('Abbreviations are ' + 'on' if k.abbrevOn else 'off')
#@+node:ekr.20050920084036.24: *6* writeAbbreviation
def writeAbbreviations (self,event):
    '''Write abbreviations to a file.'''
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='Write Abbreviations',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")
    if not fileName: return
    try:
        d = self.abbrevs
        f = open(fileName,'w')
        for name in sorted(d.keys()):
            val,tag = self.abbrevs.get(name)
            val=val.replace('\n','\\n')
            s = '%s=%s\n' % (name,val)
            if not g.isPython3:
                s = g.toEncodedString(s,reportErrors=True)
            f.write(s)
        f.close()
        g.es_print('wrote: %s' % fileName)
    except IOError:
        g.es('can not create',fileName)
#@+node:ekr.20050920084036.31: *4* BufferCommandsClass
@
An Emacs instance does not have knowledge of what is considered a
buffer in the environment.

The call to setBufferInteractionMethods calls the buffer configuration methods.
@c

class BufferCommandsClass (BaseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.32: *5*  ctor (BufferCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.fromName = '' # Saved name from getBufferName.
    self.nameList = [] # [n: <headline>]
    self.names = {}
    self.tnodes = {} # Keys are n: <headline>, values are tnodes.

    try:
        self.w = c.frame.body.wrapper
    except AttributeError:
        self.w = None
#@+node:ekr.20050920084036.33: *5*  getPublicCommands
def getPublicCommands (self):

    return {

        # These do not seem useful.
            # 'copy-to-buffer':     self.copyToBuffer,
            # 'insert-to-buffer':   self.insertToBuffer,

        'buffer-append-to':             self.appendToBuffer,
        'buffer-kill' :                 self.killBuffer,
        'buffer-prepend-to':            self.prependToBuffer,
        # 'buffer-rename':              self.renameBuffer,
        'buffer-switch-to':             self.switchToBuffer,
        'buffers-list' :                self.listBuffers,
        'buffers-list-alphabetically':  self.listBuffersAlphabetically,
    }
#@+node:ekr.20050920084036.34: *5* Entry points
#@+node:ekr.20050920084036.35: *6* appendToBuffer
def appendToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Append to buffer: ')
        self.getBufferName(event,self.appendToBufferFinisher)

def appendToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        w = self.w
        c.selectPosition(p)
        self.beginCommand('append-to-buffer: %s' % p.h)
        w.insert('end',s)
        w.setInsertPoint('end')
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
#@+node:ekr.20050920084036.36: *6* copyToBuffer
def copyToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Copy to buffer: ')
        self.getBufferName(event,self.copyToBufferFinisher)

def copyToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('copy-to-buffer: %s' % p.h)
        w.insert('end',s)
        w.setInsertPoint('end')
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
#@+node:ekr.20050920084036.37: *6* insertToBuffer
def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Insert to buffer: ')
        self.getBufferName(event,self.insertToBufferFinisher)

def insertToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('insert-to-buffer: %s' % p.h)
        i = w.getInsertPoint()
        w.insert(i,s)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
#@+node:ekr.20050920084036.38: *6* killBuffer
def killBuffer (self,event):

    '''Delete a buffer (node) and all its descendants.'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Kill buffer: ')
    self.getBufferName(event,self.killBufferFinisher)

def killBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        h = p.h
        current = c.p
        c.selectPosition(p)
        c.deleteOutline (op_name='kill-buffer: %s' % h)
        c.selectPosition(current)
        self.k.setLabelBlue('Killed buffer: %s' % h)
        c.redraw(current)
#@+node:ekr.20050920084036.42: *6* listBuffers & listBuffersAlphabetically
def listBuffers (self,event):

    '''List all buffers (node headlines), in outline order.
    Nodes with the same headline are disambiguated by giving their parent or child index.
    '''

    self.computeData()
    g.es('buffers...')
    for name in self.nameList:
        g.es('',name)

def listBuffersAlphabetically (self,event):

    '''List all buffers (node headlines), in alphabetical order.
    Nodes with the same headline are disambiguated by giving their parent or child index.'''

    self.computeData()
    names = self.nameList[:] ; names.sort()

    g.es('buffers...')
    for name in names:
        g.es('',name)
#@+node:ekr.20050920084036.39: *6* prependToBuffer
def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Prepend to buffer: ')
        self.getBufferName(event,self.prependToBufferFinisher)

def prependToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('prepend-to-buffer: %s' % p.h)
        w.insert(0,s)
        w.setInsertPoint(0)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
#@+node:ekr.20050920084036.43: *6* renameBuffer
def renameBuffer (self,event):

    '''Rename a buffer, i.e., change a node's headline.'''

    g.es('rename-buffer not ready yet')
    if 0:
        self.k.setLabelBlue('Rename buffer from: ')
        self.getBufferName(event,self.renameBufferFinisher1)

def renameBufferFinisher1 (self,name):

    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    event = None
    self.getBufferName(event,self.renameBufferFinisher2)

def renameBufferFinisher2 (self,name):

    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.setHeadString(p,name)
        c.redraw(p)
#@+node:ekr.20050920084036.40: *6* switchToBuffer
def switchToBuffer (self,event):

    '''Select a buffer (node) by its name (headline).'''

    self.k.setLabelBlue('Switch to buffer: ')
    self.getBufferName(event,self.switchToBufferFinisher)

def switchToBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

#@+node:ekr.20050927102133.1: *5* Utils
#@+node:ekr.20051215121416: *6* computeData
def computeData (self):

    self.nameList = []
    self.names = {} ; self.tnodes = {}

    for p in self.c.all_unique_positions():
        h = p.h.strip()
        v = p.v
        nameList = self.names.get(h,[])
        if nameList:
            if p.parent():
                key = '%s, parent: %s' % (h,p.parent().h)
            else:
                key = '%s, child index: %d' % (h,p.childIndex())
        else:
            key = h
        self.nameList.append(key)
        self.tnodes[key] = v
        nameList.append(key)
        self.names[h] = nameList
#@+node:ekr.20051215164823: *6* findBuffer
def findBuffer (self,name):

    v = self.tnodes.get(name)

    for p in self.c.all_unique_positions():
        if p.v == v:
            return p

    g.trace("Can't happen",name)
    return None
#@+node:ekr.20050927093851: *6* getBufferName (added event arg)
def getBufferName (self,event,finisher):

    '''Get a buffer name into k.arg and call k.setState(kind,n,handler).'''

    c,k = self.c,self.k
    state = k.getState('getBufferName')

    if state == 0:
        self.computeData()
        self.getBufferNameFinisher = finisher
        prefix = k.getLabel()
        k.getArg(event,'getBufferName',1,self.getBufferName,
            prefix=prefix,tabList=self.nameList)
    else:
        k.resetLabel()
        k.clearState()
        finisher = self.getBufferNameFinisher
        self.getBufferNameFinisher = None
        finisher(k.arg)
#@+node:ekr.20070522085324: *4* ChapterCommandsClass
class ChapterCommandsClass (BaseEditCommandsClass):

    @others
#@+node:ekr.20070522085340: *5*  ctor (ChapterCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    # c.chapterController does not exist yet.
#@+node:ekr.20070522085429: *5*  getPublicCommands (ChapterCommandsClass)
def getPublicCommands (self):

    c = self.c ; cc = c.chapterController

    if cc:
        return {
            'chapter-clone-node-to':    cc.cloneNodeToChapter,
            'chapter-convert-node-to':  cc.convertNodeToChapter,
            'chapter-copy-node-to':     cc.copyNodeToChapter,
            'chapter-create':           cc.createChapter,
            'chapter-create-from-node': cc.createChapterFromNode,
            'chapter-move-node-to':     cc.moveNodeToChapter,
            'chapter-remove':           cc.removeChapter,
            'chapter-rename':           cc.renameChapter,
            'chapter-select':           cc.selectChapter,
        }
    else:
        return {}
#@+node:ekr.20050920084036.150: *4* ControlCommandsClass
class ControlCommandsClass (BaseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.151: *5*  ctor (ControlCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.payload = None
#@+node:ekr.20050920084036.152: *5*  getPublicCommands
def getPublicCommands (self):

    k = self.c.k

    return {

        # Miscellaneous.
        'advertised-undo':          self.advertizedUndo,
        'iconify-frame':            self.iconifyFrame, # Same as suspend.
        'keyboard-quit':            k and k.keyboardQuit,
        'save-buffers-kill-leo':    self.saveBuffersKillLeo,
        'set-silent-mode':          self.setSilentMode,
        'suspend':                  self.suspend,
        'act-on-node':              self.actOnNode,

        # Plugin info.
        'print-plugin-handlers':    self.printPluginHandlers,
        'print-plugins-info':       self.printPluginsInfo,

        # Shell commands.
        'shell-command':            self.shellCommand,
        'shell-command-on-region':  self.shellCommandOnRegion,
    }
#@+node:ekr.20050922110030: *5* advertizedUndo
def advertizedUndo (self,event):

    '''Undo the previous command.'''

    self.c.undoer.undo()
#@+node:ekr.20050920084036.160: *5* executeSubprocess
def executeSubprocess (self,event,command):
    '''Execute a command in a separate process.'''
    k = self.k
    try:
        args = shlex.split(g.toEncodedString(command))
        subprocess.Popen(args).wait()
    except Exception:
        g.es_exception()
    k.keyboardQuit()
        # Inits vim mode too.
    g.es('Done: %s' % command)
#@+node:ekr.20070429090859: *5* print plugins info...
def printPluginHandlers (self,event=None):

    '''Print the handlers for each plugin.'''

    g.app.pluginsController.printHandlers(self.c)

def printPlugins (self,event=None):

    '''Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.'''

    g.app.pluginsController.printPlugins(self.c)

def printPluginsInfo (self,event=None):

    '''Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.'''

    g.app.pluginsController.printPluginsInfo(self.c)
#@+node:ekr.20060603161041: *5* setSilentMode
def setSilentMode (self,event=None):

    '''Set the mode to be run silently, without the minibuffer.
    The only use for this command is to put the following in an @mode node::

        --> set-silent-mode'''

    self.c.k.silentMode = True
#@+node:ekr.20050920084036.158: *5* shellCommand
def shellCommand (self,event):
    '''Execute a shell command.'''
    k = self.k
    state = k.getState('shell-command')
    if state == 0:
        k.setLabelBlue('shell-command: ')
        k.getArg(event,'shell-command',1,self.shellCommand)
    else:
        command = k.arg
        # k.commandName = 'shell-command: %s' % command
        # k.clearState()
        self.executeSubprocess(event,command)
#@+node:ekr.20050930112126: *5* shellCommandOnRegion
def shellCommandOnRegion (self,event):
    '''Execute a command taken from the selected text in a separate process.'''
    k = self.k
    w = self.editWidget(event)
    if w:
        if w.hasSelection():
            command = w.getSelectedText()
            # k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event,command)
        else:
            # k.clearState()
            g.es('No text selected')
    k.keyboardQuit()
#@+node:ville.20090222184600.2: *5* actOnNode
def actOnNode(self, event):
    """ Execute node-specific action (typically defined by plugins)

    Actual behaviour is to be defined by plugins.

    Here's how to define actions for nodes in your plugins::

        import leo.core.leoPlugins
        def act_print_upcase(c,p,event):
            if not p.h.startswith('@up'):
                raise leo.core.leoPlugins.TryNext
            p.h = p.h.upper()

        g.act_on_node.add(act_print_upcase)        

    This will upcase the headline when it starts with @up.            

    """
    g.act_on_node(self.c,self.c.p,event)
#@+node:ekr.20050920084036.155: *5* shutdown, saveBuffersKillEmacs & setShutdownHook
def shutdown (self,event):

    '''Quit Leo, prompting to save any unsaved files first.'''

    g.app.onQuit()

saveBuffersKillLeo = shutdown
#@+node:ekr.20050920084036.153: *5* suspend & iconifyFrame
def suspend (self,event):

    '''Minimize the present Leo window.'''

    w = self.editWidget(event)
    if not w: return
    self.c.frame.top.iconify()

def iconifyFrame (self,event):

    '''Minimize the present Leo window.'''

    self.suspend(event)
#@+node:ekr.20060127162818.1: *4* DebugCommandsClass
class DebugCommandsClass (BaseEditCommandsClass):

    @others
#@+node:ekr.20060127162921: *5*  ctor (DebugCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.
#@+node:ekr.20060127163325: *5*  getPublicCommands
def getPublicCommands (self):

    return {

        # debugging.
        'debug':        self.invoke_debugger,
        'pdb':          self.pdb,
        'print-focus':  self.printFocus,

        # Tracing of garbase collecor.
        'gc-collect-garbage':       self.collectGarbage,
        'gc-dump-all-objects':      self.dumpAllObjects,
        'gc-dump-new-objects':      self.dumpNewObjects,
        'gc-dump-objects-verbose':  self.verboseDumpObjects,
        'gc-print-summary':         self.printGcSummary,
        'gc-trace-disable':         self.disableGcTrace,
        'gc-trace-enable':          self.enableGcTrace,

        # Unit tests run externally: deprecated.
        'run-all-unit-tests-externally':        self.runAllUnitTestsExternally,
            # was 'run-all-unit-tests.
        'run-marked-unit-tests-externally':     self.runMarkedUnitTestsExternally,
            # 2011/10/31: new.
        'run-selected-unit-tests-externally':   self.runSelectedUnitTestsExternally,
            # was 'run-unit-tests.

        # Unit tests run locally.
        'run-all-unit-tests-locally':       self.runAllUnitTestsLocally,
        'run-marked-unit-tests-locally':    self.runMarkedUnitTestsLocally,
            # 2011/10/31: new.
        'run-selected-unit-tests-locally':  self.runSelectedUnitTestsLocally,
    }
#@+node:ekr.20060205050659: *5* collectGarbage
def collectGarbage (self,event=None):

    """Run Python's Gargabe Collector."""

    g.collectGarbage()
#@+node:ekr.20060519003651: *5* invoke_debugger & helper
def invoke_debugger (self,event=None):

    '''Start an external debugger in another process to debug a script.
    The script is the presently selected text or then entire tree's script.'''

    c = self.c ; p = c.p
    python = sys.executable
    script = g.getScript(c,p)
    winpdb = self.findDebugger()
    if not winpdb: return

    #check for doctest examples
    try:
        import doctest
        parser = doctest.DocTestParser()
        examples = parser.get_examples(script)

        # if this is doctest, extract the examples as a script
        if len(examples) > 0:
            script = doctest.script_from_examples(script)
    except ImportError:
        pass

    # special case; debug code may include g.es("info string").
    # insert code fragment to make this expression legal outside Leo.
    hide_ges = "class G:\n def es(s,c=None):\n  pass\ng = G()\n"
    script = hide_ges + script

    # Create a temp file from the presently selected node.
    filename = c.writeScriptFile(script)
    if not filename: return

    # Invoke the debugger, retaining the present environment.
    os.chdir(g.app.loadDir)
    if False and subprocess:
        cmdline = '%s %s -t %s' % (python,winpdb,filename)
        subprocess.Popen(cmdline)
    else:
        args = [sys.executable, winpdb, '-t', filename]
        os.spawnv(os.P_NOWAIT, python, args)
#@+node:ekr.20060521140213: *6* findDebugger
def findDebugger (self):

    '''Find the debugger using settings.'''

    c = self.c
    pythonDir = g.os_path_dirname(sys.executable)

    debuggers = (
        c.config.getString('debugger_path'),
        g.os_path_join(pythonDir,'Lib','site-packages','winpdb.py'), # winpdb 1.1.2 or newer
        g.os_path_join(pythonDir,'scripts','_winpdb.py'), # oder version.
    )

    for debugger in debuggers:
        if debugger:
            debugger = c.os_path_finalize(debugger)
            if g.os_path_exists(debugger):
                return debugger
            else:
                g.warning('debugger does not exist:',debugger)
    g.es('no debugger found.')
    return None
#@+node:ekr.20060202160523: *5* dumpAll/New/VerboseObjects
def dumpAllObjects (self,event=None):

    '''Print a summary of all existing Python objects.'''

    old = g.trace_gc
    g.trace_gc = True
    g.printGcAll()
    g.trace_gc = old

def dumpNewObjects (self,event=None):

    '''Print a summary of all Python objects created
    since the last time Python's Garbage collector was run.'''

    old = g.trace_gc
    g.trace_gc = True
    g.printGcObjects()
    g.trace_gc = old

def verboseDumpObjects (self,event=None):

    '''Print a more verbose listing of all existing Python objects.'''

    old = g.trace_gc
    g.trace_gc = True
    g.printGcVerbose()
    g.trace_gc = old
#@+node:ekr.20060127163325.1: *5* enable/disableGcTrace
def disableGcTrace (self,event=None):

    '''Enable tracing of Python's Garbage Collector.'''

    g.trace_gc = False


def enableGcTrace (self,event=None):

    '''Disable tracing of Python's Garbage Collector.'''

    g.trace_gc = True
    g.enable_gc_debug()

    if g.trace_gc_verbose:
        g.blue('enabled verbose gc stats')
    else:
        g.blue('enabled brief gc stats')
#@+node:ekr.20060202154734: *5* freeTreeWidgets
def freeTreeWidgets (self,event=None):

    '''Free all widgets used in Leo's outline pane.'''

    c = self.c

    c.frame.tree.destroyWidgets()
    c.redraw()
#@+node:ekr.20090226080753.8: *5* pdb
def pdb (self,event=None):

    '''Fall into pdb.'''

    g.pdb()
#@+node:ekr.20060210100432: *5* printFocus
# Doesn't work if the focus isn't in a pane with bindings!

def printFocus (self,event=None):

    '''Print information about the requested focus (for debugging).'''

    c = self.c

    g.es_print('      hasFocusWidget:',c.widget_name(c.hasFocusWidget))
    g.es_print('requestedFocusWidget:',c.widget_name(c.requestedFocusWidget))
    g.es_print('           get_focus:',c.widget_name(c.get_focus()))
#@+node:ekr.20060205043324.3: *5* printGcSummary
def printGcSummary (self,event=None):

    '''Print a brief summary of all Python objects.'''

    g.printGcSummary()
#@+node:ekr.20060202133313: *5* printStats
def printStats (self,event=None):

    '''Print statistics about the objects that Leo is using.'''

    c = self.c
    c.frame.tree.showStats()
    self.dumpAllObjects()
#@+node:ekr.20060328121145: *5* runUnitTest commands
def runAllUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    self.c.testManager.doTests(all=True)

def runMarkedUnitTestsLocally (self,event=None):
    '''Run marked unit tests in the outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    self.c.testManager.doTests(all=True,marked=True)

def runSelectedUnitTestsLocally (self,event=None):
    '''Run all unit tests contained in the presently selected outline.
    Tests are run in the outline's process, so tests *can* change the outline.'''
    self.c.testManager.doTests(all=False,marked=False)

# Externally run tests...

def runAllUnitTestsExternally (self,event=None):
    '''Run all unit tests contained in the entire outline.
    Tests are run in an external process, so tests *cannot* change the outline.'''
    self.c.testManager.runTestsExternally(all=True,marked=False)

def runMarkedUnitTestsExternally(self,event=None):
    '''Run all marked unit tests in the outline.
    Tests are run in an external process, so tests *cannot* change the outline.'''
    self.c.testManager.runTestsExternally(all=True,marked=True)

def runSelectedUnitTestsExternally(self,event=None):
    '''Run all unit tests contained in the presently selected outline
    Tests are run in an external process, so tests *cannot* change the outline.'''
    self.c.testManager.runTestsExternally(all=False,marked=False)
#@+node:ekr.20050920084036.53: *4* EditCommandsClass
class EditCommandsClass (BaseEditCommandsClass):

    '''Contains editing commands with little or no state.'''

    @others
#@+node:ekr.20050929155208: *5*  birth
#@+node:ekr.20050920084036.54: *6*  ctor (EditCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.ccolumn = '0'   # For comment column functions.
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 0 # For line centering.
        # Set by the set-fill-column command.
        # If zero, @pagewidth value is used.
    self.moveSpotNode = None # A VNode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.sampleWidget = None # Created later.
    self.swapSpots = []
    self._useRegex = False # For replace-string
    self.w = None # For use by state handlers.

    # Settings...
    cf = c.config
    self.autocompleteBrackets   = cf.getBool('autocomplete-brackets')
    self.bracketsFlashBg        = cf.getColor('flash-brackets-background-color')
    self.bracketsFlashCount     = cf.getInt('flash-brackets-count')
    self.bracketsFlashDelay     = cf.getInt('flash-brackets-delay')
    self.bracketsFlashFg        = cf.getColor('flash-brackets-foreground-color')
    self.flashMatchingBrackets  = cf.getBool('flash-matching-brackets')
    self.smartAutoIndent        = cf.getBool('smart_auto_indent')
    self.openBracketsList       = cf.getString('open_flash_brackets')  or '([{'
    self.closeBracketsList      = cf.getString('close_flash_brackets') or ')]}'

    self.initBracketMatcher(c)
#@+node:ekr.20050920084036.55: *6*  getPublicCommands (EditCommandsClass)
def getPublicCommands (self):        

    c = self.c

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body and c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-to-home':                         self.backToHome,
        'back-to-home-extend-selection':        self.backToHomeExtendSelection,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-page':                            self.backPage,
        'back-page-extend-selection':           self.backPageExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'back-word-smart':                      self.backwardWordSmart,
        'back-word-smart-extend-selection':     self.backwardWordSmartExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-delete-word':                 self.backwardDeleteWord,
        'backward-delete-word-smart':           self.backwardDeleteWordSmart,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'c-to-python':                          self.cToPy,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-all-caches':                     self.clearAllCaches,
        'clear-all-uas':                        self.clearAllUas,
        'clear-cache':                          self.clearCache,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-node-uas':                       self.clearNodeUas,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'clone-marked-nodes':                   c.cloneMarked,
        'cls':                                  g.cls,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'ctrl-click-icon':                      self.ctrlClickIconBox,
        'cycle-focus':                          self.cycleFocus,
        # 'cycle-all-focus':                    self.cycleAllFocus,
            # Replaced by focus-to-x commands.
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'cycle-log-focus':                      c.frame.log.cycleTabFocus,
        # 'delete-all-icons':                   self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-marked-nodes':                  c.deleteMarked,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'delete-word':                          self.deleteWord,
        'delete-word-smart':                    self.deleteWordSmart,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'find-word-in-line':                    self.findWordInLine,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-page':                         self.forwardPage,
        'forward-page-extend-selection':        self.forwardPageExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'forward-word-smart':                   self.forwardWordSmart,
        'forward-word-smart-extend-selection':  self.forwardWordSmartExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-hard-tab':                      self.insertHardTab,
        'insert-icon':                          self.insertIcon,
        'insert-file-name':                     self.insertFileName,
        'insert-headline-time':                 self.insertHeadlineTime,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'insert-soft-tab':                      self.insertSoftTab,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-marked-nodes':                    c.moveMarked,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'print-all-uas':                        self.printAllUas,
        'print-node-uas':                       self.printUas,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'replace-current-character':            self.replaceCurrentCharacter,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,
        'scroll-down-half-page':                self.scrollDownHalfPage,                
        'scroll-down-line':                     self.scrollDownLine,
        'scroll-down-page':                     self.scrollDownPage,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up-half-page':                  self.scrollUpHalfPage,                        
        'scroll-up-line':                       self.scrollUpLine,
        'scroll-up-page':                       self.scrollUpPage,
        'select-all':                           self.selectAllText,
        'select-to-matching-bracket':           self.selectToMatchingBracket,
        # Exists, but can not be executed via the minibuffer.
        'self-insert-command':                  self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'set-ua':                               self.setUa,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'toggle-case-region':                   self.toggleCaseRegion,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'typescript-to-py':                     self.tsToPy,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
#@+node:ekr.20061012113455: *6* doNothing
def doNothing (self,event):

    '''A placeholder command, useful for testing bindings.'''

    pass
#@+node:ekr.20110916215321.6709: *5* brackets (leoEditCommands)
#@+node:ekr.20110916215321.6708: *6* selectToMatchingBracket (leoEditCommands)
def selectToMatchingBracket (self,event):

    '''Select text that matches the bracket near the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    i = w.getInsertPoint()
    s = w.getAllText()
    allBrackets = self.openBracketsList + self.closeBracketsList
    if i < len(s) and s[i] in allBrackets:
        ch = s[i]
    elif i > 0 and s[i-1] in allBrackets:
        i -= 1
        ch = s[i]
    else:
        g.es('no bracket selected')
        return

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward
    delim2 = d.get(ch)

    # This should be generalized...
    language = g.findLanguageDirectives(c,c.p)
    if language in ('c','cpp','csharp'):
        j = g.skip_matching_c_delims(s,i,ch,delim2,reverse=reverse)
    else:
        j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    # g.trace(i,j,ch,delim2,reverse,language)
    if j not in (-1,i):
        if reverse:
            i += 1; j += 1
        w.setSelectionRange(i,j,insert=j)
            # 2011/11/21: Bug fix: was ins=j.
        w.see(j)
#@+node:ekr.20121016093159.10182: *5* c/ts/toPY
<< theory of operation >>
<< class To_Python >>
<< class C_To_Python (To_Python) >>
<< class TS_To_Python (To_Python) >>

def cToPy (self,event):

    ''' The c-to-python command converts c or c++ text to python text.
    The conversion is not perfect, but it eliminates a lot of tedious
    text manipulation.'''

    self.C_To_Python(self.c).go()
    self.c.bodyWantsFocus()

def tsToPy (self,event):

    ''' The typescript-to-python command converts typescript text to python
    text. The conversion is not perfect, but it eliminates a lot of tedious
    text manipulation.'''

    # Compiler stats: 35 files, 1489 nodes, 100 to 120 sec.
    self.TS_To_Python(self.c).go()
    self.c.bodyWantsFocus()
#@+node:ekr.20121016093159.10240: *6* << theory of operation >>
@nocolor
@

1. We use a single list, aList, for all changes to the text. This reduces
   stress on the gc. All replacesments are done **in place** in aList.

2. The following pattern ensures replacements do not happen in strings and comments::

    def someScan(self,aList):
        i = 0
        while i < len(aList):
            if self.is_string_or_comment(aList,i):
                i = skip_string_or_comment(aList,i)
            elif < found what we are looking for >:
                <convert what we are looking for, setting i>
            else: i += 1

#@+node:ekr.20121016093159.10183: *6* << class To_Python >>
class To_Python:

    '''The base class for x-to-python commands.'''

    @others
#@+node:ekr.20121016093159.10241: *7* ctor (To_Python)
def __init__ (self,c):

    self.c = c
    self.p = self.c.p.copy()

    aList = g.get_directives_dict_list(self.p)
    self.tab_width = g.scanAtTabwidthDirectives(aList) or 4
#@+node:ekr.20121016093159.10299: *7* go
def go (self):

    import time
    t1 = time.time()
    c = self.c
    u = c.undoer ; undoType = 'typescript-to-python'
    pp = c.CPrettyPrinter(c)

    u.beforeChangeGroup(c.p,undoType)
    changed, dirtyVnodeList = False,[]
    n_files, n_nodes = 0,0
    special = ('class ','module ','@file ','@@file ')
    files = ('@file ','@@file ')
    for p in self.p.self_and_subtree():
        if p.b:
            n_nodes += 1
            if any([p.h.startswith(z) for z in special]):
                g.es_print(p.h)
                if any([p.h.startswith(z) for z in files]):
                    n_files += 1
            bunch = u.beforeChangeNodeContents(p)

            s = pp.indent(p,giveWarnings=False)
            aList = list(s)
            self.convertCodeList(aList)

            s = ''.join(aList)
            if s != p.b:
                p.b = s
                p.v.setDirty()
                dirtyVnodeList.append(p.v)
                u.afterChangeNodeContents(p,undoType,bunch)
                changed = True

    # Call this only once, at end.
    if changed:
        u.afterChangeGroup(c.p,undoType,
            reportFlag=False,dirtyVnodeList=dirtyVnodeList)

    t2 = time.time()
    g.es_print('done! %s files, %s nodes, %2.2f sec' % (n_files,n_nodes,t2-t1))
#@+node:ekr.20121016093159.10245: *7* convertCodeList (must be defined in subclasses)
def convertCodeList(self,aList):

    '''The main search/replace method.'''

    g.trace('must be defined in subclasses.')
#@+node:ekr.20121016093159.10259: *7* Utils
#@+node:ekr.20121016093159.10260: *8* match...
#@+node:ekr.20121016093159.10261: *9* match
def match (self,s,i,pat):

    '''Return True if s[i:] matches the pat string.

    We can't use g.match because s is usually a list.
    '''

    assert pat

    j = 0
    while i+j < len(s) and j < len(pat):
        if s[i+j] == pat[j]:
            j += 1
            if j == len(pat):
                return True
        else:
            return False

    return False
#@+node:ekr.20121016093159.10293: *9* match_word
def match_word (self,s,i,pat):
    '''
    Return True if s[i:] word matches the pat string.

    We can't use g.match_word because s is usually a list
    and g.match_word uses s.find.
    '''
    if self.match(s,i,pat):
        j = i + len(pat)
        if j >= len(s):
            return True
        elif not pat[-1].isalnum():
            # Bug fix 10/16/2012: The pattern terminates the word.
            return True
        else:
            ch = s[j]
            return not ch.isalnum() and ch != '_'
    else:
        return False
#@+node:ekr.20121016093159.10247: *8* insert_not
# This may be defined in subclasses, but is not at present.

def insert_not (self,aList):

    '''Change "!" to "not" except before "="'''

    i = 0
    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif aList[i] == '!' and not self.match(aList,i+1,'='):
            aList[i:i+1] = list('not ')
            i += 4
        else:
            i += 1
#@+node:ekr.20121016093159.10263: *8* is...
#@+node:ekr.20121126103128.10144: *9* is_section_def/ref
def is_section_def (self,p):

    return self.is_section_ref(p.h)

def is_section_ref (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
#@+node:ekr.20121016093159.10265: *9* is_string_or_comment
def is_string_or_comment (self,s,i):

    # Does range checking.
    m = self.match
    return m(s,i,"'") or m(s,i,'"') or m(s,i,"//") or m(s,i,"/*")
#@+node:ekr.20121016093159.10266: *9* is_ws and is_ws_or_nl
def is_ws (self,ch):
    return ch in ' \t'

def is_ws_or_nl (self,ch):
    return ch in ' \t\n'
#@+node:ekr.20121016093159.10267: *8* prevNonWsChar and prevNonWsOrNlChar
def prevNonWsChar (self,s,i):

    i -= 1
    while i >= 0 and self.is_ws(s[i]):
        i -= 1
    return i

def prevNonWsOrNlChar (self,s,i):

    i -= 1
    while i >= 0 and self.is_ws_or_nl(s[i]):
        i -= 1
    return i
#@+node:ekr.20121016093159.10268: *8* remove...
#@+node:ekr.20121016093159.10269: *9* removeBlankLines
def removeBlankLines (self,aList):

    i = 0
    while i < len(aList):
        j = i
        while j < len(aList) and aList[j] in " \t":
            j += 1
        if j == len(aList) or aList[j] == '\n':
            del aList[i:j+1]
        else:
            i = self.skip_past_line(aList,i)
#@+node:ekr.20121016093159.10270: *9* removeExcessWs
def removeExcessWs (self,aList):

    i = 0
    i = self.removeExcessWsFromLine(aList,i)
    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif self.match(aList,i,'\n'):
            i += 1
            i = self.removeExcessWsFromLine(aList,i)
        else: i += 1
#@+node:ekr.20121016093159.10271: *9* removeExessWsFromLine
def removeExcessWsFromLine (self,aList,i):

    assert(i==0 or aList[i-1] == '\n')
    i = self.skip_ws(aList,i)
        # Retain the leading whitespace.

    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            break # safe
        elif self.match(aList,i,'\n'):
            break
        elif self.match(aList,i,' ') or self.match(aList,i,'\t'):
            # Replace all whitespace by one blank.
            j = self.skip_ws(aList,i)
            assert(j > i)
            aList[i:j] = [' ']
            i += 1 # make sure we don't go past a newline!
        else: i += 1
    return i
#@+node:ekr.20121016093159.10272: *9* removeMatchingBrackets
def removeMatchingBrackets (self,aList, i):

    j = self.skip_to_matching_bracket(aList, i)
    if j > i and j < len(aList):
        # print "del brackets:", ''.join(aList[i:j+1])
        c = aList[j]
        if c == ')' or c == ']' or c == '}':
            del aList[j:j+1]
            del aList[i:i+1]
            # print "returning:", ''.join(aList[i:j])
            return j - 1
        else: return j + 1
    else: return j
#@+node:ekr.20121016093159.10273: *9* removeSemicolonsAtEndOfLines
def removeSemicolonsAtEndOfLines (self,aList):

    i = 0
    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif aList[i] == ';':
            j = self.skip_ws(aList,i+1)
            if (
                j >= len(aList) or
                self.match(aList,j,'\n') or
                self.match(aList,j,'#') or
                self.match(aList,j,"//")
            ):
                del aList[i]
            else: i += 1
        else: i += 1
#@+node:ekr.20121016093159.10274: *9* removeTrailingWs
def removeTrailingWs (self,aList):

    i = 0
    while i < len(aList):
        if self.is_ws(aList[i]):
            j = i
            i = self.skip_ws(aList,i)
            assert(j < i)
            if i >= len(aList) or aList[i] == '\n':
                # print "removing trailing ws:", `i-j`
                del aList[j:i]
                i = j
        else: i += 1
#@+node:ekr.20121016093159.10275: *8* replace... & safe_replace
#@+node:ekr.20121016093159.10276: *9* replace
def replace (self,aList,findString,changeString):

    '''# Replaces all occurances of findString by changeString.
    changeString may be the empty string, but not None.
    '''

    if not findString: return

    changeList = list(changeString)
    i = 0
    while i < len(aList):
        if self.match(aList,i,findString):
            aList[i:i+len(findString)] = changeList
            i += len(changeList)
        else:
            i += 1
#@+node:ekr.20121016093159.10277: *9* replaceComments
def replaceComments (self,aList):

    i = 0
    while i < len(aList):
        # Loop invariant: j > progress at end.
        progress = i
        if self.match(aList,i,"//"):
            aList[i:i+2] = ['#']
            j = self.skip_past_line(aList,i)
        elif self.match(aList,i,"/*"):
            j = self.skip_c_block_comment(aList,i)
            k = i
            while k-1 >= 0 and aList[k-1] in ' \t':
                k -= 1
            assert k == 0 or aList[k-1] not in ' \t'
            lws = ''.join(aList[k:i])
            comment_body = ''.join(aList[i+2:j-2])
            comment_lines = g.splitLines(lws + comment_body)
            comment_lines = self.munge_block_comment(comment_lines)
            comment = '\n'.join(comment_lines) # A list of lines.
            comment_list = list(comment) # A list of characters.
            aList[k:j] = comment_list
            j = k + len(comment_list)
            progress = j - 1 # Disable the check below.
        elif self.match(aList,i,'"') or self.match(aList,i,"'"):
            j = self.skip_string(aList,i)
        else:
            j = i+1

        # Defensive programming.
        if j == progress:
            j += 1
        assert j > progress
        i = j
#@+node:ekr.20121016093159.10278: *10* munge_block_comment
def munge_block_comment (self,comment_lines):

    trace = False
    n = len(comment_lines)
    assert n > 0

    s = comment_lines[0]
    junk,w = g.skip_leading_ws_with_indent(s,0,tab_width=4)

    if n == 1:
        return ['%s# %s' % ((' ' * (w-1)),s.strip())]

    junk,w = g.skip_leading_ws_with_indent(s,0,tab_width=4)
    i,result = 0,[]
    for i in range(len(comment_lines)):
        s = comment_lines[i]
        if s.strip():
            result.append('%s# %s' % ((' ' * w),s.strip()))
        elif i == n-1:
            pass # Omit the line entirely.
        else:
            result.append('') # Add a blank line

    if trace:
        g.trace()
        for z in result: print(repr(z))

    return result
#@+node:ekr.20121016093159.10279: *9* replaceSectionDefs
def replaceSectionDefs (self,aList):

    '''Replaces < < x > > = by @c (at the start of lines).'''

    if not aList: return
    i = 0
    j = self.is_section_def(aList[i])
    if j > 0: aList[i:j] = list("@c ")

    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif self.match(aList,i,"\n"):
            i += 1
            j = self.is_section_def(aList[i])
            if j > i: aList[i:j] = list("@c ")
        else: i += 1
#@+node:ekr.20121016093159.10280: *9* safe_replace
def safe_replace (self,aList,findString,changeString):

    '''Replaces occurances of findString by changeString,
    but only outside of C comments and strings.
    changeString may be the empty string, but not None.
    '''

    if not findString: return

    changeList = list(changeString)
    i = 0
    if findString[0].isalpha(): # use self.match_word
        while i < len(aList):
            if self.is_string_or_comment(aList,i):
                i = self.skip_string_or_comment(aList,i)
            elif self.match_word(aList,i,findString):
                aList[i:i+len(findString)] = changeList
                i += len(changeList)
            else:
                i += 1
    else: #use self.match
        while i < len(aList):
            if self.match(aList,i,findString):
                aList[i:i+len(findString)] = changeList
                i += len(changeList)
            else:
                i += 1
#@+node:ekr.20121016093159.10281: *8* skip
#@+node:ekr.20121016093159.10282: *9* skip_c_block_comment
def skip_c_block_comment (self,s,i):

    # if 'replaceComments' in g.callers():
        # g.trace(repr(''.join(s[i:i+20])))

    assert(self.match(s,i,"/*"))
    i += 2

    while i < len(s):
        if self.match(s,i,"*/"):
            return i + 2
        else:
            i += 1

    return i
#@+node:ekr.20121016093159.10298: *9* skip_line
def skip_line (self,s,i):

    while i < len(s) and s[i] != '\n':
        i += 1
    return i
#@+node:ekr.20121016093159.10283: *9* skip_past_line
def skip_past_line (self,s,i):

    while i < len(s) and s[i] != '\n':
        i += 1
    if i < len(s) and s[i] == '\n':
        i += 1
    return i
#@+node:ekr.20121016093159.10284: *9* skip_past_word
def skip_past_word (self,s,i):

    assert(s[i].isalpha() or s[i]=='~')

    # Kludge: this helps recognize dtors.
    if s[i]=='~':
        i += 1

    while i < len(s):
        ch = s[i]
        if ch.isalnum() or ch =='_':
            i += 1
        else:
            break
    return i
#@+node:ekr.20121016093159.10285: *9* skip_string
def skip_string (self,s,i):

    delim = s[i] # handle either single or double-quoted strings
    assert(delim == '"' or delim == "'")
    i += 1

    while i < len(s):
        if s[i] == delim:
            return i + 1
        elif s[i] == '\\':
            i += 2
        else:
            i += 1
    return i
#@+node:ekr.20121016093159.10286: *9* skip_string_or_comment
def skip_string_or_comment (self,s,i):

    if self.match(s,i,"'") or self.match(s,i,'"'):
        j = self.skip_string(s,i)
    elif self.match(s,i,"//"):
        j = self.skip_past_line(s,i)
    elif self.match(s,i,"/*"):
        j = self.skip_c_block_comment(s,i)
    else: assert(0)

    # g.trace(repr(''.join(s[i:j])))
    return j
#@+node:ekr.20121016093159.10287: *9* skip_to_matching_bracket
def skip_to_matching_bracket (self,s,i):

    ch = s[i]
    if   ch == '(': delim = ')'
    elif ch == '{': delim = '}'
    elif ch == '[': delim = ']'
    else: assert(0)

    i += 1
    while i < len(s):
        ch = s[i]
        if self.is_string_or_comment(s,i):
            i = self.skip_string_or_comment(s,i)
        elif ch == delim:
            return i
        elif ch == '(' or ch == '[' or ch == '{':
            i = self.skip_to_matching_bracket(s,i)
            i += 1 # skip the closing bracket.
        else: i += 1
    return i
#@+node:ekr.20121016093159.10288: *9* skip_ws and skip_ws_and_nl
def skip_ws (self,aList,i):

    while i < len(aList):
        c = aList[i]
        if c == ' ' or c == '\t':
            i += 1
        else: break
    return i

def skip_ws_and_nl (self,aList,i):

    while i < len(aList):
        c = aList[i]
        if c == ' ' or c == '\t' or c == '\n':
            i += 1
        else: break
    return i
#@+node:ekr.20121016093159.10184: *6* << class C_To_Python (To_Python) >>
class C_To_Python (To_Python):

    @others
#@+node:ekr.20110916215321.8057: *7* ctor & helpers (C_to_Python)
def __init__ (self,c):

    c.editCommands.To_Python.__init__(self,c)
        # init the base class

    # Internal state...
    self.class_name = ''
        # The class name for the present function.  Used to modify ivars.

    self.ivars = []
        # List of ivars to be converted to self.ivar


    self.get_user_types()
#@+node:ekr.20110916215321.7984: *8* get_user_types
@nocolor
@

Change the following lists so they contain the types and classes used by your
program. c-to-python converts::

    new aType(...)

to::

    aType(...)

Change ivarsDict so it represents the instance variables (ivars) used by your
program's classes. ivarsDict is a dictionary used to translate ivar i of class c
to self.i. It also translates this->i to self.i.

@c
@color

def get_user_types (self):

    c = self.c

    self.class_list = c.config.getData('c-to-python-class-list') or []

    self.type_list  = (
        c.config.getData('c-to-python-type-list') or
        ["char", "void", "short", "long", "int", "double", "float"]
    )
    aList = c.config.getData('c-to-python-ivars-dict')
    if aList:
        self.ivars_dict = self.parse_ivars_data(aList)
    else:
        self.ivars_dict = {}

    if 0:
        #g.trace('class_list',self.class_list)
        #g.trace('type_list',self.type_list)
        g.trace('ivars_dict...')
        d = self.ivars_dict
        keys = list(d.keys())
        for key in sorted(keys):
            print('%s:' % (key))
            for val in d.get(key):
                print('  %s' % (val))

#@+node:ekr.20110917104720.6877: *8* parse_ivars_data
def parse_ivars_data (self,aList):

    d,key = {},None
    aList = [z.strip() for z in aList if z.strip()]
    for s in aList:
        if s.endswith(':'):
            key = s[:-1].strip()
        elif key:
            ivars = [z.strip() for z in s.split(',') if z.strip()]
            aList = d.get(key,[])
            aList.extend(ivars)
            d [key] = aList
        else:
            g.error('invalid @data c-to-python-ivars-dict',repr(s))
            return {}

    return d
#@+node:ekr.20110916215321.7997: *7* convertCodeList (C_To_Python) & helpers
def convertCodeList(self,aList):

    r,sr = self.replace,self.safe_replace

    # First...
    r(aList, "\r", '')
    # self.convertLeadingBlanks(aList) # Now done by indent.
    # if leoFlag: replaceSectionDefs(aList)
    self.mungeAllFunctions(aList)

    # Next...
    if 1:
        # CC2 stuff:
        sr(aList, "TRACEPB",   "if trace: g.trace")
        sr(aList, "TRACEPN",   "if trace: g.trace")
        sr(aList, "TRACEPX",   "if trace: g.trace")
        sr(aList, "TICKB",     "if trace: g.trace")
        sr(aList, "TICKN",     "if trace: g.trace")
        sr(aList, "TICKX",     "if trace: g.trace")
        sr(aList, "g.trace(ftag,", "g.trace(")
        sr(aList, "ASSERT_TRACE", "assert")

    sr(aList, "ASSERT","assert")
    sr(aList, " -> ", '.')
    sr(aList, "->", '.')
    sr(aList, " . ", '.')
    sr(aList, "this.self", "self")
    sr(aList, "{", '')
    sr(aList, "}", '')
    sr(aList, "#if", "if")
    sr(aList, "#else", "else")
    sr(aList, "#endif", '')
    sr(aList, "else if", "elif")
    sr(aList, "else", "else:")
    sr(aList, "&&", " and ")
    sr(aList, "||", " or ")
    sr(aList, "TRUE", "True")
    sr(aList, "FALSE", "False")
    sr(aList, "NULL", "None")
    sr(aList, "this", "self")
    sr(aList, "try", "try:")
    sr(aList, "catch", "except:")
    # if leoFlag: sr(aList, "@code", "@c")

    # Next...
    self.handle_all_keywords(aList)
    self.insert_not(aList)
    self.removeSemicolonsAtEndOfLines(aList)
        # after processing for keywords

    # Last...
    # if firstPart and leoFlag: removeLeadingAtCode(aList)
    self.removeBlankLines(aList)
    self.removeExcessWs(aList)
    # your taste may vary: in Python I don't like extra whitespace
    sr(aList, " :", ":") 
    sr(aList, ", ", ",")
    sr(aList, " ,", ",")
    sr(aList, " (", "(")
    sr(aList, "( ", "(")
    sr(aList, " )", ")")
    sr(aList, ") ", ")")
    sr(aList, "@language c","@language python")
    self.replaceComments(aList) # should follow all calls to safe_replace
    self.removeTrailingWs(aList)
    r(aList, "\t ", "\t") # happens when deleting declarations.
#@+node:ekr.20110916215321.8011: *8* handle_all_keywords
def handle_all_keywords (self,aList):

    '''
    converts if ( x ) to if x:
    converts while ( x ) to while x:
    '''

    i = 0
    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif (
            self.match_word(aList,i,"if") or
            self.match_word(aList,i,"while") or
            self.match_word(aList,i,"for") or
            self.match_word(aList,i,"elif")
        ):
            i = self.handle_keyword(aList,i)
        else:
            i += 1
    # print "handAllKeywords2:", ''.join(aList)
#@+node:ekr.20110916215321.8012: *9* handle_keyword
def handle_keyword (self,aList,i):

    if self.match_word(aList,i,"if"):
        i += 2
    elif self.match_word(aList,i,"elif"):
        i += 4
    elif self.match_word(aList,i,"while"):
        i += 5
    elif self.match_word(aList,i,"for"):
        i += 3
    else: assert(0)

    # Make sure one space follows the keyword.
    k = i
    i = self.skip_ws(aList,i)
    if k == i:
        c = aList[i]
        aList[i:i+1] = [ ' ', c ]
        i += 1

    # Remove '(' and matching ')' and add a ':'
    if aList[i] == "(":
        # Look ahead.  Don't remove if we span a line.
        j = self.skip_to_matching_bracket(aList, i)
        k = i
        found = False
        while k < j and not found:
            found = aList[k] == '\n'
            k += 1
        if not found:
            j = self.removeMatchingBrackets(aList,i)
        if j > i and j < len(aList):
            ch = aList[j]
            aList[j:j+1] = [ch,":", " "]
            j = j + 2
        return j
    return i
#@+node:ekr.20110916215321.8003: *8* mungeAllFunctions
def mungeAllFunctions(self,aList):

    '''Scan for a '{' at the top level that is preceeded by ')' '''

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i < len(aList):
        progress = i
        if self.is_string_or_comment(aList,i):
            j = self.skip_string_or_comment(aList,i)
            prevSemi = j
        elif self.match(aList,i,'('):
            if not firstOpen:
                firstOpen = i
            j = i + 1
        elif self.match(aList,i,'#'):
            # At this point, it is a preprocessor directive.
            j = self.skip_past_line(aList, i)
            prevSemi = j
        elif self.match(aList,i,';'):
            j = i + 1
            prevSemi = j
        elif self.match(aList,i,"{"):
            j = self.handlePossibleFunctionHeader(aList,i,prevSemi,firstOpen)
            prevSemi = j
            firstOpen = None # restart the scan
            # g.trace(repr(''.join(aList[prevSemi:prevSemi+20])))
        else:
            j = i + 1

        # Handle unusual cases.
        if j <= progress:
            j = progress + 1
        assert j > progress

        i = j
#@+node:ekr.20110916215321.8004: *9* handlePossibleFunctionHeader
# converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader (self,aList,i,prevSemi,firstOpen):

    trace = False
    assert(self.match(aList,i,"{"))

    prevSemi = self.skip_ws_and_nl(aList, prevSemi)
    close = self.prevNonWsOrNlChar(aList,i)

    if close < 0 or aList[close] != ')':
        # Should not increase *Python* indent.
        return 1 + self.skip_to_matching_bracket(aList,i)

    if not firstOpen:
        return 1 + self.skip_to_matching_bracket(aList,i)

    close2 = self.skip_to_matching_bracket(aList, firstOpen)
    if close2 != close:
        return 1 + self.skip_to_matching_bracket(aList,i)

    open_paren = firstOpen
    assert(aList[open_paren]=='(')
    head = aList[prevSemi:open_paren]

    # do nothing if the head starts with "if", "for" or "while"
    k = self.skip_ws(head,0)
    if k >= len(head) or not head[k].isalpha():
        return 1 + self.skip_to_matching_bracket(aList,i)

    kk = self.skip_past_word(head,k)
    if kk > k:
        headString = ''.join(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + self.skip_to_matching_bracket(aList, i)

    args = aList[open_paren:close+1]
    k = 1 + self.skip_to_matching_bracket(aList,i)
    body = aList[close+1:k]

    if True and trace:
        g.trace('\nhead: %s\nargs: %s\nbody: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    head = self.massageFunctionHead(head)
    args = self.massageFunctionArgs(args)
    body = self.massageFunctionBody(body)

    if False and trace:
        g.trace('\nhead2: %s\nargs2: %s\nbody2: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    result = []
    if head: result.extend(head)
    if args: result.extend(args)
    if body: result.extend(body)

    aList[prevSemi:k] = result
    return prevSemi + len(result)
#@+node:ekr.20110916215321.8005: *9* massageFunctionArgs
def massageFunctionArgs (self,args):

    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if self.class_name:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i < len(args):
        i = self.skip_ws_and_nl(args, i)
        c = args[i]
        if c.isalpha():
            j = self.skip_past_word(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", ''.join(result)
    return result
#@+node:ekr.20110916215321.8006: *9* massageFunctionHead (sets .class_name)
def massageFunctionHead (self,head):

    result = []
    prevWord = []
    self.class_name = ''
    i = 0
    # g.trace(repr(''.join(head)))
    while i < len(head):
        i = self.skip_ws_and_nl(head,i)
        if i < len(head) and head[i].isalpha():
            result = []
            j = self.skip_past_word(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = self.skip_ws(head,i)
            if self.match(head,i,"::"):
                # Set the global to the class name.
                self.class_name = ''.join(prevWord)
                # print(class name:", self.class_name)
                i = self.skip_ws(head,i+2)
                if i < len(head) and (head[i]=='~' or head[i].isalpha()):
                    j = self.skip_past_word(head,i)
                    if head[i:j] == prevWord:
                        result.extend('__init__')
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        result.extend('__del__')
                    else:
                        # result.extend(list('::'))
                        result.extend(head[i:j])
                    i = j
            else:
                result.extend(prevWord)
        else: i += 1

    finalResult = list("def ")
    finalResult.extend(result)
    return finalResult
#@+node:ekr.20110916215321.8007: *9* massageFunctionBody & helpers
def massageFunctionBody (self,body):

    body = self.massageIvars(body)
    body = self.removeCasts(body)
    body = self.removeTypeNames(body)
    body = self.dedentBlocks(body)
    return body
#@+node:ekr.20110919224143.6928: *10* dedentBlocks
def dedentBlocks (self,body):

    '''Look for '{' preceded by '{' or '}' or ';'
    (with intervening whitespace and comments).
    '''

    i = 0
    while i < len(body):
        j = i
        ch = body[i]
        if self.is_string_or_comment(body,i):
            j = self.skip_string_or_comment(body,i)
        elif ch in '{};':
            # Look ahead ofr '{'
            j += 1
            while True:
                k = j
                j = self.skip_ws_and_nl(body,j)
                if self.is_string_or_comment(body,j):
                    j = self.skip_string_or_comment(body,j)
                if k == j: break
                assert k < j
            if self.match(body,j,'{'):
                k = j
                j = self.skip_to_matching_bracket(body,j)
                # g.trace('found block\n',''.join(body[k:j+1]))
                m = '# <Start dedented block>...'
                body[k:k+1] = list(m)
                j += len(m)
                while k < j:
                    progress = k
                    if body[k] == '\n':
                        k += 1
                        spaces = 0
                        while spaces < 4 and k < j:
                            if body[k] == ' ':
                                spaces += 1
                                k += 1
                            else:
                                break
                        if spaces > 0:
                            del body[k-spaces:k]
                            k -= spaces
                            j -= spaces
                    else:
                        k += 1
                    assert progress < k
                m = '    # <End dedented block>'
                body[j:j+1] = list(m)
                j += len(m)
        else:
            j = i + 1

        # Defensive programming.
        if i == j:
            j += 1
        assert i < j
        i = j

    return body
#@+node:ekr.20110916215321.8008: *10* massageIvars
def massageIvars (self,body):

    ivars = self.ivars_dict.get(self.class_name,[])
    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body
#@+node:ekr.20110916215321.8009: *10* removeCasts
def removeCasts (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match(body, i, '('):
            start = i
            i = self.skip_ws(body, i+1)
            if body[i].isalpha():
                j = self.skip_past_word(body,i)
                word = ''.join(body[i:j])
                i = j
                if word in self.class_list or word in self.type_list:
                    i = self.skip_ws(body, i)
                    while self.match(body,i,'*'):
                        i += 1
                    i = self.skip_ws(body, i)
                    if self.match(body,i,')'):
                        i += 1
                        # print "removing cast:", ''.join(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body
#@+node:ekr.20110916215321.8010: *10* removeTypeNames
# Do _not_ remove type names when preceeded by new.

def removeTypeNames (self,body):

    i = 0
    while i < len(body):
        if self.is_string_or_comment(body,i):
            i = self.skip_string_or_comment(body,i)
        elif self.match_word(body, i, "new"):
            i = self.skip_past_word(body,i)
            i = self.skip_ws(body,i)
            # don't remove what follows new.
            if body[i].isalpha():
                i = self.skip_past_word(body,i)
        elif body[i].isalpha():
            j = self.skip_past_word(body,i)
            word = ''.join(body[i:j])
            if word in self.class_list or word in self.type_list:
                j = self.skip_ws(body,j)
                while self.match(body,j,'*'):
                    j += 1
                # print "Deleting type name:", ''.join(body[i:j])
                j = self.skip_ws(body,j)
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body
#@+node:ekr.20121016093159.10185: *6* << class TS_To_Python (To_Python) >>
class TS_To_Python (To_Python):

    @others
#@+node:ekr.20121016093159.10297: *7* ctor (TS_To_Python)
def __init__ (self,c):

    c.editCommands.To_Python.__init__(self,c)
        # init the base class

    self.class_name = ''
        # The class name for the present function.  Used to modify ivars.
#@+node:ekr.20121015183335.10145: *7* convertCodeList (TS_To_Python) & helpers
def convertCodeList(self,aList):

    r,sr = self.replace,self.safe_replace

    # First...
    r(aList, '\r', '')
    self.mungeAllFunctions(aList)
    self.mungeAllClasses(aList)

    # Second...
    sr(aList, ' -> ', '.')
    sr(aList, '->', '.')
    sr(aList, ' . ', '.')
    # sr(aList, 'this.self', 'self')
    sr(aList, '{', '')
    sr(aList, '}', '')
    sr(aList, 'else if', 'elif')
    sr(aList, 'else', 'else:')
    sr(aList, '&&', ' and ')
    sr(aList, '||', ' or ')
    sr(aList, 'true', 'True')
    sr(aList, 'false', 'False')
    sr(aList, 'null', 'None')
    sr(aList, 'this', 'self')
    sr(aList, 'try', 'try:')
    sr(aList, 'catch', 'except:')
    sr(aList, 'constructor', '__init__')
    sr(aList, 'new ','')
    # sr(aList, 'var ','')
        # var usually indicates something weird, or an uninited var,
        # so it may be good to retain as a marker.

    # Third...
    self.handle_all_keywords(aList)
    self.insert_not(aList)
    self.removeSemicolonsAtEndOfLines(aList)
        # after processing for keywords
    self.comment_scope_ids(aList)

    # Last...
    self.removeBlankLines(aList)
    self.removeExcessWs(aList)
    # I usually don't like extra whitespace. YMMV.
    sr(aList, '  and ', ' and ')
    sr(aList, '  not ', ' not ')
    sr(aList, '  or ',  ' or ')
    sr(aList, ' and  ', ' and ')
    sr(aList, ' not  ', ' not ')
    sr(aList, ' or  ',  ' or ')
    sr(aList, ' :', ':') 
    sr(aList, ', ', ',')
    sr(aList, ' ,', ',')
    sr(aList, ' (', '(')
    sr(aList, '( ', '(')
    sr(aList, ' )', ')')
    sr(aList, ') ', ')')
    sr(aList, ' and(', ' and (')
    sr(aList, ' not(', ' not (')
    sr(aList, ' or(',  ' or (')
    sr(aList, ')and ', ') and ')
    sr(aList, ')not ', ') not ')
    sr(aList, ')or ',  ') or ')
    sr(aList, ')and(', ') and (')
    sr(aList, ')not(', ') not (')
    sr(aList, ')or(',  ') or (')
    sr(aList, '@language javascript','@language python')
    self.replaceComments(aList) # should follow all calls to safe_replace
    self.removeTrailingWs(aList)
    r(aList, '\t ', '\t') # happens when deleting declarations.
#@+node:ekr.20121015183335.10191: *8* comment_scope_ids
def comment_scope_ids (self,aList):

    '''convert (public|private|export) aLine to aLine # (public|private|export)'''

    scope_ids = ('public','private','export',)
    i = 0
    if any([self.match_word(aList,i,z) for z in scope_ids]):
        i = self.handle_scope_keyword(aList,i)
    while i < len(aList):
        progress = i
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif aList[i] == '\n':
            i += 1
            i = self.skip_ws(aList,i)
            if any([self.match_word(aList,i,z) for z in scope_ids]):
                i = self.handle_scope_keyword(aList,i)
        else:
            i += 1
        assert i > progress
    # print "handAllKeywords2:", ''.join(aList)
#@+node:ekr.20121015183335.10193: *9* handle_scope_keyword
def handle_scope_keyword (self,aList,i):

    i1 = i
    for word in ('public','private','export'):
        if self.match_word(aList,i,word):
            i += len(word)
            break
    else:
        assert False,'not a scope id: %s' % word

    # Skip any following spaces.
    i2 = self.skip_ws(aList,i)

    # Scan to the next newline:
    i3 = self.skip_line(aList,i)

    # Optional: move the word to a trailing comment.
    comment = list(' # %s' % word) if False else []

    # Change the list in place.
    aList[i1:i3] = aList[i2:i3] + comment
    i = i1 + (i3-i2) + len(comment)
    # g.trace(''.join(aList[i1:i]))
    return i
#@+node:ekr.20121015183335.10157: *8* handle_all_keywords
def handle_all_keywords (self,aList):

    '''
    converts if ( x ) to if x:
    converts while ( x ) to while x:
    '''

    statements = ('elif','for','if','while',)
    i = 0
    while i < len(aList):
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif any([self.match_word(aList,i,z) for z in statements]):
            i = self.handle_keyword(aList,i)
        # elif (
            # self.match_word(aList,i,"if") or
            # self.match_word(aList,i,"while") or
            # self.match_word(aList,i,"for") or
            # self.match_word(aList,i,"elif")
        # ):
            # i = self.handle_keyword(aList,i)
        else:
            i += 1
    # print "handAllKeywords2:", ''.join(aList)
#@+node:ekr.20121015183335.10158: *9* handle_keyword
def handle_keyword (self,aList,i):

    if self.match_word(aList,i,"if"):
        i += 2
    elif self.match_word(aList,i,"elif"):
        i += 4
    elif self.match_word(aList,i,"while"):
        i += 5
    elif self.match_word(aList,i,"for"):
        i += 3
    else: assert False,'not a keyword'

    # Make sure one space follows the keyword.
    k = i
    i = self.skip_ws(aList,i)
    if k == i:
        c = aList[i]
        aList[i:i+1] = [ ' ', c ]
        i += 1

    # Remove '(' and matching ')' and add a ':'
    if aList[i] == "(":
        # Look ahead.  Don't remove if we span a line.
        j = self.skip_to_matching_bracket(aList, i)
        k = i
        found = False
        while k < j and not found:
            found = aList[k] == '\n'
            k += 1
        if not found:
            j = self.removeMatchingBrackets(aList,i)
        if j > i and j < len(aList):
            ch = aList[j]
            aList[j:j+1] = [ch,":", " "]
            j = j + 2
        return j
    return i
#@+node:ekr.20121016024338.10190: *8* mungeAllClasses
def mungeAllClasses(self,aList):

    '''Scan for a '{' at the top level that is preceeded by ')' '''

    i = 0
    while i < len(aList):
        progress = i
        if self.is_string_or_comment(aList,i):
            i = self.skip_string_or_comment(aList,i)
        elif self.match_word(aList,i,'class'):
            i1 = i
            i = self.skip_line(aList,i)
            aList[i-1:i] = list('%s:' % aList[i-1])
            s = ''.join(aList[i1:i])
            k = s.find(' extends ')
            if k > -1:
                k1 = k
                k = g.skip_id(s,k+1)
                k = g.skip_ws(s,k)
                if k < len(s) and g.is_c_id(s[k]):
                    k2 = g.skip_id(s,k)
                    word = s[k:k2]
                    aList[i1:i] = list('%s (%s)' % (s[:k1],word))

        elif self.match_word(aList,i,'interface'):
            aList[i:i+len('interface')] = list('class')
            i = self.skip_line(aList,i)
            aList[i-1:i] = list('%s: # interface' % aList[i-1])
            i = self.skip_line(aList,i) # Essential.
        else:
            i += 1
        assert i > progress
#@+node:ekr.20121015183335.10148: *8* mungeAllFunctions & helpers
def mungeAllFunctions(self,aList):

    '''Scan for a '{' at the top level that is preceeded by ')' '''

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i < len(aList):
        progress = i
        if self.is_string_or_comment(aList,i):
            j = self.skip_string_or_comment(aList,i)
            prevSemi = j
        elif self.match(aList,i,'('):
            if not firstOpen:
                firstOpen = i
            j = i + 1
        elif self.match(aList,i,';'):
            j = i + 1
            prevSemi = j
        elif self.match(aList,i,"{"):
            j = self.handlePossibleFunctionHeader(aList,i,prevSemi,firstOpen)
            prevSemi = j
            firstOpen = None # restart the scan
            # g.trace(repr(''.join(aList[prevSemi:prevSemi+20])))
        else:
            j = i + 1

        # Handle unusual cases.
        if j <= progress:
            j = progress + 1
        assert j > progress

        i = j
#@+node:ekr.20121015183335.10149: *9* handlePossibleFunctionHeader
# converts function header lines from typescript format to python format.
# That is, converts
### x1..nn w::y ( t1 z1,..tn zn) { C++
# (public|private|export) name (t1: z1, ... tn: zn {
# to
# def y (z1,..zn): { # (public|private|export)

def handlePossibleFunctionHeader (self,aList,i,prevSemi,firstOpen):

    trace = False
    assert(self.match(aList,i,"{"))

    prevSemi = self.skip_ws_and_nl(aList, prevSemi)
    close = self.prevNonWsOrNlChar(aList,i)

    if close < 0 or aList[close] != ')':
        # Should not increase *Python* indent.
        return 1 + self.skip_to_matching_bracket(aList,i)

    if not firstOpen:
        return 1 + self.skip_to_matching_bracket(aList,i)

    close2 = self.skip_to_matching_bracket(aList, firstOpen)
    if close2 != close:
        return 1 + self.skip_to_matching_bracket(aList,i)

    open_paren = firstOpen
    assert(aList[open_paren]=='(')
    head = aList[prevSemi:open_paren]

    # do nothing if the head starts with "if", "for" or "while"
    k = self.skip_ws(head,0)
    if k >= len(head) or not head[k].isalpha():
        return 1 + self.skip_to_matching_bracket(aList,i)

    kk = self.skip_past_word(head,k)
    if kk > k:
        headString = ''.join(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "do", "for", "if", "struct", "switch", "while"]:
            return 1 + self.skip_to_matching_bracket(aList, i)

    args = aList[open_paren:close+1]
    k = 1 + self.skip_to_matching_bracket(aList,i)
    body = aList[close+1:k]

    if trace:
        g.trace('\nhead: %s\nargs: %s\nbody: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    head = self.massageFunctionHead(head)
    args = self.massageFunctionArgs(args)
    body = self.massageFunctionBody(body)

    if False and trace:
        g.trace('\nhead2: %s\nargs2: %s\nbody2: %s' % (
            ''.join(head),''.join(args),''.join(body)))

    result = []
    if head: result.extend(head)
    if args: result.extend(args)
    if body: result.extend(body)

    aList[prevSemi:k] = result
    return prevSemi + len(result)
#@+node:ekr.20121015183335.10150: *9* massageFunctionArgs
def massageFunctionArgs (self,args):

    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if self.class_name:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i < len(args):
        i = self.skip_ws_and_nl(args, i)
        c = args[i]
        if c.isalpha():
            j = self.skip_past_word(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", ''.join(result)
    return result
#@+node:ekr.20121015183335.10151: *9* massageFunctionHead (sets .class_name)
def massageFunctionHead (self,head):

    result = []
    prevWord = []
    self.class_name = ''
    i = 0
    # g.trace(repr(''.join(head)))
    while i < len(head):
        i = self.skip_ws_and_nl(head,i)
        if i < len(head) and head[i].isalpha():
            result = []
            j = self.skip_past_word(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = self.skip_ws(head,i)
            if self.match(head,i,"::"):
                # Set the global to the class name.
                self.class_name = ''.join(prevWord)
                # print(class name:", self.class_name)
                i = self.skip_ws(head,i+2)
                if i < len(head) and (head[i]=='~' or head[i].isalpha()):
                    j = self.skip_past_word(head,i)
                    if head[i:j] == prevWord:
                        result.extend('__init__')
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        result.extend('__del__')
                    else:
                        # result.extend(list('::'))
                        result.extend(head[i:j])
                    i = j
            else:
                result.extend(prevWord)
        else: i += 1

    finalResult = list("def ")
    finalResult.extend(result)
    return finalResult
#@+node:ekr.20121015183335.10152: *9* massageFunctionBody & helper
def massageFunctionBody (self,body):

    # body = self.massageIvars(body)
    # body = self.removeCasts(body)
    # body = self.removeTypeNames(body)
    body = self.dedentBlocks(body)
    return body
#@+node:ekr.20121015183335.10153: *10* dedentBlocks
def dedentBlocks (self,body):

    '''Look for '{' preceded by '{' or '}' or ';'
    (with intervening whitespace and comments).
    '''

    i = 0
    while i < len(body):
        j = i
        ch = body[i]
        if self.is_string_or_comment(body,i):
            j = self.skip_string_or_comment(body,i)
        elif ch in '{};':
            # Look ahead ofr '{'
            j += 1
            while True:
                k = j
                j = self.skip_ws_and_nl(body,j)
                if self.is_string_or_comment(body,j):
                    j = self.skip_string_or_comment(body,j)
                if k == j: break
                assert k < j
            if self.match(body,j,'{'):
                k = j
                j = self.skip_to_matching_bracket(body,j)
                # g.trace('found block\n',''.join(body[k:j+1]))
                m = '# <Start dedented block>...'
                body[k:k+1] = list(m)
                j += len(m)
                while k < j:
                    progress = k
                    if body[k] == '\n':
                        k += 1
                        spaces = 0
                        while spaces < 4 and k < j:
                            if body[k] == ' ':
                                spaces += 1
                                k += 1
                            else:
                                break
                        if spaces > 0:
                            del body[k-spaces:k]
                            k -= spaces
                            j -= spaces
                    else:
                        k += 1
                    assert progress < k
                m = '    # <End dedented block>'
                body[j:j+1] = list(m)
                j += len(m)
        else:
            j = i + 1

        # Defensive programming.
        if i == j:
            j += 1
        assert i < j
        i = j

    return body
#@+node:ekr.20100209160132.5763: *5* cache (leoEditCommands)
def clearAllCaches (self,event=None):

    '''Clear all of Leo's file caches.'''

    c = self.c
    if c.cacher:
        c.cacher.clearAllCaches()

def clearCache (self,event=None):

    '''Clear the outline's file cache.'''

    c = self.c
    if c.cacher:
        c.cacher.clearCache()
#@+node:ekr.20050920084036.57: *5* capitalization & case
#@+node:ekr.20051015114221: *6* capitalizeWord & up/downCaseWord
def capitalizeWord (self,event):
    '''Capitalize the word at the cursor.'''
    self.capitalizeHelper(event,'cap','capitalize-word')

def downCaseWord (self,event):
    '''Convert all characters of the word at the cursor to lower case.'''
    self.capitalizeHelper(event,'low','downcase-word')

def upCaseWord (self,event):
    '''Convert all characters of the word at the cursor to UPPER CASE.'''
    self.capitalizeHelper(event,'up','upcase-word')
#@+node:ekr.20050920084036.145: *6* changePreviousWord (not used)
# def changePreviousWord (self,event):

    # k = self.k ; stroke = k.stroke
    # w = self.editWidget(event)
    # if not w: return

    # i = w.getInsertPoint()
    # self.beginCommand(undoType='change-previous-word')
    # self.moveWordHelper(event,extend=False,forward=False)

    # if stroke == '<Alt-c>':
        # self.capitalizeWord(event)
    # elif stroke == '<Alt-u>':
        # self.upCaseWord(event)
    # elif stroke == '<Alt-l>':
        # self.downCaseWord(event)

    # w.setInsertPoint(i)

    # self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20051015114221.1: *6* capitalizeHelper
def capitalizeHelper (self,event,which,undoType):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getWord(s,ins)
    word = s[i:j]
    # g.trace('word',repr(word))
    if not word.strip(): return

    self.beginCommand(undoType=undoType)

    if   which == 'cap':  word2 = word.capitalize()
    elif which == 'low':  word2 = word.lower()
    elif which == 'up':   word2 = word.upper()
    else: g.trace('can not happen: which = %s' %s (which))

    changed = word != word2
    # g.trace('changed',changed,'word2',repr(word2))

    if changed:
        w.delete(i,j)
        w.insert(i,word2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20051022142249: *5* clicks and focus (EditCommandsClass)
#@+node:ekr.20060211100905: *6* activate-x-menu & activateMenu (EditCommandsClass)
def activateCmdsMenu    (self,event=None):
    '''Activate Leo's Cmnds menu.'''
    self.activateMenu('Cmds')

def activateEditMenu    (self,event=None):
    '''Activate Leo's Edit menu.'''
    self.activateMenu('Edit')

def activateFileMenu    (self,event=None):
    '''Activate Leo's File menu.'''
    self.activateMenu('File')

def activateHelpMenu    (self,event=None):
    '''Activate Leo's Help menu.'''
    self.activateMenu('Help')

def activateOutlineMenu (self,event=None):
    '''Activate Leo's Outline menu.'''
    self.activateMenu('Outline')

def activatePluginsMenu (self,event=None):
    '''Activate Leo's Plugins menu.'''
    self.activateMenu('Plugins')

def activateWindowMenu  (self,event=None):
    '''Activate Leo's Window menu.'''
    self.activateMenu('Window')

def activateMenu (self,menuName):
    c = self.c
    c.frame.menu.activateMenu(menuName)
#@+node:ekr.20051022144825.1: *6* cycleFocus
def cycleFocus (self,event):
    '''Cycle the keyboard focus between Leo's outline, body and log panes.'''
    c = self.c ; k = c.k ; w = event and event.widget
    body = c.frame.body.wrapper
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas
    # A hack for the Qt gui.
    if hasattr(w,'logCtrl'):
        w = w.logCtrl
    panes = [body,log,tree]
    # g.trace(w in panes,event.widget,panes)
    if w in panes:
        i = panes.index(w) + 1
        if i >= len(panes): i = 0
        pane = panes[i]
    else:
        pane = body
    # Warning: traces mess up the focus
    # g.pr(g.app.gui.widget_name(w),g.app.gui.widget_name(pane))
    # This works from the minibuffer *only* if there is no typing completion.
    c.widgetWantsFocusNow(pane)
    k.newMinibufferWidget = pane
    k.showStateAndMode()
#@+node:ekr.20060613090701: *6* cycleAllFocus (EditCommandsClass)
editWidgetCount = 0

def cycleAllFocus (self,event):

    '''Cycle the keyboard focus between Leo's outline,
    all body editors and all tabs in the log pane.'''

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    w = event and event.widget # Does **not** require a text widget.
    pane = None # The widget that will get the new focus.
    log = c.frame.log
    w_name = g.app.gui.widget_name
    if trace: g.trace('**before',w_name(w),'isLog',log.isLogWidget(w))
    # w may not be the present body widget, so test its name, not its id.
    if w_name(w).find('tree') > -1 or w_name(w).startswith('head'):
        pane = c.frame.body.wrapper
    elif w_name(w).startswith('body'):
        # Cycle through the *body* editor if there are several.
        n = c.frame.body.numberOfEditors
        if n > 1:
            self.editWidgetCount += 1
            if self.editWidgetCount == 1:
                pane = c.frame.body.wrapper
            elif self.editWidgetCount > n:
                self.editWidgetCount = 0
                c.frame.log.selectTab('Log')
                pane = c.frame.log.logCtrl
            else:
                c.frame.body.cycleEditorFocus(event)
                pane = None
        else:
            self.editWidgetCount = 0
            c.frame.log.selectTab('Log')
            pane = c.frame.log.logCtrl
    elif log.isLogWidget(w):
        # A log widget.  Cycle until we come back to 'Log'.
        log.cycleTabFocus()
        pane = c.frame.tree.canvas if log.tabName == 'Log' else None
    else:
        # A safe default: go to the body.
        if trace: g.trace('* default to body')
        pane = c.frame.body.wrapper
    if trace: g.trace('**after',w_name(pane),pane)
    if pane:
        k.newMinibufferWidget = pane
        c.widgetWantsFocusNow(pane)
        k.showStateAndMode()
#@+node:ekr.20051022144825: *6* focusTo...
def focusToBody (self,event=None):
    '''Put the keyboard focus in Leo's body pane.'''
    c = self.c ; k = c.k
    c.bodyWantsFocus()
    if k:
        k.setDefaultInputState()
        k.showStateAndMode()

def focusToLog (self,event=None):
    '''Put the keyboard focus in Leo's log pane.'''
    self.c.logWantsFocus()

def focusToMinibuffer (self,event=None):
    '''Put the keyboard focus in Leo's minibuffer.'''
    self.c.minibufferWantsFocus()

def focusToTree (self,event=None):
    '''Put the keyboard focus in Leo's outline pane.'''
    self.c.treeWantsFocus()
#@+node:ekr.20060211063744.1: *6* clicks in the headline (leoEditCommands)
# These call wrappers that trigger hooks.

def clickHeadline (self,event=None):
    '''Simulate a click in the headline of the presently selected node.'''
    c = self.c
    c.frame.tree.onHeadlineClick(event,c.p)

def doubleClickHeadline (self,event=None):
    '''Simulate a double click in headline of the presently selected node.'''
    c = self.c
    return c.frame.tree.onDoubleClickHeadline(event,c.p)

# This is not used in Leo at present.

def rightClickHeadline (self,event=None):
    '''Simulate a right click in the headline of the presently selected node.'''
    c = self.c
    c.frame.tree.onHeadlineRightClick(event,c.p)
#@+node:ekr.20060211055455: *6* clicks in the icon box (leoEditCommands)
# These call the actual event handlers so as to trigger hooks.

def ctrlClickIconBox(self,event=None):
    '''Simulate a ctrl-click in the icon box of the presently selected node.'''
    c = self.c
    c.frame.tree.OnIconCtrlClick(c.p)
        # Calls the base LeoTree method.

def clickIconBox (self,event=None):
    '''Simulate a click in the icon box of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onIconBoxClick(event,p=p)

def doubleClickIconBox (self,event=None):
    '''Simulate a double-click in the icon box of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onIconBoxDoubleClick(event,p=p)

def rightClickIconBox (self,event=None):

    '''Simulate a right click in the icon box of the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.onIconBoxRightClick(event,p=p)
#@+node:ekr.20060211062025: *6* clickClickBox
# Call the actual event handlers so as to trigger hooks.

def clickClickBox (self,event=None):

    '''Simulate a click in the click box (+- box) of the presently selected node.'''

    c = self.c ; p = c.p
    c.frame.tree.onClickBoxClick(event,p=p)
#@+node:ekr.20060211063744.2: *6* simulate...Drag
# These call the drag setup methods which in turn trigger hooks.

def simulateBeginDrag (self,event=None):

    '''Simulate the start of a drag in the presently selected node.'''
    c = self.c ; p = c.p
    c.frame.tree.startDrag(event,p=p)

def simulateEndDrag (self,event=None):

    '''Simulate the end of a drag in the presently selected node.'''
    c = self.c

    # Note: this assumes that tree.startDrag has already been called.
    c.frame.tree.endDrag(event)
#@+node:ekr.20051019183105: *5* color & font
#@+node:ekr.20051019183105.1: *6* show-colors
def showColors (self,event):

    '''Open a tab in the log pane showing various color pickers.'''

    c = self.c ; log = c.frame.log ; tabName = 'Colors'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createColorPicker(tabName)
#@+node:ekr.20051019201809: *6* editCommands.show-fonts & helpers
def showFonts (self,event):

    '''Open a tab in the log pane showing a font picker.'''

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        log.createFontPicker(tabName)
#@+node:ekr.20050920084036.132: *5* comment column...
#@+node:ekr.20050920084036.133: *6* setCommentColumn
def setCommentColumn (self,event):

    '''Set the comment column for the indent-to-comment-column command.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,ins)
    self.ccolumn = col
#@+node:ekr.20050920084036.134: *6* indentToCommentColumn
def indentToCommentColumn (self,event):

    '''Insert whitespace to indent the line containing the insert point to the comment column.'''

    w = self.editWidget(event)
    if not w: return
    self.beginCommand(undoType='indent-to-comment-column')
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    c1 = int(self.ccolumn)
    line2 = ' ' * c1 + line.lstrip()
    if line2 != line:
        w.delete(i,j)
        w.insert(i,line2)
    w.setInsertPoint(i+c1)
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.62: *5* esc methods for Python evaluation
#@+node:ekr.20050920084036.63: *6* watchEscape
def watchEscape (self,event):

    '''Enter watch escape mode.'''

    c,k = self.c,self.k

    char = event and event.char or ''

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = g.app.lossage[0]
        data2 = g.app.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and char == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif char not in ('Shift_L','Shift_R'):
            k.keyboardQuit()
#@+node:ekr.20050920084036.64: *6* escEvaluate (Revise)
def escEvaluate (self,event):

    c,k = self.c,self.k

    w = self.editWidget(event)
    if not w: return

    char = event and event.char or ''

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if char in ('\n','Return'):
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            i = w.getInsertPoint()
            w.insert(i,result)
            ok = True
        finally:
            k.keyboardQuit()
            if not ok:
                k.setStatusLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
#@+node:ekr.20050920084036.65: *5* evalExpression
def evalExpression (self,event):
    '''Evaluate a Python Expression entered in the minibuffer.'''
    k = self.k ; state = k.getState('eval-expression')
    if state == 0:
        k.setLabelBlue('Eval: ')
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
#@+node:ekr.20050920084036.66: *5* fill column and centering
@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap

after an center-region command via Alt-x.
@c

@others
#@+node:ekr.20050920084036.67: *6* centerLine
def centerLine (self,event):

    '''Centers line within current fill column'''

    c,k,w = self.c,self.k,self.editWidget(event)
    if not w: return

    if self.fillColumn > 0:
        fillColumn = self.fillColumn
    else:
        d = c.scanAllDirectives()
        fillColumn = d.get("pagewidth")

    s = w.getAllText()
    i,j = g.getLine(s,w.getInsertPoint())
    line = s [i:j].strip()
    if not line or len(line) >= fillColumn: return

    self.beginCommand(undoType='center-line')
    n = (fillColumn-len(line)) / 2
    ws = ' ' * n
    k = g.skip_ws(s,i)
    if k > i: w.delete(i,k-i)
    w.insert(i,ws)
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.68: *6* setFillColumn
def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            # Bug fix: 2011/05/23: set the fillColumn ivar!
            self.fillColumn = n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
#@+node:ekr.20050920084036.69: *6* centerRegion
def centerRegion (self,event):

    '''Centers the selected text within the fill column'''

    c,k,w = self.c,self.k,self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    ind, junk = g.getLine(s,sel_1)
    junk, end = g.getLine(s,sel_2)

    if self.fillColumn > 0:
        fillColumn = self.fillColumn
    else:
        d = c.scanAllDirectives()
        fillColumn = d.get("pagewidth")

    self.beginCommand(undoType='center-region')

    inserted = 0
    while ind < end:
        s = w.getAllText()
        i, j = g.getLine(s,ind)
        line = s [i:j].strip()
        # g.trace(len(line),repr(line))
        if len(line) >= fillColumn:
            ind = j
        else:
            n = int((fillColumn-len(line))/2)
            inserted += n
            k = g.skip_ws(s,i)
            if k > i: w.delete(i,k-i)
            w.insert(i,' '*n)
            ind = j + n-(k-i)

    w.setSelectionRange(sel_1,sel_2+inserted)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.70: *6* setFillPrefix
def setFillPrefix( self, event ):

    '''Make the selected text the fill prefix.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.fillPrefix = s[i:j]
#@+node:ekr.20050920084036.71: *6* _addPrefix
def _addPrefix (self,ntxt):

    # pylint: disable=deprecated-lambda
    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt
#@+node:ekr.20060417194232: *5* find (quick)
#@+node:ekr.20060925151926: *6* backward/findCharacter & helper
def backwardFindCharacter (self,event):
    '''Search backwards for a character.'''
    return self.findCharacterHelper(event,backward=True,extend=False)

def backwardFindCharacterExtendSelection (self,event):
    '''Search backward for a character, extending the selection.'''
    return self.findCharacterHelper(event,backward=True,extend=True)

def findCharacter (self,event):
    '''Search for a character.'''
    return self.findCharacterHelper(event,backward=False,extend=False)

def findCharacterExtendSelection (self,event):
    '''Search for a character, extending the selection.'''
    return self.findCharacterHelper(event,backward=False,extend=True)
#@+node:ekr.20060417194232.1: *7* findCharacterHelper
def findCharacterHelper (self,event,backward,extend):
    '''Put the cursor at the next occurance of a character on a line.'''
    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward
        self.extend = extend or self.extendMode # Bug fix: 2010/01/19
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            'Backward find' if backward else 'Find',
            ' & extend' if extend else '')
        k.setLabelBlue(s)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward
        extend = self.extend or self.extendMode
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + -1 if backward else +1 # skip the present character.
        if backward:
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
#@+node:ekr.20060417194232.2: *6* findWord and FindWordOnLine & helper
def findWord(self,event):

    '''Put the cursor at the next word that starts with a character.'''

    return self.findWordHelper(event,oneLine=False)

def findWordInLine(self,event):

    '''Put the cursor at the next word (on a line) that starts with a character.'''

    return self.findWordHelper(event,oneLine=True)

#@+node:ekr.20080408060320.1: *7* findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            'in line ' if oneLine else ''))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg
        if ch:
            w = self.w
            i = w.getInsertPoint()
            s = w.getAllText()
            end = len(s)
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break
        k.resetLabel()
        k.clearState()
#@+node:ekr.20050920084036.72: *5* goto...
#@+node:ekr.20050929115226: *6* gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.warning('goto-char takes non-negative integer argument')
        k.resetLabel()
        k.clearState()
#@+node:ekr.20060417181052: *6* gotoGlobalLine
def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    c = self.c
    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            c.GoToLineNumber(c).go(n=int(n))
#@+node:ekr.20050929124234: *6* gotoLine
def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
#@+node:ekr.20071114081313: *5* icons...
@

To do:

- Define standard icons in a subfolder of Icons folder?
- Tree control recomputes height of each line.
#@+node:ekr.20080108092811: *6*  Helpers
#@+node:ekr.20080108091349: *7* appendImageDictToList
def appendImageDictToList(self,aList,iconDir,path,xoffset,**kargs):

    c = self.c
    path = c.os_path_finalize_join(iconDir,path)
    relPath = g.makePathRelativeTo(path,iconDir)
    # pylint: disable=unpacking-non-sequence
    image,image_height = g.app.gui.getTreeImage(c,path)
    if not image:
        g.es('can not load image:',path)
        return xoffset
    if image_height is None:
        yoffset = 0
    else:
        yoffset = 0 # (c.frame.tree.line_height-image_height)/2
        # TNB: I suspect this is being done again in the drawing code
    newEntry = {
        'type' : 'file',
        'file' : path,
        'relPath': relPath,
        'where' : 'beforeHeadline',
        'yoffset' : yoffset, 'xoffset' : xoffset, 'xpad' : 1, # -2,
        'on' : 'VNode',
    }
    newEntry.update(kargs)  # may switch 'on' to 'VNode'
    aList.append (newEntry)
    xoffset += 2
    return xoffset
#@+node:ekr.20090701125429.6013: *7* dHash
def dHash(self, d):
    """Hash a dictionary"""
    return ''.join(['%s%s' % (str(k),str(d[k])) for k in sorted(d)])
#@+node:tbrown.20080119085249: *7* getIconList
def getIconList(self, p):
    """Return list of icons for position p, call setIconList to apply changes"""

    trace = False and not g.unitTesting
    if trace:
        if p == self.c.rootPosition(): g.trace('='*40)
        g.trace(p.h)

    fromVnode = []
    if hasattr(p.v,'unknownAttributes'):
        if trace: g.trace(p.v.u)
        fromVnode = [dict(i) for i in p.v.u.get('icons',[])]
        for i in fromVnode: i['on'] = 'VNode'

    if trace and fromVnode: g.trace('fromVnode',fromVnode,p.h)

    return fromVnode
#@+node:tbrown.20080119085249.1: *7* setIconList & helpers
def setIconList(self,p,l,setDirty=True):
    """Set list of icons for position p to l"""
    trace = False and not g.unitTesting
    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    # if trace: g.trace('lHash:',lHash)
    # if trace: g.trace('cHash:',cHash)
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return
    if trace: g.trace(l,g.callers(6))
    self._setIconListHelper(p,l,p.v,setDirty)
    self.frame.tree.updateIcon(pm, force=True)
#@+node:ekr.20090701125429.6012: *8* _setIconListHelper
def _setIconListHelper(self,p,subl,uaLoc,setDirty):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node
    """
    trace = False and not g.unitTesting
    if subl: # Update the uA.
        if not hasattr(uaLoc,'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc.unknownAttributes["lineYOffset"] = 3
        uaLoc._p_changed = 1
        if setDirty:
            p.setDirty()
        if trace: g.trace('uA',uaLoc.u,uaLoc)
    else: # delete the uA.
        if hasattr(uaLoc,'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc.unknownAttributes["lineYOffset"] = 0
                uaLoc._p_changed = 1
                if setDirty:
                    p.setDirty()
        if trace: g.trace('del uA[icons]',uaLoc)
#@+node:ekr.20071114082418: *6* deleteFirstIcon
def deleteFirstIcon (self,event=None):

    '''Delete the first icon in the selected node's icon list.'''

    c = self.c ; p = c.p

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[1:])
        c.setChanged(True)
        c.redraw_after_icons_changed()
#@+node:ekr.20071114092622: *6* deleteIconByName
def deleteIconByName (self,t,name,relPath): # t not used.
    """for use by the right-click remove icon callback"""
    c = self.c ; p = c.p

    aList = self.getIconList(p)
    if not aList: return

    basePath = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    absRelPath = c.os_path_finalize_join(basePath,relPath)
    name = c.os_path_finalize(name)

    newList = []
    for d in aList:
        name2 = d.get('file')
        name2 = c.os_path_finalize(name2)
        name2rel = d.get('relPath')
        # g.trace('name',name,'\nrelPath',relPath,'\nabsRelPath',absRelPath,'\nname2',name2,'\nname2rel',name2rel)
        if not (name == name2 or absRelPath == name2 or relPath == name2rel):
            newList.append(d)

    if len(newList) != len(aList):
        self.setIconList(p, newList)       
        c.setChanged(True)
        c.redraw_after_icons_changed()
    else:
        g.trace('not found',name)
#@+node:ekr.20071114085054: *6* deleteLastIcon
def deleteLastIcon (self,event=None):

    '''Delete the first icon in the selected node's icon list.'''

    c = self.c ; p = c.p

    aList = self.getIconList(p)

    if aList:
        self.setIconList(p, aList[:-1])
        c.setChanged(True)
        c.redraw_after_icons_changed()
#@+node:ekr.20071114082418.1: *6* deleteNodeIcons
def deleteNodeIcons (self,event=None):

    '''Delete all of the selected node's icons.'''

    c = self.c ; p = c.p

    if hasattr(p.v,"unknownAttributes"):
        a = p.v.unknownAttributes
        p.v._p_changed = 1
        self.setIconList(p,[])
        a["lineYOffset"] = 0
        p.setDirty()
        c.setChanged(True)
        c.redraw_after_icons_changed()
#@+node:ekr.20071114081313.1: *6* insertIcon
def insertIcon (self,event=None):

    '''Prompt for an icon, and insert it into the node's icon list.'''

    c = self.c ; p = c.p
    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)
    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)
    if not paths: return
    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)
    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
#@+node:ekr.20080108090719: *6* insertIconFromFile
def insertIconFromFile (self,path,p=None,pos=None,**kargs):

    c = self.c
    if not p: p = c.p
    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)
    aList = [] ; xoffset = 2
    xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset,**kargs)
    aList2 = self.getIconList(p)
    if pos is None: pos = len(aList2)
    aList2.insert(pos,aList[0])
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
#@+node:ekr.20050920084036.74: *5* indent...
#@+node:ekr.20050920084036.76: *6* deleteIndentation
def deleteIndentation (self,event):

    '''Delete indentation in the presently line.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]
    line2 = s[i:j].lstrip()
    delta = len(line) - len(line2)
    if delta:
        self.beginCommand(undoType='delete-indentation')
        w.delete(i,j)
        w.insert(i,line2)
        ins -= delta
        w.setSelectionRange(ins,ins,insert=ins)
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.78: *6* indentRelative
def indentRelative (self,event):

    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.

    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''

    c = self.c ; undoType = 'indent-relative' ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    oldSel = w.getSelectionRange()
    oldYview = w.getYScrollPosition()
    # Find the previous non-blank line
    i,j = g.getLine(s,ins)
    while 1:
        if i <= 0: return
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip(): break
    self.beginCommand(undoType=undoType)
    try:
        k = g.skip_ws(s,i)
        ws = s[i:k]
        i2,j2 = g.getLine(s,ins)
        k = g.skip_ws(s,i2)
        line = ws + s[k:j2]
        w.delete(i2,j2)
        w.insert(i2,line)
        w.setInsertPoint(i2+len(ws))
        c.frame.body.onBodyChanged(undoType,oldSel=oldSel,oldText=s,oldYview=oldYview)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.79: *5* info...
#@+node:ekr.20050920084036.80: *6* howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ')
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
#@+node:ekr.20050920084036.81: *6* lineNumber
def lineNumber (self,event):

    '''Print the line and column number and percentage of insert point.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    percent = int((i*100)/len(s))

    k.setLabelGrey(
        'char: %s row: %d col: %d pos: %d (%d%% of %d)' % (
            repr(s[i]),row,col,i,percent,len(s)))
#@+node:ekr.20050920084036.83: *6* k.viewLossage
def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = g.app.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        g.es('',k.prettyPrintKey(stroke))
#@+node:ekr.20050920084036.84: *6* whatLine
def whatLine (self,event):
    '''Print the line number of the line containing the cursor.'''
    k = self.k ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    k.keyboardQuit()
    k.setStatusLabel("Line %s" % row)
#@+node:ekr.20050920084036.85: *5* insert & delete...
#@+node:ekr.20060417171125: *6* addSpace/TabToLines & removeSpace/TabFromLines & helper
def addSpaceToLines (self,event):
    '''Add a space to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=True,undoType='add-space-to-lines')

def addTabToLines (self,event):
    '''Add a tab to start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=True,undoType='add-tab-to-lines')

def removeSpaceFromLines (self,event):
    '''Remove a space from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch=' ',add=False,undoType='remove-space-from-lines')

def removeTabFromLines (self,event):
    '''Remove a tab from start of all lines, or all selected lines.'''
    self.addRemoveHelper(event,ch='\t',add=False,undoType='remove-tab-from-lines')
#@+node:ekr.20060417172056: *7* addRemoveHelper
def addRemoveHelper(self,event,ch,add,undoType):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    if w.hasSelection():s = w.getSelectedText()
    else:               s = w.getAllText()
    if not s: return

    # Insert or delete spaces instead of tabs when negative tab width is in effect.
    d = c.scanAllDirectives() ; width = d.get('tabwidth')
    if ch == '\t' and width < 0: ch = ' ' * abs(width)

    self.beginCommand(undoType=undoType)
    lines = g.splitLines(s)
    if add:
        result = [ch + line for line in lines]
    else:
        result = [line[len(ch):] if line.startswith(ch) else line for line in lines]
    result = ''.join(result)
    # g.trace('add',add,'hasSelection',w.hasSelection(),'result',repr(result))
    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
        w.insert(i,result)
        w.setSelectionRange(i,i+len(result))
    else:
        w.setAllText(result)
        w.setSelectionRange(0,len(s))
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20051026092433.1: *6* backwardDeleteCharacter
def backwardDeleteCharacter (self,event=None):

    '''Delete the character to the left of the cursor.'''

    c = self.c ; p = c.p
    w = self.editWidget(event)
    if not w: return

    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace(wname,i,j,ins)

    if wname.startswith('body'):
        self.beginCommand()
        try:
            d = c.scanAllDirectives(p)
            tab_width = d.get("tabwidth",c.tab_width)
            changed = True
            if i != j:
                w.delete(i,j)
                w.setSelectionRange(i,i,insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins-1)
                w.setSelectionRange(ins-1,ins-1,insert=ins-1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=changed,setLabel=False)
                # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i,min(j,len(s)))
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins-1)
            ins = ins-1
            w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20051026092746: *7* << backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i,j = g.getLine(s,ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 > 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
i = ins-(max(1,count))
w.delete(i,ins)
w.setSelectionRange(i,i,insert=i)
#@+node:ekr.20070325094935: *6* cleanAllLines
def cleanAllLines (self,event):
    '''Clean all lines in the selected tree.'''
    c = self.c
    u = c.undoer
    w = c.frame.body.wrapper
    if not w: return
    tag = 'clean-all-lines'
    u.beforeChangeGroup(c.p,tag)
    n = 0
    for p in c.p.self_and_subtree():
        lines = []
        for line in g.splitLines(p.b):
            if line.rstrip():
                lines.append(line.rstrip())
            if line.endswith('\n'):
                lines.append('\n')
        s2 = ''.join(lines)
        if s2 != p.b:
            print(p.h)
            bunch = u.beforeChangeNodeContents(p)
            p.b = s2
            p.v.setDirty()
            n += 1
            u.afterChangeNodeContents(p,tag,bunch)
    u.afterChangeGroup(c.p,tag)
    c.redraw_after_icons_changed()
    g.es('cleaned %s nodes' % n)
#@+node:ekr.20060415112257: *6* cleanLines
def cleanLines (self,event):

    '''Removes trailing whitespace from all lines, preserving newlines.
    '''

    w = self.editWidget(event)
    if not w: return
    if w.hasSelection():
        s = w.getSelectedText()
    else:
        s = w.getAllText()
    lines = []
    for line in g.splitlines(s):
        if line.rstrip():
            lines.append(line.rstrip())
        if line.endswith('\n'):
            lines.append('\n')
    result = ''.join(lines)
    if s != result:
        self.beginCommand(undoType='clean-lines')
        if w.hasSelection():
            i,j = w.getSelectionRange()
            w.delete(i,j)
            w.insert(i,result)
            w.setSelectionRange(i,j+len(result))
        else:
            i = w.getInsertPoint()
            w.delete(0,'end')
            w.insert(0,result)
            w.setInsertPoint(i)
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20060414085834: *6* clearSelectedText
def clearSelectedText (self,event):

    '''Delete the selected text.'''

    w = self.editWidget(event)
    if not w: return
    i,j = w.getSelectionRange()
    if i == j: return
    self.beginCommand(undoType='clear-selected-text')
    w.delete(i,j)
    w.setInsertPoint(i)
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20100817125519.5833: *6* delete-word & backward-delete-word
def deleteWord(self,event=None):
    '''Delete the word at the cursor.'''
    self.deleteWordHelper(event,forward=True)

def backwardDeleteWord(self,event=None):
    '''Delete the word in front of the cursor.'''
    self.deleteWordHelper(event,forward=False)

# Patch by NH2.
def deleteWordSmart(self,event=None):
    '''Delete the word at the cursor, treating whitespace
    and symbols smartly.'''
    self.deleteWordHelper(event,forward=True,smart=True)

def backwardDeleteWordSmart(self,event=None):
    '''Delete the word in front of the cursor, treating whitespace
    and symbols smartly.'''
    self.deleteWordHelper(event,forward=False,smart=True)

def deleteWordHelper(self,event,forward,smart=False):
    c = self.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType="delete-word")
    if w.hasSelection():
        from_pos,to_pos = w.getSelectionRange()
    else:
        from_pos = w.getInsertPoint()
        self.moveWordHelper(event,extend=False,forward=forward,smart=smart)
        to_pos = w.getInsertPoint()

    # For Tk GUI, make sure to_pos > from_pos
    if from_pos > to_pos:
        from_pos,to_pos = to_pos,from_pos

    w.delete(from_pos,to_pos)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.87: *6* deleteNextChar
def deleteNextChar (self,event):

    '''Delete the character to the right of the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i,j = w.getSelectionRange()
    self.beginCommand(undoType='delete-char')
    changed = True
    if i != j:
        w.delete(i,j)
        w.setInsertPoint(i)
    elif j < len(s):
        w.delete(i)
        w.setInsertPoint(i)
    else:
        changed = False
    self.endCommand(changed=changed,setLabel=False)
#@+node:ekr.20050920084036.135: *6* deleteSpaces
def deleteSpaces (self,event,insertspace=False):

    '''Delete all whitespace surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    undoType = 'insert-space' if insertspace else 'delete-spaces'
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    w1 = ins-1
    while w1 >= i and s[w1].isspace():
        w1 -= 1
    w1 += 1
    w2 = ins
    while w2 <= j and s[w2].isspace():
        w2 += 1
    spaces = s[w1:w2]
    if spaces:
        self.beginCommand(undoType=undoType)
        if insertspace: s = s[:w1] + ' ' + s[w2:]
        else:           s = s[:w1] + s[w2:]
        w.setAllText(s)
        w.setInsertPoint(w1)
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20110528103005.18328: *6* insertHardTab
def insertHardTab(self,event):

    '''Insert one hard tab.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return
    assert g.isTextWrapper(w)
    name = c.widget_name(w)
    if name.startswith('head'): return
    ins = w.getInsertPoint()
    self.beginCommand(undoType='insert-hard-tab')
    w.insert(ins,'\t')
    ins += 1
    w.setSelectionRange(ins,ins,insert=ins)
    self.endCommand()
#@+node:ekr.20050920084036.138: *6* insertNewLine
def insertNewLine (self,event):

    '''Insert a newline at the cursor.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    assert g.isTextWrapper(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    oldSel = w.getSelectionRange()
    # g.trace('oldSel',oldSel)

    self.beginCommand(undoType='newline')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand()

insertNewline = insertNewLine
#@+node:ekr.20050920084036.86: *6* insertNewLineAndTab
def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    c = self.c ; k = c.k
    w = self.editWidget(event) ; p = c.p
    if not w: return

    assert g.isTextWrapper(w),w
    name = c.widget_name(w)
    if name.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    self.updateTab(p,w,smartTab=False)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand(changed=True,setLabel=False)
#@+node:ekr.20050920084036.139: *6* insertParentheses
def insertParentheses (self,event):

    '''Insert () at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='insert-parenthesis')

    i = w.getInsertPoint()
    w.insert(i,'()')
    w.setInsertPoint(i+1)

    self.endCommand(changed=True,setLabel=False)
#@+node:ekr.20110528103005.18329: *6* insertSoftTab
def insertSoftTab (self,event):

    '''Insert spaces equivalent to one tab.'''

    c = self.c ; p = c.p
    w = self.editWidget(event) 
    if not w: return

    assert g.isTextWrapper(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    d = c.scanAllDirectives(p)
    n = abs(d.get("tabwidth",c.tab_width))
    ins = w.getInsertPoint()

    self.beginCommand(undoType='insert-soft-tab')

    w.insert(ins,' ' * n)
    ins += n
    w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand()

#@+node:ekr.20050920084036.141: *6* removeBlankLines
def removeBlankLines (self,event):

    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''

    c = self.c
    head,lines,tail,oldSel,oldYview = c.getBodyLines()

    changed = False ; result = []
    for line in lines:
        if line.strip():
            result.append(line)
        else:
            changed = True
    result = ''.join(result)

    if changed:
        oldSel = None ; undoType = 'remove-blank-lines'
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@+node:ekr.20110530082209.18248: *6* replaceCurrentCharacter
def replaceCurrentCharacter (self,event):

    '''Replace the current character with the next character typed.'''

    k = self.k ; tag = 'replace-current-character'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Replace Character: ')
            k.getArg(event,tag,1,self.replaceCurrentCharacter)
    else:
        w = self.w
        ch = k.arg
        if ch:
            i,j = w.getSelectionRange()
            if i > j: i,j = j,i
            # Use raw insert/delete to retain the coloring.
            if i == j:
                i = max(0,i-1)
                w.delete(i)
            else:
                w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
#@+node:ekr.20051125080855: *6* selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting
    c,k = self.c,self.k
    verbose = True
    w = self.editWidget(event)
    if not w: return # (for Tk) 'break'
    << set local vars >>
    assert g.isStrokeOrNone(stroke)

    if trace: g.trace('ch',repr(ch),'stroke',stroke)
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return # (for Tk) "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        isPlain = stroke.find('Alt') == -1 and stroke.find('Ctrl') == -1
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        if isPlain: # 2013/10/07: call insertKeyEvent for non-plain characters.
            w.insert(i,ch)
            w.setInsertPoint(i+1)
        else:
            g.app.gui.insertKeyEvent(event,i)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return # (for Tk) 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return # (for Tk) 'break'
#@+node:ekr.20061103114242: *7* << set local vars >>
p = c.p

stroke = event and event.stroke or None
ch = event and event.char or ''

if ch == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'

name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
#@+node:ekr.20090213065933.14: *7* doPlainTab
def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
#@+node:ekr.20060627091557: *7* flashCharacter (leoEditCommands)
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
#@+node:ekr.20060627083506: *7* flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
#@+node:ekr.20060804095512: *7* initBracketMatcher
def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
#@+node:ekr.20051026171121: *7* insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'
    if trace:
        s = w.widget.toPlainText()
        g.trace(i,j,len(s),w)

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
#@+node:ekr.20051026171121.1: *7* updateAutoIndent (leoEditCommands)
def updateAutoIndent (self,p,w):

    trace = False and not g.unitTesting
    c = self.c
    d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)

    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()

    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        if trace: g.trace('width: %s, tab_width: %s, ws: %s' % (
            width,tab_width,repr(ws)))
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
        w.seeInsertPoint()
            # 2011/10/02: Fix cursor-movement bug.
#@+node:ekr.20051027172949: *7* updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
#@+node:ekr.20051026092433: *7* updateTab
def updateTab (self,p,w,smartTab=True):

    trace = False and not g.unitTesting
    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        if trace: g.trace(tab_width)

        # Get the preceeding characters.
        s = w.getAllText()
        start,end = g.getLine(s,i)
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.

        if trace:
            g.trace('smartTab',doSmartTab,'tab_width',tab_width)
                # 'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
#@+node:ekr.20140816053742.18402: *5* insertFileName
def insertFileName(self,event=None):
    '''
    Prompt for a file name, then insert it at the cursor position.
    This operation is undoable if done in the body pane.
    '''
    c = self.c
    w = self.editWidget(event)
    if w:
        def callback(arg,w=w):
            i = w.getInsertPoint()
            w.insert(i,arg)
            if g.app.gui.widget_name(w) == 'body':
                c.frame.body.onBodyChanged(undoType='Typing')
        c.k.getFileName(event,callback=callback)
#@+node:ekr.20031218072017.3983: *5* insertHeadlineTime
def insertHeadlineTime (self,event=None):
    '''Insert a date/time stamp in the headline of the selected node.'''
    frame = self ; c = frame.c ; p = c.p
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
    w = self.editWidget(event)
    if w:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1185933
        # insert-headline-time should insert at cursor.
        # Note: The command must be bound to a key for this to work.
        ins = w.getInsertPoint()
        s = c.getTime(body=False)
        w.insert(ins,s)
    else:
        c.endEditing()
        time = c.getTime(body=False)
        s = p.h.rstrip()
        if s:
            p.h = ' '.join([s, time])
        else:
            p.h = time
        
        c.redrawAndEdit(p,selectAll=True)
#@+node:ekr.20050920084036.88: *5* line...
#@+node:ekr.20050920084036.90: *6* flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ')
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
#@+node:ekr.20051002095724: *6* keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ')
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
#@+node:ekr.20050920084036.92: *6* linesHelper
def linesHelper (self,event,pattern,which):

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType=which+'-lines')
    if w.hasSelection():
        i,end = w.getSelectionRange()
    else:
        i = w.getInsertPoint()
        end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.setInsertPoint(i)
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.77: *6* splitLine
def splitLine (self,event):

    '''Split a line at the cursor position.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='split-line')

    s = w.getAllText()
    ins = w.getInsertPoint()
    w.setAllText(s[:ins] + '\n' + s[ins:])
    w.setInsertPoint(ins+1)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050929114218: *5* move cursor... (leoEditCommands)
#@+node:ekr.20051218170358: *6*  general helpers
#@+node:ekr.20060113130510: *7* extendHelper
def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; p = c.p
    extend = extend or self.extendMode

    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    if trace: g.trace(
        'extend',extend,'ins',ins,'sel=',i,j,
        'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v != self.moveSpotNode:
        if trace: g.trace('no spot')
        self.setMoveCol(w,ins if extend else spot) # sets self.moveSpot.
    elif extend:
        # 2011/05/20: Fix bug 622819
        # Ctrl-Shift movement is incorrect when there is an unexpected selection.
        if i == j:
            if trace: g.trace('extend and no sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
        elif self.moveSpot in (i,j) and self.moveSpot != ins:
            if trace and verbose: g.trace('extend and movespot matches')
            # The bug fix, part 1.
        else:
            # The bug fix, part 2.
            # Set the moveCol to the *not* insert point.
            if ins == i: k = j
            elif ins == j: k = i
            else: k = ins
            if trace: g.trace('extend and unexpected spot',k)
            self.setMoveCol(w,k) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 < len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if trace: g.trace('range',spot,self.moveSpot)
        if spot < self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        if trace: g.trace('insert point',spot)
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()
#@+node:ekr.20051218122116: *7* moveToHelper (leoEditCommands)
def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot < i: spot = i
        elif spot > j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)
#@+node:ekr.20060209095101: *7* setMoveCol
def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.p

    i,row,col = w.toPythonIndexRowCol(spot)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v

    # g.trace('moveSpot',i)
#@+node:ekr.20081123102100.1: *6* backToHome/ExtendSelection
def backToHome (self,event,extend=False):
    '''
    Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already there.
    '''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    if s:
        i,j = g.getLine(s,ins)
        i1 = i
        while i < j and s[i] in (' \t'):
            i += 1
        if i == ins:
            i = i1
        self.moveToHelper(event,i,extend=extend)
        
def backToHomeExtendSelection (self,event):
    self.backToHome(event,extend=True)
#@+node:ekr.20050920084036.75: *6* backToIndentation
def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    # None of the other cursor move commands are undoable.
    # self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i < j and s[i] in (' \t'):
        i += 1

    self.moveToHelper(event,i,extend=False)

    # self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20051218141237: *6* between lines & helper
def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
#@+node:ekr.20060113105246.1: *7* moveUpOrDownHelper
def moveUpOrDownHelper (self,event,direction,extend):

    trace = False and not g.unitTesting
    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=direction,extend=extend)
    else:
        # Find the start of the next/prev line.
        row,col = g.convertPythonIndexToRowCol(s,ins)
        if trace:
            gui_ins = w.toPythonIndex(ins)
            bbox = w.bbox(gui_ins)
            if bbox:
                x,y,width,height = bbox
                # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
                g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
                g.trace('ins',ins,'row',row,'col',col,
                    'event.x',event and event.x,'event.y',event and event.y)
                g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
                g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
        i,j = g.getLine(s,ins)
        if direction == 'down':
            i2,j2 = g.getLine(s,j)
        else:
            i2,j2 = g.getLine(s,i-1)

        # The spot is the start of the line plus the column index.
        n = max(0,j2-i2-1) # The length of the new line.
        col2 = min(col,n)
        spot = i2 + col2
        if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20050920084036.148: *6* buffers & helper
def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToBufferHelper(event,'home',extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    self.moveToBufferHelper(event,'end',extend=True)
#@+node:ekr.20100109094541.6227: *7* moveToBufferHelper
def moveToBufferHelper (self,event,spot,extend):

    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
    else:
        if spot == 'home':
            self.moveToHelper(event,0,extend=extend)
        elif spot == 'end':
            s = w.getAllText()
            self.moveToHelper(event,len(s),extend=extend)
        else:
            g.trace('can not happen: bad spot',spot)
#@+node:ekr.20051213080533: *6* characters & helper
def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'left',extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    self.moveToCharacterHelper(event,'left',extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    self.moveToCharacterHelper(event,'right',extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    self.moveToCharacterHelper(event,'right',extend=True)
#@+node:ekr.20100109094541.6228: *7* moveToCharacterHelper
def moveToCharacterHelper (self,event,spot,extend):

    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
    else:
        i = w.getInsertPoint()
        if spot == 'left':
            i=max(0,i-1)
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'right':
            i = min(i+1,len(w.getAllText()))
            self.moveToHelper(event,i,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20051218174113: *6* clear/set/ToggleExtendMode
def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    if not g.unitTesting:
        # g.red('extend mode','on' if val else 'off'))
        c.k.showStateAndMode()
    c.widgetWantsFocusNow(w)
#@+node:ekr.20050920084036.136: *6* exchangePointMark
def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    if hasattr(w,'leoMoveCursorHelper'):
        w.leoMoveCursorHelper(kind='exchange',extend=False)
    else:
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange(sort=False)
        if i == j: return
        ins = w.getInsertPoint()
        ins = j if ins==i else i
        w.setInsertPoint(ins)
        w.setSelectionRange(i,j,insert=None)
#@+node:ekr.20061007082956: *6* extend-to-line
def extendToLine (self,event):

    '''Select the line at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 <= i < n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 <= i < n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
#@+node:ekr.20061007214835.4: *6* extend-to-sentence
def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)
#@+node:ekr.20060116074839.2: *6* extend-to-word
def extendToWord (self,event,direction='forward',select=True):

    '''Compute the word at the cursor. Select it if select arg is True.'''

    w = self.editWidget(event)
    if not w:
        return 0,0
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()
    if direction == 'forward':
        while i < n and not g.isWordChar(s[i]):
            i += 1
    else:
        while 0 <= i < n and not g.isWordChar(s[i]):
            i -= 1
    while 0 <= i < n and g.isWordChar(s[i]):
        i -= 1
    i += 1
    i1 = i
    # Move to the end of the word.
    while 0 <= i < n and g.isWordChar(s[i]):
        i += 1
    if select:
        w.setSelectionRange(i1,i)
    return i1,i
#@+node:ekr.20050920084036.140: *6* movePastClose & helper
def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
#@+node:ekr.20051218171457: *7* movePastCloseHelper
def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i >= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j >= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i < j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 < len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 < len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 > j2: return

    self.moveToHelper(event,i2+1,extend)
#@+node:ekr.20100109094541.6231: *6* moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    w = self.editWidget(event)
    if not w: return

    # Bug fix: 2012/02/28: don't use the Qt end-line logic:
    # it apparently does not work for wrapped lines.
    if hasattr(w,'leoMoveCursorHelper') and spot != 'end-line':
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # Bug fix: 2011/11/13: Significant in external tests.
            if g.match(s,j-1,'\n'): j -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20090530181848.6034: *6* pages & helper
def backPage (self,event):
    '''Move the cursor back one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='back',extend=False)

def backPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one page.'''
    self.movePageHelper(event,kind='back',extend=True)

def forwardPage (self,event):
    '''Move the cursor forward one page,
    extending the selection if in extend mode.'''
    self.movePageHelper(event,kind='forward',extend=False)

def forwardPageExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one page.'''
    self.movePageHelper(event,kind='forward',extend=True)
#@+node:ekr.20090530181848.6035: *7* movePageHelper
def movePageHelper(self,event,kind,extend): # kind in back/forward.

    '''Move the cursor up/down one page, possibly extending the selection.'''

    trace = False and not g.unitTesting
    w = self.editWidget(event)
    if not w: return

    linesPerPage = 15 # To do.
    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(
            kind='page-down' if kind=='forward' else 'page-up',
            extend=extend,linesPerPage=linesPerPage)
        # w.seeInsertPoint()
        # c.frame.updateStatusLine()
        # w.rememberSelectionAndScroll()
    else:
        ins = w.getInsertPoint()
        s = w.getAllText()
        lines = g.splitLines(s)
        row,col = g.convertPythonIndexToRowCol(s,ins)
        row2 = max(0,row-linesPerPage) if kind=='back' else min(row+linesPerPage,len(lines)-1)
        if row == row2: return
        spot = g.convertRowColToPythonIndex(s,row2,col,lines=lines)
        if trace: g.trace('spot',spot,'row2',row2)
        self.extendHelper(w,extend,spot,upOrDown=True)
#@+node:ekr.20050920084036.102: *6* paragraphs & helpers
def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
#@+node:ekr.20051218133207: *7* backwardParagraphHelper
def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i > 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i > 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)
#@+node:ekr.20051218133207.1: *7* forwardParagraphHelper
def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j < len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
#@+node:ekr.20061111223516: *6* selectAllText (leoEditCommands)
def selectAllText (self,event):

    '''Select all text.'''

    c,k = self.c,self.c.k
    w = self.editWidget(event)
    if not w: return
    # Bug fix 2013/12/13: Special case the minibuffer.
    if w == k.w:
        k.selectAll()
    else:
        isTextWrapper = g.isTextWrapper(w)
        if w and isTextWrapper:
            return w.selectAllText()
#@+node:ekr.20050920084036.131: *6* sentences & helpers
def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
#@+node:ekr.20051213094517: *7* backSentenceHelper
def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()

    # Find the starting point of the scan.
    i = ins
    i -= 1 # Ensure some progress.
    if i < 0:
        return

    # Tricky.
    if s[i] == '.':
        i -= 1
    while i >= 0 and s[i] in ' \n':
        i -= 1
    if i >= ins:
        i -= 1
    if i >= len(s):
        i -= 1
    if i <= 0:
        return
    if s[i] == '.':
        i -= 1

    # Scan backwards to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i >= 0:
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if i > 0 and s[i-1].isalnum() and s[i+1].isalnum():
                i -= 1
            else:
                i += 1
                while i < len(s) and s[i] in ' \n':
                    i += 1
                i -= 1
                break
        elif s[i] == '\n':
            j = i-1
            while j >= 0:
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True ; break # found blank line.
                elif s[j] == ' ':
                    j -= 1
                else:
                    i -= 1 ; break # no blank line found.
            else:
                # No blank line found.
                i -= 1
        else:
            i -= 1
        assert end or progress > i
    i += 1

    if i < ins:
        self.moveToHelper(event,i,extend)
#@+node:ekr.20050920084036.137: *7* forwardSentenceHelper
def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins >= len(s): return

    # Find the starting point of the scan.
    i = ins
    if i+1 < len(s) and s[i+1] == '.':
        i += 1
    if s[i] == '.':
        i += 1
    else:
        while i < len(s) and s[i] in ' \n':
            i += 1
        i -= 1
    if i <= ins:
        i += 1
    if i >= len(s):
        return

    # Scan forward to the end of the paragraph.
    # Stop at empty lines.
    # Skip periods within words.
    # Stop at sentences ending in non-periods.
    end = False
    while not end and i < len(s):
        progress = i
        if s[i] == '.':
            # Skip periods surrounded by letters/numbers
            if 0 < i < len(s) and s[i-1].isalnum() and s[i+1].isalnum():
                i += 1
            else:
                i += 1 ; break # Include the paragraph.
        elif s[i] == '\n':
            j = i+1
            while j < len(s):
                if s[j] == '\n':
                    # Don't include first newline.
                    end = True ; break # found blank line.
                elif s[j] == ' ':
                    j += 1
                else:
                    i += 1 ; break # no blank line found.
            else:
                # No blank line found.
                i += 1
        else:
            i += 1
        assert end or progress < i

    i = min(i,len(s))
    if i > ins:
        self.moveToHelper(event,i,extend)
#@+node:ekr.20100109094541.6232: *6* within lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'start-line',extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    self.moveWithinLineHelper(event,'start-line',extend=True)

def endOfLine (self,event):
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'end-line',extend=False)

def endOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the line.'''
    self.moveWithinLineHelper(event,'end-line',extend=True)
#@+node:ekr.20050920084036.149: *6* words & helper
def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the next word.'''
    self.moveWordHelper(event,extend=True,forward=True)

def backwardWordSmart (self,event):
    '''Move the cursor to the beginning of the current or the end of the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False,smart=True)

def backwardWordSmartExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the beginning of the current
    or the end of the previous word.'''
    self.moveWordHelper(event,extend=True,forward=False,smart=True)

def forwardWordSmart (self,event):
    '''Move the cursor to the end of the current or the beginning of the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,smart=True)

def forwardWordSmartExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the current
    or the beginning of the next word.'''
    self.moveWordHelper(event,extend=True,forward=True,smart=True)
#@+node:ekr.20051218121447: *7* moveWordHelper
def moveWordHelper (self,event,extend,forward,end=False,smart=False):

    '''Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    # pylint: disable=anomalous-backslash-in-string
    alphanumeric_re = re.compile("\w")
    whitespace_re = re.compile("\s")
    simple_whitespace_re = re.compile("[ \t]")

    def is_alphanumeric(c):
        return alphanumeric_re.match(c) is not None
    def is_whitespace(c):
        return whitespace_re.match(c) is not None
    def is_simple_whitespace(c):
        return simple_whitespace_re.match(c) is not None
    def is_line_break(c):
        return is_whitespace(c) and not is_simple_whitespace(c)
    def is_special(c):
        return not is_alphanumeric(c) and not is_whitespace(c)

    def seek_until_changed(i, match_function, step):
        while 0 <= i < n and match_function(s[i]):
            i += step
        return i

    def seek_word_end(i): return seek_until_changed(i,is_alphanumeric,1)
    def seek_word_start(i): return seek_until_changed(i,is_alphanumeric,-1)

    def seek_simple_whitespace_end(i): return seek_until_changed(i,is_simple_whitespace,1)
    def seek_simple_whitespace_start(i): return seek_until_changed(i,is_simple_whitespace,-1)

    def seek_special_end(i): return seek_until_changed(i,is_special,1)
    def seek_special_start(i): return seek_until_changed(i,is_special,-1)

    if smart:
        if forward:
            if 0 <= i < n:
                if is_alphanumeric(s[i]):
                    i = seek_word_end(i)
                    i = seek_simple_whitespace_end(i)
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_end(i)
                elif is_special(s[i]):
                    i = seek_special_end(i)
                    i = seek_simple_whitespace_end(i)
                else:
                    i += 1  # e.g. for newlines
        else:
            i -= 1  # Shift cursor temporarily by -1 to get easy read access to the prev. char
            if 0 <= i < n:
                if is_alphanumeric(s[i]):
                    i = seek_word_start(i)
                    # Do not seek further whitespace here
                elif is_simple_whitespace(s[i]):
                    i = seek_simple_whitespace_start(i)
                elif is_special(s[i]):
                    i = seek_special_start(i)
                    # Do not seek further whitespace here
                else:
                    i -= 1  # e.g. for newlines
            i += 1
    else:
        if forward:
            # Unlike backward-word moves, there are two options...
            if end:
                while 0 <= i < n and not g.isWordChar(s[i]):
                    i += 1
                while 0 <= i < n and g.isWordChar(s[i]):
                    i += 1
            else:
                while 0 <= i < n and g.isWordChar(s[i]):
                    i += 1
                while 0 <= i < n and not g.isWordChar(s[i]):
                    i += 1
        else:
            i -= 1
            while 0 <= i < n and not g.isWordChar(s[i]):
                i -= 1
            while 0 <= i < n and g.isWordChar(s[i]):
                i -= 1

    self.moveToHelper(event,i,extend)
#@+node:ekr.20050920084036.95: *5* paragraph...
@others
#@+node:ekr.20050920084036.99: *6* backwardKillParagraph
def backwardKillParagraph (self,event):

    '''Kill the previous paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='backward-kill-paragraph')
    try:
        self.backwardParagraphHelper(event,extend=True)
        i,j = w.getSelectionRange()
        if i > 0: i = min(i+1,j)
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.100: *6* fillRegion
def fillRegion (self,event):
    '''Fill all paragraphs in the selected text.'''
    c = self.c ; p = c.p ; undoType = 'fill-region'
    w = self.editWidget(event)
    i,j = w.getSelectionRange()
    c.undoer.beforeChangeGroup(p,undoType)
    while 1:
        progress = w.getInsertPoint()
        c.reformatParagraph(event,undoType='reformat-paragraph')
        ins = w.getInsertPoint()
        s = w.getAllText()
        w.setInsertPoint(ins)
        if progress >= ins or ins >= j or ins >= len(s):
            break
    c.undoer.afterChangeGroup(p,undoType)
#@+node:ekr.20050920084036.104: *6* fillRegionAsParagraph
def fillRegionAsParagraph (self,event):

    '''Fill the selected text.'''

    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='fill-region-as-paragraph')

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.103: *6* fillParagraph
def fillParagraph( self, event ):

    '''Fill the selected paragraph'''

    w = self.editWidget(event)
    if not w: return

    # Clear the selection range.
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,i,insert=i)

    self.c.reformatParagraph(event)
#@+node:ekr.20050920084036.98: *6* killParagraph
def killParagraph (self,event):

    '''Kill the present paragraph.'''

    k = self.k ; c = k.c ; w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='kill-paragraph')
    try:
        self.extendToParagraph(event)
        i,j = w.getSelectionRange()
        c.killBufferCommands.kill(event,i,j,undoType=None)
        w.setSelectionRange(i,i,insert=i)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.96: *6* extend-to-paragraph & helper
def extendToParagraph (self,event):

    '''Select the paragraph surrounding the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    # Find the start of the paragraph.
    if line.strip(): # Search backward.
        while i > 0:
            i2,j2 = g.getLine(s,i-1)
            line = s[i2:j2]
            if line.strip(): i = i2
            else: break # Use the previous line.
    else: # Search forward.
        while j < len(s):
            i,j = g.getLine(s,j)
            line = s[i:j]
            if line.strip(): break
        else: return

    # Select from i to the end of the paragraph.
    self.selectParagraphHelper(w,i)
#@+node:ekr.20050920084036.97: *7* selectParagraphHelper
def selectParagraphHelper (self,w,start):

    '''Select from start to the end of the paragraph.'''

    s = w.getAllText()
    i1,j = g.getLine(s,start)
    while j < len(s):
        i,j2 = g.getLine(s,j)
        line = s[i:j2]
        if line.strip(): j = j2
        else: break

    j = max(start,j-1)
    w.setSelectionRange(i1,j,insert=j)
#@+node:ekr.20050920084036.105: *5* region...
@others
#@+node:ekr.20050920084036.108: *6* tabIndentRegion (indent-rigidly)
def tabIndentRegion (self,event):

    '''Insert a hard tab at the start of each line of the selected text.'''

    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='indent-rigidly')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    lines = g.splitlines(s[i:j])
    n = len(lines)
    lines = g.joinLines(['\t' + line for line in lines])
    s = s[:i] + lines + s[j:]
    w.setAllText(s)

    # Retain original row/col selection.
    w.setSelectionRange(i1,j1+n,insert=j1+n)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.109: *6* countRegion
def countRegion (self,event):

    '''Print the number of lines and characters in the selected text.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    txt = w.getSelectedText()
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,'' if chars==1 else 's'))
#@+node:ekr.20060417183606: *6* moveLinesDown
def moveLinesDown (self,event):

    '''Move all lines containing any selected text down one line,
    moving to the next node if the lines are the last lines of the body.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]

    # Select from start of the first line to the *start* of the last line.
    # This prevents selection creep.
    # n = i2-i
    # g.trace('moveLinesDown:',repr('%s[[%s|%s|%s]]%s' % (
    #    s[i-20:i], s[i:sel_1], s[sel_1:sel_2], s[sel_2:j], s[j:j+20])))
    self.beginCommand(undoType='move-lines-down')
    changed = False
    try:
        if j < len(s):
            next_i,next_j = g.getLine(s,j) # 2011/04/01: was j+1
            next_line = s[next_i:next_j]
            n2 = next_j-next_i
            w.delete(i,next_j)
            if next_line.endswith('\n'):
                # Simply swap positions with next line
                new_lines = next_line+lines
            else:
                # Last line of the body to be moved up doesn't end in a newline
                # while we have to remove the newline from the line above moving down.
                new_lines = next_line+'\n'+lines[:-1]
                n2 += 1
            w.insert(i,new_lines)
            w.setSelectionRange(sel_1+n2,sel_2+n2,insert=insert_pt+n2)
            changed = True
            # Fix bug 799695: colorizer bug after move-lines-up into a docstring
            c.recolor_now(incremental=False)
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20060417183606.1: *6* moveLinesUp
def moveLinesUp (self,event):

    '''Move all lines containing any selected text up one line,
    moving to the previous node as needed.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    sel_1,sel_2 = w.getSelectionRange()
    insert_pt = w.getInsertPoint() # 2011/04/01     
    i,junk = g.getLine(s,sel_1)
    i2,j   = g.getLine(s,sel_2)
    lines  = s[i:j]
    # g.trace('moveLinesUp:',repr('%s[[%s|%s|%s]]%s' % (
    #    s[max(0,i-20):i], s[i:sel_1], s[sel_1:sel_2], s[sel_2:j], s[j:j+20])))
    self.beginCommand(undoType='move-lines-up')
    changed = False
    try:
        if i>0:
            prev_i,prev_j = g.getLine(s,i-1)
            prev_line = s[prev_i:prev_j]
            n2 = prev_j - prev_i
            w.delete(prev_i,j)
            if lines.endswith('\n'):
                # Simply swap positions with next line
                new_lines = lines+prev_line
            else:
                # Lines to be moved up don't end in a newline while the
                # previous line going down needs its newline taken off.
                new_lines = lines+'\n'+prev_line[:-1]
            w.insert(prev_i,new_lines)
            w.setSelectionRange(sel_1-n2,sel_2-n2,insert=insert_pt-n2)
            changed = True
            # Fix bug 799695: colorizer bug after move-lines-up into a docstring
            c.recolor_now(incremental=False)
    finally:
        self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20050920084036.110: *6* reverseRegion
def reverseRegion (self,event):

    '''Reverse the order of lines in the selected text.'''

    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='reverse-region')

    s = w.getAllText()
    i1,j1 = w.getSelectionRange()
    i,junk = g.getLine(s,i1)
    junk,j = g.getLine(s,j1)

    txt = s[i:j]
    aList = txt.split('\n')
    aList.reverse()
    txt = '\n'.join(aList) + '\n'

    w.setAllText(s[:i1] + txt + s[j1:])
    ins = i1 + len(txt) - 1
    w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.111: *6* up/downCaseRegion & helper
def downCaseRegion (self,event):
    '''Convert all characters in the selected text to lower case.'''
    self.caseHelper(event,'low','downcase-region')

def toggleCaseRegion (self,event):
    '''Toggle the case of all characters in the selected text.'''
    self.caseHelper(event,'toggle','toggle-case-region')

def upCaseRegion (self,event):
    '''Convert all characters in the selected text to UPPER CASE.'''
    self.caseHelper(event,'up','upcase-region')

def caseHelper (self,event,way,undoType):

    w = self.editWidget(event)
    if not w or not w.hasSelection():
        return
    self.beginCommand(undoType=undoType)
    s = w.getAllText()
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    s2 = s[i:j]
    if way == 'low':
        sel = s2.lower()
    elif way == 'up':
        sel = s2.upper()
    else:
        assert way == 'toggle'
        sel = s2.swapcase()
    s2 = s[:i] + sel + s[j:]
    # g.trace('sel',repr(sel),'s2',repr(s2))
    changed = s2 != s
    if changed:
        w.setAllText(s2)
        w.setSelectionRange(i,j,insert=ins)
    self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20060309060654: *5* scrolling...
#@+node:ekr.20050920084036.116: *6* scrollUp/Down & helper
def scrollDownHalfPage (self,event):
    '''Scroll the presently selected pane down one lline.'''
    self.scrollHelper(event,'down','half-page')

def scrollDownLine (self,event):
    '''Scroll the presently selected pane down one lline.'''
    self.scrollHelper(event,'down','line')

def scrollDownPage (self,event):
    '''Scroll the presently selected pane down one page.'''
    self.scrollHelper(event,'down','page')

def scrollUpHalfPage (self,event):
    '''Scroll the presently selected pane down one lline.'''
    self.scrollHelper(event,'up','half-page')

def scrollUpLine (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up','line')

def scrollUpPage (self,event):
    '''Scroll the presently selected pane up one page.'''
    self.scrollHelper(event,'up','page')
#@+node:ekr.20060113082917: *7* scrollHelper (leoEditCommands)
def scrollHelper (self,event,direction,distance):

    '''Scroll the present pane up or down one page
    kind is in ('up/down-half-page/line/page)'''

    w = event and event.w
    if w and hasattr(w,'scrollDelegate'):
        kind = direction + '-' + distance
        w.scrollDelegate(kind)
#@+node:ekr.20060309060654.1: *6* scrollOutlineUp/Down/Line/Page
def scrollOutlineDownLine (self,event=None):
    '''Scroll the outline pane down one line.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('down-line')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if b < 1.0: tree.canvas.yview_scroll(1,"unit")

def scrollOutlineDownPage (self,event=None):
    '''Scroll the outline pane down one page.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('down-page')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if b < 1.0: tree.canvas.yview_scroll(1,"page")

def scrollOutlineUpLine (self,event=None):
    '''Scroll the outline pane up one line.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('up-line')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if a > 0.0: tree.canvas.yview_scroll(-1,"unit")

def scrollOutlineUpPage (self,event=None):
    '''Scroll the outline pane up one page.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('up-page')
    elif hasattr(tree.canvas,'leo_treeBar'):
        a,b = tree.canvas.leo_treeBar.get()
        if a > 0.0: tree.canvas.yview_scroll(-1,"page")
#@+node:ekr.20060726154531: *6* scrollOutlineLeftRight
def scrollOutlineLeft (self,event=None):
    '''Scroll the outline left.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('left')
    elif hasattr(tree.canvas,'xview_scroll'):
        tree.canvas.xview_scroll(1,"unit")

def scrollOutlineRight (self,event=None):
    '''Scroll the outline left.'''
    c = self.c ; tree = c.frame.tree
    if hasattr(tree,'scrollDelegate'):
        tree.scrollDelegate('right')
    elif hasattr(tree.canvas,'xview_scroll'):
        tree.canvas.xview_scroll(-1,"unit")
#@+node:ekr.20050920084036.117: *5* sort...
@nocolor
@color
@
XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

#@+node:ekr.20050920084036.118: *6* sortLines commands
def reverseSortLinesIgnoringCase(self,event):
    '''Sort the selected lines in reverse order, ignoring case.'''
    return self.sortLines(event,ignoreCase=True,reverse=True)

def reverseSortLines(self,event):
    '''Sort the selected lines in reverse order.'''
    return self.sortLines(event,reverse=True)

def sortLinesIgnoringCase(self,event):
    '''Sort the selected lines, ignoring case.'''
    return self.sortLines(event,ignoreCase=True)

def sortLines (self,event,ignoreCase=False,reverse=False):
    '''Sort the selected lines.'''
    w = self.editWidget(event)
    if not self._chckSel(event): return

    undoType = 'reverse-sort-lines' if reverse else 'sort-lines'
    self.beginCommand(undoType=undoType)
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        ins = w.getInsertPoint()
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        s2 = s[i:j]
        if not s2.endswith('\n'): s2 = s2+'\n'
        aList = g.splitLines(s2)
        def lower(s):
            if ignoreCase: return s.lower()
            else: return s
        aList.sort(key=lower)
            # key is a function that extracts args.
        if reverse:
            aList.reverse()
        s = g.joinLines(aList)
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_2,insert=ins)
    finally:
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.119: *6* sortColumns
def sortColumns (self,event):

    '''Sort lines of selected text using only lines in the given columns to do the comparison.'''

    w = self.editWidget(event)
    if not self._chckSel(event): return
    self.beginCommand(undoType='sort-columns')
    try:
        s = w.getAllText()
        sel_1,sel_2 = w.getSelectionRange()
        sint1,sint2 = g.convertPythonIndexToRowCol(s,sel_1)
        sint3,sint4 = g.convertPythonIndexToRowCol(s,sel_2)
        sint1 += 1 ; sint3 += 1
        i,junk = g.getLine(s,sel_1)
        junk,j = g.getLine(s,sel_2)
        txt = s[i:j]
        columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
            for z in range(sint1,sint3+1)]
        aList = g.splitLines(txt)
        zlist = list(zip(columns,aList))
        zlist.sort()
        s = g.joinLines([z[1] for z in zlist])
        w.delete(i,j)
        w.insert(i,s)
        w.setSelectionRange(sel_1,sel_1+len(s),insert=sel_1+len(s))
    finally:
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.120: *6* sortFields
def sortFields (self,event,which=None):

    '''Divide the selected text into lines and sort by comparing the contents of
     one field in each line. Fields are defined as separated by whitespace, so
     the first run of consecutive non-whitespace characters in a line
     constitutes field 1, the second such run constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to sort by
     field 1, etc. A negative argument means sort in descending order. Thus,
     minus 2 means sort by field 2 in reverse-alphabetical order.'''

    w = self.editWidget(event)
    if not w or not self._chckSel(event): return

    self.beginCommand(undoType='sort-fields')

    s = w.getAllText()
    ins = w.getInsertPoint()
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    i,junk = g.getLine(s,r1)
    junk,j = g.getLine(s,r4)
    txt = s[i:j] # bug reported by pychecker.
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for line in txt:
        f = frx.findall(line)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) < i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete(i,j)
    int1 = i
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.setInsertPoint(ins)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.121: *5* swap/transpose...
#@+node:ekr.20050920084036.122: *6* transposeLines
def transposeLines (self,event):

    '''Transpose the line containing the cursor with the preceding line.'''

    w = self.editWidget(event)
    if not w: return

    ins = w.getInsertPoint()
    s = w.getAllText()
    if not s.strip(): return

    i,j = g.getLine(s,ins)
    line1 = s[i:j]

    self.beginCommand(undoType='transpose-lines')

    if i == 0: # Transpose the next line.
        i2,j2 = g.getLine(s,j+1)
        line2 = s[i2:j2]
        w.delete(0,j2)
        w.insert(0,line2+line1)
        w.setInsertPoint(j2-1)
    else: # Transpose the previous line.
        i2,j2 = g.getLine(s,i-1)
        line2 = s[i2:j2]
        w.delete(i2,j)
        w.insert(i2,line1+line2)
        w.setInsertPoint(j-1)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20060529184652.1: *6* transposeWords
def transposeWords (self,event):

    '''Transpose the word at the cursor with the preceding or following word.'''

    trace = False and not g.unitTesting
    w = self.editWidget(event)
    if not w: return
    self.beginCommand(undoType='transpose-words')
    s = w.getAllText()
    i1,j1 = self.extendToWord(event,direction='back',select=False)
    s1 = s[i1:j1]
    if trace: g.trace(i1,j1,s1)
    if i1 > j1: i1,j1 = j1,i1

    # First, search backward.
    k = i1-1
    while k >= 0 and s[k].isspace():
        k -= 1
    changed = k > 0
    if changed:
        ws = s[k+1:i1]
        if trace: g.trace(repr(ws))
        w.setInsertPoint(k+1)
        i2,j2 = self.extendToWord(event,direction='back',select=False)
        s2 = s[i2:j2]
        if trace: g.trace(i2,j2,repr(s2))
        s3 = s[:i2] + s1 + ws + s2 + s[j1:]
        w.setAllText(s3)
        if trace: g.trace(s3)
        w.setSelectionRange(j1,j1,insert=j1)
    else:
        # Next search forward.
        k = j1+1
        while k < len(s) and s[k].isspace():
            k += 1
        changed = k < len(s)
        if changed:
            ws = s[j1:k]
            if trace: g.trace(repr(ws))
            w.setInsertPoint(k+1)
            i2,j2 = self.extendToWord(event,direction='forward',select=False)
            s2 = s[i2:j2]
            if trace: g.trace(i2,j2,repr(s2))
            s3 = s[:i1] + s2 + ws + s1 + s[j2:]
            w.setAllText(s3)
            if trace: g.trace(s3)
            w.setSelectionRange(j1,j1,insert=j1)

    self.endCommand(changed=changed,setLabel=True)
#@+node:ekr.20050920084036.124: *6* swapCharacters & transeposeCharacters
def swapCharacters (self,event):

    '''Swap the characters at the cursor.'''

    w = self.editWidget(event)
    if not w: return

    self.beginCommand(undoType='swap-characters')
    s = w.getAllText()
    i = w.getInsertPoint()
    if 0 < i < len(s):
        w.setAllText(s[:i-1] + s[i] + s[i-1] + s[i+1:])
        w.setSelectionRange(i,i,insert=i)
    self.endCommand(changed=True,setLabel=True)

transposeCharacters = swapCharacters
#@+node:ekr.20050920084036.126: *5* tabify & untabify
def tabify (self,event):
    '''Convert 4 spaces to tabs in the selected text.'''
    self.tabifyHelper (event,which='tabify')

def untabify (self,event):
    '''Convert tabs to 4 spaces in the selected text.'''
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    w = self.editWidget(event)
    if not w or not w.hasSelection(): return

    self.beginCommand(undoType=which)
    i,end = w.getSelectionRange()
    txt = w.getSelectedText()
    if which == 'tabify':
        pattern = re.compile(' {4,4}') # Huh?
        ntxt = pattern.sub('\t',txt)
    else:
        pattern = re.compile('\t')
        ntxt = pattern.sub('    ',txt)
    w.delete(i,end)
    w.insert(i,ntxt)
    n = i + len(ntxt)
    w.setSelectionRange(n,n,insert=n)
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20110527105255.18384: *5* uA's (leoEditCommands)
#@+node:ekr.20110527105255.18387: *6* clearNodeUas & clearAllUas
def clearNodeUas (self,event=None):

    '''Clear the uA's in the selected VNode.'''

    if self.c.p:
        self.c.p.v.u = {}

def clearAllUas (self,event=None):

    '''Clear all uAs in the entire outline.'''

    for v in self.c.all_unique_nodes():
        v.u = {}
#@+node:ekr.20110527105255.18385: *6* printUas & printAllUas
def printAllUas (self,event=None):

    '''Print all uA's in the outline.'''

    g.es_print('Dump of uAs...')
    for v in self.c.all_unique_nodes():
        if v.u:
            self.printUas(v=v)

def printUas (self,event=None,v=None):

    '''Print the uA's in the selected node.'''

    c = self.c
    if v: d,h = v.u,v.h
    else: d,h = c.p.v.u,c.p.h
    g.es_print(h)
    keys = list(d.keys())
    keys.sort()
    n = 4
    for key in keys:
        n = max(len(key),n)
    for key in keys:
        pad = ' '*(len(key)-n)
        g.es_print('    %s%s: %s' % (pad,key,d.get(key)))
#@+node:ekr.20110527105255.18386: *6* setUa
def setUa (self,event):

    '''Prompt for the name and value of a uA, then set the uA in the present node.'''

    c,k = self.c,self.k
    tag = 'set-ua' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Set uA: ')
            k.getArg(event,tag,1,self.setUa)
    elif state == 1:
        self.uaName = k.arg
        s = 'Set uA: %s To: ' % (self.uaName)
        k.setLabelBlue(s)
        k.getArg(event,tag,2,self.setUa,completion=False)
    else:
        assert state == 2,state
        val = k.arg
        d = c.p.v.u
        d[self.uaName] = val
        self.printUas()
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
#@+node:ekr.20050920084036.161: *4* EditFileCommandsClass
class EditFileCommandsClass (BaseEditCommandsClass):

    '''A class to load files into buffers and save buffers to files.'''

    @others
#@+node:ekr.20050920084036.162: *5*  ctor (EditFileCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.
#@+node:ekr.20050920084036.163: *5*  getPublicCommands (EditFileCommandsClass)
def getPublicCommands (self):

    return {
        'directory-make':           self.makeDirectory,
        'directory-remove':         self.removeDirectory,
        'file-compare-leo-files':   self.compareLeoFiles,
        'file-delete':              self.deleteFile,
        'file-diff-files':          self.diff, 
        'file-insert':              self.insertFile,
        'file-open-by-name':        self.openOutlineByName,
        'file-save':                self.saveFile
    }
#@+node:ekr.20070920104110: *5* compareLeoFiles
def compareLeoFiles (self,event):
    '''Compare two .leo files.'''
    trace = False and not g.unitTesting
    c = c1 = self.c
    w = c.frame.body.wrapper
    # Prompt for the file to be compared with the present outline.
    filetypes = [("Leo files", "*.leo"),("All files", "*"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
    if not fileName: return
    # Read the file into the hidden commander.
    c2 = self.createHiddenCommander(fileName)
    if not c2: return
    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    if trace: self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)
    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(c1,c2,inserted,deleted,changed)
    # Fix bug 1231656: File-Compare-Leo-Files leaves other file open-count incremented.
    g.app.forgetOpenFile(fn=c2.fileName(),force=True)
    c2.frame.destroySelf()
    g.app.gui.set_focus(c,w)
#@+node:ekr.20070921072608: *6* computeChangeDicts
def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.
    
    New in Leo 4.11: show the nodes in the *invisible* file, d2, if possible.'''

    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)
    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)
    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p2 # Show the node in the *other* file.
    return inserted, deleted, changed
#@+node:ekr.20070921072910: *6* createAllCompareClones & helper
def createAllCompareClones(self,c1,c2,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    assert c == c1
    # Create parent node at the start of the outline.
    u = c.undoer ; undoType = 'Compare .leo Files'
    u.beforeChangeGroup(c.p,undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    for d,kind in (
        (deleted,'not in %s' % c2.shortFileName()),
        (inserted,'not in %s' % c1.shortFileName()),
        (changed,'changed: as in %s' % c2.shortFileName()),
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 
    c.redraw()
#@+node:ekr.20070921074410: *7* createCompareClones
def createCompareClones (self,d,kind,parent):

    if d:
        c = self.c # Use the visible commander.
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)
        for key in d:
            p = d.get(key)
            if p.v.context == c:
                clone = p.clone()
                clone.moveToLastChildOf(parent)
            else:
                # Fix bug 1160660: File-Compare-Leo-Files creates "other file" clones.
                copy = p.copyTreeAfter()
                copy.moveToLastChildOf(parent)
                for p2 in copy.self_and_subtree():
                    p2.v.context = c
#@+node:ekr.20070921070101: *6* createHiddenCommander (EditFileCommandsClass)
def createHiddenCommander(self,fn):
    '''Read the file into a hidden commander (Similar to g.openWithFileName).'''
    import leo.core.leoCommands as leoCommands
    lm = g.app.loadManager
    c2 = leoCommands.Commands(fn,gui=g.app.nullGui)
    theFile = lm.openLeoOrZipFile(fn)
    if theFile:
        c2.fileCommands.openLeoFile(theFile,fn,
            readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None
#@+node:ekr.20070921070101.1: *6* createFileDict
def createFileDict (self,c):
    '''Create a dictionary of all relevant positions in commander c.'''
    d = {}
    for p in c.all_positions():
        d[p.v.fileIndex] = p.copy()
    return d
#@+node:ekr.20070921072608.1: *6* dumpCompareNodes
def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n',kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key,p.h))
            else:
                g.pr('%-32s %s' % (key,g.toEncodedString(p.h,'ascii')))
#@+node:ekr.20050920084036.164: *5* deleteFile (changed)
def deleteFile (self,event):

    '''Prompt for the name of a file and delete it.'''

    k = self.k ; state = k.getState('delete_file')

    if state == 0:
        k.setLabelBlue('Delete File: ')
        k.extendLabel(os.getcwd() + os.sep)
        k.getArg(event,'delete_file',1,self.deleteFile)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.remove(k.arg)
            k.setStatusLabel('Deleted: %s' % k.arg)
        except Exception:
            k.setStatusLabel('Not Deleted: %s' % k.arg)
#@+node:ekr.20050920084036.165: *5* diff (revise)
def diff (self,event):

    '''Creates a node and puts the diff between 2 files into it.'''

    w = self.editWidget(event)
    if not w: return
    fn = self.getReadableTextFile()
    if not fn: return
    fn2 = self.getReadableTextFile()
    if not fn2: return
    s1,e = g.readFileIntoString(fn)
    if s1 is None: return
    s2,e = g.readFileIntoString(fn2)
    if s2 is None: return

    # self.switchToBuffer(event,"*diff* of ( %s , %s )" % (name,name2))
    data = difflib.ndiff(s1,s2)
    idata = []
    for z in data:
        idata.append(z)
    w.delete(0,'end')
    w.insert(0,''.join(idata))
#@+node:ekr.20050920084036.166: *5* getReadableTextFile
def getReadableTextFile (self):

    fn = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    return fn
#@+node:ekr.20050920084036.167: *5* insertFile
def insertFile (self,event):

    '''Prompt for the name of a file and put the selected text into it.'''

    w = self.editWidget(event)
    if not w: return

    fn = self.getReadableTextFile()
    if not fn: return

    s,e = g.readFileIntoString(fn)
    if s is None: return

    self.beginCommand(undoType='insert-file')
    i = w.getInsertPoint()
    w.insert(i,s)
    w.seeInsertPoint()
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.168: *5* makeDirectory
def makeDirectory (self,event):
    '''Prompt for the name of a directory and create it.'''
    k = self.k
    state = k.getState('make_directory')
    if state == 0:
        k.setLabelBlue('Make Directory: ')
        k.extendLabel(os.getcwd() + os.sep)
        k.getArg(event,'make_directory',1,self.makeDirectory)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.mkdir(k.arg)
            k.setStatusLabel("Created: %s" % k.arg)
        except Exception:
            k.setStatusLabel("Not Create: %s" % k.arg)
#@+node:ekr.20060419123128: *5* openOutlineByName (EditFileCommandsClass)
def openOutlineByName (self,event):
    '''file-open-by-name: Prompt for the name of a Leo outline and open it.'''
    c,k = self.c,self.k
    fileName = ''.join(k.givenArgs)
    # Bug fix: 2012/04/09: only call g.openWithFileName if the file exists.
    if fileName and g.os_path_exists(fileName):
        g.openWithFileName(fileName,old_c=c)
    else:
        k.setLabelBlue('Open Leo Outline: ')
        k.getFileName(event,callback=self.openOutlineByNameFinisher)

def openOutlineByNameFinisher (self,fn):
    c = self.c
    if fn and g.os_path_exists(fn) and not g.os_path_isdir(fn):
        c2 = g.openWithFileName(fn,old_c=c)
        try:
            g.app.gui.runAtIdle(c2.treeWantsFocusNow)
        except Exception:
            pass
    else:
        g.es('ignoring: %s' % fn)
#@+node:ekr.20050920084036.169: *5* removeDirectory
def removeDirectory (self,event):

    '''Prompt for the name of a directory and delete it.'''

    k = self.k ; state = k.getState('remove_directory')

    if state == 0:
        k.setLabelBlue('Remove Directory: ')
        k.extendLabel(os.getcwd() + os.sep)
        k.getArg(event,'remove_directory',1,self.removeDirectory)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.rmdir(k.arg)
            k.setStatusLabel('Removed: %s' % k.arg)
        except Exception:
            k.setStatusLabel('Not Removed: %s' % k.arg)
#@+node:ekr.20050920084036.170: *5* saveFile (changed)
def saveFile (self,event):

    '''Prompt for the name of a file and put the body text of the selected node into it..'''

    w = self.editWidget(event)
    if not w: return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = None,
        title='save-file',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if not fileName: return

    try:
        f = open(fileName,'w')
        s = w.getAllText()
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s,encoding='utf-8',reportErrors=True)
        f.write(s)
        f.close()
    except IOError:
        g.es('can not create',fileName)
#@+node:ekr.20060205164707: *4* HelpCommandsClass
class HelpCommandsClass (BaseEditCommandsClass):
    '''A class to load files into buffers and save buffers to files.'''
    # pylint: disable=anomalous-backslash-in-string
    @others
#@+node:ekr.20060205165501: *5* getPublicCommands (helpCommands)
def getPublicCommands (self):

    return {
    'help':                             self.help,
    'help-for-abbreviations':           self.helpForAbbreviations,
    'help-for-autocompletion':          self.helpForAutocompletion,
    'help-for-bindings':                self.helpForBindings,
    'help-for-command':                 self.helpForCommand,
    'help-for-creating-external-files': self.helpForCreatingExternalFiles,
    'help-for-debugging-commands':      self.helpForDebuggingCommands,
    'help-for-drag-and-drop':           self.helpForDragAndDrop,
    'help-for-dynamic-abbreviations':   self.helpForDynamicAbbreviations,
    'help-for-find-commands':           self.helpForFindCommands,
    'help-for-minibuffer':              self.helpForMinibuffer,
    'help-for-python':                  self.pythonHelp,
    'help-for-regular-expressions':     self.helpForRegularExpressions,
    'help-for-scripting':               self.helpForScripting,
    'print-settings':                   self.printSettings,
    }
#@+node:ekr.20130412173637.10333: *5* help
def help (self,event=None):

    '''Prints and introduction to Leo's help system.'''

    << define rst_s >>
    self.c.putHelpFor(rst_s)
#@+node:ekr.20130412173637.10330: *6* << define rst_s >> (F1)
@language rest

rst_s = '''

**Welcome to Leo's help system.**

Alt-0 (vr-toggle) hides this help message.

To learn about ``<Alt-X>`` commands, type::
    
    <Alt-X>help-for-minibuffer<Enter>
    
To get a list of help topics, type::
    
    <Alt-X>help-<tab>
    
For Leo commands (tab completion allowed), type::
    
    <Alt-X>help-for-command<Enter>
    <a Leo command name><Enter>
    
To use Python's help system, type::
    
    <Alt-X>help-for-python<Enter>
    <a python symbol><Enter>

'''
#@+node:ekr.20100901080826.5850: *5* helpForAbbreviations
def helpForAbbreviations (self,event=None):
    '''Prints a discussion of abbreviations.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20110530082209.18251: *6* << define s >> (helpForAbbreviations)
@language rest

s = '''\

About Abbreviations
-------------------

Alt-0 (vr-toggle) hides this help message.

Leo optionally expands abbreviations as you type.

Abbreviations typically end with something like ";;" so they won't trigger
by accident.

You define abbreviations in @data abbreviations nodes or @data
global-abbreviations nodes. None come predefined, but leoSettings.leo
contains example abbreviations in the node::

    @@data abbreviations examples

Abbreviations can simply be shortcuts::

    ncn;;=@nocolor
    
Abbreviations can span multiple lines. Continued lines start with \\:, like
this::

    form;;=<form action="main_submit" method="get" accept-charset="utf-8">
    \:<p><input type="submit" value="Continue &rarr;"></p>
    \:</form>\n

Abbreviations can define templates in which <\|a-field-name\|> denotes a field
to be filled in::

    input;;=<input type="text/submit/hidden/button"
    \:name="<|name|>"
    \:value="" id="<|id|>">\n

Typing ",," after inserting a template selects the next field.

Abbreviations can execute **abbreviation scripts**, delimited by {\|{ and
}\|}::

    date;;={|{import time ; x=time.asctime()}|}
    ts;;={|{import time ; x=time.strftime("%Y%m%d%H%M%S")}|}
    
For example, typing ts;; gives::

    20131009171117
    
It's even possible to define a context in which abbreviation scripts execute.

See leoSettings.leo for full details.

'''
#@+node:ekr.20060226131603.1: *5* helpForAutocompletion
def helpForAutocompletion (self,event=None):
    '''Prints a discussion of autocompletion.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20110530082209.18252: *6* << define s >> (helpForAutocompletion)
# @pagewidth 40
@language rest

s = '''

About Autocompletion and Calltips
---------------------------------

Alt-0 (vr-toggle) hides this help message.

This documentation describes both
autocompletion and calltips.

Typing a period when @language python is
in effect starts autocompletion. Typing
'(' during autocompletion shows the
calltip. Typing Return or Control-g
(keyboard-quit) exits autocompletion or
calltips.

Autocompletion
==============

Autocompletion shows what may follow a
period in code. For example, after
typing g. Leo will show a list of all
the global functions in leoGlobals.py.
Autocompletion works much like tab
completion in the minibuffer. Unlike the
minibuffer, the presently selected
completion appears directly in the body
pane.

A leading period brings up 'Autocomplete
Modules'. (The period goes away.) You
can also get any module by typing its
name. If more than 25 items would appear
in the Autocompleter tab, Leo shows only
the valid starting characters. At this
point, typing an exclamation mark shows
the complete list. Thereafter, typing
further exclamation marks toggles
between full and abbreviated modes.

If x is a list 'x.!' shows all its
elements, and if x is a Python
dictionary, 'x.!' shows list(x.keys()).
For example, 'sys.modules.!' Again,
further exclamation marks toggles
between full and abbreviated modes.

During autocompletion, typing a question
mark shows the docstring for the object.
For example: 'g.app?' shows the
docstring for g.app. This doesn't work
(yet) directly for Python globals, but
'__builtin__.f?' does. Example:
'__builtin__.pow?' shows the docstring
for pow.

Autocompletion works in the Find tab;
you can use <Tab> to cycle through the
choices. The 'Completion' tab appears
while you are doing this; the Find tab
reappears once the completion is
finished.

Calltips
========

Calltips appear after you type an open
parenthesis in code. Calltips shows the
expected arguments to a function or
method. Calltips work for any Python
function or method, including Python's
global function. Examples:

a) g.toUnicode(
   gives:
   g.toUnicode(s,encoding, reportErrors=False

b) c.widgetWantsFocusNow
   gives:
   c.widgetWantsFocusNow(w

c) reduce(
   gives:
   reduce(function, sequence[,initial]) -> value

The calltips appear directly in the text
and the argument list is highlighted so
you can just type to replace it. The
calltips appear also in the status line
for reference after you have started to
replace the args.

Options
=======

Both autocompletion and calltips are
initially enabled or disabled by the
enable_autocompleter_initially and
enable_calltips_initially settings in
leoSettings.leo. You may enable or
disable these features at any time with
these commands: enable-autocompleter,
enable-calltips, disable-autocompleter
and disable-calltips. '''
#@+node:ekr.20060205170335: *5* helpForBindings
def helpForBindings (self,event=None):
    '''Prints a discussion of keyboard bindings.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20110530082209.18253: *6* << define s >> (helpForBindings)
# @pagewidth 40
@language rest

s = '''

About Key Bindings
------------------

Alt-0 (vr-toggle) hides this help message.

A shortcut specification has the form:

command-name = shortcutSpecifier

or

command-name ! pane = shortcutSpecifier

The first form creates a binding for all
panes except the minibuffer. The second
form creates a binding for one or more
panes. The possible values for 'pane'
are:

====    ===============
pane    bound panes
====    ===============
all     body,log,tree
body    body
log     log
mini    minibuffer
text    body,log
tree    tree
====    ===============

You may use None as the specifier.
Otherwise, a shortcut specifier consists
of a head followed by a tail. The head
may be empty, or may be a concatenation
of the following: (All entries in each
row are equivalent)::

    Shift+ Shift-
    Alt+ or Alt-
    Control+, Control-, Ctrl+ or Ctrl-

Notes:

1. The case of plain letters is significant:
   a is not A.

2. The Shift- (or Shift+) prefix can be
   applied *only* to letters or
   multi-letter tails. Leo will ignore
   (with a warning) the shift prefix
   applied to other single letters,
   e.g., Ctrl-Shift-(

3. The case of letters prefixed by
   Ctrl-, Alt-, Key- or Shift- is *not*
   significant.

The following table illustrates these
rules. In each row, the first entry is
the key (for k.bindingsDict) and the
other entries are equivalents that the
user may specify in leoSettings.leo::

    a, Key-a, Key-A
    A, Shift-A
    Alt-a, Alt-A
    Alt-A, Alt-Shift-a, Alt-Shift-A
    Ctrl-a, Ctrl-A
    Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
    !, Key-!,Key-exclam,exclam

'''
#@+node:ekr.20060417203717: *5* helpForCommand & helpers
def helpForCommand (self,event):
    '''Prompts for a command name and prints the help message for that command.'''
    c,k = self.c,self.k
    s = '''\
Alt-0 (vr-toggle) hides this help message.

Type the name of the command, followed by Return.
'''
    c.putHelpFor(s)
    c.minibufferWantsFocusNow()
    k.fullCommand(event,help=True,helpHandler=self.helpForCommandFinisher)
#@+node:ekr.20120521114035.9870: *6* getBindingsForCommand
def getBindingsForCommand(self,commandName):

    c = self.c ; k = c.k
    data = [] ; n1 = 4 ; n2 = 20
    d = k.bindingsDict
    for stroke in sorted(d):
        assert g.isStroke(stroke),repr(stroke)
        aList = d.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            if si.commandName == commandName:
                pane = '' if si.pane=='all' else ' %s:' % (si.pane)
                s1 = pane
                s2 = k.prettyPrintKey(stroke)
                s3 = si.commandName
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)

    data.sort(key=lambda x: x[1])
    return ','.join(['%s %s' % (s1,s2) for s1,s2,s3 in data]).strip()
#@+node:ekr.20120521114035.9871: *6* helpForCommandFinisher
def helpForCommandFinisher (self,commandName):

    c,s = self.c,None
    if commandName and commandName.startswith('help-for-'):
        # Execute the command itself.
        c.k.simulateCommand(commandName)
    else:
        if commandName:
            bindings = self.getBindingsForCommand(commandName)
            func = c.commandsDict.get(commandName)
            s = g.getDocStringForFunction(func)
            if s:
                s = self.replaceBindingPatterns(s)
            else:
                s = 'no docstring available'
            # Create the title.
            s2 = '%s (%s)' % (commandName,bindings) if bindings else commandName
            underline = '+' * len(s2)
            # title = '%s\n%s\n%s\n\n' % (underline,s2,underline)
            title = '%s\n%s\n\n' % (s2,underline)
            # Fixes bug 618570:
            s = title + ''.join([
                line.lstrip() if line.strip() else '\n'
                    for line in g.splitLines(s)])
        else:
            << set s to about help-for-command >>
        c.putHelpFor(s) # calls g.adjustTripleString.
#@+node:ekr.20120521114035.9872: *7* << set s to about help-for-command >>
s = '''\

++++++++++++++++++++++++
About Leo's help command
++++++++++++++++++++++++

Invoke Leo's help-for-command as follows::

    <F1>
    <Alt-X>help-for-command<return>

Next, type the name of one of Leo's commands.
You can use tab completion.  Examples::

    <F1><tab>           shows all commands.
    <F1>help-for<tab>   shows all help-for- commands.

Here are the help-for commands::

    help-for-abbreviations
    help-for-autocompletion
    help-for-bindings
    help-for-command
    help-for-debugging-commands
    help-for-dynamic-abbreviations
    help-for-find-commands
    help-for-minibuffer
    help-for-python
    help-for-regular-expressions

'''
#@+node:ekr.20120524151127.9886: *6* replaceBindingPatterns
def replaceBindingPatterns (self,s):

    '''For each instance of the pattern !<command-name>! is s,
    replace the pattern by the key binding for command-name.'''

    c = self.c
    pattern = re.compile('!<(.*)>!')
    while True:
        m = pattern.search(s,0)
        if m is None: break
        name = m.group(1)
        junk,aList = c.config.getShortcut(name)
        for si in aList:
            if si.pane == 'all':
                key = c.k.prettyPrintKey(si.stroke.s)
                break
        else: key = '<Alt-X>%s<Return>' % name
        s = s[:m.start()] + key + s[m.end():]
    return s

#@+node:ekr.20131213163822.16472: *5* helpForCreatingExternalFiles
def helpForCreatingExternalFiles(self,event=None):
    '''Prints a discussion of creating external files.'''
    << define s >>
    s = s.replace('\\','')
    self.c.putHelpFor(s)
#@+node:ekr.20131213163822.16477: *6* << define s >> (helpForCreatingExternalFiles)
@language rest

s = '''

Creating External Files
-------------------------

This help discusses only @file nodes.
For other ways of creating external files, see::

    http://leoeditor.com/tutorial-programming.html or
    http://leoeditor.com/directives.html

Leo creates external files in an unusual way.
Please fee free to ask for help::

    https://groups.google.com/forum/#!forum/leo-editor or
    http://webchat.freenode.net/?channels=%23leo&uio=d4

Overview
========

Leo creates **external files** (files on your file system) from
**@file nodes** and *all the descendants* of the @file node.
Examples::

    @file spam.py
    @file ../foo.c
    @file ~/bar.py
    
A single Leo outline may contain many @file nodes. As a result, Leo
outlines function much like project files in other IDE's (Integrated
development environments).

Within an @file tree, simple text markup (discussed next) tells Leo how
to create the external file from the @file node and its descendants.

Markup
======
   
Section references and the \\@all and \\@others directives tell
Leo how to create external files.

- A **section name** is any text of the form::

    <\\< any text >\\> (>> must not appear in "any text".)

- A **section definition node** is any node whose headline starts with a section name.

- A **section reference** is a section name that appears in body text.

Leo creates external files containing \\@others directives by writing the
*expansion* of the @file node. The **expansion** of *any* node is the
node's body text after making these text **substitutions**:

- Leo replaces \\@all by the *unexpanded* body text of *all* nodes.

- Leo replaces \\@others with the *expansion* of all descendant nodes
  **except** section definition nodes. That's how \\@others got its name.

- Leo replaces section references by the *expansion* of the body text of
  the corresponding section definition node.
   
Whitespace is significant before \\@others and section references. Leo adds
the leading whitespace appearing before each \\@others directive or section
reference to every line of their expansion. As a result, Leo can generate
external files even for Python.  The following cute trick works::

    if 1:
        <\\< a section >\\>
    if 0:
        \\@others

**Notes**:

- Any node may contain a single \\@others directive. No node may contain more
  than one \@others directive.

- Nodes that *aren't* section definition nodes are included in the expansion
  of the *nearest* ancestor node containing an @others directive.

**Example 1**: The body of the @file node for a typical Python module will
look something like::

    '\\''A docstring.'\\''
    <\\< imports >\\>
    \@others
    if __name__ == '__main__':
        main()
        
**Example 2**:  Here is a typical Python class definition in Leo::

    class MyClass:
        '\\''A docstring.'\\''
        \@others
        
\@first and @last
=================

The @first directive forces lines to appear before the first sentinel of a
external file. For example::

    @first #! /usr/bin/env python
    @first # -*- coding: utf-8 -*-

Similarly, @last forces lines to appear after the last sentinel.

\\@path
=======

Rather than specifying long paths in @file nodes, you can specify a path in
an ancestor @path node.

For example, suppose three nodes have the following headlines::

    @path a
        @path b
            @file c/d.py

The @file node creates the file a/b/c/d.py

Within @path and @<file> paths, {{exp}} gets evaluated with the following
predefined symbols: c, g, p, os and sys.  For example::

    @file {{os.path.abspath(os.curdir)}}/abc.py

'''
#@+node:ekr.20070501092655: *5* helpForDebuggingCommands
def helpForDebuggingCommands (self,event=None):
    '''Prints a discussion of of Leo's debugging commands.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20070501092655.1: *6* << define s >> (helpForDebuggingCommands)
# @pagewidth 40
@language rest

s = '''

About Debugging Commands
------------------------

Alt-0 (vr-toggle) hides this help message.

The following commands are useful for debugging::

    collect-garbage:   Invoke the garbage collector.
    debug:             Start an external debugger in another process.
    disable-gc-trace:  Disable tracing of the garbage collector.
    dump-all-objects:  Print a summary of all existing Python objects.
    dump-new-objects:  Print a summary of all newly-created Python objects.
    enable-gc-trace:   Enable tracing of the garbage collector.
    free-tree-widgets: Free all widgets used in Leo's outline pane.
    print-focus:       Print information about the requested focus.
    print-stats:       Print statistics about existing Python objects.
    print-gc-summary:  Print a brief summary of all Python objects.
    run-unit-tests:    Run unit tests in the presently selected tree.
    verbose-dump-objects: Print a more verbose listing of all existing Python objects.

Leo also has many debugging settings that enable and disable traces.
For details, see the node: @settings-->Debugging in leoSettings.leo.
'''
#@+node:ekr.20141008000933.20113: *5* helpForDragAndDrop
def helpForDragAndDrop (self,event=None):
    '''Prints a discussion of of Leo's debugging commands.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20141008000933.20114: *6* << define s >> (helpForDragAndDrop
# @pagewidth 40
@language rest

s = '''

About Drag and Drop
===================

Nodes
-----

You may drag nodes from within a Leo outline or between Leo outlines,
including nodes from separately running copies of Leo.

To drag, click and hold on a headline and drag it over another headline.
Control-drags create clones; regular drags move the node.


Files
-----

You may also drag one or more files from a file folder over a headline.

For text files, Leo will create @auto, @edit or @file nodes as appropriate.

Dragging .leo files from a file folder to a Leo outline works like the
open-outline command. Control-dragging .leo files copies all nodes of the
.leo file to the receiving outline, under a single node called::

    From <name of .leo file>

'''
#@+node:ekr.20131029061413.17094: *5* helpForDynamicAbbreviations
def helpForDynamicAbbreviations (self,event=None):
    '''Prints a discussion of abbreviations.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20131029061413.17095: *6* << define s >> (helpForDynamicAbbreviations)
@language rest

s = '''

About Dynamic Abbreviations
---------------------------

Alt-0 (vr-toggle) hides this help message.

.. Description taken from http://www.emacswiki.org/emacs/DynamicAbbreviations

A dynamic abbreviation (dabbrev) is like a normal abbreviation except:

- You do not have to define it(!)
- You expand it with Alt-/ (dabbrev-expand) or Alt-Ctrl-/ (dabbrev-completion)

For example, suppose the text aLongIvarName appears anywhere in the
outline. To type this name again type::

    aLong<Alt-/>

You will see a list of possible completions in the log pane.

Alt-Ctrl-/ (dabbrev-completion) inserts the longest prefix of all
completions immediately.  For instance, suppose the following appear in text::

    aVeryLongIvarName
    aVeryLongMethodName
    
Typing::

    aVery<Alt-Ctrl-/>
    
will immediately extend the typing to::

    aVeryLong

'''
#@+node:ekr.20060205170335.1: *5* helpForFindCommands
def helpForFindCommands (self, event=None):
    '''Prints a discussion of of Leo's find commands.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20130411023826.16595: *6* << define s >> (help-for-find-commands)
@language rest

s = '''

Finding & replacing text
------------------------

Alt-0 (vr-toggle) hides this help message.

**Ctrl-F** (start-search) shows the Find pane
and puts focus in the find box.

Enter the find text and the replacement text if desired::

    Tab switches focus from widget to widget.
    Return executes the find-next command.

When Leo selects the found text you can do::

    Ctrl-equal (replace)
    Ctrl-minus (replace-then-find)
    F3 (find-next)
    F2 (find-previous)
    Ctrl-G (keyboard-quit)
    anything else :-)

You can Leo's commands toggle check boxes and radio buttons.
These commands are listed in the Search menu.

You can execute these commands (and see their key bindings)
using the minibuffer::

    <Alt-X>tog<tab>f<tab>   or
    <Alt-X>set<tab>f<tab>

Incremental searching
---------------------

Incremental search is done only from the minibuffer::

    Alt-I (isearch forward)
    Alt-R (isearch backward)
    BackSpace retracts the search
    All other characters extend the search

During an incremental search::

    Enter or Ctrl-G stops the search.
    Alt-S finds the search string again.
    Alt-R ditto for reverse searches.
'''
#@+node:ekr.20051014170754: *5* helpForMinibuffer
def helpForMinibuffer (self,event=None):
    '''Print a messages telling you how to get started with Leo.'''
    # A bug in Leo: triple quotes puts indentation before each line.
    c = self.c    
    << define s >>
    c.putHelpFor(s)
#@+node:ekr.20120522024827.9899: *6* << define s >> (helpForMinibuffer)
@language rest

s = '''\

About the Minibuffer
--------------------

Alt-0 (vr-toggle) hides this help message.

The mini-buffer is intended to be like the Emacs buffer:

full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a
full command name, then hit <Return> to execute the command. Tab completion
works, but not yet for file names.

quick-command-mode (default shortcut: Alt-x). Like Emacs Control-C. This mode is
defined in leoSettings.leo. It is useful for commonly-used commands.

universal-argument (default shortcut: Alt-u). Like Emacs Ctrl-u. Adds a repeat
count for later command. Ctrl-u 999 a adds 999 a's. Many features remain
unfinished.

keyboard-quit (default shortcut: Ctrl-g) Exits any minibuffer mode and puts
the focus in the body pane.

Use the help-for-command command to see documentation for a particular command.
'''
#@+node:ekr.20120522024827.9897: *5* helpForRegularExpressions
def helpForRegularExpressions (self, event=None):
    '''Prints a discussion of of Leo's find commands.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20120522024827.9898: *6* << define s >> (helpForRegularExpressions)
@language rest

# Using raw string is essential.

s = r'''

About regular expressions
-------------------------

Alt-0 (vr-toggle) hides this help message.

Python's regular expressions, http://docs.python.org/library/re.html,
are valid in find patterns::

    .               Matches any character (including newline if DOTALL flag specified).
    ^               Matches start of the string (of every line in MULTILINE mode).
    $               Matches end of the string (of every line in MULTILINE mode).
    *               0 or more of preceding regular expression (as many as possible).
    +               1 or more of preceding regular expression (as many as possible).
    ?               0 or 1 occurrence of preceding regular expression.
    *?, +?, ??      Same as *, + and ? but matches as few characters as possible.
    {m,n}           Matches from m to n repetitions of preceding RE.
    {m,n}?          Same as {m,n}, but attempting to match as few repetitions as possible.
    [ ]             Defines character set: e.g. '[a-zA-Z]' to match all letters (see also \w \S).
    [^ ]            Defines complemented character set: matches if char is NOT in set.
    \               Escapes special chars '*?+&$|()' and introduces special sequences (see below).
                    If not using a raw string, write as '\\' in the pattern string.
    \\              Matches a literal '\'.
    |               Specifies alternative: 'foo|bar' matches 'foo' or 'bar'.
    (...)           Matches any RE inside (), and delimits a group.
    (?:...)         Mathces RE inside (), but doesn't delimit a group.
    (?P<name>...)   Matches any RE inside (), and delimits a named group.
                    r'(?P<id>[a-zA-Z_]\w*)' defines a group named id.
    (?P=name)       Matches whatever text was matched by the earlier group named name.
    (?=...)         Matches if ... matches next, but doesn't consume any of the string
                    'Isaac (?=Asimov)' matches 'Isaac' only if followed by 'Asimov'.
    (?!...)         Matches if ... doesn't match next. Negative of (?=...).
    (?<=...)        Matches if the current position in the string is preceded by a match
                    for ... that ends at the current position.
                    This is called a positive lookbehind assertion.
    (?<!...)        Matches if the current position in the string is not preceded by a match for ...
                    This is called a negative lookbehind assertion.
    (?(group)A|B)   Group is either a numeric group ID or a group name defined with (?Pgroup...)
                    earlier in the expression.
                    If the specified group matched, the regular expression pattern A will be tested
                    against the string; if the group didn't match, the pattern B will be used instead.
    (?#...)         A comment; ignored.
    (?letters)      Each letter is in 'ilmsux' and sets the corresponding flag.
                    re.I, re.L, re.M, re.S, re.U, re.X.
    \number         Matches content of the group of the same number.     
    \A              Matches only at the start of the string.
    \b              Empty str at beginning or end of word:
                    '\bis\b' matches 'is', but not 'his'.
    \B              Empty str NOT at beginning or end of word.
    \d              Any decimal digit:          [0-9]
    \D              Any non-decimal digit char  [^0-9]).
    \s              Any whitespace char         [ \t\n\r\f\v]
    \S              Any non-whitespace char     [^ \t\n\r\f\v]
    \w              Any alphaNumeric char (depends on LOCALE flag).
    \W              Any non-alphaNumeric char (depends on LOCALE flag).
    \Z              Matches only at the end of the string.

'''
#@+node:ekr.20131213163822.16473: *5* helpForScripting
def helpForScripting(self,event=None):
    '''Prints a discussion of Leo scripting.'''
    << define s >>
    self.c.putHelpFor(s)
#@+node:ekr.20131213163822.16475: *6* << define s >> (helpForScripting)
@language rest

s = '''

Summary of Leo Scripting
-------------------------

Overview
========

Any Leo node may contain a Python script.

Ctrl-B (execute-script) executes the body text of the presently selected node.

execute-script creates the script using @others and section references:
**you can create complex scripts from a node and its descendants.**

As discussed below, execute-script predefines three variables: c, g and p.
Using these variables, scripts may easily do any of the following:

- Gain access to all data contained in any Leo outline.
- Traverse the data in any outline.
- Use utility classes and function in the leo.core.leoGlobals module.
- Execute any code in Leo's own code base.

*Tip*: use Alt-1 (toggle-autocompleter) and Alt-2 (toggle-calltips) as aids to memory and to speed typing.

Predefined symbols
==================

The execute-script command predefines three variables::

    c: The commander of the present outline.
    g: The leo.core.leoGlobals module.
    p: The presently selected position, c.p.
    
@test scripts predefine all the above, plus::

    self: The instance of unittest.TestCase
    
Commands class
==============
    
A commander is an instance of the Commands class in leo.core.leoCommands.
A commander represents all outline data and most of Leo's source code.
Here are the most important ivars of the Commands class::

    c.frame         c's outer frame, a LeoFrame instance.
    c.user_dict     a temporary dict for use of scripts and plugins.
    c.redraw()
    c.positionExists(p)

Here is a partial list of the **official ivars** of any commander c:

    c.frame                 The frame containing the log,body,tree, etc.
    c.frame.body            The body pane.
    c.frame.body.widget     The gui widget for the body pane.
    c.frame.body.wrapper    The high level interface for the body widget.
    c.frame.iconBar         The icon bar.
    c.frame.log             The log pane.
    c.frame.log.widget      The gui widget for the log pane.
    c.frame.log.wrapper     The high-level inteface for the log pane.
    c.frame.tree            The tree pane.
    
VNode class
===========

All data in Leo outlines resides in vnodes.
All clones of the same node share the same VNode.
Here are the most important ivars and properties of the VNode class::

    v.b: v's body text.
    v.h: v's headline text.
    v.u: v.unknownAttributes, a persistent Python dictionary.
    
v.u (uA's or unknownAttributes or userAttributes) allow plugins or scripts
to associate persistent data with vnodes. For details see the section about
userAttributes in the Customizing Leo chapter.

position class
==============

A position represents the state of a traversal of an outline.
Because of clones, the same VNode may appear multiple times during a traversal.

Properties of the position class::

    p.b: same as p.v.b.
    p.h: same as p.v.h.
    p.u: same as p.v.u.

Getter methods of the position class::

    p.back()
    p.children()
    p.firstChild()
    p.hasBack()
    p.hasChildren()
    p.hasNext()
    p.hasParent()
    p.hasThreadBack()
    p.hasThreadNext()
    p.isAncestorOf(p2)
    p.isAnyAtFileNode()
    p.isAt...Node()
    p.isCloned()
    p.isDirty()
    p.isExpanded()
    p.isMarked()
    p.isRoot()
    p.isVisible()
    p.lastChild()
    p.level()
    p.next()
    p.nodeAfterTree()
    p.nthChild()
    p.numberOfChildren()
    p.parent()
    p.parents()
    p.threadBack()
    p.threadNext()
    p.visBack()
    p.visNext()
    
Setter methods of the position class::

    p.setDirty()
    p.setMarked()

Methods that operate on nodes::

    p.clone()
    p.contract()
    p.doDelete(new_position)
    p.expand()
    p.insertAfter()
    p.insertAsNthChild(n)
    p.insertBefore()
    p.moveAfter(p2)
    p.moveToFirstChildOf(parent,n)
    p.moveToLastChildOf(parent,n)
    p.moveToNthChildOf(parent,n)
    p.moveToRoot(oldRoot=None)
        # oldRoot **must** be the old root position if it exists.

The following position methods move positions *themselves*: they change the
node to which a position refers. They do *not* change outline structure in
any way! Use these when generators are not flexible enough::

    p.moveToBack()
    p.moveToFirstChild()
    p.moveToLastChild()
    p.moveToLastNode()
    p.moveToNext()
    p.moveToNodeAfterTree(p2)
    p.moveToNthChild(n)) 
    p.moveToParent()
    p.moveToThreadBack()
    p.moveToThreadNext()
    p.moveToVisBack(c)
    p.moveToVisNext(c)

Generators
==========

The following Python generators return positions::

    c.all_positions()
    c.all_unique_positions()
    p.children()
    p.parents()
    p.self_and_parents()
    p.self_and_siblings()
    p.following_siblings()
    p.subtree()
    p.self_and_subtree()
    
The leo.core.leoGlobals module
==============================

**g vars**::

    g.app
    g.app.gui
    g.app.windowlist
    g.unitTesting
    g.user_dict  # a temporary dict for use of scripts and plugins.
    
**g decorator**::

    @g.command(command-name)
    
**g functions** (the most interesting: there are many more in leoGlobals.py)::
    
    g.angleBrackets()
    g.app.commanders()
    g.app.gui.guiName()
    g.es(*args,**keys)
    g.es_print(*args,**keys)
    g.es_exception()
    g.getScript(c,p,
        useSelectedText=True,
        forcePythonSentinels=True,
        useSentinels=True)
    g.openWithFileName(fileName,old_c=None,gui=None)
    g.os_path_... # Wrappers for os.path methods.
    g.pdb(message='')
    g.toEncodedString(s,encoding='utf-8',reportErrors=False)
    g.toUnicode(s, encoding='utf-8',reportErrors=False)
    g.trace(*args,**keys)
    g.warning(*args,**keys)

'''
#@+node:ekr.20070418074444: *5* printSettings
def printSettings (self,event=None):
    '''
    Prints the value of every setting, except key bindings and commands and
    open-with tables. The following shows where the active setting came
    from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,
    '''
    self.c.config.printSettings()
#@+node:ekr.20060602154458: *5* pythonHelp
def pythonHelp (self,event=None):
    '''Prompt for a arg for Python's help function, and put it to the log pane.'''
    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)
    if state == 0:
        c.minibufferWantsFocus()
        k.setLabelBlue('Python help: ')
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            # Capture the output of Python's help command.
            old = sys.stdout
            try:
                sys.stdout = stdout = g.FileLikeObject()
                help(str(s))
                s2 = stdout.read()
            finally:
                sys.stdout = old
            # Send it to the vr pane as a <pre> block
            s2 = '<pre>' + s2 + '</pre>'
            c.putHelpFor(s2)
#@+node:ekr.20050920084036.171: *4* KeyHandlerCommandsClass (add docstrings)
class KeyHandlerCommandsClass (BaseEditCommandsClass):

    '''User commands to access the keyHandler class.'''

    @others
#@+node:ekr.20050920084036.172: *5*  ctor (KeyHandlerCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.
#@+node:ekr.20050920084036.173: *5* getPublicCommands (KeyHandlerCommandsClass)
def getPublicCommands (self):

    k = self.k

    if k:
        return {
            'auto-complete':            k.autoCompleter.autoComplete,
            'auto-complete-force':      k.autoCompleter.autoCompleteForce,
            'digit-argument':           k.digitArgument,
            'disable-autocompleter':    k.autoCompleter.disableAutocompleter,
            'disable-calltips':         k.autoCompleter.disableCalltips,
            'enable-autocompleter':     k.autoCompleter.enableAutocompleter,
            'enable-calltips':          k.autoCompleter.enableCalltips,
            'exit-named-mode':          k.exitNamedMode,
            'full-command':             k.fullCommand, # For menu.
            # 'hide-mini-buffer':         k.hideMinibuffer,
            'menu-shortcut':            self.menuShortcutPlaceHolder,
            'mode-help':                k.modeHelp,
            'negative-argument':        k.negativeArgument,
            'number-command':           k.numberCommand,
            'number-command-0':         k.numberCommand0,
            'number-command-1':         k.numberCommand1,
            'number-command-2':         k.numberCommand2,
            'number-command-3':         k.numberCommand3,
            'number-command-4':         k.numberCommand4,
            'number-command-5':         k.numberCommand5,
            'number-command-6':         k.numberCommand6,
            'number-command-7':         k.numberCommand7,
            'number-command-8':         k.numberCommand8,
            'number-command-9':         k.numberCommand9,
            'print-bindings':           k.printBindings,
            'print-buttons':            k.printButtons,
            'print-commands':           k.printCommands,
            'repeat-complex-command':   k.repeatComplexCommand,
            # 'scan-for-autocompleter':   k.autoCompleter.scan,
            'set-command-state':        k.setCommandState,
            'set-insert-state':         k.setInsertState,
            'set-overwrite-state':      k.setOverwriteState,
            'show-calltips':            k.autoCompleter.showCalltips,
            'show-calltips-force':      k.autoCompleter.showCalltipsForce,
            # 'show-mini-buffer':         k.showMinibuffer,
            'toggle-autocompleter':     k.autoCompleter.toggleAutocompleter,
            'toggle-calltips':          k.autoCompleter.toggleCalltips,
            #'toggle-mini-buffer':       k.toggleMinibuffer,
            'toggle-input-state':       k.toggleInputState,
            'universal-argument':       k.universalArgument,
        }
    else:
        return {}
#@+node:ekr.20131221055224.17570: *5* def menuShortcutPlaceHolder
g.command('menu-shortcut')
def menuShortcutPlaceHolder(self,event=None):
    '''This will never be called.
    It serves as a placeholder for the print-bindings command.'''
#@+node:ekr.20050920084036.174: *4* KillBufferCommandsClass
class KillBufferCommandsClass (BaseEditCommandsClass):

    '''A class to manage the kill buffer.'''

    @others
#@+node:ekr.20050920084036.175: *5*  ctor & finishCreate (KillBufferCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.addWsToKillRing = c.config.getBool('add-ws-to-kill-ring')
    self.k = None
    self.kbiterator = self.iterateKillBuffer()
    self.last_clipboard = None  # For interacting with system clipboard.
    self.lastYankP = None
        # Position of the last item returned by iterateKillBuffer.
    self.reset = None
        # The index of the next item to be returned in
        # g.app.globalKillBuffer by iterateKillBuffer.

def finishCreate (self):

    BaseEditCommandsClass.finishCreate(self)
        # Call the base finishCreate.
        # This sets self.k
#@+node:ekr.20050920084036.176: *5*  getPublicCommands
def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-to-end-of-line':      self.killToEndOfLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'kill-ws':                  self.killWs,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
#@+node:ekr.20050920084036.183: *5* addToKillBuffer
def addToKillBuffer (self,text):

    '''Insert the text into the kill buffer if force is True or
    the text contains something other than whitespace.'''

    if self.addWsToKillRing or text.strip():
        g.app.globalKillBuffer = [
            z for z in g.app.globalKillBuffer if z != text]
        g.app.globalKillBuffer.insert(0,text)
#@+node:ekr.20050920084036.181: *5* backwardKillSentence
def backwardKillSentence (self,event):

    '''Kill the previous sentence.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.rfind('.',ins)
    if i == -1: return

    undoType='backward-kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,i) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.180: *5* backwardKillWord & killWord
def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c ; e = c.editCommands
    self.beginCommand(undoType='backward-kill-word')
    e.backwardWord(event)
    self.killWordHelper(event,'back')

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    self.beginCommand(undoType='kill-word')
    self.killWordHelper(event,'forward')

def killWordHelper(self,event,direction):
    c = self.c ; e = c.editCommands ; w = e.editWidget(event)
    # self.killWs(event)
    e.extendToWord(event,direction)
    i,j = w.getSelectionRange()
    self.kill(event,i,j,undoType = None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20051216151811: *5* clearKillRing
def clearKillRing (self,event=None):

    '''Clear the kill ring.'''

    g.app.globalKillbuffer = []
#@+node:ekr.20050920084036.185: *5* getClipboard
def getClipboard (self):

    '''Return the contents of the clipboard.'''

    try:
        ctxt = g.app.gui.getTextFromClipboard()
        if not g.app.globalKillBuffer or ctxt != self.last_clipboard:
            self.last_clipboard = ctxt
            if not g.app.globalKillBuffer or g.app.globalKillBuffer [0] != ctxt:
                return ctxt
    except Exception:
        g.es_exception()

    return None
#@+node:ekr.20050920084036.184: *5* iterateKillBuffer
class KillBufferIterClass:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def iterateKillBuffer (self):

    return self.KillBufferIterClass(self.c)
#@+node:ekr.20071003160252.1: *6* __init__ & __iter__ (iterateKillBuffer)
def __init__(self,c):

    # g.trace('iterateKillBuffer.__init')
    self.c = c
    self.index = 0 # The index of the next item to be returned.

def __iter__(self):

    return self
#@+node:ekr.20071003160252.2: *6* next
def next(self):

    commands = self.c.killBufferCommands
    aList = g.app.globalKillBuffer # commands.killBuffer

    # g.trace(g.listToString([repr(z) for z in aList]))

    if not aList:
        self.index = 0
        return None

    if commands.reset is None:
        i = self.index
    else:
        i = commands.reset
        commands.reset = None

    if i < 0 or i >= len(aList): i = 0
    # g.trace(i)
    val = aList[i]
    self.index = i + 1
    return val

__next__ = next
#@+node:ekr.20050920084036.178: *5* kill
def kill (self,event,frm,to,undoType=None):

    '''A helper method for all kill commands.'''

    w = self.editWidget(event)
    if not w: return
    s = w.get(frm,to)
    # g.trace(repr(s))
    if undoType: self.beginCommand(undoType=undoType)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    w.delete(frm,to)
    w.setInsertPoint(frm)
    if undoType:
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20130918042415.11297: *5* killToEndOfLine (New in Leo 4.11)
def killToEndOfLine (self,event):
    '''Kill from the cursor to end of the line.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    # g.trace(ins,j,repr(s[i:j]))
    if ins >= len(s) and g.match(s,j-1,'\n'):
        # Kill the trailing newline of the body text.
        i = max(0,len(s)-1)
        j = len(s)
    elif ins + 1 < j and s[ins:j-1].strip() and g.match(s,j-1,'\n'):
        # Kill the line, but not the newline.
        i,j = ins,j-1
    elif g.match(s,j-1,'\n'):
        i = ins # Kill the newline in the present line.
    else:
        i = j
    if i < j:
        self.kill(event,i,j,undoType='kill-line')
#@+node:ekr.20071003183657: *5* KillLine
def killLine (self,event):
    '''Kill the line containing the cursor.'''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    if ins >= len(s) and g.match(s,j-1,'\n'):
        # Kill the trailing newline of the body text.
        i = max(0,len(s)-1)
        j = len(s)
    elif j > i+1 and g.match(s,j-1,'\n'):
        # Kill the line, but not the newline.
        j -= 1
    else:
        pass # Kill the newline in the present line.
    self.kill(event,i,j,undoType='kill-line')
#@+node:ekr.20050920084036.182: *5* killRegion & killRegionSave & helper
def killRegion (self,event):
    '''Kill the text selection.'''
    self.killRegionHelper(event,deleteFlag=True)

def killRegionSave (self,event):
    '''Add the selected text to the kill ring, but do not delete it.'''
    self.killRegionHelper(event,deleteFlag=False)

def killRegionHelper (self,event,deleteFlag):

    w = self.editWidget(event)
    if not w: return
    i,j = w.getSelectionRange()
    if i == j: return
    s = w.getSelectedText()
    if deleteFlag:
        self.beginCommand(undoType='kill-region')
        w.delete(i,j)
        self.c.frame.body.forceFullRecolor()
        self.endCommand(changed=True,setLabel=True)
    self.addToKillBuffer(s)
    g.app.gui.replaceClipboardWith(s)
    # self.removeRKeys(w)
#@+node:ekr.20050930095323.1: *5* killSentence
def killSentence (self,event):

    '''Kill the sentence containing the cursor.'''

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins)
    if i == -1: return

    undoType='kill-sentence'

    self.beginCommand(undoType=undoType)

    i2 = s.rfind('.',0,ins) + 1
    self.kill(event,i2,i+1,undoType=undoType)
    self.c.frame.body.forceFullRecolor()
    w.setInsertPoint(i2)

    self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050930100733: *5* killWs
def killWs (self,event,undoType='kill-ws'):

    '''Kill whitespace.'''

    ws = ''
    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i = j = ins = w.getInsertPoint()

    while i >= 0 and s[i] in (' ','\t'):
        i-= 1
    if i < ins: i += 1

    while j < len(s) and s[j] in (' ','\t'):
        j += 1

    if j > i:
        ws = s[i:j]
        # g.trace(i,j,repr(ws))
        w.delete(i,j)
        if undoType: self.beginCommand(undoType=undoType)
        if self.addWsToKillRing:
            self.addToKillBuffer(ws)
        if undoType: self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050930091642.1: *5* yank
def yank (self,event,pop=False):

    '''yank: insert the first entry of the kill ring.
    yank-pop: insert the next entry of the kill ring.
    '''

    c = self.c ; w = self.editWidget(event)
    if not w: return
    current = c.p
    if not current: return
    text = w.getAllText()
    i, j = w.getSelectionRange()
    clip_text = self.getClipboard()
    if not g.app.globalKillBuffer and not clip_text: return

    undoType = 'yank-pop' if pop else 'yank'
    self.beginCommand(undoType=undoType)
    try:
        if not pop or self.lastYankP and self.lastYankP != current:
            self.reset = 0
        s = self.kbiterator.next()
        if s is None: s = clip_text or ''
        if i != j: w.deleteTextSelection()
        if s != s.lstrip(): # s contains leading whitespace.
            i2,j2 = g.getLine(text,i)
            k = g.skip_ws(text,i2)
            if i2 < i <= k:
                # Replace the line's leading whitespace by s's leading whitespace.
                w.delete(i2,k)
                i = i2
        w.insert(i,s)
        # Fix bug 1099035: Leo yank and kill behaviour not quite the same as emacs.
        # w.setSelectionRange(i,i+len(s),insert=i+len(s))
        w.setInsertPoint(i+len(s))
        self.lastYankP = current.copy()
        c.frame.body.forceFullRecolor()
    finally:
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050930091642.2: *5* yankPop
def yankPop (self,event):

    '''Insert the next entry of the kill ring.'''

    self.yank(event,pop=True)

#@+node:ekr.20050920084036.128: *5* zapToCharacter
def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ')
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        g.app.gui.replaceClipboardWith(s[ins:i]) # Support for proper yank.
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
#@+node:ekr.20050920084036.186: *4* LeoCommandsClass (add docstrings)
class LeoCommandsClass (BaseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.187: *5*  ctor (LeoCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.
#@+node:ekr.20050920084036.188: *5* leoCommands.getPublicCommands
def getPublicCommands (self):
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.'''
    c,k = self.c,self.k
    d2 = {}
    << define dictionary d of names and Leo commands >>
    # Create a callback for each item in d.
    for name in sorted(d):
        f = d.get(name)
        d2 [name] = f
        c.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
    return d2
#@+node:ekr.20050920084036.189: *6* << define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify':                     c.beautifyPythonCode,
    'beautify-c':                   c.beautifyCCode,
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify-tree':                c.beautifyPythonTree,
    'cascade-windows':              f.cascade,
    # 'check-all-python-code':      c.checkAllPythonCode,
    'check-derived-file':           c.atFileCommands.checkDerivedFile,
    'check-leo-file':               c.fileCommands.checkLeoFile,
    'check-outline':                c.checkOutline,
    # 'check-python-code':          c.checkPythonCode,
    'clean-recent-files':           c.cleanRecentFiles,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'clone-node-to-last-node':      c.cloneToLastNode,
    'close-window':                 c.close,
    'contract-all':                 c.contractAllHeadlines,
    'contract-all-other-nodes':     c.contractAllOtherNodes,
    'contract-node':                c.contractNode,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-all-subheads':          c.expandAllSubheads,
        # Fixes bug 604037 Status of expandAllSubheads
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    # 'extract-python-method':        c.extractPythonMethod,
    # 'extract-section':              c.extractSection,
    'find-next-clone':              c.findNextClone,
    'flatten-outline':              c.flattenOutline,
    'flatten-outline-to-node':      c.flattenOutlineToNode,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-first-visible-node':      c.goToFirstVisibleNode,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible-node':       c.goToLastVisibleNode,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-history-node':       c.goToNextHistory,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-history-node':       c.goToPrevHistory,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-file':                  c.importAnyFile,
    # 'import-at-file':               c.importAtFile,
    # 'import-at-root':               c.importAtRoot,
    # 'import-cweb-files':            c.importCWEBFiles,
    # 'import-derived-file':          c.importDerivedFile,
    # 'import-flattened-outline':     c.importFlattenedOutline,
    # 'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-body-time':             c.insertBodyTime,
    'insert-child':                 c.insertChild,
    'insert-node':                  c.insertHeadline,
    'insert-node-before':            c.insertHeadlineBefore,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    # 'mark-changed-roots':           c.markChangedRoots,
    # 'mark-clones':                c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    # 'open-compare-window':        c.openCompareWindow,
    'open-cheat-sheet-leo':         c.openCheatSheet,
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-local-settings':          c.selectAtSettingsNode,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-offline-tutorial':        f.leoHelp,
    'open-online-home':             c.leoHome,
    'open-online-toc':              c.openLeoTOC,
    'open-online-tutorials':        c.openLeoTutorials,
    'open-online-videos':           c.openLeoVideos,
    # 'open-online-tutorial':       c.leoTutorial,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-quickstart-leo':          c.leoQuickStart,
    'open-scripts-leo':             c.openLeoScripts,
    'open-users-guide':             c.openLeoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-auto-nodes':           c.readAtAutoNodes,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-at-shadow-nodes':         c.readAtShadowNodes,
    'read-file-into-node':          c.readFileIntoNode,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    # 'reformat-body':              c.reformatBody, # 2013/10/02.
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'refresh-from-disk':            c.refreshFromDisk,
    'revert':                       c.revert,
    'save-all':                     c.saveAll,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'settings':                     c.preferences,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-recent-files':            c.sortRecentFiles,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-sparse-move':           c.toggleSparseMove,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
    'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
    'write-file-from-node':         c.writeFileFromNode,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
#@+node:ekr.20050920084036.221: *4* RecTangleCommandsClass
class RecTangleCommandsClass (BaseEditCommandsClass):

    @others
#@+node:ekr.20050920084036.222: *5*  Birth (RecTangleCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.theKillRectangle = [] # Do not re-init this!
    self.stringRect = None

def finishCreate(self):

    BaseEditCommandsClass.finishCreate(self)

    self.commandsDict = {
        'c': ('clear-rectangle',    self.clearRectangle),
        'd': ('delete-rectangle',   self.deleteRectangle),
        'k': ('kill-rectangle',     self.killRectangle),
        'o': ('open-rectangle',     self.openRectangle),
        'r': ('copy-rectangle-to-register',
            self.c.registerCommands.copyRectangleToRegister),
        't': ('string-rectangle',   self.stringRectangle),
        'y': ('yank-rectangle',     self.yankRectangle),
    }
#@+node:ekr.20051004112630: *5* check
def check (self,event,warning='No rectangle selected'):

    '''Return True if there is a selection.
    Otherwise, return False and issue a warning.'''

    return self._chckSel(event,warning)
#@+node:ekr.20050920084036.223: *5* getPublicCommands
def getPublicCommands (self):

    return {
        'rectangle-clear':  self.clearRectangle,
        'rectangle-close':  self.closeRectangle,
        'rectangle-delete': self.deleteRectangle,
        'rectangle-kill':   self.killRectangle,
        'rectangle-open':   self.openRectangle,
        'rectangle-string': self.stringRectangle,
        'rectangle-yank':   self.yankRectangle,
    }
#@+node:ekr.20051215103053: *5* beginCommand & beginCommandWithEvent (rectangle)
def beginCommand (self,undoType='Typing'):

    w = BaseEditCommandsClass.beginCommand(self,undoType)
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    return w,r1,r2,r3,r4


def beginCommandWithEvent (self,event,undoType='Typing'):

    '''Do the common processing at the start of each command.'''

    w = BaseEditCommandsClass.beginCommandWithEvent(self,event,undoType)
    r1,r2,r3,r4 = self.getRectanglePoints(w)
    return w,r1,r2,r3,r4
#@+node:ekr.20050920084036.224: *5* Entries (RecTangleCommandsClass)
#@+node:ekr.20050920084036.225: *6* clearRectangle
def clearRectangle (self,event):

    '''Clear the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('clear-rectangle')

    # Change the text.
    fill = ' ' *(r4-r2)
    for r in range(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        w.insert('%s.%s' % (r,r2),fill)

    w.setSelectionRange('%s.%s'%(r1,r2),'%s.%s'%(r3,r2+len(fill)))

    self.endCommand()
#@+node:ekr.20050920084036.226: *6* closeRectangle
def closeRectangle (self,event):

    '''Delete the rectangle if it contains nothing but whitespace..'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('close-rectangle')

    # Return if any part of the selection contains something other than whitespace.
    for r in range(r1,r3+1):
        s = w.get('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        if s.strip(): return

    # Change the text.
    for r in range(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2)
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@+node:ekr.20050920084036.227: *6* deleteRectangle
def deleteRectangle (self,event):

    '''Delete the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('delete-rectangle')

    for r in range(r1,r3+1):
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2)
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@+node:ekr.20050920084036.228: *6* killRectangle
def killRectangle (self,event):

    '''Kill the rectangle defined by the start and end of selected text.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('kill-rectangle')

    self.theKillRectangle = []

    for r in range(r1,r3+1):
        s = w.get('%s.%s' % (r,r2),'%s.%s' % (r,r4))
        self.theKillRectangle.append(s)
        w.delete('%s.%s' % (r,r2),'%s.%s' % (r,r4))

    # g.trace('killRect',repr(self.theKillRectangle))

    if self.theKillRectangle:
        ins = '%s.%s' % (r,r2)
        w.setSelectionRange(ins,ins,insert=ins)

    self.endCommand()
#@+node:ekr.20050920084036.230: *6* openRectangle
def openRectangle (self,event):

    '''Insert blanks in the rectangle defined by the start and end of selected text.
    This pushes the previous contents of the rectangle rightward.'''

    w = self.editWidget(event)
    if not w or not self.check(event): return

    w,r1,r2,r3,r4 = self.beginCommand('open-rectangle')

    fill = ' ' * (r4-r2)
    for r in range(r1,r3+1):
        w.insert('%s.%s' % (r,r2),fill)

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2+len(fill))
    w.setSelectionRange(i,j,insert=j)

    self.endCommand()
#@+node:ekr.20050920084036.232: *6* stringRectangle
def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ')
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        # pylint: disable=unpacking-non-sequence
        r1,r2,r3,r4 = self.stringRect
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)
        self.endCommand()
        # 2010/1/1: Fix bug 480422:
        # string-rectangle kills syntax highlighting.
        c.frame.body.recolor(c.p,incremental=False)

#@+node:ekr.20050920084036.229: *6* yankRectangle
def yankRectangle (self,event,killRect=None):

    '''Yank into the rectangle defined by the start and end of selected text.'''

    # c = self.c
    k = self.k
    w = self.editWidget(event)
    if not w: return

    killRect = killRect or self.theKillRectangle
    if g.app.unitTesting:
        # This value is used by the unit test.
        killRect = ['Y1Y','Y2Y','Y3Y','Y4Y']
    elif not killRect:
        k.setLabelGrey('No kill rect') ; return

    w,r1,r2,r3,r4 = self.beginCommand('yank-rectangle')

    n = 0
    for r in range(r1,r3+1):
        # g.trace(n,r,killRect[n])
        if n >= len(killRect): break
        w.delete('%s.%s' % (r,r2), '%s.%s' % (r,r4))
        w.insert('%s.%s' % (r,r2), killRect[n])
        n += 1

    i = '%s.%s' % (r1,r2)
    j = '%s.%s' % (r3,r2+len(killRect[n-1]))
    w.setSelectionRange(i,j,insert=j)
    self.endCommand()
#@+node:ekr.20050920084036.234: *4* RegisterCommandsClass
class RegisterCommandsClass (BaseEditCommandsClass):

    '''A class to represent registers a-z and the corresponding Emacs commands.'''

    @others
#@+node:ekr.20051004095209: *5* Birth
#@+node:ekr.20050920084036.235: *6*  Birth (RegisterCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.
    self.methodDict, self.helpDict = self.addRegisterItems()

    # Init these here to keep pylint happy.
    self.method = None 
    self.registerMode = 0 # Must be an int.
    self.registers = g.app.globalRegisters

def finishCreate (self):

    BaseEditCommandsClass.finishCreate(self)
        # finish the base class.

def init (self):
    self.method = None 
    self.registerMode = 0 # Must be an int.
    self.registers = {}

#@+node:ekr.20050920084036.247: *6*  getPublicCommands
def getPublicCommands (self):

    return {
        'register-append-to':           self.appendToRegister,
        'register-copy-rectangle-to':   self.copyRectangleToRegister,
        'register-copy-to':             self.copyToRegister,
        'register-increment':           self.incrementRegister,
        'register-insert':              self.insertRegister,
        'register-jump-to':             self.jumpToRegister,
        # 'register-number-to':         self.numberToRegister,
        'register-point-to':            self.pointToRegister,
        'register-prepend-to':          self.prependToRegister,
        'register-view':                self.viewRegister,
    }
#@+node:ekr.20050920084036.252: *6* addRegisterItems
def addRegisterItems( self ):

    methodDict = {
        '+':        self.incrementRegister,
        ' ':        self.pointToRegister,
        'a':        self.appendToRegister,
        'i':        self.insertRegister,
        'j':        self.jumpToRegister,
        # 'n':        self.numberToRegister,
        'p':        self.prependToRegister,
        'r':        self.copyRectangleToRegister,
        's':        self.copyToRegister,
        'v' :       self.viewRegister,
    }    

    helpDict = {
        's':    'copy to register',
        'i':    'insert from register',
        '+':    'increment register',
        'n':    'number to register',
        'p':    'prepend to register',
        'a':    'append to register',
        ' ':    'point to register',
        'j':    'jump to register',
        'r':    'rectangle to register',
        'v':    'view register',
    }

    return methodDict, helpDict
#@+node:ekr.20051004123217: *5* checkBodySelection
def checkBodySelection (self,warning='No text selected'):

    return self._chckSel(event=None,warning=warning)
#@+node:ekr.20050920084036.236: *5* Entries... (register commands)
#@+node:ekr.20050920084036.238: *6* appendToRegister
def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'append-to-register' ; state = k.getState(tag)

    char = event and event.char or ''

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Append to Register: ')
        k.setState(tag,1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if char.isalpha():
                w = c.frame.body.wrapper
                c.bodyWantsFocus()
                key = char.lower()
                val = self.registers.get(key,'')
                val = val + w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.237: *6* prependToRegister
def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'prepend-to-register' ; state = k.getState(tag)

    char = event and event.char or ''

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Prepend to Register: ')
        k.setState(tag,1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if char.isalpha():
                w = c.frame.body.wrapper
                c.bodyWantsFocus()
                key = char.lower()
                val = self.registers.get(key,'')
                val = w.getSelectedText() + val
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.239: *6* copyRectangleToRegister
def copyRectangleToRegister (self,event):

    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    char = event and event.char or ''

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ')
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if char.isalpha():
            key = char.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 <= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.240: *6* copyToRegister
def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'copy-to-register' ; state = k.getState(tag)

    char = event and event.char or ''

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Copy to Register: ')
        k.setState(tag,1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if char.isalpha():
                key = char.lower()
                w = c.frame.body.wrapper
                c.bodyWantsFocus()
                val = w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.241: *6* incrementRegister
def incrementRegister (self,event):

    '''Prompt for a register name and increment its value if it has a numeric value.'''

    c = self.c ; k = self.k ; state = k.getState('increment-reg')

    char = event and event.char or ''

    if state == 0:
        k.setLabelBlue('Increment register: ')
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif char.isalpha():
            key = char.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.242: *6* insertRegister
def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ')
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if char.isalpha():
            w = c.frame.body.wrapper
            c.bodyWantsFocus()
            key = char.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.recTangleCommands.yankRectangle(val)
                else:
                    i = w.getInsertPoint()
                    w.insert(i,val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.243: *6* jumpToRegister
def jumpToRegister (self,event):

    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    char = event and event.char or ''

    if state == 0:
        k.setLabelBlue('Jump to register: ')
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if char.isalpha():
            if self._checkIfRectangle(event): return
            key = char.lower()
            val = self.registers.get(key)
            w = c.frame.body.wrapper
            c.bodyWantsFocus()
            if val:
                try:
                    w.setInsertPoint(val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.244: *6* numberToRegister (not used)
@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):

    c,k = self.c,self.k
    state = k.getState('number-to-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ')
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if char.isalpha():
            # self.registers[char.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
#@+node:ekr.20050920084036.245: *6* pointToRegister
def pointToRegister (self,event):

    '''Prompt for a register name and put a value indicating the insert point in the register.'''

    c = self.c ; k = self.k ; state = k.getState('point-to-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ')
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if char.isalpha():
            w = c.frame.body.wrapper
            c.bodyWantsFocus()
            key = char.lower()
            val = w.getInsertPoint()
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20050920084036.246: *6* viewRegister
def viewRegister (self,event):

    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ')
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if char.isalpha():
            key = char.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
#@+node:ekr.20051023094009: *4* Search classes (leoEditCommands)
#@+node:ekr.20050920084036.257: *5* class SearchCommandsClass
class SearchCommandsClass (BaseEditCommandsClass):

    '''Delegates all searches to LeoFind.py.'''
    
    if 0: # Not needed.
        def __init__ (self,c):
            BaseEditCommandsClass.__init__(self,c)

    @others
#@+node:ekr.20050920084036.259: *6* getPublicCommands (SearchCommandsClass)
def getPublicCommands (self):
    
    find = self.c.findCommands
    return {
    'clone-find-all':                 find.minibufferCloneFindAll,
    'clone-find-all-flattened':       find.minibufferCloneFindAllFlattened,
    'clone-find-parents':             self.c.cloneFindParents,
    'find-all':                       find.minibufferFindAll,
    'find-clone-all':                 find.minibufferCloneFindAll,
    'find-clone-all-flattened':       find.minibufferCloneFindAllFlattened,
    'find-next':                      find.findNextCommand,
    'find-prev':                      find.findPrevCommand,
    'find-tab-hide':                  find.hideFindTab,
    'find-tab-open':                  find.openFindTab,
    'focus-to-find':                  find.focusToFind,
    'isearch-forward':                find.isearchForward,
    'isearch-backward':               find.isearchBackward,
    'isearch-forward-regexp':         find.isearchForwardRegexp,
    'isearch-backward-regexp':        find.isearchBackwardRegexp,
    'isearch-with-present-options':   find.isearchWithPresentOptions,
    'replace':                        find.change,
    'replace-all':                    find.minibufferReplaceAll,
    # 'replace-string':               find.setReplaceString,
    'replace-then-find':              find.changeThenFindCommand,
    're-search-forward':              find.reSearchForward,
    're-search-backward':             find.reSearchBackward,
    'search-forward':                 find.searchForward,
    'search-backward':                find.searchBackward,
    'search-with-present-options':    find.searchWithPresentOptions,
    'set-search-string':              find.searchWithPresentOptions,
    'set-replace-string':             find.setReplaceString,
    'set-find-everywhere':            find.setFindScopeEveryWhere,
    'set-find-node-only':             find.setFindScopeNodeOnly,
    'set-find-suboutline-only':       find.setFindScopeSuboutlineOnly,
    'show-find-options':              find.showFindOptions,
    'start-search':                   find.startSearch, # 4.11.1.
    'toggle-find-collapses-nodes':    find.toggleFindCollapesNodes,
    'toggle-find-ignore-case-option': find.toggleIgnoreCaseOption,
    'toggle-find-in-body-option':     find.toggleSearchBodyOption,
    'toggle-find-in-headline-option': find.toggleSearchHeadlineOption,
    'toggle-find-mark-changes-option':find.toggleMarkChangesOption,
    'toggle-find-mark-finds-option':  find.toggleMarkFindsOption,
    'toggle-find-regex-option':       find.toggleRegexOption,
    'toggle-find-word-option':        find.toggleWholeWordOption,
    'toggle-find-wrap-around-option': find.toggleWrapSearchOption,
    'word-search-forward':            find.wordSearchForward,
    'word-search-backward':           find.wordSearchBackward,
    }
#@+node:ekr.20051025071455: *4* Spell classes (leoEditCommands)
@others
#@+node:ekr.20051025071455.1: *5* class SpellCommandsClass
class SpellCommandsClass (BaseEditCommandsClass):

    '''Commands to support the Spell Tab.'''

    @others
#@+node:ekr.20051025080056: *6* ctor (SpellCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.handler = None

    # All the work happens when we first open the frame.
#@+node:ekr.20051025080420: *6* getPublicCommands (SearchCommandsClass)
def getPublicCommands (self):

    return {
        'focus-to-spell':           self.focusToSpell,
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
        
        # these are for spell as you type, not the spell tab
        'spell-as-you-type-toggle': self.as_you_type_toggle,
        'spell-as-you-type-wrap':   self.as_you_type_wrap,
        'spell-as-you-type-next':   self.as_you_type_next,
        'spell-as-you-type-undo':   self.as_you_type_undo,        
    }
#@+node:ekr.20051025080633: *6* openSpellTab
def openSpellTab (self,event=None):

    '''Open the Spell Checker tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        self.handler = SpellTabHandler(c,tabName)

    # Bug fix: 2013/05/22.
    if not self.handler.loaded:
        log.deleteTab(tabName,force=True)

    # spell as you type stuff
    self.suggestions = []
    self.suggestions_idx = None
    self.word = None
    self.spell_as_you_type = False
    self.wrap_as_you_type = False
#@+node:ekr.20051025080420.1: *6* commands...(SpellCommandsClass)
#@+node:ekr.20141113094129.8: *7* find
def find (self,event=None):
    '''
    Simulate pressing the 'Find' button in the Spell tab.
    
    Just open the Spell tab if it has never been opened.
    For minibuffer commands, we must also force the Spell tab to be visible.
    '''
    # self.handler is a SpellTabHandler object (inited by openSpellTab)
    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

#@+node:ekr.20141113094129.9: *7* change
def change(self,event=None):
    '''Simulate pressing the 'Change' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

#@+node:ekr.20141113094129.10: *7* changeThenFind
def changeThenFind (self,event=None):
    '''Simulate pressing the 'Change, Find' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        # A workaround for a pylint warning:
        # self.handler.changeThenFind()
        f = getattr(self.handler,'changeThenFind')
        f()
    else:
        self.openSpellTab()

#@+node:ekr.20141113094129.11: *7* hide
def hide (self,event=None):
    '''Hide the Spell tab.'''
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.bodyWantsFocus()

#@+node:ekr.20141113094129.12: *7* ignore
def ignore (self,event=None):
    '''Simulate pressing the 'Ignore' button in the Spell tab.'''
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()
#@+node:ekr.20141113094129.5: *7* focusToSpell
def focusToSpell(self,event=None):
    '''Put focus in the spell tab.'''
    self.openSpellTab()
        # Makes Spell tab visible.
        
    # This is not a great idea. There is no indication of focus.
        # if self.handler and self.handler.tab:
            # self.handler.tab.setFocus()
#@+node:tbrown.20140117115926.30765: *6* as_you_type_* commands
#@+node:tbrown.20140117115926.30766: *7* as_you_type_toggle
def as_you_type_toggle(self, event):
    """as_you_type_toggle - toggle spell as you type

    :Parameters:
    - `event`: event triggering toggle, not useful
    """

    c = self.c
    if self.spell_as_you_type:
        self.spell_as_you_type = False
        if not self.wrap_as_you_type:
            g.unregisterHandler('bodykey2', self.as_you_type_onkey)
        g.es("Spell as you type disabled")
        return
    
    self.spell_as_you_type = True
    if not self.wrap_as_you_type:
        g.registerHandler('bodykey2', self.as_you_type_onkey)
    g.es("Spell as you type enabled")
#@+node:tbrown.20140805135321.39151: *7* as_you_type_wrap
def as_you_type_wrap(self, event):
    """as_you_type_wrap - toggle wrap as you type

    :Parameters:
    - `event`: event triggering toggle, not useful
    """

    c = self.c
    if self.wrap_as_you_type:
        self.wrap_as_you_type = False
        if not self.spell_as_you_type:
            g.unregisterHandler('bodykey2', self.as_you_type_onkey)
        g.es("Wrap as you type disabled")
        return
    
    self.wrap_as_you_type = True
    if not self.spell_as_you_type:
        g.registerHandler('bodykey2', self.as_you_type_onkey)
    g.es("Wrap as you type enabled")
#@+node:tbrown.20140117115926.30768: *7* as_you_type_next
def as_you_type_next(self, event):
    """as_you_type_next - cycle word behind cursor to next suggestion

    :Parameters:
    - `event`: triggering key event
    """

    if not self.suggestions:
        g.es('[no suggestions]')
        return
    word = self.suggestions[self.suggestion_idx]
    self.suggestion_idx = (self.suggestion_idx + 1) % len(self.suggestions)
    self.as_you_type_replace(word)
    
#@+node:tbrown.20140117115926.30770: *7* as_you_type_undo
def as_you_type_undo(self, event):
    """as_you_type_undo - replace word behind cursor with word
    user typed before it started cycling suggestions

    :Parameters:
    - `event`: triggering event
    """

    if not self.word:
        g.es('[no previous word]')
        return
    self.as_you_type_replace(self.word)
#@+node:tbrown.20140117115926.30771: *7* as_you_type_onkey
def as_you_type_onkey(self, tag, kwargs):
    """as_you_type_onkey - handle a keystroke in the body when
    spell as you type is active

    :Parameters:
    - `tag`: hook tag
    - `kwargs`: hook arguments
    """
    if kwargs['c'] != self.c:
        return
    if kwargs['ch'] not in '\'",.:) \n\t':
        return
    c = self.c
    spell_ok = True
    if self.spell_as_you_type:  # might just be for wrapping
        w = c.frame.body.wrapper
        txt = w.getAllText()
        i = w.getInsertPoint()
        word = txt[:i].rsplit(None, 1)[-1]
        word = ''.join(i if i.isalpha() else ' ' for i in word).split()
        if word:
            word = word[-1]
            ec = c.spellCommands.handler.spellController
            suggests = ec.processWord(word)
            if suggests:
                spell_ok = False
                g.es(' '.join(suggests[:5]) +
                     ('...' if len(suggests) > 5 else ''),
                     color='red')
            elif suggests is not None:
                spell_ok = False
                g.es('[no suggestions]')
            self.suggestions = suggests
            self.suggestion_idx = 0
            self.word = word
    if spell_ok and self.wrap_as_you_type and kwargs['ch'] == '\n':
        g.es('filling')
        c.k.simulateCommand('fill-paragraph')
#@+node:tbrown.20140117133522.32004: *7* as_you_type_replace
def as_you_type_replace(self, word):
    """as_you_type_replace - replace the word behind the cursor
    with `word`

    :Parameters:
    - `word`: word to use as replacement
    """
    c = self.c
    w = c.frame.body.wrapper
    txt = w.getAllText()
    j = i = w.getInsertPoint()
    i -= 1
    while i and not txt[i].isalpha():
        i -= 1
    xtra = j - i
    j = i+1
    while i and txt[i].isalpha():
        i -= 1
    if i or (txt and not txt[0].isalpha()):
        i += 1
    txt = txt[:i]+word+txt[j:]
    w.setAllText(txt)
    c.p.b = txt
    w.setInsertPoint(i+len(word)+xtra-1)
    c.bodyWantsFocusNow()
#@+node:ekr.20051025071455.18: *5* class SpellTabHandler
class SpellTabHandler:

    """A class to create and manage Leo's Spell Check dialog."""

    @others
#@+node:ekr.20051025071455.19: *6* Birth & death
#@+node:ekr.20051025071455.20: *7* SpellTabHandler.__init__
def __init__(self,c,tabName):
    """Ctor for the Leo Spelling dialog."""
    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.outerScrolledFrame = None
    self.workCtrl = g.app.gui.plainTextWidget(c.frame.top)
        # A text widget for scanning.
        # Must have a parent frame even though it is not packed.
    if enchant:
        self.spellController = EnchantClass(c)
        self.tab = g.app.gui.createSpellTab(c,self,tabName)
        self.loaded = True
    else:
        self.spellController = None
        self.tab = None
        self.loaded = False
#@+node:ekr.20051025071455.36: *6* Commands
#@+node:ekr.20051025071455.37: *7* add (spellTab)
def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    if self.loaded:
        w = self.currentWord
        if w:
            self.spellController.add(w)
            self.tab.onFindButton()
#@+node:ekr.20051025071455.38: *7* change (spellTab)
def change(self,event=None):
    """Make the selected change to the text"""
    if not self.loaded:
        return
    c = self.c
    w = c.frame.body.wrapper
    selection = self.tab.getSuggestion()
    if selection:
        # Use getattr to keep pylint happy.
        if hasattr(self.tab,'change_i') and getattr(self.tab,'change_i') is not None:
            start = getattr(self.tab,'change_i')
            end   = getattr(self.tab,'change_j')
            oldSel = start,end
            # g.trace('using',start,end)
        else:
            start,end = oldSel = w.getSelectionRange()
        if start is not None:
            if start > end: start,end = end,start
            w.delete(start,end)
            w.insert(start,selection)
            w.setSelectionRange(start,start+len(selection))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.invalidateFocus()
            c.bodyWantsFocus()
            return True
    # The focus must never leave the body pane.
    c.invalidateFocus()
    c.bodyWantsFocus()
    return False
#@+node:ekr.20051025071455.40: *7* find & helpers
def find (self,event=None):
    """Find the next unknown word."""
    if not self.loaded:
        return
    c = self.c
    w = c.frame.body.wrapper
    # Reload the work pane from the present node.
    s = w.getAllText().rstrip()
    self.workCtrl.delete(0,"end")
    self.workCtrl.insert("end",s)
    # Reset the insertion point of the work widget.
    ins = w.getInsertPoint()
    self.workCtrl.setInsertPoint(ins)
    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'
    if alts:
        # Save the selection range.
        ins = w.getInsertPoint()
        i,j = w.getSelectionRange()
        self.tab.fillbox(alts,word)
        c.invalidateFocus()
        c.bodyWantsFocus()
        # Restore the selection range.
        w.setSelectionRange(i,j,insert=ins)
        w.see(ins)
    else:
        g.es("no more misspellings")
        self.tab.fillbox([])
        c.invalidateFocus()
        c.bodyWantsFocus()
#@+node:ekr.20051025071455.45: *8* findNextMisspelledWord
def findNextMisspelledWord(self):
    """Find the next unknown word."""
    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    w = c.frame.body.wrapper
    sc = self.spellController
    alts = None ; word = None
    try:
        while 1:
            i,j,p,word = self.findNextWord(p)
            # g.trace(i,j,p and p.h or '<no p>')
            if not p or not word:
                alts = None
                break
            alts = sc.processWord(word)
            if trace: g.trace('alts',alts and len(alts) or 0,i,j,word,p and p.h or 'None')
            if alts:
                redraw = not p.isVisible(c)
                # New in Leo 4.4.8: show only the 'sparse' tree when redrawing.
                if c.sparse_spell and not c.p.isAncestorOf(p):
                    for p2 in c.p.self_and_parents():
                        p2.contract()
                        redraw = True
                for p2 in p.parents():
                    if not p2.isExpanded():
                        p2.expand()
                        redraw = True
                if redraw:
                    c.redraw(p)
                else:
                    c.selectPosition(p)
                w.setSelectionRange(i,j,insert=j)
                break
    except Exception:
        g.es_exception()
    return alts, word
#@+node:ekr.20051025071455.47: *8* findNextWord (spellTab)
def findNextWord(self,p):
    """Scan for the next word, leaving the result in the work widget"""
    trace = False and not g.unitTesting
    c = self.c ; p = p.copy()
    while 1:
        s = self.workCtrl.getAllText()
        i = self.workCtrl.getInsertPoint()
        while i < len(s) and not g.isWordChar1(s[i]):
            i += 1
        # g.trace('p',p and p.h,'i',i,'len(s)',len(s))
        if i < len(s):
            # A non-empty word has been found.
            j = i
            while j < len(s) and (g.isWordChar(s[j]) or s[j] == "'"):
                j += 1
            word = s[i:j]
            word = word.strip("'")
            # This trace verifies that all words have been checked.
            # g.trace(repr(word))
            for w in (self.workCtrl,c.frame.body.wrapper):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(i,j,insert=j)
            if trace: g.trace(i,j,word,p.h)
            return i,j,p,word
        else:
            # End of the body text.
            p.moveToThreadNext()
            if not p: break
            self.workCtrl.delete(0,'end')
            self.workCtrl.insert(0,p.b)
            for w in (self.workCtrl,c.frame.body.wrapper):
                c.widgetWantsFocusNow(w)
                w.setSelectionRange(0,0,insert=0)
            if trace: g.trace(0,0,'-->',p.h)
    return None,None,None,None
#@+node:ekr.20051025121408: *7* hide
def hide (self,event=None):

    self.c.frame.log.selectTab('Log')
#@+node:ekr.20051025071455.41: *7* ignore
def ignore(self,event=None):
    """Ignore the incorrect word for the duration of this spell check session."""
    if self.loaded:
        w = self.currentWord
        if w:
            self.spellController.ignore(w)
            self.tab.onFindButton()
#@+node:ekr.20100904095239.5914: *5* class EnchantClass
class EnchantClass:

    """A wrapper class for PyEnchant spell checker"""

    @others
#@+node:ekr.20100904095239.5916: *6*  __init__ (EnchantClass)
def __init__ (self,c):

    """Ctor for the EnchantClass class."""

    self.c = c
    language = g.toUnicode(c.config.getString('enchant_language'))
    # Set the base language
    if language and not enchant.dict_exists(language):
        g.warning('Invalid language code for Enchant',repr(language))
        g.es_print('Using "en_US" instead')
        language = 'en_US'
    # Compute fn, the full path to the local dictionary.
    fn = g.os_path_finalize(
        c.config.getString('enchant_local_dictionary') or
        os.path.join(g.app.loadDir,"..","plugins",'spellpyx.txt'))
    self.open_dict(fn,language)
#@+node:ekr.20130116142831.10185: *6* clean_dict
def clean_dict (self,fn):
    
    if g.os_path_exists(fn):
        f = open(fn,mode='rb')
        s = f.read()
        f.close()
        # Blanks lines cause troubles.
        s2 = s.replace(b'\r',b'').replace(b'\n\n',b'\n')
        if s2.startswith(b'\n'): s2 = s2[1:]
        if s != s2:
            g.es_print('cleaning',fn)
            f = open(fn,mode='wb')
            f.write(s2)
            f.close()
#@+node:ekr.20130915181927.11293: *6* create
def create (self,fn):
    
    '''Create the given file with empty contents.'''
    try:
        f = open(fn,mode='wb')
        f.close()
        g.note('created: %s' % (fn))
    except IOError:
        g.error('can not create: %s' % (fn))
    except Exception:
        g.error('unexpected error creating: %s' % (fn))
        g.es_exception()
#@+node:ekr.20100904095239.5927: *6* add
def add (self,word):

    '''Add a word to the user dictionary.'''

    self.d.add(word)
#@+node:ekr.20100904095239.5928: *6* ignore
def ignore (self,word):

    self.d.add_to_session(word)
#@+node:ekr.20130915181927.11294: *6* open_dict
def open_dict(self,fn,language):
    
    '''Open or create the dict with the given fn.'''
    if not fn or not language:
        return
    if not g.os_path_exists(fn):
        # Fix bug 1175013: leo/plugins/spellpyx.txt is both source controlled and customized.
        self.create(fn)
    if g.os_path_exists(fn):
        # Merge the local and global dictionaries.
        try:
            self.clean_dict(fn)
            self.d = enchant.DictWithPWL(language,fn)
        except Exception:
            g.es_exception()
            g.error('not a valid dictionary file',fn)
            self.d = enchant.Dict(language)
    else:
        # A fallback.  Unlikely to happen.
        self.d = enchant.Dict(language)
#@+node:ekr.20100904095239.5920: *6* processWord
def processWord(self, word):

    """Check the word. Return None if the word is properly spelled.
    Otherwise, return a list of alternatives."""

    d = self.d 

    if not d:
        return None
    elif d.check(word):
        return None
    else:
        return d.suggest(word)
#@+node:ekr.20050920084036.190: *3* COPY 5.5: MacroCommandsClass
class MacroCommandsClass (BaseEditCommandsClass):

    '''A class for recording, playing back, saving and restoring keyboard macros.
    '''

    @others
#@+node:ekr.20050920084036.191: *4*  ctor (MacroCommandsClass)
def __init__ (self,c):

    BaseEditCommandsClass.__init__(self,c) # init the base class.

    self.lastMacro = None
    self.macros = []
    self.macro = []
    self.namedMacros = {}

    # Important: we must not interfere with k.state in startRecordingMacro!
    self.recordingMacro = False
#@+node:ekr.20050920084036.192: *4*  getPublicCommands
def getPublicCommands (self):

    return {
        'macro-call':           self.callNamedMacro,
        'macro-call-last':      self.callLastMacro,
        'macro-end-recording':  self.endMacro,
        'macro-load-all':       self.loadMacros,
        'macro-name-last':      self.nameLastMacro,
        'macro-print-all':      self.printMacros,
        'macro-print-last':     self.printLastMacro,
        'macro-save-all':       self.saveMacros,
        'macro-start-recording':self.startRecordingMacro,
    }
#@+node:ekr.20050920084036.202: *4* callLastMacro
# Called from universal-command.

def callLastMacro (self,event=None):

    '''Call the last recorded keyboard macro.'''

    # g.trace(self.lastMacro)

    if self.lastMacro:
        self.executeMacro(self.lastMacro)
#@+node:ekr.20050920084036.194: *4* callNamedMacro
def callNamedMacro (self,event):

    '''Prompts for a macro name, then executes it.'''

    k = self.k ; tag = 'macro-name'
    state = k.getState(tag)
    prompt = 'Call macro named: '

    if state == 0:
        k.setLabelBlue(prompt)
        k.getArg(event,tag,1,self.callNamedMacro)
    else:
        macro = self.namedMacros.get(k.arg)
        # Must do this first!
        k.clearState()
        if macro:
            self.executeMacro(macro)
        else:
            g.es('no macro named %s' % k.arg)
        k.resetLabel()

#@+node:ekr.20050920085536.15: *4* completeMacroDef
# Called from loadFile and nameLastMacro.

def completeMacroDef (self,name,macro):

    '''Add the macro to the list of macros,
    and add the macro's name to c.commandsDict.
    '''

    trace = False and not g.unitTesting
    k= self ; c = k.c

    if trace:
        g.trace('macro::%s' % (name))
        for event in macro:
            g.trace(event.stroke)

    def func (event,macro=macro):
        return self.executeMacro(macro)

    if name in c.commandsDict:
        g.es_print('over-riding command: %s' % (name))
    else:
        g.es_print('loaded: %s' % (name))

    c.commandsDict [name] = func
    self.namedMacros [name] = macro
#@+node:ekr.20050920084036.206: *4* endMacro
def endMacro (self,event=None):
    '''Stops recording a macro.'''
    k = self.k
    self.recordingMacro = False
        # Tell k.masterKeyHandler and k.masterCommandHandler we are done.
    if self.macro:
        # self.macro = self.macro [: -4]
        self.macros.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelBlue('Keyboard macro defined, not named')
        # g.es('Keyboard macro defined, not named')
    else:
        k.setLabelBlue('Empty keyboard macro')
        # g.es('Empty keyboard macro')
#@+node:ekr.20050920084036.203: *4* executeMacro
def executeMacro (self,macro):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k

    c.bodyWantsFocus()

    for event in macro:
        if trace: g.trace(repr(event))
        k.masterKeyHandler(event)
#@+node:ekr.20110606152005.16785: *4* getMacrosNode
def getMacrosNode (self):

    '''Return the position of the @macros node.'''

    c = self.c

    for p in c.all_unique_positions():
        if p.h == '@macros':
            return p

    # Not found.
    for p in c.all_unique_positions():
        if p.h == '@settings':
            # Create as the last child of the @settings node.
            p2 = p.insertAsLastChild()
            break
    else:
        # Create as the root node.
        oldRoot = c.rootPosition()
        p2 = oldRoot.insertAfter()
        p2.moveToRoot(oldRoot)

    c.setHeadString(p2,'@macros')
    g.es_print('Created: %s' % p2.h)
    c.redraw()
    return p2
#@+node:ekr.20110606152005.16788: *4* getWidgetName
def getWidgetName(self,obj):

    if not obj:
        return ''
    if hasattr(obj,'objectName'):
        return obj.objectName()
    if hasattr(obj,'widget'):
        if hasattr(obj.widget,'objectName'):
            return obj.widget.objectName()
    return ''
#@+node:ekr.20110606152005.16787: *4* loadMacros
def loadMacros (self,event=None):
    '''Load macros from the @macros node.'''
    trace = False and not g.unitTesting
    c = self.c
    create_event = g.app.gui.create_key_event
    p = self.getMacrosNode()

    def oops(message):
        g.trace(message)

    lines = g.splitLines(p.b)
    i = 0
    macro = [] ; name = None
    while i < len(lines):
        progress = i
        s = lines[i].strip()
        i += 1
        if s.startswith('::') and s.endswith('::'):
            name = s[2:-2]
            if name:
                macro = []
                while i < len(lines):
                    s = lines[i].strip()
                    if trace: g.trace(repr(name),repr(s))
                    if s:
                        stroke=s
                        char = c.k.stroke2char(stroke)
                        w = c.frame.body.wrapper
                        macro.append(create_event(c,char,stroke,w))
                        i += 1
                    else: break
                # Create the entries.
                if macro:
                    self.completeMacroDef(name,macro)
                    macro = [] ; name = None
                else:
                    oops('empty expansion for %s' % (name))
        elif s:
            if s.startswith('#') or s.startswith('@'):
                pass
            else:
                oops('ignoring line: %s' % (repr(s)))
        else: pass
        assert progress < i
    # finish of the last macro.
    if macro:
        self.completeMacroDef(name,macro)
#@+node:ekr.20050920084036.198: *4* nameLastMacro
def nameLastMacro (self,event):

    '''Prompts for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ')
        k.getArg(event,'name-macro',1,self.nameLastMacro)
    else:
        k.clearState()
        name = k.arg
        self.completeMacroDef(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
#@+node:ekr.20090201152408.1: *4* printMacros & printLastMacro
def printMacros (self,event=None):

    '''Prints the name and definition of all named macros.'''

    names = list(self.namedMacros.keys())

    if names:
        names.sort()
        print('macros',names)
        # g.es('\n'.join(names),tabName='Macros')
    else:
        g.es('no macros')

def printLastMacro (self,event=None):

    '''Print the last (unnamed) macro.'''

    if self.lastMacro:
        for event in self.lastMacro:
            g.es(repr(event.stroke))
#@+node:ekr.20050920084036.199: *4* saveMacros
def saveMacros (self,event=None):

    '''Store macros in the @macros node..'''

    p = self.getMacrosNode()
    result = []
    # g.trace(list(self.namedMacros.keys()))
    for name in self.namedMacros:
        macro = self.namedMacros.get(name)
        result.append('::%s::' % (name))
        for event in macro:
            if 0:
                w_name = self.getWidgetName(event.w)
                result.append('%s::%s::%s' % (repr(event.char),event.stroke,w_name))
            result.append(event.stroke)
        result.append('') # Blank line terminates

    p.b = '\n'.join(result)

#@+node:ekr.20050920084036.204: *4* startRecordingMacro
def startRecordingMacro (self,event):

    '''Start recording or continue to record a macro.'''

    trace = False and not g.unitTesting
    k = self.k

    if event:
        if self.recordingMacro:
            if trace: g.trace('stroke',event.stroke)
            self.macro.append(event)
        else:
            self.recordingMacro = True
            k.setLabelBlue('Recording macro. ctrl-g to end...',protect=True)
            # g.es('Recording macro. ctrl-g to end...')
    else:
        g.trace('can not happen: no event')
#@+node:ekr.20190506094028.1: ** Demo stuff
#@+node:ekr.20190506094028.2: *3* @@button demo1 @key=Ctrl-8
g.cls()
if c.isChanged(): c.save()
import imp
import leo.plugins.demo as demo
imp.reload(demo)
<< class MyDemo >>
h = 'demo1-commands'
button_p = g.findNodeAnywhere(c, '@button demo1 @key=Ctrl-8')
commands = g.findNodeInTree(c, button_p, h)
if commands:
    MyDemo(c).start(commands)
else:
    print('not found', h, c.p.h)
#@+node:ekr.20190506094028.3: *4* << class MyDemo >>
class MyDemo(demo.Demo):
    
    @others
    
#@+node:ekr.20190506094028.4: *5* setup
def setup(self, p):
    
    c = self.c
    self.delta = 0
    self.clear_log()
    p = g.findNodeAnywhere(c, 'Demo area')
    if p:
        c.selectPosition(p)
#@+node:ekr.20190506094028.5: *5* teardown
def teardown(self):
    
    c = self.c
    if self.delta:
        self.set_text_delta(-self.delta)
    p = g.findNodeAnywhere(c, 'Demo area')
    if p:
        c.selectPosition(p)
        next = p.next()
        if next and next.h == 'This is a test':
            c.selectPosition(next)
            next.doDelete()
            c.selectPosition(p)
            c.setChanged(False)
            c.redraw()
    

#@+node:ekr.20190506094028.6: *4* demo1-commands
print('demo1-commands')
# c.contractAllHeadlines()
#@+node:ekr.20190506094028.7: *5* @ignore-tree
#@+node:ekr.20190506094028.8: *6* set_text_delta
print('increasing text size by 10')
demo.delta = 10
demo.set_text_delta(demo.delta)
#@+node:ekr.20190506094028.9: *6* undo
undo_type = c.undoer.undoType
if undo_type == 'Insert Node':
    c.undoer.undo()
#@+node:ekr.20190506094028.10: *6* caption
demo.caption('My Caption', 'body')
#@+node:ekr.20190506094028.11: *6* @image
demo.delete_widgets()
fn = 'SplashScreen.ico'
demo.image('body', fn, center=True, height=None, width=None)
#@+node:ekr.20190506094028.12: *6* open menu
demo.delete_widgets()
demo.open_menu('Import')
#@+node:ekr.20190506094028.13: *6* close menu
demo.dismiss_menu_bar()
#@+node:ekr.20190506094028.14: *6* Alt-X insert-node
demo.key('Alt+x') # Not the same as Alt-X
demo.keys('insert-node')
# demo.wait(0.8)
# demo.key('\n') # Works.
#@+node:ekr.20190506094028.15: *6* Return
demo.key('\n')
#@+node:ekr.20190506094028.16: *5* headline
c.k.simulateCommand('insert-node')
demo.head_keys('This is a test')
#@+node:ekr.20190506094028.17: *3* Test: import c:\test\demo-it.el
g.cls()
import imp
import leo.plugins.importers.linescanner as linescanner
import leo.plugins.importers.elisp as elisp
imp.reload(linescanner)
imp.reload(elisp)
x = elisp.Elisp_Importer(c.importCommands, atAuto=False)
with open('c:/test/demo-it.el') as f:
    s = f.read()
parent = p.next()
assert parent.h == 'demo.el', parent.h
parent.b = ''
parent.deleteAllChildren()
try:
    x.run(s, parent)
except Exception:
    g.es_exception()
parent.expand()
c.selectPosition(parent)
c.redraw()
# g.printList(g.splitLines(s))
#@+node:ekr.20190506094028.18: *3* demo.image & helper
def image(self, fn, center=None, height=None, pane=None, width=None):
    '''Put an image in the indicated pane.'''
    parent = self.pane_widget(pane or 'body')
    if parent:
        w = QtWidgets.QLabel('label', parent)
        fn = self.resolve_icon_fn(fn)
        if not fn: return None
        pixmap = QtGui.QPixmap(fn)
        if not pixmap:
            return g.trace('Not a pixmap: %s' % (fn))
        if height:
            pixmap = pixmap.scaledToHeight(height)
        if width:
            pixmap = pixmap.scaledToWidth(width)
        w.setPixmap(pixmap)
        if center:
            g_w = w.geometry()
            g_p = parent.geometry()
            dx = (g_p.width() - g_w.width()) / 2
            w.move(g_w.x() + dx, g_w.y() + 10)
        w.show()
        self.widgets.append(w)
        return w
    else:
        g.trace('bad pane: %s' % (pane))
        return None
#@+node:ekr.20190506094028.19: *4* demo.resolve_icon_fn
def resolve_icon_fn(self, fn):
    '''Resolve fn relative to the Icons directory.'''
    dir_ = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons')
    path = g.os_path_finalize_join(dir_, fn)
    if g.os_path_exists(path):
        return path
    else:
        g.trace('does not exist: %s' % (path))
        return None
#@+node:ekr.20190506094028.20: *3* demo.caption & body, log, tree
def caption(self, s, pane): # To do: center option.
    '''Pop up a QPlainTextEdit in the indicated pane.'''
    parent = self.pane_widget(pane)
    if parent:
        s = s.rstrip()
        if s and s[-1].isalpha(): s = s + '.'
        w = QtWidgets.QPlainTextEdit(s, parent)
        w.setObjectName('screencastcaption')
        self.widgets.append(w)
        w2 = self.pane_widget(pane)
        geom = w2.geometry()
        w.resize(geom.width(), min(150, geom.height() / 2))
        off = QtCore.Qt.ScrollBarAlwaysOff
        w.setHorizontalScrollBarPolicy(off)
        w.setVerticalScrollBarPolicy(off)
        w.show()
        return w
    else:
        g.trace('bad pane: %s' % (pane))
        return None

def body(self, s):
    return self.caption(s, 'body')

def log(self, s):
    return self.caption(s, 'log')

def tree(self, s):
    return self.caption(s, 'tree')
#@+node:ekr.20190506094028.21: *3* demo.body, log, tree
def body(self, s):
    return TextEdit(s, 'body')

def log(self, s):
    return TextEdit(s, 'log')

def tree(self, s):
    return TextEdit(s, 'tree')
#@+node:ekr.20190506094028.22: *3* Demo area
@language python

# A python comment.
#@+node:ekr.20190508062044.1: ** Do not delete
#@+node:ekr.20180826065640.1: *3* vr.embed_pyplot_widget (not used)
def embed_pyplot_widget(self):

    pc = self
    c = pc.c
    # Careful: we may be unit testing.
    splitter = c.free_layout.get_top_splitter()
    if not splitter:
        return
    if not pc.pyplot_canvas:

        # TODO Create the widgets.
        w = None
        ### Ref
        # pc.gs = QtWidgets.QGraphicsScene(splitter)
        # pc.gv = QtWidgets.QGraphicsView(pc.gs)
        # w = pc.gv.viewport() # A QWidget
        # Embed the widgets.
        pc.pyplot_canvas = w

        def delete_callback():
            pc.pyplot_canvas.deleteLater()
            pc.pyplot_canvas = None

    if pc.pyplot_canvas:
        pc.embed_widget(w, delete_callback=delete_callback)
#@+node:ekr.20150521114057.1: *3* test_beautifier (prints stats)
def test_beautifier(c, h, p, settings):
    '''Test Leo's beautifier code'''
    if not p:
        g.trace('not found: %s' % h)
        return None
    s = g.getScript(c, p,
            useSelectedText=False,
            forcePythonSentinels=True,
            useSentinels=False)
    g.trace(h.strip())
    t1 = time.time()
    s1 = g.toEncodedString(s)
    node1 = ast.parse(s1, filename='before', mode='exec')
    t2 = time.time()
    readlines = g.ReadLinesClass(s).next
    tokens = list(tokenize.generate_tokens(readlines))
    t3 = time.time()
    beautifier = PythonTokenBeautifier(c)
    keep_blank_lines = settings.get('tidy-keep-blank-lines')
    if keep_blank_lines is not None:
        beautifier.delete_blank_lines = not keep_blank_lines
    s2 = beautifier.run(tokens)
    t4 = time.time()
    try:
        s2_e = g.toEncodedString(s2)
        node2 = ast.parse(s2_e, filename='before', mode='exec')
        ok = compare_ast(node1, node2)
    except Exception:
        g.es_exception()
        ok = False
    t5 = time.time()
    #  Update the stats
    beautifier.n_input_tokens += len(tokens)
    beautifier.n_output_tokens += len(beautifier.code_list)
    beautifier.n_strings += len(s2)
    beautifier.parse_time += (t2 - t1)
    beautifier.tokenize_time += (t3 - t2)
    beautifier.beautify_time += (t4 - t3)
    beautifier.check_time += (t5 - t4)
    beautifier.total_time += (t5 - t1)
    if settings.get('input_string'):
        print('==================== input_string')
        for i, z in enumerate(g.splitLines(s)):
            print('%4s %s' % (i + 1, z.rstrip()))
    if settings.get('input_lines'):
        print('==================== input_lines')
        dump_tokens(tokens, verbose=False)
    if settings.get('input_tokens'):
        print('==================== input_tokens')
        dump_tokens(tokens, verbose=True)
    if settings.get('output_tokens'):
        print('==================== code_list')
        for i, z in enumerate(beautifier.code_list):
            print('%4s %s' % (i, z))
    if settings.get('output_string'):
        print('==================== output_string')
        for i, z in enumerate(g.splitLines(s2)):
            if z == '\n':
                print('%4s' % (i + 1))
            elif z.rstrip():
                print('%4s %s' % (i + 1, z.rstrip()))
            else:
                print('%4s %r' % (i + 1, str(z)))
    if settings.get('stats'):
        beautifier.print_stats()
    if not ok:
        print('*************** fail: %s ***************' % (h))
    return beautifier
        # For statistics.
#@+node:ekr.20191229062845.1: ** From leoAst.py
#@+node:ekr.20191116061253.1: *3*  Generator tests
@nosearch
#@+node:ekr.20191113050247.1: *4* test: dump a generator
def seq():
    """A test generator."""
    for i in range(5):
        yield i

def dump(it, tag):
    """A generator that dumps another generator."""
    aList = list(it)
    g.printObj(aList, tag=tag)
    for z in aList:
        yield z

for i in dump(seq(), tag='seq'):
    print(i)

print('done')
#@+node:ekr.20191119024754.1: *4* test: zip_longest + enumerate
import itertools

list_a = ['a1', 'a2']
list_b = ['b1', 'b2', 'b3']

it = itertools.zip_longest(list_a, list_b, fillvalue='missing')
for i, (a, b) in enumerate(it):
    print(i, a, b)
#@+node:ekr.20191123085218.1: *4* test: next(generator) & test for generator/iterable
g.cls()
from collections.abc import Iterable 
import itertools
import types

gen = (z for z in range(5))
g1, g2 = itertools.tee(gen, 2)
for x in gen, g1, g2:
    print(f"     types.GeneratorType: {isinstance(x, types.GeneratorType)!s:>5} {x}")
for x in gen, g1, g2:
    print(f"collections.abc.Iterable: {isinstance(x, Iterable)!s:>5} {x}")
for z in g1:
    print(z)
print('done 1')
try:
    while True:
        print(next(g2))
except StopIteration:
    print('done 2')
#@+node:ekr.20191123163549.1: *4* test: exhaust generator w/o generating data
g.cls()
gen = (z for z in range(5))
try:
    while True:
        next(gen)
except StopIteration:
    print('done 2')
#@+node:ekr.20200729081252.1: *3* FullTraverser classes
#@+node:ekr.20141012064706.18399: *4* class AstFormatter
class AstFormatter:
    """
    A class to recreate source code from an AST.

    This does not have to be perfect, but it should be close.

    Also supports optional annotations such as line numbers, file names, etc.
    """
    # No ctor.
    # pylint: disable=consider-using-enumerate

    in_expr = False
    level = 0

    @others
#@+node:ekr.20141012064706.18402: *5* f.format
def format(self, node, level, *args, **keys):
    """Format the node and possibly its descendants, depending on args."""
    self.level = level
    val = self.visit(node, *args, **keys)
    return val.rstrip() if val else ''
#@+node:ekr.20141012064706.18403: *5* f.visit
def visit(self, node, *args, **keys):
    """Return the formatted version of an Ast node, or list of Ast nodes."""

    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    if node is None:
        return 'None'
    assert isinstance(node, ast.AST), node.__class__.__name__
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self, method_name)
    s = method(node, *args, **keys)
    assert isinstance(s, str), type(s)
    return s
#@+node:ekr.20141012064706.18469: *5* f.indent
def indent(self, s):
    return f'%s%s' % (' ' * 4 * self.level, s)
#@+node:ekr.20141012064706.18404: *5* f: Contexts
#@+node:ekr.20141012064706.18405: *6* f.ClassDef
# 2: ClassDef(identifier name, expr* bases,
#             stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node, print_body=True):

    result = []
    name = node.name  # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if getattr(node, 'keywords', None):  # Python 3
        for keyword in node.keywords:
            bases.append(f'%s=%s' % (keyword.arg, self.visit(keyword.value)))
    if getattr(node, 'starargs', None):  # Python 3
        bases.append(f'*%s' % self.visit(node.starargs))
    if getattr(node, 'kwargs', None):  # Python 3
        bases.append(f'*%s' % self.visit(node.kwargs))
    if bases:
        result.append(self.indent(f'class %s(%s):\n' % (name, ','.join(bases))))
    else:
        result.append(self.indent(f'class %s:\n' % name))
    if print_body:
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18406: *6* f.FunctionDef & AsyncFunctionDef
# 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node, async_flag=False, print_body=True):
    """Format a FunctionDef node."""
    result = []
    if node.decorator_list:
        for z in node.decorator_list:
            result.append(f'@%s\n' % self.visit(z))
    name = node.name  # Only a plain string is valid.
    args = self.visit(node.args) if node.args else ''
    asynch_prefix = 'asynch ' if async_flag else ''
    if getattr(node, 'returns', None):  # Python 3.
        returns = self.visit(node.returns)
        result.append(self.indent(f'%sdef %s(%s): -> %s\n' % (
            asynch_prefix, name, args, returns)))
    else:
        result.append(self.indent(f'%sdef %s(%s):\n' % (
            asynch_prefix, name, args)))
    if print_body:
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)

def do_AsyncFunctionDef(self, node):
    return self.do_FunctionDef(node, async_flag=True)
#@+node:ekr.20141012064706.18407: *6* f.Interactive
def do_Interactive(self, node):
    for z in node.body:
        self.visit(z)
#@+node:ekr.20141012064706.18408: *6* f.Module
def do_Module(self, node):
    assert 'body' in node._fields
    result = ''.join([self.visit(z) for z in node.body])
    return result
#@+node:ekr.20141012064706.18409: *6* f.Lambda
def do_Lambda(self, node):
    return self.indent(f'lambda %s: %s' % (
        self.visit(node.args),
        self.visit(node.body)))
#@+node:ekr.20141012064706.18410: *5* f: Expressions
#@+node:ekr.20141012064706.18411: *6* f.Expr
def do_Expr(self, node):
    """An outer expression: must be indented."""
    assert not self.in_expr
    self.in_expr = True
    value = self.visit(node.value)
    self.in_expr = False
    return self.indent(f'%s\n' % value)
#@+node:ekr.20141012064706.18412: *6* f.Expression
def do_Expression(self, node):
    """An inner expression: do not indent."""
    return f'%s\n' % self.visit(node.body)
#@+node:ekr.20141012064706.18413: *6* f.GeneratorExp
def do_GeneratorExp(self, node):
    elt = self.visit(node.elt) or ''
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '<**None**>' for z in gens]  # Kludge: probable bug.
    return f'<gen %s for %s>' % (elt, ','.join(gens))
#@+node:ekr.20141012064706.18414: *6* f.ctx nodes
def do_AugLoad(self, node):
    return 'AugLoad'

def do_Del(self, node):
    return 'Del'

def do_Load(self, node):
    return 'Load'

def do_Param(self, node):
    return 'Param'

def do_Store(self, node):
    return 'Store'
#@+node:ekr.20141012064706.18415: *5* f: Operands
#@+node:ekr.20141012064706.18416: *6* f.arguments
# 2: arguments = (expr* args, identifier? vararg, identifier?
#                arg? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                arg* kwonlyargs, expr* kw_defaults,
#                arg? kwarg, expr* defaults)

def do_arguments(self, node):
    """Format the arguments node."""
    kind = node.__class__.__name__
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(node.args)):
        if i < n_plain:
            args2.append(args[i])
        else:
            args2.append(f'%s=%s' % (args[i], defaults[i-n_plain]))
    # Add the vararg and kwarg expressions.
    vararg = getattr(node, 'vararg', None)
    if vararg: args2.append('*'+self.visit(vararg))
    kwarg = getattr(node, 'kwarg', None)
    if kwarg: args2.append(f'**'+self.visit(kwarg))
    return ','.join(args2)
#@+node:ekr.20141012064706.18417: *6* f.arg (Python3 only)
# 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        return self.visit(node.annotation)
    return node.arg
#@+node:ekr.20141012064706.18418: *6* f.Attribute
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    return f'%s.%s' % (
        self.visit(node.value),
        node.attr)  # Don't visit node.attr: it is always a string.
#@+node:ekr.20141012064706.18419: *6* f.Bytes
def do_Bytes(self, node):  # Python 3.x only.
    return str(node.s)
#@+node:ekr.20141012064706.18420: *6* f.Call & f.keyword
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):

    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    if getattr(node, 'starargs', None):
        args.append(f'*%s' % (self.visit(node.starargs)))
    if getattr(node, 'kwargs', None):
        args.append(f'**%s' % (self.visit(node.kwargs)))
    args = [z for z in args if z]  # Kludge: Defensive coding.
    s = f'%s(%s)' % (func, ','.join(args))
    return s if self.in_expr else self.indent(s+'\n')
        # 2017/12/15.
#@+node:ekr.20141012064706.18421: *7* f.keyword
# keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    value = self.visit(node.value)
    # This is a keyword *arg*, not a Python keyword!
    return f'%s=%s' % (node.arg, value)
#@+node:ekr.20141012064706.18422: *6* f.comprehension
def do_comprehension(self, node):
    result = []
    name = self.visit(node.target)  # A name.
    it = self.visit(node.iter)  # An attribute.
    result.append(f'%s in %s' % (name, it))
    ifs = [self.visit(z) for z in node.ifs]
    if ifs:
        result.append(f' if %s' % (''.join(ifs)))
    return ''.join(result)
#@+node:ekr.20170721073056.1: *6* f.Constant (Python 3.6+)
def do_Constant(self, node):  # Python 3.6+ only.
    return str(node.s)  # A guess.
#@+node:ekr.20141012064706.18423: *6* f.Dict
def do_Dict(self, node):
    result = []
    keys = [self.visit(z) for z in node.keys]
    values = [self.visit(z) for z in node.values]
    if len(keys) == len(values):
        result.append('{\n' if keys else '{')
        items = []
        for i in range(len(keys)):
            items.append(f'  %s:%s' % (keys[i], values[i]))
        result.append(',\n'.join(items))
        result.append('\n}' if keys else '}')
    else:
        print(
            f"Error: f.Dict: len(keys) != len(values)\n"
            f"keys: {repr(keys)}\nvals: {repr(values)}")
    return ''.join(result)
#@+node:ekr.20160523101618.1: *6* f.DictComp
# DictComp(expr key, expr value, comprehension* generators)

def do_DictComp(self, node):
    key = self.visit(node.key)
    value = self.visit(node.value)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '<**None**>' for z in gens]  # Kludge: probable bug.
    return f'%s:%s for %s' % (key, value, ''.join(gens))
#@+node:ekr.20141012064706.18424: *6* f.Ellipsis
def do_Ellipsis(self, node):
    return '...'
#@+node:ekr.20141012064706.18425: *6* f.ExtSlice
def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
#@+node:ekr.20170721075130.1: *6* f.FormattedValue (Python 3.6+)
# FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node):  # Python 3.6+ only.
    return f'%s%s%s' % (
        self.visit(node.value),
        self.visit(node.conversion) if node.conversion else '',
        self.visit(node.format_spec) if node.format_spec else '')
#@+node:ekr.20141012064706.18426: *6* f.Index
def do_Index(self, node):
    return self.visit(node.value)
#@+node:ekr.20170721080559.1: *6* f.JoinedStr (Python 3.6)
# JoinedStr(expr* values)

def do_JoinedStr(self, node):

    if node.values:
        for value in node.values:
            self.visit(value)
#@+node:ekr.20141012064706.18427: *6* f.List
def do_List(self, node):
    # Not used: list context.
    # self.visit(node.ctx)
    elts = [self.visit(z) for z in node.elts]
    elts = [z for z in elts if z]  # Defensive.
    return f'[%s]' % ','.join(elts)
#@+node:ekr.20141012064706.18428: *6* f.ListComp
def do_ListComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '<**None**>' for z in gens]  # Kludge: probable bug.
    return f'%s for %s' % (elt, ''.join(gens))
#@+node:ekr.20141012064706.18429: *6* f.Name & NameConstant
def do_Name(self, node):
    return node.id

def do_NameConstant(self, node):  # Python 3 only.
    s = repr(node.value)
    return s
#@+node:ekr.20141012064706.18430: *6* f.Num
def do_Num(self, node):
    return repr(node.n)
#@+node:ekr.20141012064706.18431: *6* f.Repr
# Python 2.x only

def do_Repr(self, node):
    return f'repr(%s)' % self.visit(node.value)
#@+node:ekr.20160523101929.1: *6* f.Set
# Set(expr* elts)

def do_Set(self, node):
    for z in node.elts:
        self.visit(z)
#@+node:ekr.20160523102226.1: *6* f.SetComp
# SetComp(expr elt, comprehension* generators)

def do_SetComp(self, node):

    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    return f'%s for %s' % (elt, ''.join(gens))
#@+node:ekr.20141012064706.18432: *6* f.Slice
def do_Slice(self, node):
    lower, upper, step = '', '', ''
    if getattr(node, 'lower', None) is not None:
        lower = self.visit(node.lower)
    if getattr(node, 'upper', None) is not None:
        upper = self.visit(node.upper)
    if getattr(node, 'step', None) is not None:
        step = self.visit(node.step)
    if step:
        return f'%s:%s:%s' % (lower, upper, step)
    return f'%s:%s' % (lower, upper)
#@+node:ekr.20141012064706.18433: *6* f.Str
def do_Str(self, node):
    """This represents a string constant."""
    return repr(node.s)
#@+node:ekr.20141012064706.18434: *6* f.Subscript
# Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    value = self.visit(node.value)
    the_slice = self.visit(node.slice)
    return f'%s[%s]' % (value, the_slice)
#@+node:ekr.20141012064706.18435: *6* f.Tuple
def do_Tuple(self, node):
    elts = [self.visit(z) for z in node.elts]
    return f'(%s)' % ','.join(elts)
#@+node:ekr.20141012064706.18436: *5* f: Operators
#@+node:ekr.20141012064706.18437: *6* f.BinOp
def do_BinOp(self, node):
    return f'%s%s%s' % (
        self.visit(node.left),
        op_name(node.op),
        self.visit(node.right))
#@+node:ekr.20141012064706.18438: *6* f.BoolOp
def do_BoolOp(self, node):
    op_name_ = op_name(node.op)
    values = [self.visit(z).strip() for z in node.values]
    return op_name_.join(values)
#@+node:ekr.20141012064706.18439: *6* f.Compare
def do_Compare(self, node):
    result = []
    lt = self.visit(node.left)
    # ops   = [self.visit(z) for z in node.ops]
    ops = [op_name(z) for z in node.ops]
    comps = [self.visit(z) for z in node.comparators]
    result.append(lt)
    assert len(ops) == len(comps), repr(node)
    for i in range(len(ops)):
        result.append(f'%s%s' % (ops[i], comps[i]))
    return ''.join(result)
#@+node:ekr.20141012064706.18440: *6* f.UnaryOp
def do_UnaryOp(self, node):
    return f'%s%s' % (
        op_name(node.op),
        self.visit(node.operand))
#@+node:ekr.20141012064706.18441: *6* f.ifExp (ternary operator)
def do_IfExp(self, node):
    return f'%s if %s else %s ' % (
        self.visit(node.body),
        self.visit(node.test),
        self.visit(node.orelse))
#@+node:ekr.20141012064706.18442: *5* f: Statements
#@+node:ekr.20170721074105.1: *6* f.AnnAssign
# AnnAssign(expr target, expr annotation, expr? value, int simple)

def do_AnnAssign(self, node):
    return self.indent(f'%s:%s=%s\n' % (
        self.visit(node.target),
        self.visit(node.annotation),
        self.visit(node.value),
    ))
#@+node:ekr.20141012064706.18443: *6* f.Assert
def do_Assert(self, node):
    test = self.visit(node.test)
    if getattr(node, 'msg', None):
        message = self.visit(node.msg)
        return self.indent(f'assert %s, %s' % (test, message))
    return self.indent(f'assert %s' % test)
#@+node:ekr.20141012064706.18444: *6* f.Assign
def do_Assign(self, node):
    return self.indent(f'%s=%s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
#@+node:ekr.20141012064706.18445: *6* f.AugAssign
def do_AugAssign(self, node):
    return self.indent(f'%s%s=%s\n' % (
        self.visit(node.target),
        op_name(node.op),  # Bug fix: 2013/03/08.
        self.visit(node.value)))
#@+node:ekr.20160523100504.1: *6* f.Await (Python 3)
# Await(expr value)

def do_Await(self, node):

    return self.indent(f'await %s\n' % (
        self.visit(node.value)))
#@+node:ekr.20141012064706.18446: *6* f.Break
def do_Break(self, node):
    return self.indent(f'break\n')
#@+node:ekr.20141012064706.18447: *6* f.Continue
def do_Continue(self, node):
    return self.indent(f'continue\n')
#@+node:ekr.20141012064706.18448: *6* f.Delete
def do_Delete(self, node):
    targets = [self.visit(z) for z in node.targets]
    return self.indent(f'del %s\n' % ','.join(targets))
#@+node:ekr.20141012064706.18449: *6* f.ExceptHandler
def do_ExceptHandler(self, node):
    
    result = []
    result.append(self.indent('except'))
    if getattr(node, 'type', None):
        result.append(f' %s' % self.visit(node.type))
    if getattr(node, 'name', None):
        if isinstance(node.name, ast.AST):
            result.append(f' as %s' % self.visit(node.name))
        else:
            result.append(f' as %s' % node.name)  # Python 3.x.
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18450: *6* f.Exec
# Python 2.x only

def do_Exec(self, node):
    body = self.visit(node.body)
    args = []  # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent(f'exec %s in %s\n' % (
            body, ','.join(args)))
    return self.indent(f'exec {body}\n')
#@+node:ekr.20141012064706.18451: *6* f.For & AsnchFor (Python 3)
def do_For(self, node, async_flag=False):
    result = []
    result.append(self.indent(f'%sfor %s in %s:\n' % (
        'async ' if async_flag else '',
        self.visit(node.target),
        self.visit(node.iter))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)

def do_AsyncFor(self, node):
    return self.do_For(node, async_flag=True)
#@+node:ekr.20141012064706.18452: *6* f.Global
def do_Global(self, node):
    return self.indent(f'global %s\n' % (
        ','.join(node.names)))
#@+node:ekr.20141012064706.18453: *6* f.If
def do_If(self, node):
    result = []
    result.append(self.indent(f'if %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent(f'else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18454: *6* f.Import & helper
def do_Import(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append(f'%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent(f'import %s\n' % (
        ','.join(names)))
#@+node:ekr.20141012064706.18455: *7* f.get_import_names
def get_import_names(self, node):
    """Return a list of the the full file names in the import statement."""
    result = []
    for ast2 in node.names:
        assert ast2.__class__.__name__ == 'alias', (repr(ast2))
        data = ast2.name, ast2.asname
        result.append(data)
    return result
#@+node:ekr.20141012064706.18456: *6* f.ImportFrom
def do_ImportFrom(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append(f'%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent(f'from %s import %s\n' % (
        node.module,
        ','.join(names)))
#@+node:ekr.20160317050557.2: *6* f.Nonlocal (Python 3)
# Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    return self.indent(f'nonlocal %s\n' % ', '.join(node.names))
#@+node:ekr.20141012064706.18457: *6* f.Pass
def do_Pass(self, node):
    return self.indent('pass\n')
#@+node:ekr.20141012064706.18458: *6* f.Print
# Python 2.x only

def do_Print(self, node):
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append(f'dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        # vals.append('nl=%s' % self.visit(node.nl))
        vals.append(f'nl=%s' % node.nl)
    return self.indent(f'print(%s)\n' % (
        ','.join(vals)))
#@+node:ekr.20141012064706.18459: *6* f.Raise
# Raise(expr? type, expr? inst, expr? tback)    Python 2
# Raise(expr? exc, expr? cause)                 Python 3

def do_Raise(self, node):
    args = []
    for attr in ('exc', 'cause'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent(f'raise %s\n' % (
            ','.join(args)))
    return self.indent('raise\n')
#@+node:ekr.20141012064706.18460: *6* f.Return
def do_Return(self, node):
    if node.value:
        return self.indent(f'return %s\n' % (
            self.visit(node.value)))
    return self.indent('return\n')
#@+node:ekr.20160317050557.3: *6* f.Starred (Python 3)
# Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    return '*' + self.visit(node.value)
#@+node:ekr.20141012064706.18461: *6* f.Suite
# def do_Suite(self,node):
    # for z in node.body:
        # s = self.visit(z)
#@+node:ekr.20160317050557.4: *6* f.Try (Python 3)
# Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node):  # Python 3

    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    if node.finalbody:
        result.append(self.indent('finally:\n'))
        for z in node.finalbody:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18462: *6* f.TryExcept
def do_TryExcept(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18463: *6* f.TryFinally
def do_TryFinally(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18464: *6* f.While
def do_While(self, node):
    result = []
    result.append(self.indent(f'while %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
#@+node:ekr.20141012064706.18465: *6* f.With & AsyncWith (Python 3)
# 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node, async_flag=False):
    result = []
    result.append(self.indent(f'%swith ' % ('async ' if async_flag else '')))
    if getattr(node, 'context_expression', None):
        result.append(self.visit(node.context_expresssion))
    vars_list = []
    if getattr(node, 'optional_vars', None):
        try:
            for z in node.optional_vars:
                vars_list.append(self.visit(z))
        except TypeError:  # Not iterable.
            vars_list.append(self.visit(node.optional_vars))
    if getattr(node, 'items', None):  # Python 3.
        for item in node.items:
            result.append(self.visit(item.context_expr))
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        vars_list.append(self.visit(z))
                except TypeError:  # Not iterable.
                    vars_list.append(self.visit(item.optional_vars))
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append('\n')
    return ''.join(result)

def do_AsyncWith(self, node):
    return self.do_With(node, async_flag=True)
#@+node:ekr.20141012064706.18466: *6* f.Yield
def do_Yield(self, node):
    if getattr(node, 'value', None):
        return self.indent(f'yield %s\n' % (
            self.visit(node.value)))
    return self.indent('yield\n')
#@+node:ekr.20160317050557.5: *6* f.YieldFrom (Python 3)
# YieldFrom(expr value)

def do_YieldFrom(self, node):

    return self.indent(f'yield from %s\n' % (
        self.visit(node.value)))
#@+node:ekr.20141012064706.18471: *4* class AstFullTraverser
class AstFullTraverser:
    """
    A fast traverser for AST trees: it visits every node (except node.ctx fields).

    Sets .context and .parent ivars before visiting each node.
    """

    def __init__(self):
        """Ctor for AstFullTraverser class."""
        self.context = None
        self.level = 0  # The context level only.
        self.parent = None

    @others
#@+node:ekr.20141012064706.18472: *5* ft.contexts
#@+node:ekr.20141012064706.18473: *6* ft.ClassDef
# 2: ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node, visit_body=True):
    old_context = self.context
    self.context = node
    self.level += 1
    for z in node.decorator_list:
        self.visit(z)
    for z in node.bases:
        self.visit(z)
    if getattr(node, 'keywords', None):  # Python 3
        for keyword in node.keywords:
            self.visit(keyword.value)
    if getattr(node, 'starargs', None):  # Python 3
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None):  # Python 3
        self.visit(node.kwargs)
    if visit_body:
        for z in node.body:
            self.visit(z)
    self.level -= 1
    self.context = old_context
#@+node:ekr.20141012064706.18474: *6* ft.FunctionDef
# 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node, visit_body=True):

    old_context = self.context
    self.context = node
    self.level += 1
    # Visit the tree in token order.
    for z in node.decorator_list:
        self.visit(z)
    assert isinstance(node.name, str)
    self.visit(node.args)
    if getattr(node, 'returns', None):  # Python 3.
        self.visit(node.returns)
    if visit_body:
        for z in node.body:
            self.visit(z)
    self.level -= 1
    self.context = old_context

do_AsyncFunctionDef = do_FunctionDef
#@+node:ekr.20141012064706.18475: *6* ft.Interactive
def do_Interactive(self, node):
    assert False, 'Interactive context not supported'
#@+node:ekr.20141012064706.18476: *6* ft.Lambda
# Lambda(arguments args, expr body)

def do_Lambda(self, node):
    old_context = self.context
    self.context = node
    self.visit(node.args)
    self.visit(node.body)
    self.context = old_context
#@+node:ekr.20141012064706.18477: *6* ft.Module
def do_Module(self, node):
    self.context = node
    for z in node.body:
        self.visit(z)
    self.context = None
#@+node:ekr.20141012064706.18478: *5* ft.ctx nodes
# Not used in this class, but may be called by subclasses.

def do_AugLoad(self, node):
    pass

def do_Del(self, node):
    pass

def do_Load(self, node):
    pass

def do_Param(self, node):
    pass

def do_Store(self, node):
    pass
#@+node:ekr.20171214200319.1: *5* ft.format
def format(self, node, level, *args, **keys):
    """Format the node and possibly its descendants, depending on args."""
    s = AstFormatter().format(node, level, *args, **keys)
    return s.rstrip()
#@+node:ekr.20141012064706.18480: *5* ft.operators & operands
#@+node:ekr.20160521102250.1: *6* ft.op_name
def op_name(self, node, strict=True):
    """Return the print name of an operator node."""
    name = _op_names.get(node.__class__.__name__, f'<%s>' % node.__class__.__name__)
    if strict:
        assert name, node.__class__.__name__
    return name
#@+node:ekr.20141012064706.18482: *6* ft.arguments & arg
# 2: arguments = (
# expr* args,
#   identifier? vararg,
#   identifier? kwarg,
#   expr* defaults)
# 3: arguments = (
#   arg*  args,
#   arg? vararg,
#   arg* kwonlyargs,
#   expr* kw_defaults,
#   arg? kwarg,
#   expr* defaults)

def do_arguments(self, node):

    for z in node.args:
        self.visit(z)
    if getattr(node, 'vararg', None):
        # An identifier in Python 2.
        self.visit(node.vararg)
    if getattr(node, 'kwarg', None):
        # An identifier in Python 2.
        self.visit_list(node.kwarg)
    if getattr(node, 'kwonlyargs', None):  # Python 3.
        self.visit_list(node.kwonlyargs)
    if getattr(node, 'kw_defaults', None):  # Python 3.
        self.visit_list(node.kw_defaults)
    for z in node.defaults:
        self.visit(z)

# 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        self.visit(node.annotation)
#@+node:ekr.20141012064706.18483: *6* ft.Attribute
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    self.visit(node.value)
    # self.visit(node.ctx)
#@+node:ekr.20141012064706.18484: *6* ft.BinOp
# BinOp(expr left, operator op, expr right)

def do_BinOp(self, node):
    self.visit(node.left)
    # self.op_name(node.op)
    self.visit(node.right)
#@+node:ekr.20141012064706.18485: *6* ft.BoolOp
# BoolOp(boolop op, expr* values)

def do_BoolOp(self, node):
    for z in node.values:
        self.visit(z)
#@+node:ekr.20141012064706.18481: *6* ft.Bytes
def do_Bytes(self, node):
    pass  # Python 3.x only.
#@+node:ekr.20141012064706.18486: *6* ft.Call
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    # Call the nodes in token order.
    self.visit(node.func)
    for z in node.args:
        self.visit(z)
    for z in node.keywords:
        self.visit(z)
    if getattr(node, 'starargs', None):
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None):
        self.visit(node.kwargs)
#@+node:ekr.20141012064706.18487: *6* ft.Compare
# Compare(expr left, cmpop* ops, expr* comparators)

def do_Compare(self, node):
    # Visit all nodes in token order.
    self.visit(node.left)
    assert len(node.ops) == len(node.comparators)
    for i in range(len(node.ops)):
        self.visit(node.ops[i])
        self.visit(node.comparators[i])
    # self.visit(node.left)
    # for z in node.comparators:
        # self.visit(z)
#@+node:ekr.20150526140323.1: *6* ft.Compare ops
# Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

def do_Eq(self, node): pass

def do_Gt(self, node): pass

def do_GtE(self, node): pass

def do_In(self, node): pass

def do_Is(self, node): pass

def do_IsNot(self, node): pass

def do_Lt(self, node): pass

def do_LtE(self, node): pass

def do_NotEq(self, node): pass

def do_NotIn(self, node): pass
#@+node:ekr.20141012064706.18488: *6* ft.comprehension
# comprehension (expr target, expr iter, expr* ifs)

def do_comprehension(self, node):
    self.visit(node.target)  # A name.
    self.visit(node.iter)  # An attribute.
    for z in node.ifs:
        self.visit(z)
#@+node:ekr.20170721073315.1: *6* ft.Constant (Python 3.6+)
def do_Constant(self, node):  # Python 3.6+ only.
    pass
#@+node:ekr.20141012064706.18489: *6* ft.Dict
# Dict(expr* keys, expr* values)

def do_Dict(self, node):
    # Visit all nodes in token order.
    assert len(node.keys) == len(node.values)
    for i in range(len(node.keys)):
        self.visit(node.keys[i])
        self.visit(node.values[i])
#@+node:ekr.20160523094910.1: *6* ft.DictComp
# DictComp(expr key, expr value, comprehension* generators)

def do_DictComp(self, node):
    # EKR: visit generators first, then value.
    for z in node.generators:
        self.visit(z)
    self.visit(node.value)
    self.visit(node.key)
#@+node:ekr.20150522081707.1: *6* ft.Ellipsis
def do_Ellipsis(self, node):
    pass
#@+node:ekr.20141012064706.18490: *6* ft.Expr
# Expr(expr value)

def do_Expr(self, node):
    self.visit(node.value)
#@+node:ekr.20141012064706.18491: *6* ft.Expression
def do_Expression(self, node):
    """An inner expression"""
    self.visit(node.body)
#@+node:ekr.20141012064706.18492: *6* ft.ExtSlice
def do_ExtSlice(self, node):
    for z in node.dims:
        self.visit(z)
#@+node:ekr.20170721075714.1: *6* ft.FormattedValue (Python 3.6+)
# FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node):  # Python 3.6+ only.
    self.visit(node.value)
    if node.conversion:
        self.visit(node.conversion)
    if node.format_spec:
        self.visit(node.format_spec)
#@+node:ekr.20141012064706.18493: *6* ft.GeneratorExp
# GeneratorExp(expr elt, comprehension* generators)

def do_GeneratorExp(self, node):
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
#@+node:ekr.20141012064706.18494: *6* ft.ifExp (ternary operator)
# IfExp(expr test, expr body, expr orelse)

def do_IfExp(self, node):
    self.visit(node.body)
    self.visit(node.test)
    self.visit(node.orelse)
#@+node:ekr.20141012064706.18495: *6* ft.Index
def do_Index(self, node):
    self.visit(node.value)
#@+node:ekr.20170721080935.1: *6* ft.JoinedStr (Python 3.6+)
# JoinedStr(expr* values)

def do_JoinedStr(self, node):
    for value in node.values or []:
        self.visit(value)
#@+node:ekr.20141012064706.18496: *6* ft.keyword
# keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    self.visit(node.value)
#@+node:ekr.20141012064706.18497: *6* ft.List & ListComp
# List(expr* elts, expr_context ctx)

def do_List(self, node):
    for z in node.elts:
        self.visit(z)
    # self.visit(node.ctx)
# ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node):
    self.visit(node.elt)
    for z in node.generators:
        self.visit(z)
#@+node:ekr.20141012064706.18498: *6* ft.Name (revise)
# Name(identifier id, expr_context ctx)

def do_Name(self, node):
    # self.visit(node.ctx)
    pass

def do_NameConstant(self, node):  # Python 3 only.
    pass
    # s = repr(node.value)
    # return 'bool' if s in ('True', 'False') else s
#@+node:ekr.20150522081736.1: *6* ft.Num
def do_Num(self, node):
    pass  # Num(object n) # a number as a PyObject.
#@+node:ekr.20141012064706.18499: *6* ft.Repr
# Python 2.x only
# Repr(expr value)

def do_Repr(self, node):
    self.visit(node.value)
#@+node:ekr.20160523094939.1: *6* ft.Set
# Set(expr* elts)

def do_Set(self, node):
    for z in node.elts:
        self.visit(z)

#@+node:ekr.20160523095142.1: *6* ft.SetComp
# SetComp(expr elt, comprehension* generators)

def do_SetComp(self, node):
    # EKR: visit generators first.
    for z in node.generators:
        self.visit(z)
    self.visit(node.elt)
#@+node:ekr.20141012064706.18500: *6* ft.Slice
def do_Slice(self, node):
    if getattr(node, 'lower', None):
        self.visit(node.lower)
    if getattr(node, 'upper', None):
        self.visit(node.upper)
    if getattr(node, 'step', None):
        self.visit(node.step)
#@+node:ekr.20150522081748.1: *6* ft.Str
def do_Str(self, node):
    pass  # represents a string constant.
#@+node:ekr.20141012064706.18501: *6* ft.Subscript
# Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    self.visit(node.value)
    self.visit(node.slice)
    # self.visit(node.ctx)
#@+node:ekr.20141012064706.18502: *6* ft.Tuple
# Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node):
    for z in node.elts:
        self.visit(z)
    # self.visit(node.ctx)
#@+node:ekr.20141012064706.18503: *6* ft.UnaryOp
# UnaryOp(unaryop op, expr operand)

def do_UnaryOp(self, node):
    # self.op_name(node.op)
    self.visit(node.operand)
#@+node:ekr.20141012064706.18504: *5* ft.statements
#@+node:ekr.20141012064706.18505: *6* ft.alias
# identifier name, identifier? asname)

def do_alias(self, node):
    # self.visit(node.name)
    # if getattr(node,'asname')
        # self.visit(node.asname)
    pass
#@+node:ekr.20170721074528.1: *6* ft.AnnAssign
# AnnAssign(expr target, expr annotation, expr? value, int simple)

def do_AnnAssign(self, node):
    self.visit(node.target)
    self.visit(node.annotation)
    self.visit(node.value)
#@+node:ekr.20141012064706.18506: *6* ft.Assert
# Assert(expr test, expr? msg)

def do_Assert(self, node):
    self.visit(node.test)
    if node.msg:
        self.visit(node.msg)
#@+node:ekr.20141012064706.18507: *6* ft.Assign
# Assign(expr* targets, expr value)

def do_Assign(self, node):
    for z in node.targets:
        self.visit(z)
    self.visit(node.value)
#@+node:ekr.20141012064706.18508: *6* ft.AugAssign
# AugAssign(expr target, operator op, expr value)

def do_AugAssign(self, node):

    self.visit(node.target)
    self.visit(node.value)
#@+node:ekr.20141012064706.18509: *6* ft.Break
def do_Break(self, tree):
    pass
#@+node:ekr.20141012064706.18510: *6* ft.Continue
def do_Continue(self, tree):
    pass
#@+node:ekr.20141012064706.18511: *6* ft.Delete
# Delete(expr* targets)

def do_Delete(self, node):
    for z in node.targets:
        self.visit(z)
#@+node:ekr.20141012064706.18512: *6* ft.ExceptHandler
# Python 2: ExceptHandler(expr? type, expr? name, stmt* body)
# Python 3: ExceptHandler(expr? type, identifier? name, stmt* body)

def do_ExceptHandler(self, node):

    if node.type:
        self.visit(node.type)
    if node.name and isinstance(node.name, ast.Name):
        self.visit(node.name)
    for z in node.body:
        self.visit(z)
#@+node:ekr.20141012064706.18513: *6* ft.Exec
# Python 2.x only
# Exec(expr body, expr? globals, expr? locals)

def do_Exec(self, node):
    self.visit(node.body)
    if getattr(node, 'globals', None):
        self.visit(node.globals)
    if getattr(node, 'locals', None):
        self.visit(node.locals)
#@+node:ekr.20141012064706.18514: *6* ft.For & AsyncFor
# For(expr target, expr iter, stmt* body, stmt* orelse)

def do_For(self, node):
    self.visit(node.target)
    self.visit(node.iter)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)

do_AsyncFor = do_For
#@+node:ekr.20141012064706.18515: *6* ft.Global
# Global(identifier* names)

def do_Global(self, node):
    pass
#@+node:ekr.20141012064706.18516: *6* ft.If
# If(expr test, stmt* body, stmt* orelse)

def do_If(self, node):
    self.visit(node.test)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
#@+node:ekr.20141012064706.18517: *6* ft.Import & ImportFrom
# Import(alias* names)

def do_Import(self, node):
    pass
# ImportFrom(identifier? module, alias* names, int? level)

def do_ImportFrom(self, node):
    # for z in node.names:
        # self.visit(z)
    pass
#@+node:ekr.20160317051434.2: *6* ft.Nonlocal (Python 3)
# Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    pass
#@+node:ekr.20141012064706.18518: *6* ft.Pass
def do_Pass(self, node):
    pass
#@+node:ekr.20141012064706.18519: *6* ft.Print
# Python 2.x only
# Print(expr? dest, expr* values, bool nl)

def do_Print(self, node):
    if getattr(node, 'dest', None):
        self.visit(node.dest)
    for expr in node.values:
        self.visit(expr)
#@+node:ekr.20141012064706.18520: *6* ft.Raise
# Raise(expr? type, expr? inst, expr? tback)    Python 2
# Raise(expr? exc, expr? cause)                 Python 3

def do_Raise(self, node):

    for attr in ('exc', 'cause'):
        if getattr(node, attr, None):
            self.visit(getattr(node, attr))
#@+node:ekr.20141012064706.18521: *6* ft.Return
# Return(expr? value)

def do_Return(self, node):
    if node.value:
        self.visit(node.value)
#@+node:ekr.20160317051434.3: *6* ft.Starred (Python 3)
# Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    self.visit(node.value)
#@+node:ekr.20141012064706.18522: *6* ft.Try (Python 3)
# Python 3 only: Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
    for z in node.finalbody:
        self.visit(z)
#@+node:ekr.20141012064706.18523: *6* ft.TryExcept
# TryExcept(stmt* body, excepthandler* handlers, stmt* orelse)

def do_TryExcept(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
#@+node:ekr.20141012064706.18524: *6* ft.TryFinally
# TryFinally(stmt* body, stmt* finalbody)

def do_TryFinally(self, node):
    for z in node.body:
        self.visit(z)
    for z in node.finalbody:
        self.visit(z)
#@+node:ekr.20141012064706.18525: *6* ft.While
# While(expr test, stmt* body, stmt* orelse)

def do_While(self, node):
    self.visit(node.test)  # Bug fix: 2013/03/23.
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
#@+node:ekr.20141012064706.18526: *6* ft.With & AsyncWith
# 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node):
    if getattr(node, 'context_expr', None):
        self.visit(node.context_expr)
    if getattr(node, 'optional_vars', None):
        self.visit(node.optional_vars)
    if getattr(node, 'items', None):  # Python 3.
        for item in node.items:
            self.visit(item.context_expr)
            if getattr(item, 'optional_vars', None):
                try:
                    for z in item.optional_vars:
                        self.visit(z)
                except TypeError:  # Not iterable.
                    self.visit(item.optional_vars)
    for z in node.body:
        self.visit(z)

do_AsyncWith = do_With
#@+node:ekr.20141012064706.18527: *6* ft.Yield, YieldFrom & Await (Python 3)
# Yield(expr? value)
# Await(expr value)         Python 3 only.
# YieldFrom (expr value)    Python 3 only.

def do_Yield(self, node):
    if node.value:
        self.visit(node.value)

do_Await = do_YieldFrom = do_Yield
#@+node:ekr.20141012064706.18528: *5* ft.visit (supports before_* & after_*)
def visit(self, node):
    """Visit a *single* ast node.  Visitors are responsible for visiting children!"""
    name = node.__class__.__name__
    assert isinstance(node, ast.AST), repr(node)
    # Visit the children with the new parent.
    old_parent = self.parent
    self.parent = node
    before_method = getattr(self, 'before_'+name, None)
    if before_method:
        before_method(node)
    do_method = getattr(self, 'do_'+name, None)
    if do_method:
        val = do_method(node)
    after_method = getattr(self, 'after_'+name, None)
    if after_method:
        after_method(node)
    self.parent = old_parent
    return val

def visit_children(self, node):
    assert False, 'must visit children explicitly'
#@+node:ekr.20141012064706.18529: *5* ft.visit_list
def visit_list(self, aList):
    """Visit all ast nodes in aList or ast.node."""
    if isinstance(aList, (list, tuple)):
        for z in aList:
            self.visit(z)
        return None
    assert isinstance(aList, ast.AST), repr(aList)
    return self.visit(aList)
#@+node:ekr.20141012064706.18530: *4* class AstPatternFormatter (AstFormatter)
class AstPatternFormatter(AstFormatter):
    """
    A subclass of AstFormatter that replaces values of constants by Bool,
    Bytes, Int, Name, Num or Str.
    """
    # No ctor.
    @others
#@+node:ekr.20141012064706.18531: *5* Constants & Name
# Return generic markers allow better pattern matches.

def do_BoolOp(self, node):  # Python 2.x only.
    return 'Bool'

def do_Bytes(self, node):  # Python 3.x only.
    return 'Bytes'  # return str(node.s)

def do_Constant(self, node):  # Python 3.6+ only.
    return 'Constant'

def do_Name(self, node):
    return 'Bool' if node.id in ('True', 'False') else node.id

def do_NameConstant(self, node):  # Python 3 only.
    s = repr(node.value)
    return 'Bool' if s in ('True', 'False') else s

def do_Num(self, node):
    return 'Num'  # return repr(node.n)

def do_Str(self, node):
    """This represents a string constant."""
    return 'Str'  # return repr(node.s)
#@+node:ekr.20150722204300.1: *4* class HTMLReportTraverser
class HTMLReportTraverser:
    """
    Create html reports from an AST tree.

    Inspired by Paul Boddie.

    This version writes all html to a global code list.

    At present, this code does not show comments.
    The TokenSync class is probably the best way to do this.
    """
    # To do: revise report-traverser-debug.css.
    @others
#@+node:ekr.20150722204300.2: *5* rt.__init__
def __init__(self, debug=False):
    """Ctor for the NewHTMLReportTraverser class."""
    self.code_list = []
    self.debug = debug
    self.div_stack = []
        # A check to ensure matching div/end_div.
    self.last_doc = None
    # List of divs & spans to generate...
    self.enable_list = [
        'body', 'class', 'doc', 'function',
        'keyword', 'name', 'statement'
    ]
    # Formatting stuff...
    debug_css = 'report-traverser-debug.css'
    plain_css = 'report-traverser.css'
    self.css_fn = debug_css if debug else plain_css
    self.html_footer = '\n</body>\n</html>\n'
    self.html_header = self.define_html_header()
#@+node:ekr.20150722204300.3: *6* define_html_header
def define_html_header(self):
    # Use string catenation to avoid using g.adjustTripleString.
    return (
        '<?xml version="1.0" encoding="iso-8859-15"?>\n'
        '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\n'
        '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n'
        '<html xmlns="http://www.w3.org/1999/xhtml">\n'
        '<head>\n'
        '  <title>%(title)s</title>\n'
        '  <link rel="stylesheet" type="text/css" href="%(css-fn)s" />\n'
        '</head>\n<body>'
    )
#@+node:ekr.20150723094359.1: *5* rt.code generators
#@+node:ekr.20150723100236.1: *6* rt.blank
def blank(self):
    """Insert a single blank."""
    self.clean(' ')
    if self.code_list[-1] not in ' \n':
        self.gen(' ')
#@+node:ekr.20150723100208.1: *6* rt.clean
def clean(self, s):
    """Remove s from the code list."""
    s2 = self.code_list[-1]
    if s2 == s:
        self.code_list.pop()
#@+node:ekr.20150723105702.1: *6* rt.colon
def colon(self):

    self.clean('\n')
    self.clean(' ')
    self.clean('\n')
    self.gen(':')
#@+node:ekr.20150723100346.1: *6* rt.comma & clean_comma
def comma(self):

    self.clean(' ')
    self.gen(', ')

def clean_comma(self):

    self.clean(', ')
#@+node:ekr.20150722204300.21: *6* rt.doc
# Called by ClassDef & FunctionDef visitors.

def doc(self, node):
    doc = ast.get_docstring(node)
    if doc:
        self.docstring(doc)
        self.last_doc = doc  # Attempt to suppress duplicate.
#@+node:ekr.20150722204300.22: *6* rt.docstring
def docstring(self, s):

    import textwrap
    self.gen("<pre class='doc'>")
    self.gen('"""')
    self.gen(self.text(textwrap.dedent(s.replace('"""', '\\"\\"\\"'))))
    self.gen('"""')
    self.gen("</pre>")
#@+node:ekr.20150722211115.1: *6* rt.gen
def gen(self, s):
    """Append s to the global code list."""
    if s:
        self.code_list.append(s)
#@+node:ekr.20150722204300.23: *6* rt.keyword (code generator)
def keyword(self, name):

    self.blank()
    self.span('keyword')
    self.gen(name)
    self.end_span('keyword')
    self.blank()
#@+node:ekr.20150722204300.24: *6* rt.name
def name(self, name):

    # Div would put each name on a separate line.
    # span messes up whitespace, for now.
    # self.span('name')
    self.gen(name)
    # self.end_span('name')
#@+node:ekr.20150723100417.1: *6* rt.newline
def newline(self):

    self.clean(' ')
    self.clean('\n')
    self.clean(' ')
    self.gen('\n')
#@+node:ekr.20150722204300.26: *6* rt.op
def op(self, op_name, leading=False, trailing=True):

    if leading:
        self.blank()
    # self.span('operation')
    # self.span('operator')
    self.gen(self.text(op_name))
    # self.end_span('operator')
    if trailing:
        self.blank()
    # self.end_span('operation')
#@+node:ekr.20160315184954.1: *6* rt.string (code generator)
def string(self, s):

    import xml.sax.saxutils as saxutils
    s = repr(s.strip().strip())
    s = saxutils.escape(s)
    self.gen(s)
#@+node:ekr.20150722204300.27: *6* rt.simple_statement
def simple_statement(self, name):

    class_name = f'%s nowrap' % name
    self.div(class_name)
    self.keyword(name)
    self.end_div(class_name)
#@+node:ekr.20150722204300.16: *5* rt.html helpers
#@+node:ekr.20150722204300.17: *6* rt.attr & text
def attr(self, s):
    return self.text(s).replace("'", "&apos;").replace('"', "&quot;")

def text(self, s):
    return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
#@+node:ekr.20150722204300.18: *6* rt.br
def br(self):
    return '\n<br />'
#@+node:ekr.20150722204300.19: *6* rt.comment
def comment(self, comment):

    self.span('comment')
    self.gen('# '+comment)
    self.end_span('comment')
    self.newline()
#@+node:ekr.20150722204300.20: *6* rt.div
def div(self, class_name, extra=None, wrap=False):
    """Generate the start of a div element."""
    if class_name in self.enable_list:
        if class_name:
            full_class_name = class_name if wrap else class_name + ' nowrap'
        self.newline()
        if class_name and extra:
            self.gen(f"<div class='%s' %s>" % (full_class_name, extra))
        elif class_name:
            self.newline()
            self.gen(f"<div class='%s'>" % (full_class_name))
        else:
            assert not extra
            self.gen("<div>")
    self.div_stack.append(class_name)
#@+node:ekr.20150722222149.1: *6* rt.div_body
def div_body(self, aList):
    if aList:
        self.div_list('body', aList)
#@+node:ekr.20150722221101.1: *6* rt.div_list & div_node
def div_list(self, class_name, aList, sep=None):

    self.div(class_name)
    self.visit_list(aList, sep=sep)
    self.end_div(class_name)

def div_node(self, class_name, node):

    self.div(class_name)
    self.visit(node)
    self.end_div(class_name)
#@+node:ekr.20150723095033.1: *6* rt.end_div
def end_div(self, class_name):

    if class_name in self.enable_list:
        # self.newline()
        self.gen('</div>')
        # self.newline()
    class_name2 = self.div_stack.pop()
    assert class_name2 == class_name, (class_name2, class_name)
#@+node:ekr.20150723095004.1: *6* rt.end_span
def end_span(self, class_name):

    if class_name in self.enable_list:
        self.gen('</span>')
        self.newline()
    class_name2 = self.div_stack.pop()
    assert class_name2 == class_name, (class_name2, class_name)
#@+node:ekr.20150722221408.1: *6* rt.keyword_colon
# def keyword_colon(self, keyword):

    # self.keyword(keyword)
    # self.colon()
#@+node:ekr.20150722204300.5: *6* rt.link
def link(self, class_name, href, a_text):

    return f"<a class='%s' href='%s'>%s</a>" % (
        class_name, href, a_text)
#@+node:ekr.20150722204300.6: *6* rt.module_link
def module_link(self, module_name, classes=None):

    return self.link(
        class_name=classes or 'name',
        href=f'%s.xhtml' % module_name,
        a_text=self.text(module_name))
#@+node:ekr.20150722204300.7: *6* rt.name_link
def name_link(self, module_name, full_name, name, classes=None):

    return self.link(
        class_name=classes or "specific-ref",
        href=f'%s.xhtml#%s' % (module_name, self.attr(full_name)),
        a_text=self.text(name))
#@+node:ekr.20150722204300.8: *6* rt.object_name_ref
def object_name_ref(self, module, obj, name=None, classes=None):
    """
    Link to the definition for 'module' using 'obj' with the optional 'name'
    used as the label (instead of the name of 'obj'). The optional 'classes'
    can be used to customise the CSS classes employed.
    """
    return self.name_link(
        module.full_name(),
        obj.full_name(),
        name or obj.name, classes)
#@+node:ekr.20150722204300.9: *6* rt.popup
def popup(self, classes, aList):

    self.span_list(classes or 'popup', aList)
#@+node:ekr.20150722204300.28: *6* rt.span
def span(self, class_name, wrap=False):

    if class_name in self.enable_list:
        self.newline()
        if class_name:
            full_class_name = class_name if wrap else class_name + ' nowrap'
            self.gen(f"<span class='%s'>" % (full_class_name))
        else:
            self.gen('<span>')
        # self.newline()
    self.div_stack.append(class_name)
#@+node:ekr.20150722224734.1: *6* rt.span_list & span_node
def span_list(self, class_name, aList, sep=None):

    self.span(class_name)
    self.visit_list(aList, sep=sep)
    self.end_span(class_name)

def span_node(self, class_name, node):

    self.span(class_name)
    self.visit(node)
    self.end_span(class_name)
#@+node:ekr.20150722204300.10: *6* rt.summary_link
def summary_link(self, module_name, full_name, name, classes=None):

    return self.name_link(
        f"{module_name}-summary", full_name, name, classes)
#@+node:ekr.20160315161259.1: *5* rt.main
def main(self, fn, node):
    """Return a report for the given ast node as a string."""
    self.gen(self.html_header % {
            'css-fn': self.css_fn,
            'title': f"Module: {fn}"
        })
    self.parent = None
    self.parents = [None]
    self.visit(node)
    self.gen(self.html_footer)
    return ''.join(self.code_list)
#@+node:ekr.20150722204300.44: *5* rt.visit
def visit(self, node):
    """Walk a tree of AST nodes."""
    assert isinstance(node, ast.AST), node.__class__.__name__
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self, method_name)
    method(node)
#@+node:ekr.20150722204300.45: *5* rt.visit_list
def visit_list(self, aList, sep=None):
    # pylint: disable=arguments-differ
    if aList:
        for z in aList:
            self.visit(z)
            self.gen(sep)
        self.clean(sep)
#@+node:ekr.20150722204300.46: *5* rt.visitors
#@+node:ekr.20170721074613.1: *6* rt.AnnAssign
# AnnAssign(expr target, expr annotation, expr? value, int simple)

def do_AnnAssign(self, node):

    self.div('statement')
    self.visit(node.target)
    self.op('=:', leading=True, trailing=True)
    self.visit(node.annotation)
    self.blank()
    self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20150722204300.49: *6* rt.Assert
# Assert(expr test, expr? msg)

def do_Assert(self, node):

    self.div('statement')
    self.keyword("assert")
    self.visit(node.test)
    if node.msg:
        self.comma()
        self.visit(node.msg)
    self.end_div('statement')
#@+node:ekr.20150722204300.50: *6* rt.Assign
def do_Assign(self, node):

    self.div('statement')
    for z in node.targets:
        self.visit(z)
        self.op('=', leading=True, trailing=True)
    self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20150722204300.51: *6* rt.Attribute
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):

    self.visit(node.value)
    self.gen('.')
    self.gen(node.attr)
#@+node:ekr.20160523102939.1: *6* rt.Await (Python 3)
# Await(expr value)

def do_Await(self, node):

    self.div('statement')
    self.keyword('await')
    self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20150722204300.52: *6* rt.AugAssign
#  AugAssign(expr target, operator op, expr value)

def do_AugAssign(self, node):

    op_name_ = op_name(node.op)
    self.div('statement')
    self.visit(node.target)
    self.op(op_name_, leading=True)
    self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20150722204300.53: *6* rt.BinOp
def do_BinOp(self, node):

    op_name_ = op_name(node.op)
    # self.span(op_name_)
    self.visit(node.left)
    self.op(op_name_, leading=True)
    self.visit(node.right)
    # self.end_span(op_name_)
#@+node:ekr.20150722204300.54: *6* rt.BoolOp
def do_BoolOp(self, node):

    op_name_ = op_name(node.op).strip()
    self.span(op_name_)
    for i, node2 in enumerate(node.values):
        if i > 0:
            self.keyword(op_name_)
        self.visit(node2)
    self.end_span(op_name_)
#@+node:ekr.20150722204300.55: *6* rt.Break
def do_Break(self, node):

    self.simple_statement('break')
#@+node:ekr.20160523103529.1: *6* rt.Bytes (Python 3)
def do_Bytes(self, node):  # Python 3.x only.
    return str(node.s)
#@+node:ekr.20150722204300.56: *6* rt.Call & do_keyword
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):

    # self.span("callfunc")
    self.visit(node.func)
    # self.span("call")
    self.gen('(')
    self.visit_list(node.args, sep=',')
    if node.keywords:
        self.visit_list(node.keywords, sep=',')
    if getattr(node, 'starargs', None):
        self.op('*', trailing=False)
        self.visit(node.starargs)
        self.comma()
    if getattr(node, 'kwargs', None):
        self.op('**', trailing=False)
        self.visit(node.kwargs)
        self.comma()
    self.clean_comma()
    self.gen(')')
    # self.end_span('call')
    # self.end_span('callfunc')
#@+node:ekr.20150722204300.57: *7* rt.do_keyword
# keyword = (identifier arg, expr value)
# keyword arguments supplied to call

def do_keyword(self, node):

    self.span('keyword-arg')
    self.gen(node.arg)
    self.blank()
    self.gen('=')
    self.blank()
    self.visit(node.value)
    self.end_span('keyword-arg')
#@+node:ekr.20150722204300.58: *6* rt.ClassDef
# 2: ClassDef(identifier name, expr* bases,
#             stmt* body, expr* decorator_list)
# 3: ClassDef(identifier name, expr* bases,
#             keyword* keywords, expr? starargs, expr? kwargs
#             stmt* body, expr* decorator_list)
#
# keyword arguments supplied to call (NULL identifier for **kwargs)
# keyword = (identifier? arg, expr value)

def do_ClassDef(self, node):

    has_bases = (node.bases or hasattr(node, 'keywords') or
        hasattr(node, 'starargs') or hasattr(node, 'kwargs'))
    self.div('class')
    self.keyword("class")
    self.gen(node.name)  # Always a string.
    if has_bases:
        self.gen('(')
        self.visit_list(node.bases, sep=', ')
        if getattr(node, 'keywords', None):  # Python 3
            for keyword in node.keywords:
                self.gen(f'%s=%s' % (keyword.arg, self.visit(keyword.value)))
        if getattr(node, 'starargs', None):  # Python 3
            self.gen(f'*%s' % self.visit(node.starargs))
        if getattr(node, 'kwargs', None):  # Python 3
            self.gen(f'*%s' % self.visit(node.kwargs))
        self.gen(')')
    self.colon()
    self.div('body')
    self.doc(node)
    self.visit_list(node.body)
    self.end_div('body')
    self.end_div('class')
#@+node:ekr.20150722204300.59: *6* rt.Compare
def do_Compare(self, node):

    assert len(node.ops) == len(node.comparators)
    # self.span('compare')
    self.visit(node.left)
    for i in range(len(node.ops)):
        op_name_ = op_name(node.ops[i])
        self.op(op_name_, leading=True)
        self.visit(node.comparators[i])
    # self.end_span('compare')
#@+node:ekr.20150722204300.60: *6* rt.comprehension
# comprehension = (expr target, expr iter, expr* ifs)

def do_comprehension(self, node):

    self.visit(node.target)
    self.keyword('in')
    # self.span('collection')
    self.visit(node.iter)
    if node.ifs:
        self.keyword('if')
        # self.span_list("conditional", node.ifs, sep=' ')
        for z in node.ifs:
            self.visit(z)
            self.blank()
        self.clean(' ')
    # self.end_span('collection')
#@+node:ekr.20170721073431.1: *6* rt.Constant (Python 3.6+)
def do_Constant(self, node):  # Python 3.6+ only.
    return str(node.s)  # A guess.
#@+node:ekr.20150722204300.61: *6* rt.Continue
def do_Continue(self, node):

    self.simple_statement('continue')
#@+node:ekr.20150722204300.62: *6* rt.Delete
def do_Delete(self, node):

    self.div('statement')
    self.keyword('del')
    if node.targets:
        self.visit_list(node.targets, sep=',')
    self.end_div('statement')
#@+node:ekr.20150722204300.63: *6* rt.Dict
def do_Dict(self, node):

    assert len(node.keys) == len(node.values)
    # self.span('dict')
    self.gen('{')
    for i in range(len(node.keys)):
        self.visit(node.keys[i])
        self.colon()
        self.visit(node.values[i])
        self.comma()
    self.clean_comma()
    self.gen('}')
    # self.end_span('dict')
#@+node:ekr.20160523104330.1: *6* rt.DictComp
# DictComp(expr key, expr value, comprehension* generators)

def do_DictComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '<**None**>' for z in gens]  # Kludge: probable bug.
    return f'%s for %s' % (elt, ''.join(gens))
#@+node:ekr.20150722204300.47: *6* rt.do_arguments & helpers
# arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def do_arguments(self, node):

    assert isinstance(node, ast.arguments), node
    first_default = len(node.args) - len(node.defaults)
    for n, arg in enumerate(node.args):
        if isinstance(arg, (list, tuple)):
            self.tuple_parameter(arg)
        else:
            self.visit(arg)
        if n >= first_default:
            default = node.defaults[n - first_default]
            self.gen("=")
            self.visit(default)
        self.comma()
    if getattr(node, 'vararg', None):
        self.gen('*')
        self.gen(self.name(node.vararg))
        self.comma()
    if getattr(node, 'kwarg', None):
        self.gen('**')
        self.gen(self.name(node.kwarg))
        self.comma()
    self.clean_comma()
#@+node:ekr.20160315182225.1: *7* rt.arg (Python 3 only)
# 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):

    self.gen(node.arg)
    if getattr(node, 'annotation', None):
        self.colon()
        self.visit(node.annotation)
#@+node:ekr.20150722204300.48: *7* rt.tuple_parameter
def tuple_parameter(self, node):

    assert isinstance(node, (list, tuple)), node
    self.gen("(")
    for param in node:
        if isinstance(param, tuple):
            self.tuple_parameter(param)
        else:
            self.visit(param)
    self.gen(")")
#@+node:ekr.20150722204300.64: *6* rt.Ellipsis
def do_Ellipsis(self, node):

    self.gen('...')
#@+node:ekr.20150722204300.65: *6* rt.ExceptHandler
def do_ExceptHandler(self, node):

    self.div('excepthandler')
    self.keyword("except")
    if not node.type:
        self.clean(' ')
    if node.type:
        self.visit(node.type)
    if node.name:
        self.keyword('as')
        self.visit(node.name)
    self.colon()
    self.div_body(node.body)
    self.end_div('excepthandler')
#@+node:ekr.20150722204300.66: *6* rt.Exec
# Python 2.x only.

def do_Exec(self, node):

    self.div('statement')
    self.keyword('exec')
    self.visit(node.body)
    if node.globals:
        self.comma()
        self.visit(node.globals)
    if node.locals:
        self.comma()
        self.visit(node.locals)
    self.end_div('statement')
#@+node:ekr.20150722204300.67: *6* rt.Expr
def do_Expr(self, node):

    self.div_node('expr', node.value)
#@+node:ekr.20160523103429.1: *6* rf.Expression
def do_Expression(self, node):
    """An inner expression: do not indent."""
    return f'%s' % self.visit(node.body)
#@+node:ekr.20160523103751.1: *6* rt.ExtSlice
def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
#@+node:ekr.20150722204300.68: *6* rt.For & AsyncFor (Python 3)
# For(expr target, expr iter, stmt* body, stmt* orelse)

def do_For(self, node, async_flag=False):

    self.div('statement')
    if async_flag:
        self.keyword('async')
    self.keyword("for")
    self.visit(node.target)
    self.keyword("in")
    self.visit(node.iter)
    self.colon()
    self.div_body(node.body)
    if node.orelse:
        self.keyword('else')
        self.colon()
        self.div_body(node.orelse)
    self.end_div('statement')

def do_AsyncFor(self, node):
    self.do_For(node, async_flag=True)
#@+node:ekr.20170721075845.1: *6* rf.FormattedValue (Python 3.6+: unfinished)
# FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node):  # Python 3.6+ only.
    self.div('statement')
    self.visit(node.value)
    if node.conversion:
        self.visit(node.conversion)
    if node.format_spec:
        self.visit(node.format_spec)
    self.end_div('statement')
#@+node:ekr.20150722204300.69: *6* rt.FunctionDef
# 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node, async_flag=False):

    self.div('function', extra=f'id="%s"' % node.name)
    if async_flag:
        self.keyword('async')
    self.keyword("def")
    self.name(node.name)
    self.gen('(')
    self.visit(node.args)
    self.gen(')')
    if getattr(node, 'returns', None):
        self.blank()
        self.gen('->')
        self.blank()
        self.visit(node.returns)
    self.colon()
    self.div('body')
    self.doc(node)
    self.visit_list(node.body)
    self.end_div('body')
    self.end_div('function')

def do_AsyncFunctionDef(self, node):
    self.do_FunctionDef(node, async_flag=True)
#@+node:ekr.20150722204300.70: *6* rt.GeneratorExp
def do_GeneratorExp(self, node):

    # self.span('genexpr')
    self.gen('(')
    if node.elt:
        self.visit(node.elt)
    self.keyword('for')
    # self.span_node('item', node.elt)
    self.visit(node.elt)
    # self.span_list('generators', node.generators)
    self.visit_list(node.generators)
    self.gen(')')
    # self.end_span('genexpr')
#@+node:ekr.20150722204300.71: *6* rt.get_import_names
def get_import_names(self, node):
    """Return a list of the the full file names in the import statement."""
    result = []
    for ast2 in node.names:
        assert isinstance(ast2, ast.alias), repr(ast2)
        data = ast2.name, ast2.asname
        result.append(data)
    return result
#@+node:ekr.20150722204300.72: *6* rt.Global
def do_Global(self, node):

    self.div('statement')
    self.keyword("global")
    for z in node.names:
        self.gen(z)
        self.comma()
    self.clean_comma()
    self.end_div('statement')
#@+node:ekr.20150722204300.73: *6* rt.If
# If(expr test, stmt* body, stmt* orelse)

def do_If(self, node, elif_flag=False):
    
    self.div('statement')
    self.keyword('elif' if elif_flag else 'if')
    self.visit(node.test)
    self.colon()
    self.div_body(node.body)
    if node.orelse:
        node1 = node.orelse[0]
        if isinstance(node1, ast.If) and len(node.orelse) == 1:
            self.do_If(node1, elif_flag=True)
        else:
            self.keyword('else')
            self.colon()
            self.div_body(node.orelse)
    self.end_div('statement')
#@+node:ekr.20150722204300.74: *6* rt.IfExp (TernaryOp)
# IfExp(expr test, expr body, expr orelse)

def do_IfExp(self, node):

    # self.span('ifexp')
    self.visit(node.body)
    self.keyword('if')
    self.visit(node.test)
    self.keyword('else')
    self.visit(node.orelse)
    # self.end_span('ifexp')
#@+node:ekr.20150722204300.75: *6* rt.Import
def do_Import(self, node):

    self.div('statement')
    self.keyword("import")
    for name, alias in self.get_import_names(node):
        self.name(name)  # self.gen(self.module_link(name))
        if alias:
            self.keyword("as")
            self.name(alias)
    self.end_div('statement')
#@+node:ekr.20150722204300.76: *6* rt.ImportFrom
def do_ImportFrom(self, node):

    self.div('statement')
    self.keyword("from")
    self.gen(self.module_link(node.module))
    self.keyword("import")
    for name, alias in self.get_import_names(node):
        self.name(name)
        if alias:
            self.keyword("as")
            self.name(alias)
        self.comma()
    self.clean_comma()
    self.end_div('statement')
#@+node:ekr.20160315190818.1: *6* rt.Index
def do_Index(self, node):

    self.visit(node.value)
#@+node:ekr.20170721080959.1: *6* rf.JoinedStr (Python 3.6+: unfinished)
# JoinedStr(expr* values)

def do_JoinedStr(self, node):
    for value in node.values or []:
        self.visit(value)
#@+node:ekr.20150722204300.77: *6* rt.Lambda
def do_Lambda(self, node):

    # self.span('lambda')
    self.keyword('lambda')
    self.visit(node.args)
    self.comma()
    self.span_node("code", node.body)
    # self.end_span('lambda')
#@+node:ekr.20150722204300.78: *6* rt.List
# List(expr* elts, expr_context ctx)

def do_List(self, node):

    # self.span('list')
    self.gen('[')
    if node.elts:
        for z in node.elts:
            self.visit(z)
            self.comma()
        self.clean_comma()
    self.gen(']')
    # self.end_span('list')
#@+node:ekr.20150722204300.79: *6* rt.ListComp
# ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node):

    # self.span('listcomp')
    self.gen('[')
    if node.elt:
        self.visit(node.elt)
    self.keyword('for')
    # self.span('ifgenerators')
    self.visit_list(node.generators)
    self.gen(']')
    # self.end_span('ifgenerators')
    # self.end_span('listcomp')
#@+node:ekr.20150722204300.80: *6* rt.Module
def do_Module(self, node):

    self.doc(node)
    self.visit_list(node.body)
#@+node:ekr.20150722204300.81: *6* rt.Name
def do_Name(self, node):

    self.name(node.id)
#@+node:ekr.20160315165109.1: *6* rt.NameConstant
def do_NameConstant(self, node):  # Python 3 only.

    self.name(repr(node.value))
#@+node:ekr.20160317051849.2: *6* rt.Nonlocal (Python 3)
# Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    self.div('statement')
    self.keyword('nonlocal')
    self.gen(', '.join(node.names))
    self.end_div('statement')
#@+node:ekr.20150722204300.82: *6* rt.Num
def do_Num(self, node):

    self.gen(self.text(repr(node.n)))
#@+node:ekr.20150722204300.83: *6* rt.Pass
def do_Pass(self, node):

    self.simple_statement('pass')
#@+node:ekr.20150722204300.84: *6* rt.Print
# Print(expr? dest, expr* values, bool nl)

def do_Print(self, node):

    self.div('statement')
    self.keyword("print")
    self.gen('(')
    if node.dest:
        self.op('>>\n')
        self.visit(node.dest)
        self.comma()
        self.newline()
        if node.values:
            for z in node.values:
                self.visit(z)
                self.comma()
                self.newline()
    self.clean('\n')
    self.clean_comma()
    self.gen(')')
    self.end_div('statement')
#@+node:ekr.20150722204300.85: *6* rt.Raise
# Raise(expr? type, expr? inst, expr? tback)    Python 2
# Raise(expr? exc, expr? cause)                 Python 3

def do_Raise(self, node):

    self.div('statement')
    self.keyword("raise")
    for attr in ('exc', 'cause'):
        if getattr(node, attr, None) is not None:
            self.visit(getattr(node, attr))
    self.end_div('statement')
#@+node:ekr.20160523105022.1: *6* rt.Repr
# Python 2.x only

def do_Repr(self, node):
    return f'repr(%s)' % self.visit(node.value)
#@+node:ekr.20150722204300.86: *6* rt.Return
def do_Return(self, node):

    self.div('statement')
    self.keyword("return")
    if node.value:
        self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20160523104433.1: *6* rt.Set
# Set(expr* elts)

def do_Set(self, node):
    for z in node.elts:
        self.visit(z)
#@+node:ekr.20160523104454.1: *6* rt.SetComp
# SetComp(expr elt, comprehension* generators)

def do_SetComp(self, node):

    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    return f'%s for %s' % (elt, ''.join(gens))
#@+node:ekr.20150722204300.87: *6* rt.Slice
def do_Slice(self, node):

    # self.span("slice")
    if node.lower:
        self.visit(node.lower)
    self.colon()
    if node.upper:
        self.visit(node.upper)
    if node.step:
        self.colon()
        self.visit(node.step)
    # self.end_span("slice")
#@+node:ekr.20160317051849.3: *6* rt.Starred (Python 3)
# Starred(expr value, expr_context ctx)

def do_Starred(self, node):

    self.gen('*')
    self.visit(node.value)
#@+node:ekr.20150722204300.88: *6* rt.Str
def do_Str(self, node):
    """This represents a string constant."""

    def clean(s):
        return s.replace(' ', '').replace('\n', '').replace('"', '').replace("'", '')

    assert isinstance(node.s, str)
    if self.last_doc and clean(self.last_doc) == clean(node.s):
        # Already seen.
        self.last_doc = None
    else:
        self.string(node.s)
#@+node:ekr.20150722204300.89: *6* rt.Subscript
def do_Subscript(self, node):

    # self.span("subscript")
    self.visit(node.value)
    self.gen('[')
    self.visit(node.slice)
    self.gen(']')
    # self.end_span("subscript")
#@+node:ekr.20160315190913.1: *6* rt.Try (Python 3)
# Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node):

    self.div('statement')
    self.keyword('try')
    self.colon()
    self.div_list('body', node.body)
    for z in node.handlers:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
    if node.finalbody:
        self.keyword('finally')
        self.colon()
        self.div_list('body', node.finalbody)
    self.end_div('statement')
#@+node:ekr.20150722204300.90: *6* rt.TryExcept
def do_TryExcept(self, node):

    self.div('statement')
    self.keyword('try')
    self.colon()
    self.div_list('body', node.body)
    if node.orelse:
        self.keyword('else')
        self.colon()
        self.div_body(node.orelse)
    self.div_body(node.handlers)
    self.end_div('statement')
#@+node:ekr.20150722204300.91: *6* rt.TryFinally
def do_TryFinally(self, node):

    self.div('statement')
    self.keyword('try')
    self.colon()
    self.div_body(node.body)
    self.keyword('finally')
    self.colon()
    self.div_body(node.final.body)
    self.end_div('statement')
#@+node:ekr.20150722204300.92: *6* rt.Tuple
# Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node):

    # self.span('tuple')
    self.gen('(')
    for z in node.elts or []:
        self.visit(z)
        self.comma()
    self.clean_comma()
    self.gen(')')
    # self.end_span('tuple')
#@+node:ekr.20150722204300.94: *6* rt.While
def do_While(self, node):

    self.div('statement')
    self.div(None)
    self.keyword("while")
    self.visit(node.test)
    self.colon()
    self.end_div(None)
    self.div_list('body', node.body)
    if node.orelse:
        self.keyword('else')
        self.colon()
        self.div_body(node.orelse)
    self.end_div('statement')
#@+node:ekr.20150722204300.93: *6* rt.UnaryOp
def do_UnaryOp(self, node):

    op_name_ = op_name(node.op).strip()
    # self.span(op_name_)
    self.op(op_name_, trailing=False)
    self.visit(node.operand)
    # self.end_span(op_name_)
#@+node:ekr.20150722204300.95: *6* rt.With & AsyncWith (Python 3)
# 2:  With(expr context_expr, expr? optional_vars,
#          stmt* body)
# 3:  With(withitem* items,
#          stmt* body)
# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node, async_flag=False):

    context_expr = getattr(node, 'context_expr', None)
    optional_vars = getattr(node, 'optional_vars', None)
    items = getattr(node, 'items', None)
    self.div('statement')
    if async_flag:
        self.keyword('async')
    self.keyword('with')
    if context_expr:
        self.visit(context_expr)
    if optional_vars:
        self.keyword('as')
        self.visit_list(optional_vars)
    if items:
        for item in items:
            self.visit(item.context_expr)
            if getattr(item, 'optional_vars', None):
                self.keyword('as')
                self.visit(item.optional_vars)
    self.colon()
    self.div_body(node.body)
    self.end_div('statement')

def do_AsyncWith(self, node):
    self.do_With(node, async_flag=True)
#@+node:ekr.20150722204300.96: *6* rt.Yield
def do_Yield(self, node):

    self.div('statement')
    self.keyword('yield')
    self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20160317051849.5: *6* rt.YieldFrom (Python 3)
# YieldFrom(expr value)

def do_YieldFrom(self, node):

    self.div('statement')
    self.keyword('yield from')
    self.visit(node.value)
    self.end_div('statement')
#@+node:ekr.20160225102931.1: *3* class TokenSync (deprecated)
class TokenSync:
    """A class to sync and remember tokens."""
    # To do: handle comments, line breaks...
    @others
#@+node:ekr.20160225102931.2: *4*  ts.ctor & helpers
def __init__(self, s, tokens):
    """Ctor for TokenSync class."""
    assert isinstance(tokens, list)  # Not a generator.
    self.s = s
    self.first_leading_line = None
    self.lines = [z.rstrip() for z in g.splitLines(s)]
    # Order is important from here on...
    self.nl_token = self.make_nl_token()
    self.line_tokens = self.make_line_tokens(tokens)
    self.blank_lines = self.make_blank_lines()
    self.string_tokens = self.make_string_tokens()
    self.ignored_lines = self.make_ignored_lines()
#@+node:ekr.20160225102931.3: *5* ts.make_blank_lines
def make_blank_lines(self):
    """Return of list of line numbers of blank lines."""
    result = []
    for i, aList in enumerate(self.line_tokens):
        # if any([self.token_kind(z) == 'nl' for z in aList]):
        if len(aList) == 1 and self.token_kind(aList[0]) == 'nl':
            result.append(i)
    return result
#@+node:ekr.20160225102931.4: *5* ts.make_ignored_lines
def make_ignored_lines(self):
    """
    Return a copy of line_tokens containing ignored lines,
    that is, full-line comments or blank lines.
    These are the lines returned by leading_lines().
    """
    result = []
    for i, aList in enumerate(self.line_tokens):
        for z in aList:
            if self.is_line_comment(z):
                result.append(z)
                break
        else:
            if i in self.blank_lines:
                result.append(self.nl_token)
            else:
                result.append(None)
    assert len(result) == len(self.line_tokens)
    for i, aList in enumerate(result):
        if aList:
            self.first_leading_line = i
            break
    else:
        self.first_leading_line = len(result)
    return result
#@+node:ekr.20160225102931.5: *5* ts.make_line_tokens (trace tokens)
def make_line_tokens(self, tokens):
    """
    Return a list of lists of tokens for each list in self.lines.
    The strings in self.lines may end in a backslash, so care is needed.
    """
    import token as tm
    n, result = len(self.lines), []
    for i in range(0, n+1):
        result.append([])
    for token in tokens:
        t1, t2, t3, t4, t5 = token
        kind = tm.tok_name[t1].lower()
        srow, scol = t3
        erow, ecol = t4
        line = erow - 1 if kind == 'string' else srow - 1
        result[line].append(token)
    assert len(self.lines) + 1 == len(result), len(result)
    return result
#@+node:ekr.20160225102931.6: *5* ts.make_nl_token
def make_nl_token(self):
    """Return a newline token with '\n' as both val and raw_val."""
    import token as tm
    t1 = tm.NEWLINE
    t2 = '\n'
    t3 = (0, 0)  # Not used.
    t4 = (0, 0)  # Not used.
    t5 = '\n'
    return t1, t2, t3, t4, t5
#@+node:ekr.20160225102931.7: *5* ts.make_string_tokens
def make_string_tokens(self):
    """Return a copy of line_tokens containing only string tokens."""
    result = []
    for aList in self.line_tokens:
        result.append([z for z in aList if self.token_kind(z) == 'string'])
    assert len(result) == len(self.line_tokens)
    return result
#@+node:ekr.20160225102931.8: *4* ts.check_strings
def check_strings(self):
    """Check that all strings have been consumed."""
    for i, aList in enumerate(self.string_tokens):
        if aList:
            g.trace(f"warning: line {i}. unused strings: {aList}")
#@+node:ekr.20160225102931.10: *4* ts.is_line_comment
def is_line_comment(self, token):
    """Return True if the token represents a full-line comment."""
    import token as tm
    t1, t2, t3, t4, t5 = token
    kind = tm.tok_name[t1].lower()
    raw_val = t5
    return kind == 'comment' and raw_val.lstrip().startswith('#')
#@+node:ekr.20160225102931.12: *4* ts.last_node
def last_node(self, node):
    """Return the node of node's tree with the largest lineno field."""

    class LineWalker(ast.NodeVisitor):

        def __init__(self):
            """Ctor for LineWalker class."""
            self.node = None
            self.lineno = -1

        def visit(self, node):
            """LineWalker.visit."""
            if hasattr(node, 'lineno'):
                if node.lineno > self.lineno:
                    self.lineno = node.lineno
                    self.node = node
            if isinstance(node, list):
                for z in node:
                    self.visit(z)
            else:
                self.generic_visit(node)

    w = LineWalker()
    w.visit(node)
    return w.node
#@+node:ekr.20160225102931.13: *4* ts.leading_lines
def leading_lines(self, node):
    """Return a list of the preceding comment and blank lines"""
    # This can be called on arbitrary nodes.
    leading = []
    if hasattr(node, 'lineno'):
        i, n = self.first_leading_line, node.lineno
        while i < n:
            token = self.ignored_lines[i]
            if token:
                s = self.token_raw_val(token).rstrip() + '\n'
                leading.append(s)
            i += 1
        self.first_leading_line = i
    return leading
#@+node:ekr.20160225102931.14: *4* ts.leading_string
def leading_string(self, node):
    """Return a string containing all lines preceding node."""
    return ''.join(self.leading_lines(node))
#@+node:ekr.20160225102931.15: *4* ts.line_at
def line_at(self, node, continued_lines=True):
    """Return the lines at the node, possibly including continuation lines."""
    n = getattr(node, 'lineno', None)
    if n is None:
        return f'<no line> for %s' % node.__class__.__name__
    if continued_lines:
        aList, n = [], n - 1
        while n < len(self.lines):
            s = self.lines[n]
            if s.endswith('\\'):
                aList.append(s[:-1])
                n += 1
            else:
                aList.append(s)
                break
        return ''.join(aList)
    return self.lines[n - 1]
#@+node:ekr.20160225102931.16: *4* ts.sync_string
def sync_string(self, node):
    """Return the spelling of the string at the given node."""
    n = node.lineno
    tokens = self.string_tokens[n - 1]
    if tokens:
        token = tokens.pop(0)
        self.string_tokens[n - 1] = tokens
        return self.token_val(token)
    g.trace('===== underflow', n, node.s)
    return node.s
#@+node:ekr.20160225102931.18: *4* ts.tokens_for_statement
def tokens_for_statement(self, node):
    assert isinstance(node, ast.AST), node
    name = node.__class__.__name__
    if hasattr(node, 'lineno'):
        tokens = self.line_tokens[node.lineno - 1]
        g.trace(' '.join([self.dump_token(z) for z in tokens]))
    else:
        g.trace('no lineno', name)
#@+node:ekr.20160225102931.19: *4* ts.trailing_comment
def trailing_comment(self, node):
    """
    Return a string containing the trailing comment for the node, if any.
    The string always ends with a newline.
    """
    if hasattr(node, 'lineno'):
        return self.trailing_comment_at_lineno(node.lineno)
    g.trace('no lineno', node.__class__.__name__, g.callers())
    return '\n'
#@+node:ekr.20160225102931.20: *4* ts.trailing_comment_at_lineno
def trailing_comment_at_lineno(self, lineno):
    """Return any trailing comment at the given node.lineno."""
    tokens = self.line_tokens[lineno - 1]
    for token in tokens:
        if self.token_kind(token) == 'comment':
            raw_val = self.token_raw_val(token).rstrip()
            if not raw_val.strip().startswith('#'):
                val = self.token_val(token).rstrip()
                s = f' %s\n' % val
                return s
    return '\n'
#@+node:ekr.20160225102931.21: *4* ts.trailing_lines
def trailing_lines(self):
    """return any remaining ignored lines."""
    trailing = []
    i = self.first_leading_line
    while i < len(self.ignored_lines):
        token = self.ignored_lines[i]
        if token:
            s = self.token_raw_val(token).rstrip() + '\n'
            trailing.append(s)
        i += 1
    self.first_leading_line = i
    return trailing
#@+node:ekr.20191122105543.1: *4* ts:dumps
#@+node:ekr.20160225102931.9: *5* ts.dump_token
def dump_token(self, token, verbose=False):
    """Dump the token. It is either a string or a 5-tuple."""
    import token as tm
    if isinstance(token, str):
        return token
    t1, t2, t3, t4, t5 = token
    kind = g.toUnicode(tm.tok_name[t1].lower())
    # raw_val = g.toUnicode(t5)
    val = g.toUnicode(t2)
    if verbose:
        return f'token: %10s %r' % (kind, val)
    return val
#@+node:ekr.20160225102931.17: *5* ts.token_kind/raw_val/val
def token_kind(self, token):
    """Return the token's type."""
    t1, t2, t3, t4, t5 = token
    import token as tm
    return g.toUnicode(tm.tok_name[t1].lower())

def token_raw_val(self, token):
    """Return the value of the token."""
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(t5)

def token_val(self, token):
    """Return the raw value of the token."""
    t1, t2, t3, t4, t5 = token
    return g.toUnicode(t2)
#@+node:ekr.20160225102931.11: *5* ts.join
def join(self, aList, sep=','):
    """return the items of the list joined by sep string."""
    tokens = []
    for i, token in enumerate(aList or []):
        tokens.append(token)
        if i < len(aList) - 1:
            tokens.append(sep)
    return tokens
#@+node:ekr.20190910081550.1: *3* class SyntaxSanitizer
class SyntaxSanitizer:

    << SyntaxSanitizer docstring >>

    def __init__(self, c, keep_comments):
        self.c = c
        self.keep_comments = keep_comments

    @others
#@+node:ekr.20190910093739.1: *4* << SyntaxSanitizer docstring >>
r"""
This class converts section references, @others and Leo directives to
comments. This allows ast.parse to handle the result.

Within section references, these comments must *usually* be executable:
    
BEFORE:
    if condition:
        <\< do something >\>
AFTER:
    if condition:
        pass # do something
        
Alas, sanitation can result in a syntax error. For example, leoTips.py contains:
    
BEFORE:
    tips = [
        <\< define tips >\>
        ]

AFTER:
    tips = [
        pass # define tips
    ]
    
This fails because tips = [pass] is a SyntaxError.

The beautify* and black* commands clearly report such failures.
"""
#@+node:ekr.20190910022637.2: *4* sanitize.comment_leo_lines
def comment_leo_lines(self, p=None, s0=None):
    """
    Replace lines containing Leonine syntax with **special comment lines** of the form:
        
        {lws}#{lws}{marker}{line}
        
    where: 
    - lws is the leading whitespace of the original line
    - marker appears nowhere in p.b
    - line is the original line, unchanged.
    
    This convention allows uncomment_special_lines to restore these lines.
    """
    # Choose a marker that appears nowhere in s.
    if p:
        s0 = p.b
    n = 5
    while('#'+ ('!'*n)) in s0:
        n += 1
    comment = '#' + ('!' * n)
    # Create a dict of directives.
    d = {z: True for z in g.globalDirectiveList}
    # Convert all Leonine lines to special comments.
    i, lines, result = 0, g.splitLines(s0), []
    while i < len(lines):
        progress = i
        s = lines[i]
        s_lstrip = s.lstrip()
        # Comment out any containing a section reference.
        j = s.find('<<')
        k = s.find('>>') if j > -1 else -1
        if -1 < j < k:
            result.append(comment+s)
            # Generate a properly-indented pass line.
            j2 = g.skip_ws(s, 0)
            result.append(f'{" "*j2}pass\n')
        elif s_lstrip.startswith('@'):
            # Comment out all other Leonine constructs.
            if self.starts_doc_part(s):
                # Comment the entire doc part, until @c or @code.
                result.append(comment+s)
                i += 1
                while i < len(lines):
                    s = lines[i]
                    result.append(comment+s)
                    i += 1
                    if self.ends_doc_part(s):
                        break
            else:
                j = g.skip_ws(s, 0)
                assert s[j] == '@'
                j += 1
                k = g.skip_id(s, j, chars='-')
                if k > j:
                    word = s[j : k]
                    if word == 'others':
                        # Remember the original @others line.
                        result.append(comment+s)
                        # Generate a properly-indented pass line.
                        result.append(f'{" "*(j-1)}pass\n')
                    else:
                        # Comment only Leo directives, not decorators.
                        result.append(comment+s if word in d else s)
                else:
                    result.append(s)
        elif s_lstrip.startswith('#') and self.keep_comments:
            # A leading comment.
            # Bug fix: Preserve lws in comments, too.
            j2 = g.skip_ws(s, 0)
            result.append(" "*j2+comment+s)
        else:
            # A plain line.
            result.append(s)
        if i == progress:
            i += 1
    return comment, ''.join(result)
#@+node:ekr.20190910022637.3: *4* sanitize.starts_doc_part & ends_doc_part
def starts_doc_part(self, s):
    """Return True if s word matches @ or @doc."""
    return s.startswith(('@\n', '@doc\n', '@ ', '@doc '))

def ends_doc_part(self, s):
    """Return True if s word matches @c or @code."""
    return s.startswith(('@c\n', '@code\n', '@c ', '@code '))
#@+node:ekr.20190910022637.4: *4* sanitize.uncomment_leo_lines
def uncomment_leo_lines(self, comment, p, s0):
    """Reverse the effect of comment_leo_lines."""
    lines = g.splitLines(s0)
    i, result = 0, []
    while i < len(lines):
        progress = i
        s = lines[i]
        i += 1
        if comment in s:
            # One or more special lines.
            i = self.uncomment_special_lines(comment, i, lines, p, result, s)
        else:
            # A regular line.
            result.append(s)
        assert progress < i
    return ''.join(result).rstrip() + '\n'
#@+node:ekr.20190910022637.5: *4* sanitize.uncomment_special_line & helpers
def uncomment_special_lines(self, comment, i, lines, p, result, s):
    """
    This method restores original lines from the special comment lines
    created by comment_leo_lines. These lines have the form:
        
        {lws}#{marker}{line}
        
    where: 
    - lws is the leading whitespace of the original line
    - marker appears nowhere in p.b
    - line is the original line, unchanged.
    
    s is a line containing the comment delim.
    i points at the *next* line.
    Handle one or more lines, appending stripped lines to result.
    """
    #
    # Delete the lws before the comment.
    # This works because the tail contains the original whitespace.
    assert comment in s
    s = s.lstrip().replace(comment, '')
    #
    # Here, s is the original line.
    if comment in s:
        g.trace(f"can not happen: {s!r}")
        return i
    if self.starts_doc_part(s):
        result.append(s)
        while i < len(lines):
            s = lines[i].lstrip().replace(comment, '')
            i += 1
            result.append(s)
            if self.ends_doc_part(s):
                break
        return i
    j = s.find('<<')
    k = s.find('>>') if j > -1 else -1
    if -1 < j < k or '@others' in s:
        #
        # A section reference line or an @others line.
        # Such lines are followed by a pass line.
        #
        # The beautifier may insert blank lines before the pass line.
        kind = 'section ref' if -1 < j < k else '@others'
        # Restore the original line, including leading whitespace.
        result.append(s)
        # Skip blank lines.
        while i < len(lines) and not lines[i].strip():
            i += 1
        # Skip the pass line.
        if i < len(lines) and lines[i].lstrip().startswith('pass'):
            i += 1
        else:
            g.trace(f"*** no pass after {kind}: {p.h}")
    else:
        # A directive line or a comment line.
        result.append(s)
    return i
#@+node:ekr.20200729081336.1: *3* re TOG classes
#@+node:ekr.20191113133338.1: *4* class TestRunner
class TestRunner:
    """
    A testing framework for TokenOrderGenerator and related classes.
    """
    
    counts, times = {}, {}
    << define valid actions & flags >>
    @others
   
#@+node:ekr.20191222064729.1: *5* << define valid actions & flags >>
valid_actions = [
    'run-ast-tokens',       # Alternate pass 0.
    'make-tokens-and-tree', # Pass 0.
    'create-links',         # Pass 1.
    'fstringify',           # Pass 2.
    # Dumps...
    'dump-all',
    'dump-ast', # Was dump-raw-tree.
    'dump-contents',
    'dump-lines',
    'dump-results',
    'dump-times',
    'dump-tokens',
    'dump-tree',
]

valid_flags = [
    'all',
    'all-leo-files',
    'coverage',
    'dump-all-after-fail',
    'dump-ast-tree-first',
    'dump-results',
    'dump-tokens-after-fail',
    'dump-tokens-first',
    'dump-tree-after-fail',
    'no-trace-after-fail',
    'set-trace-mode',
    'show-pass0-times',
    'show-create-links-time',
    'show-fstringify-time',
    'show-exception-after-fail',
    'show-make-tokens-time',
    'show-test-description',
    'show-test-kind',
    'summarize',
    'trace-tokenizer-tokens',
    'verbose-fail',
]
#@+node:ekr.20191205160754.4: *5* TR.run_tests & helpers
def run_tests(self, actions, flags, root, contents=None):
    """The outer test runner."""
    # Startup.
    self.fails = []
    self.root = root
    self.times = {}
    # Create self.actions and self.flags.
    ok = self.make_actions_and_flags(actions, flags)
    if not ok:
        print('Aborting...')
        return
    flags = self.flags
    self.show_status()
    if contents:
        self.tests = [(contents, root.h or 'None')]
    elif 'all-leo-files' in flags:
        self.tests = self.make_leo_tests()
    else:
        self.tests = self.make_tests(root)
    # Execute all tests.
    t1 = get_time()
    for contents, description in self.tests:
        # run_one_test catches all exceptions.
        if 'show-test-description' in flags:
            print(f"Running {description}...")
        ok = self.run_one_test(contents, description)
        if not ok:
            self.fails.append(description)
        if 'fail-fast' in flags:
            break
    # End-of-tests reports.
    t2 = get_time()
    self.times['total_time'] = t2 - t1
    if 'coverage' in flags:
        self.show_coverage()
    if 'summarize' in flags:
        self.summarize()
#@+node:ekr.20191205163727.1: *6* TR.make_actions_and_flags
def make_actions_and_flags(self, actions, flags):
    """
    Create self.actions and self.flags.
    
    Return False if there are unknow actions or flags.
    """
    valid_actions, valid_flags = self.valid_actions, self.valid_flags
    # Check valid actions.
    for z in valid_actions:
        assert hasattr(self, z.replace('-','_')), repr(z)
    # Clean and check actions.
    self.actions = [z for z in actions if z in valid_actions]
    bad_actions = [z for z in actions if z not in valid_actions]
    if bad_actions:
        for z in bad_actions:
            print('Unknown action:', z)
        return False
    # Clean and check flags.
    flags = [z.lower() for z in flags or []]
    self.flags = [z for z in flags if z in valid_flags]
    bad_flags = [z for z in flags if z not in valid_flags]
    if bad_flags:
        for z in bad_flags:
            print('Unknown flag:', z)
        return False
    return True
#@+node:ekr.20191205172431.1: *6* TR.make_leo_tests
def make_leo_tests(self):
    """
    Leo-specific code for unit tests.
    
    Return a list of tuples (contents, description) for all of Leo's core
    .py files.
    """
    import leo.core.leoGlobals as leo_g
    core_directory = leo_g.os_path_finalize_join(leo_g.app.loadDir, '..', 'core')
    assert os.path.exists(core_directory), core_directory
    paths = glob.glob(core_directory + os.path.sep + 'leo*.py')
    tests = []
    for path in paths:
        assert os.path.exists(path), path
        with open(path, 'r') as f:
            contents = f.read()
        description = path
        tests.append((contents, description))   
    return tests

#@+node:ekr.20191205160754.2: *6* TR.make_tests
def make_tests(self, root):
    """
    Leo-specific code for unit tests.
    
    Return a list of tuples (contents, description) found in all children
    of the root, except this node.
    """
    import leo.core.leoGlobals as leo_g
    tests = []
    contents_tag = 'test:'
    file_tag = 'file:'
    after = root.nodeAfterTree()
    p = root.copy()
    while p and p != after:
        if p.h.startswith(('fail:', 'fails')):
            # Ignore all fails, regardless of 'all' flag.
            p.moveToNodeAfterTree()
        elif 'all' not in self.flags and p.h.startswith('ignore:'):
            # Honor 'ignore' only when *not* runnining all tests.
            p.moveToNodeAfterTree()
        elif p.h.startswith(contents_tag):
            description = p.h
            contents = p.b.strip() + '\n'
            tests.append((contents, description))
            p.moveToThreadNext()
        elif p.h.startswith(file_tag):
            description = p.h
            s = p.h[len(file_tag):].strip()
            parts = [leo_g.app.loadDir, '..'] + s.split('..')
            path = os.path.sep.join(parts)
            if os.path.exists(path):
                with open(path, 'r') as f:
                    contents = f.read()
                tests.append((contents, description))
                p.moveToThreadNext()
            else:
                assert False, f"file not found: {path}"
        else:
            # Ignore organizer nodes.
            p.moveToThreadNext()
    if not tests:
        print(f"no tests in {root.h}")
    return tests
#@+node:ekr.20191122025155.1: *6* TR.show_coverage
def show_coverage(self):
    if self.toi:
        self.toi.report_coverage()
#@+node:ekr.20191205160754.5: *6* TR.show_status
def show_status(self):
    """Show the preliminary status."""
    flags = self.flags
    print('')
    if 'show-test-kind' in flags:
        if 'all-leo-files' in flags:
            kind = 'Testing all Leo files'
        elif 'all' in flags:
            kind = 'Running *all* unit tests'
        else:
            kind = 'Running *selected* unit tests'
        print(f"{self.root.h}: {kind}...")
    if 'run-ast-tokens' in self.actions:
        print('\nUsing asttokens, *not* the TOG classes')
#@+node:ekr.20191205160754.6: *6* TR.summarize
def summarize(self):
    fails, tests = self.fails, self.tests
    status = 'FAIL' if fails else 'PASS'
    if fails:
        print('')
        g.printObj(fails, tag='Failed tests')
    print(
        f"\n{status} Ran "
        f"{len(tests)} test{g.plural(len(tests))}")
    if not 'dump-times' in self.flags:
        self.dump_times()
#@+node:ekr.20191122021515.1: *5* TR.run_one_test
def run_one_test(self, contents, description):
    """
    Run the test given by the contents and description.
    """
    tag = 'run_tests'
    self.description = description
    # flags = self.flags
    # Clean the contents.
    self.contents = contents = contents.strip() + '\n'
    
    #
    # Execute actions, in the user-defined order.
    bad_actions = []
    for action in self.actions:
        helper = getattr(self, action.replace('-', '_'), None)
        if helper:
            try:
                helper()
            except Exception as e:
                print(f"{tag}: Exception in {action}: {e}")
                if 'show-exception-after-fail' in self.flags:
                    g.es_exception()
                return False
        else:
            bad_actions.append(action)
    if bad_actions:
        for action in list(set(bad_actions)):
            print(f"{tag}: bad action option: {action!r}")
    return True
#@+node:ekr.20191205160624.1: *5* TR: actions...
# Actions should fail by throwing an exception.
#@+node:ekr.20191226064933.1: *6* TR.create_links (pass 1)
def create_links(self):
    """Pass 1: TOG.create_links"""
    flags, toi = self.flags, self.toi
    # Catch exceptions so we can get data late.
    try:
        t1 = get_time()
        # Yes, list *is* required here.
        list(toi.create_links(self.tokens, self.tree, file_name=self.description))
        t2 = get_time()
        self.update_times('10: create-links', t2 - t1)
    except Exception as e:
        g.trace(f"\nFAIL: make-tokens\n")
        # Don't use g.trace.  It doesn't handle newlines properly.
        print(e)
        if 'show-exception-after-fail' in flags:
            g.es_exception()
        if 'dump-all-after-fail' in flags:
            self.dump_all()
        else:
            if 'dump-tokens-after-fail' in flags:
                self.dump_tokens()
            if 'dump-tree-after-fail' in flags:
                self.dump_tree()
        if 'no-trace-after-fail':
            toi.trace_mode = False
        raise
#@+node:ekr.20191122022728.1: *6* TR.dump_all
def dump_all(self):

    if self.toi:
        self.dump_contents()
        self.dump_tokens()
        self.dump_tree()
        # self.dump_ast()

#@+node:ekr.20191122025306.2: *6* TR.dump_ast
def dump_ast(self):
    """Dump an ast tree.  Similar to ast.dump()."""
    print('\nast tree...\n')
    print(AstDumper().dump_ast(self.tree))
    print('')
#@+node:ekr.20191122025303.1: *6* TR.dump_contents
def dump_contents(self):
    contents = self.contents
    print('\nContents...\n')
    for i, z in enumerate(g.splitLines(contents)):
        print(f"{i+1:<3} ", z.rstrip())
    print('')
#@+node:ekr.20191122025306.1: *6* TR.dump_lines
def dump_lines(self):
    print('\nTOKEN lines...\n')
    for z in self.tokens:
        if z.line.strip():
            print(z.line.rstrip())
        else:
            print(repr(z.line))
    print('')
#@+node:ekr.20191225063758.1: *6* TR.dump_results
def dump_results(self):
    print('\nResults...\n')
    print(tokens_to_string(self.tokens))
#@+node:ekr.20191226095129.1: *6* TR.dump_times
def dump_times(self):
    """
    Show all calculated times.
    
    Keys should start with a priority (sort order) of the form `[0-9][0-9]:`
    """
    if not self.times:
        return
    print('')
    for key in sorted(self.times):
        t = self.times.get(key)
        key2 = key[3:]
        print(f"{key2:>16}: {t:6.3f} sec.")
#@+node:ekr.20191122025418.1: *6* TR.dump_tokens
def dump_tokens(self):
    tokens = self.tokens
    print('\nTokens...\n')
    print("Note: values shown are repr(value) *except* for 'string' tokens.\n")
    # pylint: disable=not-an-iterable
    if self.toi:
        for z in tokens:
            print(z.dump())
        print('')
    else:
        import token as tm
        for z in tokens:
            kind = tm.tok_name[z.type].lower()
            print(f"{z.index:4} {kind:>12} {z.string!r}")
#@+node:ekr.20191122025419.1: *6* TR.dump_tree
def dump_tree(self):
    print('\nPatched tree...\n')
    tokens, tree = self.tokens, self.tree
    if self.toi:
        print(dump_tree_and_links(tree))
        return
    try:
        # pylint: disable=import-error
        from asttokens.util import walk
    except Exception:
        return
    for z in walk(tree):
        class_name = z.__class__.__name__
        first, last = z.first_token.index, z.last_token.index
        token_range = f"{first:>4}..{last:<4}"
        if isinstance(z, ast.Module):
            tokens_s = ''
        else:
            tokens_s = ' '.join(
                repr(z.string) for z in tokens[first:last] if z)
        print(f"{class_name:>12} {token_range:<10} {tokens_s}")
#@+node:ekr.20191222074711.1: *6* TR.fstringify (pass 2)
def fstringify(self):
    """Pass 2: TOG.fstringify."""
    toi = self.toi
    assert isinstance(toi, TokenOrderGenerator), repr(toi)
    t1 = get_time()
    toi.fstringify(toi.tokens, toi.tree, filename='unit test')
    t2 = get_time()
    self.update_times('20: fstringify', t2 - t1)
#@+node:ekr.20191226063007.1: *6* TR.make_tokens_and_tree (pass 0)
def make_tokens_and_tree(self):
    """Pass 0: TOG.make_tokens_and_tree."""
    contents, flags = self.contents, self.flags
    t1 = get_time()
    # Create and remember the toi.
    toi = self.toi = TokenOrderInjector()
    toi.trace_mode = 'set-trace-mode' in flags
    # Tokenize.
    self.tokens = make_tokens(contents)
    t2 = get_time()
    self.update_times('01: make-tokens', t2 - t1)
    # Parse.
    self.tree = parse_ast(contents)
    t3 = get_time()
    self.update_times('01: parse-ast', t3 - t2)
    # Dump.
    if 'dump-tokens-first' in flags:
        dump_tokens(self.tokens)
    if 'dump-ast-tree-first' in flags:
        dump_ast(self.tree)
#@+node:ekr.20191226063942.1: *6* TR.run_ast_tokens
def run_ast_tokens(self):
    # pylint: disable=import-error
    # It's ok to raise ImportError here.
    import asttokens
    t1 = get_time()
    atok = asttokens.ASTTokens(self.contents, parse=True)
    self.tree = atok.tree
    self.tokens = atok._tokens
    t2 = get_time()
    self.update_times('01: ast-tokens', t2 - t1)
#@+node:ekr.20191228183156.1: *6* TR.update_counts & update_times
def update_counts(self, key, n):
    """Update the count statistic given by key, n."""
    old_n = self.times.get(key, 0)
    self.counts [key] = old_n + n

def update_times(self, key, t):
    """Update the timing statistic given by key, t."""
    old_t = self.times.get(key, 0.0)
    self.times [key] = old_t + t
#@+node:ekr.20191113054314.1: *4* class TokenOrderInjector (TOG)
class TokenOrderInjector (TokenOrderGenerator):
    """
    A class that injects parent/child data into tokens and ast nodes.
    """
    @others
#@+node:ekr.20191113054550.1: *5* toi.begin_visitor
def begin_visitor(self, node):
    """
    TokenOrderInjector.begin_visitor.
    
    Enter a visitor, inject data into the ast node, and update stats.
    """
    #
    # Do this first, *before* updating self.node.
    self.coverage_set.add(node.__class__.__name__)
    node.parent = self.node
    if self.node:
        children = getattr(self.node, 'children', [])
        children.append(node)
        self.node.children = children
    #
    # *Now* update self.node, etc.
    super().begin_visitor(node)
#@+node:ekr.20191121122230.1: *4* class TokenOrderNodeGenerator (TOG)
class TokenOrderNodeGenerator(TokenOrderGenerator):
    """A class that yields a stream of nodes."""

    # Other overrides...
    def sync_token(self, kind, val):
        pass
        
    @others
#@+node:ekr.20191228153344.1: *5* tong.generate_nodes
def generate_nodes(self, tokens, tree, file_name=''):
    """Entry: yield a stream of nodes."""
    #
    # Init all ivars.
    self.file_name = file_name
        # For tests.
    self.level = 0
        # Python indentation level.
    self.node = None
        # The node being visited.
        # The parent of the about-to-be visited node.
    self.tokens = tokens
        # The immutable list of input tokens.
    self.tree = tree
        # The tree of ast.AST nodes.
    #
    # Traverse the tree.
    try:
        while True:
            next(self.visitor(tree))
    except StopIteration:
        pass
#@+node:ekr.20191228152949.1: *5* tong.begin/end_visitor
def begin_visitor(self, node):
    """TONG.begin_visitor: Enter a visitor."""
    # begin_visitor and end_visitor must be paired.
    self.begin_end_stack.append(node.__class__.__name__)
    # Push the previous node.
    self.node_stack.append(self.node)
    # Update self.node *last*.
    self.node = node

def end_visitor(self, node):
    """TONG.end_visitor: Leave a visitor."""
    # begin_visitor and end_visitor must be paired.
    entry_name = self.begin_end_stack.pop()
    assert entry_name == node.__class__.__name__, (repr(entry_name), node.__class__.__name__)
    assert self.node == node, (repr(self.node), repr(node))
    # Restore self.node.
    self.node = self.node_stack.pop()
#@+node:ekr.20200129084258.21: *4* function: replace_node_and_tokens
def replace_node_and_tokens(old_node, new_node, old_tokens, new_token, token_list):
    """
    Replace old_node with new_node.
    Replace all old_tokens with a single new_token.
    """
    # Replace the tokens...
        # tokens = tokens_for_node(old_node, token_list)
        # i1 = i = tokens[0].index
        # replace_token(self.tokens[i], 'string', s)
        # replace_token(token_list[i], new_token.kind, new_token.value)
    replace_token(old_token, new_token.kind, new_token.value)
    i1 = old_token.index
    j = 1
    while j < len(tokens):
        replace_token(token_list[i1 + j], 'killed', '')
        j += 1
    # Replace the node.
        # new_node = ast.Str()
        # new_node.s = s
    replace_node(new_node, old_node)
    # Update the token.
        # token = token_list[i1]
    new_token.node = new_node
    # Update the token list.
    new_node.token_list = [token]
#@+node:ekr.20200209135643.1: *4* orange.clean_leo_nodes (black only)
def clean_leo_nodes(self):  # pragma: no cover (black)
    """
    Remove all blank lines before and after Leo @+node and @+others sentinels.
    
    This is a post pass, for last-minute cleanups.
    """

    def clean_before(i):
        """Replace blank lines before self.code_list[i] with a single newline."""
        i -= 1
        cleaned = 0
        while i > 0:
            t = self.code_list[i]
            i -= 1
            if t.kind == 'blank-lines':
                t.kind, t.value = 'killed', ''  # pragma: no cover (defensive)
            elif t.kind == 'line-end':
                if cleaned > 0:
                    t.kind, t.value = 'killed', ''  # pragma: no cover (defensive)
                cleaned += 1
            else:
                break

    def clean_after(i):
        """Replace blank lines after self.code_list[i] with a single newline."""
        i += 1
        cleaned = 0
        while i < len(self.code_list):
            t = self.code_list[i]
            i += 1
            if t.kind == 'blank-lines':
                t.kind, t.value = 'killed', ''  # pragma: no cover (defensive)
            elif t.kind == 'line-end':
                if cleaned > 0:
                    t.kind, t.value = 'killed', ''  # pragma: no cover (defensive)
                cleaned += 1
            else:
                break

    for i, t in enumerate(self.code_list):
        if t.kind == 'comment' and (
            self.node_pat.match(t.value) or
            self.at_others_pat.match(t.value)
        ):
            clean_before(i)
            clean_after(i)
#@+node:ekr.20200107165250.50: *4* orange.find_delims (never used)
def find_delims(self, tokens):
    """
    Compute the net number of each kind of delim in the given range of tokens.
    
    Return (curlies, parens, squares)
    """
    parens, curlies, squares = 0, 0, 0
    for token in tokens:
        value = token.value
        if token.kind == 'lt':
            assert value in '([{', f"Bad lt value: {token.kind} {value}"
            if value == '{':
                curlies += 1
            elif value == '(':
                parens += 1
            elif value == '[':
                squares += 1
        elif token.kind == 'rt':
            assert value in ')]}', f"Bad rt value: {token.kind} {value}"
            if value == ')':
                parens -= 1
            elif value == ']':
                squares -= 1
            elif value == '}':
                curlies += 1
    return curlies, parens, squares
#@+node:ekr.20200212072951.1: *4* TestOrange.test_bad_break
def test_bad_break(self):

    # From setup.py.
    # The total length of the ''' string should not affect line length.
    contents = r"""\
def get_semver(tag):
    if 1:
        print(
            '''*** Failed to parse Semantic Version from git tag '{0}'.
        Expecting tag name like '5.7b2', 'leo-4.9.12', 'v4.3' for releases.
        This version can't be uploaded to PyPi.org.'''.format(tag))
    return version
"""
    contents, tokens, tree = self.make_data(contents)
    # expected = self.blacken(contents).rstrip() + '\n'
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree)
    if results != expected:
        g.printObj(tokens)
        g.printObj(expected, tag='expected')
        g.printObj(results, tag='results')
        assert False
#@+node:ekr.20191114161840.1: *4* TR.diff
def diff(self, results_array):
    """
    Produce a diff of self.tokens vs self.results.
    
    The results array no longer exists, so this is a vestigial method.
    """
    import difflib
    import time
    ndiff = False
    if ndiff:
        # FAILS:
        #  File "C:\Users\edreamleo\Anaconda3\lib\difflib.py", line 1017, in _fancy_replace
        #  yield '  ' + aelt
        #  TypeError: can only concatenate str (not "tuple") to str
        results = results_array
        tokens = [(z.kind, z.value) for z in self.tokens]
        gen = difflib.ndiff(tokens, results)
    else:
        # Works.
        results = [f"{z.kind:>12}:{z.value}" for z in results_array]
        tokens =  [f"{z.kind:>12}:{z.value}" for z in self.tokens]
        gen = difflib.Differ().compare(tokens, results)
    t1 = time.process_time()
    diffs = list(gen)
    t2 = time.process_time()
    print(
        f"\nDiff: tokens: {len(tokens)}, results: {len(results)}, "
        f"{len(diffs)} diffs in {(t2-t1):4.2f} sec...")
    if len(diffs) < 1000:
        legend = '\n-: only in tokens, +: only in results, ?: not in either sequence!\n'
        heading = f"tx  rx  kind {'diff key kind:value':>15}"
        line    = f"=== === ==== {'===================':>15}"
        print(legend)
        print(heading)
        print(line)
        rx = tx = 0
        for i, z in enumerate(diffs):
            kind = z[0]
            if kind != '?': # A mystery.
                print(f"{tx:<3} {rx:<3} {kind!r:4} {truncate(z[1:], 80)!s}")
            if kind == ' ':
                rx, tx = rx + 1, tx + 1
            elif kind == '+':
                rx += 1
            elif kind == '-':
                tx += 1
        # print(line)
        # print(heading)
        # print(legend)
#@+node:ekr.20200729081221.1: *3* Re #1618: verbatim sentinels
#@+node:ekr.20200211190650.1: *4* TestOrange.test_verbatim_fail
def test_verbatim_fail(self):

    line_length = 40  # For testing.
    #
    # Warning: Do not put bare sentinel lines here!
    #          Doing so destroys leoAst.py!
    #
    contents = '''\
SENTverbatim
SENT+node:ekr.20090128083459.82: ADDED.
SENTverbatim
SENT@nobeautify

def run(self):
    if index2 is None: # <--- Essential
        g.es("No matching bracket.")  # #1447.
        return
SENTverbatim
SENT+node:ekr.20090128083459.82: *3* class g.PosList (deprecated)
class PosList(list):
SENTverbatim
    SENT+others
SENTverbatim
    SENT+node:ekr.20140531104908.17611: *4* PosList.ctor
    def __init__(self, c, aList=None):
        if aList is None:
            for p in c.all_positions():
                self.append(p.copy())
        else:  # <-------
            pass
'''
    contents = contents.replace('SENT', '#@')
    contents, tokens, tree = self.make_data(contents)
    expected = contents + '\n'
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    # Necessary.
    expected = expected.replace('#@verbatim\n', '').rstrip() + '\n'
    results = results.replace('#@verbatim\n', '')
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200728111825.1: *4* COPY (Don't Use!) at.putCodeLine (major change)
def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if 1: # New
        # First, see whether the line *might* look like a sentinel
        delim1 = at.startSentinelComment
        delim2 = at.endSentinelComment
        delims = (delim1, delim2)
        pat = re.compile(fr"{re.escape(delim1)}\s*@")
        if pat.match(s, k):
            if 0:
                # This will happen infrequently. Recalculate all patterns.
                x = FastAtRead(c=self.c, gnx2vnode={})
                patterns = x.get_patterns(delims)
                # See if the *entire line* matches any of the patterns.
                if any(z.match(s, i) for z in patterns):
                    g.trace('Add @verbatim', repr(line))
                    at.putSentinel('@verbatim')
            else: # Unpleasant: Escape everything that *might* be a sentinel.
                at.putSentinel('@verbatim')
    else:
        if g.match(s, k, at.startSentinelComment + '@'):
            at.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) > 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
#@+node:ekr.20191217092340.1: ** From leoAtFile.py
@nosearch
#@+node:ekr.20190111112432.1: *3* at.checkDirectory
def checkDirectory(self, directory):
    """Return True if directory exists or could be created."""
    at, c = self, self.c
    assert directory, g.callers()
    if g.os_path_exists(directory):
        return at.isWritable(directory)
    if c.config and c.config.create_nonexistent_directories:
        directory = c.expand_path_expression(directory)
        ok = g.makeAllNonExistentDirectories(directory)
        if not ok:
            g.error(f"did not create {directory}")
            return False
    return at.isWritable(directory)
#@+node:ekr.20190111111608.1: *3* at.checkPath
def checkPath(self, fileName):
    """Return True if we can write to the file's directory."""
    at = self
    assert g.os_path_isabs(fileName), (repr(fileName), g.callers())
    directory = g.os_path_dirname(fileName)
    if not at.checkDirectory(directory):
        return False
    if g.os_path_exists(fileName):
        return at.isWritable(fileName)
    return True
#@+node:ekr.20150602204757.1: *3* at.autoBeautify
def autoBeautify(self, p):
    """Auto beautify p's tree if allowed by settings and directives."""
    c = self.c
    try:
        if not p.isDirty():
            return
        if leoBeautify.should_kill_beautify(p):
            return
        if c.config.getBool('beautify-autobeautify'):
            leoBeautify.beautifyPythonTree(event={'c': c, 'p0': p.copy()})
    except Exception:
        g.es('unexpected exception')
        g.es_exception()
#@+node:ekr.20200108180111.1: ** From leoBeautify.py
#@+node:ekr.20190725154916.1: *3* class BlackCommand
class BlackCommand:
    """A class to run black on all Python @<file> nodes in c.p's tree."""

    # tag1 must be executable, and can't be pass.
    tag1 = "if 1: print('') # black-tag1:::"
    tag2 = ":::black-tag2"
    tag3 = "# black-tag3:::"

    def __init__(self, c):
        self.c = c
        self.wrapper = c.frame.body.wrapper
        self.reloadSettings()
    @others
#@+node:ekr.20190926105124.1: *4* black.reloadSettings
@nobeautify

def reloadSettings(self):
    c = self.c
    ### keep_comments = c.config.getBool('black-keep-comment-indentation', default=True)
    ### self.sanitizer = SyntaxSanitizer(c, keep_comments)
    self.line_length = c.config.getInt("black-line-length") or 88
    # This should be on a single line,
    # so the check-settings script in leoSettings.leo will see them.
    self.normalize_strings = c.config.getBool("black-string-normalization", default=False)
#@+node:ekr.20200103055140.1: *3* commands
#@+node:ekr.20190725154916.7: *4* black.blacken_node
def blacken_node(self, root, diff_flag, check_flag=False):
    """Run black on all Python @<file> nodes in root's tree."""
    c = self.c
    if not black or not root:
        return
    t1 = time.process_time()
    self.changed, self.errors, self.total = 0, 0, 0
    self.undo_type = 'blacken-node'
    self.blacken_node_helper(root, check_flag, diff_flag)
    t2 = time.process_time()
    if not g.unitTesting:
        print(
            f'{root.h}: scanned {self.total} node{g.plural(self.total)}, '
            f'changed {self.changed} node{g.plural(self.changed)}, '
            f'{self.errors} error{g.plural(self.errors)} '
            f'in {t2-t1:5.2f} sec.'
        )
    if self.changed or self.errors:
        c.redraw()
#@+node:ekr.20190726013924.1: *4* black.blacken_node_helper
def blacken_node_helper(self, p, check_flag, diff_flag):
    """
    blacken p.b, incrementing counts and stripping unnecessary blank lines.
    
    Return True if p.b was actually changed.
    """
    trace = 'black' in g.app.debug and not g.unitTesting
    if not should_beautify(p):
        return False
    c = self.c
    self.total += 1
    language = g.findLanguageDirectives(c, p)
    if language != 'python':
        g.trace(f"skipping node: {p.h}")
        return False
    body = p.b.rstrip() + '\n'
    comment_string, body2 = self.sanitizer.comment_leo_lines(p=p)
    try:
        # Support black, version 19.3b0.
        mode = black.FileMode()
        mode.line_length = self.line_length
        mode.string_normalization = self.normalize_strings
        # Note: format_str does not check parse trees,
        #       so in effect, it already runs in fast mode.
        body3 = black.format_str(body2, mode=mode)
    except IndentationError:
        g.warning(f"IndentationError: Can't blacken {p.h}")
        g.es_print(f"{p.h} will not be changed")
        g.printObj(body2, tag='Sanitized syntax')
        if g.unitTesting:
            raise
        p.setMarked()
        p.setDirty()
        return False
    except(SyntaxError, black.InvalidInput):
        g.warning(f"SyntaxError: Can't blacken {p.h}")
        g.es_print(f"{p.h} will not be changed")
        g.printObj(body2, tag='Sanitized syntax')
        if g.unitTesting:
            raise
        p.setMarked()
        p.setDirty()
        return False
    except Exception:
        g.warning(f"Unexpected exception: {p.h}")
        g.es_print(f"{p.h} will not be changed")
        g.printObj(body2, tag='Sanitized syntax')
        g.es_exception()
        if g.unitTesting:
            raise
        p.setMarked()
        p.setDirty()
        return False
    if trace:
        g.printObj(body2, tag='Sanitized syntax')
    result = self.sanitizer.uncomment_leo_lines(comment_string, p, body3)
    if check_flag or result == body:
        if not g.unitTesting:
            return False
    if diff_flag:
        print('=====', p.h)
        print(black.diff(body, result, "old", "new")[16:].rstrip()+'\n')
        return False
    # Update p.b and set undo params.
    self.changed += 1
    p.b = result
    c.frame.body.updateEditors()
    p.v.contentModified()
    c.undoer.setUndoTypingParams(p, 'blacken-node', oldText=body, newText=result)
    p.setDirty()
    return True
#@+node:ekr.20190729065756.1: *4* black.blacken_tree
def blacken_tree(self, root, diff_flag, check_flag=False):
    """Run black on all Python @<file> nodes in root's tree."""
    c = self.c
    if not black or not root:
        return
    t1 = time.process_time()
    self.changed, self.errors, self.total = 0, 0, 0
    undo_type = 'blacken-tree'
    bunch = c.undoer.beforeChangeTree(root)
    # Blacken *only* the selected tree.
    changed = False
    for p in root.self_and_subtree():
        if self.blacken_node_helper(p, check_flag, diff_flag):
            changed = True
    if changed:
        c.setChanged()
        c.undoer.afterChangeTree(root, undo_type, bunch)
    t2 = time.process_time()
    if not g.unitTesting:
        print(
            f'{root.h}: scanned {self.total} node{g.plural(self.total)}, '
            f'changed {self.changed} node{g.plural(self.changed)}, '
            f'{self.errors} error{g.plural(self.errors)} '
            f'in {t2-t1:5.2f} sec.'
        )
    if self.changed and not c.changed:
        c.setChanged()
    if self.changed or self.errors:
        c.redraw()
#@+node:ekr.20190830043650.1: *4* blacken-check-tree
@g.command('blkc')
@g.command('blacken-check-tree')
def blacken_check_tree(event):
    """
    Run black on all nodes of the selected tree, reporting only errors.
    """
    c = event.get('c')
    if not c:
        return
    if black:
        BlackCommand(c).blacken_tree(c.p, diff_flag=False, check_flag=True)
    else:
        g.es_print('can not import black')
#@+node:ekr.20190829163640.1: *4* blacken-diff-node
@g.command('blacken-diff-node')
def blacken_diff_node(event):
    """
    Run black on the selected node.
    """
    c = event.get('c')
    if not c:
        return
    if black:
        BlackCommand(c).blacken_node(c.p, diff_flag=True)
    else:
        g.es_print('can not import black')
#@+node:ekr.20190829163652.1: *4* blacken-diff-tree
@g.command('blkd')
@g.command('blacken-diff-tree')
def blacken_diff_tree(event):
    """
    Run black on all nodes of the selected tree,
    or the first @<file> node in an ancestor.
    """
    c = event.get('c')
    if not c:
        return
    if black:
        BlackCommand(c).blacken_tree(c.p, diff_flag=True)
    else:
        g.es_print('can not import black')
#@+node:ekr.20190725155006.1: *4* blacken-node
@g.command('blacken-node')
def blacken_node(event):
    """
    Run black on the selected node.
    """
    c = event.get('c')
    if not c:
        return
    if black:
        BlackCommand(c).blacken_node(c.p, diff_flag=False)
    else:
        g.es_print('can not import black')
#@+node:ekr.20190729105252.1: *4* blacken-tree
@g.command('blk')
@g.command('blacken-tree')
def blacken_tree(event):
    """
    Run black on all nodes of the selected tree,
    or the first @<file> node in an ancestor.
    """
    c = event.get('c')
    if not c:
        return
    if black:
        BlackCommand(c).blacken_tree(c.p, diff_flag=False)
    else:
        g.es_print('can not import black')
#@+node:ekr.20150528131012.5: *4* beautify-tree
@g.command('beautify-tree')
@g.command('pretty-print-tree')
def beautifyPythonTree(event):
    """Beautify all python files in the selected outline."""
    c = event.get('c')
    if c:
        PythonTokenBeautifier(c).beautify_tree(c.p)
#@+node:ekr.20150528131012.4: *4* beautify-node
@g.command('beautify-node')
@g.command('pretty-print-node')
def prettyPrintPythonNode(event):
    """Beautify a single Python node."""
    c = event.get('c')
    if c:
        PythonTokenBeautifier(c).beautify_node(c.p)
    
    
#@+node:ekr.20200108180155.1: *3* functions & tests
#@+node:ekr.20200110014220.2: *4* @@test leoBeautify.CPrettyPrinter
import leo.core.leoBeautify as leoBeautify
cpp = leoBeautify.CPrettyPrinter(c)
fn = 'c tokenize test'
p2 = g.findNodeInTree(c,p,fn)
assert p2,'not found: %s' % (fn)

if 1: # test of indent.
    # import os ; os.system('cls')
    cpp.indent(p2)
if 0: # test of tokenize.
    aList = cpp.tokenize(p2.b)
    assert(p2.b == ''.join(aList))
#@+node:ekr.20200110014220.3: *5* c tokenize test
@language c

static exit_values_ty indent_main_loop(void)
{
    codes_ty         hd_type         = code_eof;
    char           * t_ptr           = NULL;
    codes_ty         type_code       = start_token;
    exit_values_ty   file_exit_value = total_success;
    int              dec_ind         = 0; /* current indentation for declarations */

    BOOLEAN          scase           = false; /* true when we've just see a "case";
                                               * determines what to do with the
                                               * following colon */
    BOOLEAN          flushed_nl;              /* Used when buffering up comments to remember that
                                               * a newline was passed over */
    BOOLEAN          sp_sw           = false; /* true when in the expression part of if(...),
                                               * while(...), etc. */
    BOOLEAN          force_nl        = false;

    /* last_token_ends_sp: True if we have just encountered the end of an if (...),
     * etc. (i.e. the ')' of the if (...) was the last token).  The variable is
     * set to 2 in the middle of the main token reading loop and is decremented
     * at the beginning of the loop, so it will reach zero when the second token
     * after the ')' is read.
     */

    BOOLEAN          last_token_ends_sp = false;

    BOOLEAN          last_else = false; /* true if last keyword was an else */

    for (;;)
    {
        /* this is the main loop.  it will go until
         * we reach eof */

        BOOLEAN is_procname_definition;
        bb_code_ty can_break;

        if (type_code != newline)
        {
            can_break = parser_state_tos->can_break;
        }

        parser_state_tos->last_saw_nl = false;
        parser_state_tos->can_break = bb_none;

        type_code = lexi ();    /* lexi reads one token.  "token" points to
                                 * the actual characters. lexi returns a code
                                 * indicating the type of token */

        /* If the last time around we output an identifier or
         * a paren, then consider breaking the line here if it's
         * too long.
         *
         * A similar check is performed at the end of the loop, after
         * we've put the token on the line. */

        if ((settings.max_col > 0) &&
            (buf_break != NULL) &&
            ( ( (parser_state_tos->last_token == ident) &&
                (type_code != comma) &&
                (type_code != semicolon) &&
                (type_code != newline) &&
                (type_code != form_feed) &&
                (type_code != rparen) &&
                (type_code != struct_delim)) ||
              ( (parser_state_tos->last_token == rparen) &&
                (type_code != comma) &&
                (type_code != rparen) ) ) &&
            (output_line_length () > settings.max_col))
        {
            break_line = 1;
        }

        if (last_token_ends_sp > 0)
        {
            last_token_ends_sp--;
        }

        is_procname_definition =
                (((parser_state_tos->procname[0] != '\0') &&
                  parser_state_tos->in_parameter_declaration) ||
                 (parser_state_tos->classname[0] != '\0'));

        /* The following code moves everything following an if (), while (),
         * else, etc. up to the start of the following stmt to a buffer. This
         * allows proper handling of both kinds of brace placement.
         */

        flushed_nl = false;

        if (!search_brace(&type_code, &force_nl, &flushed_nl, &last_else, &is_procname_definition))
        {
            /* Hit EOF unexpectedly in comment. */
            return indent_punt;
        }
        
        if (type_code == code_eof)
        {
            /* we got eof */
            if (s_lab != e_lab || s_code != e_code || s_com != e_com)   /* must dump end of line */
            {
                dump_line(true, &paren_target);
            }

            if (parser_state_tos->tos > 1)      /* check for balanced braces */
            {
                ERROR (_("Unexpected end of file"), 0, 0);
                file_exit_value = indent_error;
            }

            if (settings.verbose)
            {
                printf (_("There were %d non-blank output lines and %d comments\n"),
                        (int) out_lines, (int) com_lines);
                if (com_lines > 0 && code_lines > 0)
                {
                    printf (_("(Lines with comments)/(Lines with code): %6.3f\n"),
                            (1.0 * com_lines) / code_lines);
                }
            }
            flush_output ();

            return file_exit_value;                                              /* RETURN */
        }

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            if (force_nl &&
                (type_code != semicolon) &&
                ( (type_code != lbrace) ||
                  (!parser_state_tos->in_decl && !settings.btype_2) ||
                  (parser_state_tos->in_decl && !settings.braces_on_struct_decl_line) ||
                  (parser_state_tos->last_token == rbrace)))
            {
                if (settings.verbose && !flushed_nl)
                {
                    WARNING (_("Line broken 2"), 0, 0);
                }

                flushed_nl = false;
                dump_line(true, &paren_target);
                parser_state_tos->want_blank = false;
                force_nl = false;
            }

            parser_state_tos->in_stmt = true;   /* turn on flag which causes
                                                 * an extra level of
                                                 * indentation. this is
                                                 * turned off by a ; or } */
            if (s_com != e_com)
            {
                /* the code has an embedded comment in the
                 * line. Move it from the com buffer to the
                 * code buffer.
                 *
                 * Do not add a space before the comment if it is the first
                 * thing on the line.
                 */

                if (e_code != s_code)
                {
                    set_buf_break (bb_embedded_comment_start, paren_target);
                    *e_code++ = ' ';
                    embedded_comment_on_line = 2;
                }
                else
                {
                    embedded_comment_on_line = 1;
                }

                for (t_ptr = s_com; *t_ptr; ++t_ptr)
                {
                    check_code_size();
                    *e_code++ = *t_ptr;
                }

                set_buf_break (bb_embedded_comment_end, paren_target);
                *e_code++ = ' ';
                *e_code = '\0'; /* null terminate code sect */
                parser_state_tos->want_blank = false;
                e_com = s_com;
            }
        }
        else if ((type_code != comment) &&
                 (type_code != cplus_comment) &&
                 !(settings.break_function_decl_args &&
                   (parser_state_tos->last_token == comma)) &&
                 !( (parser_state_tos->last_token == comma) &&
                    !settings.leave_comma))
        {
            /* preserve force_nl thru a comment but
             * cancel forced newline after newline, form feed, etc.
             * however, don't cancel if last thing seen was comma-newline
             * and -bc flag is on. */

            force_nl = false;
        }

        /* Main switch on type of token scanned */

        check_code_size();
        
        /* now, decide what to do with the token */

        handle_the_token(type_code, &scase, &force_nl, &sp_sw, &flushed_nl,
                         &hd_type, &dec_ind, &last_token_ends_sp, &file_exit_value,
                         can_break, &last_else, is_procname_definition);
        
        *e_code = '\0';         /* make sure code section is null terminated */

        if ((type_code != comment) &&
            (type_code != cplus_comment) &&
            (type_code != newline) &&
            (type_code != preesc) &&
            (type_code != form_feed))
        {
            parser_state_tos->last_token = type_code;
        }

        /* Now that we've put the token on the line (in most cases),
         * consider breaking the line because it's too long.
         *
         * Don't consider the cases of `unary_op', newlines,
         * declaration types (int, etc.), if, while, for,
         * identifiers (handled at the beginning of the loop),
         * periods, or preprocessor commands. */

        if ((settings.max_col > 0) && (buf_break != NULL))
        {
            if ( ( (type_code == binary_op) ||
                   (type_code == postop) ||
                   (type_code == question) ||
                   ((type_code == colon) && (scase || (squest <= 0))) ||
                   (type_code == semicolon) ||
                   (type_code == sp_nparen) ||
                   (type_code == sp_else) ||
                   ((type_code == ident) && (*token == '\"')) ||
                   (type_code == struct_delim) ||
                   (type_code == comma)) &&
                 (output_line_length () > settings.max_col))
            {
                break_line = 1;
            }
        }
    }                           /* end of main infinite loop */
}
#@+node:ekr.20200110014220.4: *4* @@test SyntaxSanitizer
from leo.core.leoBeautify import  SyntaxSanitizer
for child in p.subtree():
    child_s = child.b
    for keep in (True, False):
        # Setup.
        sanitizer = SyntaxSanitizer(c, keep)
        comment, result1 = sanitizer.comment_leo_lines(child)
        # Test basic round-tripping.
        result2 = sanitizer.uncomment_leo_lines(comment, child, s0=result1)
        assert child_s.rstrip() == result2.rstrip(), (
            f"Round-trip FAIL: keep: {keep}, {child.h}\n"
            f"{g.objToString(child_s, tag='child_s')}\n"
            f"{g.objToString(result1, tag='result1')}\n"
            f"{g.objToString(result2, tag='result2')}")
#@+node:ekr.20200110014220.5: *5* basic test
@language python
@
This is a doc part.
@c

def spam():
    if 1:
        # Regular comment.
        print('-----')
            # Indented comment.
    else:
        pass
#@+node:ekr.20200110014220.6: *5* @others & sections references
a = 1
<< section ref >>
b = 2

if 1:
    @others

# Note: section references will fail in if statements, because pass is not valid there:
    
    # if (
        # <section ref>
    # ):
        # pass
#@+node:ekr.20200110014220.7: *5* fast_at.scan_lines
@language python

def scan_lines(self, delims, first_lines, lines, path, start, test=False):
    '''Scan all lines of the file, creating vnodes.'''
    << init scan_lines >>
    << define dump_v >>
    i = 0 # To keep pylint happy.
    for i, line in enumerate(lines[start:]):
        # Order matters.
        << 1. common code for all lines >>
        << 2. short-circuit later tests >>
        << 3. handle @others >> # clears in_doc
        << 4. handle section refs >> # clears in_doc.
        # Order doesn't matter, but match more common sentinels first.
        << handle node_start >>
        << handle end of @doc & @code parts >>
        << handle @all >>
        << handle afterref >>
        << handle @first and @last >>
        << handle @comment >>
        << handle @delims >>
        << handle @raw >>
        << handle @-leo >>
        # These must be last, in this order.
        << Last 1. handle remaining @@ lines >>
        << Last 2. handle remaining @doc lines >>
        << Last 3. handle remaining @ lines >>
    else:
        # No @-leo sentinel
        return None, []
    # Handle @last lines.
    last_lines = lines[start+i:]
    if last_lines:
        last_lines = ['@last ' + z for z in last_lines]
        gnx2body[root_gnx] = gnx2body[root_gnx] + last_lines
    self.post_pass(gnx2body, gnx2vnode, root_v)
    return root_v, last_lines
#@+node:ekr.20200110014220.8: *6* << init scan_lines >>
#
# Simple vars...
afterref = False
    # A special verbatim line follows @afterref.
clone_v = None
    # The root of the clone tree.
    # When not None, we are scanning a clone and all it's descendants.
delim_start, delim_end = delims
    # The start/end delims.
doc_skip = (delim_start + '\n', delim_end + '\n')
    # To handle doc parts.
first_i = 0
    # Index into first array.
in_doc = False
    # True: in @doc parts.
in_raw = False
    # True: @raw seen.
is_cweb = delim_start == '@q@' and delim_end == '@>'
    # True: cweb hack in effect.
indent = 0 
    # The current indentation.
level_stack = []
    # Entries are (vnode, in_clone_tree)
n_last_lines = 0
    # The number of @@last directives seen.
root_seen = False
    # False: The next +@node sentinel denotes the root, regardless of gnx.
    # Needed to handle #1065 so reads will not create spurious child nodes.
sentinel = delim_start + '@'
    # Faster than a regex!
stack = []
    # Entries are (gnx, indent, body)
    # Updated when at+others, at+<section>, or at+all is seen.
verbline = delim_start + '@verbatim' + delim_end + '\n'
    # The spelling of at-verbatim sentinel
verbatim = False
    # True: the next line must be added without change.
#
# Init the data for the root node.
#

#
# Init the parent vnode for testing.
#
if self.test:
    root_gnx = gnx = 'root-gnx'
        # The node that we are reading.
        # start with the gnx for the @file node.
    gnx_head =  '<hidden top vnode>'
        # The headline of the root node.
    context = None
    parent_v = self.VNode(context=context, gnx=gnx)
    parent_v._headString = gnx_head
        # Corresponds to the @files node itself.
else:
    # Production.
    root_gnx = gnx = self.root.gnx
    context = self.c
    parent_v = self.root.v
root_v = parent_v
    # Does not change.
level_stack.append((root_v, False),)
#
# Init the gnx dict last.
#
gnx2vnode = self.gnx2vnode
    # Keys are gnx's, values are vnodes.
gnx2body = {}
    # Keys are gnxs, values are list of body lines.
gnx2vnode[gnx] = parent_v
    # Add gnx to the keys
gnx2body[gnx] = body = first_lines
    # Add gnx to the keys.
    # Body is the list of lines presently being accumulated.
#
# get the patterns.
after_pat, all_pat, code_pat, comment_pat, delims_pat,\
doc_pat, end_raw_pat, first_pat, last_pat, \
node_start_pat, others_pat, raw_pat, ref_pat = self.get_patterns(delims)
#@+node:ekr.20200110014220.9: *6* << define dump_v >>
def dump_v():
    '''Dump the level stack and v.'''
    print('----- LEVEL', level, v.h)
    print('       PARENT', parent_v.h)
    print('[')
    for i, data in enumerate(level_stack):
        v2, in_tree = data
        print('%2s %5s %s' % (i+1, in_tree, v2.h))
    print(']')
    print('PARENT.CHILDREN...')
    g.printObj([v3.h for v3 in parent_v.children])
    print('PARENTS...')
    g.printObj([v4.h for v4 in v.parents])
#@+node:ekr.20200110014220.10: *6* << 1. common code for all lines >>
if verbatim:
    # We are in raw mode, or other special situation.
    # Previous line was verbatim sentinel. Append this line as it is.
    if afterref:
        afterref = False
        if body: # a List of lines.
            body[-1] = body[-1].rstrip() + line
        else:
            body = [line]
        verbatim = False
    elif in_raw:
        m = end_raw_pat.match(line)
        if m:
            in_raw = False
            verbatim = False
        else:
             body.append(line)
             # Continue verbatim/raw mode.
    else:
        body.append(line)
        verbatim = False
    continue
if line == verbline: # <delim>@verbatim.
    verbatim = True
    continue
#
# Strip the line only once.
strip_line = line.strip()
#
# Undo the cweb hack.
if is_cweb and line.startswith(sentinel):
    line = line[:len(sentinel)] + line[len(sentinel):].replace('@@', '@')
# Adjust indentation.
if indent and line[:indent].isspace() and len(line) > indent:
    line = line[indent:]
#@+node:ekr.20200110014220.11: *6* << 2. short-circuit later tests >>
# This is valid because all following sections are either:
# 1. guarded by 'if in_doc' or
# 2. guarded by a pattern that matches the start of the sentinel.   
#
if not in_doc and not strip_line.startswith(sentinel):
    # lstrip() is faster than using a regex!
    body.append(line)
    continue
#@+node:ekr.20200110014220.12: *6* << 3. handle @others >>
m = others_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+': # opening sentinel
        body.append('%s@others%s\n' % (m.group(1), m.group(3) or ''))
        stack.append((gnx, indent, body))
        indent += m.end(1) # adjust current identation
    else: # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
#@+node:ekr.20200110014220.13: *6* << 4. handle section refs >>
m = ref_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':
        # open sentinel.
        body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
        stack.append((gnx, indent, body))
        indent += m.end(1)
    else:
        # close sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
#@+node:ekr.20200110014220.14: *6* << handle node_start >>
m = node_start_pat.match(line)
if m:
    in_doc, in_raw = False, False
    gnx, head = m.group(2), m.group(5)
    level = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
        # m.group(3) is the level number, m.group(4) is the number of stars.
    v = gnx2vnode.get(gnx)
    #
    # Case 1: The root @file node. Don't change the headline.
    if not root_seen:
        # Fix #1064: The node represents the root, regardless of the gnx!
        root_seen = True
        clone_v = None
        gnx2body[gnx] = body = []
        if not v:
            # Fix #1064.
            v = root_v
            # This message is annoying when using git-diff.
                # if gnx != root_gnx:
                    # g.es_print("using gnx from external file: %s" % (v.h), color='blue')
            gnx2vnode [gnx] = v
            v.fileIndex = gnx
        v.children = []
        continue
    #
    # Case 2: We are scanning the descendants of a clone.
    parent_v, clone_v = level_stack[level-2]
    if v and clone_v:
        # The last version of the body and headline wins..
        gnx2body[gnx] = body = []
        v._headString = head
        # Update the level_stack.
        level_stack = level_stack[:level-1]
        level_stack.append((v, clone_v),)
        # Always clear the children!
        v.children=[]
        parent_v.children.append(v)
        continue
    #
    # Case 3: we are not already scanning the descendants of a clone.
    if v:
        # The *start* of a clone tree. Reset the children.
        clone_v = v
        v.children = []
    else:
        # Make a new vnode.
        v = self.VNode(context=context, gnx=gnx)
    #
    # The last version of the body and headline wins.
    gnx2vnode[gnx] = v
    gnx2body[gnx] = body = []
    v._headString = head
    #
    # Update the stack.
    level_stack = level_stack[:level-1]
    level_stack.append((v, clone_v),)
    #
    # Update the links.
    assert v != root_v
    parent_v.children.append(v)
    v.parents.append(parent_v)
    # dump_v()
    continue
#@+node:ekr.20200110014220.15: *6* << handle end of @doc & @code parts >>
if in_doc:
    # When delim_end exists the doc block:
    # - begins with the opening delim, alonw on its own line
    # - ends with the closing delim, alone on its own line.
    # Both of these lines should be skipped
    if line in doc_skip:
        # doc_skip is (delim_start + '\n', delim_end + '\n')
        continue
    #
    # Check for @c or @code.
    m = code_pat.match(line)
    if m:
        in_doc = False 
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
else:
    m = doc_pat.match(line)
    if m:
        # @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or '' # Trailing text.
        if doc2:
            body.append('%s%s\n'%(doc, doc2))
        else:
            body.append(doc + '\n')
        # Enter @doc mode.
        in_doc = True
        continue
#@+node:ekr.20200110014220.16: *6* << handle @all >>
m = all_pat.match(line)
if m:
    # @all tells Leo's *write* code not to check for undefined sections.
    # Here, in the read code, we merely need to add it to the body.
    # Pushing and popping the stack may not be necessary, but it can't hurt.
    if m.group(2) == '+': # opening sentinel
        body.append('%s@all%s\n' % (m.group(1), m.group(3) or ''))
        stack.append((gnx, indent, body))
    else: # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        gnx2body[gnx] = body
    continue
#@+node:ekr.20200110014220.17: *6* << handle afterref >>
m = after_pat.match(line)
if m:
    afterref = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
#@+node:ekr.20200110014220.18: *6* << handle @first and @last >>
m = first_pat.match(line)
if m:
    if 0 <= first_i < len(first_lines):
        body.append('@first ' + first_lines[first_i])
        first_i += 1
    else:
        g.trace('\ntoo many @first lines: %s' %  path)
        print('@first is valid only at the start of @<file> nodes\n')
        g.printObj(first_lines, tag='first_lines')
        g.printObj(lines[start:i+2], tag='lines[start:i+2]')
    continue
m = last_pat.match(line)
if m:
    n_last_lines += 1
    continue
#@+node:ekr.20200110014220.19: *6* << handle @comment >>
# http://leoeditor.com/directives.html#part-4-dangerous-directives
m = comment_pat.match(line)
if m:
    # <1, 2 or 3 comment delims>
    delims = m.group(1).strip()
    # Whatever happens, retain the @delims line.
    body.append('@comment %s\n' % delims)
    delim1, delim2, delim3 = g.set_delims_from_string(delims)
        # delim1 is always the single-line delimiter.
    if delim1:
        delim_start, delim_end = delim1, ''
    else:
        delim_start, delim_end = delim2, delim3
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__','\n').replace('_',' ')
    delim_end = delim_end.replace('__','\n').replace('_',' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@>'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns.
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
#@+node:ekr.20200110014220.20: *6* << handle @delims >>
m = delims_pat.match(line)
if m:
    # Get 1 or 2 comment delims
    # Whatever happens, retain the original @delims line.
    delims = m.group(1).strip()
    body.append('@delims %s\n' % delims)
    #
    # Parse the delims.
    delims_pat = re.compile(r'^([^ ]+)\s*([^ ]+)?')
    m2 = delims_pat.match(delims)
    if not m2:
        g.trace('Ignoring invalid @comment: %r' % line)
        continue
    delim_start = m2.group(1)
    delim_end = m2.group(2) or ''
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__','\n').replace('_',' ')
    delim_end = delim_end.replace('__','\n').replace('_',' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@>'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
#@+node:ekr.20200110014220.21: *6* << handle @raw >>
# http://leoeditor.com/directives.html#part-4-dangerous-directives
m = raw_pat.match(line)
if m:
    in_raw = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
#@+node:ekr.20200110014220.22: *6* << handle @-leo >>
if line.startswith(delim_start + '@-leo'):
    i += 1
    break
#@+node:ekr.20200110014220.23: *6* << Last 1. handle remaining @@ lines >>
# @first, @last, @delims and @comment generate @@ sentinels,
# So this must follow all of those.
if line.startswith(delim_start + '@@'):
    ii = len(delim_start) + 1 # on second '@'
    jj = line.rfind(delim_end) if delim_end else -1
    body.append(line[ii:jj] + '\n')
    continue
#@+node:ekr.20200110014220.24: *6* << Last 2. handle remaining @doc lines >>
if in_doc:
    if delim_end:
        # doc lines are unchanged.
        body.append(line)
    else:
        # Doc lines start with start_delim + one blank.
        body.append(line[len(delim_start)+1:])
    continue
#@+node:ekr.20200110014220.25: *6* << Last 3. handle remaining @ lines >>
# Handle an apparent sentinel line.
# This *can* happen, as the result of the git-diff command.
#
# This assert verifies the short-circuit test.
assert strip_line.startswith(sentinel), (repr(sentinel), repr(line))
#
# This trace is less important, but interesting.
g.trace(f"{g.shortFileName(self.path)}: unexpected line: {line.strip()!r}")
body.append(line)
#@+node:ekr.20150530061745.1: *4* function: main & helpers
def main():
    """External entry point for Leo's beautifier."""
    t1 = time.process_time()
    base = g.os_path_abspath(os.curdir)
    files, options = scan_options()
    for path in files:
        path = g.os_path_finalize_join(base, path)
        beautify(options, path)
    print(f'beautified {len(files)} files in {time.process_time()-t1:4.2f} sec.')
#@+node:ekr.20150601170125.1: *5* beautify (stand alone)
def beautify(options, path):
    """Beautify the file with the given path."""
    fn = g.shortFileName(path)
    s, e = g.readFileIntoString(path)
    if not s:
        return
    print(f"beautifying {fn}")
    try:
        s1 = g.toEncodedString(s)
        node1 = ast.parse(s1, filename='before', mode='exec')
    except IndentationError:
        g.warning(f"IndentationError: can't check {fn}")
        return
    except SyntaxError:
        g.warning(f"SyntaxError: can't check {fn}")
        return
    readlines = g.ReadLinesClass(s).next
    tokens = list(tokenize.generate_tokens(readlines))
    x = PythonTokenBeautifier(c=None)
    # Compute the tokens.
    s2 = x.scan_all_tokens(s, tokens)
    try:
        s2_e = g.toEncodedString(s2)
        node2 = ast.parse(s2_e, filename='before', mode='exec')
    except IndentationError:
        g.warning(f"{fn}: IndentationError in result")
        g.es_print(f"{fn} will not be changed")
        g.printObj(s2, tag='RESULT')
        return
    except SyntaxError:
        g.warning(f"{fn}: Syntax error in result")
        g.es_print(f"{fn} will not be changed")
        g.printObj(s2, tag='RESULT')
        return
    except Exception:
        g.warning(f"{fn}: Unexpected exception creating the \"after\" parse tree")
        g.es_print(f"{fn} will not be changed")
        g.es_exception()
        g.printObj(s2, tag='RESULT')
        return
    ok = leoAst.compare_asts(node1, node2)
    if not ok:
        print(f"failed to beautify {fn}")
        return
    with open(path, 'wb') as f:
        f.write(s2_e)
#@+node:ekr.20150601162203.1: *5* scan_options (stand alone)
def scan_options():
    """Handle all options. Return a list of files."""
    # This automatically implements the --help option.
    usage = "usage: python -m leo.core.leoBeautify file1, file2, ..."
    parser = optparse.OptionParser(usage=usage)
    add = parser.add_option
    add(
        '-d',
        '--debug',
        action='store_true',
        dest='debug',
        help='print the list of files and exit',
    )
    # add('-k', '--keep-blank-lines', action='store_true', dest='keep',
        # help='keep-blank-lines')
    # Parse the options.
    options, files = parser.parse_args()
    if options.debug:
        # Print the list of files and exit.
        g.trace('files...', files)
        sys.exit(0)
    return files, options
#@+node:ekr.20191028141311.1: *4* test_FstringifyTokens
def test_FstringifyTokens(c, contents,
    dump=True,
    dump_input_tokens=False,
    dump_output_tokens=False,
):
    # pylint: disable=import-self
    import tokenize
    import leo.core.leoBeautify as leoBeautify
    # Tokenize.
    tokens = list(tokenize.tokenize(io.BytesIO(contents.encode('utf-8')).readline))
    # Create a list of input tokens (BeautifierTokens).
    x = leoBeautify.FstringifyTokens(c)
    x.dump_input_tokens = dump_input_tokens
    x.dump_output_tokens = dump_output_tokens
    # Scan the input tokens, creating, a string.
    results = x.scan_all_tokens(contents, tokens)
    # Show results.
    print('')
    show(contents, 'Contents', dump=dump)
    print('')
    show(results, 'Results', dump=dump)
#@+node:ekr.20191028140946.1: *4* test_NullTokenBeautifier
def test_NullTokenBeautifier(c, contents,
    dump=True,
    dump_input_tokens=False,
    dump_output_tokens=False,
):

    # pylint: disable=import-self
    import tokenize
    import leo.core.leoBeautify as leoBeautify
    # Tokenize.
    tokens = list(tokenize.tokenize(io.BytesIO(contents.encode('utf-8')).readline))
    # Untokenize.
    x = leoBeautify.NullTokenBeautifier(c)
    x.dump_input_tokens = dump_input_tokens
    x.dump_output_tokens = dump_output_tokens
    results = x.scan_all_tokens(contents, tokens)
    # Show results.
    show(contents, 'Contents', dump=dump)
    print('')
    show(results, 'Results', dump=dump)
    return contents == results
#@+node:ekr.20191029184028.1: *4* test_PythonTokenBeautifier
def test_PythonTokenBeautifier(c, contents,
    dump=True,
    dump_input_tokens=False,
    dump_output_tokens=False,
):

    # pylint: disable=import-self
    import tokenize
    import leo.core.leoBeautify as leoBeautify
    # Create 5-tuples.
    tokens = list(tokenize.tokenize(io.BytesIO(contents.encode('utf-8')).readline))
    # Beautify.
    x = leoBeautify.PythonTokenBeautifier(c)
    x.dump_input_tokens = dump_input_tokens
    x.dump_output_tokens = dump_output_tokens
    results = x.scan_all_tokens(contents, tokens)
    # Show results.
    print('')
    show(contents, 'Contents', dump)
    print('')
    show(results, 'Results', dump)
    return results.strip() == contents.strip()
#@+node:ekr.20200110015014.2: *4* These tests use only python's tokenize module
#@+node:ekr.20200110015014.3: *5* @@test bad input order 
from tokenize import Untokenizer
u = Untokenizer()
u.prev_row = 2
u.prev_col = 2
with self.assertRaises(ValueError) as cm:
    u.add_whitespace((1,3))
self.assertEqual(cm.exception.args[0],
    'start (1,3) precedes previous end (2,2)')
# raise if previous column in row
self.assertRaises(ValueError, u.add_whitespace, (2,1))
#@+node:ekr.20200110015014.4: *5* @@test backslash continuation
from tokenize import Untokenizer
import test.test_tokenize as tt
u = Untokenizer()
u.prev_row = 1
u.prev_col =  1
u.tokens = []
u.add_whitespace((2, 0))
self.assertEqual(u.tokens, ['\\\n'])
u.prev_row = 2
u.add_whitespace((4, 4))
self.assertEqual(u.tokens, ['\\\n', '\\\n\\\n', '    '])
tt.TestRoundtrip.check_roundtrip(self, 'a\n  b\n    c\n  \\\n  c\n')
#@+node:ekr.20200110015014.5: *5* @@test iter compat
from tokenize import untokenize, Untokenizer, NAME, ENCODING

u = Untokenizer()
token = (NAME, 'Hello')
tokens = [(ENCODING, 'utf-8'), token]
u.compat(token, iter([]))
self.assertEqual(u.tokens, ["Hello "])
u = Untokenizer()
self.assertEqual(u.untokenize(iter([token])), 'Hello ')
u = Untokenizer()
self.assertEqual(u.untokenize(iter(tokens)), 'Hello ')
self.assertEqual(u.encoding, 'utf-8')
self.assertEqual(untokenize(iter(tokens)), b'Hello ')
    # *not* u.untokenize.
#@+node:ekr.20200726083127.1: *3* class FStringifyTokens(NullTokenBeautifier)
class FstringifyTokens(NullTokenBeautifier):
    """A token-based tool that converts strings containing % to f-strings."""

    undo_type = "Fstringify"

    def __init__(self, c):
        super().__init__(c)
        self.ws = ''
        self.sanitizer = SyntaxSanitizer(c, keep_comments=True)

    @others
#@+node:ekr.20200726083127.2: *4* fstring.error
def error(self, message):

    if not g.unitTesting:
        g.es_print('')
        g.es_print(f"line {self.line_number}: {message}:")
        g.es_print(self.line.strip())
#@+node:ekr.20200726083127.3: *4* fstring: Conversion
#@+node:ekr.20200726083127.4: *5* fstring.check_newlines
def check_newlines(self, tokens):
    """
    Check to ensure that no newlines appear within { and }.
    
    Return False if there is an error
    """
    level = 0
    for token in tokens:
        kind, val = token.kind, token.value
        if kind == 'op':
            if val == '{':
                level += 1
            elif val == '}':
                level -= 1
                if level < 0:
                    self.error('curly bracket underflow')
                    return False
        if '\\n' in val and level > 0:
            self.error('f-expression would contain a backslash')
            return False
    if level > 0:
        self.error('unclosed curly bracket')
        return False
    return True
#@+node:ekr.20200726083127.5: *5* fstring.clean_ws
ws_pat = re.compile(r'(\s+)([:!][0-9]\})')

def clean_ws(self, s):
    """Carefully remove whitespace before ! and : specifiers."""
    s = re.sub(self.ws_pat, r'\2', s)
    return s
#@+node:ekr.20200726083127.6: *5* fstring.compute_result
def compute_result(self, string_val, results_list):
    """
    Create the final result as follows:
        
    1. Flatten the results array.
    
    2. Using string_val (the original string) compute whether to use single
       or double quotes for the outer fstring.
    
    3. Beautify the result using the PythonTokenBeautifier class.
    
    Return the result string, or None if there are errors.
    """
    trace = False and not g.unitTesting
    # pylint: disable=import-self
    import leo.core.leoBeautify as leoBeautify
    c = self.c
    #
    # Flatten the token list.
    if trace: g.printObj(results_list, tag='TOKENS 1')
    tokens = []
    ### To do: define "flatten" helper.
    for z in results_list:
        if isinstance(z, (list, tuple)):
            tokens.extend(z)
        else:
            tokens.append(z)
    if trace: g.printObj(tokens, tag='TOKENS 2')
    #
    # Fail if the result would include a backslash within { and }.
    if not self.check_newlines(tokens):
        return None
    #
    # Ensure consistent quotes.
    ok = self.change_quotes(string_val, tokens)
    if not ok:
        if not g.unitTesting:
            self.error('string contains backslashes')
        return None
    #
    # Ensure one blank after the f-string.
    ### Doesn't work well.
    # tokens.append(self.new_token('fstringify', ' '))
    #
    # Use ptb to clean up inter-token whitespace.
    if trace: g.printObj(tokens, tag='TOKENS: before ptb')
    x = leoBeautify.PythonTokenBeautifier(c)
    x.dump_input_tokens = True
    x.dump_output_tokens = True
    result_tokens = x.scan_all_beautifier_tokens(tokens)
    #
    # Create the result.
    if trace: g.printObj(result_tokens, tag='TOKENS: after ptb')
    result = ''.join([z.to_string() for z in result_tokens])
    # Ensure a space between the new fstring and a previous name.
    if self.prev_token.kind == 'name':
        result = ' ' + result
    if self.add_trailing_ws:
        result = result + ' '
    return result
#@+node:ekr.20200726083127.7: *5* fstring.convert_fstring
def convert_fstring(self):
    """
    Scan a string, converting it to an f-string.
    The 'string' token has already been consumed.
    """
    new_token = self.new_token
    string_val = self.val
    self.add_trailing_ws = False
    specs = self.scan_format_string(string_val)
    values, tokens = self.scan_for_values()
    if len(specs) != len(values):
        self.error('Scanning error')
        g.trace('\nMISMATCH\n')
        g.trace('specs:', len(specs), 'values', len(values))
        g.printObj(specs, tag='SPECS')
        g.printObj(values, tag='VALUES')
        # Punt, without popping any more tokens.
        self.add_token('string', string_val)
        return
    # Substitute the values.
    i, results = 0, [new_token('fstringify', 'f')]
    for spec_i, m in enumerate(specs):
        value = values[spec_i]
        start, end, spec = m.start(0), m.end(0), m.group(1)
        if start > i:
            results.append(new_token('fstringify', string_val[i : start]))
        head, tail = self.munge_spec(spec)
        results.append(new_token('op', '{'))
        results.append(new_token('fstringify', value))
        if head:
            results.append(new_token('fstringify', '!'))
            results.append(new_token('fstringify', head))
        if tail:
            results.append(new_token('fstringify', ':'))
            results.append(new_token('fstringify', tail))
        results.append(new_token('op', '}'))
        i = end
    # Add the tail.
    tail = string_val[i:]
    if tail:
        results.append(new_token('fstringify', tail))
    result = self.compute_result(string_val, results)
    if result:
        # Remove whitespace before ! and :.
        result = self.clean_ws(result)
        # Actually consume the scanned tokens.
        for token in tokens:
            self.tokens.pop(0)
        self.add_token('string', result)
    else:
        # Punt, without popping any more tokens.
        self.add_token('string', string_val)
#@+node:ekr.20200726083127.8: *5* fstring.munge_spec
def munge_spec(self, spec):
    """
    Return (head, tail).
    
    The format is spec !head:tail or :tail
    
    Example specs: s2, r3
    """
    ### To do: handle more specs.
    head, tail = [], []
    if spec.startswith('+'):
        pass # Leave it alone!
    elif spec.startswith('-'):
        tail.append('>')
        spec = spec[1:]
    if spec.endswith('s'):
        spec = spec[:-1]
    if spec.endswith('r'):
        head.append('r')
        spec = spec[:-1]
    tail = ''.join(tail) + spec
    head = ''.join(head)
    return head, tail
#@+node:ekr.20200726083127.9: *5* fstring.change_quotes
def change_quotes(self, string_val, aList):
    """
    Carefully change quotes in all "inner" tokens as necessary.
    
    Return True if all went well.
    
    We expect the following "outer" tokens.
        
    aList[0]:  ('fstringify', 'f')
    aList[1]:  ('fstringify', a string starting with a quote)
    aList[-1]: ('fstringify', a string ending with a quote that matches aList[1])
    """
    # Sanity checks.
    if len(aList) < 4:
        return True
    if not string_val:
        g.es_print('no string_val!')
        return False
    delim = string_val[0]
    ### delim2 = '"' if delim == "'" else "'"
    #
    # Check tokens 0, 1 and -1.
    token0 = aList[0]
    token1 = aList[1]
    token_last = aList[-1]
    for token in token0, token1, token_last:
        if token.kind != 'fstringify':
            g.es_print(f"unexpected token: {token!r}")
            return False
    if token0.value != 'f':
        g.es_print('token[0] error!', repr(token0))
        return False
    val1 = token1.value and token1.value[0]
    if delim != val1:
        g.es_print('token[1] error!', delim, val1, repr(token1))
        return False
    val_last = token_last.value and token_last.value[-1]
    if delim != val_last:
        g.es_print('token[-1] error!', delim, val_last, repr(token_last))
        return False
    # g.printObj(aList)
    # Regularize the outer tokens.
    delim, delim2 = '"', "'"
    token1.value = delim + token1.value[1:]
    aList[1] = token1
    token_last.value = token_last.value[:-1] + delim
    aList[-1] = token_last
    #
    # Replace delim by delim2 in all inner tokens.
    for z in aList[2:-1]:
        ### g.trace(z)
        if not isinstance(z, BeautifierToken):
            g.es_print('Bad token:', repr(z))
            return False
        z.value = z.value.replace(delim, delim2)
    # g.printObj(aList)
    return True
#@+node:ekr.20200726083127.10: *5* fstring.scan_for_values
def scan_for_values(self):
    """
    Return a list of possibly parenthesized values for the format string.
    
    This method never actually consumes tokens.
    
    If all goes well, we'll skip all tokens in the tokens list.
    """
    # Skip the '%'
    new_token = self.new_token
    assert self.look_ahead(0) == ('op', '%')
    token_i, tokens = self.skip_ahead(0, 'op', '%')
    # Skip '(' if it's next
    include_paren = self.look_ahead(token_i) == ('op', '(')
    if include_paren:
        token_i, skipped_tokens = self.skip_ahead(token_i, 'op', '(')
        tokens.extend(skipped_tokens)
    # Find all tokens up to the first ')' or 'for'
    values, value_list = [], []
    while token_i < len(self.tokens):
        # Don't use look_ahead here: handle each token exactly once.
        token = self.tokens[token_i]
        token_i += 1
        tokens.append(token)
        kind, val = token.kind, token.value
        if kind == 'ws':
            continue
        if kind in ('newline', 'nl'):
            if include_paren or val.endswith('\\\n'):
                # Continue scanning, ignoring the newline.
                continue
            else:
                # The newline ends the scan.
                values.append(value_list)
                    # Retain the tokens!
                if not include_paren: # Bug fix.
                    tokens.pop()  # Rescan the ')'
                break
        if (kind, val) == ('op', ')'):
            values.append(value_list)
            if not include_paren:
                tokens.pop()  # Rescan the ')'
            break
        if (kind, val) == ('name', 'for'):
            self.add_trailing_ws = True
            tokens.pop()  # Rescan the 'for'
            values.append(value_list)
            break
        if (kind, val) == ('op', ','):
            values.append(value_list)
            value_list = []
        elif kind == 'op' and val in '([{':
            values_list2, token_i2 = self.scan_to_matching(token_i-1, val)
            value_list.extend(values_list2)
            tokens.extend(self.tokens[token_i : token_i2])
            token_i = token_i2
        elif kind == 'name':
            # Ensure separation of names.
            value_list.append(new_token(kind, val))
            value_list.append(new_token('ws', ' '))
        else:
            value_list.append(new_token(kind, val))
    return values, tokens
#@+node:ekr.20200726083127.11: *5* fstring.scan_format_string
# format_spec ::=  [[fill]align][sign][#][0][width][,][.precision][type]
# fill        ::=  <any character>
# align       ::=  "<" | ">" | "=" | "^"
# sign        ::=  "+" | "-" | " "
# width       ::=  integer
# precision   ::=  integer
# type        ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"

format_pat = re.compile(r'%(([+-]?[0-9]*(\.)?[0.9]*)*[bcdeEfFgGnoxrsX]?)')

def scan_format_string(self, s):
    """Scan the format string s, returning a list match objects."""
    result = list(re.finditer(self.format_pat, s))
    return result
#@+node:ekr.20200726083127.12: *5* fstring.scan_to_matching
def scan_to_matching(self, token_i, val):
    """
    self.tokens[token_i] represents an open (, [ or {.
    
    Return (values_list, token_i) of all tokens to the matching closing delim.
    """
    trace = False and not g.unitTesting
    new_token = self.new_token
    if trace:
        g.trace('=====', token_i, repr(val))
        g.trace(''.join([z.value for z in self.tokens[token_i:]]))
    values_list = []
    kind0, val0 = self.look_ahead(token_i)
    assert kind0 == 'op' and val0 == val and val in '([{', (kind0, val0)
    levels = [0, 0, 0]
    level_index = '([{'.index(val)
    levels[level_index] += 1
    # Move past the opening delim.
    values_list.append(new_token('op', val0))
    token_i += 1
    while token_i < len(self.tokens):
        # Don't use look_ahead here: handle each token exactly once.
        progress = token_i
        token = self.tokens[token_i]
        token_i += 1
        kind, val = token.kind, token.value
        if kind == 'ws':
            continue
        if kind in ('nl', 'newline'):
            continue
        if kind == 'op' and val in ')]}':
            values_list.append(new_token('op', val))
            level_index = ')]}'.index(val)
            levels[level_index] -= 1
            if levels == [0, 0, 0]:
                if trace:
                    g.printObj(values_list, tag=f"scan_to_matching {val!r}")
                return values_list, token_i
        elif kind == 'op' and val in '([{':
            # Recurse.
            values_list2, token_i = self.scan_to_matching(token_i-1, val)
            values_list.extend(values_list2)
        elif kind == 'name':
            # Ensure separation of names.
            values_list.append(new_token('name', val))
            values_list.append(new_token('ws', '  '))
        else:
            values_list.append(new_token(kind, val))
        assert token_i > progress, (kind, val)
    # Should never happen.
    g.trace(f"\nFAIL {token_i} {''.join(values_list)}\n")
    return [], token_i
#@+node:ekr.20200726083127.13: *4* fstring: Entries
#@+node:ekr.20200726083127.14: *5* fstring.fstringify_file
def fstringify_file(self):
    """
    Find the nearest @<file> node and convert % to fstrings within it.
    
    There is no need to sanitize code when converting an external file.
    """
    trace = True and not g.unitTesting
    verbose = False
    filename = self.find_root()
    if not filename:
        return
    # Open the file.
    with open(filename, 'r') as f:
        contents = f.read()
    if trace:
        g.trace(f"Contents...\n\n{contents}")
    # Generate tokens.
    tokens = self.tokenize_string(contents, filename)
    # Handle all tokens, creating the raw result.
    result = self.scan_all_tokens(contents, tokens)
    # Trace the results.
    changed = contents.rstrip() != result.rstrip()
    if trace and verbose:
        g.printObj(f"Code List...\n\n{self.code_list}")
    if trace:
        g.trace(f"Result...\n\n{result}")
    if not changed:
        return
    # Write the file.
    with open(filename, 'w') as f:
        f.write(result)
#@+node:ekr.20200726083127.15: *5* fstring.fstringify_node
def fstringify_node(self, p):
    """
    fstringify node p.  Return True if the node has been changed.
    """
    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    if should_kill_beautify(p):
        return False
    contents = p.b
    if not contents.strip():
        return False
    # Unlike with external files, we must sanitize the text!
    comment_string, contents2 = self.sanitizer.comment_leo_lines(p=p)
    # Generate tokens.
    tokens = self.tokenize_string(contents2, p.h)
    # Handle all tokens, creating the raw result.
    raw_result = self.scan_all_tokens(contents2, tokens)
    # Undo the munging of the sources.
    result = self.sanitizer.uncomment_leo_lines(comment_string, c.p, raw_result)
    changed = contents.rstrip() != result.rstrip()
    if changed:
        p.b = result
        p.setDirty()
    # Trace the results.
    if trace and changed and verbose:
        g.trace(f"Contents...\n\n{contents}\n")
        g.trace(f"code list...\n\n{g.objToString(self.code_list)}\n")
        g.trace(f"raw result...\n\n{raw_result}\n")
        g.trace(f"Result...\n\n{result}\n")
    if trace:
        g.trace('Changed!' if changed else 'No change:', p.h)
    return changed
#@+node:ekr.20200726083127.16: *5* fstring.fstringify_tree
def fstringify_tree(self, p):
    """fstringify node p."""
    c = self.c
    if should_kill_beautify(p):
        return
    t1 = time.process_time()
    changed = total = 0
    for p in p.self_and_subtree():
        if g.scanForAtLanguage(c, p) == "python":
            total += 1
            if self.fstringify_node(p):
                changed += 1
    self.end_undo()
    if g.unitTesting:
        return
    t2 = time.process_time()
    g.es_print(
        f"scanned {total} node{g.plural(total)}, "
        f"changed {changed} node{g.plural(changed)}, "
        # f"{errors} error{g.plural(errors)} "
        f"in {t2-t1:4.2f} sec."
    )
#@+node:ekr.20200726083127.17: *4* fstring: Tokens
#@+node:ekr.20200726083127.18: *5* fstring.new_token
def new_token(self, kind, value):
    """Return a new token"""

    def item_kind(z):
        return 'string' if isinstance(z, str) else z.kind

    def val(z):
        return z if isinstance(z, str) else z.value
        
    if isinstance(value, (list, tuple)):
        return [BeautifierToken(item_kind(z), val(z)) for z in value]    
    return BeautifierToken(kind, value)
#@+node:ekr.20200726083127.19: *5* fstring.blank
def blank(self):
    """Add a blank request to the code list."""
    # Same as ptb.blank, but there is no common base class.
    prev = self.code_list[-1]
    if prev.kind not in (
        'blank',
        'blank-lines',
        'file-start',
        'line-end',
        'line-indent',
        'lt',
        'op-no-blanks',
        'unary-op',
    ):
        self.add_token('blank', ' ')
#@+node:ekr.20200726083127.20: *5* fstring.do_string
def do_string(self):
    """Handle a 'string' token."""
    # See whether a conversion is possible.
    if (
        not self.val.lower().startswith(('f', 'r'))
        and '%' in self.val
        and self.look_ahead(0) == ('op', '%')
    ):
        # Not an f or r string, and a conversion is possible.
        self.convert_fstring()
    else:
        # Just put the string
        self.add_token('string', self.val) 
#@+node:ekr.20200726083127.21: *5* fstring.do_token (override)
def do_token(self, token):
    """
    Override NullTokenBeautifier.do_token.

    Handle one input token, a BeautifierToken.
    """
    # Only the string handler is overridden.
    if token.kind == 'string':
        self.kind = token.kind
        self.val = token.value
        # Set these for error messages.
        self.line = token.line
        self.line_number = token.line_number
        self.do_string()
    else:
        # Same as super().do_token(token)
        self.code_list.append(token)
    self.prev_token = token
#@+node:ekr.20200726083127.22: *5* fstring.look_ahead & skip_ahead
def look_ahead(self, n):
    """
    Look ahead n tokens, skipping ws tokens  n >= 0.
    Return (token.kind, token.value)
    """
    while n < len(self.tokens):
        token = self.tokens[n]
        n += 1
        assert isinstance(token, BeautifierToken), (repr(token), g.callers())
        if token.kind != 'ws':
            return token.kind, token.value
    return None, None
        # Strip trailing whitespace from the token value.

def skip_ahead(self, n, target_kind, target_val):
    """
    Skip to the target token.  Only ws tokens should intervene.

    Return (n, tokens):
    """
    tokens = []
    while n < len(self.tokens):
        token = self.tokens[n]
        tokens.append(token)
        n += 1
        if (token.kind, token.value) == (target_kind, target_val):
            return n, tokens
        assert token.kind == 'ws', (token.kind, token.value)
    # Should never happen.
    return n, []
#@+node:ekr.20200726083127.23: *5* null_tok_b.scan_all_beautifier_tokens


#@+node:ekr.20150605175037.1: ** From leoCheck.py & checkerCommands.py
@first # -*- coding: utf-8 -*-
"""Experimental code checking for Leo."""
# To do:
# - Option to ignore defs without args if all calls have no args.
# * explain typical entries
import importlib
import leo.core.leoGlobals as g
import leo.core.leoAst as leoAst
importlib.reload(leoAst)
import ast
# import glob
import importlib
import os
import re
import time
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20171207095816.1: *3* class ConventionChecker
class ConventionChecker:
    """
    A prototype of an extensible convention-checking tool.
    See: https://github.com/leo-editor/leo-editor/issues/632
    
    Here is the body of @button check-conventions:
    
        g.cls()
        if c.changed: c.save()
        
        import importlib
        import leo.core.leoCheck as leoCheck
        importlib.reload(leoCheck)
        
        fn = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins', 'nodetags.py')
        leoCheck.ConventionChecker(c).check(fn=fn)
    """
    # pylint: disable=literal-comparison
        # What's wrong with `if self.test_kind is 'test'`?

    ignore = ('bool', 'dict', 'enumerate', 'list', 'tuple')
        # Things that look like function calls.

    @others
#@+node:ekr.20171210134449.1: *4* checker.Birth
def __init__(self, c):
    self.c = c
    self.class_name = None
    self.context_stack = []
        # Stack of ClassDef and FunctionDef nodes.
    # Rudimentary symbol tables...
    self.classes = self.init_classes()
    self.special_class_names = [
        'Commands', 'LeoGlobals', 'Position', 'String', 'VNode', 'VNodeBase',
    ]
    self.special_names_dict = self.init_special_names()
    # Debugging
    self.enable_trace = True
    self.file_name = None
    self.indent = 0 # For self.format.
    self.max_time = 0.0
    self.recursion_count = 0
    self.slowest_file = None
    self.stats = self.CCStats()
    # Other ivars...
    self.errors = 0
    self.line_number = 0
    self.pass_n = 0
    self.test_kind = None
    self.unknowns = {} # Keys are expression, values are (line, fn) pairs.
#@+node:ekr.20171209044610.1: *5* checker.init_classes
def init_classes(self):
    """
    Init the symbol tables with known classes.
    """
    return {
        # Pre-enter known classes.
        'Commands': {
            'ivars': {
                'p': self.Type('instance', 'Position'),
            },
            'methods': {},
        },
        'LeoGlobals': {
            'ivars': {}, # g.app, g.app.gui.
            'methods': {
                'trace': self.Type('instance', 'None')
            },
        },
        'Position': {
            'ivars': {
                'v': self.Type('instance', 'VNode'),
                'h': self.Type('instance', 'String'),
            },
            'methods': {},
        },
        'VNode': {
            'ivars': {
                'h': self.Type('instance', 'String'),
                # Vnode has no v instance!
            },
            'methods': {},
        },
        'VNodeBase': {
            'ivars': {},
            'methods': {},
        },
        'String': {
            'ivars': {},
            'methods': {}, # Possible?
        },
    }
    
#@+node:ekr.20171210133853.1: *5* checker.init_special_names
def init_special_names(self):
    """Init known special names."""
    t = self.Type
    return {
        'c': t('instance', 'Commands'),
        'c.p': t('instance', 'Position'),
        'g': t('instance', 'LeoGlobals'), # module?
        'p': t('instance', 'Position'),
        'v': t('instance', 'VNode'),
    }
#@+node:ekr.20171212015700.1: *4* checker.check & helpers (main entry)
def check(self):
    """
    The main entry point for the convention checker.

    A stand-alone version of the @button node that tested the
    ConventionChecker class.
    
    The check-conventions command in checkerCommands.py saves c and
    reloads the leoCheck module before instantiating this class and
    calling this method.
    """
    g.cls()
    c = self.c
    kind = 'production' # <----- Change only this line.
        # 'production', 'project', 'coverage', 'leo', 'lib2to3', 'pylint', 'rope'
    join = g.os_path_finalize_join
    loadDir = g.app.loadDir
    report_stats = True
    files_table = (
        # join(loadDir, 'leoCommands.py'),
        # join(loadDir, 'leoNodes.py'),
        join(loadDir, '..', 'plugins', 'qt_tree.py'),
    )
    # ===== Don't change anything below here =====
    if kind == 'files':
        for fn in files_table:
            self.check_file(fn=fn, trace_fn=True)
    elif kind == 'production':
        for p in g.findRootsWithPredicate(c, c.p, predicate=None):
            self.check_file(fn=g.fullPath(c, p), test_kind=kind, trace_fn=True)
    elif kind in ('project', 'coverage', 'leo', 'lib2to3', 'pylint', 'rope'):
        project_name = 'leo' if kind == 'project' else kind
        self.check_project(project_name)
    elif kind == 'test':
        self.test()
    else:
        g.trace('unknown kind', repr(kind))
    if report_stats:
        self.stats.report()
#@+node:ekr.20171207100432.1: *5* checker.check_file
def check_file(self, fn=None, s=None, test_kind=None, trace_fn=False):
    """Check the contents of fn or the string s."""
    # Get the source.
    if test_kind:
        self.test_kind = test_kind
    if fn:
        sfn = g.shortFileName(fn)
        if g.os_path_exists(fn):
            s, e = g.readFileIntoString(fn)
            if s:
                s = g.toEncodedString(s, encoding=e)
            else:
                g.trace('empty file:', sfn)
                return
        else:
            g.trace('file not found:', sfn)
            return
    elif s:
        sfn = '<string>'
    else:
        g.trace('no fn or s argument')
        return
    # Check the source
    if trace_fn:
        if fn:
            print(f"===== {sfn}")
        else:
            print('===== <string>\n%s\n----- </string>\n' % s.rstrip())
    t1 = time.process_time()
    node = ast.parse(s, filename='before', mode='exec')
    self.check_helper(fn=sfn, node=node, s=s)
    t2 = time.process_time()
    t_tot = t2-t1
    if t_tot > self.max_time:
        self.max_time = t_tot
        self.slowest_file = self.file_name
#@+node:ekr.20171214150828.1: *5* checker.check_helper
def check_helper(self, fn, node, s):

    cct = self.CCTraverser(controller=self)
    for n in 1, 2:
        if self.test_kind == 'test':
            g.trace('===== PASS', n)
        # Init this pass.
        self.file_name = fn
        self.indent = 0
        self.pass_n = n
        cct.visit(node)
    self.end_file()
#@+node:ekr.20171213013004.1: *5* checker.check_project
def check_project(self, project_name):
    
    trace_fn = True
    trace_skipped = False
    self.test_kind = 'project'
    fails_dict = {
        'coverage': ['cmdline.py',],
        'lib2to3': ['fixer_util.py', 'fix_dict.py', 'patcomp.py', 'refactor.py'],
        'leo': [], # All of Leo's core files pass.
        'pylint': [
            'base.py', 'classes.py', 'format.py',
            'logging.py', 'python3.py', 'stdlib.py', 
            'docparams.py', 'lint.py',
        ],
        'rope': ['objectinfo.py', 'objectdb.py', 'runmod.py',],
    }
    fails = fails_dict.get(project_name, [])
    utils = ProjectUtils()
    files = utils.project_files(project_name, force_all=False)
    if files:
        t1 = time.process_time()
        for fn in files:
            sfn = g.shortFileName(fn)
            if sfn in fails or fn in fails:
                if trace_skipped: print('===== skipping', sfn)
            else:
                self.check_file(fn=fn, trace_fn=trace_fn)
        t2 = time.process_time()
        print('%s files in %4.2f sec. max %4.2f sec in %s' % (
            len(files), (t2-t1), self.max_time, self.slowest_file))
        if self.errors:
            print(f"{self.errors} error{g.plural(self.errors)}")
    else:
        print(f"no files for project: {project_name}")
#@+node:ekr.20171208135642.1: *5* checker.end_file & helper
def end_file(self,trace_classes=False, trace_unknowns=False):
    
    # Do *not* clear self.classes.
    self.unknowns = {}
#@+node:ekr.20171212100005.1: *6* checker.trace_unknowns
def trace_unknowns(self):
    print('----- Unknown ivars...')
    d = self.unknowns
    max_key = max([len(key) for key in d ]) if d else 2
    for key, aList in sorted(d.items()):
        # Remove duplicates that vary only in line number.
        aList2, seen = [], []
        for data in aList:
            line, fn, s = data
            data2 = (key, fn, s)
            if data2 not in seen:
                seen.append(data2)
                aList2.append(data)
        for data in aList2:
            line, fn, s = data
            print('%*s %4s %s: %s' % (
                max_key, key, line, fn, g.truncate(s, 60)))
#@+node:ekr.20171212020013.1: *5* checker.test
tests = [
'''\
class TC:
    def __init__(self, c):
        c.tc = self
    def add_tag(self, p):
        print(p.v) # AttributeError if p is a vnode.

class Test:
    def __init__(self,c):
        self.c = c
        self.tc = self.c.tc
    def add_tag(self):
        p = self.c.p
        self.tc.add_tag(p.v) # WRONG: arg should be p.
''', # comma required!
]

def test(self):

    for s in self.tests:
        s = g.adjustTripleString(s, self.c.tab_width)
        self.check_file(s=s, test_kind='test', trace_fn=True)
    if self.errors:
        print(f"{self.errors} error{g.plural(self.errors)}")
#@+node:ekr.20171216063026.1: *4* checker.error, fail, note & log_line
def error(self, node, *args, **kwargs):
    
    self.errors += 1
    print('')
    print('Error: %s' % self.log_line(node, *args, **kwargs))
    print('')
    
def fail(self, node, *args, **kwargs):
    self.stats.inference_fails += 1
    print('')
    print('Inference failure: %s' % self.log_line(node, *args, **kwargs))
    print('')
    
def log_line(self, node=None, *args, **kwargs):
    # pylint: disable=keyword-arg-before-vararg
        # putting *args first is invalid in Python 2.x.
    return 'line: %s file: %s: %s' % (
        getattr(node, 'lineno', '??'),
        self.file_name or '<string>',
        ' '.join([z if isinstance(z, str) else repr(z) for z in args]),
    )
    
def note(self, node, *args, **kwargs):

    print('')
    print('Note: %s' % self.log_line(node, *args, **kwargs))
    print('')
#@+node:ekr.20171215080831.1: *4* checker.dump, format
def dump(self, node, annotate_fields=True, level=0, **kwargs):
    """Dump the node."""
    return leoAst.AstDumper().dump(node, level=level)

def format(self, node, *args, **kwargs):
    """Format the node and possibly its descendants, depending on args."""
    s = leoAst.AstFormatter().format(node, level=self.indent, *args, **kwargs)
    return s.rstrip()
#@+node:ekr.20171208142646.1: *4* checker.resolve & helpers
def resolve(self, node, name, context, trace=False):
    """Resolve name in the given context to a Type."""
    self.stats.resolve += 1
    assert isinstance(name, str), (repr(name), g.callers())
    if context:
        if context.kind in ('error', 'unknown'):
            result = context
        elif name == 'self':
            if context.name:
                result = self.Type('instance', context.name)
            else:
                g.trace('===== NO OBJECT NAME')
                result = self.Type('error', 'no object name')
        elif context.kind in ('class', 'instance'):
            result = self.resolve_ivar(node, name, context)
        else:
            result = self.Type('error', f"unknown kind: {context.kind}")
    else:
        result = self.Type('error', f"unbound name: {name}")
    return result
#@+node:ekr.20171208134737.1: *5* checker.resolve_call
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def resolve_call(self, node):
    """Resolve the head of the call's chain to a Type."""
    assert self.pass_n == 2
    self.stats.resolve_call += 1
    chain = self.get_chain(node.func)
    if chain:
        func = chain.pop()
        if isinstance(func, ast.Name):
            func = func.id
        assert isinstance(func, str), repr(func)
    if chain:
        assert isinstance(chain[0], ast.Name), repr(chain[0])
        chain[0] = chain[0].id
        # args = ','.join([self.format(z) for z in node.args])
        self.recursion_count = 0
        if self.class_name:
            context = self.Type('instance', self.class_name)
        else:
            context = self.Type('module', self.file_name)
        result = self.resolve_chain(node, chain, context)
    else:
        result = self.Type('unknown', 'empty chain')
    assert isinstance(result, self.Type), repr(result)
    return result
#@+node:ekr.20171209034244.1: *5* checker.resolve_chain
def resolve_chain(self, node, chain, context, trace=False):
    """Resolve the chain to a Type."""
    self.stats.resolve_chain += 1
    name = '<no name>'
    for obj in chain:
        name = obj.id if isinstance(obj, ast.Name) else obj
        assert isinstance(name, str), (repr(name), g.callers())
        context = self.resolve(node, name, context, trace=trace)
    assert isinstance(context, self.Type), repr(context)
    return context
#@+node:ekr.20171208173323.1: *5* checker.resolve_ivar & helpers
def resolve_ivar(self, node, ivar, context):
    """Resolve context.ivar to a Type."""
    assert self.pass_n == 2, repr(self.pass_n)
    self.stats.resolve_ivar += 1
    class_name = 'Commands' if context.name == 'c' else context.name
    self.recursion_count += 1
    if self.recursion_count > 20:
        self.report_unbounded_recursion(node, class_name, ivar, context)
        return self.Type('error', 'recursion')
    the_class = self.classes.get(class_name)
    if not the_class:
        return self.Type('error', f"no class {ivar}")
    ivars = the_class.get('ivars')
    methods = the_class.get('methods')
    if ivar == 'self':
        return self.Type('instance', class_name)
    if methods.get(ivar):
        return self.Type('func', ivar)
    if ivars.get(ivar):
        val = ivars.get(ivar)
        if isinstance(val, self.Type):
            return val
        # Check for pre-defined special names.
        for special_name, special_obj in self.special_names_dict.items():
            tail = val[len(special_name):]
            if val == special_name:
                return special_obj
            if val.startswith(special_name) and tail.startswith('.'):
                # Resovle the rest of the tail in the found context.
                return self.resolve_chain(node, tail[1:], special_obj)
        # Avoid recursion .
        head = val.split('.')
        if ivar in (val, head[0]):
            return self.Type('unknown', ivar)
        for name2 in head:
            old_context = context
            context = self.resolve(node, name2, context)
            if 0: g.trace('recursive %s: %r --> %r' % (name2, old_context, context))
        if 0: g.trace('END RECURSIVE: %r', context)
        return context
    if ivar in self.special_names_dict:
        val = self.special_names_dict.get(ivar)
        return val
    # Remember the unknown.
    self.remember_unknown_ivar(ivar)
    return self.Type('error', f"no member {ivar}")
#@+node:ekr.20171217102701.1: *6* checker.remember_unknown_ivar
def remember_unknown_ivar(self, ivar):

    d = self.unknowns
    aList = d.get(ivar, [])
    data = (self.line_number, self.file_name)
    aList.append(data)
    # tag:setter (data describing unknown ivar)
    d[ivar] = aList
    # self.error(node, 'No member:', ivar)
    return self.Type('error', 'no member %s' % ivar)
#@+node:ekr.20171217102055.1: *6* checker.report_unbounded_recursion
def report_unbounded_recursion(self, node, class_name, ivar, context):
    
    the_class = self.classes.get(class_name)
    self.error(node, 'UNBOUNDED RECURSION: %r %r\nCallers: %s' % (
        ivar, context, g.callers()))
    if 0:
        g.trace('CLASS DICT: Commands')
        g.printDict(self.classes.get('Commands'))
    if 0:
        g.trace('CLASS DICT', class_name)
        g.printDict(the_class)
#@+node:ekr.20171209065852.1: *5* checker_check_signature & helpers
def check_signature(self, node, func, args, signature):
    
    self.stats.check_signature += 1
    if signature[0] == 'self':
        signature = signature[1:]
    result = 'ok'
    for i, arg in enumerate(args):
        if i < len(signature):
            result = self.check_arg(node, func, args, arg, signature[i])
            if result == 'fail':
                self.fail(node, '\n%s(%s) incompatible with %s(%s)' % (
                    func, ','.join(args),
                    func, ','.join(signature),
                ))
                break
    if result == 'ok':
        self.stats.sig_ok += 1
    elif result == 'fail':
        self.stats.sig_fail += 1
    else:
        assert result == 'unknown'
        self.stats.sig_unknown += 1
#@+node:ekr.20171212034531.1: *6* checker.check_arg (Finish)
def check_arg(self, node, func, args, call_arg, sig_arg):
    """
    Check call_arg and sig_arg with arg (a list).
    
    To do: check keyword args.
    """
    return self.check_arg_helper(node, func, call_arg, sig_arg)

#@+node:ekr.20171212035137.1: *6* checker.check_arg_helper
def check_arg_helper(self, node, func, call_arg, sig_arg):

    special_names_dict = self.special_names_dict
    if call_arg == sig_arg or sig_arg in (None, 'None'):
        # Match anything against a default value of None.
        return 'ok'
    # Resolve the call_arg if possible.
    chain = call_arg.split('.')
    if len(chain) > 1:
        head, tail = chain[0], chain[1:]
        if head in special_names_dict:
            context = special_names_dict.get(head)
            context = self.resolve_chain(node, tail, context)
            if context.kind == 'error':
                # Caller will report the error.
                return 'unknown'
            if sig_arg in special_names_dict:
                sig_class = special_names_dict.get(sig_arg)
                return self.compare_classes(
                    node, call_arg, sig_arg, context, sig_class)
    if sig_arg in special_names_dict and call_arg in special_names_dict:
        sig_class = special_names_dict.get(sig_arg)
        call_class = special_names_dict.get(call_arg)
        return self.compare_classes(
            node, call_arg, sig_arg, call_class, sig_class)
    return 'unknown'
#@+node:ekr.20171212044621.1: *6* checker.compare_classes
def compare_classes(self, node, arg1, arg2, class1, class2):

    if class1 == class2:
        self.stats.sig_infer_ok += 1
        return 'ok'
    # The caller reports the failure.
    # self.error(node, 'FAIL', arg1, arg2, class1, class2)
    self.stats.sig_infer_fail += 1
    return 'fail'
#@+node:ekr.20171215074959.1: *4* checker.Visitors & helpers
#@+node:ekr.20171215074959.2: *5* checker.Assign & helpers
def before_Assign(self, node):
    
    s = self.format(node)
    if self.test_kind == 'test': print(s)
    if self.pass_n == 1:
        return
    self.stats.assignments += 1
    for target in node.targets:
        chain = self.get_chain(target)
        if len(chain) == 2:
            var1, var2 = chain
            assert isinstance(var1, ast.Name), repr(var1)
            assert isinstance(var2, str), repr(var2)
            name = var1.id
            if name == 'self':
                self.do_assn_to_self(node, name, var2)
            elif name in self.special_names_dict:
                self.do_assn_to_special(node, name, var2)
#@+node:ekr.20171215074959.4: *6* checker.do_assn_to_self
def do_assn_to_self(self, node, var1, var2):

    assert self.pass_n == 2
    assert var1 == 'self'
    class_name = self.class_name
    if not class_name:
        self.note(node, 'SKIP: no class name', self.format(node))
        return
    if class_name in self.special_class_names:
        # self.note(node, 'SKIP: not special', self.format(node))
        return
    d = self.classes.get(class_name)
    assert d is not None, class_name
    ivars = d.get('ivars')
    ivars[var2] = self.format(node.value)
    d['ivars'] = ivars
#@+node:ekr.20171215074959.3: *6* checker.do_assn_to_special
def do_assn_to_special(self, node, var1, var2):

    assert self.pass_n == 2
    assert var1 in self.special_names_dict, (repr(var1))
    class_name = self.class_name
    t = self.special_names_dict.get(var1)
    if not t:
        if 0: self.note(node, 'not special', var1, self.format(node).strip())
        return
    # Do not set members within the class itself.
    if t.kind == 'instance' and t.name == class_name:
        if 0: self.note(node, 'SKIP', var1, class_name)
        return
    # Resolve val, if possible.
    context = self.Type(
        'instance' if class_name else 'module',
        class_name or self.file_name,
    )
    self.recursion_count = 0
    value_s = self.format(node.value)
    resolved_type = self.resolve(node, value_s, context, trace=False)
    assert isinstance(resolved_type, self.Type), repr(resolved_type)
    if 0:
        self.note(node, f"context {context} : {value_s} ==> {resolved_type}")
    # Update var1's dict, not class_name's dict.
    d = self.classes.get(t.name)
    ivars = d.get('ivars')
    # tag:setter ivar1.ivar2 = Type
    ivars[var2] = resolved_type
    d['ivars'] = ivars
#@+node:ekr.20171215074959.5: *5* checker.Call
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def before_Call(self, node):

    if self.test_kind == 'test':
        print(self.format(node))
    if self.pass_n == 1:
        return
    self.stats.calls += 1
    context = self.resolve_call(node)
    assert isinstance(context, self.Type)
    if context.kind != 'instance':
        return
    instance = self.classes.get(context.name)
    if not instance:
        return
    chain = self.get_chain(node.func)
    func = chain[-1]
    d = instance.get('methods')
    signature = d.get(func)
    if not signature:
        return
    if isinstance(signature, self.Type):
        pass # Already checked?
    else:
        args = [self.format(z) for z in node.args]
        signature = signature.split(',')
        self.check_signature(node, func, args, signature)
#@+node:ekr.20171215074959.7: *5* checker.ClassDef
def before_ClassDef(self, node):

    s = self.format(node, print_body=False)
    if self.test_kind == 'test': print(s)
    self.indent += 1
    self.context_stack.append(node)
    self.class_name = name = node.name
    if self.pass_n == 1:
        self.stats.classes += 1
        if name not in self.special_class_names:
            # tag:setter Init the class's dict.
            self.classes [name] = {'ivars': {}, 'methods': {}}

def after_ClassDef(self, node):

    self.indent -= 1
    if 0 and self.pass_n == 1:
        g.trace(node, self.show_stack())
        print(f"----- END class {self.class_name}. class dict...")
        g.printDict(self.classes.get(self.class_name))
    #
    # This code must execute in *both* passes.
    top = self.context_stack.pop()
    assert node == top, (node, top)
    # Set the class name
    self.class_name = None
    for node2 in reversed(self.context_stack):
        if isinstance(node2, ast.ClassDef):
            self.class_name = node2.name
            break
#@+node:ekr.20171215074959.9: *5* checker.FunctionDef
def before_FunctionDef(self, node):

    s = self.format(node, print_body=False)
    if self.test_kind == 'test': print(s)
    self.indent += 1
    self.context_stack.append(node)
    if self.pass_n == 1:
        self.stats.defs += 1
        if self.class_name not in self.special_class_names:
            if self.class_name in self.classes:
                the_class = self.classes.get(self.class_name)
                methods = the_class.get('methods')
                # tag:setter function-name=stringized-args
                methods [node.name] = self.format(node.args)
            # This is not an error.
            # else: g.error(node 'no class', node.name)

def after_FunctionDef(self, node):

    self.indent -= 1
    top = self.context_stack.pop()
    assert node == top, (node, top)
#@+node:ekr.20171216110107.1: *5* checker.get_chain
def get_chain(self,node):
    """Scan node for a chain of names."""
    chain, node1 = [], node
    while not isinstance(node, ast.Name):
        if isinstance(node, ast.Attribute):
            assert isinstance(node.attr, str), repr(node.attr)
            chain.append(node.attr)
            node = node.value
        else:
            name = node.__class__.__name__
            if name not in (
                'BoolOp', # c.config.getString('stylesheet') or ''.strip
                'Call', # c1.rootPosition().h = whatever
                'Dict', # {}.whatever.
                'Subscript', # d[x] = whatever
                'Str', # ''.join(), etc
                'Tuple', # (hPos,vPos) = self.getScroll()
            ):
                self.note(node1, '(get_chain) target %s:\n%s' % (
                    name, self.format(node1)))
            return []
    if isinstance(node, ast.Name):
        chain.append(node)
        return list(reversed(chain))
    return []
#@+node:ekr.20171215082648.1: *5* checker.show_stack
def show_stack(self):

    return g.listToString([
        '%15s %s' % (node.__class__.__name__, node.name)
            for node in self.context_stack
        ])
#@+node:ekr.20171212101613.1: *4* class CCStats
class CCStats:
    """
    A basic statistics class.  Use this way:
        
        stats = Stats()
        stats.classes += 1
        stats.defs += 1
        stats.report()
    """
    # Big sigh: define these to placate pylint.
    assignments = 0
    calls = 0
    check_signature = 0
    classes = 0
    defs = 0
    inference_fails = 0
    resolve = 0
    resolve_call = 0
    resolve_chain = 0
    resolve_ivar = 0
    sig_fail = 0
    sig_infer_fail = 0
    sig_infer_ok = 0
    sig_ok = 0
    sig_unknown = 0
        
    def report(self):
        aList = [z for z in dir(self) if not z.startswith('_') and z != 'report']
        n = max([len(z) for z in aList])
        for ivar in aList:
            print('%*s: %s' % (n, ivar, getattr(self, ivar)))
    
#@+node:ekr.20171214151001.1: *4* class CCTraverser (AstFullTraverser)
class CCTraverser (leoAst.AstFullTraverser):
    
    """A traverser class that *only* calls controller methods."""

    def __init__(self, controller):

        super().__init__()
        self.cc = controller
    
    def visit(self, node):
        """
        Visit a *single* ast node.
        Visitors are responsible for visiting children!
        """
        name = node.__class__.__name__
        assert isinstance(node, ast.AST), repr(node)
        before_method = getattr(self.cc, 'before_'+name, None)
        if before_method:
            before_method(node)
        do_method = getattr(self, 'do_'+name, None)
        do_method(node)
        after_method = getattr(self.cc, 'after_'+name, None)
        if after_method:
            after_method(node)
#@+node:ekr.20171209030742.1: *4* class Type
class Type:
    """A class to hold all type-related data."""

    kinds = ('error', 'class', 'func', 'instance', 'module', 'unknown')
    
    def __init__(self, kind, name, source=None, tag=None):

        assert kind in self.kinds, repr(kind)
        self.kind = kind
        self.name=name
        self.source = source
        self.tag = tag
        
    def __repr__(self):

        return f"<{self.kind}: {self.name}>"
        
    def __eq__(self, other):
        
        return self.kind == other.kind and self.name == other.name
#@+node:ekr.20160109102859.1: *3* class Context
class Context:
    """
    Context class (NEW)

    Represents a binding context: module, class or def.

    For any Ast context node N, N.cx is a reference to a Context object.
    """
    @others
#@+node:ekr.20160109103533.1: *4* Context.ctor
def __init__ (self, fn, kind, name, node, parent_context):
    """Ctor for Context class."""
    self.fn = fn
    self.kind = kind
    self.name = name
    self.node = node
    self.parent_context = parent_context
    # Name Data...
    self.defined_names = set()
    self.global_names = set()
    self.imported_names = set()
    self.nonlocal_names = set() # To do.
    self.st = {}
        # Keys are names seen in this context, values are defining contexts.
    self.referenced_names = set()
    # Node lists. Entries are Ast nodes...
    self.inner_contexts_list = []
    self.minor_contexts_list = []
    self.assignments_list = []
    self.calls_list = []
    self.classes_list = []
    self.defs_list = []
    self.expressions_list = []
    self.returns_list = []
    self.statements_list = []
    self.yields_list = []
    # Add this context to the inner context of the parent context.
    if parent_context:
        parent_context.inner_contexts_list.append(self)
#@+node:ekr.20160109134527.1: *4* Context.define_name
def define_name(self, name):
    """Define a name in this context."""
    self.defined_names.add(name)
    if name in self.referenced_names:
        self.referenced_names.remove(name)
#@+node:ekr.20160109143040.1: *4* Context.global_name
def global_name(self, name):
    """Handle a global name in this context."""
    self.global_names.add(name)
    # Not yet.
        # Both Python 2 and 3 generate SyntaxWarnings when a name
        # is used before the corresponding global declarations.
        # We can make the same assumpution here:
        # give an *error* if an STE appears in this context for the name.
        # The error indicates that scope resolution will give the wrong result.
        # e = cx.st.d.get(name)
        # if e:
            # self.u.error(f"name {name!r} used prior to global declaration")
            # # Add the name to the global_names set in *this* context.
            # # cx.global_names.add(name)
        # # Regardless of error, bind the name in *this* context,
        # # using the STE from the module context.
        # cx.st.d[name] = module_e
#@+node:ekr.20160109144139.1: *4* Context.import_name
def import_name(self, module, name):

    if True and name == '*':
        g.trace('From x import * not ready yet')
    else:
        self.imported_names.add(name)
#@+node:ekr.20160109145526.1: *4* Context.reference_name
def reference_name(self, name):

    self.referenced_names.add(name)
#@+node:ekr.20160108105958.1: *3* class Pass1 (AstFullTraverser)
class Pass1 (leoAst.AstFullTraverser): # V2

    """ Pass1 does the following:

    1. Creates Context objects and injects them into the new_cx field of
       ast.Class, ast.FunctionDef and ast.Lambda nodes.

    2. Calls the following Context methods: cx.define/global/import/reference_name.
       These methods update lists used later to bind names to objects.
    """
    # pylint: disable=no-member
        # Stats class defines __setattr__
        # This is a known limitation of pylint.

    @others
#@+node:ekr.20160108105958.2: *4*  p1.ctor
def __init__(self, fn):

    super().__init__()
    self.fn = fn
    # Abbreviations...
    self.stats = Stats()
    self.u = ProjectUtils()
    self.format = leoAst.AstFormatter.format
    # Present context...
    self.context = None
    self.in_attr = False
        # True: traversing inner parts of an AST.Attribute tree.
    self.module_context = None
    self.parent = None
#@+node:ekr.20160108105958.3: *4*  p1.run (entry point)
def run (self,root):

    self.visit(root)
#@+node:ekr.20160109125654.1: *4*  p1.visit
def visit(self, node):
    """Visit a *single* ast node.  Visitors are responsible for visiting children!"""
    assert isinstance(node, ast.AST), node.__class__.__name__
    # Visit the children with the new parent.
    old_parent = self.parent
    self.parent = node
    method_name = 'do_' + node.__class__.__name__
    method = getattr(self, method_name)
    method(node)
    self.parent = old_parent
#@+node:ekr.20160108105958.11: *4* p1.visitors
#@+node:ekr.20160109134854.1: *5* Contexts
#@+node:ekr.20160108105958.8: *6* p1.def_args_helper
# arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def def_args_helper (self,cx,node):

    assert self.kind(node) == 'arguments'
    self.visit_list(node.args)
    self.visit_list(node.defaults)
    for field in ('vararg','kwarg'): # node.field is a string.
        name = getattr(node,field,None)
        if name:
            # e = cx.st.define_name(name)
            self.stats.n_param_names += 1
#@+node:ekr.20160108105958.16: *6* p1.ClassDef
# ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef (self,node):

    # pylint: disable=arguments-differ
    old_cx = self.context
    name = node.name
    # Define the class name in the old context.
    old_cx.define_name(name)
    # Visit bases in the old context.
    # bases = self.visit_list(node.bases)
    new_cx = Context(
        fn=None,
        kind='class',
        name=name,
        node=node,
        parent_context=old_cx)
    setattr(node,'new_cx',new_cx)
    # Visit the body in the new context.
    self.context = new_cx
    self.visit_list(node.body)
    self.context = old_cx
    # Stats.
    old_cx.classes_list.append(new_cx)
#@+node:ekr.20160108105958.19: *6* p1.FunctionDef
# 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#    expr? returns)

def do_FunctionDef (self,node):
    # pylint: disable=arguments-differ
    # Define the function/method name in the old context.
    old_cx = self.context
    name = node.name
    old_cx.define_name(name)
    # Create the new context.
    new_cx = Context(
        fn=None,
        kind='def',
        name=name,
        node=node,
        parent_context=old_cx)
    setattr(node,'new_cx',new_cx) # Bug fix.
    # Visit in the new context...
    self.context = new_cx
    self.def_args_helper(new_cx,node.args)
    self.visit_list(node.body)
    self.context = old_cx
    # Stats
    old_cx.defs_list.append(new_cx)
#@+node:ekr.20160108105958.23: *6* p1.Interactive
def do_Interactive(self,node):

    assert False,'Interactive context not supported'
#@+node:ekr.20160108105958.24: *6* p1.Lambda
def do_Lambda (self,node):

    # Synthesize a lambda name in the old context.
    # This name must not conflict with split names of the form name@n.
    old_cx = self.context
    name = f"Lambda@@{self.stats.n_lambdas}"
    # Define a Context for the 'lambda' variables.
    new_cx = Context(
        fn=None,
        kind='lambda',
        name=name,
        node=node,
        parent_context=old_cx)
    setattr(node,'new_cx',new_cx)
    # Evaluate expression in the new context.
    self.context = new_cx
    self.def_args_helper(new_cx,node.args)
    self.visit(node.body)
    self.context = old_cx
    # Stats...
    self.stats.n_lambdas += 1
#@+node:ekr.20160108105958.26: *6* p1.Module
def do_Module (self,node):

    # Not yet: Get the module context from the global dict if possible.
    new_cx = Context(
        fn=self.fn,
        kind='module',
        name=None,
        node=node,
        parent_context=None)
    self.context = new_cx
    self.visit_list(node.body)
    self.context = None
#@+node:ekr.20160109135022.1: *5* Expressions
#@+node:ekr.20160108105958.13: *6* p1.Attribute (Revise)
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self,node):

    # Visit...
    # cx = self.context
    old_attr, self.in_attr = self.in_attr, True
    # ctx = self.kind(node.ctx)
    self.visit(node.value)
    # self.visit(node.ctx)
    self.in_attr = old_attr
    if not self.in_attr:
        base_node = node
        kind = self.kind(base_node)
        if kind in ('Builtin','Name'):
            # base_name = base_node.id
            pass
        elif kind in ('Dict','List','Num','Str','Tuple',):
            pass
        elif kind in ('BinOp','UnaryOp'):
            pass
        else:
            assert False,kind
    # Stats...
    self.stats.n_attributes += 1
#@+node:ekr.20160108105958.17: *6* p1.Expr
# Expr(expr value)

def do_Expr(self,node):

    # Visit...
    cx = self.context
    self.visit(node.value)
    # Stats...
    self.stats.n_expressions += 1
    cx.expressions_list.append(node)
    cx.statements_list.append(node)
#@+node:ekr.20160108105958.27: *6* p1.Name (REWRITE)
def do_Name(self,node):

    cx  = self.context
    ctx = self.kind(node.ctx)
    name = node.id
    # def_flag,ref_flag=False,False

    if ctx in ('AugLoad','AugStore','Load'):
        # Note: AugStore does *not* define the symbol.
        cx.reference_name(name)
        self.stats.n_load_names += 1
    elif ctx == 'Store':
        # if name not in cx.global_names:
        self.stats.n_store_names += 1
    elif ctx == 'Param':
        self.stats.n_param_refs += 1
    else:
        assert ctx == 'Del',ctx
        self.stats.n_del_names += 1
#@+node:ekr.20160109140648.1: *5* Imports
#@+node:ekr.20160108105958.21: *6* p1.Import
@ From Guido:

import x            -->  x = __import__('x')
import x as y       -->  y = __import__('x')
import x.y.z        -->  x = __import__('x.y.z')
import x.y.z as p   -->  p = __import__('x.y.z').y.z
@c

def do_Import(self,node):
    """
    Add the imported file to u.files_list if needed
    and create a context for the file.
    """
    cx = self.context
    cx.statements_list.append(node)
    # e_list, names = [],[]
    for fn,asname in self.get_import_names(node):
        self.resolve_import_name(fn)
        # Not yet.
        # # Important: do *not* analyze modules not in the files list.
        # if fn2:
            # mname = self.u.module_name(fn2)
            # if g.shortFileName(fn2) in self.u.files_list:
                # if mname not in self.u.module_names:
                    # self.u.module_names.append(mname)
            # def_name = asname or mname
            # names.append(def_name)
            # e = cx.st.define_name(def_name) # sets e.defined.
            # cx.imported_symbols_list.append(def_name)
            # e_list.append(e)

            # # Add the constant type to the list of types for the *variable*.
            # mod_cx = self.u.modules_dict.get(fn2) or LibraryModuleContext(self.u,fn2)
            # e.types_cache[''] = mod_cx.module_type
            # # self.u.stats.n_imports += 1

    # for e in e_list:
        # e.defs_list.append(node)
        # e.refs_list.append(node)
#@+node:ekr.20160108105958.22: *6* p1.ImportFrom
@ From Guido:

from p.q import x       -->  x = __import__('p.q', fromlist=['x']).x
from p.q import x as y  -->  y = __import__('p.q', fromlist=['x']).x
from ..x.y import z     -->  z = __import('x.y', level=2, fromlist=['z']).z

All these equivalences are still somewhat approximate; __import__
isn't looked up the way other variables are looked up (it is taken
from the current builtins), and if the getattr operation in the "from"
versions raises AttributeError that is translated into ImportError.

There's also a subtlety where "import x.y" implies that y must be a
submodule/subpackage of x, whereas in "from x import y" it may be
either a submodule/subpackage or a plain attribute (e.g. a class,
function or some other variable).
@c

def do_ImportFrom(self,node):
    """
    Add the imported file to u.files_list if needed
    and add the imported symbols to the *present* context.
    """
    cx = self.context
    cx.statements_list.append(node)
    self.resolve_import_name(node.module)
    for fn,asname in self.get_import_names(node):
        fn2 = asname or fn
        cx.import_name(fn2)
#@+node:ekr.20160108105958.9: *6* p1.get_import_names
def get_import_names (self,node):
    """Return a list of the the full file names in the import statement."""
    result = []
    for ast2 in node.names:

        if self.kind(ast2) == 'alias':
            data = ast2.name,ast2.asname
            result.append(data)
        else:
            g.trace('unsupported kind in Import.names list',self.kind(ast2))
    return result
#@+node:ekr.20160108105958.10: *6* p1.resolve_import_name
def resolve_import_name (self,spec):
    """Return the full path name corresponding to the import spec."""
    if not spec:
        return ''
    # This may not work for leading dots.
    aList = spec.split('.')
    path = None
    # paths = None
    name = 'no name'
    for name in aList:
        try:
            pass
            ### Not ready. Old code:
                # f,path,description = imp.find_module(name,paths)
                # if not path: break
                # paths = [path]
                # if f: f.close()
        except ImportError:
            # Important: imports can fail due to Python version.
            # Thus, such errors are not necessarily searious.
            path = None
            break
    if not path:
        return ''
    if path.endswith('.pyd'):
        return ''
    return path
#@+node:ekr.20160108105958.29: *5* Operators... To be deleted???
# operator = Add | BitAnd | BitOr | BitXor | Div
# FloorDiv | LShift | Mod | Mult | Pow | RShift | Sub |

def do_Add(self,node):       setattr(node,'op_name','+')
def do_BitAnd(self,node):    setattr(node,'op_name','&')
def do_BitOr(self,node):     setattr(node,'op_name','|')
def do_BitXor(self,node):    setattr(node,'op_name','^')
def do_Div(self,node):       setattr(node,'op_name','/')
def do_FloorDiv(self,node):  setattr(node,'op_name','//')
def do_LShift(self,node):    setattr(node,'op_name','<<')
def do_Mod(self,node):       setattr(node,'op_name','%')
def do_Mult(self,node):      setattr(node,'op_name','*')
def do_Pow(self,node):       setattr(node,'op_name','**')
def do_RShift(self,node):    setattr(node,'op_name','>>')
def do_Sub(self,node):       setattr(node,'op_name','-')

# boolop = And | Or
def do_And(self,node):       setattr(node,'op_name',' and ')
def do_Or(self,node):        setattr(node,'op_name',' or ')

# cmpop = Eq | Gt | GtE | In |
# Is | IsNot | Lt | LtE | NotEq | NotIn
def do_Eq(self,node):        setattr(node,'op_name','==')
def do_Gt(self,node):        setattr(node,'op_name','>')
def do_GtE(self,node):       setattr(node,'op_name','>=')
def do_In(self,node):        setattr(node,'op_name',' in ')
def do_Is(self,node):        setattr(node,'op_name',' is ')
def do_IsNot(self,node):     setattr(node,'op_name',' is not ')
def do_Lt(self,node):        setattr(node,'op_name','<')
def do_LtE(self,node):       setattr(node,'op_name','<=')
def do_NotEq(self,node):     setattr(node,'op_name','!=')
def do_NotIn(self,node):     setattr(node,'op_name',' not in ')

# unaryop = Invert | Not | UAdd | USub
def do_Invert(self,node):   setattr(node,'op_name','~')
def do_Not(self,node):      setattr(node,'op_name',' not ')
def do_UAdd(self,node):     setattr(node,'op_name','+')
def do_USub(self,node):     setattr(node,'op_name','-')
#@+node:ekr.20160109134929.1: *5* Minor contexts
#@+node:ekr.20160109130719.1: *6* p1.comprehension (to do)
# comprehension (expr target, expr iter, expr* ifs)

def do_comprehension(self, node):

    # Visit...
    self.visit(node.target) # A name.
    self.visit(node.iter) # An attribute.
    for z in node.ifs:
        self.visit(z)
#@+node:ekr.20160108105958.18: *6* p1.For
# For(expr target, expr iter, stmt* body, stmt* orelse)

def do_For(self,node):

    # Visit...
    cx = self.context
    self.visit(node.target)
    self.visit(node.iter)
    for z in node.body:
        self.visit(z)
    for z in node.orelse:
        self.visit(z)
    # Stats...
    self.stats.n_fors += 1
    cx.statements_list.append(node)
    cx.assignments_list.append(node)
#@+node:ekr.20160108105958.30: *6* p1.With
def do_With(self,node):

    # Visit...
    cx = self.context
    self.visit(node.context_expr)
    if node.optional_vars:
        self.visit(node.optional_vars)
    for z in node.body:
        self.visit(z)
    # Stats...
    self.stats.n_withs += 1
    cx.statements_list.append(node)
#@+node:ekr.20160109135003.1: *5* Statements
#@+node:ekr.20160108105958.12: *6* p1.Assign
def do_Assign(self,node):

    # Visit...
    for z in node.targets:
        self.visit(z)
    self.visit(node.value)
    # Stats...
    cx = self.context
    self.stats.n_assignments += 1
    cx.assignments_list.append(node)
    cx.statements_list.append(node)
#@+node:ekr.20160108105958.14: *6* p1.AugAssign
# AugAssign(expr target, operator op, expr value)

def do_AugAssign(self,node):

    # Visit...
    self.visit(node.target)
    self.visit(node.value)
    # Stats...
    cx = self.context
    self.stats.n_assignments += 1
    cx.assignments_list.append(node)
    cx.statements_list.append(node)
#@+node:ekr.20160108105958.15: *6* p1.Call
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self,node):

    # Visit...
    self.visit(node.func)
    for z in node.args:
        self.visit(z)
    for z in node.keywords:
        self.visit(z)
    if getattr(node, 'starargs', None):
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None):
        self.visit(node.kwargs)
    # Stats...
    cx = self.context
    self.stats.n_calls += 1
    cx.calls_list.append(node)
#@+node:ekr.20160108105958.20: *6* p1.Global
def do_Global(self,node):

    # Visit
    cx = self.context
    for name in node.names:
        cx.global_name(name)
    # Stats...
    cx.statements_list.append(node)
    self.stats.n_globals += 1
#@+node:ekr.20160108105958.28: *6* p1.Return
def do_Return(self,node):

    # Visit...
    if node.value:
        self.visit(node.value)
    # Stats...
    self.stats.n_returns += 1
    cx = self.context
    cx.returns_list.append(node)
    cx.statements_list.append(node)
#@+node:ekr.20150525123715.1: *3* class ProjectUtils
class ProjectUtils:
    """A class to compute the files in a project."""
    # To do: get project info from @data nodes.
    @others
#@+node:ekr.20150525123715.2: *4* pu.files_in_dir
def files_in_dir(self, theDir, recursive=True, extList=None, excludeDirs=None):
    """
    Return a list of all Python files in the directory.
    Include all descendants if recursiveFlag is True.
    Include all file types if extList is None.
    """
    # import glob
    import os
    # if extList is None: extList = ['.py']
    if excludeDirs is None: excludeDirs = []
    result = []
    if recursive:
        for root, dirs, files in os.walk(theDir):
            for z in files:
                fn = g.os_path_finalize_join(root, z)
                junk, ext = g.os_path_splitext(fn)
                if not extList or ext in extList:
                    result.append(fn)
            if excludeDirs and dirs:
                for z in dirs:
                    if z in excludeDirs:
                        dirs.remove(z)
    else:
        for ext in extList:
            result.extend(g.glob_glob(f"{theDir}.*{ext}"))
    return sorted(list(set(result)))
#@+node:ekr.20150525123715.3: *4* pu.get_project_directory
def get_project_directory(self, name):
    # Ignore everything after the first space.
    i = name.find(' ')
    if i > -1:
        name = name[: i].strip()
    leo_path, junk = g.os_path_split(__file__)
    d = {
        # Change these paths as required for your system.
        'coverage': r'C:\Python26\Lib\site-packages\coverage-3.5b1-py2.6-win32.egg\coverage',
        'leo': r'C:\leo.repo\leo-editor\leo\core',
        'lib2to3': r'C:\Python26\Lib\lib2to3',
        'pylint': r'C:\Python26\Lib\site-packages\pylint',
        'rope': r'C:\Python26\Lib\site-packages\rope-0.9.4-py2.6.egg\rope\base',
        'test': g.os_path_finalize_join(g.app.loadDir, '..', 'test-proj'),
    }
    dir_ = d.get(name.lower())
    if not dir_:
        g.trace(f"bad project name: {name}")
    if not g.os_path_exists(dir_):
        g.trace('directory not found:' % (dir_))
    return dir_ or ''
#@+node:ekr.20171213071416.1: *4* pu.leo_core_files
def leo_core_files(self):
    """Return all the files in Leo's core."""
    loadDir = g.app.loadDir
    # Compute directories.
    commands_dir = g.os_path_finalize_join(loadDir, '..', 'commands')
    plugins_dir = g.os_path_finalize_join(loadDir, '..', 'plugins')
    # Compute files.
    core_files = g.glob_glob('%s%s%s' % (loadDir, os.sep, '*.py'))
    for exclude in ['format-code.py',]:
        core_files = [z for z in core_files if not z.endswith(exclude)]
    command_files = g.glob_glob(f"{commands_dir}{os.sep}{'*.py'}")
    plugins_files = g.glob_glob(f"{plugins_dir}{os.sep}{'qt_*.py'}")
    # Compute the result.
    files = core_files + command_files + plugins_files
    files = [z for z in files if not z.endswith('__init__.py')]
    return files
#@+node:ekr.20150525123715.4: *4* pu.project_files
@nobeautify

def project_files(self, name, force_all=False):
    """Return a list of all files in the named project."""
    # Ignore everything after the first space.
    i = name.find(' ')
    if i > -1:
        name = name[: i].strip()
    leo_path, junk = g.os_path_split(__file__)
    if name == 'leo':
        # Get the leo files directly.
        return self.leo_core_files()
    # Import the appropriate module.
    try:
        m = importlib.import_module(name, name)
        theDir = g.os_path_dirname(m.__file__)
    except ImportError:
        g.trace('package not found', name)
        return []
    d = {
        'coverage': (['.py'], ['.bzr', 'htmlfiles']),
        'lib2to3':  (['.py'], ['tests']),
        'pylint':   (['.py'], ['.bzr', 'test']),
        'rope':     (['.py'], ['.bzr']),
    }
    data = d.get(name.lower())
    if not data:
        g.trace(f"bad project name: {name}")
        return []
    extList, excludeDirs = data
    files = self.files_in_dir(theDir,
        recursive=True,
        extList=extList,
        excludeDirs=excludeDirs,
    )
    if files:
        if g.app.runningAllUnitTests and len(files) > 1 and not force_all:
            return [files[0]]
    if not files:
        g.trace(f"no files found for {name} in {theDir}")
    if g.app.runningAllUnitTests and len(files) > 1 and not force_all:
        return [files[0]]
    return files
#@+node:ekr.20171213155537.1: *3* class NewShowData
class NewShowData:
    """The driver class for analysis project."""
    assigns_d = {}
    calls_d = {}
    classes_d = {}
    defs_d = {}
    returns_d = {}

    @others
#@+node:ekr.20171213160214.1: *4* sd.analyze
def analyze(self, fn, root):
    
    ast_d = {
        ast.Assign: self.assigns_d,
        ast.AugAssign: self.assigns_d,
        ast.Call: self.calls_d,
        ast.ClassDef: self.classes_d,
        ast.FunctionDef: self.defs_d,
        ast.Return: self.returns_d, 
    }
    fn = g.shortFileName(fn)
    for d in ast_d.values():
        d[fn] = []
    for node in ast.walk(root):
        d = ast_d.get(node.__class__)
        if d is not None:
            d[fn].append(self.format(node))
#@+node:ekr.20171214040822.1: *4* sd.dump
def dump(self, fn, root):
    
    suppress = [
        'arg', 'arguments', 'comprehension', 'keyword',
        'Attribute', 'BinOp', 'BoolOp', 'Dict', 'IfExp', 'Index',
        'Load', 'List', 'ListComp', 'Name', 'NameConstant', 'Num',
        'Slice', 'Store', 'Str', 'Subscript', 'Tuple', 'UnaryOp',
    ]
    # statements = ['Assign', 'AugAssign', 'Call', 'Expr', 'If', 'Return',]
    errors = set()
    fn = g.shortFileName(fn)
    for node in ast.walk(root):
        name = node.__class__.__name__
        if name not in suppress:
            try:
                print('%15s: %s' % (name, self.format(node,strip=False)))
            except AttributeError:
                errors.add(name)
    g.trace('errors', sorted(errors))
    # g.printList(sorted(errors))
#@+node:ekr.20171213163216.1: *4* sd.format
def format(self, node, strip=True):
    
    class Formatter(leoAst.AstFormatter):
        level = 0
    
    s = Formatter().visit(node)
    line1 = g.splitLines(s)[0]
    line1 = line1.strip() if strip else line1.rstrip()
    return g.truncate(line1, 80)
#@+node:ekr.20171213155537.3: *4* sd.run
def run(self, files, dump=False, show_results=True):
    """Process all files"""
    t1 = time.time()
    for fn in files:
        s, e = g.readFileIntoString(fn)
        if s:
            print('=====', g.shortFileName(fn))
            s1 = g.toEncodedString(s)
            root = ast.parse(s1, filename='before', mode='exec')
            if dump:
                self.dump(fn, root)
            else:
                self.analyze(fn, root)
        else:
            g.trace('skipped', g.shortFileName(fn))
    t2 = time.time()
    if show_results:
        self.show_results()
    g.trace('done: %s files in %4.1f sec.' % (len(files), (t2 - t1)))
#@+node:ekr.20171213155537.7: *4* sd.show_results
def show_results(self):
    """Print a summary of the test results."""
    table = (
        ('assignments', self.assigns_d),
        ('calls', self.calls_d),
        ('classes', self.classes_d),
        ('defs', self.defs_d),
        ('returns', self.returns_d),
    )
    for name, d in table:
        print(f"{name}...")
        g.printDict({key: sorted(set(d.get(key))) for key in d})
#@+node:ekr.20171213174732.1: *4* sd.visit
def visit(self, node, types):
    if isinstance(node, types):
        yield self.format(node)
#@+node:ekr.20150604164113.1: *3* class ShowData
class ShowData:
    """The driver class for analysis project."""
    @others
#@+node:ekr.20150604165500.1: *4*  ctor
def __init__(self, c):
    """Ctor for ShowData controller class."""
    self.c = c
    self.files = None
    # Data.
    self.assigns_d = {}
    self.calls_d = {}
    self.classes_d = {}
    self.context_stack = []
    self.defs_d = {}
    self.returns_d = {}
    # Statistics
    self.n_matches = 0
    self.n_undefined_calls = 0
    self.tot_lines = 0
    self.tot_s = 0
#@+node:ekr.20150604163903.1: *4* run & helpers
def run(self, files):
    """Process all files"""
    self.files = files
    t1 = time.time()
    for fn in files:
        s, e = g.readFileIntoString(fn)
        if s:
            self.tot_s += len(s)
            g.trace('%8s %s' % ("{:,}".format(len(s)), g.shortFileName(fn)))
                # Print len(s), with commas.
            # Fast, accurate:
            # 1.9 sec for parsing.
            # 2.5 sec for Null AstFullTraverer traversal.
            # 2.7 sec to generate all strings.
            # 3.8 sec to generate all reports.
            s1 = g.toEncodedString(s)
            self.tot_lines += len(g.splitLines(s))
                # Adds less than 0.1 sec.
            node = ast.parse(s1, filename='before', mode='exec')
            ShowDataTraverser(self, fn).visit(node)
            # elif 0: # Too slow, too clumsy: 3.3 sec for tokenizing
                # readlines = g.ReadLinesClass(s).next
                # for token5tuple in tokenize.generate_tokens(readlines):
                    # pass
            # else: # Inaccurate. 2.2 sec to generate all reports.
                # self.scan(fn, s)
        else:
            g.trace('skipped', g.shortFileName(fn))
    t2 = time.time()
        # Get the time exlusive of print time.
    self.show_results()
    g.trace('done: %4.1f sec.' % (t2 - t1))
#@+node:ekr.20150605054921.1: *4* scan & helpers (a prototype: no longer used)
if 0:
    # The excellent prototype code, fast, easy but inaccurate.
    # It was a roadmap for the ShowDataTraverser class.

    # Regex patterns (were defined in the ctor)
    r_class = r'class[ \t]+([a-z_A-Z][a-z_A-Z0-9]*).*:'
    r_def = r'def[ \t]+([a-z_A-Z][a-z_A-Z0-9]*)[ \t]*\((.*)\)'
    r_return = r'(return[ \t].*)$'
    r_call = r'([a-z_A-Z][a-z_A-Z0-9]*)[ \t]*\(([^)]*)\)'
    r_all = re.compile(r'|'.join([r_class, r_def, r_return, r_call,]))

    def scan(self, fn, s):
        lines = g.splitLines(s)
        self.tot_lines += len(lines)
        for i, s in enumerate(lines):
            m = re.search(self.r_all, s)
            if m and not s.startswith('@'):
                self.match(fn, i, m, s)
#@+node:ekr.20150605063318.1: *5* match
def match(self, fn, i, m, s):
    """Handle the next match."""
    self.n_matches += 1
    indent = g.skip_ws(s, 0)
    # Update the context and enter data.
    if g.match_word(s, indent, 'def'):
        self.update_context(fn, indent, 'def', s)
        for i, name in enumerate(m.groups()):
            if name:
                aList = self.defs_d.get(name, [])
                def_tuple = self.context_stack[: -1], s
                aList.append(def_tuple)
                self.defs_d[name] = aList
                break
    elif g.match_word(s, indent, 'class'):
        self.update_context(fn, indent, 'class', s)
        for i, name in enumerate(m.groups()):
            if name:
                aList = self.classes_d.get(name, [])
                class_tuple = self.context_stack[: -1], s
                aList.append(class_tuple)
                self.classes_d[name] = aList
    elif s.find('return') > -1:
        context, name = self.context_names()
        j = s.find('#')
        if j > -1: s = s[: j]
        s = s.strip()
        if s:
            aList = self.returns_d.get(name, [])
            return_tuple = context, s
            aList.append(return_tuple)
            self.returns_d[name] = aList
    else:
        # A call.
        for i, name in enumerate(m.groups()):
            if name:
                context2, context1 = self.context_names()
                j = s.find('#')
                if j > -1:
                    s = s[: j]
                s = s.strip().strip(',').strip()
                if s:
                    aList = self.calls_d.get(name, [])
                    call_tuple = context2, context1, s
                    aList.append(call_tuple)
                    self.calls_d[name] = aList
                break
#@+node:ekr.20150605074749.1: *5* update_context
def update_context(self, fn, indent, kind, s):
    """Update context info when a class or def is seen."""
    while self.context_stack:
        fn2, kind2, indent2, s2 = self.context_stack[-1]
        if indent <= indent2:
            self.context_stack.pop()
        else:
            break
    context_tuple = fn, kind, indent, s
    self.context_stack.append(context_tuple)
    self.context_indent = indent
#@+node:ekr.20150604164546.1: *4* show_results & helpers
def show_results(self):
    """Print a summary of the test results."""
    make = True
    multiple_only = False # True only show defs defined in more than one place.
    c = self.c
    result = ['@killcolor\n']
    for name in sorted(self.defs_d):
        aList = self.defs_d.get(name, [])
        if len(aList) > 1 or not multiple_only: # not name.startswith('__') and (
            self.show_defs(name, result)
            self.show_calls(name, result)
            self.show_returns(name, result)
    self.show_undefined_calls(result)
    # Put the result in a new node.
    format = (
        'files: %s lines: %s chars: %s classes: %s\n'
        'defs: %s calls: %s undefined calls: %s returns: %s'
    )
    summary = format % (
        # g.plural(self.files),
        len(self.files),
        "{:,}".format(self.tot_lines),
        "{:,}".format(self.tot_s),
        "{:,}".format(len(self.classes_d.keys())),
        "{:,}".format(len(self.defs_d.keys())),
        "{:,}".format(len(self.calls_d.keys())),
        "{:,}".format(self.n_undefined_calls),
        "{:,}".format(len(self.returns_d.keys())),
    )
    result.insert(1, summary)
    result.extend(['', summary])
    if c and make:
        last = c.lastTopLevel()
        p2 = last.insertAfter()
        p2.h = 'global signatures'
        p2.b = '\n'.join(result)
        c.redraw(p=p2)
    print(summary)
#@+node:ekr.20150605160218.1: *5* show_calls
def show_calls(self, name, result):
    aList = self.calls_d.get(name, [])
    if not aList:
        return
    result.extend(['', f"    {len(aList)} call{g.plural(aList)}..."])
    w = 0
    calls = sorted(set(aList))
    for call_tuple in calls:
        context2, context1, s = call_tuple
        w = max(w, len(context2 or '') + len(context1 or ''))
    for call_tuple in calls:
        context2, context1, s = call_tuple
        pad = w - (len(context2 or '') + len(context1 or ''))
        if context2:
            result.append('%s%s::%s: %s' % (
                ' ' * (8 + pad), context2, context1, s))
        else:
            result.append('%s%s: %s' % (
                ' ' * (10 + pad), context1, s))
#@+node:ekr.20150605155601.1: *5* show_defs
def show_defs(self, name, result):
    aList = self.defs_d.get(name, [])
    name_added = False
    w = 0
    # Calculate the width
    for def_tuple in aList:
        context_stack, s = def_tuple
        if context_stack:
            fn, kind, context_s = context_stack[-1]
            w = max(w, len(context_s))
    for def_tuple in aList:
        context_stack, s = def_tuple
        if not name_added:
            name_added = True
            result.append('\n%s' % name)
            result.append(f"    {len(aList)} definition{g.plural(aList)}...")
        if context_stack:
            fn, kind, context_s = context_stack[-1]
            def_s = s.strip()
            pad = w - len(context_s)
            result.append('%s%s: %s' % (' ' * (8 + pad), context_s, def_s))
        else:
            result.append('%s%s' % (' ' * 4, s.strip()))
#@+node:ekr.20150605160341.1: *5* show_returns
def show_returns(self, name, result):
    aList = self.returns_d.get(name, [])
    if not aList:
        return
    result.extend(['', f"    {len(aList)} return{g.plural(aList)}..."])
    w, returns = 0, sorted(set(aList))
    for returns_tuple in returns:
        context, s = returns_tuple
        w = max(w, len(context or ''))
    for returns_tuple in returns:
        context, s = returns_tuple
        pad = w - len(context)
        result.append('%s%s: %s' % (' ' * (8 + pad), context, s))
#@+node:ekr.20150606092147.1: *5* show_undefined_calls
def show_undefined_calls(self, result):
    """Show all calls to undefined functions."""
    call_tuples = []
    for s in self.calls_d:
        i = 0
        while True:
            progress = i
            j = s.find('.', i)
            if j == -1:
                name = s[i:].strip()
                call_tuple = name, s
                call_tuples.append(call_tuple)
                break
            else:
                i = j + 1
            assert progress < i
    undef = []
    for call_tuple in call_tuples:
        name, s = call_tuple
        if name not in self.defs_d:
            undef.append(call_tuple)
    undef = list(set(undef))
    result.extend(['', f"{len(undef)} undefined call{g.plural(undef)}..."])
    self.n_undefined_calls = len(undef)
    # Merge all the calls for name.
    # There may be several with different s values.
    results_d = {}
    for undef_tuple in undef:
        name, s = undef_tuple
        calls = self.calls_d.get(s, [])
        aList = results_d.get(name, [])
        for call_tuple in calls:
            aList.append(call_tuple)
        results_d[name] = aList
    # Print the final results.
    for name in sorted(results_d):
        calls = results_d.get(name)
        result.extend(['', f"{name} {len(calls)} call{g.plural(calls)}..."])
        w = 0
        for call_tuple in calls:
            context2, context1, s = call_tuple
            if context2:
                w = max(w, 2 + len(context2) + len(context1))
            else:
                w = max(w, len(context1))
        for call_tuple in calls:
            context2, context1, s = call_tuple
            pad = w - (len(context2) + len(context1))
            if context2:
                result.append('%s%s::%s: %s' % (
                    ' ' * (2 + pad), context2, context1, s))
            else:
                result.append('%s%s: %s' % (
                    ' ' * (2 + pad), context1, s))
#@+node:ekr.20150605140911.1: *4* context_names
def context_names(self):
    """Return the present context name."""
    if self.context_stack:
        result = []
        for stack_i in -1, -2:
            try:
                fn, kind, indent, s = self.context_stack[stack_i]
            except IndexError:
                result.append('')
                break
            s = s.strip()
            assert kind in ('class', 'def'), kind
            i = g.skip_ws(s, 0)
            i += len(kind)
            i = g.skip_ws(s, i)
            j = g.skip_c_id(s, i)
            result.append(s[i: j])
        return reversed(result)
    return ['', '']
#@+node:ekr.20150606024455.1: *3* class ShowDataTraverser (AstFullTraverser)
class ShowDataTraverser(leoAst.AstFullTraverser):
    """
    Add data about classes, defs, returns and calls to controller's
    dictionaries.
    """

    def __init__(self, controller, fn):
        """Ctor for ShopDataTraverser class."""
        super().__init__()
        module_tuple = g.shortFileName(fn), 'module', g.shortFileName(fn)
            # fn, kind, s.
        self.context_stack = [module_tuple]
        self.controller = controller
        self.fn = g.shortFileName(fn)
        self.formatter = leoAst.AstFormatter()
            # leoAst.AstPatternFormatter()
    @others
#@+node:ekr.20150609053332.1: *4* sd.Helpers
#@+node:ekr.20150606035006.1: *5* sd.context_names
def context_names(self):
    """Return the present context names."""
    result = []
    n = len(self.context_stack)
    for i in n - 1, n - 2:
        if i >= 0:
            fn, kind, s = self.context_stack[i]
            assert kind in ('class', 'def', 'module'), kind
            if kind == 'module':
                result.append(s.strip())
            else:
                # Append the name following the class or def.
                i = g.skip_ws(s, 0)
                i += len(kind)
                i = g.skip_ws(s, i)
                j = g.skip_c_id(s, i)
                result.append(s[i: j])
        else:
            result.append('')
            break
    return reversed(result)
#@+node:ekr.20150609053010.1: *5* sd.format
def format(self, node, level, *args, **kwargs):
    """Return the formatted version of an Ast Node."""
    return self.formatter.format(node, level, *args, **kwargs).strip()
#@+node:ekr.20150606024455.62: *4* sd.visit
def visit(self, node):
    """
    Visit a *single* ast node. Visitors must visit their children
    explicitly.
    """
    method = getattr(self, 'do_' + node.__class__.__name__)
    method(node)

def visit_children(self, node):
    """Override to ensure this method is never called."""
    assert False, 'must visit children explicitly'
#@+node:ekr.20150609052952.1: *4* sd.Visitors
#@+node:ekr.20150607200422.1: *5* sd.Assign
def do_Assign(self, node):
    """Handle an assignment statement: Assign(expr* targets, expr value)"""
    value = self.format(self.visit(node.value), self.level)
    assign_tuples = []
    for target in node.targets:
        target = self.format(self.visit(target), self.level)
        s = '%s=%s' % (target, value)
        context2, context1 = self.context_names()
        assign_tuple = context2, context1, s
        assign_tuples.append(assign_tuple)
        aList = self.controller.assigns_d.get(target, [])
        aList.extend(assign_tuples)
        self.controller.calls_d[target] = aList
#@+node:ekr.20150607200439.1: *5* sd.AugAssign
def do_AugAssign(self, node):
    """
    Handle an augmented assignement:
    AugAssign(expr target, operator op, expr value).
    """
    target = self.format(self.visit(node.target), self.level)
    s = '%s=%s' % (target, self.format(self.visit(node.value), self.level))
    context2, context1 = self.context_names()
    assign_tuple = context2, context1, s
    aList = self.controller.assigns_d.get(target, [])
    aList.append(assign_tuple)
    self.controller.calls_d[target] = aList
#@+node:ekr.20150606024455.16: *5* sd.Call
def do_Call(self, node):
    """
    Handle a call statement:
    Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)
    """
    # Update data.
    s = self.format(node, self.level)
    name = self.format(node.func, self.level)
    context2, context1 = self.context_names()
    call_tuple = context2, context1, s
    aList = self.controller.calls_d.get(name, [])
    aList.append(call_tuple)
    self.controller.calls_d[name] = aList
    # Visit.
    self.visit(node.func)
    for z in node.args:
        self.visit(z)
    for z in node.keywords:
        self.visit(z)
    if getattr(node, 'starargs', None):
        self.visit(node.starargs)
    if getattr(node, 'kwargs', None):
        self.visit(node.kwargs)
#@+node:ekr.20150606024455.3: *5* sd.ClassDef
def do_ClassDef(self, node):
    """
    Handle a class defintion:
    ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)
    """
    # pylint: disable=arguments-differ
    # Format.
    if node.bases:
        bases = [self.format(z, self.level) for z in node.bases]
        s = 'class %s(%s):' % (node.name, ','.join(bases))
    else:
        s = 'class %s:' % node.name
    # Enter the new context.
    context_tuple = self.fn, 'class', s
    self.context_stack.append(context_tuple)
    # Update data.
    class_tuple = self.context_stack[: -1], s
    aList = self.controller.classes_d.get(node.name, [])
    aList.append(class_tuple)
    self.controller.classes_d[node.name] = aList
    # Visit.
    for z in node.bases:
        self.visit(z)
    for z in node.body:
        self.visit(z)
    for z in node.decorator_list:
        self.visit(z)
    # Leave the context.
    self.context_stack.pop()
#@+node:ekr.20150606024455.4: *5* sd.FunctionDef
def do_FunctionDef(self, node):
    """
    Visit a function defintion:
    FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
    """
    # pylint: disable=arguments-differ
    # Format.
    args = self.format(node.args, self.level) if node.args else ''
    s = 'def %s(%s):' % (node.name, args)
    # Enter the new context.
    context_tuple = self.fn, 'def', s
    self.context_stack.append(context_tuple)
    # Update data.
    def_tuple = self.context_stack[: -1], s
    aList = self.controller.defs_d.get(node.name, [])
    aList.append(def_tuple)
    self.controller.defs_d[node.name] = aList
    # Visit.
    for z in node.decorator_list:
        self.visit(z)
    self.visit(node.args)
    for z in node.body:
        self.visit(z)
    # Leave the context.
    self.context_stack.pop()
#@+node:ekr.20150606024455.55: *5* sd.Return
def do_Return(self, node):
    """Handle a 'return' statement: Return(expr? value)"""
    # Update data.
    s = self.format(node, self.level)
    context, name = self.context_names()
    aList = self.controller.returns_d.get(name, [])
    return_tuple = context, s
    aList.append(return_tuple)
    self.controller.returns_d[name] = aList
    # Visit.
    if node.value:
        self.visit(node.value)
#@+node:ekr.20171211163833.1: *3* class Stats
class Stats:
    """
    A basic statistics class.  Use this way:
        
        stats = Stats()
        stats.classes += 1
        stats.defs += 1
        stats.report()
    """

    d = {}
    
    def __getattr__(self, name):
        return self.d.get(name, 0)
        
    def __setattr__(self, name, val):
        self.d[name] = val
        
    def report(self):
        if self.d:
            n = max([len(key) for key in self.d])
            for key, val in sorted(self.d.items()):
                print('%*s: %s' % (n, key, val))
        else:
            print('no stats')
#@+node:ekr.20171211061816.1: *3* top-level test functions
#@+node:ekr.20150704135836.1: *4* testShowData (leoCheck.py)
def test(c, files):
    r"""
    A stand-alone version of @button show-data.  Call as follows:

        import leo.core.leoCheck as leoCheck
        files = (
            [
                # r'c:\leo.repo\leo-editor\leo\core\leoNodes.py',
            ] or
            leoCheck.ProjectUtils().project_files('leo')
        )
        leoCheck.test(files)
    """
    # pylint: disable=import-self
    import leo.core.leoCheck as leoCheck
    leoCheck.ShowData(c=c).run(files)
#@+node:ekr.20171211055756.1: *3* checkConventions (checkerCommands.py)
@g.command('check-conventions')
@g.command('cc')
def checkConventions(event):
    """Experimental script to test Leo's convensions."""
    c = event.get('c')
    if c:
        if c.changed: c.save()
        import importlib
        import leo.core.leoCheck as leoCheck
        importlib.reload(leoCheck)
        leoCheck.ConventionChecker(c).check()
#@+node:ekr.20200306045302.1: ** From leoImport.py
#@+node:ekr.20031218072017.3220: *3* ic.importFlattenedOutline (no longer used)
def importFlattenedOutline(self, files):  # Not a command, so no event arg.
    c = self.c; u = c.undoer
    if not c.p: return
    if not files: return
    self.setEncoding()
    fileName = files[0]  # files contains at most one file.
    g.setGlobalOpenDir(fileName)
    s, e = g.readFileIntoString(fileName)
    if s is None or not s.strip():
        return
    s = s.replace('\r', '')  # Fixes bug 626101.
    array = s.split("\n")
    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(c.p)
    # MORE files are more restrictive than tab-delimited outlines, so try them first.
    p = None
    c.endEditing()
    ###
        # importer = MORE_Importer(c)
        # if importer.check(s):
            # p = importer.import_lines(array, c.p)
    if not p:
        # Try to import a tab-delimited outline.
        importer = TabImporter(c)
        if importer.check(s, warn=False):
            p = importer.scan(s, fn=fileName, root=c.p)
    if p:
        c.validateOutline()
        p.setDirty()
        c.setChanged()
        u.afterInsertNode(p, 'Import', undoData)
        c.redraw(p)
    # elif not g.unitTesting:
        # g.es_print("not a valid MORE file", fileName)
#@+node:ekr.20200219073706.1: ** From leoTest.py
#@+node:ekr.20120220070422.10420: *3* Top-level functions (leoTest)
#@+node:ekr.20051104075904.97: *4* leoTest.py: factorial (a test of doctests)
# Some of these will fail now for Python 2.x.

def factorial(n):
    """Return the factorial of n, an exact integer >= 0.

    If the result is small enough to fit in an int, return an int.
    Else return a long.

    >>> [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    >>> factorial(30)
    265252859812191058636308480000000
    >>> factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be >= 0

    Factorials of floats are OK, but the float must be an exact integer:
    >>> factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    >>> factorial(30.0)
    265252859812191058636308480000000

    It must also not be ridiculously large:
    >>> factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """
    import math
    if not n >= 0:
        raise ValueError("n must be >= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n + 1 == n:  # catch a value like 1e300
        raise OverflowError("n too large")
    result = 1
    factor = 2
    while factor <= n:
        try:
            result *= factor
        except OverflowError:
            result = int(factor)
        factor += 1
    return result
#@+node:ekr.20200518051925.1: ** From leoKeys.py
#@+node:ekr.20171124074112.1: *3* c.executeAnyCommand (no longer used)
# def executeAnyCommand(self, command, event):
    # """Execute a command, no matter how defined."""
    # try:
        # return command(event)
    # except Exception:
        # g.es_exception()
        # return None
#@+node:ekr.20051106040126: *3* c.executeMinibufferCommand (no longer used)
def executeMinibufferCommand(self, commandName):
    c = self; k = c.k
    func = c.commandsDict.get(commandName)
    if func:
        event = g.app.gui.create_key_event(c)
        return k.masterCommand(commandName=None, event=event, func=func)
    g.error(f"no such command: {commandName} {g.callers()}")
    return None
#@+node:ekr.20170324143353.1: *3* k.commandExists (no longer used)
def commandExists(self, commandName):
    """
    Return the command handler for the given command name, or None.
    """
    ### This is supposed to allow for stuff after the command name.
    c, k = self.c, self
    commandName = commandName.strip()
    if not commandName:
        return None
    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]
    func = c.commandsDict.get(commandName)
    return func
#@+node:ekr.20200523081446.1: *3* k.doKeyOnlyTasks (new: no longer used)
def doKeyOnlyTasks(self, event):
    """
    Do keystroke-related tasks related to commands.
    
    Return True if we should ignore the event.
    """
    ### c, k = self.c, self
    k = self
    assert event, g.callers()
    ###if not event: g.trace('Can not happen: no event')
        
    ### ch, stroke = event.char, event.stroke
    assert event.stroke, g.callers()
    ###
        # if not event.stroke:
            # g.trace('Can not happen: no stroke')
            # return True
    ### # Ignore all special keys.
    assert not k.isSpecialKey(event), g.callers()
    ###
        # if k.isSpecialKey(event):
            # g.trace('\n===== Can not happen: k.isSpecial')
            # return True
    ###
        # Remember the key.
        # k.setLossage(ch, stroke)
    ### # Handle keyboard-quit.
    if k.abortAllModesKey and event.stroke == k.abortAllModesKey:
        g.trace('\n===== Can not happen: Ctrl-G')
        ### k.keyboardQuit()
        ### return True
        assert False, g.callers()
    ###
        # # Ignore abbreviations.
        # if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
            # return False
    return False
#@+node:ekr.20180418025702.1: *3* k.doUnboundPlainKey & helper (no longer used)
def doUnboundPlainKey(self, event):
    """
    Handle unbound plain keys.
    Return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke, w = event.stroke, event.widget
    #
    # Ignore non-plain keys.
    if not k.isPlainKey(stroke):
        return False
    #
    # Ignore any keys in the background tree widget.
    if c.widget_name(w).startswith('canvas'):
        return False
    #
    # Ignore the char if it is bound to the auto-complete command.
    if self.isAutoCompleteChar(stroke):
        return False
    #
    # Handle the unbound key.
    g.trace(event.stroke)
    k.handleUnboundKeys(event)
    return True
#@+node:ekr.20110209083917.16004: *4* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    """
    Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.
    """
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                bi = d.get(stroke)
                if bi:
                    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
                    if bi.commandName == 'auto-complete':
                        return True
    return False
#@+node:ekr.20061031131434.113: *3* k.endCommand (no longer used)
def endCommand(self, commandName):
    """Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    """
    k = self; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
        Do *not* call this by default.  It interferes with undo.
            # c.frame.body.onBodyChanged(undoType='Typing')
        
            # if k.newMinibufferWidget:
                # c.widgetWantsFocusNow(k.newMinibufferWidget)
                # # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
                # k.newMinibufferWidget = None
#@+node:ekr.20061031131434.110: *3* k.handleDefaultChar (no longer used)
def handleDefaultChar(self, event, stroke):
    """
    Handle an unbound key, based on the event's widget.
    Do not assume that stroke exists.
    """
    c, k, w = self.c, self, event.widget
    name = c.widget_name(w)
    #
    # Ignore unbound alt-ctrl key
    if stroke and stroke.isAltCtrl() and k.ignore_unbound_non_ascii_keys:
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
        return
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else:
            pass  # Ignore the key
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree.
    if name.startswith('canvas'):
        if not stroke:  # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event)
        return
    #
    # Handle events in the log pane.
    if name.startswith('log'):
        # Make sure we can insert into w.
        log_w = event.widget
        if not hasattr(log_w, 'supportsHighLevelInterface'):
            return
        # Send the event to the text widget, not the LeoLog instance.
        if not stroke:
            stroke = event.stroke
        if stroke:
            i = log_w.getInsertPoint()
            s = stroke.toGuiChar()
            log_w.insert(i, s)
        return
    #
    # Ignore all other events.
#@+node:ekr.20080510095819.1: *3* k.handleUnboundKeys (no longer used)
def handleUnboundKeys(self, event):
    """
    The last step of k.masterKeyHandler.
    Handle key events when no binding exists.
    """
    c, k = self.c, self
    stroke = event.stroke
    if not stroke:
        return
    # #1448: Very late special case for getArg state.
    #        This is not needed for other states.
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Handle a normal character in insert/overwrite.
    # <Return> is *not* a normal character.
    if (
        stroke and k.isPlainKey(stroke) and
        k.unboundKeyAction in ('insert', 'overwrite')
    ):
        c.insertCharFromEvent(event)
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
        c.insertCharFromEvent(event)
        return
    # #868
    if stroke.isNumPadKey():
        return  # To have effect, these must be bound.
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke or 'Insert' in stroke:
        return
    # Handle the unbound character.
    c.insertCharFromEvent(event)
#@+node:ekr.20061031131434.105: *3* k.masterCommand (no longer used)
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    """
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    
    Return the value returned by the command, or None if no command is executed.
    """
    c, k = self.c, self
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke  # Set this global for general use.
    ch = event.char if event else ''
    #
    # Ignore all special keys.
    if k.isSpecialKey(event):
        return None
    #
    # Compute func if not given.
    # It is *not* an error for func to be None.
    if commandName and not func:
        func = c.commandsDict.get(commandName.replace('&', ''))
        if not func:
            g.es_print(f"no command for @item {commandName!r}", color='red')
            return None
    commandName = commandName or func and func.__name__ or '<no function>'
    if 'keys' in g.app.debug:
        # A very important trace.
        g.trace(commandName, 'stroke', stroke)
    #
    # Remember the key.
    k.setLossage(ch, stroke)
    #
    # Handle keyboard-quit.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        k.keyboardQuit()
        return None
    #
    # Ignore abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
        return None
    #
    # Invoke the command, if given.
    if func:
        return_value = c.doCommand(func, commandName, event=event)
        if c.exists:
            c.frame.updateStatusLine()
        return return_value
    #
    # Ignore unbound keys in a state.
    if k.inState():
        return None
    #
    # Finally, call k.handleDefaultChar.
    k.handleDefaultChar(event, stroke)
    if c.exists:
        c.frame.updateStatusLine()
    return None
#@+node:ekr.20061031131434.200: *3* k.universalDispatcher & helpers (no longer used)
def universalDispatcher(self, event):
    """Handle accumulation of universal argument."""
    << about repeat counts >>
    k = self
    state = k.getState('u-arg')
    stroke = event.stroke if event else ''
    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg', 1, k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        char = event.char if event else ''
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L', 'Alt_R',
            'Control_L', 'Control_R',
            'Meta_L', 'Meta_R',
            'Shift_L', 'Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try: n = int(val) * k.repeatCount
            except ValueError: n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event, n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event, stroke)
#@+node:ekr.20061031131434.201: *4* << about repeat counts >>
@nocolor
@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@+node:ekr.20061031131434.202: *4* k.executeNTimes
def executeNTimes(self, event, n):

    c, k = self.c, self
    w = event and event.widget
    stroke = event.stroke if event else ''
    if not stroke: return
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        bi = k.getPaneBinding(stroke, event and event.widget)
        if bi:
            for z in range(n):
                event = g.app.gui.create_key_event(c, event=event, w=w)
                k.masterCommand(
                    commandName=None,
                    event=event,
                    func=bi.func,
                    stroke=stroke,
                )
        else:
            for z in range(n):
                k.masterKeyHandler(event)
#@+node:ekr.20061031131434.203: *4* doControlU
def doControlU(self, event, stroke):
    k = self
    ch = event.char if event else ''
    k.setLabelBlue(f"Control-u {g.stripBrackets(stroke)}")
    if ch == '(':
        k.clearState()
        k.resetLabel()
#@+node:ekr.20120208064440.10201: *3* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
#@+node:ekr.20200908101251.1: ** From leoApp.py
#@+node:ekr.20190826021428.1: *3* app.saveGlobalWindowState (no longer used)
def saveGlobalWindowState(self):
    """
    Save the window geometry and layout of dock widgets and toolbars
    for Leo's *global* QMainWindow.
    
    Called by g.app.finishQuit. 
    """
    return ###
    trace = any([z in g.app.debug for z in ('dock', 'cache', 'size', 'startup')])
    if not g.app.dock:
        if trace: g.trace('g.app.dock is False')
        return
    main_window = getattr(g.app.gui, 'main_window', None)
    if not main_window:
        if trace:
            if hasattr(g.app.gui, 'main_window'):
                g.trace('g.app.gui.main_window is None')
            else:
                g.trace('no ivar: g.app.gui.main_window')
        return
    #
    # Save the state
    key = 'globalWindowState:'
    val = main_window.saveState()
        # Method is a QMainWindow method.
    try:
        val = bytes(val)  # PyQt4
    except Exception:
        val = bytes().join(val)  # PySide
    if trace: g.trace(f"set key: {key}:")
    g.app.db[key] = base64.encodebytes(val).decode('ascii')
#@+node:ekr.20190826022349.1: *3* app.restoreGlobalWindowState (no longer used)
def restoreGlobalWindowState(self):
    """
    Restore the layout of global dock widgets and toolbars.
    """
    #
    # Note for #1189: The windows has already been properly resized
    #                 by the time this method is called.
    trace = any([z in g.app.debug for z in ('dock', 'cache', 'size', 'startup')])
    if not g.app.dock:
        if trace: g.trace('g.app.dock is False')
        return
    main_window = getattr(g.app.gui, 'main_window', None)
    if not main_window:
        if trace:
            if hasattr(g.app.gui, 'main_window'):
                g.trace('g.app.gui.main_window is None')
            else:
                g.trace('no ivar: g.app.gui.main_window')
        return
    g.trace('===== g.app.gui.main_window', main_window)
    return ###
    #
    # Support --init-docks.
    # #1196. Let Qt use it's own notion of a default layout.
    #        This should work regardless of the central widget.
    if g.app.init_docks:
        if trace: g.trace('--init-docks')
        return
    key = 'globalWindowState:'
    val = self.db.get(key)
    if val:
        if trace: g.trace(f"found key: {key}")
        try:
            val = base64.decodebytes(val.encode('ascii'))
                # Elegant pyzo code.
            main_window.restoreState(val)
            return
        except Exception as err:
            g.trace(f"bad value: {key} {err}")
            return
    # This is not an error.
    if trace: g.trace(f"missing key: {key}")
#@+node:ekr.20200915114300.1: ** ----- Deleted qt docks code
#@+node:ekr.20200303094809.1: *3*  function:dock_widget
def dock_widget(w):
    """Return the dock widget containing widget w."""
    while w:
        if isinstance(w, QtWidgets.QDockWidget):
            return w
        w = w.parent()
    return None
#@+node:ekr.20200303104851.1: *3* 'hide-body-dock'
@g.command('hide-body-dock')
def hideBodyDock(event):
    '''Hide the Body dock'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.body.widget
    dock = dock_widget(w)
    if dock:
        dock.hide()
#@+node:ekr.20200303105224.1: *3* 'hide-outline-dock'
@g.command('hide-outline-dock')
def hideOutlineDock(event):
    '''Hide the Outline dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.tree.treeWidget
    dock = dock_widget(w)
    if dock:
        dock.hide()
#@+node:ekr.20200303105106.1: *3* 'hide-tabs-dock'
@g.command('hide-tabs-dock')
def hideTabsDock(event):
    '''Hide the Tabs dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.log.logWidget
    dock = dock_widget(w)
    if dock:
        dock.hide()
#@+node:ekr.20200303105513.1: *3* 'show-body-dock'
@g.command('show-body-dock')
def showBodyDock(event):
    '''Show the Body dock'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.body.widget
    dock = dock_widget(w)
    if dock:
        dock.show()
#@+node:ekr.20200303105712.1: *3* 'show-outline-dock'
@g.command('show-outline-dock')
def showOutlineDock(event):
    '''Show the Outline dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.tree.treeWidget
    dock = dock_widget(w)
    if dock:
        dock.show()
#@+node:ekr.20200303105622.1: *3* 'show-tabs-dock'
@g.command('show-tabs-dock')
def showTabsDock(event):
    '''Show the Tabs dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.log.logWidget
    dock = dock_widget(w)
    if dock:
        dock.show()
#@+node:ekr.20200305102656.1: *3* app.restoreEditorDockState
def restoreEditorDockState(self, c):

    trace = any([z in g.app.debug for z in ('dock', 'select')]) and not g.app.unitTesting
    tag = 'app.restoreEditorDockState'
    body = c.frame.body
    dw = c.frame.top
    if not dw:
        return
    aps_s= c.db.get('added_editor_aps', '')
    dock_names_s = c.db.get('added_editor_docks', '')
    if not aps_s or not dock_names_s:
        return
    aps = aps_s.split(';')
    dock_names = dock_names_s.split(';')
    if len(aps) != len(dock_names):
        g.trace('can not happen')
        return
    if trace: g.trace('START')
    #
    # #1527: Part 1: Inject leo_wrapper ivar.
    #                Similar to LeoQtBody.injectIvars.
    wrapper = body.wrapper
    w = wrapper.widget
    w.leo_wrapper = wrapper
    if trace:
        print(f"{tag:>30}: {wrapper} <dock for main body>")
    #
    # #1527: Part 2: Pack the Body's label so it tracks p.h.
    #                Similar to code for the 'add-editor' command.
    if body.use_gutter:
        dw.packLabel(w.parent(), n=1)
        w.leo_label = w.parent().leo_label
    else:
        dw.packLabel(w, n=1)
    #
    # Restore all *added* editors.
    d = body.editorWrappers
    for i, dock_name in enumerate(dock_names):
        ap = aps[i]
        f, wrapper = dw.addNewEditor(dock_name)
        d[dock_name] = wrapper
        p = c.archivedPositionToPosition(ap)
        body.injectIvars(
            parentFrame = f,
            name = dock_name,
            p = p,
            wrapper = wrapper,
        )
        w =  c.frame.body.wrapper.widget
        body.updateInjectedIvars(w, p)
        body.selectLabel(wrapper)
        body.selectEditor(wrapper)
        if trace:
            print(f"{tag:>30}: {wrapper} {dock_name}")
    if trace: g.trace('END')
#@+node:ekr.20190528045549.1: *3* app.restoreWindowState
ekr_val = None

def restoreWindowState(self, c):
    """
    Restore the layout of dock widgets and toolbars, using the per-file
    state of the *first* loaded .leo file, or the global state.
    
    Note: The window's position or size has already been restored.
    """
    trace = any([z in g.app.debug for z in ('dock', 'cache', 'size', 'startup')])
    tag = 'app.restoreWindowState:'
    if not g.app.dock:
        if trace: g.trace('g.app.dock is False')
        return
    dw = c.frame.top
    if not dw or not hasattr(dw, 'restoreState'):
        if trace: g.trace('no dw.restoreState. dw:', repr(dw))
        return
    # First, restore the editor state.
    self.restoreEditorDockState(c)
    #
    # Support --init-docks.
    # #1196. Let Qt use it's own notion of a default layout.
    #        This should work regardless of the central widget.
    if g.app.init_docks:
        if trace: g.trace('using qt default layout')
        return
    sfn = c.shortFileName()
    table = (
        # First, try the per-outline state.
        (f"windowState:{c.fileName()}", dw.restoreState),
        # Restore the actual window state.
        ('windowState:', dw.restoreState),
    )
    for key, method in table:
        val = self.db.get(key)
        if val:
            if trace:
                g.trace(f"{sfn} found key: {key}")
            try:
                val = base64.decodebytes(val.encode('ascii'))
                    # Elegant pyzo code.
                method(val)
                return
            except Exception as err:
                g.trace(f"{sfn} bad value: {key} {err}")
        # This is not an error.
        elif trace:
            g.trace(f"{sfn} missing key: {key}")
    #
    # #1190 (bad initial layout)
    # Use a pre-defined layout (magic number).
    # The print-window-state prints this magic number for a *given* layout.
    # But this number will work *only* if the central widgets match.
    try:
        central_widget = self.get_central_widget(c)
        # central_widget = c.config.getString('central-dock-widget')
        # if central_widget:
            # central_widget = central_widget.lower()
        if central_widget in (None, 'outline'):
            if trace:
                print(tag, 'using app.defaultWindowState')
            dw.restoreState(self.defaultWindowState)
        elif trace:
            print(tag)
            print('central widget does not match default')
            print('using qt default window state')
        # See print-window-state.
    except Exception:
        g.es_print(tag, 'unexpected exception setting window state')
        g.es_exception()
#@+node:ekr.20190528045643.1: *3* app.saveWindowState
def saveWindowState(self, c):
    """
    Save the window geometry and layout of dock widgets and toolbars.
    
    This is called for all closed windows.
    """
    trace = any([z in g.app.debug for z in ('dock', 'cache', 'size', 'startup')])
    if not g.app.dock:
        if trace: g.trace('g.app.dock is False')
        return
    dw = c.frame.top
    if not dw or not hasattr(dw, 'saveState'):
        if trace: g.trace('no dw.saveState. dw:', repr(dw))
        return
    table = (
        # Save a default *global* state, for *all* outline files.
        ('windowState:', dw.saveState),
        # Save a per-file state.
        (f"windowState:{c.fileName()}", dw.saveState),
        # Do not save/restore window geometry. That is done elsewhere.
            # (f"windowGeometry:{c.fileName()}" , dw.saveGeometry),
    )
    for key, method in table:
        # This is pyzo code...
        val = method()
            # Method is a QMainWindow method.
        try:
            val = bytes(val)  # PyQt4
        except Exception:
            val = bytes().join(val)  # PySide
        val = base64.encodebytes(val).decode('ascii')
        if trace:
            g.trace(f"{c.shortFileName()} set key: {key}")         
        g.app.db[key] = val
#@+node:ekr.20190523115826.1: *3* dw.addEditorDock
added_bodies = 0

def addEditorDock(self, closeable=True, moveable=True):
    """Add an editor dock"""
    #
    # Create the new dock.
    dw, c = self, self.leo_c
    dw.added_bodies += 1
    dock = g.app.gui.create_dock_widget(
        closeable=closeable,
        moveable=moveable,
        height=50,
        name=c.p.h,
    )
    dw.added_editor_docks.append(dock)
    w = dw.createBodyPane(parent=None)
    dock.setWidget(w)
    dw.splitDockWidget(dw.body_dock, dock, QtCore.Qt.Horizontal)
    #
    # monkey-patch dock.closeEvent

    def patched_closeEvent(event=None):
        c.frame.body.delete_editor_command(event, dock=dock)

    dock.closeEvent = patched_closeEvent
    return dock
#@+node:ekr.20190522165123.1: *3* dw.createAllDockWidgets
def createAllDockWidgets(self):
    """Create all the dock widgets."""
    c, dw = self.leo_c, self
    #
    # Compute constants.
    Qt = QtCore.Qt
    bottom, top = Qt.BottomDockWidgetArea, Qt.TopDockWidgetArea
    lt, rt = Qt.LeftDockWidgetArea, Qt.RightDockWidgetArea
    g.placate_pyflakes(bottom, lt, rt, top)
    #
    # Create all the docks.
    central_widget = g.app.get_central_widget(c)
    dockable = c.config.getBool('dockable-log-tabs', default=False)
    table = [
        (True, 50, lt, 'outline', dw.createOutlineDock),  # was 100: #1339.
        (True, 50, bottom, 'body', dw.createBodyPane),  # was 100: #1339.
        (True, 50, rt, 'tabs', dw.createTabsDock),  # was 20: #1339.
        (dockable, 20, rt, 'find', dw.createFindDockOrTab),
        (dockable, 20, rt, 'spell', dw.createSpellDockOrTab),
    ]
    for make_dock, height, area, name, creator in table:
        w = creator(parent=None)
        if not make_dock:
            setattr(dw, f"{name}_dock", None)
            continue
        dock = g.app.gui.create_dock_widget(
            closeable=name != central_widget,
            moveable=name != central_widget,
            height=0,
            name=name)
        dock.setWidget(w)
        # Remember the dock.
        setattr(dw, f"{name}_dock", dock)
        if name == central_widget:
            dw.setCentralWidget(dock)
                # Important: the central widget should be a dock.
            dock.show()  # #1327.
        else:
            dw.addDockWidget(area, dock)
    #
    # Create minibuffer.
    bottom_toolbar = QtWidgets.QToolBar(dw)
    bottom_toolbar.setObjectName('minibuffer-toolbar')
    bottom_toolbar.setWindowTitle('Minibuffer')
    dw.addToolBar(Qt.BottomToolBarArea, bottom_toolbar)
    w = dw.createMiniBuffer(bottom_toolbar)
    bottom_toolbar.addWidget(w)
    #
    # Create other widgets...
    dw.createMenuBar()
    dw.createStatusBar(dw)
#@+node:ekr.20190527120808.1: *3* dw.createFindDockOrTab
def createFindDockOrTab(self, parent):
    """Create a Find dock or tab in the Log pane."""
    assert g.app.dock
    assert not parent, repr(parent)
    c = self.leo_c
    #
    # Create widgets.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    #
    # For LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Create a tab in the log Dock, if necessary.
    if not c.config.getBool('dockable-log-tabs', default=False):
        self.tabWidget.addTab(findScrollArea, 'Find')
    return findScrollArea
#@+node:ekr.20190528112002.1: *3* dw.createOutlineDock
def createOutlineDock(self, parent):
    """Create the widgets and ivars for Leo's outline."""
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
#@+node:ekr.20190527120829.1: *3* dw.createSpellDockOrTab
def createSpellDockOrTab(self, parent):
    """Create a Spell dock  or tab in the Log pane."""
    assert g.app.dock
    assert not parent, repr(parent)
    c = self.leo_c
    #
    # Create an outer widget.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('docked.spellTab')
    #
    # Create the contents.
    self.createSpellTab(spellTab)
    #
    # Create the Spell tab in the Log dock, if necessary.
    if not c.config.getBool('dockable-log-tabs', default=False):
        tabWidget = self.tabWidget
        tabWidget.addTab(spellTab, 'Spell')
        tabWidget.setCurrentIndex(1)
    return spellTab
#@+node:ekr.20190527163203.1: *3* dw.createTabbedLogDock
def createTabbedLogDock(self, parent):
    """Create a tabbed (legacy) Log dock."""
    assert g.app.dock
    assert not parent, repr(parent)
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    # Fix #516:
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if not use_minibuffer and not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Do this later, in LeoFind.finishCreate
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
    return logFrame
#@+node:ekr.20190527121112.1: *3* dw.createTabsDock
def createTabsDock(self, parent):
    """Create the Tabs dock."""
    assert g.app.dock
    assert not parent, repr(parent)
    #
    # Create the log contents
    logFrame = self.createFrame(None, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack. This *is* required.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
    return logFrame
#@+node:ekr.20190724172314.1: *3* qt: show-hide-body-dock
@g.command('show-hide-body-dock')
def show_hide_body_dock(event):
    """Show or hide the Tabs dock."""
    c = event.get('c')
    dw = c and c.frame.top
    if not dw:
        return
    if not g.app.dock:
        g.es('this command requires docks')
        return
    dock = dw.body_dock
    if not dock:
        return
    if g.app.get_central_widget(c) == 'body':
        g.es('can not hide the central dock widget')
        return
    if dock.isVisible():
        dock.hide()
    else:
        dock.show()
#@+node:ekr.20190724172258.1: *3* qt: show-hide-outline-dock
@g.command('show-hide-outline-dock')
def show_hide_outline_dock(event):
    """Show or hide the Outline dock."""
    c = event.get('c')
    dw = c and c.frame.top
    if not dw:
        return
    if not g.app.dock:
        g.es('this command requires docks')
        return
    dock = dw.outline_dock
    if not dock:
        return
    if g.app.get_central_widget(c) == 'outline':
        g.es('can not hide the central dock widget')
        return
    if dock.isVisible():
        dock.hide()
    else:
        dock.show()
#@+node:ekr.20190724172547.1: *3* qt: show-hide-render-dock
@g.command('show-hide-render-dock')
def show_hide_render_dock(event):
    """Show or hide the Tabs dock."""
    c = event.get('c')
    dw = c and c.frame.top
    if not dw:
        return
    if not g.app.dock:
        g.es('this command requires docks')
        return
    pc = g.app.pluginsController
    vr = pc.getPluginModule('leo.plugins.viewrendered')
    x = vr and vr.controllers.get(c.hash())
    dock = x and x.leo_dock
    if not dock:
        return
    if dock.isVisible():
        dock.hide()
    else:
        dock.show()
#@+node:ekr.20190724170436.1: *3* qt: show-hide-tabs-dock
@g.command('show-hide-tabs-dock')
def show_hide_tabs_dock(event):
    """Show or hide the Tabs dock."""
    c = event.get('c')
    dw = c and c.frame.top
    if not dw:
        return
    if not g.app.dock:
        g.es('this command requires docks')
        return
    dock = dw.tabs_dock
    if not dock:
        return
    if g.app.get_central_widget(c) == 'tabs':
        g.es('can not hide the central dock widget')
        return
    if dock.isVisible():
        dock.hide()
    else:
        dock.show()
#@+node:ekr.20190819091950.1: *3* qt_gui.create_dock_widget
total_docks = 0

def create_dock_widget(self, closeable, moveable, height, name):
    """Make a new dock widget in the main window"""
    dock = QtWidgets.QDockWidget(parent=self.main_window)
        # The parent must be a QMainWindow.
    features = dock.DockWidgetFloatable  # #1643.
    # #1643: Widgets are fixed unless --init-docks is in effect
    if moveable and g.app.init_docks:
        features |= dock.DockWidgetMovable
    if closeable:
        features |= dock.DockWidgetClosable
    dock.setFeatures(features)
    dock.setMinimumHeight(height)
    dock.setObjectName(f"dock-{self.total_docks}")
    self.total_docks += 1
    if name:
        dock.setWindowTitle(name.capitalize())
    else:
        # #1527. Suppress the title.
        w = QtWidgets.QWidget()
        dock.setTitleBarWidget(w)
    # #1327: frameFactory.createFrame now ensures that the main window is visible.
    return dock
#@+node:ekr.20200305075130.1: *3* qt_gui.find_dock
def find_dock(self, w):
    """return the QDockWidget containing w, or None"""
    dock = w
    while dock and not isinstance(dock, QtWidgets.QDockWidget):
        dock = dock.parent()
    return dock
#@+node:ekr.20190822113212.1: *3* qt_gui.make_global_outlines_dock
def make_global_outlines_dock(self):
    """
    Create the top-level Outlines (plural) dock,
    containing the 
    The dock's widget will be set later.
    """
    main_window = self.main_window
    # For now, make it the central widget.
    is_central = True
    dock = self.create_dock_widget(
        closeable=not is_central,
        moveable=not is_central,
        height=50,  # was 100: #1339.
        name='',  # #1527: was 'Leo Outlines'
    )
    if is_central:
        main_window.setCentralWidget(dock)
    else:
        area = QtCore.Qt.BottomDockWidgetArea
        main_window.addDockWidget(area, dock)
    return dock
#@+node:ekr.20200915153200.1: *3* from << LeoApp: global data >>
    self.defaultWindowState = b'\x00\x00\x00\xff\x00\x00\x00\x00\xfd\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x01\x19\x00\x00\x01^\xfc\x02\x00\x00\x00\x01\xfb\x00\x00\x00\x12\x00d\x00o\x00c\x00k\x00.\x00t\x00a\x00b\x00s\x01\x00\x00\x006\x00\x00\x01^\x00\x00\x00\x1b\x00\xff\xff\xff\x00\x00\x00\x03\x00\x00\x03\x1e\x00\x00\x00\xc3\xfc\x01\x00\x00\x00\x02\xfb\x00\x00\x00\x12\x00d\x00o\x00c\x00k\x00.\x00b\x00o\x00d\x00y\x01\x00\x00\x00\x00\x00\x00\x01\xfd\x00\x00\x001\x00\xff\xff\xff\xfb\x00\x00\x00\x16\x00d\x00o\x00c\x00k\x00.\x00R\x00e\x00n\x00d\x00e\x00r\x01\x00\x00\x02\x05\x00\x00\x01\x19\x00\x00\x001\x00\xff\xff\xff\x00\x00\x01\xfd\x00\x00\x01^\x00\x00\x00\x04\x00\x00\x00\x04\x00\x00\x00\x08\x00\x00\x00\x08\xfc\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x10\x00i\x00c\x00o\x00n\x00-\x00b\x00a\x00r\x01\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x01\x00\x00\x00$\x00m\x00i\x00n\x00i\x00b\x00u\x00f\x00f\x00e\x00r\x00-\x00t\x00o\x00o\x00l\x00b\x00a\x00r\x01\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00'
        #
        # For self.restoreWindowState the first time Leo is run.
        # Use the print-window-state to print this value after arranging the docks to your liking.
        # Important: the outline-pane *must* be the central widget.
#@+node:ekr.20200915153256.1: *3* from dw.addNewEditor
    #
    # Create dock, splitting the body dock.
    dock = self.addEditorDock()
    #
    # Create the editor
    widget = qt_text.LeoQTextBrowser(None, c, self)
    widget.setObjectName('richTextEdit')
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Inject ivars, set bindings, etc.
    inner_frame = self.leo_body_inner_frame
        # Inject ivars *here*, regardless of docking.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    return dock, wrapper
#@+node:ekr.20200915153424.1: *3* from dw.createBodyFrame
    #
    # Create widgets.
    #
    # bodyFrame has a VGridLayout.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    #
    # innerFrame has a VBoxLayout.
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    box = self.createVLayout(innerFrame, 'bodyVLayout', spacing=0)
    #
    # Pack the body alone or *within* a LeoLineTextWidget.
    body = self.createText(None, 'richTextEdit')  # A LeoQTextBrowser
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        box.addWidget(lineWidget)
    else:
        box.addWidget(body)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Official ivars
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
#@+node:ekr.20200915153609.1: *3* from dw.setMainWindowOptions
    dw.setDockNestingEnabled(False)
    dw.setDockOptions(
        QtWidgets.QMainWindow.AllowTabbedDocks |
        QtWidgets.QMainWindow.AnimatedDocks)
#@+node:ekr.20200915153647.1: *3* from LeoQtBody.delete_editor_command
    #
    # Sanity checks.
    if not dock:
        dock = w.parent().parent()
        if (getattr(w, 'leo_name', None) == '1' or
            not isinstance(dock, QtWidgets.QDockWidget)
        ):
            g.warning('can not delete main editor')
            return
    #
    # Actually delete the dock.
    if dock in dw.added_editor_docks:
        dw.added_editor_docks.remove(dock)
    dw.removeDockWidget(dock)
        # A QMainWidget method.
    #
    # Select another editor.
    w.leo_label = None
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    self.selectEditor(new_wrapper)
#@+node:ekr.20200915153720.1: *3* from LeoQtLog.createTab
        if g.app.dock and c.config.getBool('dockable-log-tabs', default=False):
            # #1154: Support docks in the Log pane.
            dw = c.frame.top
            dock = g.app.gui.create_dock_widget(
                closeable=True, moveable=True, height=50, name=tabName)  # was 100: #1339.
                    # #1207: all plugins docks should be closeable.
            dock.setWidget(contents)
            area = QtCore.Qt.RightDockWidgetArea
            dw.addDockWidget(area, dock)
        else:
#@+node:ekr.20200915153758.1: *3* from LeoQtBody.select/unselectLabel
        if isinstance(label, QtWidgets.QDockWidget):
            # #1517.
            label.setWindowTitle(c.p.h)
        el
#@+node:ekr.20180606035619.1: *3* Recent files
#@+node:ekr.20031218072017.2608: *4* @file leoApp.py
@first # -*- coding: utf-8 -*-
<< imports >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20120219194520.10463: *5* << imports >> (leoApp)
import leo.core.leoGlobals as g
import leo.core.leoExternalFiles as leoExternalFiles
import importlib
import io
StringIO = io.StringIO
import os
import optparse
import subprocess
import string
import sys
import time
import traceback
import zipfile
import platform
import sqlite3
#@+node:ekr.20161026122804.1: *5* class IdleTimeManager
class IdleTimeManager:
    """
    A singleton class to manage idle-time handling. This class handles all
    details of running code at idle time, including running 'idle' hooks.

    Any code can call g.app.idleTimeManager.add_callback(callback) to cause
    the callback to be called at idle time forever.
    """

    def __init__(self):
        """Ctor for IdleTimeManager class."""
        self.callback_list = []
        self.timer = None
    @others
#@+node:ekr.20161026125611.1: *6* itm.add_callback
def add_callback(self, callback):
    """Add a callback to be called at every idle time."""
    self.callback_list.append(callback)
#@+node:ekr.20161026124810.1: *6* itm.on_idle
on_idle_count = 0

def on_idle(self, timer):
    """IdleTimeManager: Run all idle-time callbacks."""
    if not g.app: return
    if g.app.killed: return
    if not g.app.pluginsController:
        g.trace('No g.app.pluginsController', g.callers())
        timer.stop()
        return  # For debugger.
    self.on_idle_count += 1
    # Handle the registered callbacks.
    for callback in self.callback_list:
        try:
            callback()
        except Exception:
            g.es_exception()
            g.es_print(f"removing callback: {callback}")
            self.callback_list.remove(callback)
    # Handle idle-time hooks.
    g.app.pluginsController.on_idle()
#@+node:ekr.20161028034808.1: *6* itm.start
def start(self):
    """Start the idle-time timer."""
    self.timer = g.IdleTime(
        self.on_idle,
        delay=500,
        tag='IdleTimeManager.on_idle')
    if self.timer:
        self.timer.start()
#@+node:ekr.20120209051836.10241: *5* class LeoApp
class LeoApp:
    """A class representing the Leo application itself.

    Ivars of this class are Leo's global variables."""
    @others
#@+node:ekr.20150509193643.1: *6* app.Birth & startup
#@+node:ekr.20031218072017.1416: *7* app.__init__ (helpers contain language dicts)
def __init__(self):
    """
    Ctor for LeoApp class. These ivars are Leo's global vars.

    leoGlobals.py contains global switches to be set by hand.
    """
    << LeoApp: command-line arguments >>
    << LeoApp: Debugging & statistics >>
    << LeoApp: error messages >>
    << LeoApp: global directories >>
    << LeoApp: global data >>
    << LeoApp: global controller/manager objects >>
    << LeoApp: global reader/writer data >>
    << LeoApp: global status vars >>
    << LeoApp: the global log >>
    << LeoApp: global theme data >>
    << LeoApp: global types >>
    << LeoApp: plugins and event handlers >>
    << LeoApp: scripting ivars >>
    << LeoApp: unit testing ivars >>
    # Define all global data.
    self.init_at_auto_names()
    self.init_at_file_names()
    self.define_global_constants()
    self.define_language_delims_dict()
    self.define_language_extension_dict()
    self.define_extension_dict()
    self.define_delegate_language_dict()
#@+node:ekr.20161028035755.1: *8* << LeoApp: command-line arguments >>
self.batchMode = False
    # True: run in batch mode.
self.debug = []
    # A list of switches to be enabled.
self.diff = False
    # True: run Leo in diff mode.
self.enablePlugins = True
    # True: run start1 hook to load plugins. --no-plugins
self.failFast = False
    # True: Use the failfast option in unit tests.
self.gui = None
    # The gui class.
self.guiArgName = None
    # The gui name given in --gui option.
self.ipython_inited = False
    # True if leoIpython.py imports succeeded.
self.isTheme = False
    # True: load files as theme files (ignore myLeoSettings.leo).
self.listen_to_log_flag = False
    # True: execute listen-to-log command.
self.qt_use_tabs = False
    # True: using qt gui: allow tabbed main window.
self.loaded_session = False
    # Set by startup logic to True if no files specified on the command line.
self.silentMode = False
    # True: no signon.
self.start_fullscreen = False
    # For qt_frame plugin.
self.start_maximized = False
    # For qt_frame plugin.
self.start_minimized = False
    # For qt_frame plugin.
self.trace_binding = None
    # The name of a binding to trace, or None.
self.trace_setting = None
    # The name of a setting to trace, or None.
self.translateToUpperCase = False
    # Never set to True.
self.useIpython = False
    # True: add support for IPython.
self.use_psyco = False
    # True: use psyco optimization.
self.use_splash_screen = True
    # True: put up a splash screen.
#@+node:ekr.20161028035835.1: *8* << LeoApp: Debugging & statistics >>
self.count = 0
    # General purpose debugging count.
self.debug_dict = {}
    # For general use.
self.disable_redraw = False
    # True: disable all redraws.
self.disableSave = False
    # May be set by plugins.
self.idle_timers = []
    # A list of IdleTime instances, so they persist.
self.log_listener = None
    # The process created by the 'listen-for-log' command.
self.positions = 0
    # The number of positions generated.
self.scanErrors = 0
    # The number of errors seen by g.scanError.
self.structure_errors = 0
    # Set by p.safeMoveToThreadNext.
self.statsDict = {}
    # dict used by g.stat, g.clear_stats, g.print_stats.
self.statsLockout = False
    # A lockout to prevent unbound recursion while gathering stats.
self.validate_outline = False
    # True: enables c.validate_outline. (slow)
#@+node:ekr.20161028035902.1: *8* << LeoApp: error messages >>
self.menuWarningsGiven = False
    # True: supress warnings in menu code.
self.unicodeErrorGiven = True
    # True: suppres unicode tracebacks.
#@+node:ekr.20161028035924.1: *8* << LeoApp: global directories >>
self.extensionsDir = None
    # The leo/extensions directory
self.globalConfigDir = None
    # leo/config directory
self.globalOpenDir = None
    # The directory last used to open a file.
self.homeDir = None
    # The user's home directory.
self.homeLeoDir = None
    # The user's home/.leo directory.
self.loadDir = None
    # The leo/core directory.
self.machineDir = None
    # The machine-specific directory.
#@+node:ekr.20161028035956.1: *8* << LeoApp: global data >>
self.atAutoNames = set()
    # The set of all @auto spellings.
self.atFileNames = set()
    # The set of all built-in @<file> spellings.

self.globalKillBuffer = []
    # The global kill buffer.
self.globalRegisters = {}
    # The global register list.
self.leoID = None
    # The id part of gnx's.
self.loadedThemes = []
    # List of loaded theme.leo files.
    # This is used by the 'new' command.
self.lossage = []
    # List of last 100 keystrokes.
self.paste_c = None
    # The commander that pasted the last outline.
self.spellDict = None
    # The singleton PyEnchant spell dict.
self.numberOfUntitledWindows = 0
    # Number of opened untitled windows.
self.windowList = []
    # Global list of all frames.
self.realMenuNameDict = {}
    # Translations of menu names.
#@+node:ekr.20161028040028.1: *8* << LeoApp: global controller/manager objects >>
# Most of these are defined in initApp.
self.backgroundProcessManager = None
    # The singleton BackgroundProcessManager instance.
self.commander_cacher = None
    # The singleton leoCacher.CommanderCacher instance.
self.commander_db = None
    # The singleton db, managed by g.app.commander_cacher.
self.config = None
    # The singleton leoConfig instance.
self.db = None
    # The singleton global db, managed by g.app.global_cacher.
self.externalFilesController = None
    # The singleton ExternalFilesController instance.
self.global_cacher = None
    # The singleton leoCacher.GlobalCacher instance.
self.idleTimeManager = None
    # The singleton IdleTimeManager instance.
self.ipk = None
    # python kernel instance
self.loadManager = None
    # The singleton LoadManager instance.
# self.logManager = None
    # The singleton LogManager instance.
# self.openWithManager = None
    # The singleton OpenWithManager instance.
self.nodeIndices = None
    # The singleton nodeIndices instance.
self.pluginsController = None
    # The singleton PluginsManager instance.
self.sessionManager = None
    # The singleton SessionManager instance.
# The Commands class...
self.commandName = None
    # The name of the command being executed.
self.commandInterruptFlag = False
    # True: command within a command.
#@+node:ekr.20170302075110.1: *8* << LeoApp: global reader/writer data >>
# From leoAtFile.py.
self.atAutoWritersDict = {}
self.writersDispatchDict = {}
# From leoImport.py
self.atAutoDict = {}
    # Keys are @auto names, values are scanner classes.
self.classDispatchDict = {}
#@+node:ekr.20161028040054.1: *8* << LeoApp: global status vars >>
self.already_open_files = []
    # A list of file names that *might* be open in another
    # copy of Leo.
self.dragging = False
    # True: dragging.
# self.allow_delayed_see = False
    # True: pqsh.reformat_blocks_helper calls w.seeInsertPoint
self.inBridge = False
    # True: running from leoBridge module.
self.inScript = False
    # True: executing a script.
self.initing = True
    # True: we are initiing the app.
self.initComplete = False
    # True: late bindings are not allowed.
self.killed = False
    # True: we are about to destroy the root window.
self.openingSettingsFile = False
    # True, opening a settings file.
self.preReadFlag = False
    # True: we are pre-reading a settings file.
self.quitting = False
    # True: quitting.  Locks out some events.
self.reverting = False
    # True: executing the revert command.
self.syntax_error_files = []
#@+node:ekr.20161028040141.1: *8* << LeoApp: the global log >>
# To be moved to the LogManager.
self.log = None
    # The LeoFrame containing the present log.
self.logInited = False
    # False: all log message go to logWaiting list.
self.logIsLocked = False
    # True: no changes to log are allowed.
self.logWaiting = []
    # List of tuples (s, color, newline) waiting to go to a log.
self.printWaiting = []
    # Queue of messages to be sent to the printer.
self.signon = ''
self.signon1 = ''
self.signon2 = ''
#@+node:ekr.20180319152119.1: *8* << LeoApp: global theme data >>
self.theme_directory = None
    # The directory from which the theme file was loaded, if any.
    # Set only by LM.readGlobalSettingsFiles.
    # Used by the StyleSheetManager class.

# Not necessary **provided** that theme .leo files
# set @string theme-name to the name of the .leo file.
if 0:
    self.theme_color = None
    self.theme_name = None
#@+node:ekr.20161028040204.1: *8* << LeoApp: global types >>
import leo.core.leoFrame as leoFrame
import leo.core.leoGui as leoGui
self.nullGui = leoGui.NullGui()
self.nullLog = leoFrame.NullLog()
#@+node:ekr.20161028040229.1: *8* << LeoApp: plugins and event handlers >>
self.hookError = False
    # True: suppress further calls to hooks.
    # g.doHook sets g.app.hookError on all exceptions.
    # Scripts may reset g.app.hookError to try again.
self.hookFunction = None
    # Application wide hook function.
self.idle_time_hooks_enabled = True
    # True: idle-time hooks are enabled.
#@+node:ekr.20161028040303.1: *8* << LeoApp: scripting ivars >>
self.searchDict = {}
    # For communication between find/change scripts.
self.scriptDict = {}
    # For use by scripts. Cleared before running each script.
self.scriptResult = None
    # For use by leoPymacs.
self.permanentScriptDict = {}
    # For use by scrips. Never cleared automatically.
#@+node:ekr.20161028040330.1: *8* << LeoApp: unit testing ivars >>
self.isExternalUnitTest = False
    # True: we are running a unit test externally.
self.runningAllUnitTests = False
    # True: we are running all unit tests (Only for local tests).
self.suppressImportChecks = False
    # Used only in basescanner.py
    # True: suppress importCommands.check
self.unitTestDict = {}
    # For communication between unit tests and code.
self.unitTestGui = None
    # A way to override the gui in external unit tests.
self.unitTesting = False
    # True if unit testing.
self.unitTestMenusDict = {}
    # Created in LeoMenu.createMenuEntries for a unit test.
    # keys are command names. values are sets of strokes.
#@+node:ekr.20141102043816.5: *8* app.define_delegate_language_dict
def define_delegate_language_dict(self):
    self.delegate_language_dict = {
        # Keys are new language names.
        # Values are existing languages in leo/modes.
        "less": "css",
        "hbs": "html",
        "handlebars": "html",
        #"rust": "c",
        # "vue": "c",
    }
#@+node:ekr.20120522160137.9911: *8* app.define_extension_dict
@nobeautify

def define_extension_dict(self):

    # Keys are extensions, values are languages
    self.extension_dict = {
        # "ada":    "ada",
        "ada":      "ada95", # modes/ada95.py exists.
        "ahk":      "autohotkey",
        "aj":       "aspect_j",
        "apdl":     "apdl",
        "as":       "actionscript", # jason 2003-07-03
        "asp":      "asp",
        "awk":      "awk",
        "b":        "b",
        "bas":      "rapidq", # fil 2004-march-11
        "bash":     "shellscript",
        "bat":      "batch",
        "bbj":      "bbj",
        "bcel":     "bcel",
        "bib":      "bibtex",
        "c":        "c",
        "c++":      "cplusplus",
        "cbl":      "cobol", # Only one extension is valid: .cob
        "cfg":      "config",
        "cfm":      "coldfusion",
        "clj":      "clojure", # 2013/09/25: Fix bug 879338.
        "cljs":     "clojure",
        "cljc":     "clojure",
        "ch":       "chill", # Other extensions, .c186,.c286
        "coffee":   "coffeescript",
        "conf":     "apacheconf",
        "cpp":      "cplusplus", # 2020/08/12: was cpp.
        "css":      "css",
        "d":        "d",
        "dart":     "dart",
        "e":        "eiffel",
        "el":       "elisp",
        "eml":      "mail",
        "erl":      "erlang",
        "ex":       "elixir",
        "f":        "fortran",
        "f90":      "fortran90",
        "factor":   "factor",
        "forth":    "forth",
        "g":        "antlr",
        "groovy":   "groovy",
        "h":        "c", # 2012/05/23.
        "handlebars": "html", # McNab.
        "hbs":      "html", # McNab.
        "hs":       "haskell",
        "html":     "html",
        "hx":       "haxe",
        "i":        "swig",
        "i4gl":     "i4gl",
        "icn":      "icon",
        "idl":      "idl",
        "inf":      "inform",
        "info":     "texinfo",
        "ini":      "ini",
        "io":       "io",
        "ipynb":    "jupyter",
        "iss":      "inno_setup",
        "java":     "java",
        "jhtml":    "jhtml",
        "jmk":      "jmk",
        "js":       "javascript", # For javascript import test.
        "jsp":      "javaserverpage",
        "json":     "json", 
        # "jsp":      "jsp",
        "ksh":      "kshell",
        "kv":       "kivy", # PeckJ 2014/05/05
        "latex":    "latex",
        "less":     "css", # McNab
        "lua":      "lua", # ddm 13/02/06
        "ly":       "lilypond",
        "m":        "matlab",
        "mak":      "makefile",
        "md":       "md", # PeckJ 2013/02/07
        "ml":       "ml",
        "mm":       "objective_c", # Only one extension is valid: .m
        "mod":      "modula3",
        "mpl":      "maple",
        "mqsc":     "mqsc",
        "nqc":      "nqc",
        "nsi":      "nsi", # EKR: 2010/10/27
        # "nsi":      "nsis2",
        "nw":       "noweb",
        "occ":      "occam",
        "otl":      "vimoutline", # TL 8/25/08 Vim's outline plugin
        "p":        "pascal",
        # "p":      "pop11", # Conflicts with pascal.
        "php":      "php",
        "pike":     "pike",
        "pl":       "perl",
        "pl1":      "pl1",
        "po":       "gettext",
        "pod":      "perlpod",
        "pov":      "povray",
        "prg":      "foxpro",
        "pro":      "prolog",
        "ps":       "postscript",
        "psp":      "psp",
        "ptl":      "ptl",
        "py":       "python",
        "pyx":      "cython", # Other extensions, .pyd,.pyi
        # "pyx":    "pyrex",
        # "r":      "r", # modes/r.py does not exist.
        "r":        "rebol", # jason 2003-07-03
        "rb":       "ruby", # thyrsus 2008-11-05
        "rest":     "rst",
        "rex":      "objectrexx",
        "rhtml":    "rhtml",
        "rib":      "rib",
        "rs":       "rust", # EKR: 2019/08/11
        "sas":      "sas",
        "scala":    "scala",
        "scm":      "scheme",
        "scpt":     "applescript",
        "sgml":     "sgml",
        "sh":       "shell", # DS 4/1/04. modes/shell.py exists.
        "shtml":    "shtml",
        "sm":       "smalltalk",
        "splus":    "splus",
        "sql":      "plsql", # qt02537 2005-05-27
        "sqr":      "sqr",
        "ss":       "ssharp",
        "ssi":      "shtml",
        "sty":      "latex",
        "tcl":      "tcl", # modes/tcl.py exists.
        # "tcl":    "tcltk",
        "tex":      "latex",
        # "tex":      "tex",
        "tpl":      "tpl",
        "ts":       "typescript",
        "txt":      "plain",
        # "txt":      "text",
        # "txt":      "unknown", # Set when @comment is seen.
        "uc":       "uscript",
        "v":        "verilog",
        "vbs":      "vbscript",
        "vhd":      "vhdl",
        "vhdl":     "vhdl",
        "vim":      "vim",
        "vtl":      "velocity",
        "w":        "cweb",
        "wiki":     "moin",
        "xml":      "xml",
        "xom":      "omnimark",
        "xsl":      "xsl",
        "yaml":     "yaml",
        "vue":      "javascript",
        "zpt":      "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm

    # Extra language extensions, used to associate extensions with mode files.
    # Used by importCommands.languageForExtension.
    # Keys are extensions, values are corresponding mode file (without .py)
    # A value of 'none' is a signal to unit tests that no extension file exists.
    self.extra_extension_dict = {
        'pod'   : 'perl',
        'unknown_language': 'none',
        'w'     : 'none', # cweb
    }
#@+node:ekr.20031218072017.1417: *8* app.define_global_constants
def define_global_constants(self):
    # self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
    self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
    self.prolog_postfix_string = "?>"
    self.prolog_namespace_string = 'xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"'
#@+node:ekr.20120522160137.9909: *8* app.define_language_delims_dict
@nobeautify

def define_language_delims_dict(self):

    self.language_delims_dict = {
        # Internally, lower case is used for all language names.
        # Keys are languages, values are 1,2 or 3-tuples of delims.
        "actionscript"       : "// /* */", # jason 2003-07-03
        "ada"                : "--",
        "ada95"              : "--",
        "ahk"                : ";",
        "antlr"              : "// /* */",
        "apacheconf"         : "#",
        "apdl"               : "!",
        "applescript"        : "-- (* *)",
        "asp"                : "<!-- -->",
        "aspect_j"           : "// /* */",
        "assembly_macro32"   : ";",
        "assembly_mcs51"     : ";",
        "assembly_parrot"    : "#",
        "assembly_r2000"     : "#",
        "assembly_x86"       : ";",
        "autohotkey"         : "; /* */", # TL - AutoHotkey language
        "awk"                : "#",
        "b"                  : "// /* */",
        "batch"              : "REM_", # Use the REM hack.
        "bbj"                : "/* */",
        "bcel"               : "// /* */",
        "bibtex"             : "%",
        "c"                  : "// /* */", # C, C++ or objective C.
        "chill"              : "/* */",
        "clojure"            : ";", # 2013/09/25: Fix bug 879338.
        "cobol"              : "*",
        "coldfusion"         : "<!-- -->",
        "coffeescript"       : "#", # 2016/02/26.
        "config"             : "#", # Leo 4.5.1
        "cplusplus"          : "// /* */",
        "cpp"                : "// /* */",# C++.
        "csharp"             : "// /* */", # C#
        "css"                : "/* */", # 4/1/04
        "cweb"               : "@q@ @>", # Use the "cweb hack"
        "cython"             : "#",
        "d"                  : "// /* */",
        "dart"               : "// /* */", # Leo 5.0.
        "doxygen"            : "#",
        "eiffel"             : "--",
        "elisp"              : ";",
        "erlang"             : "%",
        "elixir"             : "#",
        "factor"             : "!_ ( )", # Use the rem hack.
        "forth"              : "\\_ _(_ _)", # Use the "REM hack"
        "fortran"            : "C",
        "fortran90"          : "!",
        "foxpro"             : "&&",
        "gettext"            : "# ",
        "groovy"             : "// /* */",
        "handlebars"         : "<!-- -->", # McNab: delegate to html.
        "haskell"            : "--_ {-_ _-}",
        "haxe"               : "// /* */",
        "hbs"                : "<!-- -->", # McNab: delegate to html.
        "html"               : "<!-- -->",
        "i4gl"               : "-- { }",
        "icon"               : "#",
        "idl"                : "// /* */",
        "inform"             : "!",
        "ini"                : ";",
        "inno_setup"         : ";",
        "interlis"           : "/* */",
        "io"                 : "// */",
        "java"               : "// /* */",
        "javascript"         : "// /* */", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage"     : "<%-- --%>", # EKR: 2011/11/25 (See also, jsp)
        "jhtml"              : "<!-- -->",
        "jmk"                : "#",
        "json"               : "#", # EKR: 2020/07/27: Json has no delims. This is a dummy entry.
        "jsp"                : "<%-- --%>",
        "jupyter"            : "<%-- --%>", # Default to markdown?
        "kivy"               : "#", # PeckJ 2014/05/05
        "kshell"             : "#", # Leo 4.5.1.
        "latex"              : "%",
        "less"               : "/* */", # NcNab: delegate to css.
        "lilypond"           : "% %{ %}",
        "lisp"               : ";", # EKR: 2010/09/29
        "lotos"              : "(* *)",
        "lua"                : "--", # ddm 13/02/06
        "mail"               : ">",
        "makefile"           : "#",
        "maple"              : "//",
        "markdown"           : "<!-- -->", # EKR, 2018/03/03: html comments.
        "matlab"             : "%", # EKR: 2011/10/21
        "md"                 : "<!-- -->", # PeckJ: 2013/02/08
        "ml"                 : "(* *)",
        "modula3"            : "(* *)",
        "moin"               : "##",
        "mqsc"               : "*",
        "netrexx"            : "-- /* */",
        "noweb"              : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
        "nqc"                : "// /* */",
        "nsi"                : ";", # EKR: 2010/10/27
        "nsis2"              : ";",
        "objective_c"        : "// /* */",
        "objectrexx"         : "-- /* */",
        "occam"              : "--",
        "omnimark"           : ";",
        "pandoc"             : "<!-- -->", 
        "pascal"             : "// { }",
        "perl"               : "#",
        "perlpod"            : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
        "php"                : "// /* */", # 6/23/07: was "//",
        "pike"               : "// /* */",
        "pl1"                : "/* */",
        "plain"              : "#", # We must pick something.
        "plsql"              : "-- /* */", # SQL scripts qt02537 2005-05-27
        "pop11"              : ";;; /* */",
        "postscript"         : "%",
        "povray"             : "// /* */",
        "powerdynamo"        : "// <!-- -->",
        "prolog"             : "% /* */",
        "psp"                : "<!-- -->",
        "ptl"                : "#",
        "pvwave"             : ";",
        "pyrex"              : "#",
        "python"             : "#",
        "r"                  : "#",
        "rapidq"             : "'", # fil 2004-march-11
        "rebol"              : ";", # jason 2003-07-03
        "redcode"            : ";",
        "rest"               : ".._",
        "rhtml"              : "<%# %>",
        "rib"                : "#",
        "rpmspec"            : "#",
        "rst"                : ".._",
        "rust"               : "// /* */",
        "ruby"               : "#", # thyrsus 2008-11-05
        "rview"              : "// /* */",
        "sas"                : "* /* */",
        "scala"              : "// /* */",
        "scheme"             : "; #| |#",
        "sdl_pr"             : "/* */",
        "sgml"               : "<!-- -->",
        "shell"              : "#",     # shell scripts
        "shellscript"        : "#",
        "shtml"              : "<!-- -->",
        "smalltalk"          : '" "', # Comments are enclosed in double quotes(!!)
        "smi_mib"            : "--",
        "splus"              : "#",
        "sqr"                : "!",
        "squidconf"          : "#",
        "ssharp"             : "#",
        "swig"               : "// /* */",
        "tcl"                : "#",
        "tcltk"              : "#",
        "tex"                : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
        "text"               : "#", # We must pick something.
        "texinfo"            : "@c",
        "tpl"                : "<!-- -->",
        "tsql"               : "-- /* */",
        "typescript"         : "// /* */", # For typescript import test.
        "unknown"            : "#", # Set when @comment is seen.
        "unknown_language"   : '#--unknown-language--', # For unknown extensions in @shadow files.
        "uscript"            : "// /* */",
        "vbscript"           : "'",
        "velocity"           : "## #* *#",
        "verilog"            : "// /* */",
        "vhdl"               : "--",
        "vim"                : "\"",
        "vimoutline"         : "#", # TL 8/25/08 Vim's outline plugin
        "xml"                : "<!-- -->",
        "xsl"                : "<!-- -->",
        "xslt"               : "<!-- -->",
        "yaml"               : "#",
        "zpt"                : "<!-- -->",

        # These aren't real languages, or have no delims...
        # "cvs_commit"         : "",
        # "dsssl"              : "; <!-- -->",
        # "embperl"            : "<!-- -->",  # Internal colorizing state.
        # "freemarker"         : "",
        # "hex"                : "",
        # "jcl"                : "",
        # "patch"              : "",
        # "phpsection"         : "<!-- -->",  # Internal colorizing state.
        # "props"              : "#",         # Unknown language.
        # "pseudoplain"        : "",
        # "relax_ng_compact"   : "#",         # An xml schema.
        # "rtf"                : "",
        # "svn_commit"         : "",
    }
#@+node:ekr.20120522160137.9910: *8* app.define_language_extension_dict
@nobeautify

def define_language_extension_dict(self):

    # Used only by g.app.externalFilesController.get_ext.

    # Keys are languages, values are extensions.
    self.language_extension_dict = {
        "actionscript"  : "as", # jason 2003-07-03
        "ada"           : "ada",
        "ada95"         : "ada",
        "ahk"           : "ahk",
        "antlr"         : "g",
        "apacheconf"    : "conf",
        "apdl"          : "apdl",
        "applescript"   : "scpt",
        "asp"           : "asp",
        "aspect_j"      : "aj",
        "autohotkey"    : "ahk", # TL - AutoHotkey language
        "awk"           : "awk",
        "b"             : "b",
        "batch"         : "bat", # Leo 4.5.1.
        "bbj"           : "bbj",
        "bcel"          : "bcel",
        "bibtex"        : "bib",
        "c"             : "c",
        "chill"         : "ch",  # Only one extension is valid: .c186, .c286
        "clojure"       : "clj", # 2013/09/25: Fix bug 879338.
        "cobol"         : "cbl", # Only one extension is valid: .cob
        "coldfusion"    : "cfm",
        "coffeescript"  : "coffee",
        "config"        : "cfg",
        "cplusplus"     : "c++",
        "cpp"           : "cpp",
        "css"           : "css", # 4/1/04
        "cweb"          : "w",
        "cython"        : "pyx", # Only one extension is valid at present: .pyi, .pyd.
        "d"             : "d",
        "dart"          : "dart",
        "eiffel"        : "e",
        "elisp"         : "el",
        "erlang"        : "erl",
        "elixir"        : "ex",
        "factor"        : "factor",
        "forth"         : "forth",
        "fortran"       : "f",
        "fortran90"     : "f90",
        "foxpro"        : "prg",
        "gettext"       : "po",
        "groovy"        : "groovy",
        "haskell"       : "hs",
        "haxe"          : "hx",
        "html"          : "html",
        "i4gl"          : "i4gl",
        "icon"          : "icn",
        "idl"           : "idl",
        "inform"        : "inf",
        "ini"           : "ini",
        "inno_setup"    : "iss",
        "io"            : "io",
        "java"          : "java",
        "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage": "jsp", # EKR: 2011/11/25
        "jhtml"         : "jhtml",
        "jmk"           : "jmk",
        "json"          : "json", 
        "jsp"           : "jsp",
        "jupyter"       : "ipynb",
        "kivy"          : "kv", # PeckJ 2014/05/05
        "kshell"        : "ksh", # Leo 4.5.1.
        "latex"         : "tex", # 1/8/04
        "lilypond"      : "ly",
        "lua"           : "lua", # ddm 13/02/06
        "mail"          : "eml",
        "makefile"      : "mak",
        "maple"         : "mpl",
        "matlab"        : "m",
        "md"            : "md", # PeckJ: 2013/02/07
        "ml"            : "ml",
        "modula3"       : "mod",
        "moin"          : "wiki",
        "mqsc"          : "mqsc",
        "noweb"         : "nw",
        "nqc"           : "nqc",
        "nsi"           : "nsi", # EKR: 2010/10/27
        "nsis2"         : "nsi",
        "objective_c"   : "mm", # Only one extension is valid: .m
        "objectrexx"    : "rex",
        "occam"         : "occ",
        "omnimark"      : "xom",
        "pascal"        : "p",
        "perl"          : "pl",
        "perlpod"       : "pod",
        "php"           : "php",
        "pike"          : "pike",
        "pl1"           : "pl1",
        "plain"         : "txt",
        "plsql"         : "sql", # qt02537 2005-05-27
        # "pop11"       : "p", # Conflicts with pascall.
        "postscript"    : "ps",
        "povray"        : "pov",
        "prolog"        : "pro",
        "psp"           : "psp",
        "ptl"           : "ptl",
        "pyrex"         : "pyx",
        "python"        : "py",
        "r"             : "r",
        "rapidq"        : "bas", # fil 2004-march-11
        "rebol"         : "r", # jason 2003-07-03
        "rhtml"         : "rhtml",
        "rib"           : "rib",
        "rst"           : "rest",
        "ruby"          : "rb", # thyrsus 2008-11-05
        "rust"          : "rs", # EKR: 2019/08/11
        "sas"           : "sas",
        "scala"         : "scala",
        "scheme"        : "scm",
        "sgml"          : "sgml",
        "shell"         : "sh", # DS 4/1/04
        "shellscript"   : "bash",
        "shtml"         : "ssi", # Only one extension is valid: .shtml
        "smalltalk"     : "sm",
        "splus"         : "splus",
        "sqr"           : "sqr",
        "ssharp"        : "ss",
        "swig"          : "i",
        "tcl"           : "tcl",
        "tcltk"         : "tcl",
        "tex"           : "tex",
        "texinfo"       : "info",
        "text"          : "txt",
        "tpl"           : "tpl",
        "tsql"          : "sql", # A guess.
        "typescript"    : "ts",
        "unknown"       : "txt", # Set when @comment is seen.
        "uscript"       : "uc",
        "vbscript"      : "vbs",
        "velocity"      : "vtl",
        "verilog"       : "v",
        "vhdl"          : "vhd", # Only one extension is valid: .vhdl
        "vim"           : "vim",
        "vimoutline"    : "otl", # TL 8/25/08 Vim's outline plugin
        "xml"           : "xml",
        "xsl"           : "xsl",
        "xslt"          : "xsl",
        "yaml"          : "yaml",
        "zpt"           : "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm
#@+node:ekr.20140729162415.18086: *8* app.init_at_auto_names
def init_at_auto_names(self):
    """Init the app.atAutoNames set."""
    self.atAutoNames = set([
        "@auto-rst", "@auto",
    ])
#@+node:ekr.20140729162415.18091: *8* app.init_at_file_names
def init_at_file_names(self):
    """Init the app.atFileNames set."""
    self.atFileNames = set([
        "@asis",
        "@edit",
        "@file-asis", "@file-thin", "@file-nosent", "@file",
        "@clean", "@nosent",
        "@shadow",
        "@thin",
    ])
#@+node:ekr.20150509193629.1: *7* app.cmd (decorator)
def cmd(name):
    """Command decorator for the LeoApp class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['g', 'app'])
#@+node:ekr.20090717112235.6007: *7* app.computeSignon & printSignon
def computeSignon(self):
    import leo.core.leoVersion as leoVersion
    app = self
    guiVersion = ', ' + app.gui.getFullVersion() if app.gui else ''
    leoVer = leoVersion.version
    n1, n2, n3, junk, junk = sys.version_info
    if sys.platform.startswith('win'):
        sysVersion = 'Windows '
        try:
            # peckj 20140416: determine true OS architecture
            # the following code should return the proper architecture
            # regardless of whether or not the python architecture matches
            # the OS architecture (i.e. python 32-bit on windows 64-bit will return 64-bit)
            v = platform.win32_ver()
            release, winbuild, sp, ptype = v
            true_platform = os.environ['PROCESSOR_ARCHITECTURE']
            try:
                true_platform = os.environ['PROCESSOR_ARCHITEw6432']
            except KeyError:
                pass
            sysVersion = f"Windows {release} {true_platform} (build {winbuild}) {sp}"
        except Exception:
            pass
    else: sysVersion = sys.platform
    branch, junk_commit = g.gitInfo()
    author, commit, date = g.getGitVersion()
    # Compute g.app.signon.
    signon = [f"Leo {leoVer}"]
    if branch:
        signon.append(f", {branch} branch")
    if commit:
        signon.append(', build ' + commit)
    if date:
        signon.append('\n' + date)
    app.signon = ''.join(signon)
    # Compute g.app.signon1.
    app.signon1 = f"Python {n1}.{n2}.{n3}{guiVersion}\n{sysVersion}"

def printSignon(self, verbose=False):
    """Print a minimal sigon to the log."""
    app = self
    if app.silentMode:
        return
    if sys.stdout.encoding and sys.stdout.encoding.lower() != 'utf-8':
        print('Note: sys.stdout.encoding is not UTF-8')
        print(f"Encoding is: {sys.stdout.encoding!r}")
        print('See: https://stackoverflow.com/questions/14109024')
        print('')
    print(app.signon)
    if verbose:
        print(app.signon1)
#@+node:ekr.20100831090251.5838: *7* app.createXGui
#@+node:ekr.20100831090251.5840: *8* app.createCursesGui
def createCursesGui(self, fileName='', verbose=False):
    try:
        import curses
        assert curses
    except Exception:
        g.es_exception()
        print('can not import _curses.')
        if g.isWindows:
            print('Windows: pip install windows-curses')
        sys.exit()
    try:
        import leo.plugins.cursesGui2 as cursesGui2
        ok = cursesGui2.init()
        if ok:
            g.app.gui = cursesGui2.LeoCursesGui()
    except Exception:
        g.es_exception()
        print('can not create curses gui.')
        sys.exit()
#@+node:ekr.20181031160401.1: *8* app.createBrowserGui
def createBrowserGui(self, fileName='', verbose=False):
    app = self
    try:
        from flexx import flx
        assert flx
    except Exception:
        g.es_exception()
        print('can not import flexx')
        sys.exit(1)
    try:
        import leo.plugins.leoflexx as leoflexx
        assert leoflexx
    except Exception:
        g.es_exception()
        print('can not import leo.plugins.leoflexx')
        sys.exit(1)
    g.app.gui = leoflexx.LeoBrowserGui(gui_name=app.guiArgName)
#@+node:ekr.20090619065122.8593: *8* app.createDefaultGui
def createDefaultGui(self, fileName='', verbose=False):
    """A convenience routines for plugins to create the default gui class."""
    app = self
    argName = app.guiArgName
    if g.in_bridge:
        return  # The bridge will create the gui later.
    if app.gui:
        return  # This method can be called twice if we had to get .leoID.txt.
    assert argName != 'qttabs'
        # For compatibility with g.assertUi('qt')
    if argName == 'qt':
        app.createQtGui(fileName, verbose=verbose)
    elif argName == 'null':
        g.app.gui = g.app.nullGui
    elif argName.startswith('browser'):
        app.createBrowserGui()
    elif argName in ('console', 'curses'):
        app.createCursesGui()
    elif argName == 'text':
        app.createTextGui()
    if not app.gui:
        print('createDefaultGui: Leo requires Qt to be installed.')
#@+node:ekr.20031218072017.1938: *8* app.createNullGuiWithScript
def createNullGuiWithScript(self, script=None):
    app = self
    app.batchMode = True
    app.gui = g.app.nullGui
    app.gui.setScript(script)
#@+node:ekr.20090202191501.1: *8* app.createQtGui
def createQtGui(self, fileName='', verbose=False):
    # Do NOT omit fileName param: it is used in plugin code.
    """A convenience routines for plugins to create the Qt gui class."""
    app = self
    try:
        from leo.core.leoQt import Qt
        assert Qt
    except Exception:
        # #1215: Raise an emergency dialog.
        message = 'Can not Import Qt'
        print(message)
        try:
            d = g.EmergencyDialog(title=message, message=message)
            d.run()
        except Exception:
            g.es_exception()
        sys.exit(1)
    try:
        import leo.plugins.qt_gui as qt_gui
    except Exception:
        g.es_exception()
        print('can not import leo.plugins.qt_gui')
        sys.exit(1)
    try:
        from leo.plugins.editpane.editpane import edit_pane_test_open, edit_pane_csv
        g.command('edit-pane-test-open')(edit_pane_test_open)
        g.command('edit-pane-csv')(edit_pane_csv)
    except ImportError:
        print('Failed to import editpane')
    #
    # Complete the initialization.
    qt_gui.init()
    if app.gui and fileName and verbose:
        print(f"Qt Gui created in {fileName}")
#@+node:ekr.20170419093747.1: *8* app.createTextGui (was createCursesGui)
def createTextGui(self, fileName='', verbose=False):
    app = self
    app.pluginsController.loadOnePlugin('leo.plugins.cursesGui', verbose=verbose)
#@+node:ekr.20090126063121.3: *8* app.createWxGui
def createWxGui(self, fileName='', verbose=False):
    # Do NOT omit fileName param: it is used in plugin code.
    """A convenience routines for plugins to create the wx gui class."""
    app = self
    app.pluginsController.loadOnePlugin('leo.plugins.wxGui', verbose=verbose)
    if fileName and verbose:
        print(f"wxGui created in {fileName}")
#@+node:ville.20090620122043.6275: *7* app.setGlobalDb
def setGlobalDb(self):
    """ Create global pickleshare db

    Usable by::

        g.app.db['hello'] = [1,2,5]

    """
    # Fixes bug 670108.
    import leo.core.leoCache as leoCache
    g.app.global_cacher = leoCache.GlobalCacher()
    g.app.db = g.app.global_cacher.db
    g.app.commander_cacher = leoCache.CommanderCacher()
    g.app.commander_db = g.app.commander_cacher.db
#@+node:ekr.20031218072017.1978: *7* app.setLeoID & helpers
def setLeoID(self, useDialog=True, verbose=True):
    """Get g.app.leoID from various sources."""
    self.leoID = None
    assert self == g.app
    verbose = verbose and not g.unitTesting and not self.silentMode
    table = (self.setIDFromSys, self.setIDFromFile, self.setIDFromEnv,)
    for func in table:
        func(verbose)
        if self.leoID:
            return self.leoID
    if useDialog:
        self.setIdFromDialog()
        if self.leoID:
            self.setIDFile()
    return self.leoID
#@+node:ekr.20191017061451.1: *8* app.cleanLeoID
def cleanLeoID(self, id_, tag):
    """#1404: Make sure that the given Leo ID will not corrupt a .leo file."""
    old_id = id_ if isinstance(id_, str) else repr(id_)
    try:
        id_ = id_.replace('.', '').replace(',', '').replace('"', '').replace("'", '')
        # Remove *all* whitespace: https://stackoverflow.com/questions/3739909
        id_ = ''.join(id_.split())
    except Exception:
        g.es_exception()
        id_ = ''
    if len(id_) < 3:
        g.EmergencyDialog(
            title=f"Invalid Leo ID: {tag}",
            message=(
                f"Invalid Leo ID: {old_id!r}\n\n"
                "Your id should contain only letters and numbers\n"
                "and must be at least 3 characters in length."))
    return id_
#@+node:ekr.20031218072017.1979: *8* app.setIDFromSys
def setIDFromSys(self, verbose):
    """
    Attempt to set g.app.leoID from sys.leoID.

    This might be set by in Python's sitecustomize.py file.
    """
    id_ = getattr(sys, "leoID", None)
    if id_:
        # Careful: periods in the id field of a gnx will corrupt the .leo file!
        id_ = self.cleanLeoID(id_, 'sys.leoID')
            # cleanLeoID raises a warning dialog.
        if len(id_) > 2:
            self.leoID = id_
            if verbose:
                g.red("leoID=", self.leoID, spaces=False)
#@+node:ekr.20031218072017.1980: *8* app.setIDFromFile
def setIDFromFile(self, verbose):
    """Attempt to set g.app.leoID from leoID.txt."""
    tag = ".leoID.txt"
    for theDir in (self.homeLeoDir, self.globalConfigDir, self.loadDir):
        if not theDir:
            continue  # Do not use the current directory!
        fn = g.os_path_join(theDir, tag)
        try:
            with open(fn, 'r') as f:
                s = f.readline().strip()
            if not s:
                continue
            # #1404: Ensure valid ID.
            id_ = self.cleanLeoID(s, tag)
                # cleanLeoID raises a warning dialog.
            if len(id_) > 2:
                self.leoID = id_
                return
        except IOError:
            pass
        except Exception:
            g.error('unexpected exception in app.setLeoID')
            g.es_exception()
#@+node:ekr.20060211140947.1: *8* app.setIDFromEnv
def setIDFromEnv(self, verbose):
    """Set leoID from environment vars."""
    try:
        id_ = os.getenv('USER')
        if id_:
            if verbose:
                g.blue("setting leoID from os.getenv('USER'):", repr(id_))
            # Careful: periods in the gnx would corrupt the .leo file!
            id_ = self.cleanLeoID(id_, "os.getenv('USER')")
                # cleanLeoID raises a warning dialog.
            if len(id_) > 2:
                self.leoID = id_
    except Exception:
        pass
#@+node:ekr.20031218072017.1981: *8* app.setIdFromDialog
def setIdFromDialog(self):
    """Get leoID from a Tk dialog."""
    #
    # Don't put up a splash screen: it would obscure the coming dialog.
    self.use_splash_screen = False
    #
    # Get the id, making sure it is at least three characters long.
    while True:
        dialog = g.TkIDDialog()
        dialog.run()
        # #1404: Make sure the id will not corrupt the .leo file.
        id_ = self.cleanLeoID(dialog.val, "")
        if id_ and len(id_) > 2:
            break
    #
    # Put result in g.app.leoID.
    self.leoID = id_
    g.blue('leoID=', repr(self.leoID), spaces=False)
#@+node:ekr.20031218072017.1982: *8* app.setIDFile
def setIDFile(self):
    """Create leoID.txt."""
    tag = ".leoID.txt"
    for theDir in (self.homeLeoDir, self.globalConfigDir, self.loadDir):
        if theDir:
            try:
                fn = g.os_path_join(theDir, tag)
                with open(fn, 'w') as f:
                    f.write(self.leoID)
                if g.os_path_exists(fn):
                    g.error('', tag, 'created in', theDir)
                    return
            except IOError:
                pass
            g.error('can not create', tag, 'in', theDir)
#@+node:ekr.20031218072017.1847: *7* app.setLog, lockLog, unlocklog
def setLog(self, log):
    """set the frame to which log messages will go"""
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    # print("app.lockLog:")
    self.logIsLocked = True

def unlockLog(self):
    """Enable changes to the log"""
    # print("app.unlockLog:")
    self.logIsLocked = False
#@+node:ekr.20031218072017.2619: *7* app.writeWaitingLog
def writeWaitingLog(self, c):
    """Write all waiting lines to the log."""
    #
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    app = self
    if not c or not c.exists:
        return
    if g.unitTesting:
        app.logWaiting = []
        g.app.setLog(None)  # Prepare to requeue for other commanders.
        return
    # Write the signon to the log: similar to self.computeSignon().
    table = [
        ('Leo Log Window', 'red'),
        (app.signon, None),
        (app.signon1, None),
    ]
    table.reverse()
    c.setLog()
    app.logInited = True  # Prevent recursive call.
    if not app.silentMode:
        # Write the signon.
        for s, color in table:
            if s:
                app.logWaiting.insert(0, (s, color, True),)
        # Write all the queued log entries.
        for msg in app.logWaiting:
            s, color, newline = msg[:3]
            kwargs = {} if len(msg) < 4 else msg[3]
            kwargs = {
                k: v for k, v in kwargs.items() if k not in ('color', 'newline')}
            g.es('', s, color=color, newline=newline, **kwargs)
        if hasattr(c.frame.log, 'scrollToEnd'):
            g.app.gui.runAtIdle(c.frame.log.scrollToEnd)
    app.logWaiting = []
    # Essential when opening multiple files...
    g.app.setLog(None)
#@+node:ekr.20180924093227.1: *6* app.c property
@property
def c(self):
    return self.log and self.log.c
#@+node:ekr.20171127111053.1: *6* app.Closing
#@+node:ekr.20031218072017.2609: *7* app.closeLeoWindow
def closeLeoWindow(self, frame, new_c=None, finish_quit=True):
    """
    Attempt to close a Leo window.

    Return False if the user veto's the close.

    finish_quit - usually True, close Leo when last file closes, but
                  False when closing an already-open-elsewhere file
                  during initial load, so UI remains for files
                  further along the command line.
    """
    c = frame.c
    if 'shutdown' in g.app.debug:
        g.trace(f"changed: {c.changed} {c.shortFileName()}")
    c.endEditing()  # Commit any open edits.
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
    g.app.recentFilesManager.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.
    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False
    g.app.setLog(None)  # no log until we reactive a window.
    g.doHook("close-frame", c=c)
    #
    # Save the window state for *all* open files.
    g.app.commander_cacher.commit()
        # store cache, but don't close it.
    # This may remove frame from the window list.
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
        g.app.windowList.remove(frame)
    else:
        # #69.
        g.app.forgetOpenFile(fn=c.fileName(), force=True)
    if g.app.windowList:
        c2 = new_c or g.app.windowList[0].c
        g.app.selectLeoWindow(c2)
    elif finish_quit and not g.app.unitTesting:
        g.app.finishQuit()
    return True  # The window has been closed.
#@+node:ekr.20031218072017.2612: *7* app.destroyAllOpenWithFiles
def destroyAllOpenWithFiles(self):
    """Remove temp files created with the Open With command."""
    if 'shutdown' in g.app.debug:
        g.pr('destroyAllOpenWithFiles')
    if g.app.externalFilesController:
        g.app.externalFilesController.shut_down()
        g.app.externalFilesController = None
#@+node:ekr.20031218072017.2615: *7* app.destroyWindow
def destroyWindow(self, frame):
    """Destroy all ivars in a Leo frame."""
    if 'shutdown' in g.app.debug:
        g.pr(f"destroyWindow:  {frame.c.shortFileName()}")
    if g.app.externalFilesController:
        g.app.externalFilesController.destroy_frame(frame)
    if frame in g.app.windowList:
        # g.pr('destroyWindow', (g.app.windowList)
        g.app.forgetOpenFile(frame.c.fileName())
    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()
#@+node:ekr.20031218072017.1732: *7* app.finishQuit
def finishQuit(self):
    # forceShutdown may already have fired the "end1" hook.
    assert self == g.app, repr(g.app)
    if 'shutdown' in g.app.debug:
        g.pr('finishQuit: killed:', g.app.killed)
    if not g.app.killed:
        g.doHook("end1")
        g.app.global_cacher.commit_and_close()
        g.app.commander_cacher.commit()
        g.app.commander_cacher.close()
    if g.app.ipk:
        g.app.ipk.cleanup_consoles()
    g.app.destroyAllOpenWithFiles()
    if hasattr(g.app, 'pyzo_close_handler'):
        # pylint: disable=no-member
        g.app.pyzo_close_handler()
    g.app.killed = True
        # Disable all further hooks and events.
        # Alas, "idle" events can still be called
        # even after the following code.
    if g.app.gui:
        g.app.gui.destroySelf()
            # Calls qtApp.quit()
#@+node:ekr.20031218072017.2616: *7* app.forceShutdown
def forceShutdown(self):
    """
    Forces an immediate shutdown of Leo at any time.

    In particular, may be called from plugins during startup.
    """
    trace = 'shutdown' in g.app.debug
    app = self
    if trace:
        g.pr('forceShutdown')
    for c in app.commanders():
        app.forgetOpenFile(c.fileName(), force=True)
    # Wait until everything is quiet before really quitting.
    if trace: g.pr('forceShutdown: before end1')
    g.doHook("end1")
    if trace: g.pr('forceShutdown: after end1')
    self.log = None  # Disable writeWaitingLog
    self.killed = True  # Disable all further hooks.
    for w in self.windowList[:]:
        if trace: g.pr(f"forceShutdown: {w}")
        self.destroyWindow(w)
    if trace: g.pr('before finishQuit')
    self.finishQuit()
#@+node:ekr.20031218072017.2617: *7* app.onQuit
@cmd('exit-leo')
@cmd('quit-leo')
def onQuit(self, event=None):
    """Exit Leo, prompting to save unsaved outlines first."""
    if 'shutdown' in g.app.debug:
        g.trace()
    g.app.quitting = True
    if g.app.loaded_session and g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    while g.app.windowList:
        w = g.app.windowList[0]
        if not g.app.closeLeoWindow(w):
            break
    if g.app.windowList:
        g.app.quitting = False  # If we get here the quit has been disabled.
#@+node:ville.20090602181814.6219: *6* app.commanders
def commanders(self):
    """ Return list of currently active controllers """
    return [f.c for f in g.app.windowList]
#@+node:ekr.20120427064024.10068: *6* app.Detecting already-open files
#@+node:ekr.20120427064024.10064: *7* app.checkForOpenFile
def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
#@+node:ekr.20120427064024.10066: *7* app.forgetOpenFile
def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
#@+node:ekr.20120427064024.10065: *7* app.rememberOpenFile
def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
#@+node:ekr.20150621062355.1: *7* app.runAlreadyOpenDialog
def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
#@+node:ekr.20171127111141.1: *6* app.Import utils
#@+node:ekr.20140727180847.17985: *7* app.scanner_for_at_auto
def scanner_for_at_auto(self, c, p, **kwargs):
    """A factory returning a scanner function for p, an @auto node."""
    d = g.app.atAutoDict
    for key in d:
        # pylint: disable=cell-var-from-loop
        aClass = d.get(key)
        if aClass and g.match_word(p.h, 0, key):

            def scanner_for_at_auto_cb(c, parent, s, **kwargs):
                try:
                    ic = c.importCommands
                    scanner = aClass(importCommands=ic, **kwargs)
                    return scanner.run(s, parent)
                except Exception:
                    g.es_print('Exception running', aClass.__name__)
                    g.es_exception()
                    return None

            scanner_for_at_auto_cb.scanner_name = aClass.__name__
                # For traces in ic.createOutline.
            return scanner_for_at_auto_cb
    return None
#@+node:ekr.20140130172810.15471: *7* app.scanner_for_ext
def scanner_for_ext(self, c, ext, **kwargs):
    """A factory returning a scanner function for the given file extension."""
    aClass = g.app.classDispatchDict.get(ext)
    if aClass:

        def scanner_for_ext_cb(c, parent, s, **kwargs):
            try:
                ic = c.importCommands
                scanner = aClass(importCommands=ic, **kwargs)
                return scanner.run(s, parent)
            except Exception:
                g.es_print('Exception running', aClass.__name__)
                g.es_exception()
                return None

        scanner_for_ext_cb.scanner_name = aClass.__name__
            # For traces in ic.createOutline.
        return scanner_for_ext_cb
    return None
#@+node:ekr.20170429152049.1: *6* app.listenToLog
@cmd('listen-to-log')
@cmd('log-listen')
def listenToLog(self, event=None):
    """
    A socket listener, listening on localhost. See:
    https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network

    Start this listener first, then start the broadcaster.

    leo/plugins/cursesGui2.py is a typical broadcaster.
    """
    app = self
    # Kill any previous listener.
    if app.log_listener:
        g.es_print('Killing previous listener')
        try:
            app.log_listener.kill()
        except Exception:
            g.es_exception()
        app.log_listener = None
    # Start a new listener.
    g.es_print('Starting log_listener.py')
    path = g.os_path_finalize_join(app.loadDir,
        '..', 'external', 'log_listener.py')
    app.log_listener = subprocess.Popen(
        [sys.executable, path],
        shell=False,
        universal_newlines=True,
    )
#@+node:ekr.20171118024827.1: *6* app.makeAllBindings
def makeAllBindings(self):
    """
    LeoApp.makeAllBindings:
        
    Call c.k.makeAllBindings for all open commanders c.
    """
    app = self
    for c in app.commanders():
        c.k.makeAllBindings()
#@+node:ekr.20031218072017.2188: *6* app.newCommander
def newCommander(self, fileName,
    gui=None,
    parentFrame=None,
    previousSettings=None,
    relativeFileName=None,
):
    """Create a commander and its view frame for the Leo main window."""
    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    import leo.core.leoCommands as leoCommands
    c = leoCommands.Commands(fileName,
        gui=gui,
        parentFrame=parentFrame,
        previousSettings=previousSettings,
        relativeFileName=relativeFileName,
    )
    return c
#@+node:ekr.20120304065838.15588: *6* app.selectLeoWindow
def selectLeoWindow(self, c):
    frame = c.frame
    frame.deiconify()
    frame.lift()
    c.setLog()
    master = getattr(frame.top, 'leo_master', None)
    if master:
        # master is a TabbedTopLevel.
        # Selecting the new tab ensures focus is set.
        master.select(c)
    if 1:
        c.initialFocusHelper()
    else:
        c.bodyWantsFocus()
    c.outerUpdate()
#@+node:ekr.20120209051836.10242: *5* class LoadManager
class LoadManager:
    """A class to manage loading .leo files, including configuration files."""
    @others
#@+node:ekr.20120214060149.15851: *6*  LM.ctor
def __init__(self):

    #
    # Global settings & shortcuts dicts...
    # The are the defaults for computing settings and shortcuts for all loaded files.
    #
    self.globalSettingsDict = None
        # A g.TypedDict: the join of settings in leoSettings.leo & myLeoSettings.leo
    self.globalBindingsDict = None
        # A g.TypedDict: the join of shortcuts in leoSettings.leo & myLeoSettings.leo.
    #
    # LoadManager ivars corresponding to user options...
    #
    self.files = []
        # List of files to be loaded.
    self.options = {}
        # Dictionary of user options. Keys are option names.
    self.old_argv = []
        # A copy of sys.argv for debugging.
    self.more_cmdline_files = False
        # True when more files remain on the command line to be
        # loaded.  If the user is answering "No" to each file as Leo asks
        # "file already open, open again", this must be False for
        # a complete exit to be appropriate (finish_quit=True param for
        # closeLeoWindow())
    self.theme_c = None
        # #1374.
#@+node:ekr.20120211121736.10812: *6* LM.Directory & file utils
#@+node:ekr.20120219154958.10481: *7* LM.completeFileName
def completeFileName(self, fileName):
    fileName = g.toUnicode(fileName)
    fileName = g.os_path_finalize(fileName)
    # 2011/10/12: don't add .leo to *any* file.
    return fileName
#@+node:ekr.20120209051836.10372: *7* LM.computeLeoSettingsPath
def computeLeoSettingsPath(self):
    """Return the full path to leoSettings.leo."""
    # lm = self
    join = g.os_path_finalize_join
    settings_fn = 'leoSettings.leo'
    table = (
        # First, leoSettings.leo in the home directories.
        join(g.app.homeDir, settings_fn),
        join(g.app.homeLeoDir, settings_fn),
        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn)
    )
    for path in table:
        if g.os_path_exists(path):
            break
    else:
        path = None
    return path
#@+node:ekr.20120209051836.10373: *7* LM.computeMyLeoSettingsPath
def computeMyLeoSettingsPath(self):
    """
    Return the full path to myLeoSettings.leo.

    The "footnote": Get the local directory from lm.files[0]
    """
    lm = self
    join = g.os_path_finalize_join
    settings_fn = 'myLeoSettings.leo'
    # This seems pointless: we need a machine *directory*.
    # For now, however, we'll keep the existing code as is.
    machine_fn = lm.computeMachineName() + settings_fn
    # First, compute the directory of the first loaded file.
    # All entries in lm.files are full, absolute paths.
    localDir = g.os_path_dirname(lm.files[0]) if lm.files else None
    table = (
        # First, myLeoSettings.leo in the local directory
        join(localDir, settings_fn),
        # Next, myLeoSettings.leo in the home directories.
        join(g.app.homeDir, settings_fn),
        join(g.app.homeLeoDir, settings_fn),
        # Next, <machine-name>myLeoSettings.leo in the home directories.
        join(g.app.homeDir, machine_fn),
        join(g.app.homeLeoDir, machine_fn),
        # Last, leoSettings.leo in leo/config directory.
        join(g.app.globalConfigDir, settings_fn),
    )
    for path in table:
        if g.os_path_exists(path):
            break
    else:
        path = None
    return path
#@+node:ekr.20120209051836.10252: *7* LM.computeStandardDirectories & helpers
def computeStandardDirectories(self):
    """
    Compute the locations of standard directories and
    set the corresponding ivars.
    """
    lm = self
    g.app.loadDir = lm.computeLoadDir()
    g.app.leoDir = lm.computeLeoDir()
    g.app.homeDir = lm.computeHomeDir()
    g.app.homeLeoDir = lm.computeHomeLeoDir()
    g.app.globalConfigDir = lm.computeGlobalConfigDir()
    g.app.extensionsDir = g.os_path_finalize_join(g.app.loadDir, '..', 'extensions')
    g.app.testDir = g.os_path_finalize_join(g.app.loadDir, '..', 'test')
#@+node:ekr.20120209051836.10253: *8* LM.computeGlobalConfigDir
def computeGlobalConfigDir(self):
    leo_config_dir = getattr(sys, 'leo_config_directory', None)
    if leo_config_dir:
        theDir = leo_config_dir
    else:
        theDir = g.os_path_join(g.app.loadDir, "..", "config")
    if theDir:
        theDir = g.os_path_finalize(theDir)
    if (not theDir or not g.os_path_exists(theDir) or not g.os_path_isdir(theDir)):
        theDir = None
    return theDir
#@+node:ekr.20120209051836.10254: *8* LM.computeHomeDir
def computeHomeDir(self):
    """Returns the user's home directory."""
    home = os.path.expanduser("~")
        # Windows searches the HOME, HOMEPATH and HOMEDRIVE
        # environment vars, then gives up.
    if home and len(home) > 1 and home[0] == '%' and home[-1] == '%':
        # Get the indirect reference to the true home.
        home = os.getenv(home[1:-1], default=None)
    if home:
        # Important: This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_finalize(home)
        if (not g.os_path_exists(home) or not g.os_path_isdir(home)):
            home = None
    return home
#@+node:ekr.20120209051836.10260: *8* LM.computeHomeLeoDir
def computeHomeLeoDir(self):
    # lm = self
    homeLeoDir = g.os_path_finalize_join(g.app.homeDir, '.leo')
    if g.os_path_exists(homeLeoDir):
        return homeLeoDir
    ok = g.makeAllNonExistentDirectories(homeLeoDir)
    return homeLeoDir if ok else ''  # #1450
#@+node:ekr.20120209051836.10255: *8* LM.computeLeoDir
def computeLeoDir(self):
    # lm = self
    loadDir = g.app.loadDir
    return g.os_path_dirname(loadDir)
        # We don't want the result in sys.path
#@+node:ekr.20120209051836.10256: *8* LM.computeLoadDir
def computeLoadDir(self):
    """Returns the directory containing leo.py."""
    import sys
    try:
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = g.__file__  # was leo.__file__
        if path:
            # Possible fix for bug 735938:
            # Do the following only if path exists.
            << resolve symlinks >>
            if sys.platform == 'win32':
                if len(path) > 2 and path[1] == ':':
                    # Convert the drive name to upper case.
                    path = path[0].upper() + path[1:]
            path = g.os_path_finalize(path)
            loadDir = g.os_path_dirname(path)
        else: loadDir = None
        if (
            not loadDir or
            not g.os_path_exists(loadDir) or
            not g.os_path_isdir(loadDir)
        ):
            loadDir = os.getcwd()
            # From Marc-Antoine Parent.
            if loadDir.endswith("Contents/Resources"):
                loadDir += "/leo/plugins"
            else:
                g.pr("Exception getting load directory")
        loadDir = g.os_path_finalize(loadDir)
        return loadDir
    except Exception:
        print("Exception getting load directory")
        raise
#@+node:ekr.20120209051836.10257: *9* << resolve symlinks >>
if path.endswith('pyc'):
    srcfile = path[:-1]
    if os.path.islink(srcfile):
        path = os.path.realpath(srcfile)
#@+node:ekr.20120213164030.10697: *8* LM.computeMachineName
def computeMachineName(self):
    """Return the name of the current machine, i.e, HOSTNAME."""
    # This is prepended to leoSettings.leo or myLeoSettings.leo
    # to give the machine-specific setting name.
    # How can this be worth doing??
    try:
        import os
        name = os.getenv('HOSTNAME')
        if not name:
            name = os.getenv('COMPUTERNAME')
        if not name:
            import socket
            name = socket.gethostname()
    except Exception:
        name = ''
    return name
#@+node:ekr.20180318120148.1: *7* LM.computeThemeDirectories
def computeThemeDirectories(self):
    """
    Return a list of *existing* directories that might contain theme .leo files.
    """
    join = g.os_path_finalize_join
    home = g.app.homeDir
    leo = join(g.app.loadDir, '..')
    table = [
        home,
        join(home, 'themes'),
        join(home, '.leo'),
        join(home, '.leo', 'themes'),
        join(leo, 'themes'),
    ]
    return [g.os_path_normslashes(z) for z in table if g.os_path_exists(z)]
        # Make sure home has normalized slashes.
#@+node:ekr.20180318133620.1: *7* LM.computeThemeFilePath & helper
def computeThemeFilePath(self):
    """
    Return the absolute path to the theme .leo file, resolved using the search order for themes.
    
    1. Use the --theme command-line option if it exists.
    
    2. Otherwise, preload the first .leo file.
       Load the file given by @string theme-name setting.
       
    3. Finally, look up the @string theme-name in the already-loaded, myLeoSettings.leo.
       Load the file if setting exists.  Otherwise return None.
    """
    lm = self
    resolve = self.resolve_theme_path
    #
    # Step 1: Use the --theme command-line options if it exists
    path = resolve(lm.options.get('theme_path'), tag='--theme')
    if path:
        # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
        return path
    #
    # Step 2: look for the @string theme-name setting in the first loaded file.
    path = lm.files and lm.files[0]
    if path and g.os_path_exists(path):
        # Tricky: we must call lm.computeLocalSettings *here*.
        theme_c = lm.openSettingsFile(path)
        if theme_c:
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                c=theme_c,
                settings_d=lm.globalSettingsDict,
                bindings_d=lm.globalBindingsDict,
                localFlag=False,
            )
            setting = settings_d.get_string_setting('theme-name')
            if setting:
                tag = theme_c.shortFileName()
                path = resolve(setting, tag=tag)
                if path:
                    # Caller (LM.readGlobalSettingsFiles) sets lm.theme_path
                    return path
    #
    # Step 3: use the @string theme-name setting in myLeoSettings.leo.
    # Note: the setting should *never* appear in leoSettings.leo!
    setting = lm.globalSettingsDict.get_string_setting('theme-name')
    tag = 'myLeoSettings.leo'
    return resolve(setting, tag=tag)
#@+node:ekr.20180321124503.1: *8* LM.resolve_theme_path
def resolve_theme_path(self, fn, tag):
    """Search theme directories for the given .leo file."""
    if not fn:
        return None
    if not fn.endswith('.leo'):
        fn += '.leo'
    for directory in self.computeThemeDirectories():
        path = g.os_path_join(directory, fn)
            # Normalizes slashes, etc.
        if g.os_path_exists(path):
            return path
    print(f"theme .leo file not found: {fn}")
    return None
#@+node:ekr.20120211121736.10772: *7* LM.computeWorkbookFileName
def computeWorkbookFileName(self):
    """
    Return full path to the workbook.
    
    Return None if testing, or in batch mode, or if the containing
    directory does not exist.
    """
    # lm = self
    # Never create a workbook during unit tests or in batch mode.
    if g.unitTesting or g.app.batchMode:
        return None
    fn = g.app.config.getString(setting='default_leo_file') or '~/.leo/workbook.leo'
    fn = g.os_path_finalize(fn)
    directory = g.os_path_finalize(os.path.dirname(fn))
    # #1415.
    return fn if os.path.exists(directory) else None
#@+node:ekr.20120219154958.10485: *7* LM.reportDirectories
def reportDirectories(self, verbose):
    """Report directories."""
    if not verbose: return
    if 1:  # old
        for kind, theDir in (
            ('current', g.os_path_abspath(os.curdir)),
            ("load", g.app.loadDir),
            ("global config", g.app.globalConfigDir),
            ("home", g.app.homeDir),
        ):
            # g.blue calls g.es_print, and that's annoying.
            g.es(f"{kind} dir:", theDir, color='blue')
    else:
        aList = (
            'homeDir', 'homeLeoDir',
            'leoDir', 'loadDir',
            'extensionsDir', 'globalConfigDir')
        for ivar in aList:
            val = getattr(g.app, ivar)
            g.trace(f"{ivar:20}", val)
#@+node:ekr.20120215062153.10740: *6* LM.Settings
#@+node:ekr.20120130101219.10182: *7* LM.computeBindingLetter
def computeBindingLetter(self, c, path):
    lm = self
    if not path:
        return 'D'
    path = path.lower()
    table = (
        ('M', 'myLeoSettings.leo'),
        (' ', 'leoSettings.leo'),
        ('F', c.shortFileName()),
    )
    for letter, path2 in table:
        if path2 and path.endswith(path2.lower()):
            return letter
    if lm.theme_path and path.endswith(lm.theme_path.lower()):
        return 'T'
    if path == 'register-command' or path.find('mode') > -1:
        return '@'
    return 'D'
#@+node:ekr.20120223062418.10421: *7* LM.computeLocalSettings
def computeLocalSettings(self, c, settings_d, bindings_d, localFlag):
    """
    Merge the settings dicts from c's outline into *new copies of*
    settings_d and bindings_d.
    """
    lm = self
    shortcuts_d2, settings_d2 = lm.createSettingsDicts(c, localFlag)
    assert bindings_d
    assert settings_d
    if settings_d2:
        if g.app.trace_setting:
            key = g.app.config.munge(g.app.trace_setting)
            val = settings_d2.d.get(key)
            if val:
                fn = g.shortFileName(val.path)
                g.es_print(
                    f"--trace-setting: in {fn:20}: "
                    f"@{val.kind} {g.app.trace_setting}={val.val}")
        settings_d = settings_d.copy()
        settings_d.update(settings_d2)
    if shortcuts_d2:
        bindings_d = lm.mergeShortcutsDicts(c, bindings_d, shortcuts_d2, localFlag)
    return settings_d, bindings_d
#@+node:ekr.20121126202114.3: *7* LM.createDefaultSettingsDicts
def createDefaultSettingsDicts(self):
    """Create lm.globalSettingsDict & lm.globalBindingsDict."""
    settings_d = g.app.config.defaultsDict
    assert isinstance(settings_d, g.TypedDict), settings_d
    settings_d.setName('lm.globalSettingsDict')
    bindings_d = g.TypedDict(  # was TypedDictOfLists.
        name='lm.globalBindingsDict',
        keyType=type('s'),
        valType=g.BindingInfo,
    )
    return settings_d, bindings_d
#@+node:ekr.20120214165710.10726: *7* LM.createSettingsDicts
def createSettingsDicts(self, c, localFlag, theme=False):
    import leo.core.leoConfig as leoConfig
    if c:
        parser = leoConfig.SettingsTreeParser(c, localFlag)
            # returns the *raw* shortcutsDict, not a *merged* shortcuts dict.
        shortcutsDict, settingsDict = parser.traverse(theme=theme)
        return shortcutsDict, settingsDict
    return None, None
#@+node:ekr.20120223062418.10414: *7* LM.getPreviousSettings
def getPreviousSettings(self, fn):
    """
    Return the settings in effect for fn. Typically, this involves
    pre-reading fn.
    """
    lm = self
    settingsName = f"settings dict for {g.shortFileName(fn)}"
    shortcutsName = f"shortcuts dict for {g.shortFileName(fn)}"
    # A special case: settings in leoSettings.leo do *not* override
    # the global settings, that is, settings in myLeoSettings.leo.
    isLeoSettings = g.shortFileName(fn).lower() == 'leosettings.leo'
    exists = g.os_path_exists(fn)
    if fn and exists and lm.isLeoFile(fn) and not isLeoSettings:
        # Open the file usinging a null gui.
        try:
            g.app.preReadFlag = True
            c = lm.openSettingsFile(fn)
        finally:
            g.app.preReadFlag = False
        # Merge the settings from c into *copies* of the global dicts.
        d1, d2 = lm.computeLocalSettings(c,
            lm.globalSettingsDict,
            lm.globalBindingsDict,
            localFlag=True)
                # d1 and d2 are copies.
        d1.setName(settingsName)
        d2.setName(shortcutsName)
        return PreviousSettings(d1, d2)
    #
    # The file does not exist, or is not valid.
    # Get the settings from the globals settings dicts.
    d1 = lm.globalSettingsDict.copy(settingsName)
    d2 = lm.globalBindingsDict.copy(shortcutsName)
    return PreviousSettings(d1, d2)
#@+node:ekr.20120214132927.10723: *7* LM.mergeShortcutsDicts & helpers
def mergeShortcutsDicts(self, c, old_d, new_d, localFlag):
    """
    Create a new dict by overriding all shortcuts in old_d by shortcuts in new_d.

    Both old_d and new_d remain unchanged.
    """
    lm = self
    if not old_d: return new_d
    if not new_d: return old_d
    bi_list = new_d.get(g.app.trace_setting)
    if bi_list:
        # This code executed only if g.app.trace_setting exists.
        for bi in bi_list:
            fn = bi.kind.split(' ')[-1]
            stroke = c.k.prettyPrintKey(bi.stroke)
            if bi.pane and bi.pane != 'all':
                pane = f" in {bi.pane} panes"
            else:
                pane = ''
    inverted_old_d = lm.invert(old_d)
    inverted_new_d = lm.invert(new_d)
    # #510 & #327: always honor --trace-binding here.
    if g.app.trace_binding:
        binding = g.app.trace_binding
        # First, see if the binding is for a command. (Doesn't work for plugin commands).
        if localFlag and binding in c.k.killedBindings:
            g.es_print(
                f"--trace-binding: {c.shortFileName()} "
                f"sets {binding} to None")
        elif localFlag and binding in c.commandsDict:
             d = c.k.computeInverseBindingDict()
             g.trace(
                f"--trace-binding: {c.shortFileName():20} "
                f"binds {binding} to {d.get(binding) or []}")
        else:
            binding = g.app.trace_binding
            stroke = g.KeyStroke(binding)
            bi_list = inverted_new_d.get(stroke)
            if bi_list:
                print('')
                for bi in bi_list:
                    fn = bi.kind.split(' ')[-1]  # bi.kind #
                    stroke2 = c.k.prettyPrintKey(stroke)
                    if bi.pane and bi.pane != 'all':
                        pane = f" in {bi.pane} panes"
                    else:
                        pane = ''
                    g.es_print(
                        f"--trace-binding: {fn:20} binds {stroke2} "
                        f"to {bi.commandName:>20}{pane}")
                print('')
    # Fix bug 951921: check for duplicate shortcuts only in the new file.
    lm.checkForDuplicateShortcuts(c, inverted_new_d)
    inverted_old_d.update(inverted_new_d)  # Updates inverted_old_d in place.
    result = lm.uninvert(inverted_old_d)
    return result
#@+node:ekr.20120311070142.9904: *8* LM.checkForDuplicateShortcuts
def checkForDuplicateShortcuts(self, c, d):
    """
    Check for duplicates in an "inverted" dictionary d
    whose keys are strokes and whose values are lists of BindingInfo nodes.

    Duplicates happen only if panes conflict.
    """
    # lm = self
    # Fix bug 951921: check for duplicate shortcuts only in the new file.
    for ks in sorted(list(d.keys())):
        duplicates, panes = [], ['all']
        aList = d.get(ks)
            # A list of bi objects.
        aList2 = [z for z in aList if not z.pane.startswith('mode')]
        if len(aList) > 1:
            for bi in aList2:
                if bi.pane in panes:
                    duplicates.append(bi)
                else:
                    panes.append(bi.pane)
        if duplicates:
            bindings = list(set([z.stroke.s for z in duplicates]))
            if len(bindings) == 1:
                kind = 'duplicate, (not conflicting)'
            else:
                kind = 'conflicting'
            g.es_print(f"{kind} key bindings in {c.shortFileName()}")
            for bi in aList2:
                g.es_print(f"{bi.pane:6} {bi.stroke.s} {bi.commandName}")
#@+node:ekr.20120214132927.10724: *8* LM.invert
def invert(self, d):
    """
    Invert a shortcut dict whose keys are command names,
    returning a dict whose keys are strokes.
    """
    result = g.TypedDict(  # was TypedDictOfLists.
        name=f"inverted {d.name()}",
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in d.keys():
        for bi in d.get(commandName, []):
            stroke = bi.stroke  # This is canonicalized.
            bi.commandName = commandName  # Add info.
            assert stroke
            result.add_to_list(stroke, bi)
    return result
#@+node:ekr.20120214132927.10725: *8* LM.uninvert
def uninvert(self, d):
    """
    Uninvert an inverted shortcut dict whose keys are strokes,
    returning a dict whose keys are command names.
    """
    assert d.keyType == g.KeyStroke, d.keyType
    result = g.TypedDict(  # was TypedDictOfLists.
        name=f"uninverted {d.name()}",
        keyType=type('commandName'),
        valType=g.BindingInfo,
    )
    for stroke in d.keys():
        for bi in d.get(stroke, []):
            commandName = bi.commandName
            assert commandName
            result.add_to_list(commandName, bi)
    return result
#@+node:ekr.20120222103014.10312: *7* LM.openSettingsFile (new trace)
def openSettingsFile(self, fn):
    """
    Open a settings file with a null gui.  Return the commander.

    The caller must init the c.config object.
    """
    lm = self
    if not fn:
        return None
    theFile = lm.openLeoOrZipFile(fn)
    if not theFile:
        return None  # Fix #843.
    if not any([g.app.unitTesting, g.app.silentMode, g.app.batchMode]):
        # This occurs early in startup, so use the following.
        s = f"reading settings in {fn}"
        if 'startup' in g.app.debug:
            print(s)
        g.es(s, color='blue')
        # A useful trace.
        # g.trace('%20s' % g.shortFileName(fn), g.callers(3))
    # Changing g.app.gui here is a major hack.  It is necessary.
    oldGui = g.app.gui
    g.app.gui = g.app.nullGui
    c = g.app.newCommander(fn)
    frame = c.frame
    frame.log.enable(False)
    g.app.lockLog()
    g.app.openingSettingsFile = True
    try:
        ok = c.fileCommands.openLeoFile(theFile, fn,
                readAtFileNodesFlag=False, silent=True)
                    # closes theFile.
    finally:
        g.app.openingSettingsFile = False
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(fn)
    g.app.gui = oldGui
    return c if ok else None
#@+node:ekr.20120213081706.10382: *7* LM.readGlobalSettingsFiles
def readGlobalSettingsFiles(self):
    """
    Read leoSettings.leo and myLeoSettings.leo using a null gui.
    
    New in Leo 6.1: this sets ivars for the ActiveSettingsOutline class.
    """
    trace = 'themes' in g.app.debug
    lm = self
    # Open the standard settings files with a nullGui.
    # Important: their commanders do not exist outside this method!
    old_commanders = g.app.commanders()
    lm.leo_settings_path = lm.computeLeoSettingsPath()
    lm.my_settings_path = lm.computeMyLeoSettingsPath()
    lm.leo_settings_c = lm.openSettingsFile(self.leo_settings_path)
    lm.my_settings_c = lm.openSettingsFile(self.my_settings_path)
    commanders = [lm.leo_settings_c, lm.my_settings_c]
    commanders = [z for z in commanders if z]
    settings_d, bindings_d = lm.createDefaultSettingsDicts()
    for c in commanders:
        # Merge the settings dicts from c's outline into
        # *new copies of* settings_d and bindings_d.
        settings_d, bindings_d = lm.computeLocalSettings(
            c, settings_d, bindings_d, localFlag=False)
    # Adjust the name.
    bindings_d.setName('lm.globalBindingsDict')
    lm.globalSettingsDict = settings_d
    lm.globalBindingsDict = bindings_d
    # Add settings from --theme or @string theme-name files.
    # This must be done *after* reading myLeoSettigns.leo.
    lm.theme_path = lm.computeThemeFilePath()
    if lm.theme_path:
        lm.theme_c = lm.openSettingsFile(lm.theme_path)
        if lm.theme_c:
            # Merge theme_c's settings into globalSettingsDict.
            settings_d, junk_shortcuts_d = lm.computeLocalSettings(
                lm.theme_c, settings_d, bindings_d, localFlag=False)
            lm.globalSettingsDict = settings_d
            # Set global vars
            g.app.theme_directory = g.os_path_dirname(lm.theme_path)
                # Used by the StyleSheetManager.
            if 0:
                # Not necessary **provided** that theme .leo files
                # set @string theme-name to the name of the .leo file.
                g.app.theme_color = settings_d.get_string_setting('color-theme')
                g.app.theme_name = settings_d.get_string_setting('theme-name')
                if trace:
                    g.trace('\n=====\n')
                    print(f" g.app.theme_path: {g.app.theme_directory}")
                    print(f" g.app.theme_name: {g.app.theme_name}")
                    print(f"g.app.theme_color: {g.app.theme_color}")
                    print('')
    # Clear the cache entries for the commanders.
    # This allows this method to be called outside the startup logic.
    for c in commanders:
        if c not in old_commanders:
            g.app.forgetOpenFile(c.fileName())
#@+node:ekr.20120214165710.10838: *7* LM.traceSettingsDict
def traceSettingsDict(self, d, verbose=False):
    if verbose:
        print(d)
        for key in sorted(list(d.keys())):
            gs = d.get(key)
            print(f"{key:35} {g.shortFileName(gs.path):17} {gs.val}")
        if d: print('')
    else:
        # print(d)
        print(f"{d.name} {len(d.d.keys())}")
#@+node:ekr.20120214165710.10822: *7* LM.traceShortcutsDict
def traceShortcutsDict(self, d, verbose=False):
    if verbose:
        print(d)
        for key in sorted(list(d.keys())):
            val = d.get(key)
            # print('%20s %s' % (key,val.dump()))
            print(f"{key:35} {[z.stroke for z in val]}")
        if d: print('')
    else:
        print(d)
#@+node:ekr.20120219154958.10452: *6* LM.load & helpers
def load(self, fileName=None, pymacs=None):
    """Load the indicated file"""
    lm = self
    t1 = time.process_time()
    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    print('')  # Give some separation for the coming traces.
    if not lm.isValidPython():
        return
    lm.doPrePluginsInit(fileName, pymacs)
        # sets lm.options and lm.files
    g.app.computeSignon()
    g.app.printSignon()
    if lm.options.get('version'):
        return
    if not g.app.gui:
        return
    g.app.disable_redraw = True
        # Disable redraw until all files are loaded.
    #
    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed:
        return
    g.app.idleTimeManager.start()
    #
    # Phase 3: after loading plugins. Create one or more frames.
    if lm.options.get('script') and not self.files:
        ok = True
    else:
        ok = lm.doPostPluginsInit()
        # Fix #579: Key bindings don't take for commands defined in plugins
        g.app.makeAllBindings()
        if ok and g.app.diff:
            lm.doDiff()
    if not ok:
        return
    g.es('')  # Clears horizontal scrolling in the log pane.
    if g.app.listen_to_log_flag:
        g.app.listenToLog()
    if 'startup' in g.app.debug:
        t2 = time.process_time()
        g.es_print(f"startup time: {t2 - t1:5.2f} sec")
    g.app.gui.runMainLoop()
    # For scripts, the gui is a nullGui.
    # and the gui.setScript has already been called.
#@+node:ekr.20150225133846.7: *7* LM.doDiff
def doDiff(self):
    """Support --diff option after loading Leo."""
    if len(self.old_argv[2:]) == 2:
        pass  # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
#@+node:ekr.20120219154958.10487: *7* LM.doPostPluginsInit & helpers
def doPostPluginsInit(self):
    """Create a Leo window for each file in the lm.files list."""
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False  # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.Show it and all queued messages.
    c = c1 = fn = None
    if lm.files:
        try:  # #1403.
            for n, fn in enumerate(lm.files):
                lm.more_cmdline_files = n < len(lm.files) - 1
                c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                    # Returns None if the file is open in another instance of Leo.
                if c and not c1:  # #1416:
                    c1 = c
        except Exception:
            g.es_print(f"Unexpected exception reading {fn!r}")
            g.es_exception()
            c = None
    # Load (and save later) a session *only* if the command line contains no files.
    g.app.loaded_session = not lm.files
    if g.app.sessionManager and g.app.loaded_session:
        try:  # #1403.
            aList = g.app.sessionManager.load_snapshot()
            if aList:
                g.app.sessionManager.load_session(c1, aList)
                # #659.
                if g.app.windowList:
                    c = c1 = g.app.windowList[0].c
                else:
                    c = c1 = None
        except Exception:
            g.es_print('Can not load session')
            g.es_exception()
    # Enable redraws.
    g.app.disable_redraw = False
    if not c1:
        try:  # #1403.
            c1 = lm.openEmptyWorkBook()
                # Calls LM.loadLocalFile.
        except Exception:
            g.es_print('Can not create empty workbook')
            g.es_exception()
    c = c1
    if not c:
        # Leo is out of options: Force an immediate exit.
        return False
    # #199.
    g.app.runAlreadyOpenDialog(c1)
    #
    # Final inits...
    # For qt gui, select the first-loaded tab.
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            factory.setTabForCommander(c)
    g.app.logInited = True
    g.app.initComplete = True
    c.setLog()
    c.redraw()
    g.doHook("start2", c=c, p=c.p, fileName=c.fileName())
    c.initialFocusHelper()
    screenshot_fn = lm.options.get('screenshot_fn')
    if screenshot_fn:
        lm.make_screen_shot(screenshot_fn)
        return False  # Force an immediate exit.
    return True
#@+node:ekr.20120219154958.10489: *8* LM.make_screen_shot
def make_screen_shot(self, fn):
    """Create a screenshot of the present Leo outline and save it to path."""
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
#@+node:ekr.20131028155339.17098: *8* LM.openEmptyWorkBook
def openEmptyWorkBook(self):
    """Open an empty frame and paste the contents of CheatSheet.leo into it."""
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    if not fn:
        return None  # #1415
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    if not c:
        return None  # #1201: AttributeError below.
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # #933: Save clipboard.
        old_clipboard = g.app.gui.getTextFromClipboard()
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.setCurrentPosition(p2)  # 1380
                c2.copyOutline()
                p = c.pasteOutline()
                # #1380 & #1381: Add guard & use vnode methods to prevent redraw.
                if p:
                    c.setCurrentPosition(p)  # 1380
                    p.v.contract()
                    p.v.clearDirty()
            c2.close(new_c=c)
            # Delete the dummy first node.
            root = c.rootPosition()
            root.doDelete(newNode=root.next())
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.clearChanged()
            c.redraw(c.rootPosition())  # # 1380: Select the root.
        # #933: Restore clipboard
        g.app.gui.replaceClipboardWith(old_clipboard)
    return c
#@+node:ekr.20120219154958.10477: *7* LM.doPrePluginsInit & helpers
def doPrePluginsInit(self, fileName, pymacs):
    """ Scan options, set directories and read settings."""
    lm = self
    lm.computeStandardDirectories()
    lm.adjustSysPath()
        # A do-nothing.
    # Scan the options as early as possible.
    lm.options = options = lm.scanOptions(fileName, pymacs)
        # also sets lm.files.
    if options.get('version'):
        return
    script = options.get('script')
    verbose = script is None
    # Init the app.
    lm.initApp(verbose)
    g.app.setGlobalDb()
    lm.reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    lm.readGlobalSettingsFiles()
        # reads only standard settings files, using a null gui.
        # uses lm.files[0] to compute the local directory
        # that might contain myLeoSettings.leo.
    # Read the recent files file.
    localConfigFile = lm.files[0] if lm.files else None
    g.app.recentFilesManager.readRecentFiles(localConfigFile)
    # Create the gui after reading options and settings.
    lm.createGui(pymacs)
    # We can't print the signon until we know the gui.
    g.app.computeSignon()  # Set app.signon/signon1 for commanders.
#@+node:ekr.20170302093006.1: *8* LM.createAllImporterData & helpers
def createAllImporterData(self):
    """
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    """
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
#@+node:ekr.20140724064952.18037: *9* LM.createImporterData & helper
def createImporterData(self):
    """Create the data structures describing importer plugins."""
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[:-3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        f"leo.plugins.importers.{module_name}")
                    self.parse_importer_dict(sfn, m)
                    # print('createImporterData', m.__name__)
                except Exception:
                    g.warning(f"can not import leo.plugins.importers.{module_name}")
#@+node:ekr.20140723140445.18076: *10* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    """
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    """
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        # scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning(f"leo/plugins/importers/{sfn} has no importer_dict")
#@+node:ekr.20140728040812.17990: *9* LM.createWritersData & helper
def createWritersData(self):
    """Create the data structures describing writer plugins."""
    trace = False and 'createWritersData' not in g.app.debug_dict
        # Do *not* remove this trace.
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module(f"leo.plugins.writers.{sfn[:-3]}")
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning(f"can not import leo.plugins.writers.{sfn}")
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: See #40.
#@+node:ekr.20140728040812.17991: *10* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    """
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    """
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace(
                        f"{sfn}: duplicate {s} class {aClass.__name__} "
                        f"in {m.__file__}:")
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace(f"{sfn}: duplicate {ext} class", aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning(f"leo/plugins/writers/{sfn} has no writer_dict")
#@+node:ekr.20120219154958.10478: *8* LM.createGui
def createGui(self, pymacs):
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None  # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            pass
            # This can happen when launching Leo from IPython.
            # This can also happen when leoID does not exist.
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
#@+node:ekr.20120219154958.10479: *8* LM.createSpecialGui
def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        g.app.createDefaultGui()
#@+node:ekr.20120219154958.10480: *8* LM.adjustSysPath
def adjustSysPath(self):
    """
    Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:
    """
    pass
#@+node:ekr.20120219154958.10482: *8* LM.getDefaultFile
def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default-leo-file')
    fn = g.os_path_finalize(fn)
    if not fn:
        return None
    if g.os_path_exists(fn):
        return fn
    if g.os_path_isabs(fn):
        # Create the file.
        g.error(f"Using default leo file name:\n{fn}")
        return fn
    # It's too risky to open a default file if it is relative.
    return None
#@+node:ekr.20120219154958.10484: *8* LM.initApp
def initApp(self, verbose):

    self.createAllImporterData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    import leo.core.leoBackground as leoBackground
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoSessions as leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        import leo.core.leoIPython as leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython  # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
#@+node:ekr.20120219154958.10486: *8* LM.scanOptions & helpers
def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''beauty,cache,coloring,dock,drawing,events,focus,git,gnx,
      ipython,keys,plugins,save,select,shutdown,size,startup,themes'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
#@+node:ekr.20180312150559.1: *9* LM.addOptionsToParser
@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@<file> type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
#@+node:ekr.20120219154958.10483: *9* LM.computeFilesList
def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
#@+node:ekr.20180312150805.1: *9* LM.doGuiOption
def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
#@+node:ekr.20180312152329.1: *9* LM.doLoadTypeOption
def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
#@+node:ekr.20180312152609.1: *9* LM.doScreenShotOption
def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
#@+node:ekr.20180312153008.1: *9* LM.doScriptOption
def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
#@+node:ekr.20180312151544.1: *9* LM.doSimpleOptions
def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
#@+node:ekr.20190923170528.1: *9* LM.doWindowSpotOption
def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
#@+node:ekr.20180312154839.1: *9* LM.doWindowSizeOption
def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
#@+node:ekr.20160718072648.1: *8* LM.setStdStreams
def setStdStreams(self):
    """
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    """
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    import leo.core.leoGlobals as g

    # Define class LeoStdOut
    @others
    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
#@+node:ekr.20160718091844.1: *9* class LeoStdOut
class LeoStdOut:
    """A class to put stderr & stdout to Leo's log pane."""

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
    @others
#@+node:ekr.20160718102306.1: *10* LeoStdOut.write
def write(self, *args, **keys):
    """Put all non-keyword args to the log pane, as in g.es."""
    #
    # Tracing will lead to unbounded recursion unless
    # sys.stderr has been redirected on the command line.
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return
    if log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color, newline),)
#@+node:ekr.20120219154958.10491: *7* LM.isValidPython
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    message = (
        f"Leo requires Python {g.minimum_python_version} or higher"
        f"You may download Python from http://python.org/download/")
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, g.minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                d = g.EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                g.es_exception()
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20120223062418.10393: *7* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
#@+node:ekr.20120223062418.10394: *8* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    """Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui, previousSettings=previousSettings)
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # this commander is associated with sqlite db
        c.sqlite_connection = theFile
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
#@+node:ekr.20120223062418.10405: *9* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
#@+node:ekr.20120223062418.10406: *9* LM.findOpenFile
def findOpenFile(self, fn):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20120223062418.10407: *9* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # #181: Honor focus requests.
#@+node:ekr.20120223062418.10408: *9* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20120223062418.10419: *9* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
#@+node:ekr.20120224161905.10030: *9* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
#@+node:ekr.20120223062418.10416: *9* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10410: *9* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        s = g.toUnicode(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10412: *9* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = g.os_path_finalize(g.os_path_dirname(fn))  # 1341
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=False)
            # #970: Never close Leo here.
    return ok
#@+node:ekr.20160430063406.1: *6* LM.revertCommander
def revertCommander(self, c):
    """Revert c to the previously saved contents."""
    lm = self
    fn = c.mFileName
    # Re-read the file.
    theFile = lm.openLeoOrZipFile(fn)
    if theFile:
        c.fileCommands.initIvars()
        c.fileCommands.getLeoFile(theFile, fn, checkOpenFiles=False)
            # Closes the file.
#@+node:ekr.20120223062418.10420: *5* class PreviousSettings
class PreviousSettings:
    """
    A class holding the settings and shortcuts dictionaries
    that are computed in the first pass when loading local
    files and passed to the second pass.
    """

    def __init__(self, settingsDict, shortcutsDict):
        assert isinstance(settingsDict, g.TypedDict), repr(settingsDict)
        assert isinstance(shortcutsDict, g.TypedDict), repr(shortcutsDict)
            # was TypedDictOfLists.
        self.settingsDict = settingsDict
        self.shortcutsDict = shortcutsDict

    def __repr__(self):
        return (
            f"<PreviousSettings\n"
            f"{self.settingsDict}\n"
            f"{self.shortcutsDict}\n>")

    __str__ = __repr__
#@+node:ekr.20120225072226.10283: *5* class RecentFilesManager
class RecentFilesManager:
    """A class to manipulate leoRecentFiles.txt."""

    def __init__(self):

        self.edit_headline = 'Recent files. Do not change this headline!'
            # Headline used by
        self.groupedMenus = []
            # Set in rf.createRecentFilesMenuItems.
        self.recentFiles = []
            # List of g.Bunches describing .leoRecentFiles.txt files.
        self.recentFilesMenuName = 'Recent Files'
            # May be changed later.
        self.recentFileMessageWritten = False
            # To suppress all but the first message.
        self.write_recent_files_as_needed = False
            # Will be set later.
    @others
#@+node:ekr.20041201080436: *6* rf.appendToRecentFiles
def appendToRecentFiles(self, files):
    rf = self
    files = [theFile.strip() for theFile in files]

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for name in files:
        # Remove all variants of name.
        for name2 in rf.recentFiles[:]:
            if munge(name) == munge(name2):
                rf.recentFiles.remove(name2)
        rf.recentFiles.append(name)
#@+node:ekr.20120225072226.10289: *6* rf.cleanRecentFiles
def cleanRecentFiles(self, c):
    """
    Remove items from the recent files list that no longer exist.
    
    This almost never does anything because Leo's startup logic removes
    nonexistent files from the recent files list.
    """
    result = [z for z in self.recentFiles if g.os_path_exists(z)]
    if result != self.recentFiles:
        for path in result:
            self.updateRecentFiles(path)
        self.writeRecentFilesFile(c, force=True)
#@+node:ekr.20180212141017.1: *6* rf.demangleRecentFiles
def demangleRecentFiles(self, c, data):
    """Rewrite recent files based on c.config.getData('path-demangle')"""
    changes = []
    replace = None
    for line in data:
        text = line.strip()
        if text.startswith('REPLACE: '):
            replace = text.split(None, 1)[1].strip()
        if text.startswith('WITH:') and replace is not None:
            with_ = text[5:].strip()
            changes.append((replace, with_))
            g.es(f"{replace} -> {with_}")
    orig = [z for z in self.recentFiles if z.startswith("/")]
    self.recentFiles = []
    for i in orig:
        t = i
        for change in changes:
            t = t.replace(*change)
        self.updateRecentFiles(t)
    self.writeRecentFilesFile(c, force=True)
        # Force the write message.
#@+node:ekr.20120225072226.10297: *6* rf.clearRecentFiles
def clearRecentFiles(self, c):
    """Clear the recent files list, then add the present file."""
    rf = self; u = c.undoer; menu = c.frame.menu
    bunch = u.beforeClearRecentFiles()
    recentFilesMenu = menu.getMenu(self.recentFilesMenuName)
    menu.deleteRecentFilesMenuItems(recentFilesMenu)
    rf.recentFiles = [c.fileName()]
    for frame in g.app.windowList:
        rf.createRecentFilesMenuItems(frame.c)
    u.afterClearRecentFiles(bunch)
    # Write the file immediately.
    rf.writeRecentFilesFile(c, force=True)
        # Force the write message.
#@+node:ekr.20120225072226.10301: *6* rf.createRecentFilesMenuItems
def createRecentFilesMenuItems(self, c):
    rf = self
    menu = c.frame.menu
    recentFilesMenu = menu.getMenu(self.recentFilesMenuName)
    if not recentFilesMenu and not g.unitTesting:
        return
    # Delete all previous entries.
    menu.deleteRecentFilesMenuItems(recentFilesMenu)
    # Create the permanent (static) menu entries.
    table = rf.getRecentFilesTable()
    menu.createMenuEntries(recentFilesMenu, table)
    # Create all the other entries (a maximum of 36).
    accel_ch = string.digits + string.ascii_uppercase  # Not a unicode problem.
    i = 0
    n = len(accel_ch)
    # see if we're grouping when files occur in more than one place
    rf_group = c.config.getBool("recent-files-group")
    rf_always = c.config.getBool("recent-files-group-always")
    groupedEntries = rf_group or rf_always
    if groupedEntries:  # if so, make dict of groups
        dirCount = {}
        for fileName in rf.getRecentFiles()[:n]:
            dirName, baseName = g.os_path_split(fileName)
            if baseName not in dirCount:
                dirCount[baseName] = {'dirs': [], 'entry': None}
            dirCount[baseName]['dirs'].append(dirName)
    for name in rf.getRecentFiles()[:n]:
        # pylint: disable=cell-var-from-loop
        if name.strip() == "":
            continue  # happens with empty list/new file

        def recentFilesCallback(event=None, c=c, name=name):
            c.openRecentFile(fn=name)

        if groupedEntries:
            dirName, baseName = g.os_path_split(name)
            entry = dirCount[baseName]
            if len(entry['dirs']) > 1 or rf_always:  # sub menus
                if entry['entry'] is None:
                    entry['entry'] = menu.createNewMenu(baseName, "Recent Files...")
                    # acts as a flag for the need to create the menu
                c.add_command(menu.getMenu(baseName), label=dirName,
                    command=recentFilesCallback, underline=0)
            else:  # single occurence, no submenu
                c.add_command(recentFilesMenu, label=baseName,
                    command=recentFilesCallback, underline=0)
        else:  # original behavior
            label = f"{accel_ch[i]} {g.computeWindowTitle(name)}"
            c.add_command(recentFilesMenu, label=label,
                command=recentFilesCallback, underline=0)
        i += 1
    if groupedEntries:  # store so we can delete them later
        rf.groupedMenus = [z for z in dirCount
            if dirCount[z]['entry'] is not None]
#@+node:vitalije.20170703115609.1: *6* rf.editRecentFiles
def editRecentFiles(self, c):
    """
    Dump recentFiles into new node appended as lastTopLevel, selects it and
    request focus in body.

    NOTE: command write-edited-recent-files assume that headline of this
    node is not changed by user.
    """
    rf = self
    p1 = c.lastTopLevel().insertAfter()
    p1.h = self.edit_headline
    p1.b = '\n'.join(rf.recentFiles)
    c.redraw()
    c.selectPosition(p1)
    c.redraw()
    c.bodyWantsFocusNow()
    g.es('edit list and run write-rff to save recentFiles')
#@+node:ekr.20120225072226.10286: *6* rf.getRecentFiles
def getRecentFiles(self):
    # Fix #299: Leo loads a deleted file.
    self.recentFiles = [z for z in self.recentFiles
        if g.os_path_exists(z)]
    return self.recentFiles
#@+node:ekr.20120225072226.10304: *6* rf.getRecentFilesTable
def getRecentFilesTable(self):
    return (
        "*clear-recent-files",
        "*clean-recent-files",
        "*demangle-recent-files",
        "*sort-recent-files",
        ("-", None, None),
    )
#@+node:ekr.20070224115832: *6* rf.readRecentFiles & helpers
def readRecentFiles(self, localConfigFile):
    """Read all .leoRecentFiles.txt files."""
    # The order of files in this list affects the order of the recent files list.
    rf = self
    seen = []
    localConfigPath = g.os_path_dirname(localConfigFile)
    for path in (g.app.homeLeoDir, g.app.globalConfigDir, localConfigPath):
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
        if path and path not in seen:
            ok = rf.readRecentFilesFile(path)
            if ok: seen.append(path)
    if not seen and rf.write_recent_files_as_needed:
        rf.createRecentFiles()
#@+node:ekr.20061010121944: *7* rf.createRecentFiles
def createRecentFiles(self):
    """
    Try to create .leoRecentFiles.txt, in the users home directory, or in
    Leo's config directory if that fails.
    """
    for theDir in (g.app.homeLeoDir, g.app.globalConfigDir):
        if theDir:
            fn = g.os_path_join(theDir, '.leoRecentFiles.txt')
            try:
                with open(fn, 'w'):
                    g.red('created', fn)
                    return
            except IOError:
                g.error('can not create', fn)
                g.es_exception()
#@+node:ekr.20050424115658: *7* rf.readRecentFilesFile
def readRecentFilesFile(self, path):

    fileName = g.os_path_join(path, '.leoRecentFiles.txt')
    if not g.os_path_exists(fileName):
        return False
    try:
        with io.open(fileName, encoding='utf-8', mode='r') as f:
            try:  # Fix #471.
                lines = f.readlines()
            except Exception:
                lines = None
    except IOError:
        # The file exists, so FileNotFoundError is not possible.
        g.trace('can not open', fileName)
        return False
    if lines and self.sanitize(lines[0]) == 'readonly':
        lines = lines[1:]
    if lines:
        lines = [g.toUnicode(g.os_path_normpath(line)) for line in lines]
        self.appendToRecentFiles(lines)
    return True
#@+node:ekr.20120225072226.10285: *6* rf.sanitize
def sanitize(self, name):
    """Return a sanitized file name."""
    if name is None:
        return None
    name = name.lower()
    for ch in ('-', '_', ' ', '\n'):
        name = name.replace(ch, '')
    return name or None
#@+node:ekr.20120215072959.12478: *6* rf.setRecentFiles
def setRecentFiles(self, files):
    """Update the recent files list."""
    rf = self
    rf.appendToRecentFiles(files)
#@+node:ekr.20120225072226.10293: *6* rf.sortRecentFiles
def sortRecentFiles(self, c):
    """Sort the recent files list."""
    rf = self

    def key(path):
        # Sort only the base name.  That's what will appear in the menu.
        s = g.os_path_basename(path)
        return s.lower() if sys.platform.lower().startswith('win') else s

    aList = sorted(rf.recentFiles, key=key)
    rf.recentFiles = []
    for z in reversed(aList):
        rf.updateRecentFiles(z)
    rf.writeRecentFilesFile(c, force=True)
        # Force the write message.
#@+node:ekr.20031218072017.2083: *6* rf.updateRecentFiles
def updateRecentFiles(self, fileName):
    """Create the RecentFiles menu.  May be called with Null fileName."""
    rf = self
    if g.app.unitTesting: return

    def munge(name):
        return g.os_path_finalize(name or '').lower()

    def munge2(name):
        return g.os_path_finalize_join(g.app.loadDir, name or '')

    # Update the recent files list in all windows.

    if fileName:
        for frame in g.app.windowList:
            # Remove all versions of the file name.
            for name in rf.recentFiles:
                if (
                    munge(fileName) == munge(name) or
                    munge2(fileName) == munge2(name)
                ):
                    rf.recentFiles.remove(name)
            rf.recentFiles.insert(0, fileName)
            # Recreate the Recent Files menu.
            rf.createRecentFilesMenuItems(frame.c)
    else:
        for frame in g.app.windowList:
            rf.createRecentFilesMenuItems(frame.c)
#@+node:vitalije.20170703115616.1: *6* rf.writeEditedRecentFiles
def writeEditedRecentFiles(self, c):
    """
    Write content of "edit_headline" node as recentFiles and recreates
    menues.
    """
    rf = self; p = c.p
    p = g.findNodeAnywhere(c, self.edit_headline)
    if p:
        files = [z for z in p.b.splitlines() if z and g.os_path_exists(z)]
        rf.recentFiles = files
        rf.writeRecentFilesFile(c, force=False)
        rf.updateRecentFiles(None)
        c.selectPosition(p)
        c.deleteOutline()
    else:
        g.red('not found:', self.edit_headline)
#@+node:ekr.20050424114937.2: *6* rf.writeRecentFilesFile & helper
def writeRecentFilesFile(self, c, force=False):
    """
    Write the appropriate .leoRecentFiles.txt file.

    Write a message if force is True, or if it hasn't been written yet.
    """
    tag = '.leoRecentFiles.txt'
    rf = self
    # tag:#661. Do nothing if in leoBride.
    if g.app.unitTesting or g.app.inBridge:
        return
    localFileName = c.fileName()
    if localFileName:
        localPath, junk = g.os_path_split(localFileName)
    else:
        localPath = None
    written = False
    seen = []
    for path in (localPath, g.app.globalConfigDir, g.app.homeLeoDir):
        if path:
            fileName = g.os_path_join(path, tag)
            if g.os_path_exists(fileName) and fileName.lower() not in seen:
                seen.append(fileName.lower())
                ok = rf.writeRecentFilesFileHelper(fileName)
                if force or not rf.recentFileMessageWritten:
                    if ok:
                        if not g.app.silentMode:
                            # Fix #459:
                            g.es_print(f"wrote recent file: {fileName}")
                        written = True
                    else:
                        g.error(f"failed to write recent file: {fileName}")
                # Bug fix: Leo 4.4.6: write *all* recent files.
    if written:
        rf.recentFileMessageWritten = True
    else:
        # Attempt to create .leoRecentFiles.txt in the user's home directory.
        if g.app.homeLeoDir:
            fileName = g.os_path_finalize_join(g.app.homeLeoDir, tag)
            if not g.os_path_exists(fileName):
                g.red(f"creating: {fileName}")
            rf.writeRecentFilesFileHelper(fileName)
#@+node:ekr.20050424131051: *7* rf.writeRecentFilesFileHelper
def writeRecentFilesFileHelper(self, fileName):
    # Don't update the file if it begins with read-only.
    #
    # Part 1: Return False if the first line is "readonly".
    #         It's ok if the file doesn't exist.
    if g.os_path_exists(fileName):
        with io.open(fileName, encoding='utf-8', mode='r') as f:
            try:
                # Fix #471.
                lines = f.readlines()
            except Exception:
                lines = None
            if lines and self.sanitize(lines[0]) == 'readonly':
                return False
    # Part 2: write the files.
    try:
        with io.open(fileName, encoding='utf-8', mode='w') as f:
            s = '\n'.join(self.recentFiles) if self.recentFiles else '\n'
            f.write(g.toUnicode(s))
            return True
    except IOError:
        g.error('error writing', fileName)
        g.es_exception()
    except Exception:
        g.error('unexpected exception writing', fileName)
        g.es_exception()
        if g.unitTesting: raise
    return False
#@+node:ekr.20150514125218.1: *5* Top-level-commands
#@+node:ekr.20150514125218.2: *6* ctrl-click-at-cursor
@g.command('ctrl-click-at-cursor')
def ctrlClickAtCursor(event):
    """Simulate a control-click at the cursor."""
    c = event.get('c')
    if c:
        g.openUrlOnClick(event)
#@+node:ekr.20180213045148.1: *6* demangle-recent-files
@g.command('demangle-recent-files')
def demangle_recent_files_command(event):
    """
    Path demangling potentially alters the paths in the recent files list
    according to find/replace patterns in the @data path-demangle setting.
    For example:
        
        REPLACE: .gnome-desktop
        WITH: My Desktop
        
    The default setting specifies no patterns.
    """
    c = event and event.get('c')
    if c:
        data = c.config.getData('path-demangle')
        if data:
            g.app.recentFilesManager.demangleRecentFiles(c, data)
        else:
            g.es_print('No patterns in @data path-demangle')
#@+node:ekr.20150514125218.3: *6* enable/disable/toggle-idle-time-events
@g.command('disable-idle-time-events')
def disable_idle_time_events(event):
    """Disable default idle-time event handling."""
    g.app.idle_time_hooks_enabled = False

@g.command('enable-idle-time-events')
def enable_idle_time_events(event):
    """Enable default idle-time event handling."""
    g.app.idle_time_hooks_enabled = True

@g.command('toggle-idle-time-events')
def toggle_idle_time_events(event):
    """Toggle default idle-time event handling."""
    g.app.idle_time_hooks_enabled = not g.app.idle_time_hooks_enabled
#@+node:ekr.20150514125218.4: *6* join-leo-irc
@g.command('join-leo-irc')
def join_leo_irc(event=None):
    """Open the web page to Leo's irc channel on freenode.net."""
    import webbrowser
    webbrowser.open("http://webchat.freenode.net/?channels=%23leo&uio=d4")
#@+node:ekr.20150514125218.5: *6* open-url
@g.command('open-url')
def openUrl(event=None):
    """
    Open the url in the headline or body text of the selected node.

    Use the headline if it contains a valid url.
    Otherwise, look *only* at the first line of the body.
    """
    c = event.get('c')
    if c:
        g.openUrl(c.p)
#@+node:ekr.20150514125218.6: *6* open-url-under-cursor
@g.command('open-url-under-cursor')
def openUrlUnderCursor(event=None):
    """Open the url under the cursor."""
    return g.openUrlOnClick(event)
#@+node:ekr.20031218072017.2810: *4* @file leoCommands.py
@first # -*- coding: utf-8 -*-
<< imports >>

def cmd(name):
    """Command decorator for the Commands class."""
    return g.new_cmd_decorator(name, ['c',])

@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20040712045933: *5* << imports >> (leoCommands)
import leo.core.leoGlobals as g
import leo.core.leoNodes as leoNodes
    # The leoCommands ctor now does most leo.core.leo* imports.
    # This breaks circular dependencies.
import itertools
import os
import re
import sys
import time
import tokenize  # for c.checkAllPythonCode
try:
    import tabnanny  # for Check Python command # Does not exist in jython
except ImportError:
    tabnanny = None
#@+node:ekr.20160514120615.1: *5* class Commands (object)
class Commands:
    """
    A per-outline class that implements most of Leo's commands. The
    "c" predefined object is an instance of this class.

    c.initObjects() creates sucommanders corresponding to files in the
    leo/core and leo/commands. All of Leo's core code is accessible
    via this class and its subcommanders.

    g.app.pluginsController is Leo's plugins controller. Many plugins
    inject controllers objects into the Commands class. These are
    another kind of subcommander.
    
    The @g..commander_command decorator injects methods into this class.
    """
    @others
#@+node:ekr.20031218072017.2811: *6*  c.Birth & death
#@+node:ekr.20031218072017.2812: *7* c.__init__ & helpers
def __init__(self, fileName,
    gui=None,
    parentFrame=None,
    previousSettings=None,
    relativeFileName=None,
):

    # tag = 'Commands.__init__ %s' % (g.shortFileName(fileName))
    c = self
    # Official ivars.
    self._currentPosition = None
    self._topPosition = None
    self.frame = None
    self.parentFrame = parentFrame  # New in Leo 6.0.
    self.gui = gui or g.app.gui
    self.ipythonController = None
        # Set only by the ipython plugin.
    # The order of these calls does not matter.
    c.initCommandIvars()
    c.initDebugIvars()
    c.initDocumentIvars()
    c.initEventIvars()
    c.initFileIvars(fileName, relativeFileName)
    c.initOptionsIvars()
    c.initObjectIvars()
    c.initSettings(previousSettings)
        # Init the settings *before* initing the objects.
    # Initialize all subsidiary objects, including subcommanders.
    c.initObjects(self.gui)
    assert c.frame
    assert c.frame.c
    # Complete the init!
    c.finishCreate()
#@+node:ekr.20120217070122.10475: *8* c.computeWindowTitle
def computeWindowTitle(self, fileName):
    """Set the window title and fileName."""
    if fileName:
        title = g.computeWindowTitle(fileName)
    else:
        s = "untitled"
        n = g.app.numberOfUntitledWindows
        if n > 0:
            s += str(n)
        title = g.computeWindowTitle(s)
        g.app.numberOfUntitledWindows = n + 1
    return title
#@+node:ekr.20120217070122.10473: *8* c.initCommandIvars
def initCommandIvars(self):
    """Init ivars used while executing a command."""
    self.commandsDict = {}
        # Keys are command names, values are functions.
    self.disableCommandsMessage = ''
        # The presence of this message disables all commands.
    self.hookFunction = None
        # One of three places that g.doHook looks for hook functions.
    self.ignoreChangedPaths = False
        # True: disable path changed message in at.WriteAllHelper.
    self.inCommand = False
        # Interlocks to prevent premature closing of a window.
    self.isZipped = False
        # Set by g.openWithFileName.
    self.outlineToNowebDefaultFileName = "noweb.nw"
        # For Outline To Noweb dialog.
    # For tangle/untangle
    self.tangle_errors = 0
    # Default Tangle options
    self.use_header_flag = False
    self.output_doc_flag = False
    # For hoist/dehoist commands.
    self.hoistStack = []
        # Stack of nodes to be root of drawn tree.
        # Affects drawing routines and find commands.
    # For outline navigation.
    self.navPrefix = ''  # Must always be a string.
    self.navTime = None

    self.sqlite_connection = None
#@+node:ekr.20120217070122.10466: *8* c.initDebugIvars
def initDebugIvars(self):
    """Init Commander debugging ivars."""
    self.command_count = 0
    self.scanAtPathDirectivesCount = 0
    self.trace_focus_count = 0
#@+node:ekr.20120217070122.10471: *8* c.initDocumentIvars
def initDocumentIvars(self):
    """Init per-document ivars."""
    self.expansionLevel = 0
        # The expansion level of this outline.
    self.expansionNode = None
        # The last node we expanded or contracted.
    self.nodeConflictList = []
        # List of nodes with conflicting read-time data.
    self.nodeConflictFileName = None
        # The fileName for c.nodeConflictList.
    self.user_dict = {}
        # Non-persistent dictionary for free use by scripts and plugins.
#@+node:ekr.20120217070122.10467: *8* c.initEventIvars
def initEventIvars(self):
    """Init ivars relating to gui events."""
    self.configInited = False
    self.doubleClickFlag = False
    self.exists = True
        # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    self.in_qt_dialog = False
        # True: in a qt dialog.
    self.loading = False
        # True: we are loading a file: disables c.setChanged()
    self.promptingForClose = False
        # True: lock out additional closing dialogs.
    self.suppressHeadChanged = False
        # True: prevent setting c.changed when switching chapters.
    # Flags for c.outerUpdate...
    self.enableRedrawFlag = True
    self.requestCloseWindow = False
    self.requestedFocusWidget = None
    self.requestLaterRedraw = False
#@+node:ekr.20120217070122.10472: *8* c.initFileIvars
def initFileIvars(self, fileName, relativeFileName):
    """Init file-related ivars of the commander."""
    self.changed = False
        # True: the ouline has changed since the last save.
    self.ignored_at_file_nodes = []
        # List of nodes for c.raise_error_dialogs.
    self.import_error_nodes = []
        # List of nodes for c.raise_error_dialogs.
    self.last_dir = None
        # The last used directory.
    self.mFileName = fileName or ''
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName or ''
        #
    self.openDirectory = None
        #
    self.orphan_at_file_nodes = []
        # List of orphaned nodes for c.raise_error_dialogs.
    self.wrappedFileName = None
        # The name of the wrapped file, for wrapper commanders.
        # Set by LM.initWrapperLeoFile
#@+node:ekr.20120217070122.10469: *8* c.initOptionsIvars
def initOptionsIvars(self):
    """Init Commander ivars corresponding to user options."""
    self.fixed = False
    self.fixedWindowPosition = []
    self.forceExecuteEntireBody = False
    self.focus_border_color = 'white'
    self.focus_border_width = 1  # pixels
    self.outlineHasInitialFocus = False
    self.page_width = 132
    self.sparse_find = True
    self.sparse_move = True
    self.sparse_spell = True
    self.stayInTreeAfterSelect = False
    self.tab_width = -4
    self.tangle_batch_flag = False
    self.target_language = "python"
    self.untangle_batch_flag = False
    # self.use_body_focus_border = True
    # self.use_focus_border = False
        # Replaced by style-sheet entries.
    self.vim_mode = False
#@+node:ekr.20120217070122.10468: *8* c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.bufferCommands = None
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
#@+node:ekr.20120217070122.10470: *8* c.initObjects
@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '<hidden root vnode>'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.bufferCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
#@+node:ekr.20140815160132.18837: *8* c.initSettings
def initSettings(self, previousSettings):
    """Init the settings *before* initing the objects."""
    c = self
    import leo.core.leoConfig as leoConfig
    c.config = leoConfig.LocalConfigManager(c, previousSettings)
    g.app.config.setIvarsFromSettings(c)
#@+node:ekr.20031218072017.2814: *7* c.__repr__ & __str__
def __repr__(self):
    return f"Commander {id(self)}: {repr(self.mFileName)}"

__str__ = __repr__
#@+node:ekr.20050920093543: *7* c.finishCreate & helpers
def finishCreate(self):
    """
    Finish creating the commander and all sub-objects.
    This is the last step in the startup process.
    """
    c, k = self, self.k
    assert c.gui
    assert k
    c.frame.finishCreate()
    c.miniBufferWidget = c.frame.miniBufferWidget
        # Will be None for nullGui.
    # Only c.abbrevCommands needs a finishCreate method.
    c.abbrevCommands.finishCreate()
    # Finish other objects...
    c.createCommandNames()
    k.finishCreate()
    c.findCommands.finishCreate()
    if not c.gui.isNullGui:
        g.registerHandler('idle', c.idle_focus_helper)
    if getattr(c.frame, 'menu', None):
        c.frame.menu.finishCreate()
    if getattr(c.frame, 'log', None):
        c.frame.log.finishCreate()
    c.undoer.clearUndoState()
    if c.vimCommands and c.vim_mode:
        c.vimCommands.finishCreate()
        # Menus must exist at this point.
    # Do not call chapterController.finishCreate here:
    # It must be called after the first real redraw.
    g.check_cmd_instance_dict(c, g)
    c.bodyWantsFocus()
#@+node:ekr.20140815160132.18835: *8* c.createCommandNames
def createCommandNames(self):
    """
    Create all entries in c.commandsDict.
    Do *not* clear c.commandsDict here.
    """
    for commandName, func in g.global_commands_dict.items():
        self.k.registerCommand(commandName, func)
#@+node:ekr.20051007143620: *8* c.printCommandsDict
def printCommandsDict(self):
    c = self
    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print(f"{key:30} = {command.__name__ if command else '<None>'}")
    print('')
#@+node:ekr.20041130173135: *7* c.hash
# This is a bad idea.

def hash(self):
    c = self
    if c.mFileName:
        return g.os_path_finalize(c.mFileName).lower()  # #1341.
    return 0
#@+node:ekr.20110509064011.14563: *7* c.idle_focus_helper & helpers
idle_focus_count = 0

def idle_focus_helper(self, tag, keys):
    """An idle-tme handler that ensures that focus is *somewhere*."""
    trace = 'focus' in g.app.debug
    trace_inactive_focus = False  # Too disruptive for --trace-focus
    trace_in_dialog = False  # Not useful enough for --trace-focus
    c = self
    assert tag == 'idle'
    if g.app.unitTesting:
        return
    if keys.get('c') != c:
        if trace: g.trace('no c')
        return
    self.idle_focus_count += 1
    if c.in_qt_dialog:
        if trace and trace_in_dialog: g.trace('in_qt_dialog')
        return
    w = g.app.gui.get_focus(at_idle=True)
    if g.app.gui.active:
        # Always call trace_idle_focus.
        self.trace_idle_focus(w)
        if w and self.is_unusual_focus(w):
            if trace:
                w_class = w and w.__class__.__name__
                g.trace('***** unusual focus', w_class)
            # Fix bug 270: Leo's keyboard events doesn't work after "Insert"
            # on headline and Alt+Tab, Alt+Tab
            # Presumably, intricate details of Qt event handling are involved.
            # The focus was in the tree, so put the focus back in the tree.
            c.treeWantsFocusNow()
        # elif not w and active:
            # c.bodyWantsFocusNow()
    elif trace and trace_inactive_focus:
        w_class = w and w.__class__.__name__
        count = c.idle_focus_count
        g.trace(f"{count} inactive focus: {w_class}")
#@+node:ekr.20160427062131.1: *8* c.is_unusual_focus
def is_unusual_focus(self, w):
    """Return True if w is not in an expected place."""
    #
    # #270: Leo's keyboard events doesn't work after "Insert"
    #       on headline and Alt+Tab, Alt+Tab
    #
    # #276: Focus lost...in Nav text input
    import leo.plugins.qt_frame as qt_frame
    return isinstance(w, qt_frame.QtTabBarWrapper)
#@+node:ekr.20150403063658.1: *8* c.trace_idle_focus
last_unusual_focus = None
# last_no_focus = False

def trace_idle_focus(self, w):
    """Trace the focus for w, minimizing chatter."""
    from leo.core.leoQt import QtWidgets
    import leo.plugins.qt_frame as qt_frame
    trace = 'focus' in g.app.debug
    trace_known = False
    c = self
    table = (QtWidgets.QWidget, qt_frame.LeoQTreeWidget,)
    count = c.idle_focus_count
    if w:
        w_class = w and w.__class__.__name__
        c.last_no_focus = False
        if self.is_unusual_focus(w):
            if trace:
                g.trace(f"{count} unusual focus: {w_class}")
        else:
            c.last_unusual_focus = None
            if isinstance(w, table):
                if trace and trace_known:
                    g.trace(f"{count} known focus: {w_class}")
            elif trace:
                g.trace(f"{count} unknown focus: {w_class}")
    else:
        if trace:
            g.trace(f"{count:3} no focus")
#@+node:ekr.20081005065934.1: *7* c.initAfterLoad
def initAfterLoad(self):
    """Provide an offical hook for late inits of the commander."""
    pass
#@+node:ekr.20090213065933.6: *7* c.initConfigSettings
def initConfigSettings(self):
    """Init all cached commander config settings."""
    c = self
    getBool = c.config.getBool
    getColor = c.config.getColor
    getData = c.config.getData
    getInt = c.config.getInt
    c.autoindent_in_nocolor = getBool('autoindent-in-nocolor-mode')
    c.collapse_nodes_after_move = getBool('collapse-nodes-after-move')
    c.collapse_on_lt_arrow = getBool('collapse-on-lt-arrow', default=True)
    c.contractVisitedNodes = getBool('contractVisitedNodes')
    c.fixedWindowPositionData = getData('fixedWindowPosition')
    c.focus_border_color = getColor('focus-border-color') or 'red'
    c.focus_border_command_state_color = getColor(
        'focus-border-command-state-color') or 'blue'
    c.focus_border_overwrite_state_color = getColor(
        'focus-border-overwrite-state-color') or 'green'
    c.focus_border_width = getInt('focus-border-width') or 1  # pixels
    c.forceExecuteEntireBody = getBool('force-execute-entire-body', default=False)
    c.make_node_conflicts_node = getBool('make-node-conflicts-node', default=True)
    c.outlineHasInitialFocus = getBool('outline-pane-has-initial-focus')
    c.page_width = getInt('page-width') or 132
    # c.putBitsFlag = getBool('put-expansion-bits-in-leo-files', default=True)
    c.sparse_move = getBool('sparse-move-outline-left')
    c.sparse_find = getBool('collapse-nodes-during-finds')
    c.sparce_spell = getBool('collapse-nodes-while-spelling')
    c.stayInTreeAfterSelect = getBool('stayInTreeAfterSelect')
    c.smart_tab = getBool('smart-tab')
    c.tab_width = getInt('tab-width') or -4
    c.verbose_check_outline = getBool('verbose-check-outline', default=False)
    c.vim_mode = getBool('vim-mode', default=False)
    c.write_script_file = getBool('write-script-file')
#@+node:ekr.20090213065933.7: *7* c.setWindowPosition
def setWindowPosition(self):
    c = self
    if c.fixedWindowPositionData:
        try:
            aList = [z.strip() for z in c.fixedWindowPositionData if z.strip()]
            w, h, l, t = aList
            c.fixedWindowPosition = int(w), int(h), int(l), int(t)
        except Exception:
            g.error('bad @data fixedWindowPosition',
                repr(self.fixedWindowPosition))
    else:
        c.windowPosition = 500, 700, 50, 50  # width,height,left,top.
#@+node:ekr.20171123135625.4: *6* @cmd c.executeScript & public helpers
@cmd('execute-script')
def executeScript(self, event=None,
    args=None, p=None, script=None, useSelectedText=True,
    define_g=True, define_name='__main__',
    silent=False, namespace=None, raiseFlag=False,
    runPyflakes=True,
):
    """
    Execute a *Leo* script.
    Keyword args:
    args=None               Not None: set script_args in the execution environment.
    p=None                  Get the script from p.b, unless script is given.
    script=None             None: use script in p.b or c.p.b
    useSelectedText=True    False: use all the text in p.b or c.p.b.
    define_g=True           True: define g for the script.
    define_name='__main__'  Not None: define the name symbol.
    silent=False            No longer used.
    namespace=None          Not None: execute the script in this namespace.
    raiseFlag=False         True: reraise any exceptions.
    runPyflakes=True        True: run pyflakes if allowed by setting.
    """
    c, script1 = self, script
    if runPyflakes:
        run_pyflakes = c.config.getBool('run-pyflakes-on-write', default=False)
    else:
        run_pyflakes = False
    if not script:
        if c.forceExecuteEntireBody:
            useSelectedText = False
        script = g.getScript(c, p or c.p, useSelectedText=useSelectedText)
    script_p = p or c.p
        # Only for error reporting below.
    # #532: check all scripts with pyflakes.
    if run_pyflakes and not g.unitTesting:
        import leo.commands.checkerCommands as cc
        # at = c.atFileCommands
        prefix = ('c,g,p,script_gnx=None,None,None,None;'
                  'assert c and g and p and script_gnx;\n')
        cc.PyflakesCommand(c).check_script(script_p, prefix + script)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0, '.')  # New in Leo 5.0
            sys.path.insert(0, c.frame.openDirectory)  # per SegundoBob
            script += '\n'  # Make sure we end the script properly.
            try:
                if not namespace or namespace.get('script_gnx') is None:
                    namespace = namespace or {}
                    namespace.update(script_gnx=script_p.gnx)
                # We *always* execute the script with p = c.p.
                c.executeScriptHelper(args, define_g, define_name, namespace, script)
            except KeyboardInterrupt:
                g.es('interrupted')
            except Exception:
                if raiseFlag:
                    raise
                g.handleScriptException(c, script_p, script, script1)
            finally:
                del sys.path[0]
                del sys.path[0]
        else:
            tabName = log and hasattr(log, 'tabName') and log.tabName or 'Log'
            g.warning("no script selected", tabName=tabName)
    finally:
        g.app.log = oldLog
        self.unredirectScriptOutput()
#@+node:ekr.20171123135625.5: *7* c.executeScriptHelper
def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy()  # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    #
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
#@+node:ekr.20171123135625.6: *7* c.redirectScriptOutput
def redirectScriptOutput(self):
    c = self
    if c.config.redirect_execute_script_output_to_log_pane:
        g.redirectStdout()  # Redirect stdout
        g.redirectStderr()  # Redirect stderr
#@+node:ekr.20171123135625.7: *7* c.setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self, p):
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    curDir = g.os_path_abspath(os.getcwd())
    if path and path != curDir:
        try:
            os.chdir(path)
        except Exception:
            pass
#@+node:ekr.20171123135625.8: *7* c.unredirectScriptOutput
def unredirectScriptOutput(self):
    c = self
    if c.exists and c.config.redirect_execute_script_output_to_log_pane:
        g.restoreStderr()
        g.restoreStdout()
#@+node:vitalije.20190924191405.1: *6* @cmd c.execute_pytest
@cmd('execute-pytest')
def execute_pytest(self, event=None):
    c = self

    def it(p):
        for p1 in p.self_and_parents():
            if p1.h.startswith('@test '):
                yield p1
                return
        for p1 in p.subtree():
            if p1.h.startswith('@test '):
                yield p1

    try:
        for p in it(c.p):
            self.execute_single_pytest(p)
    except ImportError:
        g.es('pytest needs to be installed')
        return

def execute_single_pytest(self, p):
    c = self
    from _pytest.config import get_config
    from _pytest.assertion.rewrite import rewrite_asserts
    import ast
    cfg = get_config()
    script = g.getScript(c, p, useSentinels=False) + (
        '\n'
        'ls = dict(locals())\n'
        'failed = 0\n'
        'for x in ls:\n'
        '    if x.startswith("test_") and callable(ls[x]):\n'
        '        try:\n'
        '            ls[x]()\n'
        '        except AssertionError as e:\n'
        '            failed += 1\n'
        '            g.es(f"-------{p.h[6:].strip()}/{x} failed---------")\n'
        '            g.es(str(e))\n'
        'if failed == 0:\n'
        '    g.es("all tests passed")\n'
        'else:\n'
        '    g.es(f"failed:{failed} tests")\n')

    fname = g.os_path_finalize_join(g.app.homeLeoDir, 'leoPytestScript.py')
    with open(fname, 'wt', encoding='utf8') as out:
        out.write(script)
    tree = ast.parse(script, filename=fname)
    rewrite_asserts(tree, script, config=cfg)
    co = compile(tree, fname, "exec", dont_inherit=True)
    sys.path.insert(0, '.')
    sys.path.insert(0, c.frame.openDirectory)
    try:
        exec(co, {'c': c, 'g': g, 'p': p})
    except KeyboardInterrupt:
        g.es('interrupted')
    except Exception:
        g.handleScriptException(c, p, script, script)
    finally:
        del sys.path[:2]
#@+node:ekr.20080514131122.12: *6* @cmd c.recolorCommand
@cmd('recolor')
def recolorCommand(self, event=None):
    """Force a full recolor."""
    c = self
    wrapper = c.frame.body.wrapper
    # Setting all text appears to be the only way.
    i, j = wrapper.getSelectionRange()
    ins = wrapper.getInsertPoint()
    wrapper.setAllText(c.p.b)
    wrapper.setSelectionRange(i, j, insert=ins)
#@+node:ekr.20171124100654.1: *6* c.API
# These methods are a fundamental, unchanging, part of Leo's API.
#@+node:ekr.20091001141621.6061: *7* c.Generators
#@+node:ekr.20091001141621.6043: *8* c.all_nodes & all_unique_nodes
def all_nodes(self):
    """A generator returning all vnodes in the outline, in outline order."""
    c = self
    for p in c.all_positions():
        yield p.v

def all_unique_nodes(self):
    """A generator returning each vnode of the outline."""
    c = self
    for p in c.all_unique_positions(copy=False):
        yield p.v

# Compatibility with old code...

all_tnodes_iter = all_nodes
all_vnodes_iter = all_nodes
all_unique_tnodes_iter = all_unique_nodes
all_unique_vnodes_iter = all_unique_nodes
#@+node:ekr.20091001141621.6044: *8* c.all_positions
def all_positions(self, copy=True):
    """A generator return all positions of the outline, in outline order."""
    c = self
    p = c.rootPosition()
    while p:
        yield p.copy() if copy else p
        p.moveToThreadNext()

# Compatibility with old code...

all_positions_iter = all_positions
allNodes_iter = all_positions
#@+node:ekr.20191014093239.1: *8* c.all_positions_for_v
# from leo.core.leoNodes import Position

def all_positions_for_v(self, v, stack=None):
    """
    Generates all positions p in this outline where p.v is v.
    
    Should be called with stack=None.
    
    The generated positions are not necessarily in outline order.
    
    By Виталије Милошевић (Vitalije Milosevic).
    """
    c = self

    if stack is None:
        stack = []

    if not isinstance(v, leoNodes.VNode):
        g.es_print(f"not a VNode: {v!r}")
        return  # Stop the generator.

    def allinds(v, target_v):
        """Yield all indices i such that v.children[i] == target_v."""
        for i, x in enumerate(v.children):
            if x is target_v:
                yield i

    def stack2pos(stack):
        """Convert the stack to a position."""
        v, i = stack[-1]
        return leoNodes.Position(v, i, stack[:-1])

    for v2 in set(v.parents):
        for i in allinds(v2, v):
            stack.insert(0, (v, i))
            if v2 is c.hiddenRootNode:
                yield stack2pos(stack)
            else:
                yield from c.all_positions_for_v(v2, stack)
            stack.pop(0)
#@+node:ekr.20161120121226.1: *8* c.all_roots
def all_roots(self, copy=True, predicate=None):
    """
    A generator yielding *all* the root positions in the outline that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The generator yields all **root** anywhere in the outline that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    """
    c = self
    if predicate is None:

        # pylint: disable=function-redefined

        def predicate(p):
            return p.isAnyAtFileNode()

    p = c.rootPosition()
    while p:
        if predicate(p):
            yield p.copy()  # 2017/02/19
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
#@+node:ekr.20091001141621.6062: *8* c.all_unique_positions
def all_unique_positions(self, copy=True):
    """
    A generator return all positions of the outline, in outline order.
    Returns only the first position for each vnode.
    """
    c = self
    p = c.rootPosition()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        else:
            seen.add(p.v)
            yield p.copy() if copy else p
            p.moveToThreadNext()

# Compatibility with old code...

all_positions_with_unique_tnodes_iter = all_unique_positions
all_positions_with_unique_vnodes_iter = all_unique_positions
#@+node:ekr.20161120125322.1: *8* c.all_unique_roots
def all_unique_roots(self, copy=True, predicate=None):
    """
    A generator yielding all unique root positions in the outline that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The generator yields all **root** anywhere in the outline that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    """
    c = self
    if predicate is None:

        # pylint: disable=function-redefined

        def predicate(p):
            return p.isAnyAtFileNode()

    seen = set()
    p = c.rootPosition()
    while p:
        if p.v not in seen and predicate(p):
            seen.add(p.v)
            yield p.copy() if copy else p
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
#@+node:ekr.20150316175921.5: *8* c.safe_all_positions
def safe_all_positions(self, copy=True):
    """
    A generator returning all positions of the outline. This generator does
    *not* assume that vnodes are never their own ancestors.
    """
    c = self
    p = c.rootPosition()  # Make one copy.
    while p:
        yield p.copy() if copy else p
        p.safeMoveToThreadNext()
#@+node:ekr.20060906211747: *7* c.Getters
#@+node:ekr.20040803140033: *8* c.currentPosition
def currentPosition(self):
    """
    Return a copy of the presently selected position or a new null
    position. So c.p.copy() is never necessary.
    """
    c = self
    if hasattr(c, '_currentPosition') and getattr(c, '_currentPosition'):
        # *Always* return a copy.
        return c._currentPosition.copy()
    return c.rootPosition()

# For compatibiility with old scripts...

currentVnode = currentPosition
#@+node:ekr.20190506060937.1: *8* c.dumpExpanded
@cmd('dump-expanded')
def dump_expanded(self, event):
    c = event.get('c')
    if not c:
        return
    g.es_print('dump-expanded...')
    for p in c.all_positions():
        if p.v.expandedPositions:
            indent = ' ' * p.level()
            print(f"{indent}{p.h}")
            g.printObj(p.v.expandedPositions, indent=indent)
#@+node:ekr.20040306220230.1: *8* c.edit_widget
def edit_widget(self, p):
    c = self
    return p and c.frame.tree.edit_widget(p)
#@+node:ekr.20031218072017.2986: *8* c.fileName & relativeFileName & shortFileName
# Compatibility with scripts

def fileName(self):
    s = self.mFileName or ""
    if g.isWindows:
        s = s.replace('\\', '/')
    return s

def relativeFileName(self):
    return self.mRelativeFileName or self.mFileName

def shortFileName(self):
    return g.shortFileName(self.mFileName)

shortFilename = shortFileName
#@+node:ekr.20070615070925.1: *8* c.firstVisible
def firstVisible(self):
    """Move to the first visible node of the present chapter or hoist."""
    c = self; p = c.p
    while 1:
        back = p.visBack(c)
        if back and back.isVisible(c):
            p = back
        else: break
    return p
#@+node:ekr.20171123135625.29: *8* c.getBodyLines
def getBodyLines(self, expandSelection=False):
    """
    Return head,lines,tail where:

    before is string containg all the lines before the selected text
    (or the text before the insert point if no selection) lines is a
    list of lines containing the selected text (or the line containing
    the insert point if no selection) after is a string all lines
    after the selected text (or the text after the insert point if no
    selection)
    """
    c = self
    body = c.frame.body
    w = body.wrapper
    oldVview = w.getYScrollPosition()
    if expandSelection:
        s = w.getAllText()
        head = tail = ''
        oldSel = 0, len(s)
        lines = g.splitLines(s)  # Retain the newlines of each line.
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head, s, tail = body.getSelectionLines()
        lines = g.splitLines(s)  # Retain the newlines of each line.
        # Expand the selection.
        i = len(head)
        j = max(i, len(head) + len(s) - 1)
        oldSel = i, j
    return head, lines, tail, oldSel, oldVview  # string,list,string,tuple.
#@+node:ekr.20150417073117.1: *8* c.getTabWidth
def getTabWidth(self, p):
    """Return the tab width in effect at p."""
    c = self
    val = g.scanAllAtTabWidthDirectives(c, p)
    return val
#@+node:ekr.20040803112200: *8* c.is...Position
#@+node:ekr.20040803155551: *9* c.currentPositionIsRootPosition
def currentPositionIsRootPosition(self):
    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """
    c = self
    root = c.rootPosition()
    return c._currentPosition and root and c._currentPosition == root
    # return (
        # c._currentPosition and c._rootPosition and
        # c._currentPosition == c._rootPosition)
#@+node:ekr.20040803160656: *9* c.currentPositionHasNext
def currentPositionHasNext(self):
    """Return True if the current position is the root position.

    This method is called during idle time, so not generating positions
    here fixes a major leak.
    """
    c = self; current = c._currentPosition
    return current and current.hasNext()
#@+node:ekr.20040803112450: *9* c.isCurrentPosition
def isCurrentPosition(self, p):
    c = self
    if p is None or c._currentPosition is None:
        return False
    return p == c._currentPosition
#@+node:ekr.20040803112450.1: *9* c.isRootPosition
def isRootPosition(self, p):
    c = self
    root = c.rootPosition()
    return p and root and p == root  # 2011/03/03
#@+node:ekr.20031218072017.2987: *8* c.isChanged
def isChanged(self):
    return self.changed
#@+node:ekr.20140106215321.16676: *8* c.lastTopLevel
def lastTopLevel(self):
    """Return the last top-level position in the outline."""
    c = self
    p = c.rootPosition()
    while p.hasNext():
        p.moveToNext()
    return p
#@+node:ekr.20031218072017.4146: *8* c.lastVisible
def lastVisible(self):
    """Move to the last visible node of the present chapter or hoist."""
    c = self; p = c.p
    while 1:
        next = p.visNext(c)
        if next and next.isVisible(c):
            p = next
        else: break
    return p
#@+node:ekr.20040311094927: *8* c.nullPosition
def nullPosition(self):
    """
    New in Leo 5.5: Return None.
    Using empty positions masks problems in program logic.

    In fact, there are no longer any calls to this method in Leo's core.
    """
    g.trace('This method is deprecated. Instead, just use None.')
    # pylint complains if we return None.
#@+node:ekr.20040307104131.3: *8* c.positionExists
def positionExists(self, p, root=None, trace=False):
    """Return True if a position exists in c's tree"""
    if not p or not p.v: return False

    rstack = root.stack + [(root.v, root._childIndex)] if root else []
    pstack = p.stack + [(p.v, p._childIndex)]

    if len(rstack) > len(pstack): return False

    par = self.hiddenRootNode
    for j, x in enumerate(pstack):
        if j < len(rstack) and x != rstack[j]: return False
        v, i = x
        if i >= len(par.children) or v is not par.children[i]:
            return False
        par = v
    return True
#@+node:ekr.20160427153457.1: *9* c.dumpPosition
def dumpPosition(self, p):
    """Dump position p and it's ancestors."""
    g.trace('=====', p.h, p._childIndex)
    for i, data in enumerate(p.stack):
        v, childIndex = data
        print(f"{i} {childIndex} {v._headString}")
#@+node:ekr.20040803140033.2: *8* c.rootPosition
_rootCount = 0

def rootPosition(self):
    """Return the root position.

    Root position is the first position in the document. Other
    top level positions are siblings of this node.
    """
    c = self
    # 2011/02/25: Compute the position directly.
    if c.hiddenRootNode.children:
        v = c.hiddenRootNode.children[0]
        return leoNodes.Position(v, childIndex=0, stack=None)
    return None

# For compatibiility with old scripts...

rootVnode = rootPosition
findRootPosition = rootPosition
#@+node:ekr.20131017174814.17480: *8* c.shouldBeExpanded
def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
#@+node:ekr.20070609122713: *8* c.visLimit
def visLimit(self):
    """
    Return the topmost visible node.
    This is affected by chapters and hoists.
    """
    c = self; cc = c.chapterController
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p
        limitIsVisible = not cc or not p.h.startswith('@chapter')
        return p, limitIsVisible
    return None, None
#@+node:tbrown.20091206142842.10296: *8* c.vnode2allPositions
def vnode2allPositions(self, v):
    """Given a VNode v, find all valid positions p such that p.v = v.

    Not really all, just all for each of v's distinct immediate parents.
    """
    c = self
    context = v.context  # v's commander.
    assert(c == context)
    positions = []
    for immediate in v.parents:
        if v in immediate.children:
            n = immediate.children.index(v)
        else:
            continue
        stack = [(v, n)]
        while immediate.parents:
            parent = immediate.parents[0]
            if immediate in parent.children:
                n = parent.children.index(immediate)
            else:
                break
            stack.insert(0, (immediate, n),)
            immediate = parent
        else:
            v, n = stack.pop()
            p = leoNodes.Position(v, n, stack)
            positions.append(p)
    return positions
#@+node:ekr.20090107113956.1: *8* c.vnode2position
def vnode2position(self, v):
    """Given a VNode v, construct a valid position p such that p.v = v.
    """
    c = self
    context = v.context  # v's commander.
    assert(c == context)
    stack = []
    while v.parents:
        parent = v.parents[0]
        if v in parent.children:
            n = parent.children.index(v)
        else:
            return None
        stack.insert(0, (v, n),)
        v = parent
    # v.parents includes the hidden root node.
    if not stack:
        # a VNode not in the tree
        return None
    v, n = stack.pop()
    p = leoNodes.Position(v, n, stack)
    return p
#@+node:ekr.20090130135126.1: *7* c.Properties
def __get_p(self):
    c = self
    return c.currentPosition()

p = property(
    __get_p,  # No setter.
    doc="commander current position property")
#@+node:ekr.20060906211747.1: *7* c.Setters
#@+node:ekr.20040315032503: *8* c.appendStringToBody
def appendStringToBody(self, p, s):
    c = self
    if not s: return
    body = p.b
    s = g.toUnicode(s)
    c.setBodyString(p, body + s)
#@+node:ekr.20031218072017.2984: *8* c.clearAllMarked
def clearAllMarked(self):
    c = self
    for p in c.all_unique_positions(copy=False):
        p.v.clearMarked()
#@+node:ekr.20031218072017.2985: *8* c.clearAllVisited
def clearAllVisited(self):
    c = self
    for p in c.all_unique_positions(copy=False):
        p.v.clearVisited()
        p.v.clearWriteBit()
#@+node:ekr.20191215044636.1: *8* c.clearChanged
def clearChanged(self):
    """clear the marker that indicates that the .leo file has been changed."""
    c = self
    if not c.frame:
        return
    c.changed = False
    if c.loading:
        return  # don't update while loading.
    # Clear all dirty bits _before_ setting the caption.
    for v in c.all_unique_nodes():
        v.clearDirty()
    c.changed = False
    # Do nothing for null frames.
    assert c.gui
    if c.gui.guiName() == 'nullGui':
        return
    if not c.frame.top:
        return
    master = getattr(c.frame.top, 'leo_master', None)
    if master:
        master.setChanged(c, False)
            # LeoTabbedTopLevel.setChanged.
    s = c.frame.getTitle()
    if len(s) > 2 and s[0:2] == "* ":
        c.frame.setTitle(s[2:])
#@+node:ekr.20060906211138: *8* c.clearMarked
def clearMarked(self, p):
    c = self
    p.v.clearMarked()
    g.doHook("clear-mark", c=c, p=p)
#@+node:ekr.20040305223522: *8* c.setBodyString
def setBodyString(self, p, s):
    c, v = self, p.v
    if not c or not v:
        return
    s = g.toUnicode(s)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v == current.v:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s, None, None)
        w = c.frame.body.wrapper
        i = w.getInsertPoint()
        w.setSelectionRange(i, i)
        # This code destoys all tags, so we must recolor.
        c.recolor()
    # Keep the body text in the VNode up-to-date.
    if v.b != s:
        v.setBodyString(s)
        v.setSelection(0, 0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged()
        c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2989: *8* c.setChanged
def setChanged(self, redrawFlag=True):
    """Set the marker that indicates that the .leo file has been changed."""
    c = self
    if not c.frame:
        return
    c.changed = True
    if c.loading:
        return  # don't update while loading.
    # Do nothing for null frames.
    assert c.gui
    if c.gui.guiName() == 'nullGui':
        return
    if not c.frame.top:
        return
    if not redrawFlag:  # Prevent flash when fixing #387.
        return
    master = getattr(c.frame.top, 'leo_master', None)
    if master:
        master.setChanged(c, True)
            # LeoTabbedTopLevel.setChanged.
    s = c.frame.getTitle()
    if len(s) > 2 and s[0] != '*':
        c.frame.setTitle("* " + s)
#@+node:ekr.20040803140033.1: *8* c.setCurrentPosition
_currentCount = 0

def setCurrentPosition(self, p):
    """
    Set the presently selected position. For internal use only.
    Client code should use c.selectPosition instead.
    """
    c = self
    if not p:
        g.trace('===== no p', g.callers())
        return
    if c.positionExists(p):
        if c._currentPosition and p == c._currentPosition:
            pass  # We have already made a copy.
        else:  # Make a copy _now_
            c._currentPosition = p.copy()
    else:  # 2011/02/25:
        c._currentPosition = c.rootPosition()
        g.trace(f"Invalid position: {repr(p and p.h)}")
        g.trace(g.callers())
        # Don't kill unit tests for this kind of problem.

# For compatibiility with old scripts.

setCurrentVnode = setCurrentPosition
#@+node:ekr.20040305223225: *8* c.setHeadString
def setHeadString(self, p, s):
    """
    Set the p's headline and the corresponding tree widget to s.

    This is used in by unit tests to restore the outline.
    """
    c = self
    p.initHeadString(s)
    p.setDirty()
    # Change the actual tree widget so
    # A later call to c.endEditing or c.redraw will use s.
    c.frame.tree.setHeadline(p, s)
#@+node:ekr.20060109164136: *8* c.setLog
def setLog(self):
    c = self
    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass
#@+node:ekr.20060906211138.1: *8* c.setMarked (calls hook)
def setMarked(self, p):
    c = self
    p.setMarked()
    p.setDirty()  # Defensive programming.
    g.doHook("set-mark", c=c, p=p)
#@+node:ekr.20040803140033.3: *8* c.setRootPosition (A do-nothing)
def setRootPosition(self, unused_p=None):
    """Set c._rootPosition."""
    # 2011/03/03: No longer used.
#@+node:ekr.20060906131836: *8* c.setRootVnode (A do-nothing)
def setRootVnode(self, v):
    pass
    # c = self
    # # 2011/02/25: c.setRootPosition needs no arguments.
    # c.setRootPosition()
#@+node:ekr.20040311173238: *8* c.topPosition & c.setTopPosition
def topPosition(self):
    """Return the root position."""
    c = self
    if c._topPosition:
        return c._topPosition.copy()
    return None

def setTopPosition(self, p):
    """Set the root positioin."""
    c = self
    if p:
        c._topPosition = p.copy()
    else:
        c._topPosition = None

# Define these for compatibiility with old scripts...

topVnode = topPosition
setTopVnode = setTopPosition
#@+node:ekr.20031218072017.3404: *8* c.trimTrailingLines
def trimTrailingLines(self, p):
    """Trims trailing blank lines from a node.

    It is surprising difficult to do this during Untangle."""
    c = self
    body = p.b
    lines = body.split('\n')
    i = len(lines) - 1; changed = False
    while i >= 0:
        line = lines[i]
        j = g.skip_ws(line, 0)
        if j + 1 == len(line):
            del lines[i]
            i -= 1; changed = True
        else: break
    if changed:
        body = ''.join(body) + '\n'  # Add back one last newline.
        c.setBodyString(p, body)
        # Don't set the dirty bit: it would just be annoying.
#@+node:ekr.20171124081419.1: *6* c.Check Outline...
#@+node:ekr.20141024211256.22: *7* c.checkGnxs
def checkGnxs(self):
    """
    Check the consistency of all gnx's and remove any tnodeLists.
    Reallocate gnx's for duplicates or empty gnx's.
    Return the number of structure_errors found.
    """
    c = self
    d = {}  # Keys are gnx's; values are lists of vnodes with that gnx.
    ni = g.app.nodeIndices
    t1 = time.time()

    def new_gnx(v):
        """Set v.fileIndex."""
        v.fileIndex = ni.getNewIndex(v)

    count, gnx_errors = 0, 0
    for p in c.safe_all_positions(copy=False):
        count += 1
        v = p.v
        if hasattr(v, "tnodeList"):
            delattr(v, "tnodeList")
            v._p_changed = True
        gnx = v.fileIndex
        if gnx:
            aSet = d.get(gnx, set())
            aSet.add(v)
            d[gnx] = aSet
        else:
            gnx_errors += 1
            new_gnx(v)
            g.es_print(f"empty v.fileIndex: {v} new: {p.v.gnx!r}", color='red')
    for gnx in sorted(d.keys()):
        aList = list(d.get(gnx))
        if len(aList) != 1:
            print('\nc.checkGnxs...')
            g.es_print(f"multiple vnodes with gnx: {gnx!r}", color='red')
            for v in aList:
                gnx_errors += 1
                g.es_print(f"id(v): {id(v)} gnx: {v.fileIndex} {v.h}", color='red')
                new_gnx(v)
    ok = not gnx_errors and not g.app.structure_errors
    t2 = time.time()
    if not ok:
        g.es_print(
            f"check-outline ERROR! {c.shortFileName()} "
            f"{count} nodes, "
            f"{gnx_errors} gnx errors, "
            f"{g.app.structure_errors} "
            f"structure errors",
            color='red'
        )
    elif c.verbose_check_outline and not g.unitTesting:
        print(
            f"check-outline OK: {t2 - t1:4.2f} sec. "
            f"{c.shortFileName()} {count} nodes")
    return g.app.structure_errors
#@+node:ekr.20150318131947.7: *7* c.checkLinks & helpers
def checkLinks(self):
    """Check the consistency of all links in the outline."""
    c = self
    t1 = time.time()
    count, errors = 0, 0
    for p in c.safe_all_positions():
        count += 1
        # try:
        if not c.checkThreadLinks(p):
            errors += 1
            break
        if not c.checkSiblings(p):
            errors += 1
            break
        if not c.checkParentAndChildren(p):
            errors += 1
            break
        # except AssertionError:
            # errors += 1
            # junk, value, junk = sys.exc_info()
            # g.error("test failed at position %s\n%s" % (repr(p), value))
    t2 = time.time()
    g.es_print(
        f"check-links: {t2 - t1:4.2f} sec. "
        f"{c.shortFileName()} {count} nodes", color='blue')
    return errors
#@+node:ekr.20040314035615.2: *8* c.checkParentAndChildren
def checkParentAndChildren(self, p):
    """Check consistency of parent and child data structures."""
    c = self

    def _assert(condition):
        return g._assert(condition, show_callers=False)

    def dump(p):
        if p and p.v:
            p.v.dump()
        elif p:
            print('<no p.v>')
        else:
            print('<no p>')
        if g.unitTesting:
            assert False, g.callers()

    if p.hasParent():
        n = p.childIndex()
        if not _assert(p == p.parent().moveToNthChild(n)):
            g.trace(f"p != parent().moveToNthChild({n})")
            dump(p)
            dump(p.parent())
            return False
    if p.level() > 0 and not _assert(p.v.parents):
        g.trace("no parents")
        dump(p)
        return False
    for child in p.children():
        if not c.checkParentAndChildren(child):
            return False
        if not _assert(p == child.parent()):
            g.trace("p != child.parent()")
            dump(p)
            dump(child.parent())
            return False
    if p.hasNext():
        if not _assert(p.next().parent() == p.parent()):
            g.trace("p.next().parent() != p.parent()")
            dump(p.next().parent())
            dump(p.parent())
            return False
    if p.hasBack():
        if not _assert(p.back().parent() == p.parent()):
            g.trace("p.back().parent() != parent()")
            dump(p.back().parent())
            dump(p.parent())
            return False
    # Check consistency of parent and children arrays.
    # Every nodes gets visited, so a strong test need only check consistency
    # between p and its parent, not between p and its children.
    parent_v = p._parentVnode()
    n = p.childIndex()
    if not _assert(parent_v.children[n] == p.v):
        g.trace("parent_v.children[n] != p.v")
        parent_v.dump()
        p.v.dump()
        return False
    return True
#@+node:ekr.20040314035615.1: *8* c.checkSiblings
def checkSiblings(self, p):
    """Check the consistency of next and back links."""
    back = p.back()
    next = p.next()
    if back:
        if not g._assert(p == back.next()):
            g.trace(
                f"p!=p.back().next()\n"
                f"     back: {back}\n"
                f"back.next: {back.next()}")
            return False
    if next:
        if not g._assert(p == next.back()):
            g.trace(
                f"p!=p.next().back\n"
                f"     next: {next}\n"
                f"next.back: {next.back()}")
            return False
    return True
#@+node:ekr.20040314035615: *8* c.checkThreadLinks
def checkThreadLinks(self, p):
    """Check consistency of threadNext & threadBack links."""
    threadBack = p.threadBack()
    threadNext = p.threadNext()
    if threadBack:
        if not g._assert(p == threadBack.threadNext()):
            g.trace("p!=p.threadBack().threadNext()")
            return False
    if threadNext:
        if not g._assert(p == threadNext.threadBack()):
            g.trace("p!=p.threadNext().threadBack()")
            return False
    return True
#@+node:ekr.20031218072017.1760: *7* c.checkMoveWithParentWithWarning & c.checkDrag
#@+node:ekr.20070910105044: *8* c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning(self, root, parent, warningFlag):
    """Return False if root or any of root's descendents is a clone of
    parent or any of parents ancestors."""
    c = self
    message = "Illegal move or drag: no clone may contain a clone of itself"
    clonedVnodes = {}
    for ancestor in parent.self_and_parents(copy=False):
        if ancestor.isCloned():
            v = ancestor.v
            clonedVnodes[v] = v
    if not clonedVnodes:
        return True
    for p in root.self_and_subtree(copy=False):
        if p.isCloned() and clonedVnodes.get(p.v):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning'] = True
            elif warningFlag:
                c.alert(message)
            return False
    return True
#@+node:ekr.20070910105044.1: *8* c.checkDrag
def checkDrag(self, root, target):
    """Return False if target is any descendant of root."""
    c = self
    message = "Can not drag a node into its descendant tree."
    for z in root.subtree():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning'] = True
            else:
                c.alert(message)
            return False
    return True
#@+node:ekr.20031218072017.2072: *7* c.checkOutline
def checkOutline(self, event=None, check_links=False):
    """
    Check for errors in the outline.
    Return the count of serious structure errors.
    """
    # The check-outline command sets check_links = True.
    c = self
    g.app.structure_errors = 0
    structure_errors = c.checkGnxs()
    if check_links and not structure_errors:
        structure_errors += c.checkLinks()
    return structure_errors
#@+node:ekr.20031218072017.1765: *7* c.validateOutline
# Makes sure all nodes are valid.

def validateOutline(self, event=None):
    c = self
    if not g.app.validate_outline:
        return True
    root = c.rootPosition()
    parent = None
    if root:
        return root.validateOutlineWithParent(parent)
    return True
#@+node:ekr.20040723094220: *6* c.Check Python code
# This code is no longer used by any Leo command,
# but it will be retained for use of scripts.
#@+node:ekr.20040723094220.1: *7* c.checkAllPythonCode
def checkAllPythonCode(self, event=None, unittest=False, ignoreAtIgnore=True):
    """Check all nodes in the selected tree for syntax and tab errors."""
    c = self; count = 0; result = "ok"
    for p in c.all_unique_positions():
        count += 1
        if not unittest:
            << print dots >>
        if g.scanForAtLanguage(c, p) == "python":
            if not g.scanForAtSettings(p) and (
                not ignoreAtIgnore or not g.scanForAtIgnore(c, p)
            ):
                try:
                    c.checkPythonNode(p, unittest)
                except(SyntaxError, tokenize.TokenError, tabnanny.NannyNag):
                    result = "error"  # Continue to check.
                except Exception:
                    return "surprise"  # abort
                if unittest and result != "ok":
                    g.pr(f"Syntax error in {p.h}")
                    return result  # End the unit test: it has failed.
    if not unittest:
        g.blue("check complete")
    return result
#@+node:ekr.20040723094220.2: *8* << print dots >>
if count % 100 == 0:
    g.es('', '.', newline=False)
if count % 2000 == 0:
    g.enl()
#@+node:ekr.20040723094220.3: *7* c.checkPythonCode
def checkPythonCode(self, event=None,
    unittest=False, ignoreAtIgnore=True,
    suppressErrors=False, checkOnSave=False
):
    """Check the selected tree for syntax and tab errors."""
    c = self; count = 0; result = "ok"
    if not unittest:
        g.es("checking Python code   ")
    for p in c.p.self_and_subtree():
        count += 1
        if not unittest and not checkOnSave:
            << print dots >>
        if g.scanForAtLanguage(c, p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c, p):
                try:
                    c.checkPythonNode(p, unittest, suppressErrors)
                except(SyntaxError, tokenize.TokenError, tabnanny.NannyNag):
                    result = "error"  # Continue to check.
                except Exception:
                    return "surprise"  # abort
    if not unittest:
        g.blue("check complete")
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@+node:ekr.20040723094220.4: *8* << print dots >>
if count % 100 == 0:
    g.es('', '.', newline=False)
if count % 2000 == 0:
    g.enl()
#@+node:ekr.20040723094220.5: *7* c.checkPythonNode
def checkPythonNode(self, p, unittest=False, suppressErrors=False):
    c = self; h = p.h
    # Call getScript to ignore directives and section references.
    body = g.getScript(c, p.copy())
    if not body: return
    try:
        fn = f"<node: {p.h}>"
        compile(body + '\n', fn, 'exec')
        c.tabNannyNode(p, h, body, unittest, suppressErrors)
    except SyntaxError:
        if not suppressErrors:
            g.warning(f"Syntax error in: {h}")
            g.es_exception(full=False, color="black")
        if unittest: raise
    except Exception:
        g.es_print('unexpected exception')
        g.es_exception()
        if unittest: raise
#@+node:ekr.20040723094220.6: *7* c.tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode(self, p, headline, body, unittest=False, suppressErrors=False):
    """Check indentation using tabnanny."""
    # c = self
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if not suppressErrors:
            g.warning("IndentationError in", headline)
            g.es('', msg)
        if unittest: raise
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if not suppressErrors:
            g.warning("TokenError in", headline)
            g.es('', msg)
        if unittest: raise
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if not suppressErrors:
            badline = nag.get_lineno()
            line = nag.get_line()
            message = nag.get_msg()
            g.warning("indentation error in", headline, "line", badline)
            g.es(message)
            line2 = repr(str(line))[1:-1]
            g.es("offending line:\n", line2)
        if unittest: raise
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if unittest: raise
#@+node:ekr.20171123200644.1: *6* c.Convenience methods
#@+node:ekr.20171123135625.39: *7* c.getTime
def getTime(self, body=True):
    c = self
    default_format = "%m/%d/%Y %H:%M:%S"  # E.g., 1/30/2003 8:31:55
    # Try to get the format string from settings.
    if body:
        format = c.config.getString("body-time-format-string")
        gmt = c.config.getBool("body-gmt-time")
    else:
        format = c.config.getString("headline-time-format-string")
        gmt = c.config.getBool("headline-gmt-time")
    if format is None:
        format = default_format
    try:
        # import time
        if gmt:
            s = time.strftime(format, time.gmtime())
        else:
            s = time.strftime(format, time.localtime())
    except(ImportError, NameError):
        g.warning("time.strftime not available on this platform")
        return ""
    except Exception:
        g.es_exception()  # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format, time.gmtime())
    return s
#@+node:ekr.20171123135625.10: *7* c.goToLineNumber & goToScriptLineNumber
def goToLineNumber(self, n):
    """
    Go to line n (zero-based) of a script.
    A convenience method called from g.handleScriptException.
    """
    c = self
    c.gotoCommands.find_file_line(n)

def goToScriptLineNumber(self, n, p):
    """
    Go to line n (zero-based) of a script.
    A convenience method called from g.handleScriptException.
    """
    c = self
    c.gotoCommands.find_script_line(n, p)
#@+node:ekr.20090103070824.9: *7* c.setFileTimeStamp
def setFileTimeStamp(self, fn):
    """Update the timestamp for fn.."""
    # c = self
    if g.app.externalFilesController:
        g.app.externalFilesController.set_time(fn)
#@+node:ekr.20031218072017.3000: *7* c.updateSyntaxColorer
def updateSyntaxColorer(self, v):
    self.frame.body.updateSyntaxColorer(v)
#@+node:ekr.20180503110307.1: *7* c.interactive*
#@+node:ekr.20180504075937.1: *8* c.interactive
def interactive(self, callback, event, prompts):
    << c.interactive docstring >>
    #
    # This pathetic code should be generalized,
    # but it's not as easy as one might imagine.
    c = self
    d = {1: c.interactive1, 2: c.interactive2, 3: c.interactive3,}
    f = d.get(len(prompts))
    if f:
        f(callback, event, prompts)
    else:
        g.trace('At most 3 arguments are supported.')
#@+node:ekr.20180503131222.1: *9* << c.interactive docstring >>
"""
c.interactive: Prompt for up to three arguments from the minibuffer.

The number of prompts determines the number of arguments.

Use the @command decorator to define commands.  Examples:

    @g.command('i3')
    def i3_command(event):
        c = event.get('c')
        if not c: return
            
        def callback(args, c, event):
            g.trace(args)
            c.bodyWantsFocus()
    
        c.interactive(callback, event,
            prompts=['Arg1: ', ' Arg2: ', ' Arg3: '])
"""
#@+node:ekr.20180503111213.1: *8* c.interactive1
def interactive1(self, callback, event, prompts):

    c, k = self, self.k
    prompt = prompts[0]

    def state1(event):
        callback(args=[k.arg], c=c, event=event)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

    k.setLabelBlue(prompt)
    k.get1Arg(event, handler=state1)
#@+node:ekr.20180503111249.1: *8* c.interactive2
def interactive2(self, callback, event, prompts):

    c, d, k = self, {}, self.k
    prompt1, prompt2 = prompts

    def state1(event):
        d['arg1'] = k.arg
        k.extendLabel(prompt2, select=False, protect=True)
        k.getNextArg(handler=state2)

    def state2(event):
        callback(args=[d.get('arg1'), k.arg], c=c, event=event)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

    k.setLabelBlue(prompt1)
    k.get1Arg(event, handler=state1)
#@+node:ekr.20180503111249.2: *8* c.interactive3
def interactive3(self, callback, event, prompts):

    c, d, k = self, {}, self.k
    prompt1, prompt2, prompt3 = prompts

    def state1(event):
        d['arg1'] = k.arg
        k.extendLabel(prompt2, select=False, protect=True)
        k.getNextArg(handler=state2)

    def state2(event):
        d['arg2'] = k.arg
        k.extendLabel(prompt3, select=False, protect=True)
        k.get1Arg(event, handler=state3)
            # Restart.

    def state3(event):
        args = [d.get('arg1'), d.get('arg2'), k.arg]
        callback(args=args, c=c, event=event)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

    k.setLabelBlue(prompt1)
    k.get1Arg(event, handler=state1)
#@+node:ekr.20080901124540.1: *6* c.Directive scanning
# These are all new in Leo 4.5.1.
#@+node:ekr.20171123135625.33: *7* c.getLanguageAtCursor
def getLanguageAtCursor(self, p, language):
    """
    Return the language in effect at the present insert point.
    Use the language argument as a default if no @language directive seen.
    """
    c = self
    tag = '@language'
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    n = 0
    for s in g.splitLines(p.b):
        if g.match_word(s, 0, tag):
            i = g.skip_ws(s, len(tag))
            j = g.skip_id(s, i)
            language = s[i:j]
        if n <= ins < n + len(s):
            break
        else:
            n += len(s)
    return language
#@+node:ekr.20081006100835.1: *7* c.getNodePath & c.getNodeFileName
# Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.

def getNodePath(self, p):
    """Return the path in effect at node p."""
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.

def getNodeFileName(self, p):
    """
    Return the full file name at node p,
    including effects of all @path directives.
    Return None if p is no kind of @file node.
    """
    c = self
    path = g.scanAllAtPathDirectives(c, p)
    name = ''
    for p in p.self_and_parents(copy=False):
        name = p.anyAtFileNodeName()
        if name: break
    if name:
        # The commander method supports {{expr}}; the global function does not.
        path = c.expand_path_expression(path)  # #1341.
        name = c.expand_path_expression(name)  # #1341.
        name = g.os_path_finalize_join(path, name)
    return name
#@+node:ekr.20171123135625.32: *7* c.hasAmbiguousLangauge
def hasAmbiguousLanguage(self, p):
    """Return True if p.b contains different @language directives."""
    # c = self
    languages, tag = set(), '@language'
    for s in g.splitLines(p.b):
        if g.match_word(s, 0, tag):
            i = g.skip_ws(s, len(tag))
            j = g.skip_id(s, i)
            word = s[i:j]
            languages.add(word)
    return len(list(languages)) > 1
#@+node:ekr.20080922124033.5: *7* c.os_path_finalize and c.os_path_finalize_join (deprecated)
deprecated_messages = []

def os_path_finalize(self, path, **keys):
    """
    c.os_path_finalize is deprecated.
    It no longer evaluates path expressions.
    """
    callers = g.callers(2)
    if callers not in self.deprecated_messages:
        self.deprecated_messages.append(callers)
        g.es_print(
            f"\nc.os_path_finalize{' '*5} is deprecated. called from: {callers}")
    return g.os_path_finalize(path, **keys)

def os_path_finalize_join(self, *args, **keys):
    """
    c.os_path_finalize_join is deprecated.
    It no longer evaluates path expressions.
    """
    callers = g.callers(2)
    if callers not in self.deprecated_messages:
        self.deprecated_messages.append(callers)
        g.es_print(
            f"\nc.os_path_finalize_join is deprecated. called from: {callers}")
    return g.os_path_finalize_join(*args, **keys)
#@+node:ekr.20080827175609.39: *7* c.scanAllDirectives
@nobeautify

def scanAllDirectives(self,p=None):
    """
    Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.
    """
    c = self
    p = p or c.p
    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body-pane-wraps")
    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')
    d = {
        "delims":       lang_dict.get('delims'),
        "encoding":     d.get('encoding'),
        "language":     lang_dict.get('language'),
        "lineending":   d.get('lineending'),
        "pagewidth":    d.get('pagewidth'),
        "path":         d.get('path'), # Redundant: or g.getBaseDirectory(c),
        "tabwidth":     d.get('tabwidth'),
        "pluginsList":  [], # No longer used.
        "wrap":         d.get('wrap'),
    }
    return d
#@+node:ekr.20080828103146.15: *7* c.scanAtPathDirectives
def scanAtPathDirectives(self, aList):
    """
    Scan aList for @path directives.
    Return a reasonable default if no @path directive is found.
    """
    c = self
    c.scanAtPathDirectivesCount += 1  # An important statistic.
    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":
            base = g.app.loadDir
        elif base and base == ".":
            base = c.openDirectory
    base = c.expand_path_expression(base)  # #1341:
    absbase = g.os_path_finalize_join(g.app.loadDir, base)  # #1341:
    # Step 2: look for @path directives.
    paths = []
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        warning = d.get('@path_in_body')
        if path is not None:  # retain empty paths for warnings.
            # Convert "path" or <path> to path.
            path = g.stripPathCruft(path)
            if path and not warning:
                path = c.expand_path_expression(path)  # #1341.
                paths.append(path)
            # We will silently ignore empty @path directives.
    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()
    # Step 3: Compute the full, effective, absolute path.
    path = g.os_path_finalize_join(*paths)  # #1341.
    return path or g.getBaseDirectory(c)
        # 2010/10/22: A useful default.
#@+node:ekr.20080828103146.12: *7* c.scanAtRootDirectives (no longer used)
# No longer used. Was called only by scanLanguageDirectives.

def scanAtRootDirectives(self, aList):
    """Scan aList for @root-code and @root-doc directives."""
    c = self
    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config, tag) and getattr(c.config, tag)
    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        if 'root-doc' in d:
            return 'doc'
        if 'root' in d:
            return 'doc' if start_in_doc else 'code'
    return None
#@+node:ekr.20190921130036.1: *6* c.expand_path_expression
def expand_path_expression(self, s):
    """Expand all {{anExpression}} in c's context."""
    c = self
    if not s:
        return ''
    s = g.toUnicode(s)
    # find and replace repeated path expressions
    previ, aList = 0, []
    while previ < len(s):
        i = s.find('{{', previ)
        j = s.find('}}', previ)
        if -1 < i < j:
            # Add anything from previous index up to '{{'
            if previ < i:
                aList.append(s[previ:i])
            # Get expression and find substitute
            exp = s[i + 2 : j].strip()
            if exp:
                try:
                    s2 = c.replace_path_expression(exp)
                    aList.append(s2)
                except Exception:
                    g.es(f"Exception evaluating {{{{{exp}}}}} in {s.strip()}")
                    g.es_exception(full=True, c=c)
            # Prepare to search again after the last '}}'
            previ = j + 2
        else:
            # Add trailing fragment (fragile in case of mismatched '{{'/'}}')
            aList.append(s[previ:])
            break
    val = ''.join(aList)
    if g.isWindows:
        val = val.replace('\\', '/')
    return val
#@+node:ekr.20190921130036.2: *7* c.replace_path_expression
replace_errors = []

def replace_path_expression(self, expr):
    """ local function to replace a single path expression."""
    c = self
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    # #1338: Don't report errors when called by g.getUrlFromNode.
    try:
        # pylint: disable=eval-used
        path = eval(expr, d)
        return g.toUnicode(path, encoding='utf-8')
    except Exception as e:
        message = (
            f"{c.shortFileName()}: {c.p.h}\n"
            f"expression: {expr!s}\n"
            f"     error: {e!s}")
        if message not in self.replace_errors:
            self.replace_errors.append(message)
            g.trace(message)
        return expr
#@+node:ekr.20171123201514.1: *6* c.Executing commands & scripts
#@+node:ekr.20110605040658.17005: *7* c.check_event
def check_event(self, event):
    """Check an event object."""
    # c = self
    import leo.core.leoGui as leoGui

    if not event:
        return
    stroke = event.stroke
    got = event.char
    if g.unitTesting:
        return
    if stroke and (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1):
        expected = event.char
            # Alas, Alt and Ctrl bindings must *retain* the char field,
            # so there is no way to know what char field to expect.
    else:
        expected = event.char
            # disable the test.
            # We will use the (weird) key value for, say, Ctrl-s,
            # if there is no binding for Ctrl-s.
    if not isinstance(event, leoGui.LeoKeyEvent):
        if g.app.gui.guiName() not in ('console', 'curses'):
            g.trace(f"not leo event: {event!r}, callers: {g.callers()}")
    if expected != got:
        g.trace(f"stroke: {stroke!r}, expected char: {expected!r}, got: {got!r}")
#@+node:ekr.20031218072017.2817: *7* c.doCommand
command_count = 0

def doCommand(self, command_func, command_name, event):
    """
    Execute the given command function, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the
    command func if g.doHook("command1") returns False. This provides a
    simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # New in Leo 6.2. Set command_function and command_name ivars.
    self.command_function = command_func
    self.command_name = command_name
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return None
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True
        g.error('ignoring command: already executing a command.')
        return None
    g.app.commandInterruptFlag = False
    if not g.doHook("command1", c=c, p=p, label=command_name):
        try:
            c.inCommand = True
            try:
                return_value = command_func(event)
            except Exception:
                g.es_exception()
                return_value = None
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                ## c.k.funcReturn = return_value
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=command_name)
    return return_value
#@+node:ekr.20200522075411.1: *7* c.doCommandByName
def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
#@+node:ekr.20200526074132.1: *7* c.executeMinibufferCommand
def executeMinibufferCommand(self, commandName):
    """Call c.doCommandByName, creating the required event."""
    c = self
    event = g.app.gui.create_key_event(c)
    return c.doCommandByName(commandName, event)
#@+node:ekr.20200523135601.1: *7* c.insertCharFromEvent
def insertCharFromEvent(self, event):
    """
    Handle the character given by event *without*
    executing any command that might be bound to it.
    
    What happens depends on which widget has focus.
    """
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
#@+node:ekr.20131016084446.16724: *7* c.setComplexCommand
def setComplexCommand(self, commandName):
    """Make commandName the command to be executed by repeat-complex-command."""
    c = self
    c.k.mb_history.insert(0, commandName)
#@+node:bobjack.20080509080123.2: *7* c.universalCallback & minibufferCallback
def universalCallback(self, source_c, function):
    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """

    def minibufferCallback(event, function=function):
        # Avoid a pylint complaint.
        if hasattr(self, 'theContextMenuController'):
            cm = getattr(self, 'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None
        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}
        keywords['mb_event'] = event
        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
        # For g.getDocStringForFunction
    minibufferCallback.source_c = source_c
        # For GetArgs.command_source
    return minibufferCallback

#fix bobjack's spelling error

universallCallback = universalCallback
#@+node:ekr.20070115135502: *7* c.writeScriptFile (changed: does not expand expressions)
def writeScriptFile(self, script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script-file-path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = g.os_path_finalize_join(*allParts)  # #1431
    else:
        path = g.os_path_finalize_join(g.app.homeLeoDir, 'scriptFile.py')  # #1431
    #
    # Write the file.
    try:
        with open(path, encoding='utf-8', mode='w') as f:
            f.write(script)
    except Exception:
        g.es_exception()
        g.es(f"Failed to write script to {path}")
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script-file-path'))
        path = None
    return path
#@+node:ekr.20171124101444.1: *6* c.File
#@+node:ekr.20200305104646.1: *7* c.archivedPositionToPosition (new)
def archivedPositionToPosition(self, s):
    """Convert an archived position (a string) to a position."""
    c = self
    s = g.toUnicode(s)
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        aList = None
    if not aList:
        return None
    p = c.rootPosition()
    level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
    return p
#@+node:ekr.20150422080541.1: *7* c.backup
def backup(self, fileName=None, prefix=None, silent=False, useTimeStamp=True):
    """
    Back up given fileName or c.fileName().
    If useTimeStamp is True, append a timestamp to the filename.
    """
    c = self
    fn = fileName or c.fileName()
    if not fn:
        return None
    theDir, base = g.os_path_split(fn)
    if useTimeStamp:
        if base.endswith('.leo'):
            base = base[:-4]
        stamp = time.strftime("%Y%m%d-%H%M%S")
        branch = prefix + '-' if prefix else ''
        fn = f"{branch}{base}-{stamp}.leo"
        path = g.os_path_finalize_join(theDir, fn)
    else:
        path = fn
    if path:
        # pylint: disable=no-member
            # Defined in commanderFileCommands.py.
        c.saveTo(fileName=path, silent=silent)
            # Issues saved message.
        # g.es('in', theDir)
    return path
#@+node:ekr.20180210092235.1: *7* c.backup_helper
def backup_helper(self,
    base_dir=None,
    env_key='LEO_BACKUP',
    sub_dir=None,
    use_git_prefix=True,
):
    """
    A helper for scripts that back up a .leo file.
    Use os.environ[env_key] as the base_dir only if base_dir is not given.
    Backup to base_dir or join(base_dir, sub_dir).
    """
    c = self
    old_cwd = os.getcwd()
    join = g.os_path_finalize_join
    if not base_dir:
        if env_key:
            try:
                base_dir = os.environ[env_key]
            except KeyError:
                print(f"No environment var: {env_key}")
                base_dir = None
    if base_dir and g.os_path_exists(base_dir):
        if use_git_prefix:
            git_branch, junk = g.gitInfo()
        else:
            git_branch = None
        theDir, fn = g.os_path_split(c.fileName())
        backup_dir = join(base_dir, sub_dir) if sub_dir else base_dir
        path = join(backup_dir, fn)
        if g.os_path_exists(backup_dir):
            written_fn = c.backup(
                path,
                prefix=git_branch,
                silent=True,
                useTimeStamp=True,
            )
            g.es_print(f"wrote: {written_fn}")
        else:
            g.es_print(f"backup_dir not found: {backup_dir!r}")
    else:
        g.es_print(f"base_dir not found: {base_dir!r}")
    os.chdir(old_cwd)
#@+node:ekr.20090103070824.11: *7* c.checkFileTimeStamp
def checkFileTimeStamp(self, fn):
    """
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    """
    c = self
    if g.app.externalFilesController:
        return g.app.externalFilesController.check_overwrite(c, fn)
    return True
#@+node:ekr.20090212054250.9: *7* c.createNodeFromExternalFile
def createNodeFromExternalFile(self, fn):
    """
    Read the file into a node.
    Return None, indicating that c.open should set focus.
    """
    c = self
    s, e = g.readFileIntoString(fn)
    if s is None: return
    head, ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = f"@color\n@language {language}\n\n"
    else:
        prefix = '@killcolor\n\n'
    # pylint: disable=no-member
    # Defined in commanderOutlineCommands.py
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = f"@edit {fn}"
    p2.b = prefix + s
    w = c.frame.body.wrapper
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
#@+node:ekr.20110530124245.18248: *7* c.looksLikeDerivedFile
def looksLikeDerivedFile(self, fn):
    """
    Return True if fn names a file that looks like an
    external file written by Leo.
    """
    # c = self
    try:
        with open(fn, 'r') as f:
            s = f.read()
        return s.find('@+leo-ver=') > -1
    except Exception:
        return False
#@+node:ekr.20031218072017.2925: *7* c.markAllAtFileNodesDirty
def markAllAtFileNodesDirty(self, event=None):
    """Mark all @file nodes as changed."""
    c = self
    c.endEditing()
    p = c.rootPosition()
    while p:
        if p.isAtFileNode():
            p.setDirty()
            c.setChanged()
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2926: *7* c.markAtFileNodesDirty
def markAtFileNodesDirty(self, event=None):
    """Mark all @file nodes in the selected tree as changed."""
    c = self
    p = c.p
    if not p:
        return
    c.endEditing()
    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtFileNode():
            p.setDirty()
            c.setChanged()
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    c.redraw_after_icons_changed()
#@+node:ekr.20031218072017.2823: *7* c.openWith
def openWith(self, event=None, d=None):
    """
    This is *not* a command.

    Handles the items in the Open With... menu.

    See ExternalFilesController.open_with for details about d.
    """
    c = self
    if d and g.app.externalFilesController:
        # Select an ancestor @<file> node if possible.
        if not d.get('p'):
            d['p'] = None
            p = c.p
            while p:
                if p.isAnyAtFileNode():
                    d['p'] = p
                    break
                p.moveToParent()
        g.app.externalFilesController.open_with(c, d)
    elif not d:
        g.trace('can not happen: no d', g.callers())
#@+node:ekr.20140717074441.17770: *7* c.recreateGnxDict
def recreateGnxDict(self):
    """Recreate the gnx dict prior to refreshing nodes from disk."""
    c, d = self, {}
    for v in c.all_unique_nodes():
        gnxString = v.fileIndex
        if isinstance(gnxString, str):
            d[gnxString] = v
            if 'gnx' in g.app.debug:
                g.trace(c.shortFileName(), gnxString, v)
        else:
            g.internalError(f"no gnx for vnode: {v}")
    c.fileCommands.gnxDict = d
#@+node:ekr.20180508111544.1: *6* c.Git
#@+node:ekr.20180510104805.1: *7* c.diff_file
def diff_file(self, fn, rev1='HEAD', rev2='', directory=None):
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    import leo.commands.editFileCommands as efc
    efc.GitDiffController(c=self).diff_file(
        directory=directory,
        fn=fn,
        rev1=rev1,
        rev2=rev2,
    )
#@+node:ekr.20180508110755.1: *7* c.diff_two_revs
def diff_two_revs(self, directory=None, rev1='', rev2=''):
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    import leo.commands.editFileCommands as efc
    efc.GitDiffController(c=self).diff_two_revs(
        directory=directory,
        rev1=rev1,
        rev2=rev2,
    )
#@+node:ekr.20180510103923.1: *7* c.diff_two_branches
def diff_two_branches(self, branch1, branch2, fn, directory=None):
    """
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    """
    import leo.commands.editFileCommands as efc
    efc.GitDiffController(c=self).diff_two_branches(
        branch1=branch1,
        branch2=branch2,
        directory=directory,
        fn=fn,
    )
#@+node:ekr.20180510105125.1: *7* c.git_diff
def git_diff(self, rev1='HEAD', rev2='', directory=None):

    import leo.commands.editFileCommands as efc
    efc.GitDiffController(c=self).git_diff(
        directory=directory,
        rev1=rev1,
        rev2=rev2,
    )
#@+node:ekr.20171124100534.1: *6* c.Gui
#@+node:ekr.20111217154130.10286: *7* c.Dialogs & messages
#@+node:ekr.20110510052422.14618: *8* c.alert
def alert(self, message):
    c = self
    # The unit tests just tests the args.
    if not g.unitTesting:
        g.es(message)
        g.app.gui.alert(c, message)
#@+node:ekr.20111217154130.10284: *8* c.init_error_dialogs
def init_error_dialogs(self):
    c = self
    c.import_error_nodes = []
    c.ignored_at_file_nodes = []
    c.orphan_at_file_nodes = []
    if g.unitTesting:
        d = g.app.unitTestDict
        tag = 'init_error_dialogs'
        d[tag] = 1 + d.get(tag, 0)
#@+node:ekr.20171123135805.1: *8* c.notValidInBatchMode
def notValidInBatchMode(self, commandName):
    g.es('the', commandName, "command is not valid in batch mode")
#@+node:ekr.20110530082209.18250: *8* c.putHelpFor
def putHelpFor(self, s, short_title=''):
    """Helper for various help commands."""
    c = self
    g.app.gui.put_help(c, s, short_title)
#@+node:ekr.20111217154130.10285: *8* c.raise_error_dialogs
def raise_error_dialogs(self, kind='read'):
    """Warn abouit read/write failures."""
    c = self
    use_dialogs = True
    if g.unitTesting:
        d = g.app.unitTestDict
        tag = 'raise_error_dialogs'
        d[tag] = 1 + d.get(tag, 0)
        # This trace catches all too-many-calls failures.
            # g.trace(g.callers())
        c.init_error_dialogs()
        return
    #
    # Issue one or two dialogs or messages.
    saved_body = c.rootPosition().b
        # Save the root's body. Somehow the dialog destroys it!
    if c.import_error_nodes or c.ignored_at_file_nodes or c.orphan_at_file_nodes:
        g.app.gui.dismiss_splash_screen()
    else:
        # #1007: Exit now, so we don't have to restore c.rootPosition().b.
        c.init_error_dialogs()
        return
    if c.import_error_nodes:
        files = '\n'.join(sorted(set(c.import_error_nodes)))
        if use_dialogs:
            message = (
                'The following were not imported properly. '
                f"Inserted @ignore in...\n{files}")
            g.app.gui.runAskOkDialog(c, message=message, title='Import errors')
        else:
            g.es('import errors...', color='red')
            g.es('\n'.join(sorted(files)), color='blue')
    if c.ignored_at_file_nodes:
        files = '\n'.join(sorted(set(c.ignored_at_file_nodes)))
        kind = 'read' if kind.startswith('read') else 'written'
        if use_dialogs:
            message = (
                f"The following were not {kind} "
                f"because they contain @ignore:\n{files}")
            g.app.gui.runAskOkDialog(c,
                message=message,
                title=f"Not {kind.capitalize()}")
        else:
            g.es(f"not {kind} (@ignore)...", color='red')
            g.es(files, color='blue')
    #
    # #1050: always raise a dialog for orphan @<file> nodes.
    if c.orphan_at_file_nodes:
        message = '\n'.join([
            'The following were not written because of errors:\n',
            '\n'.join(sorted(set(c.orphan_at_file_nodes))),
            '',
            'Warning: changes to these files will be lost\n'
            'unless you can save the files successfully.'
        ])
        g.app.gui.runAskOkDialog(c, message=message, title='Not Written')
        # Mark all the nodes dirty.
        for z in c.all_unique_positions():
            if z.isOrphan():
                z.setDirty()
                z.clearOrphan()
        c.setChanged()
        c.redraw()
    # Restore the root position's body.
    c.rootPosition().v.b = saved_body
        # #1007: just set v.b.
    c.init_error_dialogs()
#@+node:ekr.20150710083827.1: *8* c.syntaxErrorDialog
def syntaxErrorDialog(self):
    """Warn about syntax errors in files."""
    c = self
    if g.app.syntax_error_files and c.config.getBool(
        'syntax-error-popup', default=False):
        aList = sorted(set(g.app.syntax_error_files))
        g.app.syntax_error_files = []
        list_s = '\n'.join(aList)
        g.app.gui.runAskOkDialog(
            c,
            title='Python Errors',
            message=f"Python errors in:\n\n{list_s}",
            text="Ok",
        )
#@+node:ekr.20031218072017.2945: *7* c.Dragging
#@+node:ekr.20031218072017.2947: *8* c.dragToNthChildOf
def dragToNthChildOf(self, p, parent, n):
    c = self; u = c.undoer; undoType = 'Drag'
    current = c.p
    if not c.checkDrag(p, parent):
        return
    if not c.checkMoveWithParentWithWarning(p, parent, True):
        return
    c.endEditing()
    undoData = u.beforeMoveNode(current)
    p.setDirty()
    p.moveToNthChildOf(parent, n)
    p.setDirty()
    c.setChanged()
    u.afterMoveNode(p, undoType, undoData)
    c.redraw(p)
    c.updateSyntaxColorer(p)  # Dragging can change syntax coloring.
#@+node:ekr.20031218072017.2353: *8* c.dragAfter
def dragAfter(self, p, after):
    c = self; u = self.undoer; undoType = 'Drag'
    current = c.p
    if not c.checkDrag(p, after):
        return
    if not c.checkMoveWithParentWithWarning(p, after.parent(), True):
        return
    c.endEditing()
    undoData = u.beforeMoveNode(current)
    p.setDirty()
    p.moveAfter(after)
    p.setDirty()
    c.setChanged()
    u.afterMoveNode(p, undoType, undoData)
    c.redraw(p)
    c.updateSyntaxColorer(p)  # Dragging can change syntax coloring.
#@+node:ekr.20031218072017.2946: *8* c.dragCloneToNthChildOf
def dragCloneToNthChildOf(self, p, parent, n):
    c = self; u = c.undoer; undoType = 'Clone Drag'
    current = c.p
    clone = p.clone()  # Creates clone & dependents, does not set undo.
    if (
        not c.checkDrag(p, parent) or
        not c.checkMoveWithParentWithWarning(clone, parent, True)
    ):
        clone.doDelete(newNode=p)  # Destroys clone and makes p the current node.
        c.selectPosition(p)  # Also sets root position.
        return
    c.endEditing()
    undoData = u.beforeInsertNode(current)
    clone.setDirty()
    clone.moveToNthChildOf(parent, n)
    clone.setDirty()
    c.setChanged()
    u.afterInsertNode(clone, undoType, undoData)
    c.redraw(clone)
    c.updateSyntaxColorer(clone)  # Dragging can change syntax coloring.
#@+node:ekr.20031218072017.2948: *8* c.dragCloneAfter
def dragCloneAfter(self, p, after):
    c = self; u = c.undoer; undoType = 'Clone Drag'
    current = c.p
    clone = p.clone()  # Creates clone.  Does not set undo.
    if c.checkDrag(
        p, after) and c.checkMoveWithParentWithWarning(clone, after.parent(), True):
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        clone.setDirty()
        clone.moveAfter(after)
        clone.v.setDirty()
        c.setChanged()
        u.afterInsertNode(clone, undoType, undoData)
        p = clone
    else:
        clone.doDelete(newNode=p)
    c.redraw(p)
    c.updateSyntaxColorer(clone)  # Dragging can change syntax coloring.
#@+node:ekr.20031218072017.2949: *7* c.Drawing
#@+node:ekr.20080514131122.7: *8* c.begin/endUpdate
def beginUpdate(self):
    """Deprecated: does nothing."""
    g.trace('***** c.beginUpdate is deprecated', g.callers())
    if g.app.unitTesting: assert(False)

def endUpdate(self, flag=True):
    """Request a redraw of the screen if flag is True."""
    g.trace('***** c.endUpdate is deprecated', g.callers())
    if g.app.unitTesting: assert(False)
    c = self
    if flag:
        c.requestRedrawFlag = True

BeginUpdate = beginUpdate  # Compatibility with old scripts
EndUpdate = endUpdate  # Compatibility with old scripts
#@+node:ekr.20080514131122.8: *8* c.bringToFront
def bringToFront(self, c2=None, set_focus=True):
    c = self
    c2 = c2 or c
    g.app.gui.ensure_commander_visible(c2)

BringToFront = bringToFront  # Compatibility with old scripts
#@+node:ekr.20040803072955.143: *8* c.expandAllAncestors
def expandAllAncestors(self, p):
    """
    Expand all ancestors without redrawing.
    Return a flag telling whether a redraw is needed.
    """
    # c = self
    redraw_flag = False
    for p in p.parents():
        if not p.v.isExpanded():
            p.v.expand()
            p.expand()
            redraw_flag = True
        elif p.isExpanded():
            p.v.expand()
        else:
            p.expand()
            redraw_flag = True
    return redraw_flag
#@+node:ekr.20080514131122.20: *8* c.outerUpdate
def outerUpdate(self):
    """Handle delayed focus requests and modified events."""
    c = self
    if not c.exists or not c.k:
        return
    # New in Leo 5.6: Delayed redraws are useful in utility methods.
    if c.requestLaterRedraw:
        if c.enableRedrawFlag:
            c.requestLaterRedraw = False
            if 'drawing' in g.app.debug and not g.unitTesting:
                g.trace('\nDELAYED REDRAW')
                time.sleep(1.0)
            c.redraw()
    # Delayed focus requests will always be useful.
    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if 'focus' in g.app.debug and not g.unitTesting:
            if hasattr(w, 'objectName'):
                name = w.objectName()
            else:
                name = w.__class__.__name__
            g.trace('DELAYED FOCUS', name)
        c.set_focus(w)
        c.requestedFocusWidget = None
    table = (
        ("childrenModified", g.childrenModifiedSet),
        ("contentModified", g.contentModifiedSet),
    )
    for kind, mods in table:
        if mods:
            g.doHook(kind, c=c, nodes=mods)
            mods.clear()
#@+node:ekr.20080514131122.13: *8* c.recolor
def recolor(self, **kwargs):
    # Support QScintillaColorizer.colorize.
    c = self
    p = kwargs.get('p')
    for name in ('incremental', 'interruptable'):
        if name in kwargs:
            print(f'c.recolor_now: "{name}" keyword arg is deprecated')
    colorizer = c.frame.body.colorizer
    if colorizer and hasattr(colorizer, 'colorize'):
        colorizer.colorize(p or c.p)

recolor_now = recolor
#@+node:ekr.20080514131122.14: *8* c.redrawing...
#@+node:ekr.20170808014610.1: *9* c.enable/disable_redraw
def disable_redraw(self):
    """Disable all redrawing until enabled."""
    c = self
    c.enableRedrawFlag = False

def enable_redraw(self):
    c = self
    c.enableRedrawFlag = True
#@+node:ekr.20090110073010.1: *9* c.redraw
@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
#@+node:ekr.20090110073010.3: *9* c.redraw_afer_icons_changed
def redraw_after_icons_changed(self):
    """Update the icon for the presently selected node"""
    c = self
    if c.enableRedrawFlag:
        c.frame.tree.redraw_after_icons_changed()
        # Do not call treeFocusHelper here.
            # c.treeFocusHelper()
    else:
        c.requestLaterRedraw = True
#@+node:ekr.20090110131802.2: *9* c.redraw_after_contract
def redraw_after_contract(self, p=None):
    c = self
    if c.enableRedrawFlag:
        if p:
            c.setCurrentPosition(p)
        else:
            p = c.currentPosition()
        c.frame.tree.redraw_after_contract(p)
        c.treeFocusHelper()
    else:
        c.requestLaterRedraw = True
#@+node:ekr.20090112065525.1: *9* c.redraw_after_expand
def redraw_after_expand(self, p):
    c = self
    if c.enableRedrawFlag:
        if p:
            c.setCurrentPosition(p)
        else:
            p = c.currentPosition()
        c.frame.tree.redraw_after_expand(p)
        c.treeFocusHelper()
    else:
        c.requestLaterRedraw = True
#@+node:ekr.20090110073010.2: *9* c.redraw_after_head_changed
def redraw_after_head_changed(self):
    """
    Redraw the screen (if needed) when editing ends.
    This may be a do-nothing for some gui's.
    """
    c = self
    if c.enableRedrawFlag:
        self.frame.tree.redraw_after_head_changed()
    else:
        c.requestLaterRedraw = True
#@+node:ekr.20090110073010.4: *9* c.redraw_after_select
def redraw_after_select(self, p):
    """Redraw the screen after node p has been selected."""
    c = self
    if c.enableRedrawFlag:
        flag = c.expandAllAncestors(p)
        if flag:
            c.frame.tree.redraw_after_select(p)
                # This is the same as c.frame.tree.full_redraw().
    else:
        c.requestLaterRedraw = True
#@+node:ekr.20170908081918.1: *9* c.redraw_later
def redraw_later(self):
    """
    Ensure that c.redraw() will be called eventually.
    
    c.outerUpdate will call c.redraw() only if no other code calls c.redraw().
    """
    c = self
    c.requestLaterRedraw = True
    if 'drawing' in g.app.debug:
        # g.trace('\n' + g.callers(8))
        g.trace(g.callers())
#@+node:ekr.20080514131122.17: *8* c.widget_name
def widget_name(self, widget):
    # c = self
    return g.app.gui.widget_name(widget) if g.app.gui else '<no widget>'
#@+node:ekr.20171124101045.1: *7* c.Events
#@+node:ekr.20060923202156: *8* c.onCanvasKey
def onCanvasKey(self, event):
    """
    Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.
    """
    if not event or not event.char or not event.char.isalnum():
        return
    c = self; p = c.p; p1 = p.copy()
    invisible = c.config.getBool('invisible-outline-navigation')
    ch = event.char if event else ''
    allFlag = ch.isupper() and invisible  # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = (True, False) if extend else (False,)
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1:  # Never try to match the same position.
                found = False; break
            newPrefix = c.navHelper(p, ch, extend2)
            if newPrefix:
                found = True; break
        if found: break
    if found:
        c.selectPosition(p)
        c.redraw_after_select(p)
        c.navTime = time.time()
        c.navPrefix = newPrefix
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocus()
#@+node:ekr.20061002095711.1: *9* c.navQuickKey
def navQuickKey(self):
    """
    Return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.
    """
    c = self
    deltaTime = c.config.getFloat('outline-nav-extend-delay')
    if deltaTime in (None, 0.0):
        return False
    nearTime = c.navTime and time.time() - c.navTime < deltaTime
    return nearTime
#@+node:ekr.20061002095711: *9* c.navHelper
def navHelper(self, p, ch, extend):
    c = self; h = p.h.lower()
    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix
    if h.startswith(ch):
        return ch
    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button', 'command', 'file', 'thin', 'asis', 'nosent',):
            prefix = '@' + s
            if h.startswith('@' + s):
                while 1:
                    n = len(prefix)
                    ch2 = h[n] if n < len(h) else ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
#@+node:ekr.20031218072017.2909: *7* c.Expand/contract
#@+node:ekr.20171124091426.1: *8* c.contractAllHeadlines
def contractAllHeadlines(self, event=None, redrawFlag=True):
    """Contract all nodes in the outline."""
    c = self
    for p in c.all_positions():
        p.contract()
    # Select the topmost ancestor of the presently selected node.
    p = c.p
    while p and p.hasParent():
        p.moveToParent()
    if redrawFlag:
        # Do a *full* redraw.
        # c.redraw_after_contract(p) only contracts a single position.
        c.redraw(p)
    c.expansionLevel = 1  # Reset expansion level.
#@+node:ekr.20031218072017.2910: *8* c.contractSubtree
def contractSubtree(self, p):
    for p in p.subtree():
        p.contract()
#@+node:ekr.20031218072017.2911: *8* c.expandSubtree
def expandSubtree(self, v, redraw=True):
    c = self
    last = v.lastNode()
    while v and v != last:
        v.expand()
        v = v.threadNext()
    if redraw:
        c.redraw()
#@+node:ekr.20031218072017.2912: *8* c.expandToLevel
def expandToLevel(self, level):

    c = self
    n = c.p.level()
    old_expansion_level = c.expansionLevel
    max_level = 0
    for p in c.p.self_and_subtree(copy=False):
        if p.level() - n + 1 < level:
            p.expand()
            max_level = max(max_level, p.level() - n + 1)
        else:
            p.contract()
    c.expansionNode = c.p.copy()
    c.expansionLevel = max_level + 1
    if c.expansionLevel != old_expansion_level:
        c.redraw()
    # It's always useful to announce the level.
    # c.k.setLabelBlue('level: %s' % (max_level+1))
    # g.es('level', max_level + 1)
    c.frame.putStatusLine(f"level: {max_level + 1}")
        # bg='red', fg='red')
#@+node:ekr.20141028061518.23: *7* c.Focus
#@+node:ekr.20080514131122.9: *8* c.get/request/set_focus
def get_focus(self):
    c = self
    w = g.app.gui and g.app.gui.get_focus(c)
    if 'focus' in g.app.debug:
        name = w.objectName() if hasattr(w, 'objectName') else w.__class__.__name__
        g.trace('(c)', name)
        # g.trace('\n(c)',  w.__class__.__name__)
        # g.trace(g.callers(6))
    return w

def get_requested_focus(self):
    c = self
    return c.requestedFocusWidget

def request_focus(self, w):
    c = self
    if w and g.app.gui:
        if 'focus' in g.app.debug:
            # g.trace('\n(c)', repr(w))
            name = w.objectName(
                ) if hasattr(w, 'objectName') else w.__class__.__name__
            g.trace('(c)', name)
        c.requestedFocusWidget = w

def set_focus(self, w, force=False):
    trace = 'focus' in g.app.debug
    c = self
    if w and g.app.gui:
        if trace:
            name = w.objectName(
                ) if hasattr(w, 'objectName') else w.__class__.__name__
            g.trace('(c)', name)
        g.app.gui.set_focus(c, w)
    else:
        if trace: g.trace('(c) no w')
    c.requestedFocusWidget = None
#@+node:ekr.20080514131122.10: *8* c.invalidateFocus (do nothing)
def invalidateFocus(self):
    """Indicate that the focus is in an invalid location, or is unknown."""
    # c = self
    # c.requestedFocusWidget = None
    pass
#@+node:ekr.20080514131122.16: *8* c.traceFocus (not used)
def traceFocus(self, w):
    c = self
    if 'focus' in g.app.debug:
        c.trace_focus_count += 1
        g.pr(f"{c.trace_focus_count:4d}", c.widget_name(w), g.callers(8))
#@+node:ekr.20070226121510: *8* c.xFocusHelper & initialFocusHelper
def treeFocusHelper(self):
    c = self
    if c.stayInTreeAfterSelect:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()

def initialFocusHelper(self):
    c = self
    if c.outlineHasInitialFocus:
        c.treeWantsFocus()
    else:
        c.bodyWantsFocus()
#@+node:ekr.20080514131122.18: *8* c.xWantsFocus
def bodyWantsFocus(self):
    c = self; body = c.frame.body
    c.request_focus(body and body.wrapper)

def logWantsFocus(self):
    c = self; log = c.frame.log
    c.request_focus(log and log.logCtrl)

def minibufferWantsFocus(self):
    c = self
    c.request_focus(c.miniBufferWidget)

def treeWantsFocus(self):
    c = self; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)

def widgetWantsFocus(self, w):
    c = self; c.request_focus(w)
#@+node:ekr.20080514131122.19: *8* c.xWantsFocusNow
# widgetWantsFocusNow does an automatic update.

def widgetWantsFocusNow(self, w):
    c = self
    if w:
        c.set_focus(w)
        c.requestedFocusWidget = None

# New in 4.9: all FocusNow methods now *do* call c.outerUpdate().

def bodyWantsFocusNow(self):
    c = self; body = c.frame.body
    c.widgetWantsFocusNow(body and body.wrapper)

def logWantsFocusNow(self):
    c = self; log = c.frame.log
    c.widgetWantsFocusNow(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self
    c.widgetWantsFocusNow(c.miniBufferWidget)

def treeWantsFocusNow(self):
    c = self; tree = c.frame.tree
    c.widgetWantsFocusNow(tree and tree.canvas)
#@+node:ekr.20031218072017.2955: *7* c.Menus
#@+node:ekr.20080610085158.2: *8* c.add_command
def add_command(self, menu, **keys):
    c = self
    command = keys.get('command')
    if command:
        # Command is always either:
        # one of two callbacks defined in createMenuEntries or
        # recentFilesCallback, defined in createRecentFilesMenuItems.

        def add_commandCallback(c=c, command=command):
            val = command()
            # Careful: func may destroy c.
            if c.exists: c.outerUpdate()
            return val

        keys['command'] = add_commandCallback
        menu.add_command(**keys)
    else:
        g.trace('can not happen: no "command" arg')
#@+node:ekr.20171123203044.1: *8* c.Menu Enablers
#@+node:ekr.20040131170659: *9* c.canClone
def canClone(self):
    c = self
    if c.hoistStack:
        current = c.p
        bunch = c.hoistStack[-1]
        return current != bunch.p
    return True
#@+node:ekr.20031218072017.2956: *9* c.canContractAllHeadlines
def canContractAllHeadlines(self):
    """Contract all nodes in the tree."""
    c = self
    for p in c.all_positions():  # was c.all_unique_positions()
        if p.isExpanded():
            return True
    return False
#@+node:ekr.20031218072017.2957: *9* c.canContractAllSubheads
def canContractAllSubheads(self):
    c = self; current = c.p
    for p in current.subtree():
        if p != current and p.isExpanded():
            return True
    return False
#@+node:ekr.20031218072017.2958: *9* c.canContractParent
def canContractParent(self):
    c = self
    return c.p.parent()
#@+node:ekr.20031218072017.2959: *9* c.canContractSubheads
def canContractSubheads(self):
    c = self; current = c.p
    for child in current.children():
        if child.isExpanded():
            return True
    return False
#@+node:ekr.20031218072017.2960: *9* c.canCutOutline & canDeleteHeadline
def canDeleteHeadline(self):
    c = self; p = c.p
    if c.hoistStack:
        bunch = c.hoistStack[0]
        if p == bunch.p: return False
    return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
#@+node:ekr.20031218072017.2961: *9* c.canDemote
def canDemote(self):
    c = self
    return c.p.hasNext()
#@+node:ekr.20031218072017.2962: *9* c.canExpandAllHeadlines
def canExpandAllHeadlines(self):
    """Return True if the Expand All Nodes menu item should be enabled."""
    c = self
    for p in c.all_positions():  # was c.all_unique_positions()
        if not p.isExpanded():
            return True
    return False
#@+node:ekr.20031218072017.2963: *9* c.canExpandAllSubheads
def canExpandAllSubheads(self):
    c = self
    for p in c.p.subtree():
        if not p.isExpanded():
            return True
    return False
#@+node:ekr.20031218072017.2964: *9* c.canExpandSubheads
def canExpandSubheads(self):
    c = self; current = c.p
    for p in current.children():
        if p != current and not p.isExpanded():
            return True
    return False
#@+node:ekr.20031218072017.2287: *9* c.canExtract, canExtractSection & canExtractSectionNames
def canExtract(self):
    c = self
    w = c.frame.body.wrapper
    return w and w.hasSelection()

canExtractSectionNames = canExtract

def canExtractSection(self):
    c = self
    w = c.frame.body.wrapper
    if not w: return False
    s = w.getSelectedText()
    if not s: return False
    line = g.get_line(s, 0)
    i1 = line.find("<<")
    j1 = line.find(">>")
    i2 = line.find("@<")
    j2 = line.find("@>")
    return -1 < i1 < j1 or -1 < i2 < j2
#@+node:ekr.20031218072017.2965: *9* c.canFindMatchingBracket
@nobeautify

def canFindMatchingBracket(self):
    c = self
    brackets = "()[]{}"
    w = c.frame.body.wrapper
    s = w.getAllText()
    ins = w.getInsertPoint()
    c1 = s[ins]   if 0 <= ins   < len(s) else ''
    c2 = s[ins-1] if 0 <= ins-1 < len(s) else ''
    val = (c1 and c1 in brackets) or (c2 and c2 in brackets)
    return bool(val)
#@+node:ekr.20040303165342: *9* c.canHoist & canDehoist
def canDehoist(self):
    """
    Return True if do-hoist should be enabled in a menu.
    Should not be used in any other context.
    """
    c = self
    return bool(c.hoistStack)

def canHoist(self):
    # This is called at idle time, so minimizing positions is crucial!
    """
    Return True if hoist should be enabled in a menu.
    Should not be used in any other context.
    """
    return True
    # c = self
    # if c.hoistStack:
        # p = c.hoistStack[-1].p
        # return p and not c.isCurrentPosition(p)
    # elif c.currentPositionIsRootPosition():
        # return c.currentPositionHasNext()
    # else:
        # return True
#@+node:ekr.20031218072017.2970: *9* c.canMoveOutlineDown
def canMoveOutlineDown(self):
    c = self; current = c.p
    return current and current.visNext(c)
#@+node:ekr.20031218072017.2971: *9* c.canMoveOutlineLeft
def canMoveOutlineLeft(self):
    c = self; p = c.p
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        if p and p.hasParent():
            p.moveToParent()
            return p != bunch.p and bunch.p.isAncestorOf(p)
        return False
    return p and p.hasParent()
#@+node:ekr.20031218072017.2972: *9* c.canMoveOutlineRight
def canMoveOutlineRight(self):
    c = self; p = c.p
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        return p and p.hasBack() and p != bunch.p
    return p and p.hasBack()
#@+node:ekr.20031218072017.2973: *9* c.canMoveOutlineUp
def canMoveOutlineUp(self):
    c = self; current = c.p
    visBack = current and current.visBack(c)
    if not visBack:
        return False
    if visBack.visBack(c):
        return True
    if c.hoistStack:
        limit, limitIsVisible = c.visLimit()
        if limitIsVisible:  # A hoist
            return current != limit
        # A chapter.
        return current != limit.firstChild()
    return current != c.rootPosition()
#@+node:ekr.20031218072017.2974: *9* c.canPasteOutline
def canPasteOutline(self, s=None):
    # c = self
    if not s:
        s = g.app.gui.getTextFromClipboard()
    if s and g.match(s, 0, g.app.prolog_prefix_string):
        return True
    return False
#@+node:ekr.20031218072017.2975: *9* c.canPromote
def canPromote(self):
    c = self; v = c.currentVnode()
    return v and v.hasChildren()
#@+node:ekr.20031218072017.2977: *9* c.canSelect....
def canSelectThreadBack(self):
    c = self; p = c.p
    return p.hasThreadBack()

def canSelectThreadNext(self):
    c = self; p = c.p
    return p.hasThreadNext()

def canSelectVisBack(self):
    c = self; p = c.p
    return p.visBack(c)

def canSelectVisNext(self):
    c = self; p = c.p
    return p.visNext(c)
#@+node:ekr.20031218072017.2978: *9* c.canShiftBodyLeft/Right
def canShiftBodyLeft(self):
    c = self
    w = c.frame.body.wrapper
    return w and w.getAllText()

canShiftBodyRight = canShiftBodyLeft
#@+node:ekr.20031218072017.2979: *9* c.canSortChildren, canSortSiblings
def canSortChildren(self):
    c = self; p = c.p
    return p and p.hasChildren()

def canSortSiblings(self):
    c = self; p = c.p
    return p and (p.hasNext() or p.hasBack())
#@+node:ekr.20031218072017.2980: *9* c.canUndo & canRedo
def canUndo(self):
    c = self
    return c.undoer.canUndo()

def canRedo(self):
    c = self
    return c.undoer.canRedo()
#@+node:ekr.20031218072017.2981: *9* c.canUnmarkAll
def canUnmarkAll(self):
    c = self
    for p in c.all_unique_positions():
        if p.isMarked():
            return True
    return False
#@+node:ekr.20040323172420: *9* Slow routines: no longer used
#@+node:ekr.20031218072017.2966: *10* c.canGoToNextDirtyHeadline (slow)
def canGoToNextDirtyHeadline(self):
    c = self; current = c.p
    for p in c.all_unique_positions():
        if p != current and p.isDirty():
            return True
    return False
#@+node:ekr.20031218072017.2967: *10* c.canGoToNextMarkedHeadline (slow)
def canGoToNextMarkedHeadline(self):
    c = self; current = c.p
    for p in c.all_unique_positions():
        if p != current and p.isMarked():
            return True
    return False
#@+node:ekr.20031218072017.2968: *10* c.canMarkChangedHeadline (slow)
def canMarkChangedHeadlines(self):
    c = self
    for p in c.all_unique_positions():
        if p.isDirty():
            return True
    return False
#@+node:ekr.20031218072017.2969: *10* c.canMarkChangedRoots (slow)
def canMarkChangedRoots(self):
    c = self
    for p in c.all_unique_positions():
        if p.isDirty and p.isAnyAtFileNode():
            return True
    return False
#@+node:ekr.20031218072017.2990: *7* c.Selecting
#@+node:ekr.20031218072017.2992: *8* c.endEditing (calls tree.endEditLabel)
# Ends the editing in the outline.

def endEditing(self):
    c = self
    p = c.p
    if p:
        c.frame.tree.endEditLabel()
    # The following code would be wrong; c.endEditing is a utility method.
    # k = c.k
    # if k:
        # k.setDefaultInputState()
        # # Recolor the *body* text, **not** the headline.
        # k.showStateAndMode(w=c.frame.body.wrapper)
#@+node:ville.20090525205736.12325: *8* c.getSelectedPositions
def getSelectedPositions(self):
    """ Get list (PosList) of currently selected positions

    So far only makes sense on qt gui (which supports multiselection)
    """
    c = self
    return c.frame.tree.getSelectedPositions()
#@+node:ekr.20031218072017.2991: *8* c.redrawAndEdit
def redrawAndEdit(self, p, selectAll=False, selection=None, keepMinibuffer=False):
    """Redraw the screen and edit p's headline."""
    c, k = self, self.k
    c.redraw(p)  # This *must* be done now.
    if p:
        # This should request focus.
        c.frame.tree.editLabel(p, selectAll=selectAll, selection=selection)
        if k and not keepMinibuffer:
            # Setting the input state has no effect on focus.
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()
            # This *does* affect focus.
            k.showStateAndMode()
    else:
        g.trace('** no p')
    # Update the focus immediately.
    if not keepMinibuffer:
        c.outerUpdate()
#@+node:ekr.20031218072017.2997: *8* c.selectPosition
def selectPosition(self, p, **kwargs):
    """
    Select a new position, redrawing the screen *only* if we must
    change chapters.
    """
    if kwargs:
        print('c.selectPosition: all keyword args are ignored', g.callers())
    c = self
    cc = c.chapterController
    if not p:
        if not g.app.batchMode:  # A serious error.
            g.trace('Warning: no p', g.callers())
        return
    if cc and not cc.selectChapterLockout:
        cc.selectChapterForPosition(p)
            # Calls c.redraw only if the chapter changes.
    # De-hoist as necessary to make p visible.
    if c.hoistStack:
        while c.hoistStack:
            bunch = c.hoistStack[-1]
            if c.positionExists(p, bunch.p):
                break
            else:
                bunch = c.hoistStack.pop()
    c.frame.tree.select(p)
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

# Compatibility, but confusing.

selectVnode = selectPosition
#@+node:ekr.20080503055349.1: *8* c.setPositionAfterSort
def setPositionAfterSort(self, sortChildren):
    """
    Return the position to be selected after a sort.
    """
    c = self
    p = c.p
    p_v = p.v
    parent = p.parent()
    parent_v = p._parentVnode()
    if sortChildren:
        return parent or c.rootPosition()
    if parent:
        p = parent.firstChild()
    else:
        p = leoNodes.Position(parent_v.children[0])
    while p and p.v != p_v:
        p.moveToNext()
    p = p or parent
    return p
#@+node:ekr.20070226113916: *8* c.treeSelectHelper
def treeSelectHelper(self, p):
    c = self
    if not p: p = c.p
    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)
    c.treeFocusHelper()
        # This is essential.
#@+node:ekr.20171123135625.51: *7* c.updateBodyPane (handles changeNodeContents)
def updateBodyPane(
    self, head, middle, tail, undoType, oldSel, oldYview, preserveSel=False):
    """Handle changed text in the body pane."""
    c, p = self, self.p
    body = c.frame.body
    # Update the text and notify the event handler.
    body.setSelectionAreas(head, middle, tail)
    # Expand the selection.
    head = head or ''
    middle = middle or ''
    tail = tail or ''
    if preserveSel:
        # Leo 5.6: just use the computed oldSel.
        i, j = oldSel
    else:
        i = len(head)
        j = max(i, len(head) + len(middle) - 1)
        newSel = i, j
    body.wrapper.setSelectionRange(i, j)
    # This handles the undo.
    body.onBodyChanged(undoType, oldSel=oldSel or newSel, oldYview=oldYview)
    # Update the changed mark and icon.
    p.setDirty()
    c.setChanged()
    c.redraw_after_icons_changed()
    # Scroll as necessary.
    if oldYview:
        body.wrapper.setYScrollPosition(oldYview)
    else:
        body.wrapper.seeInsertPoint()
    body.wrapper.setFocus()
    c.recolor()
#@+node:ekr.20130823083943.12559: *6* c.recursiveImport
def recursiveImport(self, dir_, kind,
    add_context=None,  # Override setting only if True/False
    add_file_context=None,  # Override setting only if True/False
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    # force_at_others=False, # tag:no-longer-used
    ignore_pattern=None
):
    << docstring >>
    c = self
    if g.os_path_exists(dir_):
        # Import all files in dir_ after c.p.
        try:
            import leo.core.leoImport as leoImport
            cc = leoImport.RecursiveImportController(c, kind,
                add_context=add_context,
                add_file_context=add_file_context,
                add_path=add_path,
                recursive=recursive,
                safe_at_file=safe_at_file,
                theTypes=['.py'] if not theTypes else theTypes,
                # force_at_others = force_at_others,  # tag:no-longer-used
                ignore_pattern=ignore_pattern
            )
            cc.run(dir_)
        finally:
            c.redraw()
    else:
        g.es_print(f"Does not exist: {dir_}")
#@+node:ekr.20130823083943.12614: *7* << docstring >>
"""
Recursively import all python files in a directory and clean the results.

Parameters::
    dir_              The root directory or file to import.
    kind              One of ('@clean','@edit','@file','@nosent').
    add_path=True     True: add a full @path directive to @<file> nodes.
    recursive=True    True: recurse into subdirectories.
    safe_at_file=True True: produce @@file nodes instead of @file nodes.
    theTypes=None     A list of file extensions to import.
                      None is equivalent to ['.py']

This method cleans imported files as follows:

- Replace backslashes with forward slashes in headlines.
- Remove empty nodes.
- Add @path directives that reduce the needed path specifiers in descendant nodes.
- Add @file to nodes or replace @file with @@file.
"""
#@+node:ekr.20171124084149.1: *6* c.Scripting utils
#@+node:ekr.20160201072634.1: *7* c.cloneFindByPredicated
def cloneFindByPredicate(self,
    generator,  # The generator used to traverse the tree.
    predicate,  # A function of one argument p, returning True
                   # if p should be included in the results.
    failMsg=None,  # Failure message. Default is no message.
    flatten=False,  # True: Put all matches at the top level.
    iconPath=None,  # Full path to icon to attach to all matches.
    redraw=True,  # True: redraw the outline,
    undoType=None,  # The undo name, shown in the Edit:Undo menu.
                   # The default is 'clone-find-predicate'
):
    """
    Traverse the tree given using the generator, cloning all positions for
    which predicate(p) is True. Undoably move all clones to a new node, created
    as the last top-level node. Returns the newly-created node. Arguments:

    generator,      The generator used to traverse the tree.
    predicate,      A function of one argument p returning true if p should be included.
    failMsg=None,   Message given if nothing found. Default is no message.
    flatten=False,  True: Move all node to be parents of the root node.
    iconPath=None,  Full path to icon to attach to all matches.
    redraw=True,    True: redraw the screen.
    undo_type=None, The undo/redo name shown in the Edit:Undo menu.
                    The default is 'clone-find-predicate'
    """
    c = self
    u, undoType = c.undoer, undoType or 'clone-find-predicate'
    clones, root, seen = [], None, set()
    for p in generator():
        if predicate(p) and p.v not in seen:
            c.setCloneFindByPredicateIcon(iconPath, p)
            if flatten:
                seen.add(p.v)
            else:
                for p2 in p.self_and_subtree(copy=False):
                    seen.add(p2.v)
            clones.append(p.copy())
    if clones:
        undoData = u.beforeInsertNode(c.p)
        root = c.createCloneFindPredicateRoot(flatten, undoType)
        for p in clones:
            clone = p.clone()
            clone.moveToLastChildOf(root)
        u.afterInsertNode(root, undoType, undoData)
        if redraw:
            c.selectPosition(root)
            c.setChanged()
            c.contractAllHeadlines()
            root.expand()
            c.redraw()
            c.selectPosition(root)
    elif failMsg:
        g.es_print(failMsg, color='red')
    return root
#@+node:ekr.20160304054950.1: *8* c.setCloneFindByPredicateIcon
def setCloneFindByPredicateIcon(self, iconPath, p):
    """Attach an icon to p.v.u."""
    if iconPath and g.os_path_exists(iconPath) and not g.os_path_isdir(iconPath):
        aList = p.v.u.get('icons', [])
        for d in aList:
            if d.get('file') == iconPath:
                break
        else:
            aList.append({
                'type': 'file',
                'file': iconPath,
                'on': 'VNode',
                # 'relPath': iconPath,
                'where': 'beforeHeadline',
                'xoffset': 2, 'xpad': 1,
                'yoffset': 0,

            })
            p.v.u['icons'] = aList
    elif iconPath:
        g.trace('bad icon path', iconPath)
#@+node:ekr.20160201075438.1: *8* c.createCloneFindPredicateRoot
def createCloneFindPredicateRoot(self, flatten, undoType):
    """Create a root node for clone-find-predicate."""
    c = self
    root = c.lastTopLevel().insertAfter()
    root.h = undoType + (' (flattened)' if flatten else '')
    return root
#@+node:peckj.20131023115434.10114: *7* c.createNodeHierarchy
def createNodeHierarchy(self, heads, parent=None, forcecreate=False):
    """ Create the proper hierarchy of nodes with headlines defined in
        'heads' under 'parent'

        params:
        parent - parent node to start from.  Set to None for top-level nodes
        heads - list of headlines in order to create, i.e. ['foo','bar','baz']
                will create:
                  parent
                  -foo
                  --bar
                  ---baz
        forcecreate - If False (default), will not create nodes unless they don't exist
                      If True, will create nodes regardless of existing nodes
        returns the final position ('baz' in the above example)
    """
    u = self.undoer
    undoType = 'Create Node Hierarchy'
    undoType2 = 'Insert Node In Hierarchy'
    u_node = parent or self.rootPosition()
    undoData = u.beforeChangeGroup(u_node, undoType)
    changed_node = False
    for idx, head in enumerate(heads):
        if parent is None and idx == 0:  # if parent = None, create top level node for first head
            if not forcecreate:
                for pos in self.all_positions():
                    if pos.h == head:
                        parent = pos
                        break
            if parent is None or forcecreate:
                u_d = u.beforeInsertNode(u_node)
                n = self.rootPosition().insertAfter()
                n.h = head
                u.afterInsertNode(n, undoType2, u_d)
                parent = n
        else:  # else, simply create child nodes each round
            if not forcecreate:
                for ch in parent.children():
                    if ch.h == head:
                        parent = ch
                        changed_node = True
                        break
            if parent.h != head or not changed_node or forcecreate:
                u_d = u.beforeInsertNode(parent)
                n = parent.insertAsLastChild()
                n.h = head
                u.afterInsertNode(n, undoType2, u_d)
                parent = n
        changed_node = False
    u.afterChangeGroup(parent, undoType, undoData)
    return parent  # actually the last created/found position
#@+node:ekr.20100802121531.5804: *7* c.deletePositionsInList
def deletePositionsInList(self, aList, redraw=True):
    """
    Delete all vnodes corresponding to the positions in aList.

    See "Theory of operation of c.deletePositionsInList" in LeoDocs.leo.
    """
    # New implementation by Vitalije 2020-03-17 17:29 
    c = self
    # Ensure all positions are valid.
    aList = [p for p in aList if c.positionExists(p)]
    if not aList:
        return []

    def p2link(p):
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        return p._childIndex, parent_v

    links_to_be_cut = sorted(set(map(p2link, aList)), key=lambda x:-x[0])
    undodata = []
    for i, v in links_to_be_cut:
        ch = v.children.pop(i)
        ch.parents.remove(v)
        undodata.append((v.gnx, i, ch.gnx))
    if redraw:
        if not c.positionExists(c.p):
            c.setCurrentPosition(c.rootPosition())
        c.redraw()
    return undodata

#@+node:vitalije.20200318161844.1: *7* c.undoableDeletePositions
def undoableDeletePositions(self, aList):
    """
    Deletes all vnodes corresponding to the positions in aList,
    and make changes undoable.
    """
    c = self
    u = c.undoer
    data = c.deletePositionsInList(aList)
    gnx2v = c.fileCommands.gnxDict
    def undo():
        for pgnx, i, chgnx in reversed(u.getBead(u.bead).data):
            v = gnx2v[pgnx]
            ch = gnx2v[chgnx]
            v.children.insert(i, ch)
            ch.parents.append(v)
        if not c.positionExists(c.p):
            c.setCurrentPosition(c.rootPosition())
    def redo():
        for pgnx, i, chgnx in u.getBead(u.bead + 1).data:
            v = gnx2v[pgnx]
            ch = v.children.pop(i)
            ch.parents.remove(v)
        if not c.positionExists(c.p):
            c.setCurrentPosition(c.rootPosition())
    u.pushBead(g.Bunch(
        data=data,
        undoType='delete nodes',
        undoHelper=undo,
        redoHelper=redo,
    ))
#@+node:ekr.20091211111443.6265: *7* c.doBatchOperations & helpers
def doBatchOperations(self, aList=None):
    # Validate aList and create the parents dict
    if aList is None:
        aList = []
    ok, d = self.checkBatchOperationsList(aList)
    if not ok:
        g.error('do-batch-operations: invalid list argument')
        return
    for v in list(d.keys()):
        aList2 = d.get(v, [])
        if aList2:
            aList.sort()
#@+node:ekr.20091211111443.6266: *8* c.checkBatchOperationsList
def checkBatchOperationsList(self, aList):
    ok = True; d = {}
    for z in aList:
        try:
            op, p, n = z
            ok = (op in ('insert', 'delete') and
                isinstance(p, leoNodes.position) and isinstance(n, int))
            if ok:
                aList2 = d.get(p.v, [])
                data = n, op
                aList2.append(data)
                d[p.v] = aList2
        except ValueError:
            ok = False
        if not ok: break
    return ok, d
#@+node:ekr.20091002083910.6106: *7* c.find_b & find_h (PosList)
<< PosList doc >>
#@+node:bob.20101215134608.5898: *8* << PosList doc >>
@language rest
@
List of positions

Functions find_h() and find_b() both return an instance of PosList.

Methods filter_h() and filter_b() refine a PosList.

Method children() generates a new PosList by descending one level from
all the nodes in a PosList.

A chain of PosList method calls must begin with find_h() or find_b().
The rest of the chain can be any combination of filter_h(),
filter_b(), and children(). For example:

    pl = c.find_h('@file.*py').children().filter_h('class.*').filter_b('import (.*)')

For each position, pos, in the PosList returned, find_h() and
filter_h() set attribute pos.mo to the match object (see Python
Regular Expression documentation) for the pattern match.

Caution: The pattern given to find_h() or filter_h() must match zero
or more characters at the beginning of the headline.

For each position, pos, the postlist returned, find_b() and filter_b()
set attribute pos.matchiter to an iterator that will return a match
object for each of the non-overlapping matches of the pattern in the
body of the node.
#@+node:ville.20090311190405.70: *8* c.find_h
def find_h(self, regex, flags=re.IGNORECASE):
    """ Return list (a PosList) of all nodes where zero or more characters at
    the beginning of the headline match regex
    """
    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.PosList()
    for p in c.all_positions():
        m = re.match(pat, p.h)
        if m:
            pc = p.copy()
            pc.mo = m
            res.append(pc)
    return res
#@+node:ville.20090311200059.1: *8* c.find_b
def find_b(self, regex, flags=re.IGNORECASE | re.MULTILINE):
    """ Return list (a PosList) of all nodes whose body matches regex
    one or more times.

    """
    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.PosList()
    for p in c.all_positions():
        m = re.finditer(pat, p.b)
        t1, t2 = itertools.tee(m, 2)
        try:
            t1.__next__()
        except StopIteration:
            continue
        pc = p.copy()
        pc.matchiter = t2
        res.append(pc)
    return res
#@+node:ekr.20150410095543.1: *7* c.findNodeOutsideAnyAtFileTree
def findNodeOutsideAnyAtFileTree(self, target):
    """Select the first clone of target that is outside any @file node."""
    c = self
    if target.isCloned():
        v = target.v
        for p in c.all_positions():
            if p.v == v:
                for parent in p.self_and_parents(copy=False):
                    if parent.isAnyAtFileNode():
                        break
                else:
                    return p
    return target
#@+node:ekr.20171124155725.1: *6* c.Settings
#@+node:ekr.20171114114908.1: *7* c.registerReloadSettings
def registerReloadSettings(self, obj):
    """Enter object into c.configurables."""
    c = self
    if obj not in c.configurables:
        c.configurables.append(obj)
#@+node:ekr.20170221040621.1: *7* c.reloadConfigurableSettings
def reloadConfigurableSettings(self):
    """
    Call all reloadSettings method in c.subcommanders, c.configurables and
    other known classes.
    """
    c = self
    table = [
        g.app.gui,
        g.app.pluginsController,
        c.k.autoCompleter,
        c.frame, c.frame.body, c.frame.log, c.frame.tree,
        c.frame.body.colorizer,
        getattr(c.frame.body.colorizer, 'highlighter', None),
    ]
    for obj in table:
        if obj:
            c.registerReloadSettings(obj)
    c.configurables = list(set(c.configurables))
        # Useful now that instances add themselves to c.configurables.
    c.configurables.sort(key=lambda obj: obj.__class__.__name__.lower())
    for obj in c.configurables:
        func = getattr(obj, 'reloadSettings', None)
        if func:
            # pylint: disable=not-callable
            try:
                func()
            except Exception:
                g.es_exception()
                c.configurables.remove(obj)
#@+node:ekr.20031218072017.3093: *4* @file leoGlobals.py
@first # -*- coding: utf-8 -*-
"""
Global constants, variables and utility functions used throughout Leo.

Important: This module imports no other Leo module.
"""
import sys
isPython3 = sys.version_info >= (3, 0, 0)
minimum_python_version = '3.6'
    # #1215.
isMac = sys.platform.startswith('darwin')
isWindows = sys.platform.startswith('win')
<< global switches >>
<< imports >>
<< define g.globalDirectiveList >>
<< define global decorator dicts >>
<< define g.decorators >>
<< define regex's >>
tree_popup_handlers = []  # Set later.
user_dict = {}
    # Non-persistent dictionary for free use by scripts and plugins.
# g = None
app = None  # The singleton app object. Set by runLeo.py.
# Global status vars.
inScript = False  # A synonym for app.inScript
unitTesting = False  # A synonym for app.unitTesting.
@others
# set g when the import is about to complete.
g = sys.modules.get('leo.core.leoGlobals')
assert g, sorted(sys.modules.keys())

if __name__ == '__main__':
    unittest.main()
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20120212060348.10374: *5*  << global switches >> (leoGlobals.py)
in_bridge = False
    # Set to True in leoBridge.py just before importing leo.core.leoApp.
    # This tells leoApp to load a null Gui.
#@+node:ekr.20050208101229: *5* << imports >> (leoGlobals)
# This is now done in run.
    # import leo.core.leoGlobals as g # So code can use g below.
#
# Don't import leoTest here: it messes up Leo's startup code.
    # import leo.core.leoTest as leoTest
import binascii
import codecs
from functools import reduce
try:
    import gc
except ImportError:
    gc = None
try:
    import gettext
except ImportError:  # does not exist in jython.
    gettext = None
import glob
import io
StringIO = io.StringIO
import importlib
import inspect
import operator
import os
#
# Do NOT import pdb here!  We shall define pdb as a _function_ below.
    # import pdb
import re
import shlex
import shutil
import string
import subprocess
import tempfile
import time
import traceback
import types
import unittest
import urllib
import urllib.parse as urlparse
#@+node:EKR.20040610094819: *5* << define g.globalDirectiveList >>
# Visible externally so plugins may add to the list of directives.
globalDirectiveList = [
    # Order does not matter.
    'all',
    'beautify',
    'colorcache', 'code', 'color', 'comment', 'c',
    'delims', 'doc',
    'encoding', 'end_raw',
    'first', 'header', 'ignore',
    'killbeautify', 'killcolor',
    'language', 'last', 'lineending',
    'markup',
    'nobeautify',
    'nocolor-node', 'nocolor', 'noheader', 'nowrap',
    'nopyflakes',  # Leo 6.1.
    'nosearch',  # Leo 5.3.
    'others', 'pagewidth', 'path', 'quiet',
    'raw', 'root-code', 'root-doc', 'root', 'silent',
    'tabwidth', 'terse',
    'unit', 'verbose', 'wrap',
]
#@+node:ekr.20150510103918.1: *5* << define global decorator dicts >> (leoGlobals.py)
@nobeautify
@language rest
@
The cmd_instance_dict supports per-class @cmd decorators. For example, the
following appears in leo.commands.

    def cmd(name):
        """Command decorator for the abbrevCommands class."""
        return g.new_cmd_decorator(name, ['c', 'abbrevCommands',])

For commands based on functions, use the @g.command decorator.
@c
@language python

global_commands_dict = {}

cmd_instance_dict = {
    # Keys are class names, values are attribute chains.
    'AbbrevCommandsClass':      ['c', 'abbrevCommands'],
    'AtFile':                   ['c', 'atFileCommands'],
    'AutoCompleterClass':       ['c', 'k', 'autoCompleter'],
    'ChapterController':        ['c', 'chapterController'],
    'Commands':                 ['c'],
    'ControlCommandsClass':     ['c', 'controlCommands'],
    'DebugCommandsClass':       ['c', 'debugCommands'],
    'EditCommandsClass':        ['c', 'editCommands'],
    'EditFileCommandsClass':    ['c', 'editFileCommands'],
    'FileCommands':             ['c', 'fileCommands'],
    'HelpCommandsClass':        ['c', 'helpCommands'],
    'KeyHandlerClass':          ['c', 'k'],
    'KeyHandlerCommandsClass':  ['c', 'keyHandlerCommands'],
    'KillBufferCommandsClass':  ['c', 'killBufferCommands'],
    'LeoApp':                   ['g', 'app'],
    'LeoFind':                  ['c', 'findCommands'],
    'LeoImportCommands':        ['c', 'importCommands'],
    # 'MacroCommandsClass':       ['c', 'macroCommands'],
    'PrintingController':       ['c', 'printingController'],
    'RectangleCommandsClass':   ['c', 'rectangleCommands'],
    'RstCommands':              ['c', 'rstCommands'],
    'SpellCommandsClass':       ['c', 'spellCommands'],
    'Undoer':                   ['c', 'undoer'],
    'VimCommands':              ['c', 'vimCommands'],
}
#@+node:ekr.20150508165324.1: *5* << define g.Decorators >>
@others
#@+node:ekr.20170219173203.1: *6* g.callback
def callback(func):
    """
    A global decorator that protects Leo against crashes in callbacks.

    This is the recommended way of defining all callback.

        @g.callback
        def a_callback(...):
            c = event.get('c')
            ...
    """

    def callback_wrapper(*args, **keys):
        """Callback for the @g.callback decorator."""
        try:
            return func(*args, **keys)
        except Exception:
            g.es_exception()

    return callback_wrapper
#@+node:ekr.20150510104148.1: *6* g.check_cmd_instance_dict
def check_cmd_instance_dict(c, g):
    """
    Check g.check_cmd_instance_dict.
    This is a permanent unit test, called from c.finishCreate.
    """
    d = cmd_instance_dict
    for key in d:
        ivars = d.get(key)
        obj = ivars2instance(c, g, ivars)
            # Produces warnings.
        if obj:
            name = obj.__class__.__name__
            if name != key:
                g.trace('class mismatch', key, name)
#@+node:ville.20090521164644.5924: *6* g.command (decorator)
class Command:
    """
    A global decorator for creating commands.

    This is the recommended way of defining all new commands, including
    commands that could befined inside a class. The typical usage is:

        @g.command('command-name')
        def A_Command(event):
            c = event.get('c')
            ...

    g can *not* be used anywhere in this class!
    """

    def __init__(self, name, **kwargs):
        """Ctor for command decorator class."""
        self.name = name

    def __call__(self, func):
        """Register command for all future commanders."""
        global_commands_dict[self.name] = func
        if app:
            for c in app.commanders():
                c.k.registerCommand(self.name, func)
        # Inject ivars for plugins_menu.py.
        func.__func_name__ = func.__name__ # For leoInteg.
        func.is_command = True
        func.command_name = self.name
        return func

command = Command
#@+node:ekr.20171124070654.1: *6* g.command_alias
def command_alias(alias, func):
    """Create an alias for the *already defined* method in the Commands class."""
    import leo.core.leoCommands as leoCommands
    assert hasattr(leoCommands.Commands, func.__name__)
    funcToMethod(func, leoCommands.Commands, alias)
#@+node:ekr.20171123095526.1: *6* g.commander_command (decorator)
class CommanderCommand:
    """
    A global decorator for creating commander commands, that is, commands
    that were formerly methods of the Commands class in leoCommands.py.
    
    Usage:

        @g.command('command-name')
        def command_name(self, *args, **kwargs):
            ...
        
    The decorator injects command_name into the Commander class and calls
    funcToMethod so the ivar will be injected in all future commanders.

    g can *not* be used anywhere in this class!
    """

    def __init__(self, name, **kwargs):
        """Ctor for command decorator class."""
        self.name = name

    def __call__(self, func):
        """Register command for all future commanders."""

        def commander_command_wrapper(event):
            c = event.get('c')
            method = getattr(c, func.__name__, None)
            method(event=event)

        # Inject ivars for plugins_menu.py.
        commander_command_wrapper.__func_name__ = func.__name__ # For leoInteg.
        commander_command_wrapper.__name__ = self.name
        commander_command_wrapper.__doc__ = func.__doc__
        global_commands_dict[self.name] = commander_command_wrapper
        if app:
            import leo.core.leoCommands as leoCommands
            funcToMethod(func, leoCommands.Commands)
            for c in app.commanders():
                c.k.registerCommand(self.name, func)
        # Inject ivars for plugins_menu.py.
        func.is_command = True
        func.command_name = self.name
        return func

commander_command = CommanderCommand
#@+node:ekr.20150508164812.1: *6* g.ivars2instance
def ivars2instance(c, g, ivars):
    """
    Return the instance of c given by ivars.
    ivars is a list of strings.
    A special case: ivars may be 'g', indicating the leoGlobals module.
    """
    if not ivars:
        g.trace('can not happen: no ivars')
        return None
    ivar = ivars[0]
    if ivar not in ('c', 'g'):
        g.trace('can not happen: unknown base', ivar)
        return None
    obj = c if ivar == 'c' else g
    for ivar in ivars[1:]:
        obj = getattr(obj, ivar, None)
        if not obj:
            g.trace('can not happen: unknown attribute', obj, ivar, ivars)
            break
    return obj
#@+node:ekr.20150508134046.1: *6* g.new_cmd_decorator (decorator)
def new_cmd_decorator(name, ivars):
    """
    Return a new decorator for a command with the given name.
    Compute the class *instance* using the ivar string or list.
    
    Don't even think about removing the @cmd decorators!
    See https://github.com/leo-editor/leo-editor/issues/325
    """

    def _decorator(func):

        def new_cmd_wrapper(event):
            c = event.c
            self = g.ivars2instance(c, g, ivars)
            try:
                func(self, event=event)
                    # Don't use a keyword for self.
                    # This allows the VimCommands class to use vc instead.
            except Exception:
                g.es_exception()

        new_cmd_wrapper.__func_name__ = func.__name__ # For leoInteg.
        new_cmd_wrapper.__name__ = name
        new_cmd_wrapper.__doc__ = func.__doc__
        global_commands_dict[name] = new_cmd_wrapper
            # Put the *wrapper* into the global dict.
        return func
            # The decorator must return the func itself.

    return _decorator
#@+node:ekr.20200810093517.1: *5* << define regex's >>
g_language_pat = re.compile(r'^@language\s+(\w+)+', re.MULTILINE)
    # Regex used by this module, and in leoColorizer.py.
#
# Patterns used only in this module...
g_is_directive_pattern = re.compile(r'^\s*@([\w-]+)\s*')
    # This pattern excludes @encoding.whatever and @encoding(whatever)
    # It must allow @language python, @nocolor-node, etc.
g_noweb_root = re.compile('<' + '<' + '*' + '>' + '>' + '=', re.MULTILINE)
g_pos_pattern = re.compile(r':(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')
g_tabwidth_pat = re.compile(r'(^@tabwidth)', re.MULTILINE)
#@+node:ekr.20140711071454.17644: *5* g.Classes & class accessors
#@+node:ekr.20120123115816.10209: *6* class g.BindingInfo & isBindingInfo
class BindingInfo:
    """
    A class representing any kind of key binding line.

    This includes other information besides just the KeyStroke.
    """
    # Important: The startup code uses this class,
    # so it is convenient to define it in leoGlobals.py.
    @others
def isBindingInfo(obj):
    return isinstance(obj, BindingInfo)
#@+node:ekr.20120129040823.10254: *7* bi.__init__
def __init__(
    self,
    kind,
    commandName='',
    func=None,
    nextMode=None,
    pane=None,
    stroke=None,
):
    if not g.isStrokeOrNone(stroke):
        g.trace('***** (BindingInfo) oops', repr(stroke))
    self.kind = kind
    self.commandName = commandName
    self.func = func
    self.nextMode = nextMode
    self.pane = pane
    self.stroke = stroke
        # The *caller* must canonicalize the shortcut.
#@+node:ekr.20120203153754.10031: *7* bi.__hash__
def __hash__(self):
    return self.stroke.__hash__() if self.stroke else 0
#@+node:ekr.20120125045244.10188: *7* bi.__repr__ & ___str_& dump
def __repr__(self):
    return self.dump()

__str__ = __repr__

def dump(self):
    result = [f"BindingInfo {self.kind:17}"]
    # Print all existing ivars.
    table = ('commandName', 'func', 'nextMode', 'pane', 'stroke')
    for ivar in table:
        if hasattr(self, ivar):
            val = getattr(self, ivar)
            if val not in (None, 'none', 'None', ''):
                if ivar == 'func':
                    # pylint: disable=no-member
                    val = val.__name__
                s = f"{ivar}: {val!r}"
                result.append(s)
    # Clearer w/o f-string.
    return f"[%s]" % ' '.join(result).strip()
#@+node:ekr.20120129040823.10226: *7* bi.isModeBinding
def isModeBinding(self):
    return self.kind.startswith('*mode')
#@+node:ekr.20031218072017.3098: *6* class g.Bunch (Python Cookbook)
@language rest
@
From The Python Cookbook:

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others,
del some of them, etc::

    if point.squared > threshold:
        point.isok = True
@c
@language python


class Bunch:
    """A class that represents a colection of things.

    Especially useful for representing a collection of related variables."""

    def __init__(self, **keywords):
        self.__dict__.update(keywords)

    def __repr__(self):
        return self.toString()

    def ivars(self):
        return sorted(self.__dict__)

    def keys(self):
        return sorted(self.__dict__)

    def toString(self):
        tag = self.__dict__.get('tag')
        entries = [
            f"{key}: {str(self.__dict__.get(key)) or repr(self.__dict__.get(key))}"
                for key in self.ivars() if key != 'tag'
        ]
        # Fail.
        result = [f'g.Bunch({tag or ""})']
        result.extend(entries)
        return '\n    '.join(result) + '\n'

    # Used by new undo code.

    def __setitem__(self, key, value):
        """Support aBunch[key] = val"""
        return operator.setitem(self.__dict__, key, value)

    def __getitem__(self, key):
        """Support aBunch[key]"""
        # g.pr('g.Bunch.__getitem__', key)
        return operator.getitem(self.__dict__, key)

    def get(self, key, theDefault=None):
        return self.__dict__.get(key, theDefault)

    def __contains__(self, key):  # New.
        # g.pr('g.Bunch.__contains__', key in self.__dict__, key)
        return key in self.__dict__

bunch = Bunch
#@+node:ekr.20120219154958.10492: *6* class g.EmergencyDialog
class EmergencyDialog:
    """A class that creates an tkinter dialog with a single OK button."""
    @others
#@+node:ekr.20120219154958.10493: *7* emergencyDialog.__init__
def __init__(self, title, message):
    """Constructor for the leoTkinterDialog class."""
    self.answer = None  # Value returned from run()
    self.title = title
    self.message = message
    self.buttonsFrame = None  # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None
        # Command to call when user closes the window
        # by clicking the close box.
    self.frame = None  # The outermost frame.
    self.root = None  # Created in createTopFrame.
    self.top = None  # The toplevel Tk widget.
    self.createTopFrame()
    buttons = [{
        "text": "OK",
        "command": self.okButton,
        "default": True,
    }]
    self.createButtons(buttons)
    self.top.bind("<Key>", self.onKey)
#@+node:ekr.20120219154958.10494: *7* emergencyDialog.createButtons
def createButtons(self, buttons):
    """Create a row of buttons.

    buttons is a list of dictionaries containing
    the properties of each button.
    """
    import tkinter as Tk
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top", padx=30)
    # Buttons is a list of dictionaries, with an empty dictionary
    # at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text", "<missing button name>")
        isDefault = d.get("default", False)
        underline = d.get("underline", 0)
        command = d.get("command", None)
        bd = 4 if isDefault else 2
        b = Tk.Button(f, width=6, text=text, bd=bd,
            underline=underline, command=command)
        b.pack(side="left", padx=5, pady=10)
        buttonList.append(b)
        if isDefault and command:
            self.defaultButtonCommand = command
    return buttonList
#@+node:ekr.20120219154958.10495: *7* emergencyDialog.createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    import tkinter as Tk
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=self.message, bg='white')
    label.pack(pady=10)
#@+node:ekr.20120219154958.10496: *7* emergencyDialog.okButton
def okButton(self):
    """Do default click action in ok button."""
    self.top.destroy()
    self.top = None
#@+node:ekr.20120219154958.10497: *7* emergencyDialog.onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    self.okButton()
#@+node:ekr.20120219154958.10498: *7* emergencyDialog.run
def run(self):
    """Run the modal emergency dialog."""
    # Suppress f-stringify.
    self.top.geometry(f"%dx%d%+d%+d" % (300, 200, 50, 50))
    self.top.lift()
    self.top.grab_set()  # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
#@+node:ekr.20040331083824.1: *6* class g.FileLikeObject
# Note: we could use StringIo for this.


class FileLikeObject:
    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""
    @others
fileLikeObject = FileLikeObject
    # For compatibility.
#@+node:ekr.20050404151753: *7*  ctor (g.FileLikeObject)
def __init__(self, encoding='utf-8', fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    self.encoding = encoding or 'utf-8'
    if fromString:
        self.list = g.splitLines(fromString)  # Must preserve newlines!
    else:
        self.list = []
    self.ptr = 0
# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@+node:ekr.20050404151753.1: *7* clear (g.FileLikeObject)
def clear(self):
    self.list = []
#@+node:ekr.20050404151753.2: *7* close (g.FileLikeObject)
def close(self):
    pass
    # The StringIo version free's the memory buffer.
#@+node:ekr.20050404151753.3: *7* flush (g.FileLikeObject)
def flush(self):
    pass
#@+node:ekr.20050404151753.4: *7* get & getvalue & read (g.FileLikeObject)
def get(self):
    return ''.join(self.list)

getvalue = get  # for compatibility with StringIo
read = get  # for use by sax.
#@+node:ekr.20050404151753.5: *7* readline (g.FileLikeObject)
def readline(self):
    """Read the next line using at.list and at.ptr."""
    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        self.ptr += 1
        return line
    return ''
#@+node:ekr.20050404151753.6: *7* write (g.FileLikeObject)
def write(self, s):
    if s:
        if isinstance(s, bytes):
            s = g.toUnicode(s, self.encoding)
        self.list.append(s)
#@+node:ekr.20120123143207.10223: *6* class g.GeneralSetting
# Important: The startup code uses this class,
# so it is convenient to define it in leoGlobals.py.


class GeneralSetting:
    """A class representing any kind of setting except shortcuts."""

    def __init__(self, kind,
        encoding=None,
        ivar=None,
        setting=None,
        val=None,
        path=None,
        tag='setting',
        unl=None,
    ):
        self.encoding = encoding
        self.ivar = ivar
        self.kind = kind
        self.path = path
        self.unl = unl
        self.setting = setting
        self.val = val
        self.tag = tag

    def __repr__(self):
        # Better for g.printObj.
        val = str(self.val).replace('\n', ' ')
        return (
            f"GS: {g.shortFileName(self.path):20} "
            f"{self.kind:7} = {g.truncate(val, 50)}")

    dump = __repr__
    __str__ = __repr__
#@+node:ekr.20120201164453.10090: *6* class g.KeyStroke & isStroke/OrNone
class KeyStroke:
    """
    A class that represent any key stroke or binding.
    
    stroke.s is the "canonicalized" stroke.
    """
    @others

def isStroke(obj):
    return isinstance(obj, KeyStroke)

def isStrokeOrNone(obj):
    return obj is None or isinstance(obj, KeyStroke)
#@+node:ekr.20180414195401.2: *7*  ks.__init__
def __init__(self, binding):

    if binding:
        self.s = self.finalize_binding(binding)
    else:
        self.s = None
#@+node:ekr.20120203053243.10117: *7* ks.__eq__, etc
@ All these must be defined in order to say, for example:
    for key in sorted(d)
where the keys of d are KeyStroke objects.
@c

def __eq__(self, other):
    if not other:
        return False
    if hasattr(other, 's'):
        return self.s == other.s
    return self.s == other

def __lt__(self, other):
    if not other:
        return False
    if hasattr(other, 's'):
        return self.s < other.s
    return self.s < other

def __le__(self, other): return self.__lt__(other) or self.__eq__(other)

def __ne__(self, other): return not self.__eq__(other)

def __gt__(self, other): return not self.__lt__(other) and not self.__eq__(other)

def __ge__(self, other): return not self.__lt__(other)
#@+node:ekr.20120203053243.10118: *7* ks.__hash__
# Allow KeyStroke objects to be keys in dictionaries.

def __hash__(self):
    return self.s.__hash__() if self.s else 0
#@+node:ekr.20120204061120.10067: *7* ks.__repr___ & __str__
def __str__(self):
    return f"<KeyStroke: {repr(self.s)}>"

__repr__ = __str__
#@+node:ekr.20180417160703.1: *7* ks.dump
def dump(self):
    """Show results of printable chars."""
    for i in range(128):
        s = chr(i)
        stroke = g.KeyStroke(s)
        if stroke.s != s:
            print(f"{i:2} {s!r:10} {stroke.s!r}")
    for ch in ('backspace', 'linefeed', 'return', 'tab'):
        stroke = g.KeyStroke(ch)
        print(f'{"":2} {ch!r:10} {stroke.s!r}')
#@+node:ekr.20180415082249.1: *7* ks.finalize_binding
def finalize_binding(self, binding):

    trace = False and 'keys' in g.app.debug
        # This trace is good for devs only.
    self.mods = self.find_mods(binding)
    s = self.strip_mods(binding)
    s = self.finalize_char(s)
        # May change self.mods.
    mods = ''.join([f"{z.capitalize()}+" for z in self.mods])
    if trace and 'meta' in self.mods:
        g.trace(f"{binding:20}:{self.mods:>20} ==> {mods+s}")
    return mods + s
#@+node:ekr.20180415083926.1: *7* ks.finalize_char & helper
def finalize_char(self, s):
    """Perform very-last-minute translations on bindings."""
    #
    # Retain "bigger" spelling for gang-of-four bindings with modifiers.
    shift_d = {
        'bksp': 'BackSpace',
        'backspace': 'BackSpace',
        'backtab': 'Tab',  # The shift mod will convert to 'Shift+Tab',
        'linefeed': 'Return',
        '\r': 'Return',
        'return': 'Return',
        'tab': 'Tab',
    }
    if self.mods and s.lower() in shift_d:
        return shift_d.get(s.lower())
            # Returning '' breaks existing code.
    #
    # Make all other translations...
    #
    # This dict ensures proper capitalization.
    # It also translates legacy Tk binding names to ascii chars.
    translate_d = {
        #
        # The gang of four...
        'bksp': 'BackSpace',
        'backspace': 'BackSpace',
        'backtab': 'Tab',  # The shift mod will convert to 'Shift+Tab',
        'linefeed': '\n',
        '\r': '\n',
        'return': '\n',
        'tab': 'Tab',
        #
        # Special chars...
        'delete': 'Delete',
        'down': 'Down',
        'end': 'End',
        'enter': 'Enter',
        'escape': 'Escape',
        'home': 'Home',
        'insert': 'Insert',
        'left': 'Left',
        'next': 'Next',
        'prior': 'Prior',
        'right': 'Right',
        'up': 'Up',
        #
        # Qt key names...
        'del': 'Delete',
        'dnarrow': 'Down',
        'esc': 'Escape',
        'ins': 'Insert',
        'ltarrow': 'Left',
        'pagedn': 'Next',
        'pageup': 'Prior',
        'pgdown': 'Next',
        'pgup': 'Prior',
        'rtarrow': 'Right',
        'uparrow': 'Up',
        #
        # Legacy Tk binding names...
        "ampersand": "&",
        "asciicircum": "^",
        "asciitilde": "~",
        "asterisk": "*",
        "at": "@",
        "backslash": "\\",
        "bar": "|",
        "braceleft": "{",
        "braceright": "}",
        "bracketleft": "[",
        "bracketright": "]",
        "colon": ":",
        "comma": ",",
        "dollar": "$",
        "equal": "=",
        "exclam": "!",
        "greater": ">",
        "less": "<",
        "minus": "-",
        "numbersign": "#",
        "quotedbl": '"',
        "quoteright": "'",
        "parenleft": "(",
        "parenright": ")",
        "percent": "%",
        "period": ".",
        "plus": "+",
        "question": "?",
        "quoteleft": "`",
        "semicolon": ";",
        "slash": "/",
        "space": " ",
        "underscore": "_",
    }
    #
    # pylint: disable=undefined-loop-variable
        # Looks like a pylint bug.
    if s in (None, 'none', 'None'):
        return 'None'
    if s.lower() in translate_d:
        s = translate_d.get(s.lower())
        return self.strip_shift(s)
    if len(s) > 1 and s.find(' ') > -1:
        # #917: not a pure, but should be ignored.
        return ''
    if s.isalpha():
        if len(s) == 1:
            if 'shift' in self.mods:
                if len(self.mods) == 1:
                    self.mods.remove('shift')
                    s = s.upper()
                else:
                    s = s.lower()
            elif self.mods:
                s = s.lower()
        else:
            # 917: Ignore multi-byte alphas not in the table.
            s = ''
            if 0:
                # Make sure all special chars are in translate_d.
                if g.app.gui:  # It may not exist yet.
                    if s.capitalize() in g.app.gui.specialChars:
                        s = s.capitalize()
        return s
    #
    # Translate shifted keys to their appropriate alternatives.
    return self.strip_shift(s)
#@+node:ekr.20180502104829.1: *8* ks.strip_shift
def strip_shift(self, s):
    """
    Handle supposedly shifted keys.
    
    User settings might specify an already-shifted key, which is not an error.
        
    The legacy Tk binding names have already been translated,
    so we don't have to worry about Shift-ampersand, etc.
    """
    #
    # The second entry in each line handles shifting an already-shifted character.
    # That's ok in user settings: the Shift modifier is just removed.
    shift_d = {
        # Top row of keyboard.
        "`": "~", "~": "~",
        "1": "!", "!": "!",
        "2": "@", "@": "@",
        "3": "#", "#": "#",
        "4": "$", "$": "$",
        "5": "%", "%": "%",
        "6": "^", "^": "^",
        "7": "&", "&": "&",
        "8": "*", "*": "*",
        "9": "(", "(": "(",
        "0": ")", ")": ")",
        "-": "_", "_": "_",
        "=": "+", "+": "+",
        # Second row of keyboard.
        "[": "{", "{": "{",
        "]": "}", "}": "}",
        "\\": '|', "|": "|",
        # Third row of keyboard.
        ";": ":", ":": ":",
        "'": '"', '"': '"',
        # Fourth row of keyboard.
        ".": "<", "<": "<",
        ",": ">", ">": ">",
        "//": "?", "?": "?",
    }
    if 'shift' in self.mods and s in shift_d:
        self.mods.remove('shift')
        s = shift_d.get(s)
    return s
#@+node:ekr.20120203053243.10124: *7* ks.find, lower & startswith
# These may go away later, but for now they make conversion of string strokes easier.

def find(self, pattern):
    return self.s.find(pattern)

def lower(self):
    return self.s.lower()

def startswith(self, s):
    return self.s.startswith(s)
#@+node:ekr.20180415081209.2: *7* ks.find_mods
def find_mods(self, s):
    """Return the list of all modifiers seen in s."""
    s = s.lower()
    table = (
        ['alt',],
        ['command', 'cmd',],
        ['ctrl', 'control',],  # Use ctrl, not control.
        ['meta',],
        ['shift', 'shft',],
        ['keypad', 'key_pad', 'numpad', 'num_pad'],
            # 868: Allow alternative spellings.
    )
    result = []
    for aList in table:
        kind = aList[0]
        for mod in aList:
            for suffix in '+-':
                if s.find(mod + suffix) > -1:
                    s = s.replace(mod + suffix, '')
                    result.append(kind)
                    break
    return result
#@+node:ekr.20180417101435.1: *7* ks.isAltCtl
def isAltCtrl(self):
    """Return True if this is an Alt-Ctrl character."""
    mods = self.find_mods(self.s)
    return 'alt' in mods and 'ctrl' in mods
#@+node:ekr.20120203053243.10121: *7* ks.isFKey
def isFKey(self):
    return self.s in g.app.gui.FKeys
#@+node:ekr.20180417102341.1: *7* ks.isPlainKey (does not handle alt-ctrl chars)
def isPlainKey(self):
    """
    Return True if self.s represents a plain key.
    
    A plain key is a key that can be inserted into text.
    
    **Note**: The caller is responsible for handling Alt-Ctrl keys.
    """
    s = self.s
    if s in g.app.gui.ignoreChars:
        # For unit tests.
        return False
    # #868:
    if s.find('Keypad+') > -1:
        # Enable bindings.
        return False
    if self.find_mods(s) or self.isFKey():
        return False
    if s in g.app.gui.specialChars:
        return False
    if s == 'BackSpace':
        return False
    return True
#@+node:ekr.20180511092713.1: *7* ks.isNumPadKey, ks.isPlainNumPad & ks.removeNumPadModifier
def isNumPadKey(self):
    return self.s.find('Keypad+') > -1

def isPlainNumPad(self):
    return (
        self.isNumPadKey() and
        len(self.s.replace('Keypad+', '')) == 1
    )

def removeNumPadModifier(self):

    self.s = self.s.replace('Keypad+', '')
#@+node:ekr.20180419170934.1: *7* ks.prettyPrint
def prettyPrint(self):

    s = self.s
    if not s:
        return '<None>'
    d = {' ': 'Space', '\t': 'Tab', '\n': 'Return', '\r': 'LineFeed'}
    ch = s[-1]
    return s[:-1] + d.get(ch, ch)
#@+node:ekr.20180415124853.1: *7* ks.strip_mods
def strip_mods(self, s):
    """Remove all modifiers from s, without changing the case of s."""
    table = (
        'alt',
        'cmd', 'command',
        'control', 'ctrl',
        'keypad', 'key_pad',  # 868:
        'meta',
        'shift', 'shft',
    )
    for mod in table:
        for suffix in '+-':
            target = mod + suffix
            i = s.lower().find(target)
            if i > -1:
                s = s[:i] + s[i + len(target) :]
                break
    return s
#@+node:ekr.20120203053243.10125: *7* ks.toGuiChar
def toGuiChar(self):
    """Replace special chars by the actual gui char."""
    # pylint: disable=undefined-loop-variable
    # looks like a pylint bug
    s = self.s.lower()
    if s in ('\n', 'return'): s = '\n'
    elif s in ('\t', 'tab'): s = '\t'
    elif s in ('\b', 'backspace'): s = '\b'
    elif s in ('.', 'period'): s = '.'
    return s
#@+node:ekr.20180417100834.1: *7* ks.toInsertableChar
def toInsertableChar(self):
    """Convert self to an (insertable) char."""
    # pylint: disable=len-as-condition
    s = self.s
    if not s or self.find_mods(s):
        return ''
    # Handle the "Gang of Four"
    d = {
        'BackSpace': '\b',
        'LineFeed': '\n',
        # 'Insert': '\n',
        'Return': '\n',
        'Tab': '\t',
    }
    if s in d:
        return d.get(s)
    return s if len(s) == 1 else ''
#@+node:ekr.20160119093947.1: *6* class g.MatchBrackets
class MatchBrackets:
    """
    A class implementing the match-brackets command.
    
    In the interest of speed, the code assumes that the user invokes the
    match-bracket command ouside of any string, comment or (for perl or
    javascript) regex.
    """
    @others
#@+node:ekr.20160119104510.1: *7* mb.ctor
def __init__(self, c, p, language):
    """Ctor for MatchBrackets class."""
    self.c = c
    self.p = p.copy()
    self.language = language
    # Constants.
    self.close_brackets = ")]}>"
    self.open_brackets = "([{<"
    self.brackets = self.open_brackets + self.close_brackets
    self.matching_brackets = self.close_brackets + self.open_brackets
    # Language dependent.
    d1, d2, d3 = g.set_delims_from_language(language)
    self.single_comment, self.start_comment, self.end_comment = d1, d2, d3
    # to track expanding selection
    c.user_dict.setdefault('_match_brackets', {'count': 0, 'range': (0, 0)})
#@+node:ekr.20160121164723.1: *7* mb.bi-directional helpers
#@+node:ekr.20160121112812.1: *8* mb.is_regex
def is_regex(self, s, i):
    """Return true if there is another slash on the line."""
    if self.language in ('javascript', 'perl',):
        assert s[i] == '/'
        offset = 1 if self.forward else -1
        i += offset
        while 0 <= i < len(s) and s[i] != '\n':
            if s[i] == '/':
                return True
            i += offset
        return False
    return False
#@+node:ekr.20160121112536.1: *8* mb.scan_regex
def scan_regex(self, s, i):
    """Scan a regex (or regex substitution for perl)."""
    assert s[i] == '/'
    offset = 1 if self.forward else -1
    i1 = i
    i += offset
    found = False
    while 0 <= i < len(s) and s[i] != '\n':
        ch = s[i]
        i2 = i - 1  # in case we have to look behind.
        i += offset
        if ch == '/':
            # Count the preceding backslashes.
            n = 0
            while 0 <= i2 < len(s) and s[i2] == '\\':
                n += 1
                i2 -= 1
            if (n % 2) == 0:
                if self.language == 'perl' and found is None:
                    found = i
                else:
                    found = i
                    break
    if found is None:
        self.oops('unmatched regex delim')
        return i1 + offset
    return found
#@+node:ekr.20160121112303.1: *8* mb.scan_string
def scan_string(self, s, i):
    """
    Scan the string starting at s[i] (forward or backward).
    Return the index of the next character.
    """
    # i1 = i if self.forward else i + 1
    delim = s[i]
    assert delim in "'\"", repr(delim)
    offset = 1 if self.forward else -1
    i += offset
    while 0 <= i < len(s):
        ch = s[i]
        i2 = i - 1  # in case we have to look behind.
        i += offset
        if ch == delim:
            # Count the preceding backslashes.
            n = 0
            while 0 <= i2 < len(s) and s[i2] == '\\':
                n += 1
                i2 -= 1
            if (n % 2) == 0:
                return i
    # Annoying when matching brackets on the fly.
        # self.oops('unmatched string')
    return i + offset
#@+node:tbrown.20180226113621.1: *7* mb.expand_range
def expand_range(self, s, left, right, max_right, expand=False):
    """
    Find the bracket nearest the cursor searching outwards left and right.

    Expand the range (left, right) in string s until either s[left] or
    s[right] is a bracket.  right can not exceed max_right, and if expand is
    True, the new range must encompass the old range, in addition to s[left]
    or s[right] being a bracket.

    Returns
        new_left, new_right, bracket_char, index_of_bracket_char
    if expansion succeeds, otherwise
        None, None, None, None

    Note that only one of new_left and new_right will necessarily be a
    bracket, but index_of_bracket_char will definitely be a bracket.
    """
    expanded = False
    orig_left = left
    orig_right = right
    while (
        (s[left] not in self.brackets or expand and not expanded)
        and (s[right] not in self.brackets or expand and not expanded)
        and (left > 0 or right < max_right)
    ):
        expanded = False
        if left > 0:
            left -= 1
            if s[left] in self.brackets:
                other = self.find_matching_bracket(s[left], s, left)
                if other is not None and other >= orig_right:
                    expanded = 'left'
        if right < max_right:
            right += 1
            if s[right] in self.brackets:
                other = self.find_matching_bracket(s[right], s, right)
                if other is not None and other <= orig_left:
                    expanded = 'right'
    if s[left] in self.brackets and (not expand or expanded == 'left'):
        return left, right, s[left], left
    if s[right] in self.brackets and (not expand or expanded == 'right'):
        return left, right, s[right], right
    return None, None, None, None
#@+node:ekr.20061113221414: *7* mb.find_matching_bracket
def find_matching_bracket(self, ch1, s, i):
    """Find the bracket matching s[i] for self.language."""
    self.forward = ch1 in self.open_brackets
    # Find the character matching the initial bracket.
    for n in range(len(self.brackets)):
        if ch1 == self.brackets[n]:
            target = self.matching_brackets[n]
            break
    else:
        return None
    f = self.scan if self.forward else self.scan_back
    return f(ch1, target, s, i)
#@+node:ekr.20160121164556.1: *7* mb.scan & helpers
def scan(self, ch1, target, s, i):
    """Scan forward for target."""
    level = 0
    while 0 <= i < len(s):
        progress = i
        ch = s[i]
        if ch in '"\'':
            # Scan to the end/beginning of the string.
            i = self.scan_string(s, i)
        elif self.starts_comment(s, i):
            i = self.scan_comment(s, i)
        elif ch == '/' and self.is_regex(s, i):
            i = self.scan_regex(s, i)
        elif ch == ch1:
            level += 1
            i += 1
        elif ch == target:
            level -= 1
            if level <= 0:
                return i
            i += 1
        else:
            i += 1
        assert i > progress
    # Not found
    return None
#@+node:ekr.20160119090634.1: *8* mb.scan_comment
def scan_comment(self, s, i):
    """Return the index of the character after a comment."""
    i1 = i
    start = self.start_comment if self.forward else self.end_comment
    end = self.end_comment if self.forward else self.start_comment
    offset = 1 if self.forward else -1
    if g.match(s, i, start):
        if not self.forward:
            i1 += len(end)
        i += offset
        while 0 <= i < len(s):
            if g.match(s, i, end):
                i = i + len(end) if self.forward else i - 1
                return i
            i += offset
        self.oops('unmatched multiline comment')
    elif self.forward:
        # Scan to the newline.
        target = '\n'
        while 0 <= i < len(s):
            if s[i] == '\n':
                i += 1
                return i
            i += 1
    else:
        # Careful: scan to the *first* target on the line
        target = self.single_comment
        found = None
        i -= 1
        while 0 <= i < len(s) and s[i] != '\n':
            if g.match(s, i, target):
                found = i
            i -= 1
        if found is None:
            self.oops('can not happen: unterminated single-line comment')
            found = 0
        return found
    return i
#@+node:ekr.20160119101851.1: *8* mb.starts_comment
def starts_comment(self, s, i):
    """Return True if s[i] starts a comment."""
    assert 0 <= i < len(s)
    if self.forward:
        if self.single_comment and g.match(s, i, self.single_comment):
            return True
        return (
            self.start_comment and self.end_comment and
            g.match(s, i, self.start_comment)
        )
    if s[i] == '\n':
        if self.single_comment:
            # Scan backward for any single-comment delim.
            i -= 1
            while i >= 0 and s[i] != '\n':
                if g.match(s, i, self.single_comment):
                    return True
                i -= 1
        return False
    return (
        self.start_comment and self.end_comment and
        g.match(s, i, self.end_comment)
    )
#@+node:ekr.20160119230141.1: *7* mb.scan_back & helpers
def scan_back(self, ch1, target, s, i):
    """Scan backwards for delim."""
    level = 0
    while i >= 0:
        progress = i
        ch = s[i]
        if self.ends_comment(s, i):
            i = self.back_scan_comment(s, i)
        elif ch in '"\'':
            # Scan to the beginning of the string.
            i = self.scan_string(s, i)
        elif ch == '/' and self.is_regex(s, i):
            i = self.scan_regex(s, i)
        elif ch == ch1:
            level += 1
            i -= 1
        elif ch == target:
            level -= 1
            if level <= 0:
                return i
            i -= 1
        else:
            i -= 1
        assert i < progress
    # Not found
    return None
#@+node:ekr.20160119230141.2: *8* mb.back_scan_comment
def back_scan_comment(self, s, i):
    """Return the index of the character after a comment."""
    i1 = i
    if g.match(s, i, self.end_comment):
        i1 += len(self.end_comment)  # For traces.
        i -= 1
        while i >= 0:
            if g.match(s, i, self.start_comment):
                i -= 1
                return i
            i -= 1
        self.oops('unmatched multiline comment')
        return i
    # Careful: scan to the *first* target on the line
    found = None
    i -= 1
    while i >= 0 and s[i] != '\n':
        if g.match(s, i, self.single_comment):
            found = i - 1
        i -= 1
    if found is None:
        self.oops('can not happen: unterminated single-line comment')
        found = 0
    return found
#@+node:ekr.20160119230141.4: *8* mb.ends_comment
def ends_comment(self, s, i):
    """
    Return True if s[i] ends a comment. This is called while scanning
    backward, so this is a bit of a guess.
    """
    if s[i] == '\n':
        # This is the hard (dubious) case.
        # Let w, x, y and z stand for any strings not containg // or quotes.
        # Case 1: w"x//y"z Assume // is inside a string.
        # Case 2: x//y"z Assume " is inside the comment.
        # Case 3: w//x"y"z Assume both quotes are inside the comment.
        #
        # That is, we assume (perhaps wrongly) that a quote terminates a
        # string if and *only* if the string starts *and* ends on the line.
        if self.single_comment:
            # Scan backward for single-line comment delims or quotes.
            quote = None
            i -= 1
            while i >= 0 and s[i] != '\n':
                progress = i
                if quote and s[i] == quote:
                    quote = None
                    i -= 1
                elif s[i] in '"\'':
                    if not quote:
                        quote = s[i]
                    i -= 1
                elif g.match(s, i, self.single_comment):
                    # Assume that there is a comment only if the comment delim
                    # isn't inside a string that begins and ends on *this* line.
                    if quote:
                        while i >= 0 and s[i] != 'n':
                            if s[i] == quote:
                                return False
                            i -= 1
                    return True
                else:
                    i -= 1
                assert progress > i
        return False
    return (
        self.start_comment and
        self.end_comment and
        g.match(s, i, self.end_comment))
#@+node:ekr.20160119104148.1: *7* mb.oops
def oops(self, s):
    """Report an error in the match-brackets command."""
    g.es(s, color='red')
#@+node:ekr.20160119094053.1: *7* mb.run
@nobeautify

def run(self):
    """The driver for the MatchBrackets class.

    With no selected range: find the nearest bracket and select from
    it to it's match, moving cursor to mathc.
    
    With selected range: the first time, move cursor back to other end of
    range. The second time, select enclosing range.
    """
    #
    # A partial fix for bug 127: Bracket matching is buggy.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    _mb = self.c.user_dict['_match_brackets']
    sel_range = w.getSelectionRange()
    if not w.hasSelection():
        _mb['count'] = 1
    if _mb['range'] == sel_range and _mb['count'] == 1:
        # haven't been to other end yet
        _mb['count'] += 1
        # move insert point to other end of selection
        insert = 1 if w.getInsertPoint() == sel_range[0] else 0
        w.setSelectionRange(
            sel_range[0], sel_range[1], insert=sel_range[insert])
        return

    # Find the bracket nearest the cursor.
    max_right = len(s) - 1 # insert point can be past last char.
    left = right = min(max_right, w.getInsertPoint())
    left, right, ch, index = self.expand_range(s, left, right, max_right)
    if left is None:
        g.es("Bracket not found")
        return
    index2 = self.find_matching_bracket(ch, s, index)
    if index2 is None:
        g.es("No matching bracket.")  # #1447.
        return

    # If this is the first time we've selected the range index-index2, do
    # nothing extra.  The second time, move cursor to other end (requires
    # no special action here), and the third time, try to expand the range
    # to any enclosing brackets
    minmax = (min(index, index2), max(index, index2)+1)
    # the range, +1 to match w.getSelectionRange()
    if _mb['range'] == minmax:  # count how many times this has been the answer
        _mb['count'] += 1
    else:
        _mb['count'] = 1
        _mb['range'] = minmax
    if _mb['count'] >= 3:  # try to expand range
        left, right, ch, index3 = self.expand_range(
            s,
            max(minmax[0], 0),
            min(minmax[1], max_right),
            max_right, expand=True
        )
        if index3 is not None:  # found nearest bracket outside range
            index4 = self.find_matching_bracket(ch, s, index3)
            if index4 is not None:  # found matching bracket, expand range
                index, index2 = index3, index4
                _mb['count'] = 1
                _mb['range'] = (min(index3, index4), max(index3, index4)+1)

    if index2 is not None:
        if index2 < index:
            w.setSelectionRange(index2, index + 1, insert=index2)
        else:
            w.setSelectionRange(
                index, index2 + 1, insert=min(len(s), index2 + 1))
        w.see(index2)
    else:
        g.es("unmatched", repr(ch))
#@+node:ekr.20090128083459.82: *6* class g.PosList (deprecated)
class PosList(list):
    << docstring for PosList >>
    @others
#@+node:ekr.20090130114732.2: *7* << docstring for PosList >>
"""A subclass of list for creating and selecting lists of positions.

    This is deprecated, use leoNodes.PosList instead!

    aList = g.PosList(c)
        # Creates a PosList containing all positions in c.

    aList = g.PosList(c,aList2)
        # Creates a PosList from aList2.

    aList2 = aList.select(pattern,regex=False,removeClones=True)
        # Creates a PosList containing all positions p in aList
        # such that p.h matches the pattern.
        # The pattern is a regular expression if regex is True.
        # if removeClones is True, all positions p2 are removed
        # if a position p is already in the list and p2.v == p.v.

    aList.dump(sort=False,verbose=False)
        # Prints all positions in aList, sorted if sort is True.
        # Prints p.h, or repr(p) if verbose is True.
"""
#@+node:ekr.20140531104908.17611: *7* PosList.ctor
def __init__(self, c, aList=None):
    self.c = c
    super().__init__()
    if aList is None:
        for p in c.all_positions():
            self.append(p.copy())
    else:
        for p in aList:
            self.append(p.copy())
#@+node:ekr.20140531104908.17612: *7* PosList.dump
def dump(self, sort=False, verbose=False):
    if verbose:
        return g.listToString(self, sort=sort)
    return g.listToString([p.h for p in self], sort=sort)
#@+node:ekr.20140531104908.17613: *7* PosList.select
def select(self, pat, regex=False, removeClones=True):
    """
    Return a new PosList containing all positions
    in self that match the given pattern.
    """
    c = self.c; aList = []
    if regex:
        for p in self:
            if re.match(pat, p.h):
                aList.append(p.copy())
    else:
        for p in self:
            if p.h.find(pat) != -1:
                aList.append(p.copy())
    if removeClones:
        aList = self.removeClones(aList)
    return PosList(c, aList)
#@+node:ekr.20140531104908.17614: *7* PosList.removeClones
def removeClones(self, aList):
    seen = {}; aList2 = []
    for p in aList:
        if p.v not in seen:
            seen[p.v] = p.v
            aList2.append(p)
    return aList2
#@+node:EKR.20040612114220.4: *6* class g.ReadLinesClass
class ReadLinesClass:
    """A class whose next method provides a readline method for Python's tokenize module."""

    def __init__(self, s):
        self.lines = g.splitLines(s)
        self.i = 0

    def next(self):
        if self.i < len(self.lines):
            line = self.lines[self.i]
            self.i += 1
        else:
            line = ''
        return line

    __next__ = next
#@+node:ekr.20031218072017.3121: *6* class g.RedirectClass & convenience functions
class RedirectClass:
    """A class to redirect stdout and stderr to Leo's log pane."""
    << RedirectClass methods >>

# Create two redirection objects, one for each stream.

redirectStdErrObj = RedirectClass()
redirectStdOutObj = RedirectClass()
<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.1656: *7* << RedirectClass methods >>
@others
#@+node:ekr.20041012082437: *8* RedirectClass.__init__
def __init__(self):
    self.old = None
    self.encoding = 'utf-8'  # 2019/03/29 For pdb.
#@+node:ekr.20041012082437.1: *8* isRedirected
def isRedirected(self):
    return self.old is not None
#@+node:ekr.20041012082437.2: *8* flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return
#@+node:ekr.20041012091252: *8* rawPrint
def rawPrint(self, s):
    if self.old:
        self.old.write(s + '\n')
    else:
        g.pr(s)
#@+node:ekr.20041012082437.3: *8* redirect
def redirect(self, stdout=1):
    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return
    if not self.old:
        if stdout:
            self.old, sys.stdout = sys.stdout, self
        else:
            self.old, sys.stderr = sys.stderr, self
#@+node:ekr.20041012082437.4: *8* undirect
def undirect(self, stdout=1):
    if self.old:
        if stdout:
            sys.stdout, self.old = self.old, None
        else:
            sys.stderr, self.old = self.old, None
#@+node:ekr.20041012082437.5: *8* write
def write(self, s):

    if self.old:
        if app.log:
            app.log.put(s, from_redirect=True)
        else:
            self.old.write(s + '\n')
    else:
        # Can happen when g.batchMode is True.
        g.pr(s)
#@+node:ekr.20031218072017.3122: *7* << define convenience methods for redirecting streams >>
@others
#@+node:ekr.20041012090942: *8* redirectStderr & redirectStdout
# Redirect streams to the current log window.

def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@+node:ekr.20041012090942.1: *8* restoreStderr & restoreStdout
# Restore standard streams.

def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)

def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@+node:ekr.20041012090942.2: *8* stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()

def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@+node:ekr.20041012090942.3: *8* rawPrint
# Send output to original stdout.

def rawPrint(s):
    global redirectStdOutObj
    redirectStdOutObj.rawPrint(s)
#@+node:ekr.20121128031949.12605: *6* class g.SherlockTracer
class SherlockTracer:
    """
    A stand-alone tracer class with many of Sherlock's features.

    This class should work in any environment containing the re, os and sys modules.

    The arguments in the pattern lists determine which functions get traced
    or which stats get printed. Each pattern starts with "+", "-", "+:" or
    "-:", followed by a regular expression::

    "+x"  Enables tracing (or stats) for all functions/methods whose name
          matches the regular expression x.
    "-x"  Disables tracing for functions/methods.
    "+:x" Enables tracing for all functions in the **file** whose name matches x.
    "-:x" Disables tracing for an entire file.

    Enabling and disabling depends on the order of arguments in the pattern
    list. Consider the arguments for the Rope trace::

    patterns=['+.*','+:.*',
        '-:.*\\lib\\.*','+:.*rope.*','-:.*leoGlobals.py',
        '-:.*worder.py','-:.*prefs.py','-:.*resources.py',])

    This enables tracing for everything, then disables tracing for all
    library modules, except for all rope modules. Finally, it disables the
    tracing for Rope's worder, prefs and resources modules. Btw, this is
    one of the best uses for regular expressions that I know of.

    Being able to zero in on the code of interest can be a big help in
    studying other people's code. This is a non-invasive method: no tracing
    code needs to be inserted anywhere.
    
    Usage:
        
    g.SherlockTracer(patterns).run()
    """
    @others
#@+node:ekr.20121128031949.12602: *7* __init__
def __init__(
    self,
    patterns,
    dots=True,
    show_args=True,
    show_return=True,
    verbose=True,
):
    """SherlockTracer ctor."""
    self.bad_patterns = []  # List of bad patterns.
    self.dots = dots  # True: print level dots.
    self.contents_d = {}  # Keys are file names, values are file lines.
    self.n = 0  # The frame level on entry to run.
    self.stats = {}  # Keys are full file names, values are dicts.
    self.patterns = None  # A list of regex patterns to match.
    self.pattern_stack = []
    self.show_args = show_args  # True: show args for each function call.
    self.show_return = show_return  # True: show returns from each function.
    self.trace_lines = True  # True: trace lines in enabled functions.
    self.verbose = verbose  # True: print filename:func
    self.set_patterns(patterns)
    from leo.core.leoQt import QtCore
    if QtCore:
        # pylint: disable=no-member
        QtCore.pyqtRemoveInputHook()
#@+node:ekr.20140326100337.16844: *7* __call__
def __call__(self, frame, event, arg):
    """Exists so that self.dispatch can return self."""
    return self.dispatch(frame, event, arg)
#@+node:ekr.20140326100337.16846: *7* sherlock.bad_pattern
def bad_pattern(self, pattern):
    """Report a bad Sherlock pattern."""
    if pattern not in self.bad_patterns:
        self.bad_patterns.append(pattern)
        print(f"\nignoring bad pattern: {pattern}\n")
#@+node:ekr.20140326100337.16847: *7* sherlock.check_pattern
def check_pattern(self, pattern):
    """Give an error and return False for an invalid pattern."""
    try:
        for prefix in ('+:', '-:', '+', '-'):
            if pattern.startswith(prefix):
                re.match(pattern[len(prefix) :], 'xyzzy')
                return True
        self.bad_pattern(pattern)
        return False
    except Exception:
        self.bad_pattern(pattern)
        return False
#@+node:ekr.20121128031949.12609: *7* sherlock.dispatch
def dispatch(self, frame, event, arg):
    """The dispatch method."""
    if event == 'call':
        self.do_call(frame, arg)
    elif event == 'return' and self.show_return:
        self.do_return(frame, arg)
    elif True and event == 'line' and self.trace_lines:
        self.do_line(frame, arg)
    # Queue the SherlockTracer instance again.
    return self
#@+node:ekr.20121128031949.12603: *7* sherlock.do_call & helper
def do_call(self, frame, unused_arg):
    """Trace through a function call."""
    frame1 = frame
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    function_name = code.co_name
    try:
        full_name = self.get_full_name(locals_, function_name)
    except Exception:
        full_name = function_name
    if not self.is_enabled(file_name, full_name, self.patterns):
        # 2020/09/09: Don't touch, for example, __ methods.
        return
    n = 0  # The number of callers of this def.
    while frame:
        frame = frame.f_back
        n += 1
    dots = '.' * max(0, n - self.n) if self.dots else ''
    path = f"{os.path.basename(file_name):>20}" if self.verbose else ''
    leadin = '+' if self.show_return else ''
    args = f"(%s)" % self.get_args(frame1) if self.show_args else ''
    print(f"{path}:{dots}{leadin}{full_name}{args}")
    # Always update stats.
    d = self.stats.get(file_name, {})
    d[full_name] = 1 + d.get(full_name, 0)
    self.stats[file_name] = d
#@+node:ekr.20130111185820.10194: *8* sherlock.get_args
def get_args(self, frame):
    """Return name=val for each arg in the function call."""
    code = frame.f_code
    locals_ = frame.f_locals
    name = code.co_name
    n = code.co_argcount
    if code.co_flags & 4: n = n + 1
    if code.co_flags & 8: n = n + 1
    result = []
    for i in range(n):
        name = code.co_varnames[i]
        if name != 'self':
            arg = locals_.get(name, '*undefined*')
            if arg:
                if isinstance(arg, (list, tuple)):
                    # Clearer w/o f-string
                    val = f"[%s]" % ','.join(
                        [self.show(z) for z in arg if self.show(z)])
                else:
                    val = self.show(arg)
                if val:
                    result.append(f"{name}={val}")
    return ','.join(result)
#@+node:ekr.20140402060647.16845: *7* sherlock.do_line (not used)
bad_fns = []

def do_line(self, frame, arg):
    """print each line of enabled functions."""
    if 1:
        return
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    full_name = self.get_full_name(locals_, name)
    if not self.is_enabled(file_name, full_name, self.patterns):
        return
    n = frame.f_lineno - 1  # Apparently, the first line is line 1.
    d = self.contents_d
    lines = d.get(file_name)
    if not lines:
        print(file_name)
        try:
            with open(file_name) as f:
                s = f.read()
        except Exception:
            if file_name not in self.bad_fns:
                self.bad_fns.append(file_name)
                print(f"open({file_name}) failed")
            return
        lines = g.splitLines(s)
        d[file_name] = lines
    line = lines[n].rstrip() if n < len(lines) else '<EOF>'
    if 0:
        print(f"{name:3} {line}")
    else:
        print(f"{g.shortFileName(file_name)} {n} {full_name} {line}")
#@+node:ekr.20130109154743.10172: *7* sherlock.do_return & helper
def do_return(self, frame, arg):  # Arg *is* used below.
    """Trace a return statement."""
    import os
    code = frame.f_code
    fn = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    full_name = self.get_full_name(locals_, name)
    if self.is_enabled(fn, full_name, self.patterns):
        n = 0
        while frame:
            frame = frame.f_back
            n += 1
        dots = '.' * max(0, n - self.n) if self.dots else ''
        path = f"{os.path.basename(fn):>20}" if self.verbose else ''
        if name and name == '__init__':
            try:
                ret1 = locals_ and locals_.get('self', None)
                ret = self.format_ret(ret1)
            except NameError:
                ret = f"<{ret1.__class__.__name__}>"
        else:
            ret = self.format_ret(arg)
        print(f"{path}{dots}-{full_name}{ret}")
#@+node:ekr.20130111120935.10192: *8* sherlock.format_ret
def format_ret(self, arg):
    """Format arg, the value returned by a "return" statement."""
    try:
        if isinstance(arg, types.GeneratorType):
            ret = '<generator>'
        elif isinstance(arg, (tuple, list)):
            # Clearer w/o f-string.
            ret = f"[%s]" % ','.join([self.show(z) for z in arg])
            if len(ret) > 40:
                # Clearer w/o f-string.
                ret = f"[\n%s]" % ('\n,'.join([self.show(z) for z in arg]))
        elif arg:
            ret = self.show(arg)
            if len(ret) > 40:
                ret = f"\n    {ret}"
        else:
            ret = '' if arg is None else repr(arg)
    except Exception:
        exctype, value = sys.exc_info()[:2]
        s = f"<**exception: {exctype.__name__}, {value} arg: {arg !r}**>"
        # Clearer w/o f-string.
        ret = f" ->\n    %s" % s if len(s) > 40 else f" -> {s}"
    return f" -> {ret}"
#@+node:ekr.20121128111829.12185: *7* sherlock.fn_is_enabled (not used)
def fn_is_enabled(self, func, patterns):
    """Return True if tracing for the given function is enabled."""
    if func in self.ignored_functions:
        return False
        
    def ignore_function():
        if func not in self.ignored_functions:
            self.ignored_functions.append(func)
            print(f"Ignore function: {func}")
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b', 
        # String primitives.
        'append\b', 'split\b', 'join\b', 
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    g.trace('=====', func)
    for z in table:
        if re.match(z, func):
            ignore_function()
            return False
    #
    # Legacy code.  
    try:
        enabled, pattern = False, None
        for pattern in patterns:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], func):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], func):
                    enabled = False
        return enabled
    except Exception:
        self.bad_pattern(pattern)
        return False
#@+node:ekr.20130112093655.10195: *7* get_full_name
def get_full_name(self, locals_, name):
    """Return class_name::name if possible."""
    full_name = name
    try:
        user_self = locals_ and locals_.get('self', None)
        if user_self:
            full_name = user_self.__class__.__name__ + '::' + name
    except Exception:
        pass
    return full_name
#@+node:ekr.20121128111829.12183: *7* sherlock.is_enabled
ignored_files = []
ignored_functions = []

def is_enabled(self, file_name, function_name, patterns=None):
    """Return True if tracing for function_name in the given file is enabled."""
    #
    # New in Leo 6.3. Never trace through some files.
    if not os:
        return False  # Shutting down.
    base_name = os.path.basename(file_name)
    if base_name in self.ignored_files:
        return False

    def ignore_file():
        if not base_name in self.ignored_files:
            self.ignored_files.append(base_name)
            # print(f"Ignore file: {base_name}")
            
    def ignore_function():
        if function_name not in self.ignored_functions:
            self.ignored_functions.append(function_name)
            # print(f"Ignore function: {function_name}")
            
    if f"{os.sep}lib{os.sep}" in file_name:
        ignore_file()
        return False
    if base_name.startswith('<') and base_name.endswith('>'):
        ignore_file()
        return False
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b', 
        # String primitives.
        'append\b', 'split\b', 'join\b', 
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    for z in table:
        if re.match(z, function_name):
            ignore_function()
            return False
    #
    # Legacy code.
    enabled = False
    if patterns is None: patterns = self.patterns
    for pattern in patterns:
        try:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], file_name):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], file_name):
                    enabled = False
            elif pattern.startswith('+'):
                if re.match(pattern[1:], function_name):
                    enabled = True
            elif pattern.startswith('-'):
                if re.match(pattern[1:], function_name):
                    enabled = False
            else:
                self.bad_pattern(pattern)
        except Exception:
            self.bad_pattern(pattern)
    return enabled
#@+node:ekr.20121128111829.12182: *7* print_stats
def print_stats(self, patterns=None):
    """Print all accumulated statisitics."""
    print('\nSherlock statistics...')
    if not patterns: patterns = ['+.*', '+:.*',]
    for fn in sorted(self.stats.keys()):
        d = self.stats.get(fn)
        if self.fn_is_enabled(fn, patterns):
            result = sorted(d.keys())
        else:
            result = [key for key in sorted(d.keys())
                if self.is_enabled(fn, key, patterns)]
        if result:
            print('')
            fn = fn.replace('\\', '/')
            parts = fn.split('/')
            print('/'.join(parts[-2:]))
            for key in result:
                print(f"{d.get(key):4} {key}")
#@+node:ekr.20121128031949.12614: *7* run
# Modified from pdb.Pdb.set_trace.

def run(self, frame=None):
    """Trace from the given frame or the caller's frame."""
    import sys
    print(f"SherlockTracer.run:patterns:\n%s" % '\n'.join(self.patterns))
    if frame is None:
        frame = sys._getframe().f_back
    # Compute self.n, the number of frames to ignore.
    self.n = 0
    while frame:
        frame = frame.f_back
        self.n += 1
    # Pass self to sys.settrace to give easy access to all methods.
    sys.settrace(self)
#@+node:ekr.20140322090829.16834: *7* push & pop
def push(self, patterns):
    """Push the old patterns and set the new."""
    self.pattern_stack.append(self.patterns)
    self.set_patterns(patterns)
    print(f"SherlockTracer.push: {self.patterns}")

def pop(self):
    """Restore the pushed patterns."""
    if self.pattern_stack:
        self.patterns = self.pattern_stack.pop()
        print(f"SherlockTracer.pop: {self.patterns}")
    else:
        print('SherlockTracer.pop: pattern stack underflow')
#@+node:ekr.20140326100337.16845: *7* set_patterns
def set_patterns(self, patterns):
    """Set the patterns in effect."""
    self.patterns = [z for z in patterns if self.check_pattern(z)]
#@+node:ekr.20140322090829.16831: *7* show
def show(self, item):
    """return the best representation of item."""
    if not item:
        return repr(item)
    if isinstance(item, dict):
        return 'dict'
    if isinstance(item, str):
        s = repr(item)
        if len(s) <= 20:
            return s
        return s[:17] + '...'
    return repr(item)
#@+node:ekr.20121128093229.12616: *7* stop
def stop(self):
    """Stop all tracing."""
    import sys
    sys.settrace(None)
#@+node:ekr.20191013145307.1: *6* class g.TkIDDialog (EmergencyDialog)
class TkIDDialog(EmergencyDialog):
    """A class that creates an tkinter dialog to get the Leo ID."""

    message = (
        "leoID.txt not found\n\n"
        "Please enter an id that identifies you uniquely.\n"
        "Your git/cvs/bzr login name is a good choice.\n\n"
        "Leo uses this id to uniquely identify nodes.\n\n"
        "Your id should contain only letters and numbers\n"
        "and must be at least 3 characters in length.")

    title = 'Enter Leo id'

    def __init__(self):
        super().__init__(self.title, self.message)
        self.val = ''
    @others
#@+node:ekr.20191013145710.1: *7* leo_id_dialog.onKey
def onKey(self, event):
    """Handle Key events in askOk dialogs."""
    if event.char in '\n\r':
        self.okButton()
#@+node:ekr.20191013145757.1: *7* leo_id_dialog.createTopFrame
def createTopFrame(self):
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    import tkinter as Tk
    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()
    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top", expand=1, fill="both")
    label = Tk.Label(self.frame, text=self.message, bg='white')
    label.pack(pady=10)
    self.entry = Tk.Entry(self.frame)
    self.entry.pack()
    self.entry.focus_set()
#@+node:ekr.20191013150158.1: *7* leo_id_dialog.okButton
def okButton(self):
    """Do default click action in ok button."""
    self.val = self.entry.get()
        # Return is not possible.
    self.top.destroy()
    self.top = None
#@+node:ekr.20080531075119.1: *6* class g.Tracer
class Tracer:
    """A "debugger" that computes a call graph.

    To trace a function and its callers, put the following at the function's start:

    g.startTracer()
    """
    @others
def startTracer(limit=0, trace=False, verbose=False):
    import sys
    t = g.Tracer(limit=limit, trace=trace, verbose=verbose)
    sys.settrace(t.tracer)
    return t
#@+node:ekr.20080531075119.2: *7*  __init__ (Tracer)
def __init__(self, limit=0, trace=False, verbose=False):
    self.callDict = {}
        # Keys are function names.
        # Values are the number of times the function was called by the caller.
    self.calledDict = {}
        # Keys are function names.
        # Values are the total number of times the function was called.
    self.count = 0
    self.inited = False
    self.limit = limit  # 0: no limit, otherwise, limit trace to n entries deep.
    self.stack = []
    self.trace = trace
    self.verbose = verbose  # True: print returns as well as calls.
#@+node:ekr.20080531075119.3: *7* computeName
def computeName(self, frame):
    if not frame: return ''
    code = frame.f_code; result = []
    module = inspect.getmodule(code)
    if module:
        module_name = module.__name__
        if module_name == 'leo.core.leoGlobals':
            result.append('g')
        else:
            tag = 'leo.core.'
            if module_name.startswith(tag):
                module_name = module_name[len(tag) :]
            result.append(module_name)
    try:
        # This can fail during startup.
        self_obj = frame.f_locals.get('self')
        if self_obj: result.append(self_obj.__class__.__name__)
    except Exception:
        pass
    result.append(code.co_name)
    return '.'.join(result)
#@+node:ekr.20080531075119.4: *7* report
def report(self):
    if 0:
        g.pr('\nstack')
        for z in self.stack:
            g.pr(z)
    g.pr('\ncallDict...')
    for key in sorted(self.callDict):
        # Print the calling function.
        g.pr(f"{self.calledDict.get(key,0):d}", key)
        # Print the called functions.
        d = self.callDict.get(key)
        for key2 in sorted(d):
            g.pr(f"{d.get(key2):8d}", key2)
#@+node:ekr.20080531075119.5: *7* stop
def stop(self):
    sys.settrace(None)
    self.report()
#@+node:ekr.20080531075119.6: *7* tracer
def tracer(self, frame, event, arg):
    """A function to be passed to sys.settrace."""
    n = len(self.stack)
    if event == 'return':
        n = max(0, n - 1)
    pad = '.' * n
    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) < self.limit):
            g.trace(f"{pad}call", name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    if event == 'return':
        if self.stack:
            name = self.stack.pop()
            if (
                self.trace and
                self.verbose and
                (self.limit == 0 or len(self.stack) < self.limit)
            ):
                g.trace(f"{pad}ret ", name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        self.stop()
        return None
    return self.tracer
#@+node:ekr.20080531075119.7: *7* updateStats
def updateStats(self, name):
    if not self.stack:
        return
    caller = self.stack[-1]
    d = self.callDict.get(caller, {})
        # d is a dict reprenting the called functions.
        # Keys are called functions, values are counts.
    d[name] = 1 + d.get(name, 0)
    self.callDict[caller] = d
    # Update the total counts.
    self.calledDict[name] = 1 + self.calledDict.get(name, 0)
#@+node:ekr.20031219074948.1: *6* class g.Tracing/NullObject & helpers
@nobeautify

tracing_tags = {}
    # Keys are id's, values are tags.
tracing_vars = {}
    # Keys are id's, values are names of ivars.
tracing_signatures = {}
    # Keys are signatures: '%s.%s:%s' % (tag, attr, callers). Values not important.

class NullObject:
    """An object that does nothing, and does it very well."""
    def __init__(self, ivars=None, *args, **kwargs):
        if isinstance(ivars, str):
            ivars = [ivars]
        tracing_vars [id(self)] = ivars or []
    def __call__(self, *args, **keys): return self
    def __repr__(self): return "NullObject"
    def __str__(self): return "NullObject"
    # Attribute access...
    def __delattr__(self, attr): return None
    def __getattr__(self, attr):
        if attr in tracing_vars.get(id(self), []):
            return getattr(self, attr, None)
        return self # Required.
    def __setattr__(self, attr, val):
        if attr in tracing_vars.get(id(self), []):
            object.__setattr__(self, attr, val)
    # Container methods..
    def __bool__(self): return False
    def __contains__(self, item): return False
    def __getitem__(self, key): raise KeyError
    def __setitem__(self, key, val): pass
    def __iter__(self): return self
    def __len__(self): return 0
    # Iteration methods:
    def __next__(self): raise StopIteration
    

class TracingNullObject:
    """Tracing NullObject."""
    def __init__(self, tag, ivars=None, *args, **kwargs):
        tracing_tags [id(self)] = tag
        if isinstance(ivars, str):
            ivars = [ivars]
        tracing_vars [id(self)] = ivars or []
        if 0:
            suppress = ('tree item',)
            if tag not in suppress:
                print('='*10, 'NullObject.__init__:', id(self), tag)
    def __call__(self, *args, **kwargs):
        if 0:
            suppress = ('PyQt5.QtGui.QIcon', 'LeoQtTree.onItemCollapsed',)
            for z in suppress:
                if z not in repr(args):
                    print(f"%30s"  % 'NullObject.__call__:', args, kwargs)
        return self
    def __repr__(self):
        return f'TracingNullObject: {tracing_tags.get(id(self), "<NO TAG>")}'
    def __str__(self):
        return f'TracingNullObject: {tracing_tags.get(id(self), "<NO TAG>")}'
    #
    # Attribute access...
    def __delattr__(self, attr):
        return self
    def __getattr__(self, attr):
        null_object_print_attr(id(self), attr)
        if attr in tracing_vars.get(id(self), []):
            return getattr(self, attr, None)
        return self # Required.
    def __setattr__(self, attr, val):
        g.null_object_print(id(self), '__setattr__', attr, val)
        if attr in tracing_vars.get(id(self), []):
            object.__setattr__(self, attr, val)
    #
    # All other methods...
    def __bool__(self):
        if 0: # To do: print only once.
            suppress = ('getShortcut','on_idle', 'setItemText')
            callers = g.callers(2)
            if not callers.endswith(suppress):
                g.null_object_print(id(self), '__bool__')
        return False
    def __contains__(self, item):
        g.null_object_print(id(self), '__contains__')
        return False
    def __getitem__(self, key):
        g.null_object_print(id(self), '__getitem__')
        # pylint doesn't like trailing return None.
        # return None
    def __iter__(self):
        g.null_object_print(id(self), '__iter__')
        return self
    def __len__(self):
        # g.null_object_print(id(self), '__len__')
        return 0
    def __next__(self):
        g.null_object_print(id(self), '__next__')
        raise StopIteration
    def __setitem__(self, key, val):
        g.null_object_print(id(self), '__setitem__')
        # pylint doesn't like trailing return None.
        # return None
#@+node:ekr.20190330062625.1: *7* g.null_object_print_attr
def null_object_print_attr(id_, attr):
    suppress = True
    if suppress:
        << define suppression lists >>
    else:
        # Print everything.
        suppress_callers = []
        suppress_attrs = []

    tag = tracing_tags.get(id_, "<NO TAG>")
    callers = g.callers(3).split(',')
    callers = ','.join(callers[:-1])
    in_callers = any([z in callers for z in suppress_callers])
    s = f"{tag}.{attr}"
    if suppress:
        # Filter traces.
        if not in_callers and s not in suppress_attrs:
            g.pr(f"{s:40} {callers}")
    else:
        # Print each signature once.  No need to filter!
        signature = f"{tag}.{attr}:{callers}"
        if signature not in tracing_signatures:
            tracing_signatures[signature] = True
            g.pr(f"{s:40} {callers}")
#@+node:ekr.20190330072026.1: *8* << define suppression lists >>
suppress_callers = (
    'drawNode', 'drawTopTree', 'drawTree',
    'contractItem', 'getCurrentItem',
    'declutter_node',
    'finishCreate',
    'initAfterLoad',
    'show_tips',
    'writeWaitingLog',
    # 'set_focus', 'show_tips',
)
suppress_attrs = (
    # Leo...
    'c.frame.body.wrapper',
    'c.frame.getIconBar.add',
    'c.frame.log.createTab',
    'c.frame.log.enable',
    'c.frame.log.finishCreate',
    'c.frame.menu.createMenuBar',
    'c.frame.menu.finishCreate',
    # 'c.frame.menu.getMenu',
    'currentItem',
    'dw.leo_master.windowTitle',
    # Pyzo...
    'pyzo.keyMapper.connect',
    'pyzo.keyMapper.keyMappingChanged',
    'pyzo.keyMapper.setShortcut',
)
#@+node:ekr.20190330072832.1: *7* g.null_object_print
def null_object_print(id_, kind, *args):
    tag = tracing_tags.get(id_, "<NO TAG>")
    callers = g.callers(3).split(',')
    callers = ','.join(callers[:-1])
    s = f"{kind}.{tag}"
    signature = f"{s}:{callers}"
    if 1:
        # Always print:
        if args:
            args = ', '.join([repr(z) for z in args])
            g.pr(f"{s:40} {callers}\n\t\t\targs: {args}")
        else:
            g.pr(f"{s:40} {callers}")
    elif signature not in tracing_signatures:
        # Print each signature once.
        tracing_signatures[signature] = True
        g.pr(f"{s:40} {callers}")
#@+node:ekr.20120129181245.10220: *6* class g.TypedDict
class TypedDict:
    """
    A class providing additional dictionary-related methods:
    
    __init__:     Specifies types and the dict's name.
    __repr__:     Compatible with g.printObj, based on g.objToString.
    __setitem__:  Type checks its arguments.
    __str__:      A concise summary of the inner dict.
    add_to_list:  A convenience method that adds a value to its key's list.
    name:         The dict's name.
    setName:      Sets the dict's name, for use by __repr__.
    
    Overrides the following standard methods:

    copy:         A thin wrapper for copy.deepcopy.
    get:          Returns self.d.get
    items:        Returns self.d.items
    keys:         Returns self.d.keys
    update:       Updates self.d from either a dict or a TypedDict.
    """

    def __init__(self, name, keyType, valType):
        self.d = {}
        self._name = name  # For __repr__ only.
        self.keyType = keyType
        self.valType = valType
    @others
#@+node:ekr.20120205022040.17770: *7* td.__repr__ & __str__
def __str__(self):
    """Concise: used by repr."""
    return (
        f"<TypedDict name:{self._name} "
        f"keys:{self.keyType.__name__} "
        f"values:{self.valType.__name__} "
        f"len(keys): {len(list(self.keys()))}>"
    )

def __repr__(self):
    """Suitable for g.printObj"""
    return f"{g.dictToString(self.d)}\n{str(self)}\n"
#@+node:ekr.20120205022040.17774: *7* td.__setitem__
def __setitem__(self, key, val):
    """Allow d[key] = val"""
    if key is None:
        g.trace('TypeDict: None is not a valid key', g.callers())
        return
    self._checkKeyType(key)
    self._checkKeyType(key)
    try:
        for z in val:
            self._checkValType(z)
    except TypeError:
        self._checkValType(val)  # val is not iterable.
    self.d[key] = val
#@+node:ekr.20190904052828.1: *7* td.add_to_list
def add_to_list(self, key, val):
    """Update the *list*, self.d [key]"""
    if key is None:
        g.trace('TypeDict: None is not a valid key', g.callers())
        return
    self._checkKeyType(key)
    self._checkValType(val)
    aList = self.d.get(key, [])
    if val not in aList:
        aList.append(val)
        self.d[key] = aList
#@+node:ekr.20120206134955.10150: *7* td.checking
def _checkKeyType(self, key):
    if key and key.__class__ != self.keyType:
        self._reportTypeError(key, self.keyType)

def _checkValType(self, val):
    if val.__class__ != self.valType:
        self._reportTypeError(val, self.valType)

def _reportTypeError(self, obj, objType):
    # print(f"Type mismatch: obj: {obj.__class__}, objType: {objType}")
    return (
        f"{self._name}\n"
        f"expected: {obj.__class__.__name__}\n"
        f"     got: {objType.__name__}")
#@+node:ekr.20120223062418.10422: *7* td.copy
def copy(self, name=None):
    """Return a new dict with the same contents."""
    import copy
    return copy.deepcopy(self)
#@+node:ekr.20120205022040.17771: *7* td.get & keys & values
def get(self, key, default=None):
    return self.d.get(key, default)

def items(self):
    return self.d.items()

def keys(self):
    return self.d.keys()

def values(self):
    return self.d.values()
#@+node:ekr.20190903181030.1: *7* td.get_getting & get_string_setting
def get_setting(self, key):
    key = key.replace('-', '').replace('_', '')
    gs = self.get(key)
    val = gs and gs.val
    return val

def get_string_setting(self, key):
    val = self.get_setting(key)
    return val if val and isinstance(val, str) else None
#@+node:ekr.20190904103552.1: *7* td.name & setName
def name(self):
    return self._name

def setName(self, name):
    self._name = name
#@+node:ekr.20120205022040.17807: *7* td.update
def update(self, d):
    """Update self.d from a the appropriate dict."""
    if isinstance(d, TypedDict):
        self.d.update(d.d)
    else:
        self.d.update(d)
#@+node:ville.20090827174345.9963: *6* class g.UiTypeException & g.assertui
class UiTypeException(Exception):
    pass

def assertUi(uitype):
    if not g.app.gui.guiName() == uitype:
        raise UiTypeException
#@+node:ekr.20200219071828.1: *6* class TestLeoGlobals
class TestLeoGlobals(unittest.TestCase):
    """Tests for leoGlobals.py."""
    @others
#@+node:ekr.20200219071958.1: *7* test_comment_delims_from_extension
def test_comment_delims_from_extension(self):

    # pylint: disable=import-self
    import leo.core.leoGlobals as leo_g
    import leo.core.leoApp as leoApp
    leo_g.app = leoApp.LeoApp()
    assert leo_g.comment_delims_from_extension(".py") == ('#', '', '')
    assert leo_g.comment_delims_from_extension(".c") == ('//', '/*', '*/')
    assert leo_g.comment_delims_from_extension(".html") == ('', '<!--', '-->')
#@+node:ekr.20200219072957.1: *7* test_is_sentinel
def test_is_sentinel(self):

    # pylint: disable=import-self
    import leo.core.leoGlobals as leo_g
    # Python.
    py_delims = leo_g.comment_delims_from_extension('.py')
    assert leo_g.is_sentinel("#@+node", py_delims)
    assert not leo_g.is_sentinel("#comment", py_delims)
    # C.
    c_delims = leo_g.comment_delims_from_extension('.c')
    assert leo_g.is_sentinel("//@+node", c_delims)
    assert not g.is_sentinel("//comment", c_delims)
    # Html.
    html_delims = leo_g.comment_delims_from_extension('.html')
    assert leo_g.is_sentinel("<!--@+node-->", html_delims)
    assert not leo_g.is_sentinel("<!--comment-->", html_delims)
#@+node:ekr.20140904112935.18526: *6* g.isTextWrapper & isTextWidget
def isTextWidget(w):
    return g.app.gui.isTextWidget(w)

def isTextWrapper(w):
    return g.app.gui.isTextWrapper(w)
#@+node:ekr.20140711071454.17649: *5* g.Debugging, GC, Stats & Timing
#@+node:ekr.20031218072017.3104: *6* g.Debugging
#@+node:ekr.20031218072017.3105: *7* g.alert (deprecated)
def alert(message, c=None):
    """Raise an alert.

    This method is deprecated: use c.alert instead.
    """
    # The unit tests just tests the args.
    if not g.unitTesting:
        g.es(message)
        g.app.gui.alert(c, message)
#@+node:ekr.20180415144534.1: *7* g.assert_is
def assert_is(obj, list_or_class, warn=True):

    if warn:
        ok = isinstance(obj, list_or_class)
        if not ok:
            g.es_print(
                f"can not happen. {obj !r}: "
                f"expected {list_or_class}, "
                f"got: {obj.__class__.__name__}")
            g.es_print(g.callers())
        return ok
    ok = isinstance(obj, list_or_class)
    assert ok, (obj, obj.__class__.__name__, g.callers())
    return ok
#@+node:ekr.20180420081530.1: *7* g._assert
def _assert(condition, show_callers=True):
    """A safer alternative to a bare assert."""
    if g.unitTesting:
        assert condition
        return True
    ok = bool(condition)
    if ok:
        return True
    g.es_print('\n===== g._assert failed =====\n')
    if show_callers:
        g.es_print(g.callers())
    return False
#@+node:ekr.20051023083258: *7* g.callers & g.caller & _callerName
def callers(n=4, count=0, excludeCaller=True, verbose=False):
    """
    Return a string containing a comma-separated list of the callers
    of the function that called g.callerList.

    excludeCaller: True (the default), g.callers itself is not on the list.
    
    If the `verbose` keyword is True, return a list separated by newlines.
    """
    # Be careful to call g._callerName with smaller values of i first:
    # sys._getframe throws ValueError if there are less than i entries.
    result = []
    i = 3 if excludeCaller else 2
    while 1:
        s = _callerName(n=i, verbose=verbose)
        if s:
            result.append(s)
        if not s or len(result) >= n:
            break
        i += 1
    result.reverse()
    if count > 0:
        result = result[:count]
    if verbose:
        return ''.join([f"\n  {z}" for z in result])
    return ','.join(result)
#@+node:ekr.20031218072017.3107: *8* g._callerName
def _callerName(n, verbose=False):
    try:
        # get the function name from the call stack.
        f1 = sys._getframe(n)  # The stack frame, n levels up.
        code1 = f1.f_code  # The code object
        sfn = shortFilename(code1.co_filename)  # The file name.
        locals_ = f1.f_locals  # The local namespace.
        name = code1.co_name
        line = code1.co_firstlineno
        if verbose:
            obj = locals_.get('self')
            full_name = f"{obj.__class__.__name__}.{name}" if obj else name
            return f"line {line:4} {sfn:>30} {full_name}"
        return name
    except ValueError:
        return ''
            # The stack is not deep enough OR
            # sys._getframe does not exist on this platform.
    except Exception:
        es_exception()
        return ''  # "<no caller name>"
#@+node:ekr.20180328170441.1: *8* g.caller
def caller(i=1):
    """Return the caller name i levels up the stack."""
    return g.callers(i + 1).split(',')[0]
#@+node:ekr.20031218072017.3109: *7* g.dump
def dump(s):
    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out

def oldDump(s):
    out = ""
    for i in s:
        if i == '\n':
            out += "["; out += "n"; out += "]"
        if i == '\t':
            out += "["; out += "t"; out += "]"
        elif i == ' ':
            out += "["; out += " "; out += "]"
        else: out += i
    return out
#@+node:ekr.20150227102835.8: *7* g.dump_encoded_string
def dump_encoded_string(encoding, s):
    """Dump s, assumed to be an encoded string."""
    # Can't use g.trace here: it calls this function!
    print(f"dump_encoded_string: {g.callers()}")
    print(f"dump_encoded_string: encoding {encoding}\n")
    print(s)
    in_comment = False
    for ch in s:
        if ch == '#':
            in_comment = True
        elif not in_comment:
            print(f"{ord(ch):02x} {repr(ch)}")
        elif ch == '\n':
            in_comment = False
#@+node:ekr.20031218072017.1317: *7* g.file/module/plugin_date
def module_date(mod, format=None):
    theFile = g.os_path_join(app.loadDir, mod.__file__)
    root, ext = g.os_path_splitext(theFile)
    return g.file_date(root + ".py", format=format)

def plugin_date(plugin_mod, format=None):
    theFile = g.os_path_join(app.loadDir, "..", "plugins", plugin_mod.__file__)
    root, ext = g.os_path_splitext(theFile)
    return g.file_date(root + ".py", format=format)

def file_date(theFile, format=None):
    if theFile and g.os_path_exists(theFile):
        try:
            n = g.os_path_getmtime(theFile)
            if format is None:
                format = "%m/%d/%y %H:%M:%S"
            return time.strftime(format, time.gmtime(n))
        except(ImportError, NameError):
            pass  # Time module is platform dependent.
    return ""
#@+node:ekr.20031218072017.3127: *7* g.get_line & get_line__after
# Very useful for tracing.

def get_line(s, i):
    nl = ""
    if g.is_nl(s, i):
        i = g.skip_nl(s, i)
        nl = "[nl]"
    j = g.find_line_start(s, i)
    k = g.skip_to_end_of_line(s, i)
    return nl + s[j:k]

# Important: getLine is a completely different function.
# getLine = get_line

def get_line_after(s, i):
    nl = ""
    if g.is_nl(s, i):
        i = g.skip_nl(s, i)
        nl = "[nl]"
    k = g.skip_to_end_of_line(s, i)
    return nl + s[i:k]

getLineAfter = get_line_after
#@+node:ekr.20080729142651.1: *7* g.getIvarsDict and checkUnchangedIvars
def getIvarsDict(obj):
    """Return a dictionary of ivars:values for non-methods of obj."""
    d = dict(
        [[key, getattr(obj, key)] for key in dir(obj)
            if not isinstance(getattr(obj, key), types.MethodType)])
    return d

def checkUnchangedIvars(obj, d, exceptions=None):
    if not exceptions: exceptions = []
    ok = True
    for key in d:
        if key not in exceptions:
            if getattr(obj, key) != d.get(key):
                g.trace(
                    f"changed ivar: {key} "
                    f"old: {repr(d.get(key))} "
                    f"new: {repr(getattr(obj, key))}")
                ok = False
    return ok
#@+node:ekr.20031218072017.3128: *7* g.pause
def pause(s):
    g.pr(s)
    i = 0
    while i < 1000 * 1000:
        i += 1
#@+node:ekr.20041105091148: *7* g.pdb
def pdb(message=''):
    """Fall into pdb."""
    import pdb  # Required: we have just defined pdb as a function!
    if app and not app.useIpython:
        # from leo.core.leoQt import QtCore
        # This is more portable.
        try:
            import PyQt5.QtCore as QtCore
        except ImportError:
            try:
                import PyQt4.QtCore as QtCore
            except ImportError:
                QtCore = None
        if QtCore:
            # pylint: disable=no-member
            QtCore.pyqtRemoveInputHook()
    if message:
        print(message)
    pdb.set_trace()
#@+node:ekr.20041224080039: *7* g.dictToString
def dictToString(d, indent='', tag=None):
    """Pretty print a Python dict to a string."""
    # pylint: disable=unnecessary-lambda
    if not d:
        return '{}'
    result = ['{\n']
    indent2 = indent + ' ' * 4
    n = 2 + len(indent) + max([len(repr(z)) for z in d.keys()])
    for i, key in enumerate(sorted(d, key=lambda z: repr(z))):
        pad = ' ' * max(0, (n - len(repr(key))))
        result.append(f"{pad}{key}:")
        result.append(objToString(d.get(key), indent=indent2))
        if i + 1 < len(d.keys()):
            result.append(',')
        result.append('\n')
    result.append(indent + '}')
    s = ''.join(result)
    return f"{tag}...\n{s}\n" if tag else s
#@+node:ekr.20041126060136: *7* g.listToString
def listToString(obj, indent='', tag=None):
    """Pretty print a Python list to a string."""
    if not obj:
        return '[]'
    result = ['[']
    indent2 = indent + ' ' * 4
    # I prefer not to compress lists.
    for i, obj2 in enumerate(obj):
        result.append('\n' + indent2)
        result.append(objToString(obj2, indent=indent2))
        if i + 1 < len(obj) > 1:
            result.append(',')
        else:
            result.append('\n' + indent)
    result.append(']')
    s = ''.join(result)
    return f"{tag}...\n{s}\n" if tag else s
#@+node:ekr.20050819064157: *7* g.objToSTring & g.toString
def objToString(obj, indent='', printCaller=False, tag=None):
    """Pretty print any Python object to a string."""
    # pylint: disable=undefined-loop-variable
        # Looks like a a pylint bug.
    #
    # Compute s.
    if isinstance(obj, dict):
        s = dictToString(obj, indent=indent)
    elif isinstance(obj, list):
        s = listToString(obj, indent=indent)
    elif isinstance(obj, tuple):
        s = tupleToString(obj, indent=indent)
    elif isinstance(obj, str):
        # Print multi-line strings as lists.
        s = obj
        lines = g.splitLines(s)
        if len(lines) > 1:
            s = listToString(lines, indent=indent)
        else:
            s = repr(s)
    else:
        s = repr(obj)
    #
    # Compute the return value.
    if printCaller and tag:
        prefix = f"{g.caller()}: {tag}"
    elif printCaller or tag:
        prefix = g.caller() if printCaller else tag
    else:
        prefix = None
    if prefix:
        sep = '\n' if '\n' in s else ' '
        return f"{prefix}:{sep}{s}"
    return s

toString = objToString
#@+node:ekr.20140401054342.16844: *7* g.run_pylint
def run_pylint(fn, rc,
    dots=True,  # Show level dots in Sherlock traces.
    patterns=None,  # List of Sherlock trace patterns.
    sherlock=False,  # Enable Sherlock tracing.
    show_return=True,  # Show returns in Sherlock traces.
    stats_patterns=None,  # Patterns for Sherlock statistics.
    verbose=True,  # Show filenames in Sherlock traces.
):
    """
    Run pylint with the given args, with Sherlock tracing if requested.

    **Do not assume g.app exists.**

    run() in pylint-leo.py and PylintCommand.run_pylint *optionally* call this function.
    """
    try:
        from pylint import lint
    except ImportError:
        g.trace('can not import pylint')
        return
    if not g.os_path_exists(fn):
        g.trace('does not exist:', fn)
        return
    if not g.os_path_exists(rc):
        g.trace('does not exist', rc)
        return
    args = [f"--rcfile={rc}"]
    # Prints error number.
        # args.append('--msg-template={path}:{line}: [{msg_id}({symbol}), {obj}] {msg}')
    args.append(fn)
    if sherlock:
        sherlock = g.SherlockTracer(
                dots=dots,
                show_return=show_return,
                verbose=True,  # verbose: show filenames.
                patterns=patterns or [],
            )
        try:
            sherlock.run()
            lint.Run(args)
        finally:
            sherlock.stop()
            sherlock.print_stats(patterns=stats_patterns or [])
    else:
        # print('run_pylint: %s' % g.shortFileName(fn))
        try:
            lint.Run(args)  # does sys.exit
        finally:
            # Printing does not work well here.
            # When not waiting, printing from severl process can be interspersed.
            pass
#@+node:ekr.20120912153732.10597: *7* g.wait
def sleep(n):
    """Wait about n milliseconds."""
    from time import sleep
    sleep(n)  #sleeps for 5 seconds
#@+node:ekr.20171023140544.1: *7* g.printObj & aliases
def printObj(obj, indent='', printCaller=False, tag=None):
    """Pretty print any Python object using g.pr."""
    g.pr(objToString(obj, indent=indent, printCaller=printCaller, tag=tag))

printDict = printObj
printList = printObj
printTuple = printObj
#@+node:ekr.20171023110057.1: *7* g.tupleToString
def tupleToString(obj, indent='', tag=None):
    """Pretty print a Python tuple to a string."""
    if not obj:
        return '(),'
    result = ['(']
    indent2 = indent + ' ' * 4
    for i, obj2 in enumerate(obj):
        if len(obj) > 1:
            result.append('\n' + indent2)
        result.append(objToString(obj2, indent=indent2))
        if len(obj) == 1 or i + 1 < len(obj):
            result.append(',')
        elif len(obj) > 1:
            result.append('\n' + indent)
    result.append(')')
    s = ''.join(result)
    return f"{tag}...\n{s}\n" if tag else s
#@+node:ekr.20031218072017.1588: *6* g.Garbage Collection
lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}
#@+node:ekr.20031218072017.1589: *7* g.clearAllIvars
def clearAllIvars(o):
    """Clear all ivars of o, a member of some class."""
    if o:
        o.__dict__.clear()
#@+node:ekr.20031218072017.1590: *7* g.collectGarbage
def collectGarbage():
    try:
        gc.collect()
    except Exception:
        pass
#@+node:ekr.20060127162818: *7* g.enable_gc_debug
def enable_gc_debug(event=None):
    # pylint: disable=no-member
    if not gc:
        g.error('can not import gc module')
        return
    gc.set_debug(
        gc.DEBUG_STATS |  # prints statistics.
        gc.DEBUG_LEAK |  # Same as all below.
        gc.DEBUG_COLLECTABLE |
        gc.DEBUG_UNCOLLECTABLE |
        # gc.DEBUG_INSTANCES |
        # gc.DEBUG_OBJECTS |
        gc.DEBUG_SAVEALL)
#@+node:ekr.20190609113810.1: *7* g.GetRepresentativeObjects
def getRepresentativeLiveObjects():
    """
    Return a dict.
    Keys classes.
    Values are the first (representative) live object for each type.
    """
    d = {}  # Keys are types, values are the *first* instance.
    for obj in gc.get_objects():
        t = type(obj)
        if t not in d and hasattr(obj, '__class__'):
            d[t] = obj
    return d
#@+node:ekr.20031218072017.1592: *7* g.printGc
# Formerly called from unit tests.

def printGc(tag=None):
    tag = tag or g._callerName(n=2)
    printGcObjects(tag=tag)
    printGcRefs(tag=tag)
    printGcVerbose(tag=tag)
#@+node:ekr.20031218072017.1593: *8* g.printGcRefs
def printGcRefs(tag=''):
    verbose = False
    refs = gc.get_referrers(app.windowList[0])
    g.pr('-' * 30, tag)
    if verbose:
        g.pr("refs of", app.windowList[0])
        for ref in refs:
            g.pr(type(ref))
    else:
        g.pr(f"{len(refs):d} referers")
#@+node:ekr.20060202161935: *7* g.printGcAll
def printGcAll(full=False, sort_by_n=True):
    """Print a summary of all presently live objects."""
    if g.unitTesting:
        return
    t1 = time.process_time()
    objects = gc.get_objects()
    d = {}  # Keys are types, values are ints (number of instances).
    for obj in objects:
        t = type(obj)
        if hasattr(obj, '__class__'):
            d[t] = d.get(t, 0) + 1
    t2 = time.process_time()
    if full:
        if sort_by_n:  # Sort by n
            items = list(d.items())
            items.sort(key=lambda x: x[1])
            for z in reversed(items):
                print(f"{z[1]:8} {z[0]}")
        else:  # Sort by type
            g.printObj(d)
    #
    # Summarize
    print(
        f"\n"
        f"printGcAll: {len(objects):d} objects "
        f"in {t2-t1:5.2f} sec. ")
#@+node:ekr.20060127164729.1: *7* g.printGcObjects
def printGcObjects(tag=''):
    """Print newly allocated objects."""
    tag = tag or g._callerName(n=2)
    global lastObjectCount
    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2 - lastObjectCount
        if delta == 0: return
        lastObjectCount = n2
        << print number of each type of object >>
        if 0:
            << print added functions >>
    except Exception:
        traceback.print_exc()

printNewObjects = pno = printGcObjects
#@+node:ekr.20040703054646: *8* << print number of each type of object >>
global lastTypesDict
typesDict = {}
for obj in gc.get_objects():
    t = type(obj)
    # pylint: disable=no-member
    if t == 'instance' and t != types.UnicodeType:  # NOQA
        try: t = obj.__class__
        except Exception: pass
    if t != types.FrameType:  # NOQA
        r = repr(t)  # was type(obj) instead of repr(t)
        n = typesDict.get(r, 0)
        typesDict[r] = n + 1
# Create the union of all the keys.
keys = {}
for key in lastTypesDict:
    if key not in typesDict:
        keys[key] = None
empty = True
for key in keys:
    n3 = lastTypesDict.get(key, 0)
    n4 = typesDict.get(key, 0)
    delta2 = n4 - n3
    if delta2 != 0:
        empty = False
        break
if not empty:
    g.pr('-' * 30)
    g.pr(f"{tag}: garbage: {n}, objects: {n2}, delta: {delta}")
    if 0:
        for key in sorted(keys):
            n1 = lastTypesDict.get(key, 0)
            n2 = typesDict.get(key, 0)
            delta2 = n2 - n1
            if delta2 != 0:
                g.pr(f"{delta2:6d} ={n2:7d} {key}")
lastTypesDict = typesDict
typesDict = {}
#@+node:ekr.20040703065638: *8* << print added functions >>
global lastFunctionsDict
funcDict = {}
getspec = inspect.getfullargspec
n = 0  # Don't print more than 50 objects.
for obj in gc.get_objects():
    if isinstance(obj, types.FunctionType):
        n += 1
        key = repr(obj)  # Don't create a pointer to the object!
        funcDict[key] = None
        if n < 50 and key not in lastFunctionsDict:
            g.pr(obj)
            data = getspec(obj)
            args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations = data
            g.pr("args", args)
            if varargs: g.pr("varargs", varargs)
            if varkw: g.pr("varkw", varkw)
            if defaults:
                g.pr("defaults...")
                for s in defaults: g.pr(s)
lastFunctionsDict = funcDict
funcDict = {}
#@+node:ekr.20060205043324.1: *7* g.printGcSummary
def printGcSummary(tag=''):
    tag = tag or g._callerName(n=2)
    g.enable_gc_debug()
    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = f"{tag}: printGCSummary: garbage: {n}, objects: {n2}"
        g.pr(s)
    except Exception:
        traceback.print_exc()
#@+node:ekr.20060127165509: *7* g.printGcVerbose
# WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(tag=''):
    tag = tag or g._callerName(n=2)
    global lastObjectsDict
    objects = gc.get_objects()
    newObjects = [o for o in objects if id(o) not in lastObjectsDict]
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)] = o
    dicts = 0; seqs = 0
    i = 0; n = len(newObjects)
    while i < 100 and i < n:
        o = newObjects[i]
        if isinstance(o, dict):
            dicts += 1
        elif isinstance(o, (list, tuple)):
            #g.pr(id(o),repr(o))
            seqs += 1
        #else:
        #    g.pr(o)
        i += 1
    g.pr('=' * 40)
    g.pr(f"dicts: {dicts}, sequences: {seqs}")
    g.pr(f"{tag}: {len(newObjects)} new, {len(objects)} total objects")
    g.pr('-' * 40)
#@+node:ekr.20180528151850.1: *6* g.printTimes
def printTimes(times):
    """
    Print the differences in the times array.
    
    times: an array of times (calls to time.process_time()).
    """
    for n, junk in enumerate(times[:-1]):
        t = times[n + 1] - times[n]
        if t > 0.1:
            g.trace(f"*** {n} {t:5.4f} sec.")
#@+node:ekr.20031218072017.3133: *6* g.Statistics
#@+node:ekr.20031218072017.3134: *7* g.clearStats
def clearStats():

    g.app.statsDict = {}
#@+node:ekr.20031218072017.3135: *7* g.printStats
@command('show-stats')
def printStats(event=None, name=None):
    """
    Print all gathered statistics.
    
    Here is the recommended code to gather stats for one method/function:
        
        if not g.app.statsLockout:
            g.app.statsLockout = True
            try:
                d = g.app.statsDict
                key = 'g.isUnicode:' + g.callers()
                d [key] = d.get(key, 0) + 1
            finally:
                g.app.statsLockout = False
    """
    if name:
        if not isString(name):
            name = repr(name)
    else:
        name = g._callerName(n=2)  # Get caller name 2 levels back.
    #
    # Print the stats, organized by number of calls.
    d = g.app.statsDict
    d2 = {val: key for key, val in d.iteritems()}
    for key in reversed(sorted(d2.keys())):
        print(f"{key:7} {d2.get(key)}")
#@+node:ekr.20031218072017.3136: *7* g.stat
def stat(name=None):
    """Increments the statistic for name in g.app.statsDict
    The caller's name is used by default.
    """
    d = g.app.statsDict
    if name:
        if not isString(name):
            name = repr(name)
    else:
        name = g._callerName(n=2)  # Get caller name 2 levels back.
    d[name] = 1 + d.get(name, 0)
#@+node:ekr.20031218072017.3137: *6* g.Timing
def getTime():
    return time.time()

def esDiffTime(message, start):
    delta = time.time() - start
    g.es('', f"{message} {delta:5.2f} sec.")
    return time.time()

def printDiffTime(message, start):
    delta = time.time() - start
    g.pr(f"{message} {delta:5.2f} sec.")
    return time.time()

def timeSince(start):
    return f"{time.time()-start:5.2f} sec."
#@+node:ekr.20031218072017.1380: *5* g.Directives
# Weird pylint bug, activated by TestLeoGlobals class.
# Disabling this will be safe, because pyflakes will still warn about true redefinitions
# pylint: disable=function-redefined
#@+node:EKR.20040504150046.4: *6* g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    """
    Return the comment delims corresponding to the filename's extension.
    """
    if filename.startswith('.'):
        root, ext = None, filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    g.trace(
        f"unknown extension: {ext!r}, "
        f"filename: {filename!r}, "
        f"root: {root!r}")
    return '', '', ''
#@+node:ekr.20090214075058.8: *6* g.findAtTabWidthDirectives (must be fast)
def findTabWidthDirectives(c, p):
    """Return the language in effect at position p."""
    if c is None:
        return None  # c may be None for testing.
    w = None
    # 2009/10/02: no need for copy arg to iter
    for p in p.self_and_parents(copy=False):
        if w: break
        for s in p.h, p.b:
            if w: break
            anIter = g_tabwidth_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = g.skip_ws(s, i + len(word))
                junk, w = g.skip_long(s, j)
                if w == 0: w = None
    return w
#@+node:ekr.20090214075058.6: *6* g.findLanguageDirectives (must be fast)
def findLanguageDirectives(c, p):
    """Return the language in effect at position p."""
    if c is None or p is None:
        return None  # c may be None for testing.
        
    v0 = p.v
        
    def find_language(p_or_v):
        for s in p_or_v.h, p_or_v.b:
            for m in g_language_pat.finditer(s):
                language = m.group(1)
                if g.isValidLanguage(language):
                    return language
        return None

    # First, search up the tree.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    # #1625: Second, expand the search for cloned nodes.
    seen = [] # vnodes that have already been searched.
    parents = v0.parents[:] # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    # Finally, fall back to the defaults.
    return c.target_language.lower() if c.target_language else 'python'
#@+node:ekr.20031218072017.1385: *6* g.findReference
# Called from the syntax coloring method that colorizes section references.
# Also called from write at.putRefAt.

def findReference(name, root):
    """Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    """
    for p in root.subtree(copy=False):
        assert(p != root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p.copy()
    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents(copy=False):
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree(copy=False):
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2.copy()
    return None
#@+node:ekr.20090214075058.9: *6* g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

def get_directives_dict(p, root=None):
    """
    Scan p for Leo directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    if root: root_node = root[0]
    # c = p and p.v and p.v.context
    d = {}
    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat, re.MULTILINE)
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j < len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j:k].strip()
            if word in ('root-doc', 'root-code'):
                d['root'] = val  # in addition to optioned version
            d[word] = val
            # New in Leo 5.7.1: @path is allowed in body text.
            # This is very useful when doing recursive imports.
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0  # value not immportant
            else:
                g.es(f'{g.angleBrackets("*")} may only occur in a topmost node (i.e., without a parent)')
            break
    return d
#@+node:ekr.20090214075058.10: *7* g.compute_directives_re
def compute_directives_re():
    """
    Return an re pattern which word matches all Leo directives.
    Only g.get_directives_dict uses this pattern.
    """
    global globalDirectiveList
    # Use a pattern that guarantees word matches.
    aList = [
        fr"\b{z}\b" for z in globalDirectiveList if z != 'others'
    ]
    # Clearer w/o f-strings.
    return f"^@(%s)" % "|".join(aList)
#@+node:ekr.20080827175609.1: *6* g.get_directives_dict_list (must be fast)
def get_directives_dict_list(p):
    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to
    the start of each directive"""
    result = []
    p1 = p.copy()
    for p in p1.self_and_parents(copy=False):
        root = None if p.hasParent() else [p]
            # No copy necessary: g.get_directives_dict does not change p.
        result.append(g.get_directives_dict(p, root=root))
    return result
#@+node:ekr.20111010082822.15545: *6* g.getLanguageFromAncestorAtFileNode
def getLanguageFromAncestorAtFileNode(p):
    """
    Return the language in effect as determined
    by the file extension of the nearest enclosing @<file> node.
    """
    
    v0 = p.v
        
    def find_language(p_or_v):
        if p_or_v.isAnyAtFileNode():
            name = p_or_v.anyAtFileNodeName()
            junk, ext = g.os_path_splitext(name)
            ext = ext[1:]  # strip the leading .
            language = g.app.extension_dict.get(ext)
            if g.isValidLanguage(language):
                return language
        return None

    # First, look at the direct parents.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    #
    # #1625: Expand the search for cloned nodes.
    seen = [] # vnodes that have already been searched.
    parents = v0.parents[:] # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    return None
#@+node:ekr.20150325075144.1: *6* g.getLanguageFromPosition
def getLanguageAtPosition(c, p):
    """
    Return the language in effect at position p.
    This is always a lowercase language name, never None.
    """
    aList = g.get_directives_dict_list(p)
    d = g.scanAtCommentAndAtLanguageDirectives(aList)
    language = (
        d and d.get('language') or
        g.getLanguageFromAncestorAtFileNode(p) or
        c.config.getString('target-language') or
        'python'
    )
    return language.lower()
#@+node:ekr.20031218072017.1386: *6* g.getOutputNewline
def getOutputNewline(c=None, name=None):
    """Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.
    """
    if name: s = name
    elif c: s = c.config.output_newline
    else: s = app.config.output_newline
    if not s: s = ''
    s = s.lower()
    # pylint: disable=undefined-loop-variable
    # looks like a pylint bug
    if s in ("nl", "lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n'  # Default for erroneous values.
    assert isinstance(s, str), repr(s)
    return s
#@+node:ekr.20200521075143.1: *6* g.inAtNosearch
def inAtNosearch(p):
    """Return True if p or p's ancestors contain an @nosearch directive."""
    for p in p.self_and_parents():
        if p.is_at_ignore() or re.search(r'(^@|\n@)nosearch\b', p.b):
            return True
    return False
#@+node:ekr.20200810074755.1: *6* g.isValidLanguage (new)
def isValidLanguage(language):
    """True if language exists in leo/modes."""
    # 2020/08/12: A hack for c++
    if language in ('c++', 'cpp'):
        language = 'cplusplus'
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', f"{language}.py")
    return g.os_path_exists(fn)
#@+node:ekr.20131230090121.16528: *6* g.isDirective
def isDirective(s):
    """Return True if s starts with a directive."""
    m = g_is_directive_pattern.match(s)
    if m:
        s2 = s[m.end(1) :]
        if s2 and s2[0] in ".(":
            return False
        return bool(m.group(1) in g.globalDirectiveList)
    return False
#@+node:ekr.20080827175609.52: *6* g.scanAtCommentAndLanguageDirectives
def scanAtCommentAndAtLanguageDirectives(aList):
    """
    Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.
    """
    lang = None
    for d in aList:
        comment = d.get('comment')
        language = d.get('language')
        # Important: assume @comment follows @language.
        if language:
            lang, delim1, delim2, delim3 = g.set_language(language, 0)
        if comment:
            delim1, delim2, delim3 = g.set_delims_from_string(comment)
        if comment or language:
            delims = delim1, delim2, delim3
            d = {'language': lang, 'comment': comment, 'delims': delims}
            return d
    return None
#@+node:ekr.20080827175609.32: *6* g.scanAtEncodingDirectives
def scanAtEncodingDirectives(aList):
    """Scan aList for @encoding directives."""
    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            return encoding
        if encoding and not g.app.unitTesting:
            g.error("invalid @encoding:", encoding)
    return None
#@+node:ekr.20080827175609.53: *6* g.scanAtHeaderDirectives
def scanAtHeaderDirectives(aList):
    """scan aList for @header and @noheader directives."""
    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.error("conflicting @header and @noheader directives")
#@+node:ekr.20080827175609.33: *6* g.scanAtLineendingDirectives
def scanAtLineendingDirectives(aList):
    """Scan aList for @lineending directives."""
    for d in aList:
        e = d.get('lineending')
        if e in ("cr", "crlf", "lf", "nl", "platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.error("invalid @lineending directive:",e)
    return None
#@+node:ekr.20080827175609.34: *6* g.scanAtPagewidthDirectives
def scanAtPagewidthDirectives(aList, issue_error_flag=False):
    """Scan aList for @pagewidth directives."""
    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s, 0)
            if val is not None and val > 0:
                return val
            if issue_error_flag and not g.app.unitTesting:
                g.error("ignoring @pagewidth", s)
    return None
#@+node:ekr.20101022172109.6108: *6* g.scanAtPathDirectives scanAllAtPathDirectives
def scanAtPathDirectives(c, aList):
    path = c.scanAtPathDirectives(aList)
    return path

def scanAllAtPathDirectives(c, p):
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path
#@+node:ekr.20100507084415.5760: *6* g.scanAtRootDirectives
def scanAtRootDirectives(aList):
    """Scan aList for @root directives."""
    for d in aList:
        s = d.get('root')
        if s is not None:
            i, mode = g.scanAtRootOptions(s, 0)
            return mode
    return None
#@+node:ekr.20031218072017.3154: *6* g.scanAtRootOptions
def scanAtRootOptions(s, i, err_flag=False):
    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s, i, "@root"):
        i += len("@root")
        i = g.skip_ws(s, i)
    mode = None
    while g.match(s, i, '-'):
        << scan another @root option >>
    if mode is None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = "doc" if doc else "code"
    return i, mode
#@+node:ekr.20031218072017.3155: *7* << scan another @root option >>
i += 1; err = -1
if g.match_word(s, i, "code"):  # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
elif g.match(s, i, "doc"):  # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:", g.get_line(s, i))
else:
    err = i - 1
# Scan to the next minus sign.
while i < len(s) and s[i] not in (' ', '\t', '\n', '-'):
    i += 1
if err > -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s, i)
    g.es("unknown option:", z_opt, "in", z_line)
#@+node:ekr.20080827175609.37: *6* g.scanAtTabwidthDirectives & scanAllTabWidthDirectives
def scanAtTabwidthDirectives(aList, issue_error_flag=False):
    """Scan aList for @tabwidth directives."""
    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk, val = g.skip_long(s, 0)
            if val not in (None, 0):
                return val
            if issue_error_flag and not g.app.unitTesting:
                g.error("ignoring @tabwidth", s)
    return None

def scanAllAtTabWidthDirectives(c, p):
    """Scan p and all ancestors looking for @tabwidth directives."""
    if c and p:
        aList = g.get_directives_dict_list(p)
        val = g.scanAtTabwidthDirectives(aList)
        ret = c.tab_width if val is None else val
    else:
        ret = None
    return ret
#@+node:ekr.20080831084419.4: *6* g.scanAtWrapDirectives & scanAllAtWrapDirectives
def scanAtWrapDirectives(aList, issue_error_flag=False):
    """Scan aList for @wrap and @nowrap directives."""
    for d in aList:
        if d.get('wrap') is not None:
            return True
        if d.get('nowrap') is not None:
            return False
    return None

def scanAllAtWrapDirectives(c, p):
    """Scan p and all ancestors looking for @wrap/@nowrap directives."""
    if c and p:
        default = c and c.config.getBool("body-pane-wraps")
        aList = g.get_directives_dict_list(p)
        val = g.scanAtWrapDirectives(aList)
        ret = default if val is None else val
    else:
        ret = None
    return ret
#@+node:ekr.20080901195858.4: *6* g.scanDirectives  (for compatibility only)
def scanDirectives(c, p=None):
    return c.scanAllDirectives(p)
#@+node:ekr.20040715155607: *6* g.scanForAtIgnore
def scanForAtIgnore(c, p):
    """Scan position p and its ancestors looking for @ignore directives."""
    if g.app.unitTesting:
        return False  # For unit tests.
    for p in p.self_and_parents(copy=False):
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True
    return False
#@+node:ekr.20040712084911.1: *6* g.scanForAtLanguage
def scanForAtLanguage(c, p):
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.
    if c and p:
        for p in p.self_and_parents(copy=False):
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language, delim1, delim2, delim3 = g.set_language(z, 0)
                return language
    return c.target_language
#@+node:ekr.20041123094807: *6* g.scanForAtSettings
def scanForAtSettings(p):
    """Scan position p and its ancestors looking for @settings nodes."""
    for p in p.self_and_parents(copy=False):
        h = p.h
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True
    return False
#@+node:ekr.20031218072017.1382: *6* g.set_delims_from_language
def set_delims_from_language(language):
    """Return a tuple (single,start,end) of comment delims."""
    val = g.app.language_delims_dict.get(language)
    if val:
        delim1, delim2, delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return '', delim1, delim2
        # 0,1 or 3 params.
        return delim1, delim2, delim3
    return '', '', ''
        # Indicate that no change should be made
#@+node:ekr.20031218072017.1383: *6* g.set_delims_from_string
def set_delims_from_string(s):
    """
    Return (delim1, delim2, delim2), the delims following the @comment
    directive.

    This code can be called from @language logic, in which case s can
    point at @comment
    """
    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s, i, tag):
        i += len(tag)
    count = 0; delims = ['', '', '']
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s, i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
            i += 1
        if j == i: break
        delims[count] = s[j:i] or ''
        count += 1
    # 'rr 09/25/02
    if count == 2:  # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = ''
    for i in range(0, 3):
        if delims[i]:
            if delims[i].startswith("@0x"):
                # Allow delimiter definition as @0x + hexadecimal encoded delimiter
                # to avoid problems with duplicate delimiters on the @comment line.
                # If used, whole delimiter must be encoded.
                if len(delims[i]) == 3:
                    g.warning(f"'{delims[i]}' delimiter is invalid")
                    return None, None, None
                try:
                    delims[i] = binascii.unhexlify(delims[i][3:])
                    delims[i] = g.toUnicode(delims[i])
                except Exception as e:
                    g.warning(f"'{delims[i]}' delimiter is invalid: {e}")
                    return None, None, None
            else:
                # 7/8/02: The "REM hack": replace underscores by blanks.
                # 9/25/02: The "perlpod hack": replace double underscores by newlines.
                delims[i] = delims[i].replace("__", '\n').replace('_', ' ')
    return delims[0], delims[1], delims[2]
#@+node:ekr.20031218072017.1384: *6* g.set_language
def set_language(s, i, issue_errors_flag=False):
    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """
    tag = "@language"
    assert(i is not None)
    if g.match_word(s, i, tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i; i = g.skip_c_id(s, i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    if issue_errors_flag:
        g.es("ignoring:", g.get_line(s, i))
    return None, None, None, None
#@+node:ekr.20081001062423.9: *6* g.setDefaultDirectory & helper
def setDefaultDirectory(c, p, importing=False):
    """ Return a default directory by scanning @path directives."""
    if p:
        name = p.anyAtFileNodeName()
        if name:
            # An absolute path overrides everything.
            d = g.os_path_dirname(name)
            if d and g.os_path_isabs(d):
                return d
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
            # Returns g.getBaseDirectory(c) by default.
            # However, g.getBaseDirectory can return ''
    else:
        path = None
    if path:
        path = g.os_path_finalize(path)
    else:
        g.checkOpenDirectory(c)
        for d in (c.openDirectory, g.getBaseDirectory(c)):
            # Errors may result in relative or invalid path.
            if d and g.os_path_isabs(d):
                path = d
                break
        else:
            path = ''
    if not importing and not path:
        # This should never happen, but is not serious if it does.
        g.warning("No absolute directory specified anywhere.")
    return path
#@+node:ekr.20101022124309.6132: *7* g.checkOpenDirectory
def checkOpenDirectory(c):
    if c.openDirectory != c.frame.openDirectory:
        g.error(
            f"Error: c.openDirectory != c.frame.openDirectory\n"
            f"c.openDirectory: {c.openDirectory}\n"
            f"c.frame.openDirectory: {c.frame.openDirectory}")
    if not g.os_path_isabs(c.openDirectory):
        g.error(f"Error: relative c.openDirectory: {c.openDirectory}")
#@+node:ekr.20071109165315: *6* g.stripPathCruft
def stripPathCruft(path):
    """Strip cruft from a path name."""
    if not path:
        return path  # Retain empty paths for warnings.
    if len(path) > 2 and (
        (path[0] == '<' and path[-1] == '>') or
        (path[0] == '"' and path[-1] == '"') or
        (path[0] == "'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()
    # We want a *relative* path, not an absolute path.
    return path
#@+node:ekr.20031218072017.3116: *5* g.Files & Directories
#@+node:ekr.20080606074139.2: *6* g.chdir
def chdir(path):
    if not g.os_path_isdir(path):
        path = g.os_path_dirname(path)
    if g.os_path_isdir(path) and g.os_path_exists(path):
        os.chdir(path)
#@+node:ekr.20120222084734.10287: *6* g.compute...Dir
# For compatibility with old code.

def computeGlobalConfigDir():
    return g.app.loadManager.computeGlobalConfigDir()

def computeHomeDir():
    return g.app.loadManager.computeHomeDir()

def computeLeoDir():
    return g.app.loadManager.computeLeoDir()

def computeLoadDir():
    return g.app.loadManager.computeLoadDir()

def computeMachineName():
    return g.app.loadManager.computeMachineName()

def computeStandardDirectories():
    return g.app.loadManager.computeStandardDirectories()
#@+node:ekr.20031218072017.3103: *6* g.computeWindowTitle
def computeWindowTitle(fileName):

    branch, commit = g.gitInfoForFile(fileName)  # #1616
    if not fileName:
        return branch + ": untitled" if branch else 'untitled'
    path, fn = g.os_path_split(fileName)
    if path:
        title = fn + " in " + path
    else:
        title = fn
    # Yet another fix for bug 1194209: regularize slashes.
    if os.sep in '/\\':
        title = title.replace('/', os.sep).replace('\\', os.sep)
    if branch:
        title = branch + ": " + title
    return title
#@+node:ekr.20031218072017.3117: *6* g.create_temp_file
def create_temp_file(textMode=False):
    """
    Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.
    """
    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd, theFileName = tempfile.mkstemp(text=textMode)
        mode = 'w' if textMode else 'wb'
        theFile = os.fdopen(fd, mode)
    except Exception:
        g.error('unexpected exception in g.create_temp_file')
        g.es_exception()
        theFile, theFileName = None, ''
    return theFile, theFileName
#@+node:vitalije.20170714085545.1: *6* g.defaultLeoFileExtension
def defaultLeoFileExtension(c=None):
    conf = c.config if c else g.app.config
    return conf.getString('default-leo-extension') or '.leo'
#@+node:ekr.20031218072017.3118: *6* g.ensure_extension
def ensure_extension(name, ext):

    theFile, old_ext = g.os_path_splitext(name)
    if not name:
        return name  # don't add to an empty name.
    if old_ext in ('.db', '.leo'):
        return name
    if old_ext and old_ext == ext:
        return name
    return name + ext
#@+node:ekr.20150403150655.1: *6* g.fullPath
def fullPath(c, p, simulate=False):
    """
    Return the full path (including fileName) in effect at p. Neither the
    path nor the fileName will be created if it does not exist.
    """
    # Search p and p's parents.
    for p in p.self_and_parents(copy=False):
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        fn = p.h if simulate else p.anyAtFileNodeName()
            # Use p.h for unit tests.
        if fn:
            # Fix #102: expand path expressions.
            fn = c.expand_path_expression(fn)  # #1341.
            return g.os_path_finalize_join(path, fn)  # #1341.
    return ''
#@+node:ekr.20190327192721.1: *6* g.get_files_in_directory
def get_files_in_directory(directory, kinds=None, recursive=True):
    """
    Return a list of all files of the given file extensions in the directory.
    Default kinds: ['*.py'].
    """
    files, sep = [], os.path.sep
    if not g.os.path.exists(directory):
        g.es_print('does not exist', directory)
        return files
    try:
        if kinds:
            kinds = [z if z.startswith('*') else '*' + z for z in kinds]
        else:
            kinds = ['*.py']
        if recursive:
            # Works for all versions of Python.
            import fnmatch
            for root, dirnames, filenames in os.walk(directory):
                for kind in kinds:
                    for filename in fnmatch.filter(filenames, kind):
                        files.append(os.path.join(root, filename))
        else:
            for kind in kinds:
                files.extend(glob.glob(directory + sep + kind))
        return list(set(sorted(files)))
    except Exception:
        g.es_exception()
        return []
#@+node:ekr.20031218072017.1264: *6* g.getBaseDirectory
# Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c):
    """Convert '!' or '.' to proper directory references."""
    base = app.config.relative_path_base_directory
    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory
    if base and g.os_path_isabs(base):
        # Set c.chdir_to_relative_path as needed.
        if not hasattr(c, 'chdir_to_relative_path'):
            c.chdir_to_relative_path = c.config.getBool('chdir-to-relative-path')
        # Call os.chdir if requested.
        if c.chdir_to_relative_path:
            os.chdir(base)
        return base  # base need not exist yet.
    return ""  # No relative base given.
#@+node:ekr.20170223093758.1: *6* g.getEncodingAt
def getEncodingAt(p, s=None):
    """
    Return the encoding in effect at p and/or for string s.

    Read logic:  s is not None.
    Write logic: s is None.
    """
    # A BOM overrides everything.
    if s:
        e, junk_s = g.stripBOM(s)
        if e:
            return e
    aList = g.get_directives_dict_list(p)
    e = g.scanAtEncodingDirectives(aList)
    if s and s.strip() and not e:
        e = 'utf-8'
    return e
#@+node:ville.20090701144325.14942: *6* g.guessExternalEditor
def guessExternalEditor(c=None):
    """ Return a 'sensible' external editor """
    editor = (
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db and g.app.db.get("LEO_EDITOR") or
        c and c.config.getString('external-editor'))
    if editor: return editor
    # fallbacks
    platform = sys.platform.lower()
    if platform.startswith('win'):
        return "notepad"
    if platform.startswith('linux'):
        return 'gedit'
    g.es(
        '''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db['LEO_EDITOR'] = "gvim"''',
    )
    return None
#@+node:ekr.20160330204014.1: *6* g.init_dialog_folder
def init_dialog_folder(c, p, use_at_path=True):
    """Return the most convenient folder to open or save a file."""
    if c and p and use_at_path:
        path = g.fullPath(c, p)
        if path:
            dir_ = g.os_path_dirname(path)
            if dir_ and g.os_path_exists(dir_):
                return dir_
    table = (
        ('c.last_dir', c and c.last_dir),
        ('os.curdir', g.os_path_abspath(os.curdir)),
    )
    for kind, dir_ in table:
        if dir_ and g.os_path_exists(dir_):
            return dir_
    return ''
#@+node:ekr.20100329071036.5744: *6* g.is_binary_file/external_file/string
def is_binary_file(f):
    return f and isinstance(f, io.BufferedIOBase)

def is_binary_external_file(fileName):
    try:
        with open(fileName, 'rb') as f:
            s = f.read(1024)  # bytes, in Python 3.
        return g.is_binary_string(s)
    except IOError:
        return False
    except Exception:
        g.es_exception()
        return False

def is_binary_string(s):
    # http://stackoverflow.com/questions/898669
    # aList is a list of all non-binary characters.
    aList = [7, 8, 9, 10, 12, 13, 27] + list(range(0x20, 0x100))
    aList = bytes(aList)
    return bool(s.translate(None, aList))
#@+node:EKR.20040504154039: *6* g.is_sentinel
def is_sentinel(line, delims):
    """Return True if line starts with a sentinel comment."""
    delim1, delim2, delim3 = delims
    line = line.lstrip()
    if delim1:
        return line.startswith(delim1 + '@')
    if delim2 and delim3:
        i = line.find(delim2 + '@')
        j = line.find(delim3)
        return 0 == i < j
    g.error(f"is_sentinel: can not happen. delims: {repr(delims)}")
    return False
#@+node:ekr.20031218072017.3119: *6* g.makeAllNonExistentDirectories
def makeAllNonExistentDirectories(theDir):
    """
    A wrapper from os.makedirs.
    Attempt to make all non-existent directories.

    Return True if the directory exists or was created successfully.
    """
    # Return True if the directory already exists.
    theDir = g.os_path_normpath(theDir)
    ok = g.os_path_isdir(theDir) and g.os_path_exists(theDir)
    if ok:
        return theDir
    # #1450: Create the directory with os.makedirs.
    try:
        os.makedirs(theDir, mode=0o777, exist_ok=False)
        return theDir
    except Exception:
        return None
#@+node:ekr.20071114113736: *6* g.makePathRelativeTo
def makePathRelativeTo(fullPath, basePath):
    if fullPath.startswith(basePath):
        s = fullPath[len(basePath) :]
        if s.startswith(os.path.sep):
            s = s[len(os.path.sep) :]
        return s
    return fullPath
#@+node:ekr.20090520055433.5945: *6* g.openWithFileName
def openWithFileName(fileName, old_c=None, gui=None):
    """Create a Leo Frame for the indicated fileName if the file exists.

    returns the commander of the newly-opened outline.
    """
    return g.app.loadManager.loadLocalFile(fileName, gui, old_c)
#@+node:ekr.20150306035851.7: *6* g.readFileIntoEncodedString
def readFileIntoEncodedString(fn, silent=False):
    """Return the raw contents of the file whose full path is fn."""
    try:
        with open(fn, 'rb') as f:
            return f.read()
    except IOError:
        if not silent:
            g.error('can not open', fn)
    except Exception:
        if not silent:
            g.error(f"readFileIntoEncodedString: exception reading {fn}")
            g.es_exception()
    return None
#@+node:ekr.20100125073206.8710: *6* g.readFileIntoString
def readFileIntoString(fileName,
    encoding='utf-8',  # BOM may override this.
    kind=None,  # @file, @edit, ...
    verbose=True,
):
    """
    Return the contents of the file whose full path is fileName.

    Return (s,e)
    s is the string, converted to unicode, or None if there was an error.
    e is the encoding of s, computed in the following order:
    - The BOM encoding if the file starts with a BOM mark.
    - The encoding given in the # -*- coding: utf-8 -*- line for python files.
    - The encoding given by the 'encoding' keyword arg.
    - None, which typically means 'utf-8'.
    """
    if not fileName:
        if verbose: g.trace('no fileName arg given')
        return None, None
    if g.os_path_isdir(fileName):
        if verbose: g.trace('not a file:', fileName)
        return None, None
    if not g.os_path_exists(fileName):
        if verbose: g.error('file not found:', fileName)
        return None, None
    try:
        e = None
        with open(fileName, 'rb') as f:
            s = f.read()
        # Fix #391.
        if not s:
            return '', None
        # New in Leo 4.11: check for unicode BOM first.
        e, s = g.stripBOM(s)
        if not e:
            # Python's encoding comments override everything else.
            junk, ext = g.os_path_splitext(fileName)
            if ext == '.py':
                e = g.getPythonEncodingFromString(s)
        s = g.toUnicode(s, encoding=e or encoding)
        return s, e
    except IOError:
        # Translate 'can not open' and kind, but not fileName.
        if verbose:
            g.error('can not open', '', (kind or ''), fileName)
    except Exception:
        g.error(f"readFileIntoString: unexpected exception reading {fileName}")
        g.es_exception()
    return None, None
#@+node:ekr.20160504062833.1: *6* g.readFileToUnicodeString
def readFileIntoUnicodeString(fn, encoding=None, silent=False):
    """Return the raw contents of the file whose full path is fn."""
    try:
        with open(fn, 'rb') as f:
            s = f.read()
        return g.toUnicode(s, encoding=encoding)
    except IOError:
        if not silent:
            g.error('can not open', fn)
    except Exception:
        g.error(f"readFileIntoUnicodeString: unexpected exception reading {fn}")
        g.es_exception()
    return None
#@+node:ekr.20031218072017.3120: *6* g.readlineForceUnixNewline
@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim,
while the windows versions force the string to use the Unix convention
of using only "\n". This routine causes the Unix readline to do the
same.
@c

def readlineForceUnixNewline(f, fileName=None):
    try:
        s = f.readline()
    except UnicodeDecodeError:
        g.trace(f"UnicodeDecodeError: {fileName}", f, g.callers())
        s = ''
    if len(s) >= 2 and s[-2] == "\r" and s[-1] == "\n":
        s = s[0:-2] + "\n"
    return s
#@+node:ekr.20031218072017.3124: *6* g.sanitize_filename
def sanitize_filename(s):
    """
    Prepares string s to be a valid file name:

    - substitute '_' for whitespace and special path characters.
    - eliminate all other non-alphabetic characters.
    - convert double quotes to single quotes.
    - strip leading and trailing whitespace.
    - return at most 128 characters.
    """
    result = []
    for ch in s:
        if ch in string.ascii_letters:
            result.append(ch)
        elif ch == '\t':
            result.append(' ')
        elif ch == '"':
            result.append("'")
        elif ch in '\\/:|<>*:._':
            result.append('_')
    s = ''.join(result).strip()
    while len(s) > 1:
        n = len(s)
        s = s.replace('__', '_')
        if len(s) == n:
            break
    return s[:128]
#@+node:ekr.20060328150113: *6* g.setGlobalOpenDir
def setGlobalOpenDir(fileName):
    if fileName:
        g.app.globalOpenDir = g.os_path_dirname(fileName)
        # g.es('current directory:',g.app.globalOpenDir)
#@+node:ekr.20031218072017.3125: *6* g.shortFileName & shortFilename
def shortFileName(fileName, n=None):
    """Return the base name of a path."""
    if n is not None:
        g.trace('"n" keyword argument is no longer used')
    return g.os_path_basename(fileName) if fileName else ''

shortFilename = shortFileName
#@+node:ekr.20150610125813.1: *6* g.splitLongFileName
def splitLongFileName(fn, limit=40):
    """Return fn, split into lines at slash characters."""
    aList = fn.replace('\\', '/').split('/')
    n, result = 0, []
    for i, s in enumerate(aList):
        n += len(s)
        result.append(s)
        if i + 1 < len(aList):
            result.append('/')
            n += 1
        if n > limit:
            result.append('\n')
            n = 0
    return ''.join(result)
#@+node:ekr.20050104135720: *6* g.Used by tangle code & leoFileCommands
#@+node:ekr.20050104123726.3: *7* g.utils_remove
def utils_remove(fileName, verbose=True):
    try:
        os.remove(fileName)
        return True
    except Exception:
        if verbose:
            g.es("exception removing:", fileName)
            g.es_exception()
        return False
#@+node:ekr.20031218072017.1263: *7* g.utils_rename
def utils_rename(c, src, dst, verbose=True):
    """Platform independent rename."""
    # Don't call g.makeAllNonExistentDirectories here!
    try:
        shutil.move(src, dst)
        return True
    except Exception:
        if verbose:
            g.error('exception renaming', src, 'to', dst)
            g.es_exception(full=False)
        return False
#@+node:ekr.20050104124903: *7* g.utils_chmod
def utils_chmod(fileName, mode, verbose=True):
    if mode is None:
        return
    try:
        os.chmod(fileName, mode)
    except Exception:
        if verbose:
            g.es("exception in os.chmod", fileName)
            g.es_exception()
#@+node:ekr.20050104123726.4: *7* g.utils_stat
def utils_stat(fileName):
    """Return the access mode of named file, removing any setuid, setgid, and sticky bits."""
    try:
        mode = (os.stat(fileName))[0] & (7 * 8 * 8 + 7 * 8 + 7)  # 0777
    except Exception:
        mode = None
    return mode
#@+node:ekr.20190114061452.26: *6* g.writeFile
def writeFile(contents, encoding, fileName):
    """Create a file with the given contents."""
    try:
        if g.isUnicode(contents):
            contents = g.toEncodedString(contents, encoding=encoding)
        # 'wb' preserves line endings.
        with open(fileName, 'wb') as f:
            f.write(contents)
        return True
    except Exception as e:
        print(f"exception writing: {fileName}:\n{e}")
        # g.trace(g.callers())
        # g.es_exception()
        return False
#@+node:ekr.20031218072017.3151: *5* g.Finding & Scanning
#@+node:ekr.20140602083643.17659: *6* g.find_word
def find_word(s, word, i=0):
    """
    Return the index of the first occurance of word in s, or -1 if not found.

    g.find_word is *not* the same as s.find(i,word);
    g.find_word ensures that only word-matches are reported.
    """
    while i < len(s):
        progress = i
        i = s.find(word, i)
        if i == -1:
            return -1
        # Make sure we are at the start of a word.
        if i > 0:
            ch = s[i - 1]
            if ch == '_' or ch.isalnum():
                i += len(word)
                continue
        if g.match_word(s, i, word):
            return i
        i += len(word)
        assert progress < i
    return -1
#@+node:ekr.20170220103251.1: *6* g.findRootsWithPredicate
def findRootsWithPredicate(c, root, predicate=None):
    """
    Commands often want to find one or more **roots**, given a position p.
    A root is the position of any node matching a predicate.

    This function formalizes the search order used by the black,
    pylint, pyflakes and the rst3 commands, returning a list of zero
    or more found roots.
    """
    seen = []
    roots = []
    if predicate is None:

        # A useful default predicate for python.
        # pylint: disable=function-redefined

        def predicate(p):
            return p.isAnyAtFileNode() and p.h.strip().endswith('.py')

    # 1. Search p's tree.
    for p in root.self_and_subtree(copy=False):
        if predicate(p) and p.v not in seen:
            seen.append(p.v)
            roots.append(p.copy())
    if roots:
        return roots
    # 2. Look up the tree.
    for p in root.parents():
        if predicate(p):
            return [p.copy()]
    # 3. Expand the search if root is a clone.
    clones = []
    for p in root.self_and_parents(copy=False):
        if p.isCloned():
            clones.append(p.v)
    if clones:
        for p in c.all_positions(copy=False):
            if predicate(p):
                # Match if any node in p's tree matches any clone.
                for p2 in p.self_and_subtree():
                    if p2.v in clones:
                        return [p.copy()]
    return []
#@+node:tbrown.20140311095634.15188: *6* g.recursiveUNLSearch & helper
def recursiveUNLSearch(unlList, c, depth=0, p=None, maxdepth=0, maxp=None,
                       soft_idx=False, hard_idx=False):
    """try and move to unl in the commander c

    All parameters passed on to recursiveUNLFind(), see that for docs.

    NOTE: maxdepth is max depth seen in recursion so far, not a limit on
          how far we will recurse.  So it should default to 0 (zero).
    """
    if g.unitTesting:
        g.app.unitTestDict['g.recursiveUNLSearch'] = True
        return True, maxdepth, maxp

    def moveToP(c, p, unlList):
        # Process events, to calculate new sizes.
        g.app.gui.qtApp.processEvents()
        c.expandAllAncestors(p)
        c.selectPosition(p)
        nth_sib, nth_same, nth_line_no, nth_col_no = recursiveUNLParts(unlList[-1])
        if nth_line_no:
            if nth_line_no < 0:
                c.goToLineNumber(-nth_line_no)
                if nth_col_no:
                    pos = c.frame.body.wrapper.getInsertPoint() + nth_col_no
                    c.frame.body.wrapper.setInsertPoint(pos)
            else:
                pos = sum(len(i) + 1 for i in p.b.split('\n')[: nth_line_no - 1])
                if nth_col_no:
                    pos += nth_col_no
                c.frame.body.wrapper.setInsertPoint(pos)
        if p.hasChildren():
            p.expand()
        c.redraw()
        c.frame.bringToFront()
        c.bodyWantsFocusNow()
    
    found, maxdepth, maxp = recursiveUNLFind(
        unlList, c, depth, p, maxdepth, maxp, soft_idx=soft_idx, hard_idx=hard_idx)
    if maxp:
        moveToP(c, maxp, unlList)
    return found, maxdepth, maxp
#@+node:ekr.20140711071454.17654: *7* g.recursiveUNLFind
def recursiveUNLFind(unlList, c, depth=0, p=None, maxdepth=0, maxp=None,
                     soft_idx=False, hard_idx=False):
    """
    Internal part of recursiveUNLSearch which doesn't change the
    selected position or call c.frame.bringToFront()

    returns found, depth, p, where:

        - found is True if a full match was found
        - depth is the depth of the best match
        - p is the position of the best match

    NOTE: maxdepth is max depth seen in recursion so far, not a limit on
          how far we will recurse.  So it should default to 0 (zero).

    - `unlList`: list of 'headline', 'headline:N', or 'headline:N,M'
      elements, where N is the node's position index and M the zero based
      count of like named nodes, eg. 'foo:2', 'foo:4,1', 'foo:12,3'
    - `c`: outline
    - `soft_idx`: use index when matching name not found
    - `hard_idx`: use only indexes, ignore node names
    - `depth`: part of recursion, don't set explicitly
    - `p`: part of recursion, don't set explicitly
    - `maxdepth`: part of recursion, don't set explicitly
    - `maxp`: part of recursion, don't set explicitly
    """
    if depth == 0:
        nds = list(c.rootPosition().self_and_siblings())
        unlList = [i.replace('--%3E', '-->') for i in unlList if i.strip()]
        # drop empty parts so "-->node name" works
    else:
        nds = list(p.children())
    heads = [i.h for i in nds]
    # work out order in which to try nodes
    order = []
    nth_sib = nth_same = nth_line_no = nth_col_no = None
    try:
        target = unlList[depth]
    except IndexError:
        target = ''
    try:
        target = g_pos_pattern.sub('', unlList[depth])
        nth_sib, nth_same, nth_line_no, nth_col_no = recursiveUNLParts(unlList[depth])
        pos = nth_sib is not None
    except IndexError:
        # #36.
        pos = False
    if pos:
        use_idx_mode = True  # ok to use hard/soft_idx
        target = re.sub(g_pos_pattern, "", target).replace('--%3E', '-->')
        if hard_idx:
            if nth_sib < len(heads):
                order.append(nth_sib)
        else:
            # First we try the nth node with same header
            if nth_same:
                nths = [n for n, i in enumerate(heads) if i == target]
                if nth_same < len(nths) and heads[nths[nth_same]] == target:
                    order.append(nths[nth_same])
            # Then we try *all* other nodes with same header
            order += [n for n, s in enumerate(heads)
                        if n not in order and s == target]
            # Then position based, if requested
            if soft_idx and nth_sib < len(heads):
                order.append(nth_sib)
    elif hard_idx:
        pass  # hard_idx mode with no idx in unl, go with empty order list
    else:
        order = range(len(nds))
        target = target.replace('--%3E', '-->')
        use_idx_mode = False  # not ok to use hard/soft_idx
        # note, the above also fixes calling with soft_idx=True and an old UNL

    for ndi in order:
        nd = nds[ndi]
        if (
            target == nd.h or
            (use_idx_mode and (soft_idx or hard_idx) and ndi == nth_sib)
        ):
            if depth + 1 == len(unlList):  # found it
                return True, maxdepth, nd
            if maxdepth < depth + 1:
                maxdepth = depth + 1
                maxp = nd.copy()
            found, maxdepth, maxp = g.recursiveUNLFind(
                unlList, c, depth + 1, nd,
                maxdepth, maxp, soft_idx=soft_idx, hard_idx=hard_idx)
            if found:
                return found, maxdepth, maxp
            # else keep looking through nds
    if depth == 0 and maxp:  # inexact match
        g.es('Partial UNL match')
    if soft_idx and depth + 2 < len(unlList):
        aList = []
        for p in c.all_unique_positions():
            if any([p.h.replace('--%3E', '-->') in unl for unl in unlList]):
                aList.append((p.copy(), p.get_UNL(False, False, True)))
        maxcount = 0
        singleMatch = True
        for iter_unl in aList:
            count = 0
            compare_list = unlList[:]
            for header in reversed(iter_unl[1].split('-->')):
                if (re.sub(g_pos_pattern, "", header).replace('--%3E', '-->') ==
                     compare_list[-1]
                ):
                    count = count + 1
                    compare_list.pop(-1)
                else:
                    break
            if count > maxcount:
                p = iter_unl[0]
                singleMatch = True
            elif count == maxcount:
                singleMatch = False
        if maxcount and singleMatch:
            maxp = p
            maxdepth = p.level()
    return False, maxdepth, maxp
#@+node:tbrown.20171221094755.1: *7* g.recursiveUNLParts
def recursiveUNLParts(text):
    """recursiveUNLParts - return index, occurence, line_number, col_number
    from an UNL fragment.  line_number is allowed to be negative to indicate
    a "global" line number within the file.

    :param str text: the fragment, foo or foo:2 or foo:2,0,4,10
    :return: index, occurence, line_number, col_number
    :rtype: (int, int, int, int) or (None, None, None, None)
    """
    pos = re.findall(g_pos_pattern, text)
    if pos:
        return tuple(int(i) if i else 0 for i in pos[0])
    return (None, None, None, None)
#@+node:ekr.20031218072017.3156: *6* g.scanError
# It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):
    """Bump the error count in the tangle command."""
    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors += 1
    g.es('', s)
#@+node:ekr.20031218072017.3157: *6* g.scanf
# A quick and dirty sscanf.  Understands only %s and %d.

def scanf(s, pat):
    count = pat.count("%s") + pat.count("%d")
    pat = pat.replace("%s", r"(\S+)")
    pat = pat.replace("%d", r"(\d+)")
    parts = re.split(pat, s)
    result = []
    for part in parts:
        if part and len(result) < count:
            result.append(part)
    return result
#@+node:ekr.20031218072017.3195: *6* g.splitLines & g.joinLines
def splitLines(s):
    """Split s into lines, preserving the number of lines and
    the endings of all lines, including the last line."""
    # g.stat()
    if s:
        return s.splitlines(True)
            # This is a Python string function!
    return []

splitlines = splitLines

def joinLines(aList):
    return ''.join(aList)

joinlines = joinLines
#@+node:ekr.20031218072017.3158: *6* Scanners: calling scanError
@ These scanners all call g.scanError() directly or indirectly, so they
will call g.es if they find an error. g.scanError() also bumps
c.tangleCommands.errors, which is harmless if we aren't tangling, and
useful if we are.

These routines are called by the Import routines and the Tangle routines.
#@+node:ekr.20031218072017.3159: *7* skip_block_comment
# Scans past a block comment (an old_style C comment).

def skip_block_comment(s, i):
    assert(g.match(s, i, "/*"))
    j = i; i += 2; n = len(s)
    k = s.find("*/", i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    return k + 2
#@+node:ekr.20031218072017.3160: *7* skip_braces
@ This code is called only from the import logic, so we are allowed to
try some tricks. In particular, we assume all braces are matched in
if blocks.
@c

def skip_braces(s, i):
    """
    Skips from the opening to the matching brace.

    If no matching is found i is set to len(s)
    """
    # start = g.get_line(s,i)
    assert(g.match(s, i, '{'))
    level = 0; n = len(s)
    while i < n:
        c = s[i]
        if c == '{':
            level += 1; i += 1
        elif c == '}':
            level -= 1
            if level <= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s, i)
        elif g.match(s, i, '//'): i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, '/*'): i = g.skip_block_comment(s, i)
        # 7/29/02: be more careful handling conditional code.
        elif (
            g.match_word(s, i, "#if") or
            g.match_word(s, i, "#ifdef") or
            g.match_word(s, i, "#ifndef")
        ):
            i, delta = g.skip_pp_if(s, i)
            level += delta
        else: i += 1
    return i
#@+node:ekr.20031218072017.3162: *7* skip_parens
def skip_parens(s, i):
    """
    Skips from the opening ( to the matching ).

    If no matching is found i is set to len(s).
    """
    level = 0; n = len(s)
    assert g.match(s, i, '('), repr(s[i])
    while i < n:
        c = s[i]
        if c == '(':
            level += 1; i += 1
        elif c == ')':
            level -= 1
            if level <= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s, i)
        elif g.match(s, i, "//"): i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, "/*"): i = g.skip_block_comment(s, i)
        else: i += 1
    return i
#@+node:ekr.20031218072017.3163: *7* skip_pascal_begin_end
def skip_pascal_begin_end(s, i):
    """
    Skips from begin to matching end.
    If found, i points to the end. Otherwise, i >= len(s)
    The end keyword matches begin, case, class, record, and try.
    """
    assert(g.match_c_word(s, i, "begin"))
    level = 1; i = g.skip_c_id(s, i)  # Skip the opening begin.
    while i < len(s):
        ch = s[i]
        if ch == '{':
            i = g.skip_pascal_braces(s, i)
        elif ch == '"' or ch == '\'':
            i = g.skip_pascal_string(s, i)
        elif g.match(s, i, "//"):
            i = g.skip_line(s, i)
        elif g.match(s, i, "(*"):
            i = g.skip_pascal_block_comment(s, i)
        elif g.match_c_word(s, i, "end"):
            level -= 1
            if level == 0:
                return i
            i = g.skip_c_id(s, i)
        elif g.is_c_id(ch):
            j = i; i = g.skip_c_id(s, i); name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else:
            i += 1
    return i
#@+node:ekr.20031218072017.3164: *7* skip_pascal_block_comment
# Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s, i):
    j = i
    assert(g.match(s, i, "(*"))
    i = s.find("*)", i)
    if i > -1:
        return i + 2
    g.scanError("Run on comment" + s[j:i])
    return len(s)
#@+node:ekr.20031218072017.3165: *7* skip_pascal_string : called by tangle
def skip_pascal_string(s, i):
    j = i; delim = s[i]; i += 1
    assert(delim == '"' or delim == '\'')
    while i < len(s):
        if s[i] == delim:
            return i + 1
        i += 1
    g.scanError("Run on string: " + s[j:i])
    return i
#@+node:ekr.20031218072017.3166: *7* skip_heredoc_string : called by php import (Dave Hein)
@ 08-SEP-2002 DTHEIN:  added function skip_heredoc_string
A heredoc string in PHP looks like:

  <<<EOS
  This is my string.
  It is mine. I own it.
  No one else has it.
  EOS

It begins with <<< plus a token (naming same as PHP variable names).
It ends with the token on a line by itself (must start in first position.
@c

def skip_heredoc_string(s, i):
    j = i
    assert(g.match(s, i, "<<<"))
    m = re.match(r"\<\<\<([a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*)", s[i:])
    if m is None:
        i += 3
        return i
    # 14-SEP-2002 DTHEIN: needed to add \n to find word, not just string
    delim = m.group(1) + '\n'
    i = g.skip_line(s, i)  # 14-SEP-2002 DTHEIN: look after \n, not before
    n = len(s)
    while i < n and not g.match(s, i, delim):
        i = g.skip_line(s, i)  # 14-SEP-2002 DTHEIN: move past \n
    if i >= n:
        g.scanError("Run on string: " + s[j:i])
    elif g.match(s, i, delim):
        i += len(delim)
    return i
#@+node:ekr.20031218072017.3167: *7* skip_pp_directive
# Now handles continuation lines and block comments.

def skip_pp_directive(s, i):
    while i < len(s):
        if g.is_nl(s, i):
            if g.escaped(s, i): i = g.skip_nl(s, i)
            else: break
        elif g.match(s, i, "//"): i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, "/*"): i = g.skip_block_comment(s, i)
        else: i += 1
    return i
#@+node:ekr.20031218072017.3168: *7* skip_pp_if
# Skips an entire if or if def statement, including any nested statements.

def skip_pp_if(s, i):
    start_line = g.get_line(s, i)  # used for error messages.
    assert(
        g.match_word(s, i, "#if") or
        g.match_word(s, i, "#ifdef") or
        g.match_word(s, i, "#ifndef"))
    i = g.skip_line(s, i)
    i, delta1 = g.skip_pp_part(s, i)
    i = g.skip_ws(s, i)
    if g.match_word(s, i, "#else"):
        i = g.skip_line(s, i)
        i = g.skip_ws(s, i)
        i, delta2 = g.skip_pp_part(s, i)
        if delta1 != delta2:
            g.es("#if and #else parts have different braces:", start_line)
    i = g.skip_ws(s, i)
    if g.match_word(s, i, "#endif"):
        i = g.skip_line(s, i)
    else:
        g.es("no matching #endif:", start_line)
    return i, delta1
#@+node:ekr.20031218072017.3169: *7* skip_pp_part
# Skip to an #else or #endif.  The caller has eaten the #if, #ifdef, #ifndef or #else

def skip_pp_part(s, i):

    delta = 0
    while i < len(s):
        c = s[i]
        if (
            g.match_word(s, i, "#if") or
            g.match_word(s, i, "#ifdef") or
            g.match_word(s, i, "#ifndef")
        ):
            i, delta1 = g.skip_pp_if(s, i)
            delta += delta1
        elif g.match_word(s, i, "#else") or g.match_word(s, i, "#endif"):
            return i, delta
        elif c == '\'' or c == '"': i = g.skip_string(s, i)
        elif c == '{':
            delta += 1; i += 1
        elif c == '}':
            delta -= 1; i += 1
        elif g.match(s, i, "//"): i = g.skip_line(s, i)
        elif g.match(s, i, "/*"): i = g.skip_block_comment(s, i)
        else: i += 1
    return i, delta
#@+node:ekr.20031218072017.3170: *7* skip_python_string
def skip_python_string(s, i, verbose=True):
    if g.match(s, i, "'''") or g.match(s, i, '"""'):
        j = i; delim = s[i] * 3; i += 3
        k = s.find(delim, i)
        if k > -1: return k + 3
        if verbose:
            g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    # 2013/09/08: honor the verbose argument.
    return g.skip_string(s, i, verbose=verbose)
#@+node:ekr.20031218072017.2369: *7* skip_string (leoGlobals)
def skip_string(s, i, verbose=True):
    """
    Scan forward to the end of a string.
    New in Leo 4.4.2 final: give error only if verbose is True.
    """
    j = i; delim = s[i]; i += 1
    assert(delim == '"' or delim == '\'')
    n = len(s)
    while i < n and s[i] != delim:
        if s[i] == '\\': i += 2
        else: i += 1
    if i >= n:
        if verbose:
            g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1
    return i
#@+node:ekr.20031218072017.3171: *7* skip_to_semicolon
# Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s, i):
    n = len(s)
    while i < n:
        c = s[i]
        if c == ';':
            return i
        if c == '\'' or c == '"':
            i = g.skip_string(s, i)
        elif g.match(s, i, "//"):
            i = g.skip_to_end_of_line(s, i)
        elif g.match(s, i, "/*"):
            i = g.skip_block_comment(s, i)
        else:
            i += 1
    return i
#@+node:ekr.20031218072017.3172: *7* skip_typedef
def skip_typedef(s, i):
    n = len(s)
    while i < n and g.is_c_id(s[i]):
        i = g.skip_c_id(s, i)
        i = g.skip_ws_and_nl(s, i)
    if g.match(s, i, '{'):
        i = g.skip_braces(s, i)
        i = g.skip_to_semicolon(s, i)
    return i
#@+node:ekr.20031218072017.3173: *6* Scanners: no error messages
#@+node:ekr.20031218072017.3174: *7* escaped
# Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s, i):
    count = 0
    while i - 1 >= 0 and s[i - 1] == '\\':
        count += 1
        i -= 1
    return (count % 2) == 1
#@+node:ekr.20031218072017.3175: *7* find_line_start
def find_line_start(s, i):
    """Return the index in s of the start of the line containing s[i]."""
    if i < 0:
        return 0  # New in Leo 4.4.5: add this defensive code.
    # bug fix: 11/2/02: change i to i+1 in rfind
    i = s.rfind('\n', 0, i + 1)  # Finds the highest index in the range.
    return 0 if i == -1 else i + 1
    # if i == -1: return 0
    # else: return i + 1
#@+node:ekr.20031218072017.3176: *7* find_on_line
def find_on_line(s, i, pattern):
    j = s.find('\n', i)
    if j == -1: j = len(s)
    k = s.find(pattern, i, j)
    return k
#@+node:ekr.20031218072017.3177: *7* is_c_id
def is_c_id(ch):
    return g.isWordChar(ch)
#@+node:ekr.20031218072017.3178: *7* is_nl
def is_nl(s, i):
    return i < len(s) and (s[i] == '\n' or s[i] == '\r')
#@+node:ekr.20031218072017.3179: *7* g.is_special
def is_special(s, directive):
    """Return True if the body text contains the @ directive."""
    assert(directive and directive[0] == '@')
    lws = directive in ("@others", "@all")
        # Most directives must start the line.
    pattern = r'^\s*(%s\b)' if lws else r'^(%s\b)'
    pattern = re.compile(pattern % directive, re.MULTILINE)
    m = re.search(pattern, s)
    if m:
        return True, m.start(1)
    return False, -1
#@+node:ekr.20031218072017.3180: *7* is_ws & is_ws_or_nl
def is_ws(c):
    return c == '\t' or c == ' '

def is_ws_or_nl(s, i):
    return g.is_nl(s, i) or (i < len(s) and g.is_ws(s[i]))
#@+node:ekr.20031218072017.3181: *7* match
# Warning: this code makes no assumptions about what follows pattern.

def match(s, i, pattern):
    return s and pattern and s.find(pattern, i, i + len(pattern)) == i
#@+node:ekr.20031218072017.3182: *7* match_c_word
def match_c_word(s, i, name):
    n = len(name)
    return (
        name and
        name == s[i : i + n] and
        (i + n == len(s) or not g.is_c_id(s[i + n]))
    )
#@+node:ekr.20031218072017.3183: *7* match_ignoring_case
def match_ignoring_case(s1, s2):
    return s1 and s2 and s1.lower() == s2.lower()
#@+node:ekr.20031218072017.3184: *7* g.match_word
def match_word(s, i, pattern):

    # Using a regex is surprisingly tricky.
    if pattern is None:
        return False
    if i > 0 and g.isWordChar(s[i - 1]):  # Bug fix: 2017/06/01.
        return False
    j = len(pattern)
    if j == 0:
        return False
    if s.find(pattern, i, i + j) != i:
        return False
    if i + j >= len(s):
        return True
    ch = s[i + j]
    return not g.isWordChar(ch)
#@+node:ekr.20031218072017.3185: *7* skip_blank_lines
# This routine differs from skip_ws_and_nl in that
# it does not advance over whitespace at the start
# of a non-empty or non-nl terminated line

def skip_blank_lines(s, i):
    while i < len(s):
        if g.is_nl(s, i):
            i = g.skip_nl(s, i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s, i)
            if g.is_nl(s, j):
                i = j
            else: break
        else: break
    return i
#@+node:ekr.20031218072017.3186: *7* skip_c_id
def skip_c_id(s, i):
    n = len(s)
    while i < n and g.isWordChar(s[i]):
        i += 1
    return i
#@+node:ekr.20040705195048: *7* skip_id
def skip_id(s, i, chars=None):
    chars = g.toUnicode(chars) if chars else ''
    n = len(s)
    while i < n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i
#@+node:ekr.20031218072017.3187: *7* skip_line, skip_to_start/end_of_line
@ These methods skip to the next newline, regardless of whether the
newline may be preceeded by a backslash. Consequently, they should be
used only when we know that we are not in a preprocessor directive or
string.
@c

def skip_line(s, i):
    if i >= len(s):
        return len(s)
    if i < 0: i = 0
    i = s.find('\n', i)
    if i == -1:
        return len(s)
    return i + 1

def skip_to_end_of_line(s, i):
    if i >= len(s):
        return len(s)
    if i < 0: i = 0
    i = s.find('\n', i)
    if i == -1:
        return len(s)
    return i

def skip_to_start_of_line(s, i):
    if i >= len(s):
        return len(s)
    if i <= 0:
        return 0
    # Don't find s[i], so it doesn't matter if s[i] is a newline.
    i = s.rfind('\n', 0, i)
    if i == -1:
        return 0
    return i + 1
#@+node:ekr.20031218072017.3188: *7* skip_long
def skip_long(s, i):
    """
    Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """
    val = 0
    i = g.skip_ws(s, i)
    n = len(s)
    if i >= n or (not s[i].isdigit() and s[i] not in '+-'):
        return i, None
    j = i
    if s[i] in '+-':  # Allow sign before the first digit
        i += 1
    while i < n and s[i].isdigit():
        i += 1
    try:  # There may be no digits.
        val = int(s[j:i])
        return i, val
    except Exception:
        return i, None
#@+node:ekr.20031218072017.3190: *7* skip_nl
# We need this function because different systems have different end-of-line conventions.

def skip_nl(s, i):
    """Skips a single "logical" end-of-line character."""
    if g.match(s, i, "\r\n"):
        return i + 2
    if g.match(s, i, '\n') or g.match(s, i, '\r'):
        return i + 1
    return i
#@+node:ekr.20031218072017.3191: *7* skip_non_ws
def skip_non_ws(s, i):
    n = len(s)
    while i < n and not g.is_ws(s[i]):
        i += 1
    return i
#@+node:ekr.20031218072017.3192: *7* skip_pascal_braces
# Skips from the opening { to the matching }.

def skip_pascal_braces(s, i):
    # No constructs are recognized inside Pascal block comments!
    if i == -1:
        return len(s)
    return s.find('}', i)
#@+node:ekr.20031218072017.3193: *7* skip_to_char
def skip_to_char(s, i, ch):
    j = s.find(ch, i)
    if j == -1:
        return len(s), s[i:]
    return j, s[i:j]
#@+node:ekr.20031218072017.3194: *7* skip_ws, skip_ws_and_nl
def skip_ws(s, i):
    n = len(s)
    while i < n and g.is_ws(s[i]):
        i += 1
    return i

def skip_ws_and_nl(s, i):
    n = len(s)
    while i < n and (g.is_ws(s[i]) or g.is_nl(s, i)):
        i += 1
    return i
#@+node:ekr.20170414034616.1: *5* g.Git
#@+node:ekr.20180325025502.1: *6* g.backupGitIssues
def backupGitIssues(c, base_url=None):
    """Get a list of issues from Leo's GitHub site."""
    import time

    if base_url is None:
        base_url = 'https://api.github.com/repos/leo-editor/leo-editor/issues'

    root = c.lastTopLevel().insertAfter()
    root.h = f'Backup of issues: {time.strftime("%Y/%m/%d")}'
    label_list = []
    GitIssueController().backup_issues(base_url, c, label_list, root)
    root.expand()
    c.selectPosition(root)
    c.redraw()
    g.trace('done')
#@+node:ekr.20170616102324.1: *6* g.execGitCommand
def execGitCommand(command, directory=None):
    """Execute the given git command in the given directory."""
    git_dir = g.os_path_finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir)
        return []
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n', '')
    if directory:
        os.chdir(directory)
    p = subprocess.Popen(
        shlex.split(command),
        stdout=subprocess.PIPE,
        stderr=None,  # Shows error traces.
        shell=False,
    )
    out, err = p.communicate()
    lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    return lines
#@+node:ekr.20180126043905.1: *6* g.getGitIssues
def getGitIssues(c,
    base_url=None,
    label_list=None,
    milestone=None,
    state=None,  # in (None, 'closed', 'open')
):
    """Get a list of issues from Leo's GitHub site."""
    if base_url is None:
        base_url = 'https://api.github.com/repos/leo-editor/leo-editor/issues'
    if isinstance(label_list, (list, tuple)):
        root = c.lastTopLevel().insertAfter()
        root.h = 'Issues for ' + milestone if milestone else 'Backup'
        GitIssueController().backup_issues(base_url, c, label_list, root)
        root.expand()
        c.selectPosition(root)
        c.redraw()
        g.trace('done')
    else:
        g.trace('label_list must be a list or tuple', repr(label_list))
#@+node:ekr.20180126044602.1: *7* class GitIssueController
class GitIssueController:
    """
    A class encapsulating the retrieval of GitHub issues.
    
    The GitHub api: https://developer.github.com/v3/issues/
    """
    @others
#@+node:ekr.20180325023336.1: *8* git.backup_issues
def backup_issues(self, base_url, c, label_list, root, state=None):

    self.base_url = base_url
    self.root = root
    self.milestone = None
    if label_list:
        for state in ('closed', 'open'):
            for label in label_list:
                self.get_one_issue(label, state)
    elif state is None:
        for state in ('closed', 'open'):
            organizer = root.insertAsLastChild()
            organizer.h = f"{state} issues..."
            self.get_all_issues(label_list, organizer, state)
    elif state in ('closed', 'open'):
        self.get_all_issues(label_list, root, state)
    else:
        g.es_print('state must be in (None, "open", "closed")')
#@+node:ekr.20180325024334.1: *8* git.get_all_issues
def get_all_issues(self, label_list, root, state, limit=100):
    """Get all issues for the base url."""
    import requests
    label = None
    assert state in ('open', 'closed')
    page_url = self.base_url + '?&state=%s&page=%s'
    page, total = 1, 0
    while True:
        url = page_url % (state, page)
        r = requests.get(url)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # Do not remove this trace. It's reassuring.
            g.trace(f"done: {done:5} page: {page:3} found: {n} label: {label}")
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page > limit:
            g.trace('too many pages')
            break
#@+node:ekr.20180126044850.1: *8* git.get_issues
def get_issues(self, base_url, label_list, milestone, root, state):
    """Create a list of issues for each label in label_list."""
    self.base_url = base_url
    self.milestone = milestone
    self.root = root
    for label in label_list:
        self.get_one_issue(label, state)
#@+node:ekr.20180126043719.3: *8* git.get_one_issue
def get_one_issue(self, label, state, limit=20):
    """Create a list of issues with the given label."""
    import requests
    root = self.root.insertAsLastChild()
    page, total = 1, 0
    page_url = self.base_url + '?labels=%s&state=%s&page=%s'
    while True:
        url = page_url % (label, state, page)
        r = requests.get(url)
        try:
            done, n = self.get_one_page(label, page, r, root)
            # Do not remove this trace. It's reassuring.
            g.trace(f"done: {done:5} page: {page:3} found: {n:3} label: {label}")
        except AttributeError:
            g.trace('Possible rate limit')
            self.print_header(r)
            g.es_exception()
            break
        total += n
        if done:
            break
        page += 1
        if page > limit:
            g.trace('too many pages')
            break
    state = state.capitalize()
    if self.milestone:
        root.h = f"{total} {state} {label} issues for milestone {self.milestone}"
    else:
        root.h = f"{total} {state} {label} issues"
#@+node:ekr.20180126043719.4: *8* git.get_one_page
def get_one_page(self, label, page, r, root):

    if self.milestone:
        aList = [
            z for z in r.json()
                if z.get('milestone') is not None and
                    self.milestone == z.get('milestone').get('title')
        ]
    else:
        aList = [z for z in r.json()]
    for d in aList:
        n, title = d.get('number'), d.get('title')
        html_url = d.get('html_url') or self.base_url
        p = root.insertAsNthChild(0)
        p.h = f"#{n}: {title}"
        p.b = f"{html_url}\n\n"
        p.b += d.get('body').strip()
    link = r.headers.get('Link')
    done = not link or link.find('rel="next"') == -1
    return done, len(aList)
#@+node:ekr.20180127092201.1: *8* git.print_header
def print_header(self, r):

    # r.headers is a CaseInsensitiveDict
    # so g.printObj(r.headers) is just repr(r.headers)
    if 0:
        print('Link', r.headers.get('Link'))
    else:
        for key in r.headers:
            print(f"{key:35}: {r.headers.get(key)}")
#@+node:ekr.20190428173354.1: *6* g.getGitVersion
def getGitVersion(directory=None):
    """Return a tuple (author, build, date) from the git log, or None."""
    #
    # -n: Get only the last log.
    trace = 'git' in g.app.debug
    try:
        s = subprocess.check_output(
            'git log -n 1 --date=iso',
            cwd=directory or g.app.loadDir,
            stderr=subprocess.DEVNULL,
            shell=True,
        )
        if trace:
            g.trace(s)
    # #1209.
    except subprocess.CalledProcessError as e:
        s = e.output
        if trace:
            g.trace('return code', e.returncode)
            g.trace('value', repr(s))
            g.es_print('Exception in g.getGitVersion')
            g.es_exception()
        s = g.toUnicode(s)
        if not isinstance(s, str):
            return '', '', ''
    except Exception:
        if trace:
            g.es_print('Exception in g.getGitVersion')
            g.es_exception()
        return '', '', ''

    info = [g.toUnicode(z) for z in s.splitlines()]

    def find(kind):
        """Return the given type of log line."""
        for z in info:
            if z.startswith(kind):
                return z.lstrip(kind).lstrip(':').strip()
        return ''

    return find('Author'), find('commit')[:10], find('Date')
#@+node:ekr.20170414034616.2: *6* g.gitBranchName
def gitBranchName(path=None):
    """
    Return the git branch name associated with path/.git, or the empty
    string if path/.git does not exist. If path is None, use the leo-editor
    directory.
    """
    branch, commit = g.gitInfo(path)
    return branch
#@+node:ekr.20170414034616.4: *6* g.gitCommitNumber
def gitCommitNumber(path=None):
    """
    Return the git commit number associated with path/.git, or the empty
    string if path/.git does not exist. If path is None, use the leo-editor
    directory.
    """
    branch, commit = g.gitInfo(path)
    return commit
#@+node:ekr.20200724132432.1: *6* g.gitInfoForFile
def gitInfoForFile(filename):
    """
    return the git (branch, commit) info associated for the given file.
    
    Look for a .git directory in the file's directory, and parent directories.
    """
    from pathlib import Path
    branch, commit = '', ''
    if filename:
        parent = Path(filename)
        while parent:
            git_dir = os.path.join(parent, '.git')
            if os.path.exists(git_dir) and os.path.isdir(git_dir):
                head = os.path.join(git_dir, 'HEAD')
                if os.path.exists(head):
                    branch, commit = g.gitInfo(head)
                    break
            if parent == parent.parent:
                break
            parent = parent.parent
    return branch, commit
#@+node:ekr.20200724133754.1: *6* g.gitInfoForOutline
def gitInfoForOutline(c):
    """
    Return the git (branch, commit) info associated for commander c.
    """
    return g.gitInfoForFile(c.fileName())
#@+node:maphew.20171112205129.1: *6* g.gitDescribe
def gitDescribe(path=None):
    """
    Return the Git tag, distance-from-tag, and commit hash for the
    associated path. If path is None, use the leo-editor directory.
    
    Given `git describe` cmd line output: `x-leo-v5.6-55-ge1129da\n`
    This function returns ('x-leo-v5.6', '55', 'e1129da')
    """
    describe = g.execGitCommand('git describe --tags --long', path)
    tag, distance, commit = describe[0].rsplit('-', 2)
        # rsplit not split, as '-' might be in tag name
    if 'g' in commit[0:]: commit = commit[1:]
        # leading 'g' isn't part of the commit hash
    commit = commit.rstrip()
    return tag, distance, commit
#@+node:ekr.20170414034616.6: *6* g.gitHeadPath
def gitHeadPath(path=None):
    """
    Compute the path to the .git/HEAD directory given the path to another
    directory. If no path is given, use the path to *this* file. This code
    can *not* use g.app.loadDir because it is called too early in Leo's
    startup code.
    """
    if not path:
        path = g.os_path_dirname(__file__)
    head = g.os_path_finalize_join(path, '..', '..', '.git', 'HEAD')
    exists = g.os_path_exists(head)
    return head if exists else None
#@+node:ekr.20170414034616.3: *6* g.gitInfo
def gitInfo(path=None):
    """
    Path is a .git/HEAD directory, or None.

    Return the branch and commit number or ('', '').
    """
    branch, commit = '', ''  # Set defaults.
    # Does path/../ref exist?
    path = g.gitHeadPath(path)
    if not path or not g.os_path_exists(path):
        return branch, commit
    try:
        with open(path) as f:
            s = f.read()
            if not s.startswith('ref'):
                branch = 'None'
                commit = s[:7]
                return branch, commit
        # On a proper branch
        pointer = s.split()[1]
        dirs = pointer.split('/')
        branch = dirs[-1]
    except IOError:
        g.trace('can not open:', path)
        return branch, commit
    # Try to get a better commit number.
    git_dir = g.os_path_finalize_join(path, '..')
    try:
        path = g.os_path_finalize_join(git_dir, pointer)
        with open(path) as f:
            s = f.read()
        commit = s.strip()[0:12]
        # shorten the hash to a unique shortname
    except IOError:
        try:
            path = g.os_path_finalize_join(git_dir, 'packed-refs')
            with open(path) as f:
                for line in f:
                    if line.strip().endswith(' ' + pointer):
                        commit = line.split()[0][0:12]
                        break
        except IOError:
            pass
    return branch, commit
#@+node:ekr.20031218072017.3139: *5* g.Hooks & Plugins
#@+node:ekr.20101028131948.5860: *6* g.act_on_node
def dummy_act_on_node(c, p, event):
    pass

# This dummy definition keeps pylint happy.
# Plugins can change this.

act_on_node = dummy_act_on_node
#@+node:ville.20120502221057.7500: *6* g.childrenModifiedSet, g.contentModifiedSet
childrenModifiedSet = set()
contentModifiedSet = set()
#@+node:ekr.20031218072017.1596: *6* g.doHook
def doHook(tag, *args, **keywords):
    """
    This global function calls a hook routine. Hooks are identified by the
    tag param.

    Returns the value returned by the hook routine, or None if the there is
    an exception.

    We look for a hook routine in three places:
    1. c.hookFunction
    2. app.hookFunction
    3. leoPlugins.doPlugins()

    Set app.hookError on all exceptions.
    Scripts may reset app.hookError to try again.
    """
    if g.app.killed or g.app.hookError:
        return None
    if args:
        # A minor error in Leo's core.
        g.pr(f"***ignoring args param.  tag = {tag}")
    if not g.app.config.use_plugins:
        if tag in ('open0', 'start1'):
            g.warning("Plugins disabled: use_plugins is 0 in a leoSettings.leo file.")
        return None
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    # pylint: disable=consider-using-ternary
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        g.app.hookFunction = f = g.app.pluginsController.doPlugins
    try:
        # Pass the hook to the hook handler.
        # g.pr('doHook',f.__name__,keywords.get('c'))
        return f(tag, keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True  # Supress this function.
        g.app.idle_time_hooks_enabled = False
        return None
#@+node:ekr.20100910075900.5950: *6* g.Wrappers for g.app.pluginController methods
# Important: we can not define g.pc here!
#@+node:ekr.20100910075900.5951: *7* g.Loading & registration
def loadOnePlugin(pluginName, verbose=False):
    pc = g.app.pluginsController
    return pc.loadOnePlugin(pluginName, verbose=verbose)

def registerExclusiveHandler(tags, fn):
    pc = g.app.pluginsController
    return pc.registerExclusiveHandler(tags, fn)

def registerHandler(tags, fn):
    pc = g.app.pluginsController
    return pc.registerHandler(tags, fn)

def plugin_signon(module_name, verbose=False):
    pc = g.app.pluginsController
    return pc.plugin_signon(module_name, verbose)

def unloadOnePlugin(moduleOrFileName, verbose=False):
    pc = g.app.pluginsController
    return pc.unloadOnePlugin(moduleOrFileName, verbose)

def unregisterHandler(tags, fn):
    pc = g.app.pluginsController
    return pc.unregisterHandler(tags, fn)
#@+node:ekr.20100910075900.5952: *7* g.Information
def getHandlersForTag(tags):
    pc = g.app.pluginsController
    return pc.getHandlersForTag(tags)

def getLoadedPlugins():
    pc = g.app.pluginsController
    return pc.getLoadedPlugins()

def getPluginModule(moduleName):
    pc = g.app.pluginsController
    return pc.getPluginModule(moduleName)

def pluginIsLoaded(fn):
    pc = g.app.pluginsController
    return pc.isLoaded(fn)
#@+node:ekr.20031218072017.1315: *5* g.Idle time functions
#@+node:EKR.20040602125018.1: *6* g.disableIdleTimeHook
def disableIdleTimeHook():
    """Disable the global idle-time hook."""
    g.app.idle_time_hooks_enabled = False
#@+node:EKR.20040602125018: *6* g.enableIdleTimeHook
def enableIdleTimeHook(*args, **keys):
    """Enable idle-time processing."""
    g.app.idle_time_hooks_enabled = True
#@+node:ekr.20140825042850.18410: *6* g.IdleTime
def IdleTime(handler, delay=500, tag=None):
    """
    A thin wrapper for the LeoQtGui.IdleTime class.

    The IdleTime class executes a handler with a given delay at idle time.
    The handler takes a single argument, the IdleTime instance::

        def handler(timer):
            '''IdleTime handler.  timer is an IdleTime instance.'''
            delta_t = timer.time-timer.starting_time
            g.trace(timer.count, '%2.4f' % (delta_t))
            if timer.count >= 5:
                g.trace('done')
                timer.stop()

        # Execute handler every 500 msec. at idle time.
        timer = g.IdleTime(handler,delay=500)
        if timer: timer.start()

    Timer instances are completely independent::

        def handler1(timer):
            delta_t = timer.time-timer.starting_time
            g.trace('%2s %2.4f' % (timer.count,delta_t))
            if timer.count >= 5:
                g.trace('done')
                timer.stop()

        def handler2(timer):
            delta_t = timer.time-timer.starting_time
            g.trace('%2s %2.4f' % (timer.count,delta_t))
            if timer.count >= 10:
                g.trace('done')
                timer.stop()

        timer1 = g.IdleTime(handler1,delay=500)
        timer2 = g.IdleTime(handler2,delay=1000)
        if timer1 and timer2:
            timer1.start()
            timer2.start()
    """
    try:
        return g.app.gui.idleTimeClass(handler, delay, tag)
    except Exception:
        return None
#@+node:ekr.20161027205025.1: *6* g.idleTimeHookHandler (stub)
def idleTimeHookHandler(timer):
    """This function exists for compatibility."""
    g.es_print('Replaced by IdleTimeManager.on_idle')
    g.trace(g.callers())
#@+node:ekr.20041219095213: *5* g.Importing
#@+node:ekr.20040917061619: *6* g.cantImport
def cantImport(moduleName, pluginName=None, verbose=True):
    """Print a "Can't Import" message and return None."""
    s = f"Can not import {moduleName}"
    if pluginName: s = s + f" from {pluginName}"
    if not g.app or not g.app.gui:
        print(s)
    elif g.unitTesting:
        # print s
        return
    else:
        g.warning('', s)
#@+node:ekr.20191220044128.1: *6* g.import_module
def import_module(name, package=None):
    """
    A thin wrapper over importlib.import_module.
    """
    trace = True or 'plugins' in g.app.debug
    exceptions = []
    try:
        m = importlib.import_module(name, package=package)
    except Exception as e:
        m = None
        if trace:
            t, v, tb = sys.exc_info()
            del tb  # don't need the traceback
            v = v or str(t)
                # # in case v is empty, we'll at least have the execption type
            if v not in exceptions:
                exceptions.append(v)
                g.trace(f"Can not import {name}: {e}")
    return m
#@+node:ekr.20140711071454.17650: *5* g.Indices, Strings, Unicode & Whitespace
#@+node:ekr.20140711071454.17647: *6* g.Indices
#@+node:ekr.20050314140957: *7* g.convertPythonIndexToRowCol
def convertPythonIndexToRowCol(s, i):
    """Convert index i into string s into zero-based row/col indices."""
    if not s or i <= 0:
        return 0, 0
    i = min(i, len(s))
    # works regardless of what s[i] is
    row = s.count('\n', 0, i)  # Don't include i
    if row == 0:
        return row, i
    prevNL = s.rfind('\n', 0, i)  # Don't include i
    return row, i - prevNL - 1
#@+node:ekr.20050315071727: *7* g.convertRowColToPythonIndex
def convertRowColToPythonIndex(s, row, col, lines=None):
    """Convert zero-based row/col indices into a python index into string s."""
    if row < 0: return 0
    if lines is None:
        lines = g.splitLines(s)
    if row >= len(lines):
        return len(s)
    col = min(col, len(lines[row]))
    # A big bottleneck
    prev = 0
    for line in lines[:row]:
        prev += len(line)
    return prev + col
#@+node:ekr.20061031102333.2: *7* g.getWord & getLine
def getWord(s, i):
    """Return i,j such that s[i:j] is the word surrounding s[i]."""
    if i >= len(s): i = len(s) - 1
    if i < 0: i = 0
    # Scan backwards.
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i -= 1
    i += 1
    # Scan forwards.
    j = i
    while 0 <= j < len(s) and g.isWordChar(s[j]):
        j += 1
    return i, j

def getLine(s, i):
    """
    Return i,j such that s[i:j] is the line surrounding s[i].
    s[i] is a newline only if the line is empty.
    s[j] is a newline unless there is no trailing newline.
    """
    if i > len(s): i = len(s) - 1
    if i < 0: i = 0
    # A newline *ends* the line, so look to the left of a newline.
    j = s.rfind('\n', 0, i)
    if j == -1: j = 0
    else: j += 1
    k = s.find('\n', i)
    if k == -1: k = len(s)
    else: k = k + 1
    return j, k
#@+node:ekr.20111114151846.9847: *7* g.toPythonIndex
def toPythonIndex(s, index):
    """
    Convert index to a Python int.

    index may be a Tk index (x.y) or 'end'.
    """
    if index is None:
        return 0
    if isinstance(index, int):
        return index
    if index == '1.0':
        return 0
    if index == 'end':
        return len(s)
    data = index.split('.')
    if len(data) == 2:
        row, col = data
        row, col = int(row), int(col)
        i = g.convertRowColToPythonIndex(s, row - 1, col)
        return i
    g.trace(f"bad string index: {index}")
    return 0
#@+node:ekr.20150722051946.1: *6* g.List composition (deprecated)
# These functions are deprecated.
# The LeoTidy class in leoBeautify.py shows a much better way.
#@+node:ekr.20150722051946.2: *7* g.flatten_list
def flatten_list(obj):
    """A generator yielding a flattened (concatenated) version of obj."""
    # pylint: disable=no-else-return
    if isinstance(obj, dict) and obj.get('_join_list'):
        # join_list created obj, and ensured that all args are strings.
        indent = obj.get('indent') or ''
        leading = obj.get('leading') or ''
        sep = obj.get('sep') or ''
        trailing = obj.get('trailing') or ''
        aList = obj.get('aList')
        for i, item in enumerate(aList):
            if leading: yield leading
            for s in flatten_list(item):
                if indent and s.startswith('\n'):
                    yield '\n' + indent + s[1:]
                else:
                    yield s
            if sep and i < len(aList) - 1: yield sep
            if trailing: yield trailing
    elif isinstance(obj, (list, tuple)):
        for obj2 in obj:
            for s in flatten_list(obj2):
                yield s
    elif obj:
        if isinstance(obj, str):
            yield obj
        else:
            yield repr(obj)  # Not likely to be useful.
    else:
        pass  # Allow None and empty containers.
#@+node:ekr.20150722051946.3: *7* g.join_list
def join_list(aList, indent='', leading='', sep='', trailing=''):
    """
    Create a dict representing the concatenation of the
    strings in aList, formatted per the keyword args.
    See the HTMLReportTraverser class for many examples.
    """
    if not aList:
        return None
    # These asserts are reasonable.
    assert isinstance(indent, str), indent
    assert isinstance(leading, str), leading
    assert isinstance(sep, str), sep
    assert isinstance(trailing, str), trailing
    if indent or leading or sep or trailing:
        return {
            '_join_list': True,  # Indicate that join_list created this dict.
            'aList': aList,
            'indent': indent, 'leading': leading, 'sep': sep, 'trailing': trailing,
        }
    return aList
#@+node:ekr.20150722051946.4: *7* g.list_to_string
def list_to_string(obj):
    """
    Convert obj (a list of lists) to a single string.

    This function stresses the gc; it will usually be better to
    work with the much smaller strings generated by flatten_list.

    Use this function only in special circumstances, for example,
    when it is known that the resulting string will be small.
    """
    return ''.join([z for z in flatten_list(obj)])
#@+node:ekr.20140526144610.17601: *6* g.Strings
#@+node:ekr.20190503145501.1: *7* g.isascii
def isascii(s):
    # s.isascii() is defined in Python 3.7.
    return all(ord(ch) < 128 for ch in s)
#@+node:ekr.20031218072017.3106: *7* g.angleBrackets & virtual_event_name
def angleBrackets(s):
    """Returns < < s > >"""
    lt = "<<"
    rt = ">>"
    return lt + s + rt

virtual_event_name = angleBrackets
#@+node:ekr.20090516135452.5777: *7* g.ensureLeading/TrailingNewlines
def ensureLeadingNewlines(s, n):
    s = g.removeLeading(s, '\t\n\r ')
    return ('\n' * n) + s

def ensureTrailingNewlines(s, n):
    s = g.removeTrailing(s, '\t\n\r ')
    return s + '\n' * n
#@+node:ekr.20050920084036.4: *7* g.longestCommonPrefix & g.itemsMatchingPrefixInList
def longestCommonPrefix(s1, s2):
    """Find the longest prefix common to strings s1 and s2."""
    prefix = ''
    for ch in s1:
        if s2.startswith(prefix + ch):
            prefix = prefix + ch
        else:
            return prefix
    return prefix

def itemsMatchingPrefixInList(s, aList, matchEmptyPrefix=False):
    """This method returns a sorted list items of aList whose prefix is s.

    It also returns the longest common prefix of all the matches.
    """
    if s:
        pmatches = [a for a in aList if a.startswith(s)]
    elif matchEmptyPrefix:
        pmatches = aList[:]
    else: pmatches = []
    if pmatches:
        pmatches.sort()
        common_prefix = reduce(g.longestCommonPrefix, pmatches)
    else:
        common_prefix = ''
    return pmatches, common_prefix
#@+node:ekr.20090516135452.5776: *7* g.removeLeading/Trailing
# Warning: g.removeTrailingWs already exists.
# Do not change it!

def removeLeading(s, chars):
    """Remove all characters in chars from the front of s."""
    i = 0
    while i < len(s) and s[i] in chars:
        i += 1
    return s[i:]

def removeTrailing(s, chars):
    """Remove all characters in chars from the end of s."""
    i = len(s) - 1
    while i >= 0 and s[i] in chars:
        i -= 1
    i += 1
    return s[:i]
#@+node:ekr.20060410112600: *7* g.stripBrackets
def stripBrackets(s):
    """Strip leading and trailing angle brackets."""
    if s.startswith('<'):
        s = s[1:]
    if s.endswith('>'):
        s = s[:-1]
    return s
#@+node:ekr.20170317101100.1: *7* g.unCamel
def unCamel(s):
    """Return a list of sub-words in camelCased string s."""
    result, word = [], []
    for ch in s:
        if ch.isalpha() and ch.isupper():
            if word: result.append(''.join(word))
            word = [ch]
        elif ch.isalpha():
            word.append(ch)
        elif word:
            result.append(''.join(word))
            word = []
    if word: result.append(''.join(word))
    return result
#@+node:ekr.20031218072017.1498: *6* g.Unicode
#@+node:ekr.20190505052756.1: *7* g.checkUnicode
checkUnicode_dict = {}

def checkUnicode(s, encoding=None):
    """
    Warn when converting bytes. Report *all* errors.
    
    This method is meant to document defensive programming. We don't expect
    these errors, but they might arise as the result of problems in
    user-defined plugins or scripts.
    """
    if isinstance(s, str):
        return s
    tag = 'g.checkUnicode'
    if not isinstance(s, bytes):
        g.error(f"{tag}: unexpected argument: {s!r}")
        return ''
    #
    # Report the unexpected conversion.
    callers = g.callers(1)
    if callers not in checkUnicode_dict:
        g.trace(g.callers())
        g.error(f"\n{tag}: expected unicode. got: {s!r}\n")
        checkUnicode_dict[callers] = True
    #
    # Convert to unicode, reporting all errors.
    if not encoding:
        encoding = 'utf-8'
    try:
        s = s.decode(encoding, 'strict')
    except(UnicodeDecodeError, UnicodeError):
        # https://wiki.python.org/moin/UnicodeDecodeError
        s = s.decode(encoding, 'replace')
        g.trace(g.callers())
        g.error(f"{tag}: unicode error. encoding: {encoding!r}, s:\n{s!r}")
    except Exception:
        g.trace(g.callers())
        g.es_excption()
        g.error(f"{tag}: unexpected error! encoding: {encoding!r}, s:\n{s!r}")
    return s
#@+node:ekr.20100125073206.8709: *7* g.getPythonEncodingFromString
def getPythonEncodingFromString(s):
    """Return the encoding given by Python's encoding line.
    s is the entire file.
    """
    encoding = None
    tag, tag2 = '# -*- coding:', '-*-'
    n1, n2 = len(tag), len(tag2)
    if s:
        # For Python 3.x we must convert to unicode before calling startswith.
        # The encoding doesn't matter: we only look at the first line, and if
        # the first line is an encoding line, it will contain only ascii characters.
        s = g.toUnicode(s, encoding='ascii', reportErrors=False)
        lines = g.splitLines(s)
        line1 = lines[0].strip()
        if line1.startswith(tag) and line1.endswith(tag2):
            e = line1[n1 : -n2].strip()
            if e and g.isValidEncoding(e):
                encoding = e
        elif g.match_word(line1, 0, '@first'):  # 2011/10/21.
            line1 = line1[len('@first') :].strip()
            if line1.startswith(tag) and line1.endswith(tag2):
                e = line1[n1 : -n2].strip()
                if e and g.isValidEncoding(e):
                    encoding = e
    return encoding
#@+node:ekr.20160229070349.2: *7* g.isBytes (deprecated)
def isBytes(s):
    """Return True if s is a bytes type."""
    return isinstance(s, bytes)
#@+node:ekr.20160229070349.3: *7* g.isCallable (deprecated)
def isCallable(obj):
    return hasattr(obj, '__call__')
#@+node:ekr.20160229070429.1: *7* g.isInt (deprecated)
def isInt(obj):
    """Return True if obj is an int or a long."""
    return isinstance(obj, int)
#@+node:ekr.20161223082445.1: *7* g.isList (deprecated)
def isList(s):
    """Return True if s is a list."""
    return isinstance(s, list)
#@+node:ekr.20160229070349.5: *7* g.isString (deprecated)
def isString(s):
    """Return True if s is any string, but not bytes."""
    return isinstance(s, str)
#@+node:ekr.20160229070349.6: *7* g.isUnicode (deprecated)
def isUnicode(s):
    """Return True if s is a unicode string."""
    return isinstance(s, str)
#@+node:ekr.20031218072017.1500: *7* g.isValidEncoding
def isValidEncoding(encoding):
    """Return True if the encooding is valid."""
    if not encoding:
        return False
    if sys.platform == 'cli':
        return True
    import codecs
    try:
        codecs.lookup(encoding)
        return True
    except LookupError:  # Windows
        return False
    except AttributeError:  # Linux
        return False
    except Exception:
        # UnicodeEncodeError
        g.es_print('Please report the following error')
        g.es_exception()
        return False
#@+node:ekr.20061006152327: *7* g.isWordChar & g.isWordChar1
def isWordChar(ch):
    """Return True if ch should be considered a letter."""
    return ch and (ch.isalnum() or ch == '_')

def isWordChar1(ch):
    return ch and (ch.isalpha() or ch == '_')
#@+node:ekr.20130910044521.11304: *7* g.stripBOM
def stripBOM(s):
    """
    If there is a BOM, return (e,s2) where e is the encoding
    implied by the BOM and s2 is the s stripped of the BOM.

    If there is no BOM, return (None,s)

    s must be the contents of a file (a string) read in binary mode.
    """
    table = (
        # Important: test longer bom's first.
        (4, 'utf-32', codecs.BOM_UTF32_BE),
        (4, 'utf-32', codecs.BOM_UTF32_LE),
        (3, 'utf-8', codecs.BOM_UTF8),
        (2, 'utf-16', codecs.BOM_UTF16_BE),
        (2, 'utf-16', codecs.BOM_UTF16_LE),
    )
    if s:
        for n, e, bom in table:
            assert len(bom) == n
            if bom == s[: len(bom)]:
                return e, s[len(bom) :]
    return None, s
#@+node:ekr.20050208093800: *7* g.toEncodedString
def toEncodedString(s, encoding='utf-8', reportErrors=False):
    """Convert unicode string to an encoded string."""
    if not g.isUnicode(s):
        return s
    if not encoding:
        encoding = 'utf-8'
    # These are the only significant calls to s.encode in Leo.
    try:
        s = s.encode(encoding, "strict")
    except UnicodeError:
        s = s.encode(encoding, "replace")
        if reportErrors:
            g.error(f"Error converting {s} from unicode to {encoding} encoding")
    # Tracing these calls directly yields thousands of calls.
    # Never call g.trace here!
        # g.dump_encoded_string(encoding,s)
    return s
#@+node:ekr.20050208093800.1: *7* g.toUnicode
unicode_warnings = {}  # Keys are g.callers.

def toUnicode(s, encoding=None, reportErrors=False):
    """Convert bytes to unicode if necessary."""
    if isinstance(s, str):
        return s
    tag = 'g.toUnicode'
    if not isinstance(s, bytes):
        if not isinstance(s, (NullObject, TracingNullObject)):
            callers = g.callers()
            if callers not in unicode_warnings:
                unicode_warnings[callers] = True
                g.error(f"{tag}: unexpected argument of type {s.__class__.__name__}")
                g.trace(callers)
        return ''
    if not encoding:
        encoding = 'utf-8'
    try:
        s = s.decode(encoding, 'strict')
    except(UnicodeDecodeError, UnicodeError):
        # https://wiki.python.org/moin/UnicodeDecodeError
        s = s.decode(encoding, 'replace')
        if reportErrors:
            g.error(f"{tag}: unicode error. encoding: {encoding!r}, s:\n{s!r}")
            g.trace(g.callers())
    except Exception:
        g.es_exception()
        g.error(f"{tag}: unexpected error! encoding: {encoding!r}, s:\n{s!r}")
        g.trace(g.callers())
    return s
#@+node:ekr.20091206161352.6232: *7* g.u (deprecated)
def u(s):
    """
    Return s, converted to unicode from Qt widgets.
    
    leoQt.py uses is as a stand-in for QString, but all other calls to
    g.u can and should be removed.
    
    Neither Leo's core nor any of Leo's official plugins call this
    method directly.
    """
    return s
#@+node:ekr.20031218072017.3197: *6* g.Whitespace
#@+node:ekr.20031218072017.3198: *7* g.computeLeadingWhitespace
# Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace(width, tab_width):
    if width <= 0:
        return ""
    if tab_width > 1:
        tabs = int(width / tab_width)
        blanks = int(width % tab_width)
        return ('\t' * tabs) + (' ' * blanks)
    # Negative tab width always gets converted to blanks.
    return (' ' * width)
#@+node:ekr.20120605172139.10263: *7* g.computeLeadingWhitespaceWidth
# Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespaceWidth(s, tab_width):
    w = 0
    for ch in s:
        if ch == ' ':
            w += 1
        elif ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            break
    return w
#@+node:ekr.20031218072017.3199: *7* g.computeWidth
# Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth(s, tab_width):
    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        elif ch == '\n':  # Bug fix: 2012/06/05.
            break
        else:
            w += 1
    return w
#@+node:ekr.20051014175117: *7* g.adjustTripleString
def adjustTripleString(s, tab_width):
    """Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    """
    # Compute the minimum leading whitespace of all non-blank lines.
    lines = g.splitLines(s)
    first, w = True, 0
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            # The sign of w2 does not matter.
            w2 = abs(g.computeWidth(lws, tab_width))
            if w2 == 0:
                return s
            if first or w2 < w:
                w = w2
                first = False
    if w == 0:
        return s
    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line, w, tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20050211120242.2: *7* g.removeExtraLws
def removeExtraLws(s, tab_width):
    """
    Remove extra indentation from one or more lines.

    Warning: used by getScript. This is *not* the same as g.adjustTripleString.
    """
    lines = g.splitLines(s)
    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for line in lines:
        if line.strip():
            lws = g.get_leading_ws(line)
            w = g.computeWidth(lws, tab_width)
            break
    else: return s
    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line, w, tab_width) for line in lines]
    result = ''.join(result)
    return result
#@+node:ekr.20110727091744.15083: *7* g.wrap_lines (newer)
@language rest
@
Important note: this routine need not deal with leading whitespace.

Instead, the caller should simply reduce pageWidth by the width of
leading whitespace wanted, then add that whitespace to the lines
returned here.

The key to this code is the invarient that line never ends in whitespace.
@c
@language python

def wrap_lines(lines, pageWidth, firstLineWidth=None):
    """Returns a list of lines, consisting of the input lines wrapped to the given pageWidth."""
    if pageWidth < 10:
        pageWidth = 10
    # First line is special
    if not firstLineWidth:
        firstLineWidth = pageWidth
    if firstLineWidth < 10:
        firstLineWidth = 10
    outputLineWidth = firstLineWidth
    # Sentence spacing
    # This should be determined by some setting, and can only be either 1 or 2
    sentenceSpacingWidth = 1
    assert(0 < sentenceSpacingWidth < 3)
    result = []  # The lines of the result.
    line = ""  # The line being formed.  It never ends in whitespace.
    for s in lines:
        i = 0
        while i < len(s):
            assert(len(line) <= outputLineWidth)  # DTHEIN 18-JAN-2004
            j = g.skip_ws(s, i)  # ;   ws = s[i:j]
            k = g.skip_non_ws(s, j); word = s[j:k]
            assert(k > i)
            i = k
            # DTHEIN 18-JAN-2004: wrap at exactly the text width,
            # not one character less
            #
            wordLen = len(word)
            if line.endswith('.') or line.endswith('?') or line.endswith('!'):
                space = ' ' * sentenceSpacingWidth
            else:
                space = ' '
            if line and wordLen > 0: wordLen += len(space)
            if wordLen + len(line) <= outputLineWidth:
                if wordLen > 0:
                    << place blank and word on the present line >>
                else: pass  # discard the trailing whitespace.
            else:
                << place word on a new line >>
    if line:
        result.append(line)
    return result
#@+node:ekr.20110727091744.15084: *8* << place blank and word on the present line >>
if line:
    # Add the word, preceeded by a blank.
    line = space.join((line, word))
else:
    # Just add the word to the start of the line.
    line = word
#@+node:ekr.20110727091744.15085: *8* << place word on a new line >>
# End the previous line.
if line:
    result.append(line)
    outputLineWidth = pageWidth  # DTHEIN 3-NOV-2002: width for remaining lines
# Discard the whitespace and put the word on a new line.
line = word
# Careful: the word may be longer than pageWidth.
if len(line) > pageWidth:  # DTHEIN 18-JAN-2004: line can equal pagewidth
    result.append(line)
    outputLineWidth = pageWidth  # DTHEIN 3-NOV-2002: width for remaining lines
    line = ""
#@+node:ekr.20031218072017.3200: *7* g.get_leading_ws
def get_leading_ws(s):
    """Returns the leading whitespace of 's'."""
    i = 0; n = len(s)
    while i < n and s[i] in (' ', '\t'):
        i += 1
    return s[0:i]
#@+node:ekr.20031218072017.3201: *7* g.optimizeLeadingWhitespace
# Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace(line, tab_width):
    i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
    s = g.computeLeadingWhitespace(width, tab_width) + line[i:]
    return s
#@+node:ekr.20040723093558: *7* g.regularizeTrailingNewlines
@ The caller should call g.stripBlankLines before calling this routine
if desired.

This routine does _not_ simply call rstrip(): that would delete all
trailing whitespace-only lines, and in some cases that would change
the meaning of program or data.
@c

def regularizeTrailingNewlines(s, kind):
    """Kind is 'asis', 'zero' or 'one'."""
    pass
#@+node:ekr.20091229090857.11698: *7* g.removeBlankLines
def removeBlankLines(s):
    lines = g.splitLines(s)
    lines = [z for z in lines if z.strip()]
    return ''.join(lines)
#@+node:ekr.20091229075924.6235: *7* g.removeLeadingBlankLines
def removeLeadingBlankLines(s):
    lines = g.splitLines(s)
    result = []; remove = True
    for line in lines:
        if remove and not line.strip():
            pass
        else:
            remove = False
            result.append(line)
    return ''.join(result)
#@+node:ekr.20031218072017.3202: *7* g.removeLeadingWhitespace
# Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace(s, first_ws, tab_width):
    j = 0; ws = 0; first_ws = abs(first_ws)
    for ch in s:
        if ws >= first_ws:
            break
        elif ch == ' ':
            j += 1; ws += 1
        elif ch == '\t':
            j += 1; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j > 0:
        s = s[j:]
    return s
#@+node:ekr.20031218072017.3203: *7* g.removeTrailingWs
# Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):
    j = len(s) - 1
    while j >= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[: j + 1]
#@+node:ekr.20031218072017.3204: *7* g.skip_leading_ws
# Skips leading up to width leading whitespace.

def skip_leading_ws(s, i, ws, tab_width):
    count = 0
    while count < ws and i < len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break
    return i
#@+node:ekr.20031218072017.3205: *7* g.skip_leading_ws_with_indent
def skip_leading_ws_with_indent(s, i, tab_width):
    """Skips leading whitespace and returns (i, indent),

    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""
    count = 0; n = len(s)
    while i < n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break
    return i, count
#@+node:ekr.20040723093558.1: *7* g.stripBlankLines
def stripBlankLines(s):
    lines = g.splitLines(s)
    for i, line in enumerate(lines):
        j = g.skip_ws(line, 0)
        if j >= len(line):
            lines[i] = ''
        elif line[j] == '\n':
            lines[i] = '\n'
    return ''.join(lines)
#@+node:ekr.20031218072017.3108: *5* g.Logging & Printing
# g.es and related print to the Log window.
# g.pr prints to the console.
# g.es_print and related print to both the Log window and the console.
#@+node:ekr.20080821073134.2: *6* g.doKeywordArgs
def doKeywordArgs(keys, d=None):
    """
    Return a result dict that is a copy of the keys dict
    with missing items replaced by defaults in d dict.
    """
    if d is None: d = {}
    result = {}
    for key, default_val in d.items():
        isBool = default_val in (True, False)
        val = keys.get(key)
        if isBool and val in (True, 'True', 'true'):
            result[key] = True
        elif isBool and val in (False, 'False', 'false'):
            result[key] = False
        elif val is None:
            result[key] = default_val
        else:
            result[key] = val
    return result
#@+node:ekr.20031218072017.1474: *6* g.enl, ecnl & ecnls
def ecnl(tabName='Log'):
    g.ecnls(1, tabName)

def ecnls(n, tabName='Log'):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl(tabName)

def enl(tabName='Log'):
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl(tabName)
#@+node:ekr.20100914094836.5892: *6* g.error, g.note, g.warning, g.red, g.blue
def blue(*args, **keys):
    g.es_print(color='blue', *args, **keys)

def error(*args, **keys):
    g.es_print(color='error', *args, **keys)

def note(*args, **keys):
    g.es_print(color='note', *args, **keys)

def red(*args, **keys):
    g.es_print(color='red', *args, **keys)

def warning(*args, **keys):
    g.es_print(color='warning', *args, **keys)
#@+node:ekr.20070626132332: *6* g.es
def es(*args, **keys):
    """Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    if not app or app.killed:
        return
    if app.gui and app.gui.consoleOnly:
        return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return  # New in 4.3.
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    # Do not call g.es, g.es_print, g.pr or g.trace here!
        # sys.__stdout__.write('\n===== g.es: %r\n' % s)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            g.pr(s, newline=newline)
    elif log and app.logInited:
        if newline:
            s += '\n'
        log.put(s, color=color, tabName=tabName, nodeLink=d['nodeLink'])
        # Count the number of *trailing* newlines.
        for ch in s:
            if ch == '\n': log.newlines += 1
            else: log.newlines = 0
    else:
        app.logWaiting.append((s, color, newline, d),)

log = es
#@+node:ekr.20190608090856.1: *6* g.es_clickable_link
def es_clickable_link(c, p, line_number, message):
    """Write a clickable message to the given line number of p.b."""
    log = c.frame.log
    unl = p.get_UNL(with_proto=True, with_count=True)
    if unl:
        nodeLink = f"{unl},{line_number}"
        log.put(message, nodeLink=nodeLink)
    else:
        log.put(message)
#@+node:ekr.20141107085700.4: *6* g.es_debug
def es_debug(*args, **keys):
    """
    Print all non-keyword args, and put them to the log pane in orange.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    keys['color'] = 'blue'
    try:  # get the function name from the call stack.
        f1 = sys._getframe(1)  # The stack frame, one level up.
        code1 = f1.f_code  # The code object
        name = code1.co_name  # The code name
    except Exception:
        name = g.shortFileName(__file__)
    if name == '<module>':
        name = g.shortFileName(__file__)
    if name.endswith('.pyc'):
        name = name[:-1]
    g.pr(name, *args, **keys)
    if not g.app.unitTesting:
        g.es(name, *args, **keys)
#@+node:ekr.20060917120951: *6* g.es_dump
def es_dump(s, n=30, title=None):
    if title:
        g.es_print('', title)
    i = 0
    while i < len(s):
        aList = ''.join([f"{ord(ch):2x} " for ch in s[i : i + n]])
        g.es_print('', aList)
        i += n
#@+node:ekr.20031218072017.3110: *6* g.es_error & es_print_error
def es_error(*args, **keys):
    color = keys.get('color')
    if color is None and g.app.config:
        keys['color'] = g.app.config.getColor("log-error-color") or 'red'
    g.es(*args, **keys)

def es_print_error(*args, **keys):
    color = keys.get('color')
    if color is None and g.app.config:
        keys['color'] = g.app.config.getColor("log-error-color") or 'red'
    g.es_print(*args, **keys)
#@+node:ekr.20031218072017.3111: *6* g.es_event_exception
def es_event_exception(eventName, full=False):
    g.es("exception handling ", eventName, "event")
    typ, val, tb = sys.exc_info()
    if full:
        errList = traceback.format_exception(typ, val, tb)
    else:
        errList = traceback.format_exception_only(typ, val)
    for i in errList:
        g.es('', i)
    if not g.stdErrIsRedirected():  # 2/16/04
        traceback.print_exc()
#@+node:ekr.20031218072017.3112: *6* g.es_exception
def es_exception(full=True, c=None, color="red"):
    typ, val, tb = sys.exc_info()
    # val is the second argument to the raise statement.
    if full:
        lines = traceback.format_exception(typ, val, tb)
    else:
        lines = traceback.format_exception_only(typ, val)
    for line in lines:
        g.es_print_error(line, color=color)
    fileName, n = g.getLastTracebackFileAndLineNumber()
    return fileName, n
#@+node:ekr.20061015090538: *6* g.es_exception_type
def es_exception_type(c=None, color="red"):
    # exctype is a Exception class object; value is the error message.
    exctype, value = sys.exc_info()[:2]
    g.es_print('', f"{exctype.__name__}, {value}", color=color)
#@+node:ekr.20050707064040: *6* g.es_print
# see: http://www.diveintopython.org/xml_processing/unicode.html

def es_print(*args, **keys):
    """
    Print all non-keyword args, and put them to the log pane.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    g.pr(*args, **keys)
    if g.app and not g.app.unitTesting:
        g.es(*args, **keys)
#@+node:ekr.20111107181638.9741: *6* g.es_print_exception
def es_print_exception(full=True, c=None, color="red"):
    """Print exception info about the last exception."""
    typ, val, tb = sys.exc_info()
        # val is the second argument to the raise statement.
    if full:
        lines = traceback.format_exception(typ, val, tb)
    else:
        lines = traceback.format_exception_only(typ, val)
    print(''.join(lines))
    try:
        fileName, n = g.getLastTracebackFileAndLineNumber()
        return fileName, n
    except Exception:
        return "<no file>", 0
#@+node:ekr.20050707065530: *6* g.es_trace
def es_trace(*args, **keys):
    if args:
        try:
            s = args[0]
            g.trace(g.toEncodedString(s, 'ascii'))
        except Exception:
            pass
    g.es(*args, **keys)
#@+node:ekr.20040731204831: *6* g.getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():
    typ, val, tb = sys.exc_info()
    if typ == SyntaxError:
        # IndentationError is a subclass of SyntaxError.
        return val.filename, val.lineno
    #
    # Data is a list of tuples, one per stack entry.
    # Tupls have the form (filename,lineNumber,functionName,text).
    data = traceback.extract_tb(tb)
    if data:
        item = data[-1]  # Get the item at the top of the stack.
        filename, n, functionName, text = item
        return filename, n
    # Should never happen.
    return '<string>', 0
#@+node:ekr.20150621095017.1: *6* g.goto_last_exception
def goto_last_exception(c):
    """Go to the line given by sys.last_traceback."""
    typ, val, tb = sys.exc_info()
    if tb:
        file_name, line_number = g.getLastTracebackFileAndLineNumber()
        line_number = max(0, line_number - 1)
            # Convert to zero-based.
        if file_name.endswith('scriptFile.py'):
            # A script.
            c.goToScriptLineNumber(line_number, c.p)
        else:
            for p in c.all_nodes():
                if p.isAnyAtFileNode() and p.h.endswith(file_name):
                    c.goToLineNumber(line_number, p)
                    return
    else:
        g.trace('No previous exception')
#@+node:ekr.20100126062623.6240: *6* g.internalError
def internalError(*args):
    """Report a serious interal error in Leo."""
    callers = g.callers(20).split(',')
    caller = callers[-1]
    g.error('\nInternal Leo error in', caller)
    g.es_print(*args)
    g.es_print('Called from', ', '.join(callers[:-1]))
    g.es_print('Please report this error to Leo\'s developers', color='red')
#@+node:ekr.20150127060254.5: *6* g.log_to_file
def log_to_file(s, fn=None):
    """Write a message to ~/test/leo_log.txt."""
    if fn is None:
        fn = g.os_path_expanduser('~/test/leo_log.txt')
    if not s.endswith('\n'):
        s = s + '\n'
    try:
        with open(fn, 'a') as f:
            f.write(s)
    except Exception:
        g.es_exception()
#@+node:ekr.20080710101653.1: *6* g.pr
# see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args, **keys):
    """
    Print all non-keyword args. This is a wrapper for the print statement.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    """
    # Compute the effective args.
    d = {'commas': False, 'newline': True, 'spaces': True}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    stdout = sys.stdout if sys.stdout and g.unitTesting else sys.__stdout__
        # Unit tests require sys.stdout.
    if not stdout:
        # #541.
        return
    if sys.platform.lower().startswith('win'):
        encoding = 'ascii'  # 2011/11/9.
    elif getattr(stdout, 'encoding', None):
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = stdout.encoding
    else:
        encoding = 'utf-8'
    s = translateArgs(args, d)
        # Translates everything to unicode.
    s = g.toUnicode(s, encoding=encoding, reportErrors=False)
    if newline:
        s += '\n'
    #
    # Python's print statement *can* handle unicode, but
    # sitecustomize.py must have sys.setdefaultencoding('utf-8')
    try:
        # #783: print-* commands fail under pythonw.
        stdout.write(s)
    except Exception:
        pass
#@+node:ekr.20060221083356: *6* g.prettyPrintType
def prettyPrintType(obj):
    if isinstance(obj, str):
        return 'string'
    t = type(obj)
    if t in (types.BuiltinFunctionType, types.FunctionType):
        return 'function'
    if t == types.ModuleType:
        return 'module'
    if t in [types.MethodType, types.BuiltinMethodType]:
        return 'method'
    # Fall back to a hack.
    t = str(type(obj))
    if t.startswith("<type '"): t = t[7:]
    if t.endswith("'>"): t = t[:-2]
    return t
#@+node:ekr.20031218072017.3113: *6* g.printBindings
def print_bindings(name, window):
    bindings = window.bind()
    g.pr("\nBindings for", name)
    for b in bindings:
        g.pr(b)
#@+node:ekr.20070510074941: *6* g.printEntireTree
def printEntireTree(c, tag=''):
    g.pr('printEntireTree', '=' * 50)
    g.pr('printEntireTree', tag, 'root', c.rootPosition())
    for p in c.all_positions():
        g.pr('..' * p.level(), p.v)
#@+node:ekr.20031218072017.3114: *6* g.printGlobals
def printGlobals(message=None):
    # Get the list of globals.
    globs = list(globals())
    globs.sort()
    # Print the list.
    if message:
        leader = "-" * 10
        g.pr(leader, ' ', message, ' ', leader)
    for name in globs:
        g.pr(name)
#@+node:ekr.20031218072017.3115: *6* g.printLeoModules
def printLeoModules(message=None):
    # Create the list.
    mods = []
    for name in sys.modules:
        if name and name[0:3] == "leo":
            mods.append(name)
    # Print the list.
    if message:
        leader = "-" * 10
        g.pr(leader, ' ', message, ' ', leader)
    mods.sort()
    for m in mods:
        g.pr(m, newline=False)
    g.pr('')
#@+node:ekr.20041122153823: *6* g.printStack
def printStack():
    traceback.print_stack()
#@+node:ekr.20031218072017.2317: *6* g.trace
def trace(*args, **keys):
    """Print a tracing message."""
    # Don't use g here: in standalone mode g is a NullObject!
    # Compute the effective args.
    d = {'align': 0, 'before': '', 'newline': True, 'caller_level': 1, 'noname': False}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    align = d.get('align', 0)
    caller_level = d.get('caller_level', 1)
    noname = d.get('noname')
    # Compute the caller name.
    if noname:
        name = ''
    else:
        try:  # get the function name from the call stack.
            f1 = sys._getframe(caller_level)  # The stack frame, one level up.
            code1 = f1.f_code  # The code object
            name = code1.co_name  # The code name
        except Exception:
            name = g.shortFileName(__file__)
        if name == '<module>':
            name = g.shortFileName(__file__)
        if name.endswith('.pyc'):
            name = name[:-1]
    # Pad the caller name.
    if align != 0 and len(name) < abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align > 0: name = name + pad
        else: name = pad + name
    # Munge *args into s.
    result = [name] if name else []
    #
    # Put leading newlines into the prefix.
    if isinstance(args, tuple):
        args = list(args)
    if args and isString(args[0]):
        prefix = ''
        while args[0].startswith('\n'):
            prefix += '\n'
            args[0] = args[0][1:]
    else:
        prefix = ''
    for arg in args:
        if isString(arg):
            pass
        elif isBytes(arg):
            arg = toUnicode(arg)
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = d.get('before') + ''.join(result)
    if prefix:
        prefix = prefix[1:]  # One less newline.
        pr(prefix)
    pr(s, newline=newline)
#@+node:ekr.20080220111323: *6* g.translateArgs
console_encoding = None

def translateArgs(args, d):
    """
    Return the concatenation of s and all args, with odd args translated.
    """
    global console_encoding
    if not console_encoding:
        e = sys.getdefaultencoding()
        console_encoding = e if isValidEncoding(e) else 'utf-8'
        # print 'translateArgs',console_encoding
    result = []; n = 0; spaces = d.get('spaces')
    for arg in args:
        n += 1
        # First, convert to unicode.
        if isinstance(arg, str):
            arg = toUnicode(arg, console_encoding)
        # Now translate.
        if not isString(arg):
            arg = repr(arg)
        elif (n % 2) == 1:
            arg = translateString(arg)
        else:
            pass  # The arg is an untranslated string.
        if arg:
            if result and spaces: result.append(' ')
            result.append(arg)
    return ''.join(result)
#@+node:ekr.20060810095921: *6* g.translateString & tr
def translateString(s):
    """Return the translated text of s."""
    # pylint: disable=undefined-loop-variable
    # looks like a pylint bug
    upper = app and getattr(app, 'translateToUpperCase', None)
    if not isinstance(s, str):
        s = str(s, 'utf-8')
    if upper:
        s = s.upper()
    else:
        s = gettext.gettext(s)
    return s

tr = translateString
#@+node:EKR.20040612114220: *5* g.Miscellaneous
#@+node:ekr.20120928142052.10116: *6* g.actualColor
def actualColor(color):
    """Return the actual color corresponding to the requested color."""
    c = g.app.log and g.app.log.c
    # Careful: c.config may not yet exist.
    if not c or not c.config:
        return color
    # Don't change absolute colors.
    if color and color.startswith('#'):
        return color
    # #788: Translate colors to theme-defined colors.
    if color is None:
        # Prefer text_foreground_color'
        color2 = c.config.getColor('log-text-foreground-color')
        if color2: return color2
        # Fall back to log_black_color.
        color2 = c.config.getColor('log-black-color')
        return color2 or 'black'
    if color == 'black':
        # Prefer log_black_color.
        color2 = c.config.getColor('log-black-color')
        if color2: return color2
        # Fall back to log_text_foreground_color.
        color2 = c.config.getColor('log-text-foreground-color')
        return color2 or 'black'
    color2 = c.config.getColor(f"log_{color}_color")
    return color2 or color
#@+node:ekr.20060921100435: *6* g.CheckVersion & helpers
# Simplified version by EKR: stringCompare not used.

def CheckVersion(s1, s2, condition=">=", stringCompare=None, delimiter='.', trace=False):
    # CheckVersion is called early in the startup process.
    vals1 = [g.CheckVersionToInt(s) for s in s1.split(delimiter)]; n1 = len(vals1)
    vals2 = [g.CheckVersionToInt(s) for s in s2.split(delimiter)]; n2 = len(vals2)
    n = max(n1, n2)
    if n1 < n: vals1.extend([0 for i in range(n - n1)])
    if n2 < n: vals2.extend([0 for i in range(n - n2)])
    for cond, val in (
        ('==', vals1 == vals2), ('!=', vals1 != vals2),
        ('<', vals1 < vals2), ('<=', vals1 <= vals2),
        ('>', vals1 > vals2), ('>=', vals1 >= vals2),
    ):
        if condition == cond:
            result = val; break
    else:
        raise EnvironmentError(
            "condition must be one of '>=', '>', '==', '!=', '<', or '<='.")
    return result
#@+node:ekr.20070120123930: *7* g.CheckVersionToInt
def CheckVersionToInt(s):
    try:
        return int(s)
    except ValueError:
        aList = []
        for ch in s:
            if ch.isdigit(): aList.append(ch)
            else: break
        if aList:
            s = ''.join(aList)
            return int(s)
        return 0
#@+node:ekr.20031218072017.3147: *6* g.choose (deprecated)
# This can and should be replaced by Python's ternary operator.

def choose(cond, a, b):  # warning: evaluates all arguments
    """(Deprecated) simulate `a if cond else b`."""
    if cond:
        return a
    return b
#@+node:ekr.20111103205308.9657: *6* g.cls
@command('cls')
def cls(event=None):
    """Clear the screen."""
    import os
    import sys
    if sys.platform.lower().startswith('win'):
        os.system('cls')
#@+node:ekr.20131114124839.16665: *6* g.createScratchCommander
def createScratchCommander(fileName=None):
    c = g.app.newCommander(fileName)
    frame = c.frame
    frame.createFirstTreeNode()
    assert c.rootPosition()
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
#@+node:ekr.20031218072017.3126: *6* g.funcToMethod (Python Cookbook)
def funcToMethod(f, theClass, name=None):
    """
    From the Python Cookbook...

    The following method allows you to add a function as a method of
    any class. That is, it converts the function to a method of the
    class. The method just added is available instantly to all
    existing instances of the class, and to all instances created in
    the future.
    
    The function's first argument should be self.
    
    The newly created method has the same name as the function unless
    the optional name argument is supplied, in which case that name is
    used as the method name.
    """
    setattr(theClass, name or f.__name__, f)
#@+node:ekr.20060913090832.1: *6* g.init_zodb
init_zodb_import_failed = False
init_zodb_failed = {}  # Keys are paths, values are True.
init_zodb_db = {}  # Keys are paths, values are ZODB.DB instances.

def init_zodb(pathToZodbStorage, verbose=True):
    """
    Return an ZODB.DB instance from the given path.
    return None on any error.
    """
    global init_zodb_db, init_zodb_failed, init_zodb_import_failed
    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db
    if init_zodb_import_failed: return None
    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None
    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None
    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db[pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed[pathToZodbStorage] = True
        return None
#@+node:ekr.20170206080908.1: *6* g.input_
def input_(message='', c=None):
    """
    Safely execute python's input statement.

    c.executeScriptHelper binds 'input' to be a wrapper that calls g.input_
    with c and handler bound properly.
    """
    if app.gui.isNullGui:
        return ''
    # Prompt for input from the console, assuming there is one.
    # pylint: disable=no-member
    from leo.core.leoQt import QtCore
    QtCore.pyqtRemoveInputHook()
    return input(message)
#@+node:ekr.20110609125359.16493: *6* g.isMacOS
def isMacOS():
    return sys.platform == 'darwin'
#@+node:ekr.20181027133311.1: *6* g.issueSecurityWarning
def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
#@+node:ekr.20031218072017.3144: *6* g.makeDict (Python Cookbook)
# From the Python cookbook.

def makeDict(**keys):
    """Returns a Python dictionary from using the optional keyword arguments."""
    return keys
#@+node:ekr.20140528065727.17963: *6* g.pep8_class_name
def pep8_class_name(s):
    """Return the proper class name for s."""
    # Warning: s.capitalize() does not work.
    # It lower cases all but the first letter!
    return ''.join([z[0].upper() + z[1:] for z in s.split('_') if z])

if 0:  # Testing:
    cls()
    aList = (
        '_',
        '__',
        '_abc',
        'abc_',
        'abc',
        'abc_xyz',
        'AbcPdQ',
    )
    for s in aList:
        print(pep8_class_name(s))
#@+node:ekr.20190522093202.1: *6* g.placate_pyflakes
def placate_pyflakes(*args):
    """A do-nothing method that suppresses pyflakes warnings."""
#@+node:ekr.20160417174224.1: *6* g.plural
def plural(obj):
    """Return "s" or "" depending on n."""
    if isinstance(obj, (list, tuple, str)):
        n = len(obj)
    else:
        n = obj
    return '' if n == 1 else 's'
#@+node:ekr.20160331194701.1: *6* g.truncate
def truncate(s, n):
    """Return s truncated to n characters."""
    if len(s) <= n:
        return s
    # Fail: weird ws.
    s2 = s[: n - 3] + f"...({len(s)})"
    if s.endswith('\n'):
        return s2 + '\n'
    return s2
#@+node:ekr.20031218072017.3150: *6* g.windows
def windows():
    return app and app.windowList
#@+node:ekr.20031218072017.2145: *5* g.os_path_ Wrappers
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@+node:ekr.20180314120442.1: *6* g.glob_glob
def glob_glob(pattern):
    """Return the regularized glob.glob(pattern)"""
    aList = glob.glob(pattern)
    if g.isWindows:
        aList = [z.replace('\\', '/') for z in aList]
    return aList
#@+node:ekr.20031218072017.2146: *6* g.os_path_abspath
def os_path_abspath(path):
    """Convert a path to an absolute path."""
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00', '')  # Fix Pytyon 3 bug on Windows 10.
    path = os.path.abspath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20031218072017.2147: *6* g.os_path_basename
def os_path_basename(path):
    """Return the second half of the pair returned by split(path)."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.basename(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20031218072017.2148: *6* g.os_path_dirname
def os_path_dirname(path):
    """Return the first half of the pair returned by split(path)."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.dirname(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20031218072017.2149: *6* g.os_path_exists
def os_path_exists(path):
    """Return True if path exists."""
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00', '')  # Fix Pytyon 3 bug on Windows 10.
    return os.path.exists(path)
#@+node:ekr.20080922124033.6: *6* g.os_path_expandExpression & helper (deprecated)
deprecated_messages = []

def os_path_expandExpression(s, **keys):
    """
    Expand all {{anExpression}} in c's context.
    
    Deprecated: use c.expand_path_expression(s) instead.
    """

    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c', g.callers())
        return s
    callers = g.callers(2)
    if callers not in deprecated_messages:
        deprecated_messages.append(callers)
        g.es_print(f"\nos_path_expandExpression is deprecated. called from: {callers}")
    return c.expand_path_expression(s)
#@+node:ekr.20080921060401.13: *6* g.os_path_expanduser
def os_path_expanduser(path):
    """wrap os.path.expanduser"""
    path = g.toUnicodeFileEncoding(path)
    result = os.path.normpath(os.path.expanduser(path))
    if g.isWindows:
        path = path.replace('\\', '/')
    return result
#@+node:ekr.20080921060401.14: *6* g.os_path_finalize
def os_path_finalize(path):
    """
    Expand '~', then return os.path.normpath, os.path.abspath of the path.
    There is no corresponding os.path method
    """
    path = path.replace('\x00', '')  # Fix Pytyon 3 bug on Windows 10.
    path = os.path.expanduser(path)  # #1383.
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    # calling os.path.realpath here would cause problems in some situations.
    return path
#@+node:ekr.20140917154740.19483: *6* g.os_path_finalize_join
def os_path_finalize_join(*args, **keys):
    """
    Join and finalize.
    
    **keys may contain a 'c' kwarg, used by c.os_path_join.
    """
    # Old code
        # path = os.path.normpath(os.path.abspath(g.os_path_join(*args, **keys)))
        # if g.isWindows:
            # path = path.replace('\\','/')
    #
    # #1383: Call both wrappers, to ensure ~ is always expanded.
    #        This is significant change, to undo previous mistakes.
    #        Revs cbbf5e8b and 6e461196 in devel were the likely culprits.
    path = g.os_path_join(*args, **keys)
    path = g.os_path_finalize(path)
    return path
#@+node:ekr.20031218072017.2150: *6* g.os_path_getmtime
def os_path_getmtime(path):
    """Return the modification time of path."""
    path = g.toUnicodeFileEncoding(path)
    try:
        return os.path.getmtime(path)
    except Exception:
        return 0
#@+node:ekr.20080729142651.2: *6* g.os_path_getsize
def os_path_getsize(path):
    """Return the size of path."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.getsize(path)
#@+node:ekr.20031218072017.2151: *6* g.os_path_isabs
def os_path_isabs(path):
    """Return True if path is an absolute path."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isabs(path)
#@+node:ekr.20031218072017.2152: *6* g.os_path_isdir
def os_path_isdir(path):
    """Return True if the path is a directory."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isdir(path)
#@+node:ekr.20031218072017.2153: *6* g.os_path_isfile
def os_path_isfile(path):
    """Return True if path is a file."""
    path = g.toUnicodeFileEncoding(path)
    return os.path.isfile(path)
#@+node:ekr.20031218072017.2154: *6* g.os_path_join
def os_path_join(*args, **keys):
    """
    Join paths, like os.path.join, with enhancements:
    
    A '!!' arg prepends g.app.loadDir to the list of paths.
    A '.'  arg prepends c.openDirectory to the list of paths,
           provided there is a 'c' kwarg.
    """
    c = keys.get('c')
    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
    if uargs:
        try:
            path = os.path.join(*uargs)
        except TypeError:
            g.trace(uargs, args, keys, g.callers())
            raise
    else:
        path = ''
    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    path = path.replace('\x00', '')  # Fix Pytyon 3 bug on Windows 10.
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20031218072017.2156: *6* g.os_path_normcase
def os_path_normcase(path):
    """Normalize the path's case."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.normcase(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20031218072017.2157: *6* g.os_path_normpath
def os_path_normpath(path):
    """Normalize the path."""
    path = g.toUnicodeFileEncoding(path)
    path = os.path.normpath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20180314081254.1: *6* g.os_path_normslashes
def os_path_normslashes(path):
    if g.isWindows and path:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20080605064555.2: *6* g.os_path_realpath
def os_path_realpath(path):
    """Return the canonical path of the specified filename, eliminating any
    symbolic links encountered in the path (if they are supported by the
    operating system).
    """
    path = g.toUnicodeFileEncoding(path)
    path = os.path.realpath(path)
    path = g.toUnicodeFileEncoding(path)
    if g.isWindows:
        path = path.replace('\\', '/')
    return path
#@+node:ekr.20031218072017.2158: *6* g.os_path_split
def os_path_split(path):
    path = g.toUnicodeFileEncoding(path)
    head, tail = os.path.split(path)
    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)
    return head, tail
#@+node:ekr.20031218072017.2159: *6* g.os_path_splitext
def os_path_splitext(path):
    path = g.toUnicodeFileEncoding(path)
    head, tail = os.path.splitext(path)
    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)
    return head, tail
#@+node:ekr.20090829140232.6036: *6* g.os_startfile
def os_startfile(fname):
    @others
    if fname.find('"') > -1:
        quoted_fname = f"'{fname}'"
    else:
        quoted_fname = f'"{fname}"'
    if sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(quoted_fname)
            # Exists only on Windows.
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            # Fix bug 1226358: File URL's are broken on MacOS:
            # use fname, not quoted_fname, as the argument to subprocess.call.
            subprocess.call(['open', fname])
        except OSError:
            pass  # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system(f"open {quoted_fname}")
    else:
        try:
            ree = None
            wre = tempfile.NamedTemporaryFile()
            ree = io.open(wre.name, 'rb', buffering=0)
        except IOError:
            g.trace(f"error opening temp file for {fname!r}")
            if ree: ree.close()
            return
        try:
            subPopen = subprocess.Popen(['xdg-open', fname], stderr=wre, shell=False)
        except Exception:
            g.es_print(f"error opening {fname!r}")
            g.es_exception()
        try:
            itoPoll = g.IdleTime(
                (lambda ito: itPoll(fname, ree, subPopen, g, ito)),
                delay=1000,
            )
            itoPoll.start()
            # Let the Leo-Editor process run
            # so that Leo-Editor is usable while the file is open.
        except Exception:
            g.es_exception(f"exception executing g.startfile for {fname!r}")
#@+node:bob.20170516112250.1: *7* stderr2log()
def stderr2log(g, ree, fname):
    """ Display stderr output in the Leo-Editor log pane

    Arguments:
        g:  Leo-Editor globals
        ree:  Read file descriptor for stderr
        fname:  file pathname

    Returns:
        None
    """

    while True:
        emsg = ree.read().decode('utf-8')
        if emsg:
            g.es_print_error(f"xdg-open {fname} caused output to stderr:\n{emsg}")
        else:
            break
#@+node:bob.20170516112304.1: *7* itPoll()
def itPoll(fname, ree, subPopen, g, ito):
    """ Poll for subprocess done

    Arguments:
        fname:  File name
        ree:  stderr read file descriptor
        subPopen:  URL open subprocess object
        g: Leo-Editor globals
        ito: Idle time object for itPoll()

    Returns:
        None
    """

    stderr2log(g, ree, fname)
    rc = subPopen.poll()
    if not rc is None:
        ito.stop()
        ito.destroy_self()
        if rc != 0:
            g.es_print(f"xdg-open {fname} failed with exit code {rc}")
        stderr2log(g, ree, fname)
        ree.close()
#@+node:ekr.20031218072017.2160: *6* g.toUnicodeFileEncoding
def toUnicodeFileEncoding(path):
    # Fix bug 735938: file association crash
    if path and isinstance(path, str):
        path = path.replace('\\', os.sep)
        # Yes, this is correct.  All os_path_x functions return Unicode strings.
        return g.toUnicode(path)
    return ''
#@+node:ekr.20111115155710.9859: *5* g.Parsing & Tokenizing
#@+node:ekr.20031218072017.822: *6* g.createTopologyList
def createTopologyList(c, root=None, useHeadlines=False):
    """Creates a list describing a node and all its descendents"""
    if not root: root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(), v.headString()),]
    else:
        aList = [v.numberOfChildren()]
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c, child, useHeadlines))
        child = child.next()
    return aList
#@+node:ekr.20111017204736.15898: *6* g.getDocString
def getDocString(s):
    """Return the text of the first docstring found in s."""
    tags = ('"""', "'''")
    tag1, tag2 = tags
    i1, i2 = s.find(tag1), s.find(tag2)
    if i1 == -1 and i2 == -1:
        return ''
    if i1 > -1 and i2 > -1:
        i = min(i1, i2)
    else:
        i = max(i1, i2)
    tag = s[i : i + 3]
    assert tag in tags
    j = s.find(tag, i + 3)
    if j > -1:
        return s[i + 3 : j]
    return ''
#@+node:ekr.20111017211256.15905: *6* g.getDocStringForFunction
def getDocStringForFunction(func):
    """Return the docstring for a function that creates a Leo command."""

    def name(func):
        return func.__name__ if hasattr(func, '__name__') else '<no __name__>'

    def get_defaults(func, i):
        defaults = inspect.getfullargspec(func)[3]
        return defaults[i]

    # Fix bug 1251252: https://bugs.launchpad.net/leo-editor/+bug/1251252
    # Minibuffer commands created by mod_scripting.py have no docstrings.
    # Do special cases first.

    s = ''
    if name(func) == 'minibufferCallback':
        func = get_defaults(func, 0)
        if hasattr(func, 'func.__doc__') and func.__doc__.strip():
            s = func.__doc__
    if not s and name(func) == 'commonCommandCallback':
        script = get_defaults(func, 1)
        s = g.getDocString(script)
            # Do a text scan for the function.
    # Now the general cases.  Prefer __doc__ to docstring()
    if not s and hasattr(func, '__doc__'):
        s = func.__doc__
    if not s and hasattr(func, 'docstring'):
        s = func.docstring
    return s
#@+node:ekr.20111115155710.9814: *6* g.python_tokenize
def python_tokenize(s, line_numbers=True):
    """
    Tokenize string s and return a list of tokens (kind,value,line_number)

    where kind is in ('comment,'id','nl','other','string','ws').
    """
    result, i, line_number = [], 0, 0
    while i < len(s):
        progress = j = i
        ch = s[i]
        if ch == '\n':
            kind, i = 'nl', i + 1
        elif ch in ' \t':
            kind = 'ws'
            while i < len(s) and s[i] in ' \t':
                i += 1
        elif ch == '#':
            kind, i = 'comment', g.skip_to_end_of_line(s, i)
        elif ch in '"\'':
            kind, i = 'string', g.skip_python_string(s, i, verbose=False)
        elif ch == '_' or ch.isalpha():
            kind, i = 'id', g.skip_id(s, i)
        else:
            kind, i = 'other', i + 1
        assert progress < i and j == progress
        val = s[j:i]
        assert val
        if line_numbers:
            line_number += val.count('\n')  # A comment.
            result.append((kind, val, line_number),)
        else:
            result.append((kind, val),)
    return result
#@+node:ekr.20040327103735.2: *5* g.Scripting
#@+node:ekr.20161223090721.1: *6* g.exec_file
def exec_file(path, d, script=None):
    """Simulate python's execfile statement for python 3."""
    if script is None:
        with open(path) as f:
            script = f.read()
    exec(compile(script, path, 'exec'), d)
#@+node:ekr.20131016032805.16721: *6* g.execute_shell_commands
def execute_shell_commands(commands, trace=False):
    """
    Execute each shell command in a separate process.
    Wait for each command to complete, except those starting with '&'
    """
    if isinstance(commands, str):
        commands = [commands]
    for command in commands:
        wait = not command.startswith('&')
        if trace: g.trace(command)
        if command.startswith('&'):
            command = command[1:].strip()
        proc = subprocess.Popen(command, shell=True)
        if wait:
            proc.communicate()
        else:
            if trace: print('Start:', proc)
            # #1489: call proc.poll at idle time.

            def proc_poller(timer, proc=proc):
                val = proc.poll()
                if val is not None:
                    # This trace can be disruptive.
                    if trace: print('  End:', proc, val)
                    timer.stop()

            g.IdleTime(proc_poller, delay=0).start()
#@+node:ekr.20180217113719.1: *6* g.execute_shell_commands_with_options & helpers
def execute_shell_commands_with_options(
    base_dir=None,
    c=None,
    command_setting=None,
    commands=None,
    path_setting=None,
    trace=False,
    warning=None,
):
    """
    A helper for prototype commands or any other code that
    runs programs in a separate process.
    
    base_dir:           Base directory to use if no config path given.
    commands:           A list of commands, for g.execute_shell_commands.
    commands_setting:   Name of @data setting for commands.
    path_setting:       Name of @string setting for the base directory.
    warning:            A warning to be printed before executing the commands.
    """
    base_dir = g.computeBaseDir(c, base_dir, path_setting, trace)
    if not base_dir:
        return
    commands = g.computeCommands(c, commands, command_setting, trace)
    if not commands:
        return
    if warning:
        g.es_print(warning)
    os.chdir(base_dir)  # Can't do this in the commands list.
    g.execute_shell_commands(commands)
#@+node:ekr.20180217152624.1: *7* g.computeBaseDir
def computeBaseDir(c, base_dir, path_setting, trace=False):
    """
    Compute a base_directory.
    If given, @string path_setting takes precedence.
    """
    # Prefer the path setting to the base_dir argument.
    if path_setting:
        if not c:
            return g.es_print('@string path_setting requires valid c arg')
        # It's not an error for the setting to be empty.
        base_dir2 = c.config.getString(path_setting)
        if base_dir2:
            base_dir2 = base_dir2.replace('\\', '/')
            if g.os_path_exists(base_dir2):
                return base_dir2
            return g.es_print(f"@string {path_setting} not found: {base_dir2!r}")
    # Fall back to given base_dir.
    if base_dir:
        base_dir = base_dir.replace('\\', '/')
        if g.os_path_exists(base_dir):
            return base_dir
        return g.es_print(f"base_dir not found: {base_dir!r}")
    return g.es_print(f"Please use @string {path_setting}")
#@+node:ekr.20180217153459.1: *7* g.computeCommands
def computeCommands(c, commands, command_setting, trace=False):
    """
    Get the list of commands.
    If given, @data command_setting takes precedence.
    """
    if not commands and not command_setting:
        g.es_print('Please use commands, command_setting or both')
        return []
    # Prefer the setting to the static commands.
    if command_setting:
        if c:
            aList = c.config.getData(command_setting)
            # It's not an error for the setting to be empty.
            # Fall back to the commands.
            return aList or commands
        g.es_print('@data command_setting requires valid c arg')
        return []
    return commands
#@+node:ekr.20050503112513.7: *6* g.executeFile
def executeFile(filename, options=''):
    if not os.access(filename, os.R_OK): return
    fdir, fname = g.os_path_split(filename)
    # New in Leo 4.10: alway use subprocess.

    def subprocess_wrapper(cmdlst):

        p = subprocess.Popen(cmdlst, cwd=fdir,
            universal_newlines=True,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdo, stde = p.communicate()
        return p.wait(), stdo, stde

    rc, so, se = subprocess_wrapper(f"{sys.executable} {fname} {options}")
    if rc: g.pr('return code', rc)
    g.pr(so, se)
#@+node:ekr.20040321065415: *6* g.findNode... &,findTopLevelNode
def findNodeInChildren(c, p, headline, exact=True):
    """Search for a node in v's tree matching the given headline."""
    p1 = p.copy()
    h = headline.strip()
    for p in p1.children():
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in p1.children():
            if p.h.strip().startswith(h):
                return p.copy()
    return None

def findNodeInTree(c, p, headline, exact=True):
    """Search for a node in v's tree matching the given headline."""
    h = headline.strip()
    p1 = p.copy()
    for p in p1.subtree():
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in p1.subtree():
            if p.h.strip().startswith(h):
                return p.copy()
    return None

def findNodeAnywhere(c, headline, exact=True):
    h = headline.strip()
    for p in c.all_unique_positions(copy=False):
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in c.all_unique_positions(copy=False):
            if p.h.strip().startswith(h):
                return p.copy()
    return None

def findTopLevelNode(c, headline, exact=True):
    h = headline.strip()
    for p in c.rootPosition().self_and_siblings(copy=False):
        if p.h.strip() == h:
            return p.copy()
    if not exact:
        for p in c.rootPosition().self_and_siblings(copy=False):
            if p.h.strip().startswith(h):
                return p.copy()
    return None
#@+node:EKR.20040614071102.1: *6* g.getScript & helpers
def getScript(c, p,
    useSelectedText=True,
    forcePythonSentinels=True,
    useSentinels=True,
):
    """
    Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if
    p is not the current node or if there is no text selection.
    """
    w = c.frame.body.wrapper
    if not p: p = c.p
    try:
        if g.app.inBridge:
            s = p.b
        elif w and p == c.p and useSelectedText and w.hasSelection():
            s = w.getSelectedText()
        else:
            s = p.b
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s, c.tab_width)
        s = g.extractExecutableString(c, p, s)
        script = g.composeScript(c, p, s,
                    forcePythonSentinels=forcePythonSentinels,
                    useSentinels=useSentinels)
    except Exception:
        g.es_print("unexpected exception in g.getScript")
        g.es_exception()
        script = ''
    return script
#@+node:ekr.20170228082641.1: *7* g.composeScript
def composeScript(c, p, s, forcePythonSentinels=True, useSentinels=True):
    """Compose a script from p.b."""
    # This causes too many special cases.
        # if not g.unitTesting and forceEncoding:
            # aList = g.get_directives_dict_list(p)
            # encoding = scanAtEncodingDirectives(aList) or 'utf-8'
            # s = g.insertCodingLine(encoding,s)
    if not s.strip():
        return ''
    at = c.atFileCommands
    old_in_script = g.app.inScript
    try:
        # #1297: set inScript flags.
        g.app.inScript = g.inScript = True
        g.app.scriptDict["script1"] = s
        # Important: converts unicode to utf-8 encoded strings.
        script = at.stringToString(p.copy(), s,
            forcePythonSentinels=forcePythonSentinels,
            sentinels=useSentinels)
        script = script.replace("\r\n", "\n")  # Use brute force.
            # Important, the script is an **encoded string**, not a unicode string.
        g.app.scriptDict["script2"] = script
    finally:
        g.app.inScript = g.inScript = old_in_script
    return script
#@+node:ekr.20170123074946.1: *7* g.extractExecutableString
def extractExecutableString(c, p, s):
    """
    Return all lines for the given @language directive.

    Ignore all lines under control of any other @language directive.
    """
    #
    # Rewritten to fix #1071.
    if g.unitTesting:
        return s  # Regretable, but necessary.
    #
    # Return s if no @language in effect. Should never happen.
    language = g.scanForAtLanguage(c, p)
    if not language:
        return s
    #
    # Return s if @language is unambiguous.
    pattern = r'^@language\s+(\w+)'
    matches = list(re.finditer(pattern, s, re.MULTILINE))
    if len(matches) < 2:
        return s
    #
    # Scan the lines, extracting only the valid lines.
    extracting, result = False, []
    for i, line in enumerate(g.splitLines(s)):
        m = re.match(pattern, line)
        if m:
            # g.trace(language, m.group(1))
            extracting = m.group(1) == language
        elif extracting:
            result.append(line)
    return ''.join(result)
#@+node:ekr.20060624085200: *6* g.handleScriptException
def handleScriptException(c, p, script, script1):
    g.warning("exception executing script")
    full = c.config.getBool('show-full-tracebacks-in-scripts')
    fileName, n = g.es_exception(full=full)
    # Careful: this test is no longer guaranteed.
    if p.v.context == c:
        try:
            c.goToScriptLineNumber(n, p)
            << dump the lines near the error >>
        except Exception:
            g.es_print('Unexpected exception in g.handleScriptException')
            g.es_exception()
#@+node:EKR.20040612215018: *7* << dump the lines near the error >>
if g.os_path_exists(fileName):
    with open(fileName) as f:
        lines = f.readlines()
else:
    lines = g.splitLines(script)
s = '-' * 20
g.es_print('', s)
# Print surrounding lines.
i = max(0, n - 2)
j = min(n + 2, len(lines))
while i < j:
    ch = '*' if i == n - 1 else ' '
    s = f"{ch} line {i+1:d}: {lines[i]}"
    g.es('', s, newline=False)
    i += 1
#@+node:ekr.20140209065845.16767: *6* g.insertCodingLine
def insertCodingLine(encoding, script):
    """
    Insert a coding line at the start of script s if no such line exists.
    The coding line must start with @first because it will be passed to
    at.stringToString.
    """
    if script:
        tag = '@first # -*- coding:'
        lines = g.splitLines(script)
        for s in lines:
            if s.startswith(tag):
                break
        else:
            lines.insert(0, f"{tag} {encoding} -*-\n")
            script = ''.join(lines)
    return script
#@+node:ekr.20070524083513: *5* g.Unit Tests
#@+node:ekr.20100812172650.5909: *6* g.findTestScript
def findTestScript(c, h, where=None, warn=True):
    if where:
        p = g.findNodeAnywhere(c, where)
        if p:
            p = g.findNodeInTree(c, p, h)
    else:
        p = g.findNodeAnywhere(c, h)
    if p:
        return g.getScript(c, p)
    if warn: g.trace('Not found', h)
    return None
#@+node:ekr.20070619173330: *6* g.getTestVars
def getTestVars():
    d = g.app.unitTestDict
    c = d.get('c')
    p = d.get('p')
    # Indicate that getTestVars has run.
    # This is an indirect test that some unit test has run.
    d['getTestVars'] = True
    return c, p and p.copy()
#@+node:ekr.20200221050038.1: *6* g.run_unit_test_in_separate_process
def run_unit_test_in_separate_process(command):
    """
    A script to be run from unitTest.leo.
    
    Run the unit testing command (say `python -m leo.core.leoAst`) in a separate process.
    
    Fail (in leoTest.leo) if that fails.
    """
    leo_editor_dir = os.path.join(g.app.loadDir, '..', '..')
    os.chdir(leo_editor_dir)
    p = subprocess.Popen(
        shlex.split(command),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        shell=sys.platform.startswith('win'),
    )
    out, err = p.communicate()
    err = g.toUnicode(err)
    out = g.toUnicode(out)
    print('')
    print(command)
    if out.strip():
        # print('traces...')
        print(out.rstrip())
    print(err.rstrip())
    # There may be skipped tests...
    err_lines = g.splitLines(err.rstrip())
    assert err_lines[-1].startswith('OK')
#@+node:ekr.20080919065433.2: *6* g.toEncodedStringWithErrorCode (for unit testing)
def toEncodedStringWithErrorCode(s, encoding, reportErrors=False):
    """For unit testing: convert s to an encoded string and return (s,ok)."""
    ok = True
    if g.isUnicode(s):
        try:
            s = s.encode(encoding, "strict")
        except UnicodeError:
            s = s.encode(encoding, "replace")
            if reportErrors:
                g.error(f"Error converting {s} from unicode to {encoding} encoding")
            ok = False
    return s, ok
#@+node:ekr.20080919065433.1: *6* g.toUnicodeWithErrorCode (for unit testing)
def toUnicodeWithErrorCode(s, encoding, reportErrors=False):
    """For unit testing: convert s to unicode and return (s,ok)."""
    if s is None:
        return '', True
    if isinstance(s, str):
        return s, True
    try:
        s = str(s, encoding, 'strict')
        return s, True
    except UnicodeError:
        s = str(s, encoding, 'replace')
        if reportErrors:
            g.error(f"Error converting {s} from {encoding} encoding to unicode")
        return s, False
#@+node:ekr.20120311151914.9916: *5* g.Urls
unl_regex = re.compile(r'\bunl:.*$')

kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
url_regex = re.compile(fr"""{kinds}://[^\s'"]+[\w=/]""")
#@+node:ekr.20170226093349.1: *6* g.unquoteUrl
def unquoteUrl(url):
    """Replace special characters (especially %20, by their equivalent)."""
    return urllib.parse.unquote(url)
#@+node:ekr.20120320053907.9776: *6* g.computeFileUrl
def computeFileUrl(fn, c=None, p=None):
    """
    Compute finalized url for filename fn.
    """
    # First, replace special characters (especially %20, by their equivalent).
    url = urllib.parse.unquote(fn)
    # Finalize the path *before* parsing the url.
    i = url.find('~')
    if i > -1:
        # Expand '~'.
        path = url[i:]
        path = g.os_path_expanduser(path)
        # #1338: This is way too dangerous, and a serious security violation.
            # path = g.os_path_expandExpression(path, c=c)
        path = g.os_path_finalize(path)
        url = url[:i] + path
    else:
        tag = 'file://'
        tag2 = 'file:///'
        if sys.platform.startswith('win') and url.startswith(tag2):
            path = url[len(tag2) :].lstrip()
        elif url.startswith(tag):
            path = url[len(tag) :].lstrip()
        else:
            path = url
        # #1338: This is way too dangerous, and a serious security violation.
            # path = g.os_path_expandExpression(path, c=c)
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(p)
            path = g.os_path_finalize_join(c.openDirectory, base, path)
        else:
            path = g.os_path_finalize(path)
        url = f"{tag}{path}"
    return url
#@+node:ekr.20120311151914.9917: *6* g.getUrlFromNode
def getUrlFromNode(p):
    """
    Get an url from node p:
    1. Use the headline if it contains a valid url.
    2. Otherwise, look *only* at the first line of the body.
    """
    if not p: return None
    c = p.v.context
    assert c
    table = [p.h, g.splitLines(p.b)[0] if p.b else '']
    table = [s[4:] if g.match_word(s, 0, '@url') else s for s in table]
    table = [s.strip() for s in table if s.strip()]
    # First, check for url's with an explicit scheme.
    for s in table:
        if g.isValidUrl(s):
            return s
    # Next check for existing file and add a file:// scheme.
    for s in table:
        tag = 'file://'
        url = computeFileUrl(s, c=c, p=p)
        if url.startswith(tag):
            fn = url[len(tag) :].lstrip()
            fn = fn.split('#', 1)[0]
            if g.os_path_isfile(fn):
                # Return the *original* url, with a file:// scheme.
                # g.handleUrl will call computeFileUrl again.
                return 'file://' + s
    # Finally, check for local url's.
    for s in table:
        if s.startswith("#"):
            return s
    return None
#@+node:tbrown.20090219095555.63: *6* g.handleUrl & helpers
def handleUrl(url, c=None, p=None):
    """Open a url or a unl."""
    if c and not p:
        p = c.p
    urll = url.lower()
    if urll.startswith('@url'):
        url = url[4:].lstrip()
    if (
        urll.startswith('unl:' + '//') or
        urll.startswith('file://') and url.find('-->') > -1 or
        urll.startswith('#')
    ):
        return g.handleUnl(url, c)
    try:
        return g.handleUrlHelper(url, c, p)
    except Exception:
        g.es_print("exception opening", repr(url))
        g.es_exception()
        return None
#@+node:ekr.20170226054459.1: *7* g.handleUrlHelper
def handleUrlHelper(url, c, p):
    """Open a url.  Most browsers should handle:
        ftp://ftp.uu.net/public/whatever
        http://localhost/MySiteUnderDevelopment/index.html
        file:///home/me/todolist.html
    """
    tag = 'file://'
    original_url = url
    if url.startswith(tag) and not url.startswith(tag + '#'):
        # Finalize the path *before* parsing the url.
        url = g.computeFileUrl(url, c=c, p=p)
    parsed = urlparse.urlparse(url)
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    else:
        leo_path = parsed.path
    if leo_path.endswith('\\'): leo_path = leo_path[:-1]
    if leo_path.endswith('/'): leo_path = leo_path[:-1]
    if parsed.scheme == 'file' and leo_path.endswith('.leo'):
        g.handleUnl(original_url, c)
    elif parsed.scheme in ('', 'file'):
        unquote_path = g.unquoteUrl(leo_path)
        if g.unitTesting:
            g.app.unitTestDict['os_startfile'] = unquote_path
        elif g.os_path_exists(leo_path):
            g.os_startfile(unquote_path)
        else:
            g.es(f"File '{leo_path}' does not exist")
    else:
        import webbrowser
        if g.unitTesting:
            g.app.unitTestDict['browser'] = url
        else:
            # Mozilla throws a weird exception, then opens the file!
            try:
                webbrowser.open(url)
            except Exception:
                pass
#@+node:ekr.20170226060816.1: *7* g.traceUrl
def traceUrl(c, path, parsed, url):

    print()
    g.trace('url          ', url)
    g.trace('c.frame.title', c.frame.title)
    g.trace('path         ', path)
    g.trace('parsed.fragment', parsed.fragment)
    g.trace('parsed.netloc', parsed.netloc)
    g.trace('parsed.path  ', parsed.path)
    g.trace('parsed.scheme', repr(parsed.scheme))
#@+node:ekr.20170221063527.1: *6* g.handleUnl
def handleUnl(unl, c):
    """Handle a Leo UNL. This must *never* open a browser."""
    if not unl:
        return None
    unll = unl.lower()
    if unll.startswith('unl:' + '//'):
        unl = unl[6:]
    elif unll.startswith('file://'):
        unl = unl[7:]
    unl = unl.strip()
    if not unl:
        return None
    unl = g.unquoteUrl(unl)
    # Compute path and unl.
    if unl.find('#') == -1 and unl.find('-->') == -1:
        # The path is the entire unl.
        path, unl = unl, None
    elif unl.find('#') == -1:
        # The path is empty.
        # Move to the unl in *this* commander.
        g.recursiveUNLSearch(unl.split("-->"), c, soft_idx=True)
        return c
    else:
        path, unl = unl.split('#', 1)
    if not path:
        # Move to the unl in *this* commander.
        g.recursiveUNLSearch(unl.split("-->"), c, soft_idx=True)
        return c
    if c:
        base = g.os_path_dirname(c.fileName())
        c_path = g.os_path_finalize_join(base, path)
    else:
        c_path = None
    # Look for the file in various places.
    table = (
        c_path,
        g.os_path_finalize_join(g.app.loadDir, '..', path),
        g.os_path_finalize_join(g.app.loadDir, '..', '..', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'core', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'config', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'dist', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'doc', path),
        g.os_path_finalize_join(g.app.loadDir, '..', 'test', path),
        g.app.loadDir,
        g.app.homeDir,
    )
    for path2 in table:
        if path2 and path2.lower().endswith('.leo') and os.path.exists(path2):
            path = path2
            break
    else:
        g.es_print('path not found', repr(path))
        return None
    # End editing in *this* outline, so typing in the new outline works.
    c.endEditing()
    c.redraw()
    if g.unitTesting:
        g.app.unitTestDict['g.recursiveUNLSearch'] = path
    else:
        c2 = g.openWithFileName(path, old_c=c)
        if unl:
            g.recursiveUNLSearch(unl.split("-->"), c2 or c, soft_idx=True)
        if c2:
            c2.bringToFront()
            return c2
    return None
#@+node:ekr.20120311151914.9918: *6* g.isValidUrl
def isValidUrl(url):
    """Return true if url *looks* like a valid url."""
    table = (
        'file', 'ftp', 'gopher', 'hdl', 'http', 'https', 'imap',
        'mailto', 'mms', 'news', 'nntp', 'prospero', 'rsync', 'rtsp', 'rtspu',
        'sftp', 'shttp', 'sip', 'sips', 'snews', 'svn', 'svn+ssh', 'telnet', 'wais',
    )
    if url.lower().startswith('unl:' + '//') or url.startswith('#'):
        # All Leo UNL's.
        return True
    if url.startswith('@'):
        return False
    parsed = urlparse.urlparse(url)
    scheme = parsed.scheme
    for s in table:
        if scheme.startswith(s):
            return True
    return False
#@+node:ekr.20120315062642.9744: *6* g.openUrl
def openUrl(p):
    """
    Open the url of node p.
    Use the headline if it contains a valid url.
    Otherwise, look *only* at the first line of the body.
    """
    if p:
        url = g.getUrlFromNode(p)
        if url:
            c = p.v.context
            if not g.doHook("@url1", c=c, p=p, url=url):
                g.handleUrl(url, c=c, p=p)
            g.doHook("@url2", c=c, p=p, url=url)
#@+node:ekr.20110605121601.18135: *6* g.openUrlOnClick (open-url-under-cursor)
def openUrlOnClick(event, url=None):
    """Open the URL under the cursor.  Return it for unit testing."""
    # This can be called outside Leo's command logic, so catch all exceptions.
    try:
        return openUrlHelper(event, url)
    except Exception:
        g.es_exception()
        return None
#@+node:ekr.20170216091704.1: *7* g.openUrlHelper
def openUrlHelper(event, url=None):
    """Open the UNL or URL under the cursor.  Return it for unit testing."""
    c = getattr(event, 'c', None)
    if not c:
        return None
    w = getattr(event, 'w', c.frame.body.wrapper)
    if not g.app.gui.isTextWrapper(w):
        g.internalError('must be a text wrapper', w)
        return None
    setattr(event, 'widget', w)
    # Part 1: get the url.
    if url is None:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = w.getSelectionRange()
        if i != j:
            return None  # So find doesn't open the url.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        line = s[i:j]
        # Find the url on the line.
        for match in g.url_regex.finditer(line):
            # Don't open if we click after the url.
            if match.start() <= col < match.end():
                url = match.group()
                if g.isValidUrl(url):
                    break
        else:
            # Look for the unl:
            for match in g.unl_regex.finditer(line):
                # Don't open if we click after the unl.
                if match.start() <= col < match.end():
                    unl = match.group()
                    g.handleUnl(unl, c)
                    return None
    elif not isinstance(url, str):
        url = url.toString()
        url = g.toUnicode(url)
            # Fix #571
    if url and g.isValidUrl(url):
        # Part 2: handle the url
        p = c.p
        if not g.doHook("@url1", c=c, p=p, url=url):
            g.handleUrl(url, c=c, p=p)
        g.doHook("@url2", c=c, p=p)
        return url
    # Part 3: call find-def.
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if word:
        c.findCommands.findDef(event)
    return None
#@+node:ekr.20110605121601.17862: *4* Qt gui
# These files are true plugins, but it is more convenient to put them here.
#@+node:ekr.20171031111403.1: *5* Leo Edit Pane
#@+node:tbrown.20171029210211.1: *6* @file ../plugins/editpane/clicky_splitter.py
@language python
"""
clicky_splitter.py - a QSplitter which allows flipping / rotating of
content by clicking on the splitter handle

Terry Brown, TerryNBrown@gmail.com, Sun Oct 29 21:02:25 2017
"""

from leo.core.leoQt import QtCore, QtWidgets


class ClickySplitterHandle(QtWidgets.QSplitterHandle):
    """Handle which notifies splitter when it's clicked"""

    def mouseReleaseEvent(self, event):
        """mouse event - mouse released on splitter handle,

        Args:
            event (QMouseEvent): mouse event
        """
        if event.button() == QtCore.Qt.LeftButton:
            return  # might have been resizing panes
        self.splitter().flip_spin()


class ClickySplitter(QtWidgets.QSplitter):
    """Splitter that rotates / flips when its handle's clicked"""

    def __init__(self, *args, **kwargs):
        """set initial state"""
        super().__init__(*args, **kwargs)
        self._click_state = 'spin'

    def createHandle(self):
        """use custom handle"""
        return ClickySplitterHandle(self.orientation(), self)

    def flip_spin(self):
        """swap or rotate"""
        if self._click_state == 'flip':
            self.insertWidget(0, self.widget(1))
            self._click_state = 'spin'
        else:
            self.setOrientation(
                QtCore.Qt.Vertical
                if self.orientation() == QtCore.Qt.Horizontal
                else QtCore.Qt.Horizontal
            )
            self._click_state = 'flip'

#@+node:tbrown.20171028115144.6: *6* @file ../plugins/editpane/editpane.py
"""Support for the edit-pane-test-open command and window."""
<<editpane.py imports>>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115438.1: *7* << editpane.py imports >>
import leo.core.leoGlobals as g
import leo.core.signal_manager as sig
try:
    # this can fix an issue with Qt Web views in Ubuntu
    from OpenGL import GL
    assert GL  # To keep pyflakes happy.
except Exception:
    # but not need to stop if it doesn't work
    pass
from collections import defaultdict
from leo.core.leoQt import QtCore, QtWidgets, QtConst  # QtGui
if QtCore is not None:
    from leo.plugins.editpane.clicky_splitter import ClickySplitter
from importlib import import_module
import os
#@+node:tbrown.20171028115438.2: *7* DBG
def DBG(text):
    """DBG - temporary debugging function

    :param str text: text to print
    """
    print(f"LEP: {text}")
#@+node:tbrown.20171028115438.3: *7* edit_pane_test_open
def edit_pane_test_open(event):
    """Make a command for opening the editpane in free_layout.

    This is just for testing / demoing, and will be removed eventually.
    """
    c = event['c']

    if not hasattr(c, '__edit_pane_test'):
        c.__edit_pane_test = True


        class MinimalDemoProvider:

            def ns_provides(self):
                return [("Demo editor", "__demo_provider_minimal_slider")]

            def ns_provide(self, id_):
                if id_ == "__demo_provider_minimal_slider":
                    w = LeoEditPane(c=c, mode='split')
                    return w
                return None

            def ns_provider_id(self):
                return "__demo_provider_minimal"

        c.free_layout.get_top_splitter().register_provider(MinimalDemoProvider())

    s = c.free_layout.get_top_splitter()
    s.open_window("__demo_provider_minimal_slider")
#@+node:tbrown.20180207103918.1: *7* edit_pane_csv
def edit_pane_csv(event):
    from leo.plugins.nested_splitter import NestedSplitter
    c = event['c']
    w = c.frame.body.widget
    while not isinstance(w, NestedSplitter):
        w = w.parent()
    w.insert(-1, LeoEditPane(c=c, show_control=False, lep_type='EDITOR-CSV'))
#@+node:tbrown.20171028115438.4: *7* class LeoEditPane
class LeoEditPane(QtWidgets.QWidget):
    """
    Leo node body editor / viewer
    """
    @others
#@+node:tbrown.20171028115438.5: *8* __init__
def __init__(self, c=None, p=None, mode='edit', show_head=True, show_control=True,
    update=True, recurse=False, lep_type=None, *args, **kwargs):
    """__init__ - bind to outline

    :param outline c: outline to bind to
    :param position p: initial position
    :param str mode: 'edit' | 'view' | 'split'
    :param bool show_head: show header
    :param bool show_control: show controls
    :param bool update: update view pane when text changes
    :param bool recurse: render view pane recursively
    :param str or [str] lep_type: 'EDITOR' or ['EDITOR', 'HTML']
    :param list *args: pass through
    :param dict **kwargs: pass through
    """
    DBG("__init__ LEP")
    super(LeoEditPane, self).__init__(*args, **kwargs)
    self.setAttribute(QtConst.WA_DeleteOnClose)

    lep_type = lep_type or ['EDITOR', 'TEXT']
    if isinstance(lep_type, str):
        lep_type = [lep_type]
    if len(lep_type) < 2:
        lep_type.append('TEXT')

    self.modules = []  # modules we collect widgets from
    self.widget_classes = []  # collected widgets
    self.widget_for = defaultdict(lambda: [])  # widget by class.lep_type

    self.c = c
    p = p or self.c.p
    self.mode = mode

    self.gnx = p.gnx

    self.load_modules()

    self._build_layout(
        show_head=show_head,
        show_control=show_control,
        update=update,
        recurse=recurse,
    )

    self.track = self.cb_track.isChecked()
    self.update = self.cb_update.isChecked()
    self.recurse = self.cb_recurse.isChecked()
    self.goto = self.cb_goto.isChecked()

    for type_ in lep_type:
        self.set_widget(lep_type=type_)

    self.set_mode(self.mode)

    self.handlers = [
        ('select1', self._before_select),
        ('select2', self._after_select),
        # ('bodykey2', self._after_body_key),
    ]
    self._register_handlers()
#@+node:tbrown.20171028115438.6: *8* _add_checkbox
def _add_checkbox(self, text, state_changed, tooltip, checked=True,
    enabled=True, button_label=True):
    """
    _add_checkbox - helper to add a checkbox

    :param str text: Text for label
    :param function state_changed: callback for state_changed signal
    :param bool checked: initially checked?
    :param bool enabled: initially enabled?
    :param bool button_label: label should be a button for single shot use
    :return: QCheckBox
    """
    cbox = QtWidgets.QCheckBox('' if button_label else text, self)
    self.control.layout().addWidget(cbox)
    btn = None
    if button_label:
        btn = QtWidgets.QPushButton(text, self)
        self.control.layout().addWidget(btn)

        def cb(checked, cbox=cbox, state_changed=state_changed):
            state_changed(cbox.isChecked(), one_shot=True)

        btn.clicked.connect(cb)
        btn.setToolTip(tooltip)
    cbox.setChecked(checked)
    cbox.setEnabled(enabled)
    cbox.stateChanged.connect(state_changed)
    cbox.setToolTip(tooltip)
    self.control.layout().addItem(QtWidgets.QSpacerItem(20, 0))
    return cbox
#@+node:tbrown.20171028115438.7: *8* _add_frame
def _add_frame(self):
    """_add_frame - add a widget with a layout as a hiding target.

    i.e. a container we can hide / show easily"""
    w = QtWidgets.QWidget(self)
    self.layout().addWidget(w)
    w.setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Maximum)
    w.setLayout(QtWidgets.QHBoxLayout())
    w.layout().setContentsMargins(0, 0, 0, 0)
    w.layout().setSpacing(0)
    return w
#@+node:tbrown.20171028115438.8: *8* _after_body_key
def _after_body_key(self, v):
    """_after_body_key - after Leo selects another node

    FIXME: although class EditCommandsClass-->insert &
    delete...-->selfInsertCommand() implies that bodykey2 should fire
    after all keys, it doesn't seem to fire after \n, backspace, delete
    etc., so the viewer gets out of date for those keys. The simplest
    fix would be a new bodychanged2 hook.

    :param str tag: handler name ("bodykey2")
    :param dict keywords: c, p, etc.
    :return: None
    """
    p = self.c.vnode2position(v)
    DBG("after body key")
    #X if self.update:
    self.update_position(p)
#@+node:tbrown.20171028115438.9: *8* _after_select
def _after_select(self, tag, keywords):
    """_after_select - after Leo selects another node

    :param str tag: handler name ("select2")
    :param dict keywords: c, new_p, old_p
    :return: None
    """
    c = keywords['c']
    if c != self.c:
        return None

    DBG("after select")

    if self.track:
        self.new_position(keywords['new_p'])
    return None
#@+node:tbrown.20171028115438.10: *8* _before_select
def _before_select(self, tag, keywords):
    """_before_select - before Leo selects another node

    :param str tag: handler name ("select1")
    :param dict keywords: c, new_p, old_p
    :return: None
    """

    c = keywords['c']
    if c != self.c:
        return None

    # currently nothing to do here, focusOut in widget takes care
    # of any text updates

    # BUT keyboard driven position change might need some action here
    # BUT then again, textChanged in widget is probably sufficient

    DBG("before select")

    return None
#@+node:tbrown.20171028115438.11: *8* _find_gnx_node
def _find_gnx_node(self, gnx):
    """Return the first position having the given gnx."""
    if self.c.p.gnx == gnx:
        return self.c.p
    for p in self.c.all_unique_positions():
        if p.v.gnx == gnx:
            return p
    g.es("Edit/View pane couldn't find node")
    return None
#@+node:tbrown.20171028115438.12: *8* _register_handlers
def _register_handlers(self):
    """_register_handlers - attach to Leo signals
    """
    DBG("\nregister handlers")
    for hook, handler in self.handlers:
        g.registerHandler(hook, handler)

    sig.connect(self.c, 'body_changed', self._after_body_key)
#@+node:tbrown.20171028115438.13: *8* _build_layout
def _build_layout(
    self, show_head=True, show_control=True, update=True, recurse=False):
    """build_layout - build layout
    """
    DBG("build layout")
    self.setLayout(QtWidgets.QVBoxLayout())
    self.layout().setContentsMargins(0, 0, 0, 0)
    self.layout().setSpacing(0)

    # header
    self.header = self._add_frame()
    self.toggle_ctrl = QtWidgets.QPushButton("-", self)
    self.header.layout().addWidget(self.toggle_ctrl)
    self.line_edit = QtWidgets.QLineEdit(self)
    self.header.layout().addWidget(self.line_edit)
    self.header.layout().addStretch(1)
    self.btn_close = QtWidgets.QPushButton("X", self)
    self.btn_close.clicked.connect(lambda checked: self.close())
    self.header.layout().addWidget(self.btn_close)

    # controls
    self.control = self._add_frame()
    # checkboxes
    txt = ",\ncheck to do this always"
    self.cb_track = self._add_checkbox("Track", self.change_track,
        "Track the node selected in the tree" + txt)
    self.cb_goto = self._add_checkbox("Goto", self.change_goto,
        "Make the tree go to this node" + txt)
    self.cb_update = self._add_checkbox("Update", self.change_update,
        "Update view to match changed node" + txt)
    self.cb_recurse = self._add_checkbox("Recurse", self.change_recurse,
        "Recursive view" + txt, checked=recurse)
    # mode menu
    btn = self.btn_mode = QtWidgets.QPushButton("Mode", self)
    self.control.layout().addWidget(btn)
    btn.setContextMenuPolicy(QtConst.CustomContextMenu)
    btn.customContextMenuRequested.connect(  # right click
        lambda pnt: self.mode_menu())
    btn.clicked.connect(  # or left click
        lambda checked: self.mode_menu())

    # misc. menu
    btn = self.control_menu_button = QtWidgets.QPushButton("More\u25BE", self)
    self.control.layout().addWidget(btn)
    btn.setContextMenuPolicy(QtConst.CustomContextMenu)
    btn.customContextMenuRequested.connect(  # right click
        lambda pnt: self.misc_menu())
    btn.clicked.connect(  # or left click
        lambda checked: self.misc_menu())

    # padding
    self.control.layout().addItem(
        QtWidgets.QSpacerItem(0, 0, hPolicy=QtWidgets.QSizePolicy.Expanding))

    # content
    self.splitter = ClickySplitter(self)
    self.splitter.setOrientation(QtCore.Qt.Vertical)
    self.layout().addWidget(self.splitter)
    self.edit_frame = self._add_frame()
    self.splitter.addWidget(self.edit_frame)
    self.view_frame = self._add_frame()
    self.splitter.addWidget(self.view_frame)

    self.control_visible = show_control
    self.header_visible = show_head
    self.show()

    # debug
    self.line_edit.setText("test")

    # toggle control visibility
    self.toggle_ctrl.clicked.connect(
        lambda checked: self.control.setVisible(not self.control.isVisible()))
#@+node:tbrown.20171028115438.14: *8* header_visible
@property
def header_visible(self):
    return self.header.isVisible()
#@+node:tbrown.20171028115438.15: *8* header_visible
@header_visible.setter
def header_visible(self, state):
    self.header.setVisible(state)
#@+node:tbrown.20171028115438.16: *8* control_visible
@property
def control_visible(self):
    return self.control.isVisible()
#@+node:tbrown.20171028115438.17: *8* control_visible
@control_visible.setter
def control_visible(self, state):
    self.control.setVisible(state)
#@+node:tbrown.20171028115438.18: *8* change_goto
def change_goto(self, state, one_shot=False):
    self.goto = one_shot or bool(state)
    self.state_changed()
    self.goto = bool(state)
#@+node:tbrown.20171028115438.19: *8* change_recurse
def change_recurse(self, state, one_shot=False):
    self.recurse = one_shot or bool(state)
    self.state_changed()
    self.recurse = bool(state)
#@+node:tbrown.20171028115438.20: *8* change_track
def change_track(self, state, one_shot=False):
    self.track = one_shot or bool(state)
    if self.track:
        p = self.c.p
        self.new_position(p)
    self.track = bool(state)
#@+node:tbrown.20171028115438.21: *8* change_update
def change_update(self, state, one_shot=False):
    self.update = one_shot or bool(state)
    if self.update:
        p = self.get_position()
        if p is not None:
            self.new_position(p)
    self.update = bool(state)
#@+node:tbrown.20171028115438.22: *8* close
def close(self):
    """close - clean up
    """
    do_close = QtWidgets.QWidget.close(self)
    if do_close:
        sig.disconnect_all(self)
        DBG("unregister handlers\n")
        for hook, handler in self.handlers:
            g.unregisterHandler(hook, handler)
    return do_close
#@+node:tbrown.20171028115438.23: *8* edit_widget_focus
def edit_widget_focus(self):
    """edit_widget_focus - edit widget got focus"""
    if self.goto:
        self.goto_node()
    self.update_position(self.get_position())
#@+node:tbrown.20171028115438.24: *8* get_position
def get_position(self):
    """get_position - get current position"""
    return self._find_gnx_node(self.gnx)
#@+node:tbrown.20171028115438.25: *8* goto_node
def goto_node(self):
    """goto_node - goto node being edited / viewed"""
    p = self.get_position()
    if p and p != self.c.p:
        self.c.selectPosition(p)
#@+node:tbrown.20171028115438.26: *8* load_modules
def load_modules(self):
    """load_modules - load modules to find widgets
    """
    module_dir = os.path.dirname(__file__)
    names = [os.path.splitext(i) for i in os.listdir(module_dir)
             if os.path.isfile(os.path.join(module_dir, i))]
    # FIXME: sort 'plain' to start of list for devel.
    names.sort(key=lambda x: (not x[0].startswith('plain'), x[0]))
    modules = []
    for name in [i[0] for i in names if i[1].lower() == '.py']:
        try:
            modules.append(import_module('leo.plugins.editpane.' + name))
            DBG(f"Loaded module: {name}")
        except ImportError as e:
            DBG(
                f"{e.__class__.__name__}: "
                f"Module not loaded (unmet dependencies?): {name}")
    for module in modules:
        for key in dir(module):
            value = getattr(module, key)
            if hasattr(value, 'lep_type') and value not in self.widget_classes:
                if module not in self.modules:
                    self.modules.append(module)
                self.widget_classes.append(value)
                self.widget_for[value.lep_type].append(value)
#@+node:tbrown.20171028115438.27: *8* misc_menu
def misc_menu(self):
    """build menu on Action button"""

    # info needed to separate edit and view widgets in self.widget_classes
    name_test_current = [
        ("Editor", lambda x: x.lep_type == 'EDITOR', self.edit_widget.__class__),
        ("Viewer", lambda x: x.lep_type != 'EDITOR', self.view_widget.__class__),
    ]

    menu = QtWidgets.QMenu()
    for name, is_one, current in name_test_current:
        # list Editor widgets, then Viewer widgets
        for widget_class in [i for i in self.widget_classes if is_one(i)]:

            def cb(checked, widget_class=widget_class):
                self.set_widget(widget_class=widget_class)

            act = QtWidgets.QAction(f"{name}: {widget_class.lep_name}", self)
            act.setCheckable(True)
            act.setChecked(widget_class == current)
            act.triggered.connect(cb)
            menu.addAction(act)
    menu.exec_(self.mapToGlobal(self.control_menu_button.pos()))
#@+node:tbrown.20171028115438.28: *8* mode_menu
def mode_menu(self):
    """build menu on Action button"""
    menu = QtWidgets.QMenu()

    for mode in 'edit', 'view', 'split':
        act = QtWidgets.QAction(mode.title(), self)

        def cb(checked, self=self, mode=mode):
            self.set_mode(mode)

        act.triggered.connect(cb)
        act.setCheckable(True)
        act.setChecked(mode == self.mode)
        menu.addAction(act)
    menu.exec_(self.mapToGlobal(self.btn_mode.pos()))
#@+node:tbrown.20171028115438.29: *8* new_position
def new_position(self, p):
    """new_position - update editor and view for new Leo position

    :param position p: the new position
    """
    if self.track:
        self.gnx = p.gnx
    else:
        p = self.get_position()

    self.new_position_edit(p)
    self.new_position_view(p)
#@+node:tbrown.20171028115438.30: *8* new_position_edit
def new_position_edit(self, p):
    """new_position_edit - update editor for new position

    WARNING: unlike new_position() this uses p without regard
             for self.track

    :param position p: the new position
    """

    DBG("new edit position")
    if self.mode != 'view':
        self.edit_widget.new_text(p.b)
#@+node:tbrown.20171028115438.31: *8* new_position_view
def new_position_view(self, p):
    """new_position_view - update viewer for new position

    WARNING: unlike new_position() this uses p without regard
             for self.track

    :param position p: the new position
    """
    DBG("new view position")
    if self.mode != 'edit':
        if self.recurse:
            text = g.getScript(self.c, p, useSelectedText=False, useSentinels=False)
        else:
            text = p.b
        self.view_widget.new_text(text)
#@+node:tbrown.20171028115438.32: *8* text_changed
def text_changed(self, new_text):
    """text_changed - node text changed by this LEP's editor"""

    # Update p.b
    p = self.get_position()
    sig.lock(self)
    p.b = new_text  # triggers 'body_changed' signal from c
    self.update_position_view(p)  # as we're ignoring signals
    sig.unlock(self)
#@+node:tbrown.20171028115438.33: *8* update_position
def update_position(self, p):
    """update_position - update editor and view for current Leo position

    :param position p: the new position
    """
    if self.track:
        our_p = self.c.p
        assert self.gnx == our_p.gnx
    else:
        our_p = self.get_position()

    if p.gnx == our_p.gnx:
        self.update_position_edit(p)
        if self.update:
            self.update_position_view(p)
#@+node:tbrown.20171028115438.34: *8* update_position_edit
def update_position_edit(self, p):
    """update_position_edit - update editor for current position

    WARNING: unlike update_position() this uses p without regard
             for self.track

    :param position p: the position to update to
    """

    DBG("update edit position")
    if self.mode != 'view':
        self.edit_widget.update_text(p.b)
#@+node:tbrown.20171028115438.35: *8* update_position_view
def update_position_view(self, p):
    """update_position_view - update viewer for current position

    WARNING: unlike update_position() this uses p without regard
             for self.track

    :param position p: the position to update to
    """

    DBG("update view position")
    if self.update and self.mode != 'edit':
        if self.recurse:
            text = g.getScript(self.c, p, useSelectedText=False, useSentinels=False)
        else:
            text = p.b
        self.view_widget.update_text(text)
#@+node:tbrown.20171028115438.36: *8* render
def render(self, checked):
    pass
#@+node:tbrown.20171028115438.37: *8* set_widget
def set_widget(self, widget_class=None, lep_type='TEXT'):
    """set_widget - set edit or view widget

    :param QWidget widget: widget to use
    """

    if widget_class is None:
        widget_class = [i for i in self.widget_classes if i.lep_type == lep_type][0]
    if hasattr(
        widget_class, 'lep_type') and widget_class.lep_type.startswith('EDITOR'):
        frame = self.edit_frame
        attr = 'edit_widget'
        update = self.new_position_edit
    else:
        frame = self.view_frame
        attr = 'view_widget'
        update = self.new_position_view
    widget = widget_class(c=self.c, lep=self)

    setattr(self, attr, widget)
    for i in reversed(range(frame.layout().count())):
        frame.layout().itemAt(i).widget().setParent(None)
    frame.layout().addWidget(widget)
    update(self.get_position())
#@+node:tbrown.20171028115438.38: *8* set_mode
def set_mode(self, mode):
    """set_mode - change mode edit / view / split

    :param str mode: mode to change to

    """
    self.mode = mode
    self.btn_mode.setText(f"{mode.title()}\u25BE")
    self.state_changed()
#@+node:tbrown.20171028115438.39: *8* state_changed
def state_changed(self):
    """state_changed - control state has changed
    """

    if self.goto and self.get_position() != self.c.p:
        self.goto_node()

    if self.mode == 'edit':
        self.edit_frame.show()
        self.view_frame.hide()
    elif self.mode == 'view':
        self.edit_frame.hide()
        self.view_frame.show()
    else:
       self.edit_frame.show()
       self.view_frame.show()

    self.update_position(self.c.p)
#@+node:tbrown.20171028115144.5: *6* @file ../plugins/editpane/leotextedit.py
<<leotextedit.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115508.1: *7* <<leotextedit.py imports >>
# import re
import leo.core.leoGlobals as g
assert g
from leo.core.leoQt import QtWidgets  #  QtConst, QtCore, QtGui
from leo.core.leoColorizer import JEditColorizer  # LeoHighlighter
import leo.plugins.qt_text as qt_text

# import time  # temporary for debugging

#@+node:tbrown.20171028115508.2: *7* DBG
def DBG(text):
    """DBG - temporary debugging function

    Args:
        text (str): text to print
    """
    print(f"LEP: {text}")
#@+node:tbrown.20171028115508.3: *7* class LEP_LeoTextEdit
class LEP_LeoTextEdit(QtWidgets.QTextEdit):
    """LEP_LeoTextEdit - Leo LeoEditorPane editor
    """
    lep_type = "EDITOR"
    lep_name = "Leo Text Edit"
    @others
#@+node:tbrown.20171028115508.4: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_LeoTextEdit, self).__init__(*args, **kwargs)
    self.c = c
    self.lep = lep
    self.textChanged.connect(self.text_changed)
    self.wrapper = qt_text.QTextEditWrapper(self, name='edit_pane', c=c)
    self.wrapper.widget = self
    self.highlighter = JEditColorizer(c, self, self.wrapper)

    # maybe need to go in this direction, but this is insufficient by iteself
    # g.app.gui.setFilter(c, self, self.wrapper, 'edit_pane')
#@+node:tbrown.20171028115508.5: *8* focusInEvent
def focusInEvent(self, event):
    QtWidgets.QTextEdit.focusInEvent(self, event)
    DBG("focusin()")
    self.lep.edit_widget_focus()
    #X self.update_position(self.lep.get_position())
#@+node:tbrown.20171028115508.6: *8* focusOutEvent
def focusOutEvent(self, event):
    QtWidgets.QTextEdit.focusOutEvent(self, event)
    DBG("focusout()")
#@+node:tbrown.20171028115508.7: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setPlainText(text)
#@+node:tbrown.20171028115508.8: *8* text_changed
def text_changed(self):
    """text_changed - text editor text changed"""
    if QtWidgets.QApplication.focusWidget() == self:
        DBG("text changed, focused")
        self.lep.text_changed(self.toPlainText())

    else:
        DBG("text changed, NOT focused")
#@+node:tbrown.20171028115508.9: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    DBG("update editor text")
    self.setPlainText(text)
#@+node:tbrown.20171028115144.4: *6* @file ../plugins/editpane/markdownview.py
<< markdownview.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115507.1: *7* << markdownview.py imports >>
import leo.core.leoGlobals as g
assert g
# from leo.core.leoQt import QtCore, QtGui, QtWidgets, QtConst

import markdown

# FIXME: for now, prefer the older WebKit over WebEngine.  WebEngine is
# probably superior, but needs --disable-web-security passed to the
# QApplication to load local images without a server.
try:
    from leo.plugins.editpane.webkitview import LEP_WebKitView as HtmlView
except ImportError:
    from leo.plugins.editpane.webengineview import LEP_WebEngineView as HtmlView

from leo.plugins.editpane.plaintextview import LEP_PlainTextView as TextView
#@+node:tbrown.20171028115507.2: *7* to_html
def to_html(text):
    """to_html - convert to HTML

    Args:
        text (str): markdown text to convert

    Returns:
        str: html
    """

    return markdown.markdown(
        text,
        extensions=[
            'markdown.extensions.extra',
            'markdown.extensions.codehilite',
        ]
    )
#@+node:tbrown.20171028115507.3: *7* class LEP_MarkdownView
class LEP_MarkdownView(HtmlView):
    """LEP_MarkdownView -
    """
    lep_type = "MARKDOWN"
    lep_name = "Markdown(.py) View"
    @others
#@+node:tbrown.20171028115507.4: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_MarkdownView, self).__init__(c=c, lep=lep, *args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115507.5: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setHtml(to_html(text))
#@+node:tbrown.20171028115507.6: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current position
    """
    # h = self.horizontalScrollBar().value()
    # v = self.verticalScrollBar().value()
    self.new_text(text)
    # self.horizontalScrollBar().setValue(h)
    # self.verticalScrollBar().setValue(v)
#@+node:tbrown.20171028115507.7: *7* class LEP_MarkdownHtmlView
class LEP_MarkdownHtmlView(TextView):
    """LEP_MarkdownHtmlView - view the HTML for markdown
    """
    lep_type = "MARKDOWN-HTML"
    lep_name = "Markdown(.py) Html View"
    @others
#@+node:tbrown.20171028115507.8: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_MarkdownHtmlView, self).__init__(c=c, lep=lep, *args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115507.9: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setPlainText(to_html(text))
#@+node:tbrown.20171028115144.3: *6* @file ../plugins/editpane/pandownview.py
<< pandownview.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115505.1: *7* << pandownview.py imports >>
"""Markdown view using Pandoc.

There could also be a more generic Pandoc view that handles more input
languages, but this just does markdown.
"""
from subprocess import Popen, PIPE

import leo.core.leoGlobals as g
assert g
# from leo.core.leoQt import QtCore, QtGui, QtWidgets, QtConst

# FIXME: for now, prefer the older WebKit over WebEngine.  WebEngine is
# probably superior, but needs --disable-web-security passed to the
# QApplication to load local images without a server.
try:
    from leo.plugins.editpane.webkitview import LEP_WebKitView as HtmlView
except ImportError:
    from leo.plugins.editpane.webengineview import LEP_WebEngineView as HtmlView

from leo.plugins.editpane.plaintextview import LEP_PlainTextView as TextView

#@+node:tbrown.20171028115505.2: *7* to_html
def to_html(text, from_='markdown'):
    """to_html - convert to HTML

    Args:
        text (str): markdown text to convert

    Returns:
        str: html
    """

    cmd = f"pandoc --smart --standalone --mathjax --from {from_} --to html"
    cmd = cmd.split()
    proc = Popen(cmd, stdin=PIPE, stdout=PIPE)
    out, err = proc.communicate(text)
    return out

# see if Pandoc's installed

try:
    to_html("test")
except:
    raise ImportError
#@+node:tbrown.20171028115505.3: *7* class LEP_PanDownView
class LEP_PanDownView(HtmlView):
    """LEP_MarkdownView -
    """
    lep_type = "MARKDOWN"
    lep_name = "PanDoc Markdown View"
    from_fmt = 'markdown'
    @others
#@+node:tbrown.20171028115505.4: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_PanDownView, self).__init__(c=c, lep=lep, *args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115505.5: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setHtml(to_html(text, from_=self.from_fmt))
#@+node:tbrown.20171028115505.6: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    # h = self.horizontalScrollBar().value()
    # v = self.verticalScrollBar().value()
    self.new_text(text)
    # self.horizontalScrollBar().setValue(h)
    # self.verticalScrollBar().setValue(v)
#@+node:tbrown.20171028115505.7: *7* class LEP_PanDownHtmlView
class LEP_PanDownHtmlView(TextView):
    """LEP_PanDownHtmlView - view the HTML for markdown from PanDoc
    """
    lep_type = "MARKDOWN-HTML"
    lep_name = "PanDoc Markdown Html View"
    from_fmt = 'markdown'
    @others
#@+node:tbrown.20171028115505.8: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_PanDownHtmlView, self).__init__(c=c, lep=lep, *args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115505.9: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setPlainText(to_html(text, from_=self.from_fmt))
#@+node:tbrown.20171128074654.1: *7* class LEP_PanRstView
class LEP_PanRstView(LEP_PanDownView):
    """LEP_PanDownView -
    """
    lep_type = "RST"
    lep_name = "PanDoc rst View"
    from_fmt = 'rst'
#@+node:tbrown.20171128074707.1: *7* class LEP_PanRstHtmlView
class LEP_PanRstHtmlView(LEP_PanDownHtmlView):
    """LEP_PanDownHtmlView -
    """
    lep_type = "RST-HTML"
    lep_name = "PanDoc rst Html View"
    from_fmt = 'rst'
#@+node:tbrown.20171028115144.2: *6* @file ../plugins/editpane/plaintextedit.py
<< plaintextedit.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115504.1: *7* << plaintextedit.py imports >>
import re
import leo.core.leoGlobals as g
assert g
from leo.core.leoQt import QtCore, QtGui, QtWidgets

# import time  # temporary for debugging
#@+node:tbrown.20171028115504.2: *7* DBG
def DBG(text):
    """DBG - temporary debugging function

    Args:
        text (str): text to print
    """
    print(f"LEP: {text}")
#@+node:tbrown.20171028115504.3: *7* class LEP_PlainTextEdit
class LEP_PlainTextEdit(QtWidgets.QTextEdit):
    """LEP_PlainTextEdit - simple LeoEditorPane editor
    """
    lep_type = "EDITOR"
    lep_name = "Plain Text Edit"
    @others
#@+node:tbrown.20171028115504.4: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_PlainTextEdit, self).__init__(*args, **kwargs)
    self.c = c
    self.lep = lep
    self.textChanged.connect(self.text_changed)
#@+node:tbrown.20171028115504.5: *8* focusInEvent
def focusInEvent(self, event):
    QtWidgets.QTextEdit.focusInEvent(self, event)
    DBG("focusin()")
    self.lep.edit_widget_focus()
    #X self.update_position(self.lep.get_position())
#@+node:tbrown.20171028115504.6: *8* focusOutEvent
def focusOutEvent(self, event):
    QtWidgets.QTextEdit.focusOutEvent(self, event)
    DBG("focusout()")
#@+node:tbrown.20171028115504.7: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setPlainText(text)
#@+node:tbrown.20171028115504.8: *8* text_changed
def text_changed(self):
    """text_changed - text editor text changed"""
    if QtWidgets.QApplication.focusWidget() == self:
        DBG("text changed, focused")
        self.lep.text_changed(self.toPlainText())
    else:
        DBG("text changed, NOT focused")
#@+node:tbrown.20171028115504.9: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    DBG("update editor text")
    self.setPlainText(text)
#@+node:tbrown.20171028115504.10: *7* class LEP_PlainTextEditB
class LEP_PlainTextEditB(LEP_PlainTextEdit):
    """LEP_PlainTextEditB - copy of LEP_PlainTextEdit with different
    background color to test multiple edtitors
    """
    lep_name = "Plain Text Edit 'B'"
    @others
#@+node:tbrown.20171028115504.11: *8* class BHighlighter
class BHighlighter(QtGui.QSyntaxHighlighter):
    fmt = QtGui.QTextCharFormat()
    fmt.setFontWeight(QtGui.QFont.Bold)
    fmt.setForeground(QtCore.Qt.darkMagenta)
    pattern = "\\bMy[A-Za-z]*\\b"
    regex = re.compile(pattern)
    @others
#@+node:tbrown.20171028115504.12: *9* highlightBlock
def highlightBlock(self, text):
    offset = 0
    index = self.regex.search(text)
    while index:
        start = index.start()
        length = index.end() - start
        self.setFormat(offset + start, length, self.fmt)
        offset += start + length
        index = self.regex.search(text[offset:])
#@+node:tbrown.20171028115504.13: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_PlainTextEditB, self).__init__(c=c, lep=lep, *args, **kwargs)
    self.setStyleSheet("* {background: #989; color: #222; }")
    self.highlighter = self.BHighlighter(self.document())
#@+node:tbrown.20171028115144.1: *6* @file ../plugins/editpane/plaintextview.py
<< plaintextview.py declarations >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115502.1: *7* << plaintextview.py declarations >>
import leo.core.leoGlobals as g
assert g
from leo.core.leoQt import QtWidgets  # QtCore, QtGui, QtConst
#@+node:tbrown.20171028115502.2: *7* class LEP_PlainTextView
class LEP_PlainTextView(QtWidgets.QTextBrowser):
    """LEP_PlainTextView - simplest possible LeoEditorPane viewer
    """
    lep_type = "TEXT"
    lep_name = "Plain Text View"
    @others
#@+node:tbrown.20171028115502.3: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_PlainTextView, self).__init__(*args, **kwargs)
    self.c = c
    self.lep = lep
    self.setStyleSheet("* {background: #998; color: #222; }")
#@+node:tbrown.20171028115502.4: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setPlainText(text)
#@+node:tbrown.20171028115502.5: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    h = self.horizontalScrollBar().value()
    v = self.verticalScrollBar().value()
    self.new_text(text)
    self.horizontalScrollBar().setValue(h)
    self.verticalScrollBar().setValue(v)
#@+node:tbrown.20171028115502.6: *7* class LEP_PlainTextViewB
class LEP_PlainTextViewB(LEP_PlainTextView):
    """LEP_PlainTextViewB - copy of LEP_PlainTextView with different
    background color to test multiple viewers
    """
    lep_name = "Plain Text View 'B'"
    @others
#@+node:tbrown.20171028115502.7: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_PlainTextViewB, self).__init__(c=c, lep=lep, *args, **kwargs)
    self.setStyleSheet("* {background: #899; color: #222; }")
#@+node:tbrown.20171028115143.3: *6* @file ../plugins/editpane/vanillascintilla.py
"""
vanillascintilla.py - a LeoEditPane editor that uses QScintilla
but does not try to add Leo key handling

Terry Brown, Terry_N_Brown@yahoo.com, Sat Feb  4 12:38:26 2017
"""
<< vanillascintilla.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115501.1: *7* << vanillascintilla.py imports >>
import leo.core.leoGlobals as g
assert g
from leo.core.leoQt import QtGui, QtWidgets, Qsci  # QtCore, QtConst

if Qsci is None:  # leo.core.leoQt eats ImportErrors
    raise ImportError
#@+node:tbrown.20171028115501.2: *7* DBG
def DBG(text):
    """DBG - temporary debugging function

    Args:
        text (str): text to print
    """
    print(f"LEP: {text}")
#@+node:tbrown.20171028115501.3: *7* class LEP_VanillaScintilla
class LEP_VanillaScintilla(Qsci.QsciScintilla):
    lep_type = "EDITOR"
    lep_name = "Vanilla Scintilla"
    @others
#@+node:tbrown.20171028115501.4: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_VanillaScintilla, self).__init__(*args, **kwargs)
    self.c = c
    self.lep = lep
    self.textChanged.connect(self.text_changed)

    font = QtGui.QFont()
    font.setFamily('Courier')
    font.setFixedPitch(True)
    font.setPointSize(14)

    lexer = Qsci.QsciLexerPython()
    lexer.setDefaultFont(font)
    self.setLexer(lexer)
    # self.SendScintilla(Qsci.QsciScintilla.SCI_STYLESETFONT, 1, 'Courier')

    self.setCaretLineVisible(True)
    self.setCaretLineBackgroundColor(QtGui.QColor("#ffe4e4"))
#@+node:tbrown.20171028115501.5: *8* focusInEvent
def focusInEvent(self, event):
    Qsci.QsciScintilla.focusInEvent(self, event)
    DBG("focusin()")
    self.lep.edit_widget_focus()
    #X self.update_position(self.lep.get_position())
#@+node:tbrown.20171028115501.6: *8* focusOutEvent
def focusOutEvent(self, event):
    Qsci.QsciScintilla.focusOutEvent(self, event)
    DBG("focusout()")
    #X text = self.lep.get_position()
    #X text = self.text()
    #X self.lep.c.redraw()
#@+node:tbrown.20171028115501.7: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    self.setText(text)
#@+node:tbrown.20171028115501.8: *8* text_changed
def text_changed(self):
    """text_changed - text editor text changed"""
    if QtWidgets.QApplication.focusWidget() == self:
        DBG("text changed, focused")
        self.lep.text_changed(self.text())
    else:
        DBG("text changed, NOT focused")
#@+node:tbrown.20171028115501.9: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    DBG("update editor text")
    self.setText(text)
#@+node:tbrown.20171028115143.2: *6* @file ../plugins/editpane/webengineview.py
<< webengineview.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115459.1: *7* << webengineview.py imports >>
import leo.core.leoGlobals as g
assert g
# EKR: Use QtWebKitWidgets instead of QtWebEngineWidgets
# TNB: No, there are two HTML viewers, this one must be QtWebEngineWidgets
#      it's ok if it fails to load
from PyQt5 import QtWebEngineWidgets

#@+node:tbrown.20171028115459.2: *7* class LEP_WebEngineView
class LEP_WebEngineView(QtWebEngineWidgets.QWebEngineView):
    """LEP_PlainTextView - simplest possible LeoEditorPane viewer
    """
    lep_type = "HTML"
    lep_name = "Web Engine View"
    @others
#@+node:tbrown.20171028115459.3: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_WebEngineView, self).__init__(*args, **kwargs)
    self.c = c
    self.lep = lep
#@+node:tbrown.20171028115459.4: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    :param str text: new text
    """
    # see https://stackoverflow.com/questions/36609489,
    # widget grabs focus on .setHTML()
    self.setEnabled(False)
    self.setHtml(text)
    self.setEnabled(True)
#@+node:tbrown.20171028115459.5: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    :param str text: current text
    """
    # h = self.horizontalScrollBar().value()
    # v = self.verticalScrollBar().value()
    self.new_text(text)
    # self.horizontalScrollBar().setValue(h)
    # self.verticalScrollBar().setValue(v)
#@+node:tbrown.20171028115143.1: *6* @file ../plugins/editpane/webkitview.py
<< webkitview.py imports >>
@others
@language python
@tabwidth -4
#@+node:tbrown.20171028115457.1: *7* << webkitview.py imports >>
import os
import leo.core.leoGlobals as g
assert g
from leo.core.leoQt import QtWebKit, QtWebKitWidgets
if not QtWebKitWidgets or 'engine' in g.os_path_basename(
    QtWebKitWidgets.__file__).lower():
    # not loading webkit view, webengine masquerading as webkit
    raise ImportError
#@+node:tbrown.20171028115457.2: *7* _path_from_pos
def _path_from_pos(c, p):
    """_path_from_pos - get folder for position

    FIXME: should be in Leo core somewhere.

    Args:
        p (position): position

    Returns:
        str: path
    """
    p = p.copy()

    def atfile(p):
        word0 = p.h.split()[0]
        return (
            word0 in g.app.atFileNames | set(['@auto']) or
            word0.startswith('@auto-')
        )

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    while c.positionExists(p):
        if atfile(p):  # see if it's a @<file> node of some sort
            nodepath = p.h.split(None, 1)[-1]
            nodepath = g.os_path_join(path, nodepath)
            if not g.os_path_isdir(nodepath):  # remove filename
                nodepath = g.os_path_dirname(nodepath)
            if g.os_path_isdir(nodepath):  # append if it's a directory
                path = nodepath
            break
        p.moveToParent()

    return path
#@+node:tbrown.20171028115457.3: *7* class LEP_WebKitView
class LEP_WebKitView(QtWebKitWidgets.QWebView):
    """LEP_WebKitView - Web Kit View
    """
    lep_type = "HTML"
    lep_name = "Web Kit View"
    @others
#@+node:tbrown.20171028115457.4: *8* __init__
def __init__(self, c=None, lep=None, *args, **kwargs):
    """set up"""
    super(LEP_WebKitView, self).__init__(*args, **kwargs)
    self.c = c
    self.lep = lep

    # enable inspector
    try:
        QtWebKit.QWebSettings.globalSettings().setAttribute(
          QtWebKit.QWebSettings.DeveloperExtrasEnabled, True)
    except AttributeError:
        # seems that leoQt(?) substitutes QtWebEngine for QtWebKit
        # if QtWebKit isn't available, causing this to fail
        pass
#@+node:tbrown.20171028115457.5: *8* new_text
def new_text(self, text):
    """new_text - update for new text

    Args:
        text (str): new text
    """
    owd = os.getcwd()
    path = _path_from_pos(self.c, self.c.p)
    g.es("FIXME: _path_from_pos() in WebKitView - not self.c.p")
    os.chdir(path)
    g.es(path)
    self.setHtml(text)
    os.chdir(owd)
#@+node:tbrown.20171028115457.6: *8* update_text
def update_text(self, text):
    """update_text - update for current text

    Args:
        text (str): current text
    """
    self.new_text(text)
#@+node:tbrown.20171028115144.8: *6* @file ../plugins/editpane/__init__.py
@language python
@tabwidth -4
#@+node:tbrown.20171028115541.1: *6* @file signal_manager.py
"""
signal_manager.py - SignalManager - light weight signal management

Extremely light weight.  No enforcement of signal arguments, or
even explicit listing of which signals exist.

Terry Brown, terrynbrown@gmail.com, Thu Mar 23 21:13:38 2017
"""
from collections import defaultdict
@others
if __name__ == '__main__':
    main()

@language python
@tabwidth -4
#@+node:tbrown.20171028115601.2: *7* class SignalData
class SignalData:

    def __init__(self):
        self.listeners = defaultdict(list)
        self.emitters = []
        self.locked = False
#@+node:tbrown.20171028115601.4: *7* class MsgSignalHandled
class MsgSignalHandled:
    """A listener can return SignalManager.MsgSignalHandled to prevent
    other listeners from being called
    """
    pass
#@+node:tbrown.20171028115601.5: *7* _setup
def _setup(obj):
    if not hasattr(obj, '_signal_data'):
        obj._signal_data = SignalData()
#@+node:tbrown.20171028115601.6: *7* emit
def emit(source, signal_name, *args, **kwargs):
    """Emit signal to all listeners"""
    if not hasattr(source, '_signal_data'):
        return
    if '_sig_lock' in kwargs:
        obj_to_lock = kwargs.pop('_sig_lock')
        _setup(obj_to_lock)
        obj_to_lock._signal_data.locked = True
    else:
        obj_to_lock = None

    for listener in source._signal_data.listeners[signal_name]:
        try:
            if listener.__self__._signal_data.locked:
                continue
        except AttributeError:
            pass
        response = listener(*args, **kwargs)
        if response == MsgSignalHandled:
            break

    if obj_to_lock is not None:
        obj_to_lock._signal_data.locked = False
#@+node:tbrown.20171028115601.7: *7* connect
def connect(source, signal_name, listener):
    """Connect to signal"""
    _setup(source)
    source._signal_data.listeners[signal_name].append(listener)

    if hasattr(listener, '__self__'):
        obj = listener.__self__
        _setup(obj)
        obj._signal_data.emitters.append(source)
#@+node:tbrown.20171028115601.8: *7* disconnect_all
def disconnect_all(listener):
    """Disconnect from all signals"""
    for emitter in listener._signal_data.emitters:
        for signal in emitter._signal_data.listeners:
            emitter._signal_data.listeners[signal] = [
                i for i in emitter._signal_data.listeners[signal]
                if getattr(i, '__self__', None) != listener
            ]
#@+node:tbrown.20171028115601.9: *7* is_locked
def is_locked(obj):
    return hasattr(obj, '_signal_data') and obj._signal_data.locked
#@+node:tbrown.20171028115601.10: *7* lock
def lock(obj):
    _setup(obj)
    obj._signal_data.locked = True
#@+node:tbrown.20171028115601.11: *7* unlock
def unlock(obj):
    _setup(obj)
    obj._signal_data.locked = False
#@+node:tbrown.20171028115601.12: *7* class SignalManager
class SignalManager:
    """SignalManager - light weight signal management mixin."""
    @others
#@+node:tbrown.20171028115601.13: *8* emit
def emit(self, signal_name, *args, **kwargs):
    """Emit signal to all listeners"""
    emit(self, signal_name, *args, **kwargs)
#@+node:tbrown.20171028115601.14: *8* connect
def connect(self, signal_name, listener):
    """Connect to signal"""
    connect(self, signal_name, listener)
#@+node:tbrown.20171028115601.15: *7* main
def main():
    """test of SignalManager"""

    # simple use


    class Emitter(SignalManager):

        def some_emission(self):
            self.emit('the_emission', 12, [1, 2, 3])

    def hear_emit(n, l):
        print(f"Got {n} {l}")

    emitter = Emitter()
    emitter.connect('the_emission', hear_emit)
    emitter.some_emission()

    # use with proxy and locking


    class Tester:

        def __init__(self, name, relay):
            self.name = name
            self.relay = relay
            connect(self.relay, 'work_done', self.check_work)

        def do_work(self):
            emit(self.relay, 'work_done', 4.2, animal='otters', _sig_lock=self)

        def check_work(self, num, animal='eels'):
            if is_locked(self):
                return
            print(f"{self.name} heard about {num} {animal}")


    class SomeProxy:
        """Like a public notice board"""
        pass

    relay = SomeProxy()
    a = Tester('A', relay)
    a.do_work()
    b = Tester('B', relay)
    a.do_work()
    b.do_work()
#@+node:ekr.20120419093256.10048: *5* @file ../plugins/free_layout.py
<< docstring >>
# Written by Terry Brown.
<< imports >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20110319161401.14467: *6* << docstring >> (free_layout.py)
"""
Free layout
===========

Adds flexible panel layout through context menus on the handles between panels.

Uses NestedSplitter, a more intelligent QSplitter, from leo.plugins.nested_splitter

Requires Qt.

Commands (bindable with @settings-->@keys-->@shortcuts):

free-layout-load
    Open context menu for loading a different layout,
    convenient keyboard shortcut target.
free-layout-restore
    Use the layout this outline had when it was opened.
free-layout-zoom
    Zoom or unzoom the current pane

"""
#@+node:tbrown.20110203111907.5520: *6* << imports >> (free_layout.py)
import leo.core.leoGlobals as g
from leo.core.leoQt import QtWidgets, QtCore
if QtWidgets:
    from leo.plugins.nested_splitter import NestedSplitter
        # NestedSplitterChoice
import json
#@+node:tbrown.20110203111907.5521: *6* free_layout:init
def init():
    """Return True if the free_layout plugin can be loaded."""
    return g.app.gui.guiName() == "qt"
#@+node:ekr.20110318080425.14389: *6* class FreeLayoutController
class FreeLayoutController:
    """Glue between Leo and the NestedSplitter gui widget.  All Leo aware
    code should be in here, none in NestedSplitter.

    *ALSO* implements the provider interface for NestedSplitter, in
    ns_provides, ns_provide, ns_context, ns_do_context, which
    NestedSplitter uses as callbacks to populate splitter-handle context-menu
    and the empty pane Action button menu:

    see nested_splitter.py-->class%20NestedSplitter%20(QSplitter)-->register_provider

    ns_provides
      tell NestedSplitter which Action button items we can provide
    ns_provide
      provide the advertised service when an Action button item we
      advertised is selected
    ns_context
      tell NestedSplitter which splitter-handle context-menu items
      we can provide
    ns_do_context
      provide the advertised service when a splitter-handle context-menu
      item we advertised is selected
    """
    @others
#@+node:ekr.20110318080425.14390: *7*  flc.ctor
def __init__(self, c):
    """Ctor for FreeLayoutController class."""

    # if hasattr(c,'free_layout'):
        # return
    self.c = c
    # c.free_layout = self
        # To be removed
    # g.registerHandler('after-create-leo-frame',self.bindControllers)
    # attach to an outline
    g.registerHandler('after-create-leo-frame', self.init)
    # now that the outline's set up (plugins etc.), load layout for
    # outline, can't do that sooner as plugins must be loaded first
    # to provide their widgets in panels etc.
    g.registerHandler('after-create-leo-frame2', self.loadLayouts)
    # self.init()
#@+node:tbrown.20110203111907.5522: *7*  flc.init
def init(self, tag, keys):
    """Attach to an outline and

    - add tags to widgets to indicate that they're essential
      (tree, body, log-window-tabs) and

    - tag the log-window-tabs widget as the place to put widgets
      from free-laout panes which are closed

    - register this FreeLayoutController as a provider of menu items
      for NestedSplitter
    """
    c = self.c
    if c != keys.get('c'):
        return
    # Careful: we could be unit testing.
    splitter = self.get_top_splitter()  # A NestedSplitter.
    if not splitter:
        return
    # by default NestedSplitter's context menus are disabled, needed
    # once to globally enable them
    NestedSplitter.enabled = True
    # when NestedSplitter disposes of children, it will either close
    # them, or move them to another designated widget.  Here we set
    # up two designated widgets
    logTabWidget = splitter.findChild(QtWidgets.QWidget, "logTabWidget")
    splitter.root.holders['_is_from_tab'] = logTabWidget
    splitter.root.holders['_is_permanent'] = 'TOP'
    # allow body and tree widgets to be "removed" to tabs on the log tab panel
    bodyWidget = splitter.findChild(QtWidgets.QFrame, "bodyFrame")
    bodyWidget._is_from_tab = "Body"
    treeWidget = splitter.findChild(QtWidgets.QFrame, "outlineFrame")
    treeWidget._is_from_tab = "Tree"
    # also the other tabs will have _is_from_tab set on them by the
    # offer_tabs menu callback above
    # if the log tab panel is removed, move it back to the top splitter
    logWidget = splitter.findChild(QtWidgets.QFrame, "logFrame")
    logWidget._is_permanent = True
    # tag core Leo components (see ns_provides)
    splitter.findChild(
        QtWidgets.QWidget, "outlineFrame")._ns_id = '_leo_pane:outlineFrame'
    splitter.findChild(QtWidgets.QWidget, "logFrame")._ns_id = '_leo_pane:logFrame'
    splitter.findChild(QtWidgets.QWidget, "bodyFrame")._ns_id = '_leo_pane:bodyFrame'
    splitter.register_provider(self)
    splitter.splitterClicked_connect(self.splitter_clicked)
#@+node:tbrown.20120119080604.22982: *7* flc.embed
def embed(self):
    """called from ns_do_context - embed layout in outline's
    @settings, an alternative to the Load/Save named layout system
    """
    # Careful: we could be unit testing.
    top_splitter = self.get_top_splitter()
    if not top_splitter: return
    c = self.c
    layout = top_splitter.get_saveable_layout()
    nd = g.findNodeAnywhere(c, "@data free-layout-layout")
    if not nd:
        settings = g.findNodeAnywhere(c, "@settings")
        if not settings:
            settings = c.rootPosition().insertAfter()
            settings.h = "@settings"
        nd = settings.insertAsNthChild(0)
    nd.h = "@data free-layout-layout"
    nd.b = json.dumps(layout, indent=4)
    nd = nd.parent()
    if not nd or nd.h != "@settings":
        g.es(
            "WARNING: @data free-layout-layout node is not " "under an active @settings node")
    c.redraw()
#@+node:ekr.20160424035257.1: *7* flc.get_main_splitter
def get_main_splitter(self, w=None):
    """
    Return the splitter the main splitter, or None. The main splitter is a
    NestedSplitter that contains the body pane.

    Yes, the user could delete the secondary splitter but if so, there is
    not much we can do here.
    """
    top = self.get_top_splitter()
    if top:
        w = top.find_child(QtWidgets.QWidget, "bodyFrame")
        while w:
            if isinstance(w, NestedSplitter):
                return w
            w = w.parent()
    return None
#@+node:ekr.20160424035254.1: *7* flc.get_secondary_splitter
def get_secondary_splitter(self):
    """
    Return the secondary splitter, if it exists. The secondary splitter
    contains the outline pane.

    Yes, the user could delete the outline pane, but if so, there is not
    much we can do here.
    """
    top = self.get_top_splitter()
    if top:
        w = top.find_child(QtWidgets.QWidget, 'outlineFrame')
        while w:
            if isinstance(w, NestedSplitter):
                return w
            w = w.parent()
    return None
#@+node:tbrown.20110621120042.22914: *7* flc.get_top_splitter
def get_top_splitter(self):
    """Return the top splitter of c.frame.top."""
    # Careful: we could be unit testing.
    f = self.c.frame
    if hasattr(f, 'top') and f.top:
        child = f.top.findChild(NestedSplitter)
        return child and child.top()
    return None
#@+node:ekr.20120419095424.9927: *7* flc.loadLayouts (sets wrap=True)
def loadLayouts(self, tag, keys, reloading=False):
    """loadLayouts - Load the outlines layout

    :Parameters:
    - `tag`: from hook event
    - `keys`: from hook event
    - `reloading`: True if this is not the initial load, see below

    When called from the `after-create-leo-frame2` hook this defaults
    to False.  When called from the `resotre-layout` command, this is set
    True, and the layout the outline had *when first loaded* is restored.
    Useful if you want to temporarily switch to a different layout and then
    back, without having to remember the original layouts name.
    """
    c = self.c
    if not (g.app and g.app.db):
        return  # Can happen when running from the Leo bridge.
    d = g.app.db.get('ns_layouts') or {}
    if c != keys.get('c'):
        return
    layout = c.config.getData("free-layout-layout")
    if layout:
        layout = json.loads('\n'.join(layout))
    name = c.db.get('_ns_layout')
    if name:
        if reloading:
            name = c.free_layout.original_layout
            c.db['_ns_layout'] = name
        else:
            c.free_layout.original_layout = name
        if layout:
            g.es("NOTE: embedded layout in @settings/@data free-layout-layout "
                 "overrides saved layout " + name)
        else:
            layout = d.get(name)
    # EKR: Create commands that will load each layout.
    if d:
        for name in sorted(d.keys()):

            def func(event, c=c, d=d, name=name):
                layout = d.get(name)
                if layout:
                    c.free_layout.get_top_splitter().load_layout(layout)
                else:
                    g.trace('no layout', name)

            name_s = name.strip().lower().replace(' ', '-')
            commandName = f"free-layout-load-{name_s}"
            c.k.registerCommand(commandName, func)
    # Careful: we could be unit testing or in the Leo bridge.
    if layout:
        splitter = c.free_layout.get_top_splitter()
        if splitter:
            splitter.load_layout(layout)
#@+node:tbrown.20110628083641.11730: *7* flc.ns_context
def ns_context(self):
    ans = [
        ('Embed layout', '_fl_embed_layout'),
        ('Save layout', '_fl_save_layout'),
    ]
    d = g.app.db.get('ns_layouts', {})
    if d:
        ans.append({'Load layout': [(k, '_fl_load_layout:' + k) for k in d]})
        ans.append({'Delete layout': [(k, '_fl_delete_layout:' + k) for k in d]})
        ans.append(('Forget layout', '_fl_forget_layout:'))
        ans.append(('Restore initial layout', '_fl_restore_layout:'))
    ans.append(('Restore default layout', '_fl_restore_default:'))
    ans.append(('Help for this menu', '_fl_help:'))
    return ans
#@+node:tbrown.20110628083641.11732: *7* flc.ns_do_context
def ns_do_context(self, id_, splitter, index):
    if id_.startswith('_fl_embed_layout'):
        self.embed()
        return True
    if id_.startswith('_fl_restore_default'):
        self.get_top_splitter().load_layout(
            {'content': [{'content': ['_leo_pane:outlineFrame',
             '_leo_pane:logFrame'], 'orientation': 1, 'sizes':
             [509, 275]}, '_leo_pane:bodyFrame'],
             'orientation': 2, 'sizes': [216, 216]})
    if id_.startswith('_fl_help'):
        self.c.putHelpFor(__doc__)
        # g.handleUrl("http://leoeditor.com/")
        return True
    if id_ == '_fl_save_layout':
        if self.c.config.getData("free-layout-layout"):
            g.es("WARNING: embedded layout in")
            g.es("@settings/@data free-layout-layout")
            g.es("will override saved layout")
        layout = self.get_top_splitter().get_saveable_layout()
        name = g.app.gui.runAskOkCancelStringDialog(self.c,
            title="Save layout",
            message="Name for layout?",
        )
        if name:
            self.c.db['_ns_layout'] = name
            d = g.app.db.get('ns_layouts', {})
            d[name] = layout
            # make sure g.app.db's __set_item__ is hit so it knows to save
            g.app.db['ns_layouts'] = d
        return True
    if id_.startswith('_fl_load_layout:'):
        if self.c.config.getData("free-layout-layout"):
            g.es("WARNING: embedded layout in")
            g.es("@settings/@data free-layout-layout")
            g.es("will override saved layout")
        name = id_.split(':', 1)[1]
        self.c.db['_ns_layout'] = name
        layout = g.app.db['ns_layouts'][name]
        self.get_top_splitter().load_layout(layout)
        return True
    if id_.startswith('_fl_delete_layout:'):
        name = id_.split(':', 1)[1]
        if ('yes' == g.app.gui.runAskYesNoCancelDialog(self.c,
            "Really delete Layout?",
            f"Really permanently delete the layout '{name}'?")
        ):
            d = g.app.db.get('ns_layouts', {})
            del d[name]
            # make sure g.app.db's __set_item__ is hit so it knows to save
            g.app.db['ns_layouts'] = d
            if '_ns_layout' in self.c.db:
                del self.c.db['_ns_layout']
        return True
    if id_.startswith('_fl_forget_layout:'):
        if '_ns_layout' in self.c.db:
            del self.c.db['_ns_layout']
        return True
    if id_.startswith('_fl_restore_layout:'):
        self.loadLayouts("reload", {'c': self.c}, reloading=True)
        return True
    return False
#@+node:tbrown.20110628083641.11724: *7* flc.ns_provide
def ns_provide(self, id_):
    if id_.startswith('_leo_tab:'):
        id_ = id_.split(':', 1)[1]
        top = self.get_top_splitter()
        logTabWidget = top.find_child(QtWidgets.QWidget, "logTabWidget")
        for n in range(logTabWidget.count()):
            if logTabWidget.tabText(n) == id_:
                w = logTabWidget.widget(n)
                w.setHidden(False)
                w._is_from_tab = logTabWidget.tabText(n)
                w.setMinimumSize(20, 20)
                return w
        # didn't find it, maybe it's already in a splitter
        return 'USE_EXISTING'
    if id_.startswith('_leo_pane:'):
        id_ = id_.split(':', 1)[1]
        w = self.get_top_splitter().find_child(QtWidgets.QWidget, id_)
        if w:
            w.setHidden(False)  # may be from Tab holder
            w.setMinimumSize(20, 20)
        return w
    return None
#@+node:tbrown.20110627201141.11745: *7* flc.ns_provides
def ns_provides(self):
    ans = []
    # list of things in tab widget
    logTabWidget = self.get_top_splitter(
        ).find_child(QtWidgets.QWidget, "logTabWidget")
    for n in range(logTabWidget.count()):
        text = str(logTabWidget.tabText(n))
        if text in ('Body', 'Tree'):
            continue  # handled below
        if text == 'Log':
            # if Leo can't find Log in tab pane, it creates another
            continue
        ans.append((text, '_leo_tab:' + text))
    ans.append(('Tree', '_leo_pane:outlineFrame'))
    ans.append(('Body', '_leo_pane:bodyFrame'))
    ans.append(('Tab pane', '_leo_pane:logFrame'))
    return ans
#@+node:tbnorth.20160510122413.1: *7* flc.splitter_clicked
def splitter_clicked(self, splitter, handle, event, release, double):
    """
    splitter_clicked - middle click release will zoom adjacent
    body / tree panes

    :param NestedSplitter splitter: splitter containing clicked handle
    :param NestedSplitterHandle handle: clicked handle
    :param QMouseEvent event: mouse event for click
    :param bool release: was it a Press or Release event
    :param bool double: was it a double click event
    """
    if not release or event.button() != QtCore.Qt.MidButton:
        return
    if splitter.root.zoomed:  # unzoom if *any* handle clicked
        splitter.zoom_toggle()
        return
    before = splitter.widget(splitter.indexOf(handle) - 1)
    after = splitter.widget(splitter.indexOf(handle))
    for pane in before, after:
        if pane.objectName() == 'bodyFrame':
            pane.setFocus()
            splitter.zoom_toggle()
            return
        if pane.objectName() == 'outlineFrame':
            pane.setFocus()
            splitter.zoom_toggle(local=True)
            return
#@+node:ekr.20160416065221.1: *6* commands: free_layout.py
#@+node:tbrown.20140524112944.32658: *7* @g.command free-layout-context-menu
@g.command('free-layout-context-menu')
def free_layout_context_menu(event):
    """
    Open free layout's context menu, using the first divider of the top
    splitter for context.
    """
    c = event.get('c')
    splitter = c.free_layout.get_top_splitter()
    handle = splitter.handle(1)
    handle.splitter_menu(handle.rect().topLeft())
#@+node:tbrown.20130403081644.25265: *7* @g.command free-layout-restore
@g.command('free-layout-restore')
def free_layout_restore(event):
    """
    Restore layout outline had when it was loaded.
    """
    c = event.get('c')
    c.free_layout.loadLayouts('reload', {'c': c}, reloading=True)
#@+node:tbrown.20131111194858.29876: *7* @g.command free-layout-load
@g.command('free-layout-load')
def free_layout_load(event):
    """Load layout from menu."""
    c = event.get('c')
    d = g.app.db.get('ns_layouts', {})
    menu = QtWidgets.QMenu(c.frame.top)
    for k in d:
        menu.addAction(k)
    pos = c.frame.top.window().frameGeometry().center()
    action = menu.exec_(pos)
    if action is None:
        return
    name = str(action.text())
    c.db['_ns_layout'] = name
    # layout = g.app.db['ns_layouts'][name]
    layouts = g.app.db.get('ns_layouts', {})
    layout = layouts.get(name)
    if layout:
        c.free_layout.get_top_splitter().load_layout(layout)
#@+node:tbrown.20140522153032.32658: *7* @g.command free-layout-zoom
@g.command('free-layout-zoom')
def free_layout_zoom(event):
    """(un)zoom the current pane."""
    c = event.get('c')
    c.free_layout.get_top_splitter().zoom_toggle()
#@+node:ekr.20160327060009.1: *7* free_layout:register_provider
def register_provider(c, provider_instance):
    """Register the provider instance with the top splitter."""
    # Careful: c.free_layout may not exist during unit testing.
    if c and hasattr(c, 'free_layout'):
        splitter = c.free_layout.get_top_splitter()
        if splitter:
            splitter.register_provider(provider_instance)
#@+node:ekr.20110605121601.17954: *5* @file ../plugins/nested_splitter.py
"""Nested splitter classes."""
<< imports >>
# pylint: disable=cell-var-from-loop
@others
if __name__ == "__main__":
    main()
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20110605121601.17955: *6* << imports >> (nested_splitter.py)
try:
    import leo.core.leoGlobals as g
except ImportError:
    g = None
        # This will fail when run from main function.
        # this import should be removed anyway
from leo.core.leoQt import Qt, QtCore, QtConst, QtGui, QtWidgets
import sys
# from inspect import isclass
#@+node:ekr.20110605121601.17956: *6* init
def init():
    # Allow this to be imported as a plugin,
    # but it should never be necessary to do so.
    return True
#@+node:ekr.20110605121601.17957: *6* class DemoWidget
if QtWidgets:


    class DemoWidget(QtWidgets.QWidget):
        count = 0
        @others
#@+node:ekr.20110605121601.17958: *7* __init__(DemoWidget)
def __init__(self, parent=None, color=None):
    """Ctor for DemoWidget class."""
    super().__init__(parent)
    self.setLayout(QtWidgets.QVBoxLayout())
    self.layout().setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.layout().setSpacing(0)
    text = QtWidgets.QTextEdit()
    self.layout().addWidget(text)
    DemoWidget.count += 1
    text.setPlainText(f"#{DemoWidget.count:d}")
    button_layout = QtWidgets.QHBoxLayout()
    button_layout.setContentsMargins(QtCore.QMargins(5, 5, 5, 5))
    self.layout().addLayout(button_layout)
    button_layout.addWidget(QtWidgets.QPushButton("Go"))
    button_layout.addWidget(QtWidgets.QPushButton("Stop"))
    if color:
        self.setStyleSheet(f"background-color: {color};")
#@+node:tbrown.20120418121002.25711: *6* class NestedSplitterTopLevel (QWidget)
if QtWidgets:


    class NestedSplitterTopLevel(QtWidgets.QWidget):
        """A QWidget to wrap a NestedSplitter to allow it to live in a top
        level window and handle close events properly.

        These windows are opened by the splitter handle context-menu item
        'Open Window'.

        The NestedSplitter itself can't be the top-level widget/window,
        because it assumes it can wrap itself in another NestedSplitter
        when the user wants to "Add Above/Below/Left/Right".  I.e. wrap
        a vertical nested splitter in a horizontal nested splitter, or
        visa versa.  Parent->SplitterOne becomes Parent->SplitterTwo->SplitterOne,
        where parent is either Leo's main window's QWidget 'centralwidget',
        or one of these NestedSplitterTopLevel "window frames".
        """
        @others
#@+node:tbrown.20120418121002.25713: *7* __init__
def __init__(self, *args, **kargs):
    """Init. taking note of the FreeLayoutController which owns this"""
    self.owner = kargs['owner']
    del kargs['owner']
    window_title = kargs.get('window_title')
    del kargs['window_title']
    super().__init__(*args, **kargs)
    if window_title:
        self.setWindowTitle(window_title)
#@+node:tbrown.20120418121002.25714: *7* closeEvent (NestedSplitterTopLevel)
def closeEvent(self, event):
    """A top-level NestedSplitter window has been closed, check all the
    panes for widgets which must be preserved, and move any found
    back into the main splitter."""
    widget = self.findChild(NestedSplitter)
    # top level NestedSplitter in window being closed
    other_top = self.owner.top()
    # top level NestedSplitter in main splitter
    # adapted from NestedSplitter.remove()
    count = widget.count()
    all_ok = True
    to_close = []
    # get list of widgets to close so index based access isn't
    # derailed by closing widgets in the same loop
    for splitter in widget.self_and_descendants():
        for i in range(splitter.count() - 1, -1, -1):
            to_close.append(splitter.widget(i))
    for w in to_close:
        all_ok &= (widget.close_or_keep(w, other_top=other_top) is not False)
    # it should always be ok to close the window, because it should always
    # be possible to move widgets which must be preserved back to the
    # main splitter, but if not, keep this window open
    if all_ok or count <= 0:
        self.owner.closing(self)
    else:
        event.ignore()
#@+node:ekr.20110605121601.17959: *6* class NestedSplitterChoice (QWidget)
if QtWidgets:


    class NestedSplitterChoice(QtWidgets.QWidget):
        """When a new pane is opened in a nested splitter layout, this widget
        presents a button, labled 'Action', which provides a popup menu
        for the user to select what to do in the new pane"""
        @others
#@+node:ekr.20110605121601.17960: *7* __init__ (NestedSplitterChoice)
def __init__(self, parent=None):
    """ctor for NestedSplitterChoice class."""
    super().__init__(parent)
    self.setLayout(QtWidgets.QVBoxLayout())
    button = QtWidgets.QPushButton("Action", self)  # EKR: 2011/03/15
    self.layout().addWidget(button)
    button.setContextMenuPolicy(QtConst.CustomContextMenu)
    button.customContextMenuRequested.connect(
        lambda pnt: self.parent().choice_menu(self,
            button.mapToParent(pnt)))
    button.clicked.connect(lambda: self.parent().choice_menu(self, button.pos()))
#@+node:ekr.20110605121601.17961: *6* class NestedSplitterHandle (QSplitterHandle)
if QtWidgets:


    class NestedSplitterHandle(QtWidgets.QSplitterHandle):
        """Show the context menu on a NestedSplitter splitter-handle to access
        NestedSplitter's special features"""
        @others
#@+node:ekr.20110605121601.17962: *7* nsh.__init__
def __init__(self, owner):
    """Ctor for NestedSplitterHandle class."""
    super().__init__(owner.orientation(), owner)
    # Confusing!
        # self.setStyleSheet("background-color: green;")
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.splitter_menu)
#@+node:ekr.20110605121601.17963: *7* nsh.__repr__
def __repr__(self):
    return f"(NestedSplitterHandle) at: {id(self)}"

__str__ = __repr__
#@+node:ekr.20110605121601.17964: *7* nsh.add_item
def add_item(self, func, menu, name, tooltip=None):
    """helper for splitter_menu menu building"""
    act = QtWidgets.QAction(name, self)
    act.setObjectName(name.lower().replace(' ', '-'))
    act.triggered.connect(lambda checked: func())
    if tooltip:
        act.setToolTip(tooltip)
    menu.addAction(act)
#@+node:tbrown.20131130134908.27340: *7* nsh.show_tip
def show_tip(self, action):
    """show_tip - show a tooltip, calculate the box in which
    the pointer must stay for the tip to remain visible

    :Parameters:
    - `self`: this handle
    - `action`: action triggering event to display
    """
    if action.toolTip() == action.text():
        tip = ""
    else:
        tip = action.toolTip()
    pos = QtGui.QCursor.pos()
    x = pos.x()
    y = pos.y()
    rect = QtCore.QRect(x - 5, y - 5, x + 5, y + 5)
    QtWidgets.QToolTip.showText(pos, tip, action.parentWidget(), rect)
#@+node:ekr.20110605121601.17965: *7* nsh.splitter_menu
def splitter_menu(self, pos):
    """build the context menu for NestedSplitter"""
    splitter = self.splitter()
    if not splitter.enabled:
        g.trace('splitter not enabled')
        return
    index = splitter.indexOf(self)
    # get three pairs
    widget, neighbour, count = splitter.handle_context(index)
    lr = 'Left', 'Right'
    ab = 'Above', 'Below'
    split_dir = 'Vertically'
    if self.orientation() == QtCore.Qt.Vertical:
        lr, ab = ab, lr
        split_dir = 'Horizontally'
    # blue/orange - color-blind friendly
    color = '#729fcf', '#f57900'
    sheet = []
    for i in 0, 1:
        sheet.append(widget[i].styleSheet())
        widget[i].setStyleSheet(sheet[-1] + f"\nborder: 2px solid {color[i]};")
    menu = QtWidgets.QMenu()
    menu.hovered.connect(self.show_tip)

    def pl(n):
        return 's' if n > 1 else ''

    def di(s):
        return {
            'Above': 'above',
            'Below': 'below',
            'Left': 'left of',
            'Right': 'right of',
        }[s]

    # Insert.

    def insert_callback(index=index):
        splitter.insert(index)

    self.add_item(insert_callback, menu, 'Insert',
        "Insert an empty pane here")
    # Remove, +0/-1 reversed, we need to test the one that remains
    # First see if a parent has more than two splits
    # (we could be a sole surviving child).
    max_parent_splits = 0
    up = splitter.parent()
    while isinstance(up, NestedSplitter):
        max_parent_splits = max(max_parent_splits, up.count())
        up = up.parent()
        if max_parent_splits >= 2:
            break  # two is enough
    for i in 0, 1:
        # keep = splitter.widget(index)
        # cull = splitter.widget(index - 1)
        if (max_parent_splits >= 2 or  # more splits upstream
            splitter.count() > 2 or  # 3+ splits here, or 2+ downstream
            neighbour[not i] and neighbour[not i].max_count() >= 2
        ):

            def remove_callback(i=i, index=index):
                splitter.remove(index, i)

            self.add_item(remove_callback, menu,
                f"Remove {count[i]:d} {lr[i]}",
                f"Remove the {count[i]} pane{pl(count[i])} {di(lr[i])} here")
    # Swap.

    def swap_callback(index=index):
        splitter.swap(index)

    self.add_item(swap_callback, menu,
        f"Swap {count[0]:d} {lr[0]} {count[1]:d} {lr[1]}",
        f"Swap the {count[0]:d} pane{pl(count[0])} {di(lr[0])} here "
        f"with the {count[1]:d} pane{pl(count[1])} {di(lr[1])} here"
        )
    # Split: only if not already split.
    for i in 0, 1:
        if not neighbour[i] or neighbour[i].count() == 1:

            def split_callback(i=i, index=index, splitter=splitter):
                splitter.split(index, i)

            self.add_item(
                split_callback, menu, f"Split {lr[i]} {split_dir}")
    for i in 0, 1:

        def mark_callback(i=i, index=index):
            splitter.mark(index, i)

        self.add_item(mark_callback, menu, f"Mark {count[i]:d} {lr[i]}")
    # Swap With Marked.
    if splitter.root.marked:
        for i in 0, 1:
            if not splitter.invalid_swap(widget[i], splitter.root.marked[2]):

                def swap_mark_callback(i=i, index=index, splitter=splitter):
                    splitter.swap_with_marked(index, i)

                self.add_item(swap_mark_callback, menu,
                    f"Swap {count[i]:d} {lr[i]} With Marked")
    # Add.
    for i in 0, 1:
        if (
            not isinstance(splitter.parent(), NestedSplitter) or
            splitter.parent().indexOf(splitter) ==
                [0, splitter.parent().count() - 1][i]
        ):

            def add_callback(i=i, splitter=splitter):
                splitter.add(i)

            self.add_item(add_callback, menu, f"Add {ab[i]}")
    # Rotate All.
    self.add_item(splitter.rotate, menu, 'Toggle split direction')

    def rotate_only_this(index=index):
        splitter.rotateOne(index)

    self.add_item(rotate_only_this, menu, 'Toggle split/dir. just this')
    # equalize panes

    def eq(splitter=splitter.top()):
        splitter.equalize_sizes(recurse=True)

    self.add_item(eq, menu, 'Equalize all')
    # (un)zoom pane

    def zoom(splitter=splitter.top()):
        splitter.zoom_toggle()

    self.add_item(
        zoom,
        menu,
        ('Un' if splitter.root.zoomed else '') + 'Zoom pane'
    )
    # open window
    if splitter.top().parent().__class__ != NestedSplitterTopLevel:
        # don't open windows from windows, only from main splitter
        # so owner is not a window which might close.  Could instead
        # set owner to main splitter explicitly.  Not sure how right now.
        submenu = menu.addMenu('Open window')
        if 1:
            # pylint: disable=unnecessary-lambda
            self.add_item(lambda: splitter.open_window(), submenu, "Empty")
        # adapted from choice_menu()
        if (splitter.root.marked and
            splitter.top().max_count() > 1
        ):
            self.add_item(
                lambda: splitter.open_window(action="_move_marked_there"),
                submenu, "Move marked there")
        for provider in splitter.root.providers:
            if hasattr(provider, 'ns_provides'):
                for title, id_ in provider.ns_provides():

                    def cb(id_=id_):
                        splitter.open_window(action=id_)

                    self.add_item(cb, submenu, title)
    submenu = menu.addMenu('Debug')
    act = QtWidgets.QAction("Print splitter layout", self)

    def cb(checked, splitter=splitter):  # pylint: disable=function-redefined
        print(f"\n{splitter.layout_to_text(splitter.top().get_layout())}\n")

    act.triggered.connect(cb)
    submenu.addAction(act)

    def load_items(menu, items):
        for i in items:
            if isinstance(i, dict):
                for k in i:
                    load_items(menu.addMenu(k), i[k])
            else:
                title, id_ = i

                def cb(checked, id_=id_):
                    splitter.context_cb(id_, index)

                act = QtWidgets.QAction(title, self)
                act.triggered.connect(cb)
                menu.addAction(act)

    for provider in splitter.root.providers:
        if hasattr(provider, 'ns_context'):
            load_items(menu, provider.ns_context())
    menu.exec_(self.mapToGlobal(pos))
    for i in 0, 1:
        widget[i].setStyleSheet(sheet[i])
#@+node:tbnorth.20160510091151.1: *7* nsh.mouseEvents
def mousePressEvent(self, event):
    """mouse event - mouse pressed on splitter handle,
    pass info. up to splitter

    :param QMouseEvent event: mouse event
    """
    self.splitter()._splitter_clicked(self, event, release=False, double=False)

def mouseReleaseEvent(self, event):
    """mouse event - mouse pressed on splitter handle,
    pass info. up to splitter

    :param QMouseEvent event: mouse event
    """
    self.splitter()._splitter_clicked(self, event, release=True, double=False)

def mouseDoubleClickEvent(self, event):
    """mouse event - mouse pressed on splitter handle,
    pass info. up to splitter

    :param QMouseEvent event: mouse event
    """
    self.splitter()._splitter_clicked(self, event, release=True, double=True)
#@+node:ekr.20110605121601.17966: *6* class NestedSplitter (QSplitter)
if QtWidgets:  # NOQA


    class NestedSplitter(QtWidgets.QSplitter):
        enabled = True
            # allow special behavior to be turned of at import stage
            # useful if other code must run to set up callbacks, that
            # other code can re-enable
        other_orientation = {
            QtCore.Qt.Vertical: QtCore.Qt.Horizontal,
            QtCore.Qt.Horizontal: QtCore.Qt.Vertical
            # QtConst.Vertical: QtConst.Horizontal,
            # QtConst.Horizontal: QtConst.Vertical
        }
        # a regular signal, but you can't use its .connect() directly,
        # use splitterClicked_connect()
        _splitterClickedSignal = QtCore.pyqtSignal(
            QtWidgets.QSplitter,
            QtWidgets.QSplitterHandle,
            QtGui.QMouseEvent,
            bool,
            bool
        )
        @others
#@+node:ekr.20110605121601.17967: *7* ns.__init__
def __init__(self, parent=None, orientation=QtCore.Qt.Horizontal, root=None):
    """Ctor for NestedSplitter class."""
    super().__init__(orientation, parent)
        # This creates a NestedSplitterHandle.
    if root is None:
        root = self.top(local=True)
        if root == self:
            root.marked = None  # Tuple: self,index,side-1,widget
            root.providers = []
            root.holders = {}
            root.windows = []
            root._main = self.parent()  # holder of the main splitter
            # list of top level NestedSplitter windows opened from 'Open Window'
            # splitter handle context menu
            root.zoomed = False
        #
        # NestedSplitter is a kind of meta-widget, in that it manages
        # panes across multiple actual splitters, even windows.
        # So to create a signal for a click on splitter handle, we
        # need to propagate the .connect() call across all the
        # actual splitters, current and future
        root._splitterClickedArgs = []  # save for future added splitters
    for args in root._splitterClickedArgs:
        # apply any .connect() calls that occured earlier
        self._splitterClickedSignal.connect(*args)

    self.root = root
#@+node:ekr.20110605121601.17968: *7* ns.__repr__
def __repr__(self):
    # parent = self.parent()
    # name = parent and parent.objectName() or '<no parent>'
    name = self.objectName() or '<no name>'
    return f"(NestedSplitter) {name} at {id(self)}"

__str__ = __repr__
#@+node:ekr.20110605121601.17969: *7* ns.overrides of QSplitter methods
#@+node:ekr.20110605121601.17970: *8* ns.createHandle
def createHandle(self, *args, **kargs):
    return NestedSplitterHandle(self)
#@+node:tbrown.20110729101912.30820: *8* ns.childEvent
def childEvent(self, event):
    """If a panel client is closed not by us, there may be zero
    splitter handles left, so add an Action button

    unless it was the last panel in a separate window, in which
    case close the window"""
    QtWidgets.QSplitter.childEvent(self, event)
    if not event.removed():
        return
    local_top = self.top(local=True)
    # if only non-placeholder pane in a top level window deletes
    # itself, delete the window
    if (isinstance(local_top.parent(), NestedSplitterTopLevel) and
        local_top.count() == 1 and  # one left, could be placeholder
        isinstance(local_top.widget(0), NestedSplitterChoice)  # is placeholder
       ):
        local_top.parent().deleteLater()
        return
    # don't leave a one widget splitter
    if self.count() == 1 and local_top != self:
        self.parent().addWidget(self.widget(0))
        self.deleteLater()
    parent = self.parentWidget()
    if parent:
        layout = parent.layout()  # QLayout, not a NestedSplitter
    else:
        layout = None
    if self.count() == 1 and self.top(local=True) == self:
        if self.max_count() <= 1 or not layout:
            # maintain at least two items
            self.insert(0)
            # shrink the added button
            self.setSizes([0] + self.sizes()[1:])
        else:
            # replace ourselves in out parent's layout with our child
            pos = layout.indexOf(self)
            child = self.widget(0)
            layout.insertWidget(pos, child)
            pos = layout.indexOf(self)
            layout.takeAt(pos)
            self.setParent(None)
#@+node:ekr.20110605121601.17971: *7* ns.add
def add(self, side, w=None):
    """wrap a horizontal splitter in a vertical splitter, or
    visa versa"""
    orientation = self.other_orientation[self.orientation()]
    layout = self.parent().layout()
    if isinstance(self.parent(), NestedSplitter):
        # don't add new splitter if not needed, i.e. we're the
        # only child of a previously more populated splitter
        if w is None:
            w = NestedSplitterChoice(self.parent())
        self.parent().insertWidget(self.parent().indexOf(self) + side, w)
        # in this case, where the parent is a one child, no handle splitter,
        # the (prior to this invisible) orientation may be wrong
        # can't reproduce this now, but this guard is harmless
        self.parent().setOrientation(orientation)
    elif layout:
        new = NestedSplitter(None, orientation=orientation, root=self.root)
        # parent set by layout.insertWidget() below
        old = self
        pos = layout.indexOf(old)
        new.addWidget(old)
        if w is None:
            w = NestedSplitterChoice(new)
        new.insertWidget(side, w)
        layout.insertWidget(pos, new)
    else:
        # fail - parent is not NestedSplitter and has no layout
        pass
#@+node:tbrown.20110621120042.22675: *7* ns.add_adjacent
def add_adjacent(self, what, widget_id, side='right-of'):
    """add a widget relative to another already present widget"""
    horizontal, vertical = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    layout = self.top().get_layout()

    def hunter(layout, id_):
        """Recursively look for this widget"""
        for n, i in enumerate(layout['content']):
            if (i == id_ or
                    (isinstance(i, QtWidgets.QWidget) and
                    (i.objectName() == id_ or i.__class__.__name__ == id_)
                )
            ):
                return layout, n
            if not isinstance(i, QtWidgets.QWidget):
                # then it must be a layout dict
                x = hunter(i, id_)
                if x:
                    return x
        return None

    # find the layout containing widget_id

    l = hunter(layout, widget_id)
    if l is None:
        return False
    # pylint: disable=unpacking-non-sequence
    layout, pos = l
    orient = layout['orientation']
    if (orient == horizontal and side in ('right-of', 'left-of') or
        orient == vertical and side in ('above', 'below')
    ):
        # easy case, just insert the new thing, what,
        # either side of old, in existng splitter
        if side in ('right-of', 'below'):
            pos += 1
        layout['splitter'].insert(pos, what)
    else:
        # hard case, need to replace old with a new splitter
        if side in ('right-of', 'left-of'):
            ns = NestedSplitter(orientation=horizontal, root=self.root)
        else:
            ns = NestedSplitter(orientation=vertical, root=self.root)
        old = layout['content'][pos]
        if not isinstance(old, QtWidgets.QWidget):  # see get_layout()
            old = layout['splitter']
        # put new thing, what, in new splitter, no impact on anything else
        ns.insert(0, what)
        # then swap the new splitter with the old content
        layout['splitter'].replace_widget_at_index(pos, ns)
        # now put the old content in the new splitter,
        # doing this sooner would mess up the index (pos)
        ns.insert(0 if side in ('right-of', 'below') else 1, old)
    return True
#@+node:ekr.20110605121601.17972: *7* ns.choice_menu
def choice_menu(self, button, pos):
    """build menu on Action button"""
    menu = QtWidgets.QMenu()
    index = self.indexOf(button)
    if (self.root.marked and
        not self.invalid_swap(button, self.root.marked[3]) and
        self.top().max_count() > 2
    ):
        act = QtWidgets.QAction("Move marked here", self)
        act.triggered.connect(
            lambda checked: self.replace_widget(button, self.root.marked[3]))
        menu.addAction(act)
    for provider in self.root.providers:
        if hasattr(provider, 'ns_provides'):
            for title, id_ in provider.ns_provides():

                def cb(checked, id_=id_):
                    self.place_provided(id_, index)

                act = QtWidgets.QAction(title, self)
                act.triggered.connect(cb)
                menu.addAction(act)
    if menu.isEmpty():
        act = QtWidgets.QAction("Nothing marked, and no options", self)
        menu.addAction(act)
    menu.exec_(button.mapToGlobal(pos))
#@+node:tbrown.20120418121002.25712: *7* ns.closing
def closing(self, window):
    """forget a top-level additional layout which was closed"""
    self.windows.remove(window)
#@+node:tbrown.20110628083641.11723: *7* ns.place_provided
def place_provided(self, id_, index):
    """replace Action button with provided widget"""
    provided = self.get_provided(id_)
    if provided is None:
        return
    self.replace_widget_at_index(index, provided)
    self.top().prune_empty()
    # user can set up one widget pane plus one Action pane, then move the
    # widget into the action pane, level 1 pane and no handles
    if self.top().max_count() < 2:
        print('Adding Action widget to maintain at least one handle')
        self.top().insert(0, NestedSplitterChoice(self.top()))
#@+node:tbrown.20110628083641.11729: *7* ns.context_cb
def context_cb(self, id_, index):
    """find a provider to provide a context menu service, and do it"""
    for provider in self.root.providers:
        if hasattr(provider, 'ns_do_context'):
            provided = provider.ns_do_context(id_, self, index)
            if provided:
                break
#@+node:ekr.20110605121601.17973: *7* ns.contains
def contains(self, widget):
    """check if widget is a descendent of self"""
    for i in range(self.count()):
        if widget == self.widget(i):
            return True
        if isinstance(self.widget(i), NestedSplitter):
            if self.widget(i).contains(widget):
                return True
    return False
#@+node:tbrown.20120418121002.25439: *7* ns.find_child
def find_child(self, child_class, child_name=None):
    """Like QObject.findChild, except search self.top()
    *AND* each window in self.root.windows
    """
    child = self.top().findChild(child_class, child_name)
    if not child:
        for window in self.root.windows:
            child = window.findChild(child_class, child_name)
            if child:
                break
    return child
#@+node:ekr.20110605121601.17974: *7* ns.handle_context
def handle_context(self, index):
    """for a handle, return (widget, neighbour, count)

    This is the handle's context in the NestedSplitter, not the
    handle's context menu.

    widget
      the pair of widgets either side of the handle
    neighbour
      the pair of NestedSplitters either side of the handle, or None
      if the neighbours are not NestedSplitters, i.e.
      [ns0, ns1] or [None, ns1] or [ns0, None] or [None, None]
    count
      the pair of nested counts of widgets / spliters around the handle
    """
    widget = [self.widget(index - 1), self.widget(index)]
    neighbour = [(i if isinstance(i, NestedSplitter) else None) for i in widget]
    count = []
    for i in 0, 1:
        if neighbour[i]:
            l = [ii.count() for ii in neighbour[i].self_and_descendants()]
            n = sum(l) - len(l) + 1  # count leaves, not splitters
            count.append(n)
        else:
            count.append(1)
    return widget, neighbour, count
#@+node:tbrown.20110621120042.22920: *7* ns.equalize_sizes
def equalize_sizes(self, recurse=False):
    """make all pane sizes equal"""
    if not self.count():
        return
    for i in range(self.count()):
        self.widget(i).setHidden(False)
    size = sum(self.sizes()) / self.count()
    self.setSizes([size] * self.count())
    if recurse:
        for i in range(self.count()):
            if isinstance(self.widget(i), NestedSplitter):
                self.widget(i).equalize_sizes(recurse=True)
#@+node:ekr.20110605121601.17975: *7* ns.insert (NestedSplitter)
def insert(self, index, w=None):
    """insert a pane with a widget or, when w==None, Action button"""
    if w is None:  # do NOT use 'not w', fails in PyQt 4.8
        w = NestedSplitterChoice(self)
        # A QWidget, with self as parent.
        # This creates the menu.
    self.insertWidget(index, w)
    self.equalize_sizes()
    return w
#@+node:ekr.20110605121601.17976: *7* ns.invalid_swap
def invalid_swap(self, w0, w1):
    """check for swap violating hierachy"""
    return (
        w0 == w1 or
        isinstance(w0, NestedSplitter) and w0.contains(w1) or
        isinstance(w1, NestedSplitter) and w1.contains(w0))
#@+node:ekr.20110605121601.17977: *7* ns.mark
def mark(self, index, side):
    """mark a widget for later swapping"""
    self.root.marked = (self, index, side - 1, self.widget(index + side - 1))
#@+node:ekr.20110605121601.17978: *7* ns.max_count
def max_count(self):
    """find max widgets in this and child splitters"""
    counts = []
    count = 0
    for i in range(self.count()):
        count += 1
        if isinstance(self.widget(i), NestedSplitter):
            counts.append(self.widget(i).max_count())
    counts.append(count)
    return max(counts)
#@+node:tbrown.20120418121002.25438: *7* ns.open_window
def open_window(self, action=None):
    """open a top-level window, a TopLevelFreeLayout instance, to hold a
    free-layout in addition to the one in the outline's main window"""
    ns = NestedSplitter(root=self.root)
    window = NestedSplitterTopLevel(
        owner=self.root, window_title=ns.get_title(action))
    hbox = QtWidgets.QHBoxLayout()
    window.setLayout(hbox)
    hbox.setContentsMargins(0, 0, 0, 0)
    window.resize(400, 300)
    hbox.addWidget(ns)
    # NestedSplitters must have two widgets so the handle carrying
    # the all important context menu exists
    ns.addWidget(NestedSplitterChoice(ns))
    button = NestedSplitterChoice(ns)
    ns.addWidget(button)
    if action == '_move_marked_there':
        ns.replace_widget(button, ns.root.marked[3])
    elif action is not None:
        ns.place_provided(action, 1)
    ns.setSizes([0, 1])  # but hide one initially
    self.root.windows.append(window)
    # copy the main main window's stylesheet to new window
    w = self.root  # this is a Qt Widget, class NestedSplitter
    sheets = []
    while w:
        s = w.styleSheet()
        if s:
            sheets.append(str(s))
        w = w.parent()
    sheets.reverse()
    sheets = '\n'.join(sheets)
    ns.setStyleSheet(sheets)
    window.show()
#@+node:tbrown.20110627201141.11744: *7* ns.register_provider
def register_provider(self, provider):
    """Register something which provides some of the ns_* methods.

    NestedSplitter tests for the presence of the following methods on
    the registered things, and calls them when needed if they exist.

    ns_provides()
      should return a list of ('Item name', '__item_id') strings,
      'Item name' is displayed in the Action button menu, and
      '__item_id' is used in ns_provide().
    ns_provide(id_)
      should return the widget to replace the Action button based on
      id_, or None if the called thing is not the provider for this id_
    ns_context()
      should return a list of ('Item name', '__item_id') strings,
      'Item name' is displayed in the splitter handle context-menu, and
      '__item_id' is used in ns_do_context().  May also return a dict,
      in which case each key is used as a sub-menu title, whose menu
      items are the corresponding dict value, a list of tuples as above.
      dicts and tuples may be interspersed in lists.
    ns_do_context()
      should do something based on id_ and return True, or return False
      if the called thing is not the provider for this id_
    ns_provider_id()
      return a string identifying the provider (at class or instance level),
      any providers with the same id will be removed before a new one is
      added
    """
    # drop any providers with the same id
    if hasattr(provider, 'ns_provider_id'):
        id_ = provider.ns_provider_id()
        cull = []
        for i in self.root.providers:
            if (hasattr(i, 'ns_provider_id') and
                i.ns_provider_id() == id_
            ):
                cull.append(i)
        for i in cull:
            self.root.providers.remove(i)
    self.root.providers.append(provider)
#@+node:ekr.20110605121601.17980: *7* ns.remove & helper
def remove(self, index, side):
    widget = self.widget(index + side - 1)
    # clear marked if it's going to be deleted
    if (self.root.marked and (self.root.marked[3] == widget or
        isinstance(self.root.marked[3], NestedSplitter) and
        self.root.marked[3].contains(widget))
    ):
        self.root.marked = None
    # send close signal to all children
    if isinstance(widget, NestedSplitter):
        count = widget.count()
        all_ok = True
        for splitter in widget.self_and_descendants():
            for i in range(splitter.count() - 1, -1, -1):
                all_ok &= (self.close_or_keep(splitter.widget(i)) is not False)
        if all_ok or count <= 0:
            widget.setParent(None)
    else:
        self.close_or_keep(widget)
#@+node:ekr.20110605121601.17981: *8* ns.close_or_keep
def close_or_keep(self, widget, other_top=None):
    """when called from a closing secondary window, self.top() would
    be the top splitter in the closing window, and we need the client
    to specify the top of the primary window for us, in other_top"""
    if widget is None:
        return True
    for k in self.root.holders:
        if hasattr(widget, k):
            holder = self.root.holders[k]
            if holder == 'TOP':
                holder = other_top or self.top()
            if hasattr(holder, "addTab"):
                holder.addTab(widget, getattr(widget, k))
            else:
                holder.addWidget(widget)
            return True
    if widget.close():
        widget.setParent(None)
        return True
    return False
#@+node:ekr.20110605121601.17982: *7* ns.replace_widget & replace_widget_at_index
def replace_widget(self, old, new):
    "Swap the provided widgets in place" ""
    sizes = self.sizes()
    new.setParent(None)
    self.insertWidget(self.indexOf(old), new)
    self.close_or_keep(old)
    new.show()
    self.setSizes(sizes)

def replace_widget_at_index(self, index, new):
    """Replace the widget at index with w."""
    sizes = self.sizes()
    old = self.widget(index)
    if old != new:
        new.setParent(None)
        self.insertWidget(index, new)
        self.close_or_keep(old)
        new.show()
        self.setSizes(sizes)
#@+node:ekr.20110605121601.17983: *7* ns.rotate
def rotate(self, descending=False):
    """Change orientation - current rotates entire hierachy, doing less
    is visually confusing because you end up with nested splitters with
    the same orientation - avoiding that would mean doing rotation by
    inserting out widgets into our ancestors, etc.
    """
    for i in self.top().self_and_descendants():
        if i.orientation() == QtCore.Qt.Vertical:
            i.setOrientation(QtCore.Qt.Horizontal)
        else:
            i.setOrientation(QtCore.Qt.Vertical)
#@+node:vitalije.20170713085342.1: *7* ns.rotateOne
def rotateOne(self, index):
    """Change orientation - only of splithandle at index."""
    psp = self.parent()
    if self.count() == 2 and isinstance(psp, NestedSplitter):
        i = psp.indexOf(self)
        sizes = psp.sizes()
        [a, b] = self.sizes()
        s = sizes[i]
        s1 = a * s / (a + b); s2 = b * s / (a + b)
        sizes[i : i + 1] = [s1, s2]
        prev = self.widget(0)
        next = self.widget(1)
        psp.insertWidget(i, prev)
        psp.insertWidget(i + 1, next)
        psp.setSizes(sizes)
        assert psp.widget(i + 2) is self
        psp.remove(i + 3, 0)
        psp.setSizes(sizes)
    elif self is self.root and self.count() == 2:
        self.rotate()
    elif self.count() == 2:
        self.setOrientation(self.other_orientation[self.orientation()])
    else:
        orientation = self.other_orientation[self.orientation()]
        prev = self.widget(index - 1)
        next = self.widget(index)
        if None in (prev, next): return
        sizes = self.sizes()
        s1, s2 = sizes[index - 1 : index + 1]
        sizes[index - 1 : index + 1] = [s1 + s2]
        newsp = NestedSplitter(self, orientation=orientation, root=self.root)
        newsp.addWidget(prev)
        newsp.addWidget(next)
        self.insertWidget(index - 1, newsp)
        prev.setHidden(False)
        next.setHidden(False)
        newsp.setSizes([s1, s2])
        self.setSizes(sizes)
#@+node:ekr.20110605121601.17984: *7* ns.self_and_descendants
def self_and_descendants(self):
    """Yield self and all **NestedSplitter** descendants"""
    for i in range(self.count()):
        if isinstance(self.widget(i), NestedSplitter):
            for w in self.widget(i).self_and_descendants():
                yield w
    yield self
#@+node:ekr.20110605121601.17985: *7* ns.split (NestedSplitter)
def split(self, index, side, w=None, name=None):
    """replace the adjacent widget with a NestedSplitter containing
    the widget and an Action button"""
    sizes = self.sizes()
    old = self.widget(index + side - 1)
    #X old_name = old and old.objectName() or '<no name>'
    #X splitter_name = self.objectName() or '<no name>'
    if w is None:
        w = NestedSplitterChoice(self)
    if isinstance(old, NestedSplitter):
        old.addWidget(w)
        old.equalize_sizes()
        #X index = old.indexOf(w)
        #X return old,index # For viewrendered plugin.
    else:
        orientation = self.other_orientation[self.orientation()]
        new = NestedSplitter(self, orientation=orientation, root=self.root)
        #X if name: new.setObjectName(name)
        self.insertWidget(index + side - 1, new)
        new.addWidget(old)
        new.addWidget(w)
        new.equalize_sizes()
        #X index = new.indexOf(w)
        #X return new,index # For viewrendered plugin.
    self.setSizes(sizes)
#@+node:ekr.20110605121601.17986: *7* ns.swap
def swap(self, index):
    """swap widgets either side of a handle"""
    self.insertWidget(index - 1, self.widget(index))
#@+node:ekr.20110605121601.17987: *7* ns.swap_with_marked
def swap_with_marked(self, index, side):
    # pylint: disable=unpacking-non-sequence
    osplitter, oidx, oside, ow = self.root.marked
    idx = index + side - 1
    # convert from handle index to widget index
    # 1 already subtracted from oside in mark()
    w = self.widget(idx)
    if self.invalid_swap(w, ow):
        return
    self.insertWidget(idx, ow)
    osplitter.insertWidget(oidx, w)
    self.root.marked = self, self.indexOf(ow), 0, ow
    self.equalize_sizes()
    osplitter.equalize_sizes()
#@+node:ekr.20110605121601.17988: *7* ns.top
def top(self, local=False):
    """find top (outer) widget, which is not necessarily root"""
    if local:
        top = self
        while isinstance(top.parent(), NestedSplitter):
            top = top.parent()
    else:
        top = self.root._main.findChild(NestedSplitter)
    return top
#@+node:ekr.20110605121601.17989: *7* ns.get_layout
def get_layout(self, _saveable=False):
    """return {'orientation':QOrientation, 'content':[], 'splitter':ns}

    Where content is a list of widgets, or if a widget is a NestedSplitter, the
    result of that splitters call to get_layout().  splitter is the splitter
    which generated the dict.

    Usually you would call ns.top().get_layout()

    With _saveable==True (via get_saveable_layour()) content entry for
    non-NestedSplitter items is the provider ID string for the item, or
    'UNKNOWN', and the splitter entry is omitted.
    """
    ans = {
        'orientation': self.orientation(),
        'content': []
    }
    if not _saveable:
        ans['splitter'] = self
    ans['sizes'] = self.sizes()
    for i in range(self.count()):
        w = self.widget(i)
        if isinstance(w, NestedSplitter):
            ans['content'].append(w.get_layout(_saveable=_saveable))
        else:
            if _saveable:
                ans['content'].append(getattr(w, '_ns_id', 'UNKNOWN'))
            else:
                ans['content'].append(w)
    return ans
#@+node:tbrown.20110628083641.11733: *7* ns.get_saveable_layout
def get_saveable_layout(self):
    return self.get_layout(_saveable=True)
#@+node:ekr.20160416083415.1: *7* ns.get_splitter_by_name
def get_splitter_by_name(self, name):
    """Return the splitter with the given objectName()."""
    if self.objectName() == name:
        return self
    for i in range(self.count()):
        w = self.widget(i)
        # Recursively test w and its descendants.
        if isinstance(w, NestedSplitter):
            w2 = w.get_splitter_by_name(name)
            if w2:
                return w2
    return None
#@+node:tbrown.20110628083641.21154: *7* ns.load_layout
def load_layout(self, layout, level=0):

    self.setOrientation(layout['orientation'])
    found = 0
    if level == 0:
        for i in self.self_and_descendants():
            for n in range(i.count()):
                i.widget(n)._in_layout = False
    for i in layout['content']:
        if isinstance(i, dict):
            new = NestedSplitter(root=self.root, parent=self)
            new._in_layout = True
            self.insert(found, new)
            found += 1
            new.load_layout(i, level + 1)
        else:
            provided = self.get_provided(i)
            if provided:
                self.insert(found, provided)
                provided._in_layout = True
                found += 1
            else:
                print(f"NO {i}")
    self.prune_empty()
    if self.count() != len(layout['sizes']):
        not_in_layout = set()
        for i in self.self_and_descendants():
            for n in range(i.count()):
                c = i.widget(n)
                if not (hasattr(c, '_in_layout') and c._in_layout):
                    not_in_layout.add(c)
        for i in not_in_layout:
            self.close_or_keep(i)
        self.prune_empty()
    if self.count() == len(layout['sizes']):
        self.setSizes(layout['sizes'])
    else:
        print(
            f"Wrong pane count at level {level:d}, "
            f"count:{self.count():d}, "
            f"sizes:{len(layout['sizes']):d}")
        self.equalize_sizes()
#@+node:tbrown.20110628083641.21156: *7* ns.prune_empty
def prune_empty(self):
    for i in range(self.count() - 1, -1, -1):
        w = self.widget(i)
        if isinstance(w, NestedSplitter):
            if w.max_count() == 0:
                w.setParent(None)
                # w.deleteLater()
#@+node:tbrown.20110628083641.21155: *7* ns.get_provided
def find_by_id(self, id_):
    for s in self.self_and_descendants():
        for i in range(s.count()):
            if getattr(s.widget(i), '_ns_id', None) == id_:
                return s.widget(i)
    return None

def get_provided(self, id_):
    """IMPORTANT: nested_splitter should set the _ns_id attribute *only*
    if the provider doesn't do it itself.  That allows the provider to
    encode state information in the id.

    Also IMPORTANT: nested_splitter should call all providers for each id_, not
    just providers which previously advertised the id_.  E.g. a provider which
    advertises leo_bookmarks_show may also be the correct provider for
    leo_bookmarks_show:4532.234 - let the providers decide in ns_provide().
    """
    for provider in self.root.providers:
        if hasattr(provider, 'ns_provide'):
            provided = provider.ns_provide(id_)
            if provided:
                if provided == 'USE_EXISTING':
                    # provider claiming responsibility, and saying
                    # we already have it, i.e. it's a singleton
                    w = self.top().find_by_id(id_)
                    if w:
                        if not hasattr(w, '_ns_id'):
                            # IMPORTANT: see docstring
                            w._ns_id = id_
                        return w
                else:
                    if not hasattr(provided, '_ns_id'):
                        # IMPORTANT: see docstring
                        provided._ns_id = id_
                    return provided
    return None

def get_title(self, id_):
    """Like get_provided(), but just gets a title for a window
    """
    if id_ is None:
        return "Leo widget window"
    for provider in self.root.providers:
        if hasattr(provider, 'ns_title'):
            provided = provider.ns_title(id_)
            if provided:
                return provided
    return "Leo unnamed window"
#@+node:ekr.20110605121601.17990: *7* ns.layout_to_text
def layout_to_text(self, layout, _depth=0, _ans=None):
    """convert the output from get_layout to indented human readable text
    for development/debugging"""
    if _ans is None: _ans = []
    if _depth == 0:
        _ans = []
    orientation = 'vertical'
    if layout['orientation'] == QtCore.Qt.Horizontal:
        orientation = 'horizontal'
    _ans.append(
        f"{'   ' * _depth}{layout['splitter'].__class__.__name__} "
        f"({layout['splitter'].objectName()}) - {orientation}",
    )
    _depth += 1
    for n, i in enumerate(layout['content']):
        if isinstance(i, dict):
            self.layout_to_text(i, _depth, _ans)
        else:
            _ans.append(
                f"{'   ' * _depth}{i.__class__.__name__} "
                f"({str(i.objectName())}) from {getattr(i, '_ns_id', 'UNKNOWN')}",
            )
    if _depth == 1:
        return '\n'.join(_ans)
    return None
#@+node:tbrown.20140522153032.32656: *7* ns.zoom_toggle
def zoom_toggle(self, local=False):
    """zoom_toggle - (Un)zoom current pane to be only expanded pane

    :param bool local: just zoom pane within its own splitter
    """
    if self.root.zoomed:
        for ns in self.top().self_and_descendants():
            if hasattr(ns, '_unzoom'):
                # this splitter could have been added since
                ns.setSizes(ns._unzoom)
    else:
        focused = Qt.QApplication.focusWidget()
        parents = []
        parent = focused
        while parent:
            parents.append(parent)
            parent = parent.parent()
        if not focused:
            g.es("Not zoomed, and no focus")
        for ns in (self if local else self.top()).self_and_descendants():
            # FIXME - shouldn't be doing this across windows
            ns._unzoom = ns.sizes()
            for i in range(ns.count()):
                w = ns.widget(i)
                if w in parents:
                    sizes = [0] * len(ns._unzoom)
                    sizes[i] = sum(ns._unzoom)
                    ns.setSizes(sizes)
                    break
    self.root.zoomed = not self.root.zoomed
#@+node:tbnorth.20160510092439.1: *7* ns._splitter_clicked
def _splitter_clicked(self, handle, event, release, double):
    """_splitter_clicked - coordinate propagation of signals
    for clicks on handles.  Turned out not to need any particular
    coordination, handles could call self._splitterClickedSignal.emit
    directly, but design wise this is a useful control point.

    :param QSplitterHandle handle: handle that was clicked
    :param QMouseEvent event: click event
    :param bool release: was it a release event
    :param bool double: was it a double click event
    """
    self._splitterClickedSignal.emit(self, handle, event, release, double)
#@+node:tbnorth.20160510123445.1: *7* splitterClicked_connect
def splitterClicked_connect(self, *args):
    """Apply .connect() args to all actual splitters,
    and store for application to future splitters.
    """
    self.root._splitterClickedArgs.append(args)
    for splitter in self.top().self_and_descendants():
        splitter._splitterClickedSignal.connect(*args)
#@+node:ekr.20110605121601.17991: *6* main
def main():
    """The main top-level function executed when this file is executed stand-alone."""
    app = Qt.QApplication(sys.argv)
    wdg = DemoWidget()
    wdg2 = DemoWidget()
    splitter = NestedSplitter()
    splitter.addWidget(wdg)
    splitter.addWidget(wdg2)


    class DemoProvider:

        def ns_provides(self):
            return [('Add demo widget', '_add_demo_widget')]

        def ns_provide(self, id_):
            if id_ == '_add_demo_widget':
                return DemoWidget()
            return None

    splitter.register_provider(DemoProvider())
    holder = QtWidgets.QWidget()
    holder.setLayout(QtWidgets.QVBoxLayout())
    holder.layout().setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    holder.layout().addWidget(splitter)
    holder.show()
    app.exec_()
#@+node:ekr.20110605121601.17996: *5* @file ../plugins/qt_commands.py
"""Leo's Qt-related commands defined by @g.command."""
import leo.core.leoGlobals as g
import leo.core.leoColor as leoColor
import leo.core.leoConfig as leoConfig
from leo.core.leoQt import QtGui, QtWidgets
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20110605121601.18000: *6* init
def init():
    """Top-level init function for qt_commands.py."""
    ok = True
    g.plugin_signon(__name__)
    g.registerHandler("select2", onSelect)
    return ok

def onSelect(tag, keywords):
    c = keywords.get('c') or keywords.get('new_c')
    wdg = c.frame.top.leo_body_frame
    wdg.setWindowTitle(c.p.h)
#@+node:ekr.20110605121601.18001: *6* qt: detach-editor-toggle & helpers
@g.command('detach-editor-toggle')
def detach_editor_toggle(event):
    """ Detach or undetach body editor """
    c = event['c']
    detach = True
    try:
        if c.frame.detached_body_info is not None:
            detach = False
    except AttributeError:
        pass
    if detach:
        detach_editor(c)
    else:
        undetach_editor(c)

@g.command('detach-editor-toggle-max')
def detach_editor_toggle_max(event):
    """ Detach editor, maximize """
    c = event['c']
    detach_editor_toggle(event)
    if c.frame.detached_body_info is not None:
        wdg = c.frame.top.leo_body_frame
        wdg.showMaximized()
#@+node:ekr.20170324145714.1: *7* qt: detach_editor
def detach_editor(c):
    wdg = c.frame.top.leo_body_frame
    parent = wdg.parent()
    if parent is None:
        # just show if already detached
        wdg.show()
    else:
        c.frame.detached_body_info = parent, parent.sizes()
        wdg.setParent(None)
        sheet = c.config.getData('qt-gui-plugin-style-sheet')
        if sheet:
            sheet = '\n'.join(sheet)
            wdg.setStyleSheet(sheet)
        wdg.show()
#@+node:ekr.20170324145716.1: *7* qt: undetach_editor
def undetach_editor(c):
    wdg = c.frame.top.leo_body_frame
    parent, sizes = c.frame.detached_body_info
    parent.insertWidget(0, wdg)
    wdg.show()
    parent.setSizes(sizes)
    c.frame.detached_body_info = None
#@+node:ekr.20170324143944.2: *6* qt: show-color-names
@g.command('show-color-names')
def showColorNames(event=None):
    """Put up a dialog showing color names."""
    c = event.get('c')
    template = '''
        QComboBox {
            background-color: %s;
            selection-background-color: %s;
            selection-color: black;
        }'''
    ivar = 'leo_settings_color_picker'
    if getattr(c, ivar, None):
        g.es('The color picker already exists in the icon bar.')
    else:
        color_list = []
        box = QtWidgets.QComboBox()

        def onActivated(n, *args, **keys):
            color = color_list[n]
            sheet = template % (color, color)
            box.setStyleSheet(sheet)
            g.es("copied to clipboard:", color)
            QtWidgets.QApplication.clipboard().setText(color)

        box.activated.connect(onActivated)
        color_db = leoColor.leo_color_database
        for key in sorted(color_db):
            if not key.startswith('grey'):  # Use gray, not grey.
                val = color_db.get(key)
                color = QtGui.QColor(val)
                color_list.append(val)
                pixmap = QtGui.QPixmap(40, 40)
                pixmap.fill(color)
                icon = QtGui.QIcon(pixmap)
                box.addItem(icon, key)

        c.frame.iconBar.addWidget(box)
        setattr(c, ivar, True)
        g.es('created color picker in icon area')
            # Do this last, so errors don't prevent re-execution.
#@+node:ekr.20170324142416.1: *6* qt: show-color-wheel
@g.command('show-color-wheel')
def showColorWheel(self, event=None):
    """Show a Qt color dialog."""
    c = self.c; p = c.p
    picker = QtWidgets.QColorDialog()
    in_color_setting = p.h.startswith('@color ')
    try:
        text = QtWidgets.QApplication.clipboard().text()
        if in_color_setting:
            text = p.h.split('=', 1)[1].strip()
        color = QtGui.QColor(text)
        picker.setCurrentColor(color)
    except(ValueError, IndexError) as e:
        g.trace('error caught', e)
    if not picker.exec_():
        g.es("No color selected")
    elif in_color_setting:
        udata = c.undoer.beforeChangeNodeContents(p)
        p.h = f"{p.h.split('=', 1)[0].strip()} = {picker.selectedColor().name()}"
        c.undoer.afterChangeNodeContents(p, 'change-color', udata)
    else:
        text = picker.selectedColor().name()
        g.es("copied to clipboard:", text)
        QtWidgets.QApplication.clipboard().setText(text)
#@+node:ekr.20170324143944.3: *6* qt: show-fonts
@g.command('show-fonts')
def showFonts(self, event=None):
    """Open a tab in the log pane showing a font picker."""
    c = self.c; p = c.p

    picker = QtWidgets.QFontDialog()
    if p.h.startswith('@font'):
        (name, family, weight, slant, size) = leoConfig.parseFont(p.b)
    else:
        name, family, weight, slant, size = None, None, False, False, 12
    try:
        font = QtGui.QFont()
        if family: font.setFamily(family)
        font.setBold(weight)
        font.setItalic(slant)
        font.setPointSize(size)
        picker.setCurrentFont(font)
    except ValueError:
        pass
    if not picker.exec_():
        g.es("No font selected")
    else:
        font = picker.selectedFont()
        udata = c.undoer.beforeChangeNodeContents(p)
        comments = [x for x in g.splitLines(p.b) if x.strip().startswith('#')]
        defs = [
            '\n' if comments else '',
            f"{name}_family = {font.family()}\n",
            f"{name}_weight = {'bold' if font.bold() else 'normal'}\n",
            f"{name}_slant = {'italic' if font.italic() else 'roman'}\n",
            f"{name}_size = {font.pointSizeF()}\n"
        ]
        p.b = ''.join(comments + defs)
        c.undoer.afterChangeNodeContents(p, 'change-font', udata)
#@+node:ekr.20140918124632.17893: *6* qt: show-style-sheet
@g.command('show-style-sheet')
def print_style_sheet(event):
    """show-style-sheet command."""
    c = event.get('c')
    if c:
        c.styleSheetManager.print_style_sheet()
#@+node:ekr.20140918124632.17891: *6* qt: style-reload
@g.command('style-reload')
@g.command('reload-style-sheets')
def style_reload(event):
    """reload-styles command.

    Find the appropriate style sheet and re-apply it.

    This replaces execution of the `stylesheet & source` node in settings files.
    """
    c = event.get('c')
    if c and c.styleSheetManager:
        c.reloadSettings()
            # Call ssm.reload_settings after reloading all settings.
#@+node:ekr.20140918124632.17892: *6* qt: style-set-selected
@g.command('style-set-selected')
def style_set_selected(event):
    """style-set-selected command. Set the global stylesheet to c.p.b. (For testing)"""
    c = event.get('c')
    if c:
        c.styleSheetManager.set_selected_style_sheet()
#@+node:ekr.20140907103315.18766: *5* @file ../plugins/qt_events.py
@first # -*- coding: utf-8 -*-
"""Leo's Qt event handling code."""
<< about internal bindings >>
import leo.core.leoGlobals as g
import leo.core.leoGui as leoGui
from leo.core.leoQt import QtCore, QtGui, QtWidgets
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20110605121601.18538: *6* << about internal bindings >>
@language rest
@
Here are the rules for translating key bindings (in leoSettings.leo) into keys
for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
#@+node:ekr.20141028061518.17: *6* class LeoQtEventFilter
class LeoQtEventFilter(QtCore.QObject):
    @others
#@+node:ekr.20110605121601.18539: *7* filter.ctor
def __init__(self, c, w, tag=''):
    """Ctor for LeoQtEventFilter class."""
    super().__init__()
    self.c = c
    self.w = w  # A leoQtX object, *not* a Qt object.
    self.tag = tag
    # Debugging.
    self.keyIsActive = False
    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close-flash-brackets') or ''
    open_flashers = c.config.getString('open-flash-brackets') or ''
    self.flashers = open_flashers + close_flashers
    # #1563: Support German keyboards.
    self.use_german_keyboard = c.config.getBool('use-german-keyboard', default=False)
    # Support for ctagscompleter.py plugin.
    self.ctagscompleter_active = False
    self.ctagscompleter_onKey = None
#@+node:ekr.20110605121601.18540: *7* filter.eventFilter & helpers
def eventFilter(self, obj, event):
    c, k = self.c, self.c.k
    #
    # Handle non-key events first.
    if not self.c.p:
        return False  # Startup. Let Qt handle the key event
    if 'keys' in g.app.debug and isinstance(event, QtGui.QKeyEvent):
        self.traceKeys(obj, event)
    elif 'events' in g.app.debug:
        self.traceEvent(obj, event)
        self.traceWidget(event)
    if self.doNonKeyEvent(event, obj):
        return False  # Let Qt handle the non-key event.
    #
    # Ignore incomplete key events.
    if self.shouldIgnoreKeyEvent(event, obj):
        return False  # Let Qt handle the key event.
    #
    # Generate a g.KeyStroke for k.masterKeyHandler.
    try:
        binding, ch = self.toBinding(event)
        if not binding:
            return False  # Not the correct event type.
        #
        # Pass the KeyStroke to masterKeyHandler.
        key_event = self.createKeyEvent(event, c, self.w, ch, binding)
        k.masterKeyHandler(key_event)
        c.outerUpdate()
    except Exception:
        g.es_exception()
    return True
        # Whatever happens, suppress all other Qt key handling.
#@+node:ekr.20110605195119.16937: *8* filter.createKeyEvent
def createKeyEvent(self, event, c, w, ch, binding):

    return leoGui.LeoKeyEvent(
        c=self.c,
        char=ch,
            # char = None doesn't work at present.
            # But really, the binding should suffice.
        event=event,
        binding=binding,
        w=w,
        x=getattr(event, 'x', None) or 0,
        y=getattr(event, 'y', None) or 0,
        x_root=getattr(event, 'x_root', None) or 0,
        y_root=getattr(event, 'y_root', None) or 0,
    )
#@+node:ekr.20180413180751.2: *8* filter.doNonKeyEvent
def doNonKeyEvent(self, event, obj):
    """Handle all non-key event. """
    c = self.c
    ev = QtCore.QEvent
    eventType = event.type()
    if eventType == ev.WindowActivate:
        g.app.gui.onActivateEvent(event, c, obj, self.tag)
    elif eventType == ev.WindowDeactivate:
        g.app.gui.onDeactivateEvent(event, c, obj, self.tag)
    elif eventType == ev.FocusIn:
        if self.tag == 'body':
            c.frame.body.onFocusIn(obj)
        if c.frame and c.frame.top and obj is c.frame.top.lineEdit:
            if c.k.getStateKind() == 'getArg':
                c.frame.top.lineEdit.restore_selection()
    elif eventType == ev.FocusOut and self.tag == 'body':
        c.frame.body.onFocusOut(obj)
    return eventType not in (ev.ShortcutOverride, ev.KeyPress, ev.KeyRelease)
        # Return True unless we have a key event.
#@+node:ekr.20180413180751.3: *8* filter.shouldIgnoreKeyEvent
def shouldIgnoreKeyEvent(self, event, obj):
    """
    Return True if we should ignore the key event.
    
    Alas, QLineEdit *only* generates ev.KeyRelease on Windows, Ubuntu,
    so the following hack is required.
    """
    c = self.c
    ev = QtCore.QEvent
    t = event.type()
    isEditWidget = (obj == c.frame.tree.edit_widget(c.p))
    if isEditWidget:
        return t != ev.KeyRelease
            # QLineEdit: ignore all key events except keyRelease events.
    if t == ev.KeyPress:
        return False  # Never ignore KeyPress events.
    # This doesn't work. Two shortcut-override events are generated!
        # if t == ev.ShortcutOverride and event.text():
            # return False # Don't ignore shortcut overrides with a real value.
    return True  # Ignore everything else.
#@+node:ekr.20110605121601.18543: *8* filter.toBinding & helpers
def toBinding(self, event):
    """
    Return (binding, actual_ch):

    binding:    A user binding, to create g.KeyStroke.
                Spelling no longer fragile.
    actual_ch:  The insertable key, or ''.
    """
    mods = self.qtMods(event)
    keynum, text, toString, ch = self.qtKey(event)
    actual_ch = text or toString
    #
    # Never allow empty chars, or chars in g.app.gui.ignoreChars
    if toString in g.app.gui.ignoreChars:
        return None, None
    ch = ch or toString or ''
    if not ch:
        return None, None
    #
    # Check for AltGr and Alt+Ctrl keys *before* creating a binding.
    actual_ch, ch, mods = self.doMacTweaks(actual_ch, ch, mods)
    mods = self.doAltTweaks(actual_ch, keynum, mods, toString)
    #
    # Use *ch* in the binding.
    # Clearer w/o f-strings.
    binding = '%s%s' % (''.join([f"{z}+" for z in mods]), ch)
    #
    # Return the tweaked *actual* char.
    binding, actual_ch = self.doLateTweaks(binding, actual_ch)
    return binding, actual_ch
#@+node:ekr.20180419154543.1: *9* filter.doAltTweaks
def doAltTweaks(self, actual_ch, keynum, mods, toString):
    """Turn AltGr and some Alt-Ctrl keys into plain keys."""
    qt = QtCore.Qt

    def removeAltCtrl(mods):
        for mod in ('Alt', 'Control'):
            if mod in mods:
                mods.remove(mod)
        return mods

    #
    # Remove Alt, Ctrl for AltGr keys.
    # See https://en.wikipedia.org/wiki/AltGr_key

    if keynum == qt.Key_AltGr:
        return removeAltCtrl(mods)
    #
    # Never alter complex characters.
    if len(actual_ch) != 1:
        return mods
    #
    # #1563: A hack for German keyboards:
    #        Remove *plain* Shift modifier for colon and semicolon.
    #        https://en.m.wikipedia.org/wiki/German_keyboard_layout
    if (
        self.use_german_keyboard
        and actual_ch in ":;" and 'Shift' in mods
        and 'Alt' not in mods and 'Control' not in mods
    ):
        mods.remove('Shift')
        # g.trace('mods', mods, 'ch', repr(actual_ch))
    #
    # Handle Alt-Ctrl modifiers for chars whose that are not ascii.
    # Testing: Alt-Ctrl-E is '€'.
    if ord(actual_ch) > 127 and 'Alt' in mods and 'Control' in mods:
        return removeAltCtrl(mods)
    return mods
#@+node:ekr.20180417161548.1: *9* filter.doLateTweaks
def doLateTweaks(self, binding, ch):
    """Make final tweaks. g.KeyStroke does other tweaks later."""
    #
    # These are needed  because ch is separate from binding.
    if ch == '\r':
        ch = '\n'
    if binding == 'Escape':
        ch = 'Escape'
    #
    # Adjust the case of the binding string (for the minibuffer).
    if len(ch) == 1 and len(binding) == 1 and ch.isalpha() and binding.isalpha():
        if ch != binding:
            binding = ch
    return binding, ch
#@+node:ekr.20180419160958.1: *9* filter.doMacTweaks
def doMacTweaks(self, actual_ch, ch, mods):
    """Replace MacOS Alt characters."""
    if not g.isMac:
        return actual_ch, ch, mods
    if ch == 'Backspace':
        # On the Mac, the reported char can be DEL (7F)
        return '\b', ch, mods
    if len(mods) == 1 and mods[0] == 'Alt':
        # Patch provided by resi147.
        # See the thread: special characters in MacOSX, like '@'.
        mac_d = {
            '/': '\\',
            '5': '[',
            '6': ']',
            '7': '|',
            '8': '{',
            '9': '}',
            'e': '€',
            'l': '@',
        }
        if ch.lower() in mac_d:
            # Ignore the case.
            actual_ch = ch = g.checkUnicode(mac_d.get(ch.lower()))
            mods = []
    return actual_ch, ch, mods
#@+node:ekr.20110605121601.18544: *9* filter.qtKey
def qtKey(self, event):
    """
    Return the components of a Qt key event.

    Modifiers are handled separately.

    Return (keynum, text, toString, ch).

    keynum: event.key()
    ch:     chr(keynum) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    """
    keynum = event.key()
    text = event.text()  # This is the unicode character!
    qt = QtCore.Qt
    d = {
        qt.Key_Alt: 'Key_Alt',
        qt.Key_AltGr: 'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta: 'Key_Meta',
            # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Shift: 'Key_Shift',
        qt.Key_NumLock: 'Num_Lock',
            # 868.
        qt.Key_Super_L: 'Key_Super_L',
        qt.Key_Super_R: 'Key_Super_R',
        qt.Key_Hyper_L: 'Key_Hyper_L',
        qt.Key_Hyper_R: 'Key_Hyper_R',
    }
    if d.get(keynum):
        if 0:  # Allow bare modifier key.
            toString = d.get(keynum)
        else:
            toString = ''
    else:
        toString = QtGui.QKeySequence(keynum).toString()
    # Fix bug 1244461: Numpad 'Enter' key does not work in minibuffer
    if toString == 'Enter':
        toString = 'Return'
    if toString == 'Esc':
        toString = 'Escape'
    try:
        ch = chr(keynum)
    except ValueError:
        ch = ''
    # g.trace(keynum, ch)
    return keynum, text, toString, ch
#@+node:ekr.20120204061120.10084: *9* filter.qtMods
def qtMods(self, event):
    """Return the text version of the modifiers of the key event."""
    qt = QtCore.Qt
    modifiers = event.modifiers()
    mod_table = (
        (qt.AltModifier, 'Alt'),
        (qt.ControlModifier, 'Control'),
        (qt.MetaModifier, 'Meta'),
        (qt.ShiftModifier, 'Shift'),
        (qt.KeypadModifier, 'KeyPad'),
            # #1448: Replacing this by 'Key' would make separate keypad bindings impossible.
    )
    mods = [b for a, b in mod_table if (modifiers & a)]
    #
    # MacOS: optionally convert Meta (Ctrl key) to Alt.
    # 945: remove @bool swap-mac-keys and @bool replace-meta-with-alt.
    # if g.isMac:
        # c = self.c
        # if c.k.replace_meta_with_alt:
            # if 'Meta' in mods:
                # mods.remove('Meta')
                # mods.append('Alt')
        # if c.k.swap_mac_keys:
            # # Swap the Command (clover) and Control keys.
            # # That is, swap the meaning of the Control and Meta modifiers.
            # if 'Meta' in mods and 'Control' not in mods:
                # mods.remove('Meta')
                # mods.append('Control')
            # elif 'Control' in mods and 'Meta' not in mods:
                # mods.remove('Control')
                # mods.append('Meta')
    return mods
#@+node:ekr.20140907103315.18767: *7* filter.Tracing
#@+node:ekr.20190922075339.1: *8* filter.traceKeys
def traceKeys(self, obj, event):
    if g.unitTesting:
        return
    e = QtCore.QEvent
    key_events = {
        e.KeyPress: 'key-press',  # 6
        e.KeyRelease: 'key-release',  # 7
        e.Shortcut: 'shortcut',  # 117
        e.ShortcutOverride: 'shortcut-override',  # 51
    }
    kind = key_events.get(event.type())
    if kind:
        mods = ','.join(self.qtMods(event))
        g.trace(f"{kind:>20}: {mods:>7} {event.text()!r}")
#@+node:ekr.20110605121601.18548: *8* filter.traceEvent
def traceEvent(self, obj, event):
    if g.unitTesting: return
    # http://qt-project.org/doc/qt-4.8/qevent.html#properties
    exclude_names = ('tree', 'log', 'body', 'minibuffer')
    traceActivate = True
    traceFocus = False
    traceHide = False
    traceHover = False
    traceKey = False
    traceLayout = False
    traceMouse = False
    tracePaint = False
    traceUpdate = False
    c, e = self.c, QtCore.QEvent
    eventType = event.type()
    # http://doc.qt.io/qt-5/qevent.html
    show = []
    ignore = [
        e.MetaCall,  # 43
        e.Timer,  # 1
        e.ToolTip,  # 110
    ]
    activate_events = (
        (e.Close, 'close'),  # 19
        (e.WindowActivate, 'window-activate'),  # 24
        (e.WindowBlocked, 'window-blocked'),  # 103
        (e.WindowUnblocked, 'window-unblocked'),  # 104
        (e.WindowDeactivate, 'window-deactivate'),  # 25
    )
    focus_events = [
        (e.Enter, 'enter'),  # 10
        (e.Leave, 'leave'),  # 11
        (e.FocusIn, 'focus-in'),  # 8
        (e.FocusOut, 'focus-out'),  # 9
        (e.ShowToParent, 'show-to-parent'),  # 26
    ]
    if hasattr(e, 'FocusAboutToChange'):
        # pylint: disable=no-member
        focus_events.extend([
            (e.FocusAboutToChange, 'focus-about-to-change'),  # 23
        ])
    hide_events = (
        (e.Hide, 'hide'),  # 18
        (e.HideToParent, 'hide-to-parent'),  # 27
        # (e.LeaveEditFocus,'leave-edit-focus'), # 151
        (e.Show, 'show'),  # 17
    )
    hover_events = (
        (e.HoverEnter, 'hover-enter'),  # 127
        (e.HoverLeave, 'hover-leave'),  # 128
        (e.HoverMove, 'hover-move'),  # 129
    )
    key_events = [
        (e.KeyPress, 'key-press'),  # 6
        (e.KeyRelease, 'key-release'),  # 7
        (e.Shortcut, 'shortcut'),  # 117
        (e.ShortcutOverride, 'shortcut-override'),  # 51
    ]
    if hasattr(e, 'InputMethodQuery'):
        # pylint: disable=no-member
        key_events.extend([
            (e.InputMethodQuery, 'input-method-query'),  # 207
        ])
    layout_events = [
        (e.ChildAdded, 'child-added'),  # 68
        (e.ChildRemoved, 'child-removed'),  # 71
        (e.DynamicPropertyChange, 'dynamic-property-change'),  # 170
        (e.FontChange, 'font-change'),  # 97
        (e.LayoutRequest, 'layout-request'),  # 76
        (e.Move, 'move'),  # 13 widget's position changed.
        (e.Resize, 'resize'),  # 14
        (e.StyleChange, 'style-change'),  # 100
        (e.ZOrderChange, 'z-order-change'),  # 126
    ]
    if hasattr(e, 'CloseSoftwareInputPanel'):
        layout_events.extend([
            (e.CloseSoftwareInputPanel, 'close-sip'),  # 200
        ])
    mouse_events = (
        (e.MouseMove, 'mouse-move'),  # 155
        (e.MouseButtonPress, 'mouse-press'),  # 2
        (e.MouseButtonRelease, 'mouse-release'),  # 3
        (e.Wheel, 'mouse-wheel'),  # 31
    )
    paint_events = [
        (e.ChildPolished, 'child-polished'),  # 69
        (e.PaletteChange, 'palette-change'),  # 39
        (e.ParentChange, 'parent-change'),  # 21
        (e.Paint, 'paint'),  # 12
        (e.Polish, 'polish'),  # 75
        (e.PolishRequest, 'polish-request'),  # 74
    ]
    if hasattr(e, 'RequestSoftwareInputPanel'):
        paint_events.extend([
            (e.RequestSoftwareInputPanel, 'sip'),  # 199
        ])
    update_events = (
        (e.UpdateLater, 'update-later'),  # 78
        (e.UpdateRequest, 'update'),  #	77
    )
    option_table = (
        (traceActivate, activate_events),
        (traceFocus, focus_events),
        (traceHide, hide_events),
        (traceHover, hover_events),
        (traceKey, key_events),
        (traceLayout, layout_events),
        (traceMouse, mouse_events),
        (tracePaint, paint_events),
        (traceUpdate, update_events),
    )
    for option, table in option_table:
        if option:
            show.extend(table)
        else:
            for n, tag in table:
                ignore.append(n)
    for val, kind in show:
        if self.tag in exclude_names:
            return
        if eventType == val:
            tag = (
                obj.objectName() if hasattr(obj, 'objectName')
                else f"id: {id(obj)}, {obj.__class__.__name__}"
            )
            if traceKey: g.trace(
                f"{kind:-25} {self.tag:-25} in-state: {repr(c.k and c.k.inState()):5} obj: {tag}")
            return
    if eventType not in ignore:
        tag = (
            obj.objectName() if hasattr(obj, 'objectName')
            else f"id: {id(obj)}, {obj.__class__.__name__}"
        )
        g.trace(f"{eventType:-25} {self.tag:-25} {tag}")
#@+node:ekr.20131121050226.16331: *8* filter.traceWidget
def traceWidget(self, event):
    """Show unexpected events in unusual widgets."""
    verbose = False
        # Not good for --trace-events
    e = QtCore.QEvent
    assert isinstance(event, QtCore.QEvent)
    et = event.type()
    # http://qt-project.org/doc/qt-4.8/qevent.html#properties
    ignore_d = {
        e.ChildAdded: 'child-added',  # 68
        e.ChildPolished: 'child-polished',  # 69
        e.ChildRemoved: 'child-removed',  # 71
        e.Close: 'close',  # 19
        e.CloseSoftwareInputPanel: 'close-software-input-panel',  # 200
        178: 'contents-rect-change',  # 178
        # e.DeferredDelete:'deferred-delete', # 52 (let's trace this)
        e.DynamicPropertyChange: 'dynamic-property-change',  # 170
        e.FocusOut: 'focus-out',  # 9 (We don't care if we are leaving an unknown widget)
        e.FontChange: 'font-change',  # 97
        e.Hide: 'hide',  # 18
        e.HideToParent: 'hide-to-parent',  # 27
        e.HoverEnter: 'hover-enter',  # 127
        e.HoverLeave: 'hover-leave',  # 128
        e.HoverMove: 'hover-move',  # 129
        e.KeyPress: 'key-press',  # 6
        e.KeyRelease: 'key-release',  # 7
        e.LayoutRequest: 'layout-request',  # 76
        e.Leave: 'leave',  # 11 (We don't care if we are leaving an unknown widget)
        # e.LeaveEditFocus:'leave-edit-focus', # 151
        e.MetaCall: 'meta-call',  # 43
        e.Move: 'move',  # 13 widget's position changed.
        e.MouseButtonPress: 'mouse-button-press',  # 2
        e.MouseButtonRelease: 'mouse-button-release',  # 3
        e.MouseButtonDblClick: 'mouse-button-double-click',  # 4
        e.MouseMove: 'mouse-move',  # 5
        e.MouseTrackingChange: 'mouse-tracking-change',  # 105
        e.Paint: 'paint',  # 12
        e.PaletteChange: 'palette-change',  # 39
        e.ParentChange: 'parent-change',  # 21
        e.Polish: 'polish',  # 75
        e.PolishRequest: 'polish-request',  # 74
        e.RequestSoftwareInputPanel: 'request-software-input-panel',  # 199
        e.Resize: 'resize',  # 14
        e.ShortcutOverride: 'shortcut-override',  # 51
        e.Show: 'show',  # 17
        e.ShowToParent: 'show-to-parent',  # 26
        e.StyleChange: 'style-change',  # 100
        e.StatusTip: 'status-tip',  # 112
        e.Timer: 'timer',  # 1
        e.ToolTip: 'tool-tip',  # 110
        e.WindowBlocked: 'window-blocked',  # 103
        e.WindowUnblocked: 'window-unblocked',  # 104
        e.ZOrderChange: 'z-order-change',  # 126
    }
    focus_d = {
        e.DeferredDelete: 'deferred-delete',  # 52
        e.Enter: 'enter',  # 10
        e.FocusIn: 'focus-in',  # 8
        e.WindowActivate: 'window-activate',  # 24
        e.WindowDeactivate: 'window-deactivate',  # 25
    }
    line_edit_ignore_d = {
        e.Enter: 'enter',  # 10 (mouse over)
        e.Leave: 'leave',  # 11 (mouse over)
        e.FocusOut: 'focus-out',  # 9
        e.WindowActivate: 'window-activate',  # 24
        e.WindowDeactivate: 'window-deactivate',  # 25
    }
    none_ignore_d = {
        e.Enter: 'enter',  # 10 (mouse over)
        e.Leave: 'leave',  # 11 (mouse over)
        e.FocusOut: 'focus-out',  # 9
        e.WindowActivate: 'window-activate',  # 24
    }
    if et in ignore_d:
        return
    w = QtWidgets.QApplication.focusWidget()
    if verbose:  # Too verbose for --trace-events.
        for d in (ignore_d, focus_d, line_edit_ignore_d, none_ignore_d):
            t = d.get(et)
            if t: break
        else:
            t = et
        g.trace(f"{t:20} {w.__class__}")
        return
    if w is None:
        if et not in none_ignore_d:
            t = focus_d.get(et) or et
            g.trace(f"None {t}")
    if isinstance(w, QtWidgets.QPushButton):
        return
    if isinstance(w, QtWidgets.QLineEdit):
        if et not in line_edit_ignore_d:
            t = focus_d.get(et) or et
            if hasattr(w, 'objectName'):
                tag = w.objectName()
            else:
                tag = f"id: {id(w)}, {w.__class__.__name__}"
            g.trace(f"{t:20} {tag}")
        return
    t = focus_d.get(et) or et
    if hasattr(w, 'objectName'):
        tag = w.objectName()
    else:
        tag = f"id: {id(w)}, {w.__class__.__name__}"
    g.trace(f"{t:20} {tag}")
#@+node:ekr.20140907123524.18774: *5* @file ../plugins/qt_frame.py
@first # -*- coding: utf-8 -*-
"""Leo's qt frame classes."""
<< imports >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20110605121601.18003: *6*  << imports >> (qt_frame.py)
import leo.core.leoGlobals as g
import leo.core.leoColor as leoColor
import leo.core.leoColorizer as leoColorizer
import leo.core.leoFrame as leoFrame
import leo.core.leoMenu as leoMenu
import leo.commands.gotoCommands as gotoCommands
from leo.core.leoQt import isQt5, QtCore, QtGui, QtWidgets
from leo.core.leoQt import Qsci
import leo.plugins.qt_events as qt_events
import leo.plugins.qt_text as qt_text
import leo.plugins.qt_tree as qt_tree
from leo.plugins.mod_scripting import build_rclick_tree
import os
import sys
import platform
from collections import defaultdict
try:
    import leo.plugins.nested_splitter as nested_splitter
    splitter_class = nested_splitter.NestedSplitter
    nested_splitter.NestedSplitter.enabled = False
        # Disable special behavior, turned back on by associated plugin.
except ImportError:
    print('Can not import nested_splitter')
    splitter_class = QtWidgets.QSplitter
#@+node:ekr.20200303082457.1: *6* top-level commands (qt_frame.py)
#@+node:ekr.20200303082511.6: *7* 'contract-body-pane' & 'expand-outline-pane'
@g.command('contract-body-pane')
@g.command('expand-outline-pane')
def contractBodyPane(event):
    '''Contract the body pane. Expand the outline/log splitter.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = min(1.0, f.ratio + 0.1)
    f.divideLeoSplitter1(r)
    
expandOutlinePane = contractBodyPane
#@+node:ekr.20200303084048.1: *7* 'contract-log-pane'
@g.command('contract-log-pane')
def contractLogPane(event):
    '''Contract the log pane. Expand the outline pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = min(1.0, f.secondary_ratio + 0.1)
    f.divideLeoSplitter2(r)
#@+node:ekr.20200303084225.1: *7* 'contract-outline-pane' & 'expand-body-pane'
@g.command('contract-outline-pane')
@g.command('expand-body-pane')
def contractOutlinePane(event):
    '''Contract the outline pane. Expand the body pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = max(0.0, f.ratio - 0.1)
    f.divideLeoSplitter1(r)

expandBodyPane = contractOutlinePane
#@+node:ekr.20200303084226.1: *7* 'expand-log-pane'
@g.command('expand-log-pane')
def expandLogPane(event):
    '''Expand the log pane. Contract the outline pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = max(0.0, f.secondary_ratio - 0.1)
    f.divideLeoSplitter2(r)
#@+node:ekr.20200303084610.1: *7* 'hide-body-pane'
@g.command('hide-body-pane')
def hideBodyPane(event):
    '''Hide the body pane. Fully expand the outline/log splitter.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter1(1.0)
#@+node:ekr.20200303084625.1: *7* 'hide-log-pane'
@g.command('hide-log-pane')
def hideLogPane(event):
    '''Hide the log pane. Fully expand the outline pane.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter2(1.0)
#@+node:ekr.20200303082511.7: *7* 'hide-outline-pane'
@g.command('hide-outline-pane')
def hideOutlinePane(event):
    '''Hide the outline/log splitter. Fully expand the body pane.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter1(0.0)

#@+node:ekr.20110605121601.18137: *6* class  DynamicWindow (QMainWindow)
class DynamicWindow(QtWidgets.QMainWindow):
    """
    A class representing all parts of the main Qt window.
    
    c.frame.top is a DynamicWindow.
    c.frame.top.leo_master is a LeoTabbedTopLevel.
    c.frame.top.parent() is a QStackedWidget()

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    """
    @others
#@+node:ekr.20110605121601.18138: *7*  dw.ctor & reloadSettings
def __init__(self, c, parent=None):
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    if 'startup' in g.app.debug:
        print('DynamicWindow.__init__', c.shortFileName())
    super().__init__(parent)
    self.leo_c = c
    self.leo_master = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
#@+node:ekr.20110605121601.18172: *7* dw.do_leo_spell_btn_*
def doSpellBtn(self, btn):
    """Execute btn, a button handler."""
    # Make *sure* this never crashes.
    try:
        tab = self.leo_c.spellCommands.handler.tab
        button = getattr(tab, btn)
        button()
    except Exception:
        g.es_exception()

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@+node:ekr.20110605121601.18140: *7* dw.closeEvent
def closeEvent(self, event):
    """Handle a close event in the Leo window."""
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        event.accept()
        return
    if c.inCommand:
        c.requestCloseWindow = True
        return
    ok = g.app.closeLeoWindow(c.frame)
    if ok:
        event.accept()
    else:
        event.ignore()
#@+node:ekr.20110605121601.18139: *7* dw.construct & helpers
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')
        # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
#@+node:ekr.20140915062551.19519: *8* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
#@+node:ekr.20110605121601.18141: *7* dw.createMainWindow & helpers
def createMainWindow(self):
    """
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    """
    self.setMainWindowOptions()
    #
    # Legacy code: will not go away.
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        # Top pane contains only outline.  Bottom pane contains body and log panes.
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        # Top pane contains outline and log panes.
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(self)
    # Signals...
    QtCore.QMetaObject.connectSlotsByName(self)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18142: *8* dw.top-level
#@+node:ekr.20190118150859.10: *9* dw.addNewEditor
def addNewEditor(self, name):
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    #
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame
        # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    
#@+node:ekr.20110605121601.18143: *9* dw.createBodyPane
def createBodyPane(self, parent):
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=QtWidgets.QSizePolicy.Expanding,
         vPolicy=QtWidgets.QSizePolicy.Expanding,
    )
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
 
#@+node:ekr.20110605121601.18144: *9* dw.createCentralWidget
def createCentralWidget(self):
    """Create the central widget."""
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
    return w
#@+node:ekr.20110605121601.18145: *9* dw.createLogPane & helpers (legacy)
def createLogPane(self, parent):
    """Create all parts of Leo's log pane."""
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    #
    # #516 and #1507: Create a Find tab unless we are using a dialog.
    #
    # Careful: @bool minibuffer-ding-mode overrides @bool use-find-dialog.
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if use_minibuffer or not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Complete the Find tab in LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
#@+node:ekr.20131118172620.16858: *10* dw.finishCreateLogPane
def finishCreateLogPane(self):
    """It's useful to create this late, because c.config is now valid."""
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
#@+node:ekr.20110605121601.18146: *9* dw.createMainLayout
def createMainLayout(self, parent):
    """Create the layout for Leo's main window."""
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setObjectName('main_splitter')
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setObjectName('secondary_splitter')
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18147: *9* dw.createMenuBar
def createMenuBar(self):
    """Create Leo's menu bar."""
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
#@+node:ekr.20110605121601.18148: *9* dw.createMiniBuffer (class VisLineEdit)
def createMiniBuffer(self, parent):
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            super().focusInEvent(event)
                # Call the base class method.

        def focusOutEvent(self, event):
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
        # Transfers focus request from label to lineEdit.
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
#@+node:ekr.20110605121601.18149: *9* dw.createOutlinePane
def createOutlinePane(self, parent):
    """Create the widgets and ivars for Leo's outline."""
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
#@+node:ekr.20110605121601.18150: *9* dw.createStatusBar
def createStatusBar(self, parent):
    """Create the widgets and ivars for Leo's status area."""
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
#@+node:ekr.20110605121601.18212: *9* dw.packLabel
def packLabel(self, w, n=None):
    """
    Pack w into the body frame's QVGridLayout.
    
    The type of w does not affect the following code. In fact, w is a
    QTextBrowser possibly packed inside a LeoLineTextWidget.
    """
    c = self.leo_c
    #
    # Reuse the grid layout in the body frame.
    grid = self.leo_body_frame.layout()
    # Pack the label and the text widget.
    label = QtWidgets.QLineEdit(None)
    label.setObjectName('editorLabel')
    label.setText(c.p.h)
    if n is None:
        n = c.frame.body.numberOfEditors
    n = max(0, n - 1)
    grid.addWidget(label, 0, n)
    grid.addWidget(w, 1, n)
    grid.setRowStretch(0, 0)  # Don't grow the label vertically.
    grid.setRowStretch(1, 1)  # Give row 1 as much as vertical room as possible.
    # Inject the ivar.
    w.leo_label = label
#@+node:ekr.20110605121601.18151: *9* dw.setMainWindowOptions
def setMainWindowOptions(self):
    """Set default options for Leo's main window."""
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
#@+node:ekr.20110605121601.18152: *8* dw.widgets
#@+node:ekr.20110605121601.18153: *9* dw.createButton
def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18154: *9* dw.createCheckBox
def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18155: *9* dw.createFrame
def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    """Create a Qt Frame."""
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18156: *9* dw.createGrid
def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18157: *9* dw.createHLayout & createVLayout
def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
#@+node:ekr.20110605121601.18158: *9* dw.createLabel
def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18159: *9* dw.createLineEdit
def createLineEdit(self, parent, name, disabled=True):

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled  # Inject the ivar.
    return w
#@+node:ekr.20110605121601.18160: *9* dw.createRadioButton
def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18161: *9* dw.createStackedWidget
def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18162: *9* dw.createTabWidget
def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18163: *9* dw.createText (creates QTextBrowser)
def createText(self, parent, name,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18164: *9* dw.createTreeWidget
def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18165: *8* dw.log tabs
#@+node:ekr.20110605121601.18167: *9* dw.createSpellTab
def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for (ivar, label, row, col) in table:
        name = f"spell_{label}_button"
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, f"do_leo_spell_btn_{ivar}")
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, f"leo_spell_btn_{ivar}", button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent  # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox  # Must exist
    self.leo_spell_label = lab  # Must exist (!!)
#@+node:ekr.20110605121601.18166: *9* dw.createFindTab & helpers
def createFindTab(self, parent, tab_widget):
    """Create a Find Tab in the given parent."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0  # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget  # A scrollArea.
    ftm.init_widgets()
#@+node:ekr.20131118152731.16847: *10* dw.create_find_grid
def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
#@+node:ekr.20131118152731.16849: *10* dw.create_find_header
def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
#@+node:ekr.20131118152731.16848: *10* dw.create_find_findbox
def create_find_findbox(self, grid, parent, row):
    """Create the Find: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(
        parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16850: *10* dw.create_find_replacebox
def create_find_replacebox(self, grid, parent, row):
    """Create the Replace: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(
        parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:')  # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16851: *10* dw.create_find_checkboxes
def create_find_checkboxes(self, grid, parent, max_row2, row):
    """Create check boxes and radio buttons."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&', '').lower()
        return f"{kind}{name}"

    # Rows for check boxes, radio buttons & execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &Word', 0, 0),
        ('rb', '&Entire outline', 0, 1),
        # Second row.
        ('box', '&Ignore case', 1, 0),
        ('rb', '&Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &Around', 2, 0),
        ('rb', '&Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&Xp', 3, 0),
        ('box', 'search &Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &Finds', 4, 0),
        ('box', 'search &Body', 4, 1),
        # Sixth row.
        ('box', 'mark &Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
#@+node:ekr.20131118152731.16852: *10* dw.create_find_buttons
def create_find_buttons(self, grid, parent, max_row2, row):
    """
    Per #1342, this method now creates labels, not real buttons.
    """
    dw, k = self, self.leo_c.k

    # Create Buttons in column 2 (Leo 4.11.1.)
    table = (
        (0, 2, 'findButton', 'find-next'),
        (1, 2, 'findPreviousButton', 'find-prev'),
        (2, 2, 'findAllButton', 'find-all'),
        (3, 2, 'changeButton', 'replace'),
        (4, 2, 'changeThenFindButton', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'replace-all'),
    )
    for row2, col, func_name, cmd_name in table:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = f"{cmd_name}:  {k.prettyPrintKey(stroke)}"
        else:
            label = cmd_name
        # #1342: Create a label, not a button.
        w = dw.createLabel(parent, cmd_name, label)
        w.setObjectName('find-label')
        grid.addWidget(w, row + row2, col)
    row += max_row2
    row += 2
    return row
#@+node:ekr.20131118152731.16853: *10* dw.create_help_row
def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: <alt-x>help-for-find-commands<return>')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
#@+node:ekr.20150618072619.1: *10* dw.create_find_status
if 0:

    def create_find_status(self, grid, parent, row):
        """Create the status line."""
        dw = self
        status_label = dw.createLabel(parent, 'status-label', 'Status')
        status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
        grid.addWidget(status_label, row, 0)
        grid.addWidget(status_line, row, 1, 1, 2)
        # Official ivars.
        dw.find_status_label = status_label
        dw.find_status_edit = status_line
#@+node:ekr.20131118172620.16891: *10* dw.override_events
def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(
        c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(
        c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)

    if 0:  # #1342: These are no longer needed, because there are no buttons.
        table = (
            ('findNextCommand', 'find-next'),
            ('findPrevCommand', 'find-prev'),
            ('findAll', 'find-all'),
            ('changeCommand', 'replace'),
            ('changeThenFind', 'replace-then-find'),
            ('changeAll', 'replace-all'),
        )
        for func_name, cmd_name in table:
            ivar = f"{cmd_name}-{'button'}"
            ivar = ivar.replace('-', '_')
            w = getattr(ftm, ivar, None)
            func = getattr(fc, func_name, None)
            if w and func:
                next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
                EventWrapper(c, w=w, next_w=next_w, func=func)
            else:
                g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
#@+node:ekr.20131118172620.16892: *11* class EventWrapper
class EventWrapper:

    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper
    @others
#@+node:ekr.20131120054058.16281: *12* create_d
def create_d(self):
    """Create self.d dictionary."""
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
#@+node:ekr.20131118172620.16893: *12* wrapper
def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    if type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16894: *12* keyPress (EventWrapper)
def keyPress(self, event):

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16895: *12* keyRelease
def keyRelease(self, event):
    return self.oldEvent(event)
#@+node:ekr.20110605121601.18168: *8* dw.utils
#@+node:ekr.20110605121601.18169: *9* dw.setName
def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
#@+node:ekr.20110605121601.18170: *9* dw.setSizePolicy
def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
#@+node:ekr.20110605121601.18171: *9* dw.tr
def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    return QtWidgets.QApplication.translate(
        'MainWindow',
        s,
        None,
        QtWidgets.QApplication.UnicodeUTF8)
#@+node:ekr.20110605121601.18173: *7* dw.select
def select(self, c):
    """Select the window or tab for c."""
    # Called from the save commands.
    self.leo_master.select(c)
#@+node:ekr.20110605121601.18178: *7* dw.setGeometry (legacy)
def setGeometry(self, rect):
    """Set the window geometry, but only once when using the qt gui."""
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
        # Only set the geometry once, even for new files.
        if not hasattr(m, 'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            super().setGeometry(rect)
    else:
        super().setGeometry(rect)
#@+node:ekr.20110605121601.18177: *7* dw.setLeoWindowIcon
def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
    g.app.gui.attachLeoIcon(self)
#@+node:ekr.20110605121601.18174: *7* dw.setSplitDirection
def setSplitDirection(self, main_splitter, secondary_splitter, orientation):
    """Set the orientations of the splitters in the Leo main window."""
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    h, v = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
#@+node:ekr.20130804061744.12425: *7* dw.setWindowTitle
if 0:  # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
#@+node:ekr.20131117054619.16698: *6* class FindTabManager
class FindTabManager:
    """A helper class for the LeoFind class."""
    @others
#@+node:ekr.20131117120458.16794: *7*  ftm.ctor
def __init__(self, c):
    """Ctor for the FindTabManager class."""
    self.c = c
    self.entry_focus = None  # The widget that had focus before find-pane entered.
    # Find/change text boxes.
    self.find_findbox = None
    self.find_replacebox = None
    # Check boxes.
    self.check_box_ignore_case = None
    self.check_box_mark_changes = None
    self.check_box_mark_finds = None
    self.check_box_regexp = None
    self.check_box_search_body = None
    self.check_box_search_headline = None
    self.check_box_whole_word = None
    self.check_box_wrap_around = None
    # Radio buttons
    self.radio_button_entire_outline = None
    self.radio_button_node_only = None
    self.radio_button_suboutline_only = None
    # Push buttons
    self.find_next_button = None
    self.find_prev_button = None
    self.find_all_button = None
    self.help_for_find_commands_button = None
    self.replace_button = None
    self.replace_then_find_button = None
    self.replace_all_button = None
#@+node:ekr.20131117164142.16853: *7* ftm.text getters/setters
def getFindText(self):
    return self.find_findbox.text()

def getReplaceText(self):
    return self.find_replacebox.text()

getChangeText = getReplaceText

def setFindText(self, s):
    w = self.find_findbox
    s = g.checkUnicode(s)
    w.clear()
    w.insert(s)

def setReplaceText(self, s):
    w = self.find_replacebox
    s = g.checkUnicode(s)
    w.clear()
    w.insert(s)

setChangeText = setReplaceText
#@+node:ekr.20131119185305.16478: *7* ftm.clear_focus & init_focus & set_entry_focus
def clear_focus(self):
    self.entry_focus = None
    self.find_findbox.clearFocus()

def init_focus(self):
    self.set_entry_focus()
    w = self.find_findbox
    w.setFocus()
    s = w.text()
    w.setSelection(0, len(s))

def set_entry_focus(self):
    # Remember the widget that had focus, changing headline widgets
    # to the tree pane widget.  Headline widgets can disappear!
    c = self.c
    w = g.app.gui.get_focus(raw=True)
    if w != c.frame.body.wrapper.widget:
        w = c.frame.tree.treeWidget
    self.entry_focus = w
#@+node:ekr.20150619082825.1: *7* ftm.set_ignore_case
def set_ignore_case(self, aBool):
    """Set the ignore-case checkbox to the given value."""
    c = self.c
    c.findCommands.ignore_case = aBool
    w = self.check_box_ignore_case
    w.setChecked(aBool)
#@+node:ekr.20131117120458.16789: *7* ftm.init_widgets (creates callbacks)
def init_widgets(self):
    """
    Init widgets and ivars from c.config settings.
    Create callbacks that always keep the LeoFind ivars up to date.
    """
    c = self.c
    find = c.findCommands
    # Find/change text boxes.
    table = (
        ('find_findbox', 'find_text', '<find pattern here>'),
        ('find_replacebox', 'change_text', ''),
    )
    for ivar, setting_name, default in table:
        s = c.config.getString(setting_name) or default
        w = getattr(self, ivar)
        w.insert(s)
        if find.minibuffer_mode:
            w.clearFocus()
        else:
            w.setSelection(0, len(s))
    # Check boxes.
    table = (
        ('ignore_case', self.check_box_ignore_case),
        ('mark_changes', self.check_box_mark_changes),
        ('mark_finds', self.check_box_mark_finds),
        ('pattern_match', self.check_box_regexp),
        ('search_body', self.check_box_search_body),
        ('search_headline', self.check_box_search_headline),
        ('whole_word', self.check_box_whole_word),
        ('wrap', self.check_box_wrap_around),
    )
    for setting_name, w in table:
        val = c.config.getBool(setting_name, default=False)
        # The setting name is also the name of the LeoFind ivar.
        assert hasattr(find, setting_name), setting_name
        setattr(find, setting_name, val)
        if val:
            w.toggle()

        def check_box_callback(n, setting_name=setting_name, w=w):
            # The focus has already change when this gets called.
            # focus_w = QtWidgets.QApplication.focusWidget()
            val = w.isChecked()
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            # Too kludgy: we must use an accurate setting.
            # It would be good to have an "about to change" signal.
            # Put focus in minibuffer if minibuffer find is in effect.
            c.bodyWantsFocusNow()

        w.stateChanged.connect(check_box_callback)
    # Radio buttons
    table = (
        ('node_only', 'node_only', self.radio_button_node_only),
        ('entire_outline', None, self.radio_button_entire_outline),
        ('suboutline_only', 'suboutline_only', self.radio_button_suboutline_only),
    )
    for setting_name, ivar, w in table:
        val = c.config.getBool(setting_name, default=False)
        # The setting name is also the name of the LeoFind ivar.
        if ivar is not None:
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            w.toggle()

        def radio_button_callback(n, ivar=ivar, setting_name=setting_name, w=w):
            val = w.isChecked()
            find.radioButtonsChanged = True
            if ivar:
                assert hasattr(find, ivar), ivar
                setattr(find, ivar, val)

        w.toggled.connect(radio_button_callback)
    # Ensure one radio button is set.
    if not find.node_only and not find.suboutline_only:
        w = self.radio_button_entire_outline
        w.toggle()
#@+node:ekr.20131117120458.16792: *7* ftm.set_radio_button
def set_radio_button(self, name):
    """Set the value of the radio buttons"""
    c = self.c
    find = c.findCommands
    d = {
        # Name is not an ivar. Set by find.setFindScope... commands.
        'node-only': self.radio_button_node_only,
        'entire-outline': self.radio_button_entire_outline,
        'suboutline-only': self.radio_button_suboutline_only,
    }
    w = d.get(name)
    assert w
    # Most of the work will be done in the radio button callback.
    if not w.isChecked():
        w.toggle()
    if find.minibuffer_mode:
        find.showFindOptionsInStatusArea()
#@+node:ekr.20131117120458.16791: *7* ftm.toggle_checkbox
@nobeautify

def toggle_checkbox(self,checkbox_name):
    """Toggle the value of the checkbox whose name is given."""
    c = self.c
    find = c.findCommands
    if not find:
        return
    d = {
        'ignore_case':     self.check_box_ignore_case,
        'mark_changes':    self.check_box_mark_changes,
        'mark_finds':      self.check_box_mark_finds,
        'pattern_match':   self.check_box_regexp,
        'search_body':     self.check_box_search_body,
        'search_headline': self.check_box_search_headline,
        'whole_word':      self.check_box_whole_word,
        'wrap':            self.check_box_wrap_around,
    }
    w = d.get(checkbox_name)
    assert w
    assert hasattr(find,checkbox_name),checkbox_name
    w.toggle() # The checkbox callback toggles the ivar.
    if find.minibuffer_mode:
        find.showFindOptionsInStatusArea()
#@+node:ekr.20131115120119.17376: *6* class LeoBaseTabWidget(QTabWidget)
class LeoBaseTabWidget(QtWidgets.QTabWidget):
    """Base class for all QTabWidgets in Leo."""
    @others
#@+node:ekr.20131115120119.17390: *7* qt_base_tab.__init__
def __init__(self, *args, **kwargs):

    #
    # Called from frameFactory.createMaster.
    #
    self.factory = kwargs.get('factory')
    if self.factory:
        del kwargs['factory']
    super().__init__(*args, **kwargs)
    self.detached = []
    self.setMovable(True)

    def tabContextMenu(point):
        index = self.tabBar().tabAt(point)
        if index < 0:  # or (self.count() < 1 and not self.detached):
            return
        menu = QtWidgets.QMenu()
        # #310: Create new file on right-click in file tab in UI.
        if True:
            a = menu.addAction("New Outline")
            a.triggered.connect(lambda checked: self.new_outline(index))
        if self.count() > 1:
            a = menu.addAction("Detach")
            a.triggered.connect(lambda checked: self.detach(index))
            a = menu.addAction("Horizontal tile")
            a.triggered.connect(
                lambda checked: self.tile(index, orientation='H'))
            a = menu.addAction("Vertical tile")
            a.triggered.connect(
                lambda checked: self.tile(index, orientation='V'))
        if self.detached:
            a = menu.addAction("Re-attach All")
            a.triggered.connect(lambda checked: self.reattach_all())
        menu.exec_(self.mapToGlobal(point))

    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(tabContextMenu)
#@+node:ekr.20180123082452.1: *7* qt_base_tab.new_outline
def new_outline(self, index):
    """Open a new outline tab."""
    w = self.widget(index)
    c = w.leo_c
    c.new()
#@+node:ekr.20131115120119.17391: *7* qt_base_tab.detach
def detach(self, index):
    """detach tab (from tab's context menu)"""
    w = self.widget(index)
    name = self.tabText(index)
    self.detached.append((name, w))
    self.factory.detachTab(w)
    icon = g.app.gui.getImageFinder("application-x-leo-outline.png")
    icon = QtGui.QIcon(icon)
    if icon:
        w.window().setWindowIcon(icon)
    c = w.leo_c
    if c.styleSheetManager:
        c.styleSheetManager.set_style_sheets(w=w)
    if platform.system() == 'Windows':
        w.move(20, 20)
            # Windows (XP and 7) put the windows title bar off screen.
    return w
#@+node:ekr.20131115120119.17392: *7* qt_base_tab.tile
def tile(self, index, orientation='V'):
    """detach tab and tile with parent window"""
    w = self.widget(index)
    window = w.window()
    # window.showMaximized()
    # this doesn't happen until we've returned to main even loop
    # user needs to do it before using this function
    fg = window.frameGeometry()
    geom = window.geometry()
    x, y, fw, fh = fg.x(), fg.y(), fg.width(), fg.height()
    ww, wh = geom.width(), geom.height()
    w = self.detach(index)
    if window.isMaximized():
        window.showNormal()
    if orientation == 'V':
        # follow MS Windows convention for which way is horizontal/vertical
        window.resize(ww / 2, wh)
        window.move(x, y)
        w.resize(ww / 2, wh)
        w.move(x + fw / 2, y)
    else:
        window.resize(ww, wh / 2)
        window.move(x, y)
        w.resize(ww, wh / 2)
        w.move(x, y + fh / 2)
#@+node:ekr.20131115120119.17393: *7* qt_base_tab.reattach_all
def reattach_all(self):
    """reattach all detached tabs"""
    for name, w in self.detached:
        self.addTab(w, name)
        self.factory.leoFrames[w] = w.leo_c.frame
    self.detached = []
#@+node:ekr.20131115120119.17394: *7* qt_base_tab.delete
def delete(self, w):
    """called by TabbedFrameFactory to tell us a detached tab
    has been deleted"""
    self.detached = [i for i in self.detached if i[1] != w]
#@+node:ekr.20131115120119.17395: *7* qt_base_tab.setChanged
def setChanged(self, c, changed):
    """Set the changed indicator in c's tab."""
    # Find the tab corresponding to c.
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    if i < 0: return
    s = self.tabText(i)
    if len(s) > 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i, title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i, title)
#@+node:ekr.20131115120119.17396: *7* qt_base_tab.setTabName
def setTabName(self, c, fileName):
    """Set the tab name for c's tab to fileName."""
    # Find the tab corresponding to c.
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    if i > -1:
        self.setTabText(i, g.shortFileName(fileName))
#@+node:ekr.20131115120119.17397: *7* qt_base_tab.closeEvent
def closeEvent(self, event):
    """Handle a close event."""
    g.app.gui.close_event(event)
#@+node:ekr.20131115120119.17398: *7* qt_base_tab.select (leoTabbedTopLevel)
def select(self, c):
    """Select the tab for c."""
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    # Fix bug 844953: tell Unity which menu to use.
        # c.enableMenuBar()
#@+node:ekr.20110605121601.18180: *6* class LeoQtBody(leoFrame.LeoBody)
class LeoQtBody(leoFrame.LeoBody):
    """A class that represents the body pane of a Qt window."""
    @others
#@+node:ekr.20150521061618.1: *7* LeoQtBody.cmd (decorator)
def cmd(name):
    """Command decorator for the c.frame.body class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'body'])
#@+node:ekr.20110605121601.18181: *7* LeoQtBody.Birth
#@+node:ekr.20110605121601.18182: *8* LeoQtBody.ctor
def __init__(self, frame, parentFrame):
    """Ctor for LeoQtBody class."""
    # Call the base class constructor.
    super().__init__(frame, parentFrame)
    c = self.c
    assert c.frame == frame and frame.c == c
    self.reloadSettings()
    self.set_widget()
        # Sets self.widget and self.wrapper.
    self.setWrap(c.p)
    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
    # For renderer panes.
    self.canvasRenderer = None
    self.canvasRendererLabel = None
    self.canvasRendererVisible = False
    self.textRenderer = None
    self.textRendererLabel = None
    self.textRendererVisible = False
    self.textRendererWrapper = None
#@+node:ekr.20110605121601.18185: *9* LeoQtBody.get_name
def getName(self):
    return 'body-widget'
#@+node:ekr.20140901062324.18562: *9* LeoQtBody.reloadSettings
def reloadSettings(self):
    c = self.c
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_gutter = c.config.getBool('use-gutter', default=False)
#@+node:ekr.20160309074124.1: *9* LeoQtBody.set_invisibles
def set_invisibles(self, c):
    """Set the show-invisibles bit in the document."""
    d = c.frame.body.wrapper.widget.document()
    option = QtGui.QTextOption()
    if c.frame.body.colorizer.showInvisibles:
        option.setFlags(QtGui.QTextOption.ShowTabsAndSpaces)
    d.setDefaultTextOption(option)
#@+node:ekr.20140901062324.18563: *9* LeoQtBody.set_widget
def set_widget(self):
    """Set the actual gui widget."""
    c = self.c
    top = c.frame.top
    sw = getattr(top, 'stackedWidget', None)
    if sw:
        sw.setCurrentIndex(1)
    if self.useScintilla and not Qsci:
        g.trace('Can not import Qsci: ignoring @bool qt-use-scintilla')
    if self.useScintilla and Qsci:
        self.widget = c.frame.top.scintilla_widget
            # A Qsci.QsciSintilla object.
            # dw.createText sets self.scintilla_widget
        self.wrapper = qt_text.QScintillaWrapper(self.widget, name='body', c=c)
        self.colorizer = leoColorizer.QScintillaColorizer(
            c, self.widget, self.wrapper)
    else:
        self.widget = top.richTextEdit  # A LeoQTextBrowser
        self.wrapper = qt_text.QTextEditWrapper(self.widget, name='body', c=c)
        self.widget.setAcceptRichText(False)
        self.colorizer = leoColorizer.make_colorizer(c, self.widget, self.wrapper)
#@+node:ekr.20110605121601.18183: *9* LeoQtBody.setWrap
def setWrap(self, p=None, force=False):
    """Set **only** the wrap bits in the body."""
    if not p or self.useScintilla:
        return
    c = self.c
    w = c.frame.body.wrapper.widget
    option, qt = QtGui.QTextOption, QtCore.Qt
    if force:
        wrap = option.WrapAtWordBoundaryOrAnywhere
    else:
        wrap = g.scanAllAtWrapDirectives(c, p)
        w.setHorizontalScrollBarPolicy(
            qt.ScrollBarAlwaysOff if wrap else qt.ScrollBarAsNeeded)
        wrap = option.WrapAtWordBoundaryOrAnywhere if wrap else option.NoWrap
            # was option WordWrap
    w.setWordWrapMode(wrap)
#@+node:ekr.20110605121601.18193: *7* LeoQtBody.Editors
#@+node:ekr.20110605121601.18194: *8* LeoQtBody.entries
#@+node:ekr.20110605121601.18195: *9* LeoQtBody.add_editor_command
# An override of leoFrame.addEditor.

@cmd('editor-add')
@cmd('add-editor')
def add_editor_command(self, event=None):
    """Add another editor to the body pane."""
    c, p = self.c, self.c.p
    d = self.editorWrappers
    dw = c.frame.top
    wrapper = c.frame.body.wrapper  # A QTextEditWrapper
    widget = wrapper.widget
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.totalNumberOfEditors == 2:
        d ['1'] = wrapper
        # Pack the original body editor.
        # Fix #1021: Pack differently depending on whether the gutter exists.
        if self.use_gutter:
            dw.packLabel(widget.parent(), n=1)
            widget.leo_label = widget.parent().leo_label
        else:
            dw.packLabel(widget, n=1)
    name = f"{self.totalNumberOfEditors}"
    f, wrapper = dw.addNewEditor(name)
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(widget), widget
    assert isinstance(f, QtWidgets.QFrame), f
    d[name] = wrapper
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        keys = list(d.keys())
        old_name = keys[0]
        old_wrapper = d.get(old_name)
        old_w = old_wrapper.widget
        self.injectIvars(f, old_name, p, old_wrapper)
        self.updateInjectedIvars(old_w, p)
        self.selectLabel(old_wrapper)
             # Immediately create the label in the old editor.
    # Switch editors.
    c.frame.body.wrapper = wrapper
    self.selectLabel(wrapper)
    self.selectEditor(wrapper)
    self.updateEditors()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18197: *9* LeoQtBody.assignPositionToEditor
def assignPositionToEditor(self, p):
    """Called *only* from tree.select to select the present body editor."""
    c = self.c
    wrapper = c.frame.body.wrapper
    w = wrapper and wrapper.widget
        # Careful: w may not exist during unit testing.
    if w:
        self.updateInjectedIvars(w, p)
        self.selectLabel(wrapper)
#@+node:ekr.20110605121601.18198: *9* LeoQtBody.cycleEditorFocus
# Use the base class method.
#@+node:ekr.20110605121601.18199: *9* LeoQtBody.delete_editor_command
@cmd('delete-editor')
@cmd('editor-delete')
def delete_editor_command(self, event=None):
    """Delete the presently selected body text editor."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    # Fix bug 228: make *sure* the old text is saved.
    c.p.b = wrapper.getAllText()
    name = getattr(w, 'leo_name', None)
    if len(list(d.keys())) <= 1 or name == '1':
        g.warning('can not delete main editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        label = getattr(w, 'leo_label', None)
        if label:
            self.unpackWidget(layout, label)
    w.leo_label = None
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18200: *9* LeoQtBody.findEditorForChapter
def findEditorForChapter(self, chapter, p):
    """Return an editor to be assigned to chapter."""
    c, d = self.c, self.editorWrappers
    values = list(d.values())
    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w, 'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w, 'leo_p') and w.leo_p and w.leo_p == p
            ):
                return w
    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w, 'leo_chapter') and w.leo_chapter == chapter:
            return w
    # As a last resort, return the present editor widget.
    return c.frame.body.wrapper
#@+node:ekr.20110605121601.18201: *9* LeoQtBody.select/unselectLabel
def unselectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    pass
    # self.createChapterIvar(wrapper)

def selectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    c = self.c
    w = wrapper.widget
    label = getattr(w, 'leo_label', None)
    if label:
        label.setEnabled(True)
        label.setText(c.p.h)
        label.setEnabled(False)
#@+node:ekr.20110605121601.18202: *9* LeoQtBody.selectEditor & helpers
selectEditorLockout = False

def selectEditor(self, wrapper):
    """Select editor w and node w.leo_p."""
    # pylint: disable=arguments-differ
    trace = 'select' in g.app.debug and not g.unitTesting
    tag = 'qt_body.selectEditor'
    c = self.c
    if not wrapper:
        return c.frame.body.wrapper
    if self.selectEditorLockout:
        return None
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if trace:
        print(f"{tag:>30}: {wrapper} {c.p.h}")
    if wrapper and wrapper == c.frame.body.wrapper:
        self.deactivateEditors(wrapper)
        if hasattr(w, 'leo_p') and w.leo_p and w.leo_p != c.p:
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        return None
    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False
    return val  # Don't put a return in a finally clause.
#@+node:ekr.20110605121601.18203: *10* LeoQtBody.selectEditorHelper
def selectEditorHelper(self, wrapper):

    c = self.c
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if not w.leo_p:
        g.trace('no w.leo_p')
        return 'break'
    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget(w.leo_p, wrapper)  # switches colorizers.
    c.frame.body.wrapper = wrapper
    # 2014/09/04: Must set both wrapper.widget and body.widget.
    c.frame.body.wrapper.widget = w
    c.frame.body.widget = w
    w.leo_active = True
    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)
    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w, 'leo_p') and w.leo_p):
        g.trace('***** no w.leo_p', w)
        return None
    p = w.leo_p
    assert p, p
    c.expandAllAncestors(p)
    c.selectPosition(p)
        # Calls assignPositionToEditor.
        # Calls p.v.restoreCursorAndScroll.
    c.redraw()
    c.recolor()
    c.bodyWantsFocus()
    return None
#@+node:ekr.20110605121601.18205: *9* LeoQtBody.updateEditors
# Called from addEditor and assignPositionToEditor

def updateEditors(self):
    c, p = self.c, self.c.p;
    body = p.b
    d = self.editorWrappers
    if len(list(d.keys())) < 2:
        return  # There is only the main widget
    w0 = c.frame.body.wrapper
    i, j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w, 'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p, wrapper)
            sb.setSliderPosition(pos)
    c.bodyWantsFocus()
    w0.setSelectionRange(i, j, insert=ins)
    sb0.setSliderPosition(pos0)
#@+node:ekr.20110605121601.18206: *8* LeoQtBody.utils
#@+node:ekr.20110605121601.18207: *9* LeoQtBody.computeLabel
def computeLabel(self, w):
    if hasattr(w, 'leo_label') and w.leo_label:  # 2011/11/12
        s = w.leo_label.text()
    else:
        s = ''
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        s = f"{w.leo_chapter}: {s}"
    return s
#@+node:ekr.20110605121601.18208: *9* LeoQtBody.createChapterIvar
def createChapterIvar(self, w):
    c = self.c; cc = c.chapterController
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        pass
    elif cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
#@+node:ekr.20110605121601.18209: *9* LeoQtBody.deactivateEditors
def deactivateEditors(self, wrapper):
    """Deactivate all editors except wrapper's editor."""
    d = self.editorWrappers
    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2, 'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            self.onFocusOut(w2)
#@+node:ekr.20110605121601.18210: *9* LeoQtBody.ensurePositionExists
def ensurePositionExists(self, w):
    """Return True if w.leo_p exists or can be reconstituted."""
    c = self.c
    if c.positionExists(w.leo_p):
        return True
    for p2 in c.all_unique_positions():
        if p2.v and p2.v == w.leo_p.v:
            w.leo_p = p2.copy()
            return True
    # This *can* happen when selecting a deleted node.
    w.leo_p = c.p.copy()
    return False
#@+node:ekr.20110605121601.18211: *9* LeoQtBody.injectIvars
def injectIvars(self, parentFrame, name, p, wrapper):

    trace = g.app.debug == 'select' and not g.app.unitTesting
    tag = 'qt_body.injectIvars'
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if trace:
        print(f"{tag:>30}: {wrapper!r} {g.callers(1)}")
    # Inject ivars
    if name == '1':
        w.leo_p = None  # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in JEditColorizer ctor.
    w.leo_frame = parentFrame
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    w.leo_wrapper = wrapper
#@+node:ekr.20110605121601.18213: *9* LeoQtBody.recolorWidget (QScintilla only)
def recolorWidget(self, p, wrapper):
    """Support QScintillaColorizer.colorize."""
    # pylint: disable=arguments-differ
    c = self.c
    colorizer = c.frame.body.colorizer
    if p and colorizer and hasattr(colorizer, 'colorize'):
        g.trace('=====', hasattr(colorizer, 'colorize'), p.h, g.callers())
        old_wrapper = c.frame.body.wrapper
        c.frame.body.wrapper = wrapper
        try:
            colorizer.colorize(p)
        finally:
            # Restore.
            c.frame.body.wrapper = old_wrapper
#@+node:ekr.20110605121601.18214: *9* LeoQtBody.switchToChapter
def switchToChapter(self, w):
    """select w.leo_chapter."""
    c = self.c; cc = c.chapterController
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
#@+node:ekr.20110605121601.18216: *9* LeoQtBody.unpackWidget
def unpackWidget(self, layout, w):

    index = layout.indexOf(w)
    if index == -1:
        return
    item = layout.itemAt(index)
    if item:
        item.setGeometry(QtCore.QRect(0, 0, 0, 0))
        layout.removeItem(item)
#@+node:ekr.20110605121601.18215: *9* LeoQtBody.updateInjectedIvars
def updateInjectedIvars(self, w, p):

    c = self.c
    cc = c.chapterController
    assert g.isTextWidget(w), w
    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
    w.leo_p = p.copy()
#@+node:ekr.20110605121601.18223: *7* LeoQtBody.Event handlers
#@+node:ekr.20110930174206.15472: *8* LeoQtBody.onFocusIn
def onFocusIn(self, obj):
    """Handle a focus-in event in the body pane."""
    trace = 'select' in g.app.debug and not g.unitTesting
    tag = 'qt_body.onFocusIn'
    if obj.objectName() == 'richTextEdit':
        wrapper = getattr(obj, 'leo_wrapper', None)
        if trace:
            print(f"{tag:>30}: {wrapper}")
        if wrapper and wrapper != self.wrapper:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in', obj)
        if hasattr(obj, 'leo_copy_button') and obj.leo_copy_button:
            obj.setReadOnly(True)
        else:
            obj.setReadOnly(False)
        obj.setFocus()  # Weird, but apparently necessary.
#@+node:ekr.20110930174206.15473: *8* LeoQtBody.onFocusOut
def onFocusOut(self, obj):
    """Handle a focus-out event in the body pane."""
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out', obj)
        obj.setReadOnly(True)
#@+node:ekr.20110605121601.18224: *8* LeoQtBody.qtBody.onFocusColorHelper (revised)
# badFocusColors = []

def onFocusColorHelper(self, kind, obj):
    """Handle changes of style when focus changes."""
    c, vc = self.c, self.c.vimCommands
    if vc and c.vim_mode:
        try:
            assert kind in ('focus-in', 'focus-out')
            w = c.frame.body.wrapper.widget
            vc.set_border(w=w, activeFlag=kind == 'focus-in')
        except Exception:
            # g.es_exception()
            pass
#@+node:ekr.20110605121601.18217: *7* LeoQtBody.Renderer panes
#@+node:ekr.20110605121601.18218: *8* LeoQtBody.hideCanvasRenderer
def hideCanvasRenderer(self, event=None):
    """Hide canvas pane."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name), 'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) <= 1: return
    #
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    w.leo_label = None
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label:  # 2011/11/12
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None  # 2011/11/12
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18219: *8* LeoQtBody.hideTextRenderer
def hideCanvas(self, event=None):
    """Hide canvas pane."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name), 'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) <= 1: return
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    w.leo_label = None
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label:
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18220: *8* LeoQtBody.packRenderer
def packRenderer(self, f, name, w):
    n = max(1, self.numberOfEditors)
    assert isinstance(f, QtWidgets.QFrame), f
    layout = f.layout()
    f.setObjectName(f"{name} Frame")
    # Create the text: to do: use stylesheet to set font, height.
    lab = QtWidgets.QLineEdit(f)
    lab.setObjectName(f"{name} Label")
    lab.setText(name)
    # Pack the label and the widget.
    layout.addWidget(lab, 0, max(0, n - 1), QtCore.Qt.AlignVCenter)
    layout.addWidget(w, 1, max(0, n - 1))
    layout.setRowStretch(0, 0)
    layout.setRowStretch(1, 1)  # Give row 1 as much as possible.
    return lab
#@+node:ekr.20110605121601.18221: *8* LeoQtBody.showCanvasRenderer
# An override of leoFrame.addEditor.

def showCanvasRenderer(self, event=None):
    """Show the canvas area in the body pane, creating it if necessary."""
    c = self.c
    f = c.frame.top.leo_body_inner_frame
    assert isinstance(f, QtWidgets.QFrame), f
    if not self.canvasRenderer:
        name = 'Graphics Renderer'
        self.canvasRenderer = w = QtWidgets.QGraphicsView(f)
        w.setObjectName(name)
    if not self.canvasRendererVisible:
        self.canvasRendererLabel = self.packRenderer(f, name, w)
        self.canvasRendererVisible = True
#@+node:ekr.20110605121601.18222: *8* LeoQtBody.showTextRenderer
# An override of leoFrame.addEditor.

def showTextRenderer(self, event=None):
    """Show the canvas area in the body pane, creating it if necessary."""
    c = self.c
    f = c.frame.top.leo_body_inner_frame
    assert isinstance(f, QtWidgets.QFrame), f
    if not self.textRenderer:
        name = 'Text Renderer'
        self.textRenderer = w = qt_text.LeoQTextBrowser(f, c, self)
        w.setObjectName(name)
        self.textRendererWrapper = qt_text.QTextEditWrapper(
            w, name='text-renderer', c=c)
    if not self.textRendererVisible:
        self.textRendererLabel = self.packRenderer(f, name, w)
        self.textRendererVisible = True
#@+node:ekr.20110605121601.18245: *6* class LeoQtFrame (leoFrame)
class LeoQtFrame(leoFrame.LeoFrame):
    """A class that represents a Leo window rendered in qt."""
    @others
#@+node:ekr.20110605121601.18246: *7*  qtFrame.Birth & Death
#@+node:ekr.20110605121601.18247: *8* qtFrame.__init__ & reloadSettings
def __init__(self, c, title, gui):

    super().__init__(c, gui)
    assert self.c == c
    leoFrame.LeoFrame.instances += 1  # Increment the class var.
    # Official ivars...
    self.iconBar = None
    self.iconBarClass = self.QtIconBarClass
    self.initComplete = False  # Set by initCompleteHint().
    self.minibufferVisible = True
    self.statusLineClass = self.QtStatusLineClass
    self.title = title
    self.setIvars()
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.cursorStay = c.config.getBool("cursor-stay-on-paste", default=True)
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_chapter_tabs = c.config.getBool('use-chapter-tabs')
#@+node:ekr.20110605121601.18248: *9* qtFrame.setIvars
def setIvars(self):
    # "Official ivars created in createLeoFrame and its allies.
    self.bar1 = None
    self.bar2 = None
    self.body = None
    self.f1 = self.f2 = None
    self.findPanel = None  # Inited when first opened.
    self.iconBarComponentName = 'iconBar'
    self.iconFrame = None
    self.log = None
    self.canvas = None
    self.outerFrame = None
    self.statusFrame = None
    self.statusLineComponentName = 'statusLine'
    self.statusText = None
    self.statusLabel = None
    self.top = None  # This will be a class Window object.
    self.tree = None
    # Used by event handlers...
    self.controlKeyIsDown = False  # For control-drags
    self.isActive = True
    self.redrawCount = 0
    self.wantedWidget = None
    self.wantedCallbackScheduled = False
    self.scrollWay = None
#@+node:ekr.20110605121601.18249: *8* qtFrame.__repr__
def __repr__(self):
    return f"<LeoQtFrame: {self.title}>"
#@+node:ekr.20150509040227.1: *8* qtFrame.cmd (decorator)
def cmd(name):
    """Command decorator for the LeoQtFrame class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame',])
#@+node:ekr.20110605121601.18250: *8* qtFrame.finishCreate & helpers
def finishCreate(self):
    """Finish creating the outline's frame."""
    # Called from app.newCommander, Commands.__init__
    c = self.c
    assert c
    frameFactory = g.app.gui.frameFactory
    if not frameFactory.masterFrame:
        frameFactory.createMaster()
    self.top = frameFactory.createFrame(leoFrame=self)
    self.createIconBar()  # A base class method.
    self.createSplitterComponents()
    self.createStatusLine()  # A base class method.
    self.createFirstTreeNode()  # Call the base-class method.
    self.menu = LeoQtMenu(c, self, label='top-level-menu')
    g.app.windowList.append(self)
    self.setQtStyle()
    self.miniBufferWidget = qt_text.QMinibufferWrapper(c)
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18251: *9* qtFrame.createSplitterComponents
def createSplitterComponents(self):

    c = self.c
    self.tree = qt_tree.LeoQtTree(c, self)
    self.log = LeoQtLog(self, None)
    self.body = LeoQtBody(self, None)
    self.splitVerticalFlag, ratio, secondary_ratio = self.initialRatios()
    self.resizePanesToRatio(ratio, secondary_ratio)
#@+node:ekr.20190412044556.1: *9* qtFrame.setQtStyle
def setQtStyle(self):
    """
    Set the default Qt style.  Based on pyzo code.
    
    Copyright (C) 2013-2018, the Pyzo development team

    Pyzo is distributed under the terms of the (new) BSD License.
    The full license can be found in 'license.txt'.
    """
    c = self.c
    trace = 'themes' in g.app.debug
    #
    # Get the requested style name.
    stylename = c.config.getString('qt-style-name') or ''
    if trace: g.trace(repr(stylename))
    if not stylename:
        return
    #
    # Return if the style does not exist.
    styles = [z.lower() for z in QtWidgets.QStyleFactory.keys()]
    if stylename.lower() not in styles:
        g.es_print(f"ignoring unknown Qt style name: {stylename!r}")
        g.printObj(styles)
        return
    #
    # Change the style and palette.
    QtWidgets.qApp.nativePalette = QtWidgets.qApp.palette()
    qstyle = QtWidgets.qApp.setStyle(stylename)
    if not qstyle:
        g.es_print(f"failed to set Qt style name: {stylename!r}")
        return
    g.app.gui.qtApp.setPalette(QtWidgets.qApp.nativePalette)
    # g.es_print('set qt style: %r' % stylename)
#@+node:ekr.20110605121601.18252: *8* qtFrame.initCompleteHint
def initCompleteHint(self):
    """A kludge: called to enable text changed events."""
    self.initComplete = True
#@+node:ekr.20110605121601.18253: *8* Destroying the qtFrame
#@+node:ekr.20110605121601.18254: *9* qtFrame.destroyAllObjects (not used)
def destroyAllObjects(self):
    """Clear all links to objects in a Leo window."""
    frame = self; c = self.c
    # g.printGcAll()
    # Do this first.
    << clear all vnodes in the tree >>
    if 1:
        # Destroy all ivars in subcommanders.
        g.clearAllIvars(c.atFileCommands)
        if c.chapterController:  # New in Leo 4.4.3 b1.
            g.clearAllIvars(c.chapterController)
        g.clearAllIvars(c.fileCommands)
        g.clearAllIvars(c.keyHandler)  # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.importCommands)
        g.clearAllIvars(c.tangleCommands)
        g.clearAllIvars(c.undoer)
        g.clearAllIvars(c)
    if 0:  # No need.
        tree = frame.tree; body = self.body
        g.clearAllIvars(body.colorizer)
        g.clearAllIvars(body)
        g.clearAllIvars(tree)
#@+node:ekr.20110605121601.18255: *10* << clear all vnodes in the tree>> (qtFrame)
vList = [z for z in c.all_unique_nodes()]
for v in vList:
    g.clearAllIvars(v)
vList = []  # Remove these references immediately.
#@+node:ekr.20110605121601.18256: *9* qtFrame.destroySelf
def destroySelf(self):
    # Remember these: we are about to destroy all of our ivars!
    c, top = self.c, self.top
    if hasattr(g.app.gui, 'frameFactory'):
        g.app.gui.frameFactory.deleteFrame(top)
    # Indicate that the commander is no longer valid.
    c.exists = False
    if 0:  # We can't do this unless we unhook the event filter.
        # Destroys all the objects of the commander.
        self.destroyAllObjects()
    c.exists = False  # Make sure this one ivar has not been destroyed.
    # print('destroySelf: qtFrame: %s' % c,g.callers(4))
    top.close()
#@+node:ekr.20110605121601.18257: *7* qtFrame.class QtStatusLineClass
class QtStatusLineClass:
    """A class representing the status line."""
    @others
#@+node:ekr.20110605121601.18258: *8* QtStatusLineClass.ctor
def __init__(self, c, parentFrame):
    """Ctor for LeoQtFrame class."""
    self.c = c
    self.statusBar = c.frame.top.statusBar
    self.lastFcol = 0
    self.lastRow = 0
    self.lastCol = 0
    # Create the text widgets.
    self.textWidget1 = w1 = QtWidgets.QLineEdit(self.statusBar)
    self.textWidget2 = w2 = QtWidgets.QLineEdit(self.statusBar)
    w1.setObjectName('status1')
    w2.setObjectName('status2')
    w1.setReadOnly(True)
    w2.setReadOnly(True)
    splitter = QtWidgets.QSplitter()
    self.statusBar.addWidget(splitter, True)
    sizes = c.config.getString('status-line-split-sizes') or '1 2'
    sizes = [int(i) for i in sizes.replace(',', ' ').split()]
    # pylint: disable=consider-using-ternary
    for n, i in enumerate(sizes):
        w = [w1, w2][n]
        policy = w.sizePolicy()
        policy.setHorizontalStretch(i)
        policy.setHorizontalPolicy(policy.Minimum)
        w.setSizePolicy(policy)
    splitter.addWidget(w1)
    splitter.addWidget(w2)
    c.status_line_unl_mode = 'original'

    def cycle_unl_mode():
        if c.status_line_unl_mode == 'original':
            c.status_line_unl_mode = 'canonical'
        else:
            c.status_line_unl_mode = 'original'
        verbose = c.status_line_unl_mode == 'canonical'
        w2.setText(c.p.get_UNL(with_proto=verbose, with_index=verbose))

    def add_item(event, w2=w2):
        menu = w2.createStandardContextMenu()
        menu.addSeparator()
        menu.addAction("Toggle UNL mode", cycle_unl_mode)
        menu.exec_(event.globalPos())

    w2.contextMenuEvent = add_item
    self.put('')
    self.update()
#@+node:ekr.20110605121601.18260: *8* QtStatusLineClass.clear, get & put/1
def clear(self):
    self.put('')

def get(self):
    return self.textWidget2.text()

def put(self, s, bg=None, fg=None):
    self.put_helper(s, self.textWidget2, bg, fg)

def put1(self, s, bg=None, fg=None):
    self.put_helper(s, self.textWidget1, bg, fg)

styleSheetCache = {}
    # Keys are widgets, values are stylesheets.

def put_helper(self, s, w, bg=None, fg=None):
    """Put string s in the indicated widget, with proper colors."""
    c = self.c
    bg = bg or c.config.getColor('status-bg') or 'white'
    fg = fg or c.config.getColor('status-fg') or 'black'
    if True:
        # Work around #804. w is a QLineEdit.
        w.setStyleSheet(f"background: {bg}; color: {fg};")
    else:
        # Rather than put(msg, explicit_color, explicit_color) we should use
        # put(msg, status) where status is None, 'info', or 'fail'.
        # Just as a quick hack to avoid dealing with propagating those changes
        # back upstream, infer status like this:
        if (
            fg == c.config.getColor('find-found-fg') and
            bg == c.config.getColor('find-found-bg')
        ):
            status = 'info'
        elif (
            fg == c.config.getColor('find-not-found-fg') and
            bg == c.config.getColor('find-not-found-bg')
        ):
            status = 'fail'
        else:
            status = None
        d = self.styleSheetCache
        if status != d.get(w, '__undefined__'):
            d[w] = status
            c.styleSheetManager.mng.remove_sclass(w, ['info', 'fail'])
            c.styleSheetManager.mng.add_sclass(w, status)
            c.styleSheetManager.mng.update_view(w)  # force appearance update
    w.setText(s)
#@+node:chris.20180320072817.1: *8* QtStatusLineClass.update & helpers
def update(self):
    if g.app.killed: return
    c, body = self.c, self.c.frame.body
    if not c.p:
        return
    te = body.widget
    if not isinstance(te, QtWidgets.QTextEdit):
        return
    cursor = te.textCursor()
    block = cursor.block()
    row = block.blockNumber() + 1
    col, fcol = self.compute_columns(block, cursor)
    words = len(c.p.b.split(None))
    self.put_status_line(col, fcol, row, words)
    self.lastRow = row
    self.lastCol = col
    self.lastFcol = fcol
#@+node:ekr.20190118082646.1: *9* qstatus.compute_columns
def compute_columns(self, block, cursor):

    c = self.c
    line = block.text()
    col = cursor.columnNumber()
    offset = c.p.textOffset()
    fcol_offset = 0
    s2 = line[0:col]
    col = g.computeWidth(s2, c.tab_width)
    #
    # #195: fcol when using @first directive is inaccurate
    i = line.find('<<')
    j = line.find('>>')
    if -1 < i < j or g.match_word(line.strip(), 0, '@others'):
        offset = None
    else:
        for tag in ('@first ', '@last '):
            if line.startswith(tag):
                fcol_offset = len(tag)
                break
    #
    # fcol is '' if there is no ancestor @<file> node.
    fcol = None if offset is None else max(0, col + offset - fcol_offset)
    return col, fcol
#@+node:chris.20180320072817.2: *9* qstatus.file_line (not used)
def file_line(self):
    """
    Return the line of the first line of c.p in its external file.
    Return None if c.p is not part of an external file.
    """
    c, p = self.c, self.c.p
    if p:
        goto = gotoCommands.GoToCommands(c)
        return goto.find_node_start(p)
    return None
#@+node:ekr.20190118082047.1: *9* qstatus.put_status_line
def put_status_line(self, col, fcol, row, words):

    if 1:
        fcol_part = '' if fcol is None else f" fcol: {fcol}"
        # For now, it seems to0 difficult to get alignment *exactly* right.
        self.put1(f"line: {row:d} col: {col:d} {fcol_part} words: {words}")
    else:
        # #283 is not ready yet, and probably will never be.
        fline = self.file_line()
        fline = '' if fline is None else fline + row
        self.put1(
            f"fline: {fline:2} line: {row:2d} col: {col:2} fcol: {fcol:2}")
#@+node:ekr.20110605121601.18262: *7* qtFrame.class QtIconBarClass
class QtIconBarClass:
    """A class representing the singleton Icon bar"""
    @others
#@+node:ekr.20110605121601.18263: *8*  ctor & reloadSettings (QtIconBarClass)
def __init__(self, c, parentFrame):
    """Ctor for QtIconBarClass."""
    # Copy ivars
    self.c = c
    self.parentFrame = parentFrame
    # Status ivars.
    self.actions = []
    self.chapterController = None
    self.toolbar = self
    self.w = c.frame.top.iconBar  # A QToolBar.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.buttonColor = c.config.getString('qt-button-color')
    self.toolbar_orientation = c.config.getString('qt-toolbar-location')
#@+node:ekr.20110605121601.18264: *8*  do-nothings (QtIconBarClass)
# These *are* called from Leo's core.

def addRow(self, height=None):
    pass  # To do.

def getNewFrame(self):
    return None  # To do
#@+node:ekr.20110605121601.18265: *8* add (QtIconBarClass)
def add(self, *args, **keys):
    """Add a button to the icon bar."""
    c = self.c
    if not self.w:
        return None
    command = keys.get('command')
    text = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction = keys.get('qaction')
    if not text and not qaction:
        g.es('bad toolbar item')
    kind = keys.get('kind') or 'generic-button'
    # imagefile = keys.get('imagefile')
    # image = keys.get('image')


    class leoIconBarButton(QtWidgets.QWidgetAction):

        def __init__(self, parent, text, toolbar):
            super().__init__(parent)
            self.button = None  # set below
            self.text = text
            self.toolbar = toolbar

        def createWidget(self, parent):
            self.button = b = QtWidgets.QPushButton(self.text, parent)
            self.button.setProperty('button_kind', kind)  # for styling
            return b

    if qaction is None:
        action = leoIconBarButton(parent=self.w, text=text, toolbar=self)
        button_name = text
    else:
        action = qaction
        button_name = action.text()
    self.w.addAction(action)
    self.actions.append(action)
    b = self.w.widgetForAction(action)
    # Set the button's object name so we can use the stylesheet to color it.
    if not button_name: button_name = 'unnamed'
    button_name = button_name + '-button'
    b.setObjectName(button_name)
    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(checked, action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtWidgets.QAction('Remove Button', b)
    b.addAction(rb)
    rb.triggered.connect(delete_callback)
    if command:

        def button_callback(event, c=c, command=command):
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        b.clicked.connect(button_callback)
    return action
#@+node:ekr.20110605121601.18266: *8* addRowIfNeeded
def addRowIfNeeded(self):
    """Add a new icon row if there are too many widgets."""
    # n = g.app.iconWidgetCount
    # if n >= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()
    # g.app.iconWidgetCount += 1
#@+node:ekr.20110605121601.18267: *8* addWidget
def addWidget(self, w):
    self.w.addWidget(w)
#@+node:ekr.20110605121601.18268: *8* clear (QtIconBarClass)
def clear(self):
    """Destroy all the widgets in the icon bar"""
    self.w.clear()
    self.actions = []
    g.app.iconWidgetCount = 0
#@+node:ekr.20110605121601.18269: *8* createChaptersIcon
def createChaptersIcon(self):

    c = self.c
    f = c.frame
    if f.use_chapters and f.use_chapter_tabs:
        return LeoQtTreeTab(c, f.iconBar)
    return None
#@+node:ekr.20110605121601.18270: *8* deleteButton
def deleteButton(self, w):
    """ w is button """
    self.w.removeAction(w)
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@+node:ekr.20141031053508.14: *8* goto_command (QtIconBarClass)
def goto_command(self, controller, gnx):
    """
    Select the node corresponding to the given gnx.
    controller is a ScriptingController instance.
    """
    # Fix bug 74: command_p may be in another outline.
    c = self.c
    c2, p = controller.open_gnx(c, gnx)
    if p:
        assert c2.positionExists(p)
        if c == c2:
            c2.selectPosition(p)
        else:
            g.app.selectLeoWindow(c2)
            # Fix #367: Process events before selecting.
            g.app.gui.qtApp.processEvents()
            c2.selectPosition(p)
    else:
        g.trace('not found', gnx)
#@+node:ekr.20110605121601.18271: *8* setCommandForButton (@rclick nodes) & helper
# qtFrame.QtIconBarClass.setCommandForButton

def setCommandForButton(
    self, button, command, command_p, controller, gnx, script):
    """
    Set the "Goto Script" rlick item of an @button button.
    Called from mod_scripting.py plugin.

    button is a leoIconBarButton.
    command is a callback, defined in mod_scripting.py.
    command_p exists only if the @button node exists in the local .leo file.
    gnx is the gnx of the @button node.
    script is a static script for common @button nodes.
    """
    if not command:
        return
    # Fix bug 74: use the controller and gnx arguments.
    b = button.button
    b.clicked.connect(command)

    def goto_callback(checked, controller=controller, gnx=gnx):
        self.goto_command(controller, gnx)

    b.goto_script = gts = QtWidgets.QAction('Goto Script', b)
    b.addAction(gts)
    gts.triggered.connect(goto_callback)
    rclicks = build_rclick_tree(command_p, top_level=True)
    self.add_rclick_menu(b, rclicks, controller, script=script)
#@+node:ekr.20141031053508.15: *9* add_rclick_menu (QtIconBarClass)
def add_rclick_menu(self, action_container, rclicks, controller,
    top_level=True,
    button=None,
    script=None
):
    c = controller.c
    top_offset = -2  # insert before the remove button and goto script items
    if top_level:
        button = action_container
    for rc in rclicks:
        # pylint: disable=cell-var-from-loop
        headline = rc.position.h[8:].strip()
        act = QtWidgets.QAction(headline, action_container)
        if '---' in headline and headline.strip().strip('-') == '':
            act.setSeparator(True)
        elif rc.position.b.strip():

            def cb(checked, p=rc.position, button=button):
                controller.executeScriptFromButton(
                    b=button,
                    buttonText=p.h[8:].strip(),
                    p=p,
                    script=script,
                )
                if c.exists:
                    c.outerUpdate()

            act.triggered.connect(cb)
        else:  # recurse submenu
            sub_menu = QtWidgets.QMenu(action_container)
            act.setMenu(sub_menu)
            self.add_rclick_menu(sub_menu, rc.children, controller,
                top_level=False, button=button)
        if top_level:
            # insert act before Remove Button
            action_container.insertAction(
                action_container.actions()[top_offset], act)
        else:
            action_container.addAction(act)
    if top_level and rclicks:
        act = QtWidgets.QAction('---', action_container)
        act.setSeparator(True)
        action_container.insertAction(
            action_container.actions()[top_offset], act)
        action_container.setText(
            action_container.text() +
            (c.config.getString('mod-scripting-subtext') or '')
        )
#@+node:ekr.20110605121601.18274: *7* qtFrame.Configuration
#@+node:ekr.20110605121601.18275: *8* qtFrame.configureBar
def configureBar(self, bar, verticalFlag):
    c = self.c
    # Get configuration settings.
    w = c.config.getInt("split-bar-width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief", "relief")
    if not relief: relief = "flat"
    color = c.config.getColor("split-bar-color")
    if not color: color = "LightSteelBlue2"
    try:
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(
                relief=relief, height=w, bg=color, cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(
                relief=relief, width=w, bg=color, cursor="sb_h_double_arrow")
    except Exception:
        # Could be a user error. Use all defaults
        g.es("exception in user configuration for splitbar")
        g.es_exception()
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(height=7, cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(width=7, cursor="sb_h_double_arrow")
#@+node:ekr.20110605121601.18276: *8* qtFrame.configureBarsFromConfig
def configureBarsFromConfig(self):
    c = self.c
    w = c.config.getInt("split-bar-width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief", "relief")
    if not relief or relief == "": relief = "flat"
    color = c.config.getColor("split-bar-color")
    if not color or color == "": color = "LightSteelBlue2"
    if self.splitVerticalFlag:
        bar1, bar2 = self.bar1, self.bar2
    else:
        bar1, bar2 = self.bar2, self.bar1
    try:
        bar1.configure(relief=relief, height=w, bg=color)
        bar2.configure(relief=relief, width=w, bg=color)
    except Exception:
        # Could be a user error.
        g.es("exception in user configuration for splitbar")
        g.es_exception()
#@+node:ekr.20110605121601.18277: *8* qtFrame.reconfigureFromConfig
def reconfigureFromConfig(self):
    """Init the configuration of the Qt frame from settings."""
    c, frame = self.c, self
    frame.configureBarsFromConfig()
    frame.setTabWidth(c.tab_width)
    c.redraw()
#@+node:ekr.20110605121601.18278: *8* qtFrame.setInitialWindowGeometry
def setInitialWindowGeometry(self):
    """Set the position and size of the frame to config params."""
    c = self.c
    h = c.config.getInt("initial-window-height") or 500
    w = c.config.getInt("initial-window-width") or 600
    x = c.config.getInt("initial-window-left") or 50  # #1190: was 10
    y = c.config.getInt("initial-window-top") or 50  # #1190: was 10
    if h and w and x and y:
        if 'size' in g.app.debug:
            g.trace(w, h, x, y)
        self.setTopGeometry(w, h, x, y)
#@+node:ekr.20110605121601.18279: *8* qtFrame.setTabWidth
def setTabWidth(self, w):
    # A do-nothing because tab width is set automatically.
    # It *is* called from Leo's core.
    pass
#@+node:ekr.20110605121601.18280: *8* qtFrame.setWrap
def setWrap(self, p=None, force=False):
    return self.c.frame.body.setWrap(p, force)
#@+node:ekr.20110605121601.18281: *8* qtFrame.reconfigurePanes
def reconfigurePanes(self):
    c, f = self.c, self
    if f.splitVerticalFlag:
        r = c.config.getRatio("initial-vertical-ratio")
        if r is None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial-vertical-secondary-ratio")
        if r2 is None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial-horizontal-ratio")
        if r is None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial-horizontal-secondary-ratio")
        if r2 is None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    f.resizePanesToRatio(r, r2)
#@+node:ekr.20110605121601.18282: *8* qtFrame.resizePanesToRatio
def resizePanesToRatio(self, ratio, ratio2):
    """Resize splitter1 and splitter2 using the given ratios."""
    # pylint: disable=arguments-differ
    self.divideLeoSplitter1(ratio)
    self.divideLeoSplitter2(ratio2)
#@+node:ekr.20110605121601.18283: *8* qtFrame.divideLeoSplitter1/2
def divideLeoSplitter1(self, frac):
    """Divide the main splitter."""
    layout = self.c and self.c.free_layout
    if not layout:
        return
    w = layout.get_main_splitter()
    if w:
        self.divideAnySplitter(frac, w)

def divideLeoSplitter2(self, frac):
    """Divide the secondary splitter."""
    layout = self.c and self.c.free_layout
    if not layout:
        return
    w = layout.get_secondary_splitter()
    if w:
        self.divideAnySplitter(frac, w)
#@+node:ekr.20110605121601.18284: *8* qtFrame.divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter(self, frac, splitter):
    """Set the splitter sizes."""
    sizes = splitter.sizes()
    if len(sizes) != 2:
        g.trace(f"{len(sizes)} widget(s) in {id(splitter)}")
        return
    if frac > 1 or frac < 0:
        g.trace(f"split ratio [{frac}] out of range 0 <= frac <= 1")
        return
    s1, s2 = sizes
    s = s1 + s2
    s1 = int(s * frac + 0.5)
    s2 = s - s1
    splitter.setSizes([s1, s2])
#@+node:ekr.20110605121601.18285: *7* qtFrame.Event handlers
#@+node:ekr.20110605121601.18286: *8* qtFrame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    f = self; c = f.c
    if c.inCommand:
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@+node:ekr.20110605121601.18287: *8* qtFrame.OnControlKeyUp/Down
def OnControlKeyDown(self, event=None):
    self.controlKeyIsDown = True

def OnControlKeyUp(self, event=None):
    self.controlKeyIsDown = False
#@+node:ekr.20110605121601.18290: *8* qtFrame.OnActivateTree
def OnActivateTree(self, event=None):
    pass
#@+node:ekr.20110605121601.18291: *8* qtFrame.OnBodyClick, OnBodyRClick (not used)
# At present, these are not called,
# but they could be called by LeoQTextBrowser.

def OnBodyClick(self, event=None):
    g.trace()
    try:
        c = self.c; p = c.currentPosition()
        if g.doHook("bodyclick1", c=c, p=p, event=event):
            g.doHook("bodyclick2", c=c, p=p, event=event)
            return
        c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodyclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self, event=None):
    try:
        c = self.c; p = c.currentPosition()
        if g.doHook("bodyrclick1", c=c, p=p, event=event):
            g.doHook("bodyrclick2", c=c, p=p, event=event)
            return
        c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodyrclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("iconrclick")
#@+node:ekr.20110605121601.18292: *8* qtFrame.OnBodyDoubleClick (Events) (not used)
# Not called

def OnBodyDoubleClick(self, event=None):
    try:
        c = self.c; p = c.currentPosition()
        if event and not g.doHook("bodydclick1", c=c, p=p, event=event):
            c.editCommands.extendToWord(event)  # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodydclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("bodydclick")
    return "break"  # Restore this to handle proper double-click logic.
#@+node:ekr.20110605121601.18293: *7* qtFrame.Gui-dependent commands
#@+node:ekr.20110605121601.18301: *8* qtFrame.Window Menu...
#@+node:ekr.20110605121601.18302: *9* qtFrame.toggleActivePane
@cmd('toggle-active-pane')
def toggleActivePane(self, event=None):
    """Toggle the focus between the outline and body panes."""
    frame = self; c = frame.c
    w = c.get_focus()
    w_name = g.app.gui.widget_name(w)
    if w_name in ('canvas', 'tree', 'treeWidget'):
        c.endEditing()
        c.bodyWantsFocus()
    else:
        c.treeWantsFocus()
#@+node:ekr.20110605121601.18303: *9* qtFrame.cascade
@cmd('cascade-windows')
def cascade(self, event=None):
    """Cascade all Leo windows."""
    x, y, delta = 50, 50, 50
    for frame in g.app.windowList:
        w = frame and frame.top
        if w:
            r = w.geometry()  # a Qt.Rect
            # 2011/10/26: Fix bug 823601: cascade-windows fails.
            w.setGeometry(QtCore.QRect(x, y, r.width(), r.height()))
            # Compute the new offsets.
            x += 30; y += 30
            if x > 200:
                x = 10 + delta; y = 40 + delta
                delta += 10
#@+node:ekr.20110605121601.18304: *9* qtFrame.equalSizedPanes
@cmd('equal-sized-panes')
def equalSizedPanes(self, event=None):
    """Make the outline and body panes have the same size."""
    self.resizePanesToRatio(0.5, self.secondary_ratio)
#@+node:ekr.20110605121601.18305: *9* qtFrame.hideLogWindow
def hideLogWindow(self, event=None):
    """Hide the log pane."""
    self.divideLeoSplitter2(0.99)
#@+node:ekr.20110605121601.18306: *9* qtFrame.minimizeAll
@cmd('minimize-all')
def minimizeAll(self, event=None):
    """Minimize all Leo's windows."""
    for frame in g.app.windowList:
        self.minimize(frame)

def minimize(self, frame):
    # This unit test will fail when run externally.
    if frame and frame.top:
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['minimize-all'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMinimized)
#@+node:ekr.20110605121601.18307: *9* qtFrame.toggleSplitDirection
@cmd('toggle-split-direction')
def toggleSplitDirection(self, event=None):
    """Toggle the split direction in the present Leo window."""
    if hasattr(self.c, 'free_layout'):
        self.c.free_layout.get_top_splitter().rotate()
#@+node:ekr.20110605121601.18308: *9* qtFrame.resizeToScreen
@cmd('resize-to-screen')
def resizeToScreen(self, event=None):
    """Resize the Leo window so it fill the entire screen."""
    frame = self
    # This unit test will fail when run externally.
    if frame and frame.top:
        # frame.top.leo_master is a LeoTabbedTopLevel.
        # frame.top is a DynamicWindow.
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['resize-to-screen'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMaximized)
#@+node:ekr.20110605121601.18309: *8* qtFrame.Help Menu...
#@+node:ekr.20110605121601.18310: *9* qtFrame.leoHelp
@cmd('open-offline-tutorial')
def leoHelp(self, event=None):
    """Open Leo's offline tutorial."""
    frame = self; c = frame.c
    theFile = g.os_path_join(g.app.loadDir, "..", "doc", "sbooks.chm")
    if g.os_path_exists(theFile) and sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")
        if answer == "yes":
            try:
                url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                import webbrowser
                os.chdir(g.app.loadDir)
                webbrowser.open_new(url)
            except Exception:
                if 0:
                    g.es("exception downloading", "sbooks.chm")
                    g.es_exception()
#@+node:ekr.20160424080647.1: *7* qtFrame.Properties
# The ratio and secondary_ratio properties are read-only.
#@+node:ekr.20160424080815.2: *8* qtFrame.ratio property
def __get_ratio(self):
    """Return splitter ratio of the main splitter."""
    c = self.c
    free_layout = c.free_layout
    if free_layout:
        w = free_layout.get_main_splitter()
        if w:
            aList = w.sizes()
            if len(aList) == 2:
                n1, n2 = aList
                # 2017/06/07: guard against division by zero.
                ratio = 0.5 if n1 + n2 == 0 else float(n1) / float(n1 + n2)
                return ratio
    return 0.5

ratio = property(
    __get_ratio,  # No setter.
    doc="qtFrame.ratio property")
#@+node:ekr.20160424080815.3: *8* qtFrame.secondary_ratio property
def __get_secondary_ratio(self):
    """Return the splitter ratio of the secondary splitter."""
    c = self.c
    free_layout = c.free_layout
    if free_layout:
        w = free_layout.get_secondary_splitter()
        if w:
            aList = w.sizes()
            if len(aList) == 2:
                n1, n2 = aList
                ratio = float(n1) / float(n1 + n2)
                return ratio
    return 0.5

secondary_ratio = property(
    __get_secondary_ratio,  # no setter.
    doc="qtFrame.secondary_ratio property")
#@+node:ekr.20110605121601.18311: *7* qtFrame.Qt bindings...
#@+node:ekr.20190611053431.1: *8* qtFrame.bringToFront
def bringToFront(self):
    if 'size' in g.app.debug:
        g.trace()
    self.lift()
#@+node:ekr.20190611053431.2: *8* qtFrame.deiconify
def deiconify(self):
    """Undo --minimized"""
    if 'size' in g.app.debug:
        g.trace(
            'top:', bool(self.top),
            'isMinimized:', self.top and self.top.isMinimized())
    if self.top and self.top.isMinimized():  # Bug fix: 400739.
        self.lift()
#@+node:ekr.20190611053431.4: *8* qtFrame.get_window_info
def get_window_info(self):
    """Return the geometry of the top window."""
    if getattr(self.top, 'leo_master', None):
        f = self.top.leo_master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x, y = topLeft.x(), topLeft.y()
    w, h = rect.width(), rect.height()
    if 'size' in g.app.debug:
        g.trace('\n', w, h, x, y)
    return w, h, x, y
#@+node:ekr.20190611053431.3: *8* qtFrame.getFocus
def getFocus(self):
    return g.app.gui.get_focus(self.c)  # Bug fix: 2009/6/30.
#@+node:ekr.20190611053431.7: *8* qtFrame.getTitle
def getTitle(self):
    # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
    # For qt, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
    w = self.top.leo_master if g.app.qt_use_tabs else self.top
    return w.windowTitle()
#@+node:ekr.20190611053431.5: *8* qtFrame.iconify
def iconify(self):
    if 'size' in g.app.debug:
        g.trace(bool(self.top))
    if self.top: self.top.showMinimized()
#@+node:ekr.20190611053431.6: *8* qtFrame.lift
def lift(self):
    if 'size' in g.app.debug:
        g.trace(bool(self.top), self.top and self.top.isMinimized())
    if not self.top:
        return
    if self.top.isMinimized():  # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
#@+node:ekr.20190611053431.8: *8* qtFrame.setTitle
def setTitle(self, s):
    # pylint: disable=arguments-differ
    if self.top:
        # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
        # When using tabs, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
        w = self.top.leo_master if g.app.qt_use_tabs else self.top
        w.setWindowTitle(s)
#@+node:ekr.20190611053431.9: *8* qtFrame.setTopGeometry
def setTopGeometry(self, w, h, x, y):
    # self.top is a DynamicWindow.
    if 'size' in g.app.debug:
        g.trace(bool(self.top), w, h, x, y)
    if self.top:
        self.top.setGeometry(QtCore.QRect(x, y, w, h))
#@+node:ekr.20190611053431.10: *8* qtFrame.update
def update(self, *args, **keys):
    if 'size' in g.app.debug:
        g.trace(bool(self.top))
    self.top.update()
#@+node:ekr.20110605121601.18312: *6* class LeoQtLog (LeoLog)
class LeoQtLog(leoFrame.LeoLog):
    """A class that represents the log pane of a Qt window."""
    @others
#@+node:ekr.20150717102609.1: *7* LeoQtLog.cmd (decorator)
def cmd(name):
    """Command decorator for the c.frame.log class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'log'])
#@+node:ekr.20110605121601.18313: *7* LeoQtLog.Birth
#@+node:ekr.20110605121601.18314: *8* LeoQtLog.__init__ & reloadSettings
def __init__(self, frame, parentFrame):
    """Ctor for LeoQtLog class."""
    super().__init__(frame, parentFrame)
        # Calls createControl.
    assert self.logCtrl is None, self.logCtrl  # Set in finishCreate.
        # Important: depeding on the log *tab*,
        # logCtrl may be either a wrapper or a widget.
    self.c = c = frame.c
        # Also set in the base constructor, but we need it here.
    self.contentsDict = {}
        # Keys are tab names.  Values are widgets.
    self.eventFilters = []
        # Apparently needed to make filters work!
    self.logDict = {}
        # Keys are tab names text widgets.  Values are the widgets.
    self.logWidget = None
        # Set in finishCreate.
    self.menu = None
        # A menu that pops up on right clicks in the hull or in tabs.
    self.tabWidget = tw = c.frame.top.tabWidget
        # The Qt.QTabWidget that holds all the tabs.
    #
    # Bug 917814: Switching Log Pane tabs is done incompletely.
    tw.currentChanged.connect(self.onCurrentChanged)
    if 0:  # Not needed to make onActivateEvent work.
        # Works only for .tabWidget, *not* the individual tabs!
        theFilter = qt_events.LeoQtEventFilter(c, w=tw, tag='tabWidget')
        tw.installEventFilter(theFilter)
    #
    # 2013/11/15: Partial fix for bug 1251755: Log-pane refinements
    tw.setMovable(True)
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.wrap = bool(c.config.getBool('log-pane-wraps'))
#@+node:ekr.20110605121601.18315: *8* LeoQtLog.finishCreate
def finishCreate(self):
    """Finish creating the LeoQtLog class."""
    c, log, w = self.c, self, self.tabWidget
    #
    # Create the log tab as the leftmost tab.
    log.createTab('Log')
    self.logWidget = logWidget = self.contentsDict.get('Log')
    option = QtGui.QTextOption
    logWidget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
    w.insertTab(0, logWidget, 'Log')
        # Required.
    #
    # set up links in log handling
    logWidget.setTextInteractionFlags(
        QtCore.Qt.LinksAccessibleByMouse |
        QtCore.Qt.TextEditable |
        QtCore.Qt.TextSelectableByMouse
    )
    logWidget.setOpenLinks(False)
    logWidget.setOpenExternalLinks(False)
    logWidget.anchorClicked.connect(self.linkClicked)
    #
    # Show the spell tab.
    c.spellCommands.openSpellTab()
    #
    #794: Clicking Find Tab should do exactly what pushing Ctrl-F does

    def tab_callback(index):
        name = w.tabText(index)
        if name == 'Find':
            c.findCommands.startSearch(event=None)

    w.currentChanged.connect(tab_callback)
    # #1286.
    w.customContextMenuRequested.connect(self.onContextMenu)
#@+node:ekr.20110605121601.18316: *8* LeoQtLog.getName
def getName(self):
    return 'log'  # Required for proper pane bindings.
#@+node:ekr.20150717102728.1: *7* LeoQtLog.Commands
@cmd('clear-log')
def clearLog(self, event=None):
    """Clear the log pane."""
    w = self.logCtrl.widget  # w is a QTextBrowser
    if w:
        w.clear()
#@+node:ekr.20110605121601.18333: *7* LeoQtLog.color tab stuff
def createColorPicker(self, tabName):
    g.warning('color picker not ready for qt')
#@+node:ekr.20110605121601.18334: *7* LeoQtLog.font tab stuff
#@+node:ekr.20110605121601.18335: *8* LeoQtLog.createFontPicker
def createFontPicker(self, tabName):
    # log = self
    QFont = QtGui.QFont
    font, ok = QtWidgets.QFontDialog.getFont()
    if not (font and ok): return
    style = font.style()
    table = (
        (QFont.StyleNormal, 'normal'),
        (QFont.StyleItalic, 'italic'),
        (QFont.StyleOblique, 'oblique'))
    for val, name in table:
        if style == val:
            style = name
            break
    else:
        style = ''
    weight = font.weight()
    table = (
        (QFont.Light, 'light'),
        (QFont.Normal, 'normal'),
        (QFont.DemiBold, 'demibold'),
        (QFont.Bold, 'bold'),
        (QFont.Black, 'black'))
    for val, name in table:
        if weight == val:
            weight = name
            break
    else:
        weight = ''
    table = (
        ('family', str(font.family())),
        ('size  ', font.pointSize()),
        ('style ', style),
        ('weight', weight),
    )
    for key, val in table:
        if val: g.es(key, val, tabName='Fonts')
#@+node:ekr.20110605121601.18339: *8* LeoQtLog.hideFontTab
def hideFontTab(self, event=None):
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@+node:ekr.20111120124732.10184: *7* LeoQtLog.isLogWidget
def isLogWidget(self, w):
    val = w == self or w in list(self.contentsDict.values())
    return val
#@+node:tbnorth.20171220123648.1: *7* LeoQtLog.linkClicked
def linkClicked(self, link):
    """linkClicked - link clicked in log

    :param QUrl link: link that was clicked
    """
    # see addition of '/' in LeoQtLog.put()
    url = s = g.toUnicode(link.toString())
    if platform.system() == 'Windows':
        for scheme in 'file', 'unl':
            if s.startswith(scheme + ':///') and s[len(scheme) + 5] == ':':
                url = s.replace(':///', '://', 1)
                break
    g.handleUrl(url, c=self.c)
#@+node:ekr.20120304214900.9940: *7* LeoQtLog.onCurrentChanged
def onCurrentChanged(self, idx):

    tabw = self.tabWidget
    w = tabw.widget(idx)
    #
    # #917814: Switching Log Pane tabs is done incompletely
    wrapper = getattr(w, 'leo_log_wrapper', None)
    #
    # #1161: Don't change logs unless the wrapper is correct.
    if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
        self.logCtrl = wrapper
#@+node:ekr.20200304132424.1: *7* LeoQtLog.onContextMenu
def onContextMenu(self, point):
    """LeoQtLog: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.c, self
    g.app.gui.onContextMenu(c, w, point)
#@+node:ekr.20110605121601.18321: *7* LeoQtLog.put & putnl
#@+node:ekr.20110605121601.18322: *8* LeoQtLog.put
def put(self, s, color=None, tabName='Log', from_redirect=False, nodeLink=None):
    """
    Put s to the Qt Log widget, converting to html.
    All output to the log stream eventually comes here.

    The from_redirect keyword argument is no longer used.
    """
    c = self.c
    if g.app.quitting or not c or not c.exists:
        return
    # Note: g.actualColor does all color translation.
    if color:
        color = leoColor.getColor(color)
    if not color:
        # #788: First, fall back to 'log_black_color', not 'black.
        color = c.config.getColor('log-black-color')
        if not color:
            # Should never be necessary.
            color = 'black'
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    wrapper = self.logCtrl
    if not isinstance(wrapper, qt_text.QTextEditWrapper):
        g.trace('BAD wrapper', wrapper.__class__.__name__)
        return
    w = wrapper.widget
    if not isinstance(w, QtWidgets.QTextEdit):
        g.trace('BAD widget', w.__class__.__name__)
        return
    sb = w.horizontalScrollBar()
    s = s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    # #884: Always convert leading blanks and tabs to &nbsp.
    n = len(s) - len(s.lstrip())
    if n > 0 and s.strip():
        s = '&nbsp;' * (n) + s[n:]
    if not self.wrap:
        # Convert all other blanks to &nbsp;
        s = s.replace(' ', '&nbsp;')
    s = s.replace('\n', '<br>')
        # The caller is responsible for newlines!
    s = f'<font color="{color}">{s}</font>'
    if nodeLink:
        url = nodeLink
        for scheme in 'file', 'unl':
            # QUrl requires paths start with '/'
            if url.startswith(
                scheme + '://') and not url.startswith(scheme + ':///'):
                url = url.replace('://', ':///', 1)
        s = f'<a href="{url}" title="{nodeLink}">{s}</a>'
    w.insertHtml(s)
    w.moveCursor(QtGui.QTextCursor.End)
    sb.setSliderPosition(0)  # Force the slider to the initial position.
    w.repaint()  # Slow, but essential.
#@+node:ekr.20110605121601.18323: *8* LeoQtLog.putnl
def putnl(self, tabName='Log'):
    """Put a newline to the Qt log."""
    #
    # This is not called normally.
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    wrapper = self.logCtrl
    if not isinstance(wrapper, qt_text.QTextEditWrapper):
        g.trace('BAD wrapper', wrapper.__class__.__name__)
        return
    w = wrapper.widget
    if not isinstance(w, QtWidgets.QTextEdit):
        g.trace('BAD widget', w.__class__.__name__)
        return
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    # Not needed!
        # contents = w.toHtml()
        # w.setHtml(contents + '\n')
    w.moveCursor(QtGui.QTextCursor.End)
    sb.setSliderPosition(pos)
    w.repaint()  # Slow, but essential.
#@+node:ekr.20150205181818.5: *8* LeoQtLog.scrollToEnd
def scrollToEnd(self, tabName='Log'):
    """Scroll the log to the end."""
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    w = self.logCtrl.widget
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint()  # Slow, but essential.
#@+node:ekr.20120913110135.10613: *7* LeoQtLog.putImage
#@+node:ekr.20110605121601.18324: *7* LeoQtLog.Tab
#@+node:ekr.20110605121601.18325: *8* LeoQtLog.clearTab
def clearTab(self, tabName, wrap='none'):
    w = self.logDict.get(tabName)
    if w:
        w.clear()  # w is a QTextBrowser.
#@+node:ekr.20110605121601.18326: *8* LeoQtLog.createTab
def createTab(self, tabName, createText=True, widget=None, wrap='none'):
    """
    Create a new tab in tab widget
    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c
    if widget is None:
        widget = qt_text.LeoQTextBrowser(parent=None, c=c, wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = qt_text.QTextEditWrapper(widget=widget, name='log', c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
        option = QtGui.QTextOption
        widget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
        widget.setReadOnly(False)  # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
        # Set binding on all log pane widgets.
        g.app.gui.setFilter(c, widget, self, tag='log')
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget, tabName)
    else:
        # #1161: Don't set the wrapper unless it has the correct type.
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        if isinstance(contents, qt_text.QTextEditWrapper):
            widget.leo_log_wrapper = widget
                # The leo_log_wrapper is the widget itself.
        else:
            widget.leo_log_wrapper = None
                # Tell the truth.
        g.app.gui.setFilter(c, widget, contents, 'tabWidget')
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents, tabName)
    return contents
#@+node:ekr.20110605121601.18328: *8* LeoQtLog.deleteTab
def deleteTab(self, tabName, force=False):
    """
    Delete the tab if it exists.  Otherwise do *nothing*.
    
    The spell code sets force=True if there is no spell dict.
    """
    c = self.c
    w = self.tabWidget
    if force and tabName != 'Spell':
        g.trace('can not force delete tab:', tabName)
        return
    i = self.findTabIndex(tabName)
    if i is None:
        return
    w.removeTab(i)
    self.selectTab('Log')
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20190603062456.1: *8* LeoQtLog.findTabIndex
def findTabIndex(self, tabName):
    """Return the tab index for tabName, or None."""
    w = self.tabWidget
    for i in range(w.count()):
        if tabName == w.tabText(i):
            return i
    return None
#@+node:ekr.20110605121601.18329: *8* LeoQtLog.hideTab
def hideTab(self, tabName):
    self.selectTab('Log')
#@+node:ekr.20111122080923.10185: *8* LeoQtLog.orderedTabNames
def orderedTabNames(self, LeoLog=None):  # Unused: LeoLog
    """Return a list of tab names in the order in which they appear in the QTabbedWidget."""
    w = self.tabWidget
    return [w.tabText(i) for i in range(w.count())]
#@+node:ekr.20110605121601.18330: *8* LeoQtLog.numberOfVisibleTabs
def numberOfVisibleTabs(self):
    return len([val for val in self.contentsDict.values() if val is not None])
        # **Note**: the base-class version of this uses frameDict.
#@+node:ekr.20110605121601.18331: *8* LeoQtLog.selectTab & helpers
def selectTab(self, tabName, createText=True, widget=None, wrap='none'):
    """Create the tab if necessary and make it active."""
    i = self.findTabIndex(tabName)
    if i is None:
        self.createTab(tabName, widget=widget, wrap=wrap)
        self.finishCreateTab(tabName)
    self.finishSelectTab(tabName)
#@+node:ekr.20190603064815.1: *9* LeoQtLog.finishCreateTab
def finishCreateTab(self, tabName):
    """Finish creating the given tab. Do not set focus!"""
    c = self.c
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('Can not happen', tabName)
        self.tabName = None
        return
    # # #1161.
    if tabName == 'Log':
        wrapper = None
        widget = self.contentsDict.get('Log')
            # a qt_text.QTextEditWrapper
        if widget:
            wrapper = getattr(widget, 'leo_log_wrapper', None)
            if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
                self.logCtrl = wrapper
        if not wrapper: g.trace('NO LOG WRAPPER')
    if tabName == 'Find':
        # Do *not* set focus here!
        # #1254861: Ctrl-f doesn't ensure find input field visible.
        if c.config.getBool('auto-scroll-find-tab', default=True):
            # This is the cause of unwanted scrolling.
            findbox = c.findCommands.ftm.find_findbox
            if hasattr(widget, 'ensureWidgetVisible'):
                widget.ensureWidgetVisible(findbox)
            else:
                findbox.setFocus()
    if tabName == 'Spell':
        # Set a flag for the spell system.
        widget = self.tabWidget.widget(i)
        self.frameDict['Spell'] = widget
#@+node:ekr.20190603064816.1: *9* LeoQtLog.finishSelectTab
def finishSelectTab(self, tabName):
    """Select the proper tab."""
    w = self.tabWidget
    # Special case for Spell tab.
    if tabName == 'Spell':
        return
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('can not happen', tabName)
        self.tabName = None
        return
    w.setCurrentIndex(i)
    self.tabName = tabName
#@+node:ekr.20110605121601.18340: *6* class LeoQtMenu (LeoMenu)
class LeoQtMenu(leoMenu.LeoMenu):

    @others
#@+node:ekr.20110605121601.18341: *7* LeoQtMenu.__init__
def __init__(self, c, frame, label):
    """ctor for LeoQtMenu class."""
    assert frame
    assert frame.c
    super().__init__(frame)
    self.leo_menu_label = label.replace('&', '').lower()
    self.frame = frame
    self.c = c
    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar is not None
    # Inject this dict into the commander.
    if not hasattr(c, 'menuAccels'):
        setattr(c, 'menuAccels', {})
    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant', 'menu_text_font_weight',
            c.config.defaultMenuFontSize)
#@+node:ekr.20120306130648.9848: *7* LeoQtMenu.__repr__
def __repr__(self):
    return f"<LeoQtMenu: {self.leo_menu_label}>"

__str__ = __repr__
#@+node:ekr.20110605121601.18342: *7* LeoQtMenu.Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20110605121601.18343: *8* LeoQtMenu.Methods with Tk spellings
#@+node:ekr.20110605121601.18344: *9* LeoQtMenu.add_cascade
def add_cascade(self, parent, label, menu, underline):
    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""
    # menu and parent are a QtMenuWrappers, subclasses of  QMenu.
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    menu.setTitle(label)
    if parent:
        parent.addMenu(menu)  # QMenu.addMenu.
    else:
        self.menuBar.addMenu(menu)
    label = label.replace('&', '').lower()
    menu.leo_menu_label = label
    return menu
#@+node:ekr.20110605121601.18345: *9* LeoQtMenu.add_command (Called by createMenuEntries)
def add_command(self, **keys):
    """Wrapper for the Tkinter add_command menu method."""
    # pylint: disable=arguments-differ
    accel = keys.get('accelerator') or ''
    command = keys.get('command') or ''
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    if n is None: n = -1
    menu = keys.get('menu') or self
    if not label:
        return
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = f"{label}\t{accel}"
    action = menu.addAction(label)
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName
    if command:

        def qt_add_command_callback(checked, label=label, command=command):
            return command()

        action.triggered.connect(qt_add_command_callback)
#@+node:ekr.20110605121601.18346: *9* LeoQtMenu.add_separator
def add_separator(self, menu):
    """Wrapper for the Tkinter add_separator menu method."""
    if menu:
        action = menu.addSeparator()
        action.leo_menu_label = '*seperator*'
#@+node:ekr.20110605121601.18347: *9* LeoQtMenu.delete
def delete(self, menu, realItemName='<no name>'):
    """Wrapper for the Tkinter delete menu method."""
    # if menu:
        # return menu.delete(realItemName)
#@+node:ekr.20110605121601.18348: *9* LeoQtMenu.delete_range
def delete_range(self, menu, n1, n2):
    """Wrapper for the Tkinter delete menu method."""
    # Menu is a subclass of QMenu and LeoQtMenu.
    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@+node:ekr.20110605121601.18349: *9* LeoQtMenu.destroy
def destroy(self, menu):
    """Wrapper for the Tkinter destroy menu method."""
    # Fixed bug https://bugs.launchpad.net/leo-editor/+bug/1193870
    if menu:
        menu.menuBar.removeAction(menu.menuAction())
#@+node:ekr.20110605121601.18350: *9* LeoQtMenu.index
def index(self, label):
    """Return the index of the menu with the given label."""
    return 0
#@+node:ekr.20110605121601.18351: *9* LeoQtMenu.insert
def insert(self, menuName, position, label, command, underline=None):

    menu = self.getMenu(menuName)
    if menu and label:
        n = underline or 0
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:

            def insert_callback(checked, label=label, command=command):
                command()

            action.triggered.connect(insert_callback)
#@+node:ekr.20110605121601.18352: *9* LeoQtMenu.insert_cascade
def insert_cascade(self, parent, index, label, menu, underline):
    """Wrapper for the Tkinter insert_cascade menu method."""
    menu.setTitle(label)
    label.replace('&', '').lower()
    menu.leo_menu_label = label  # was leo_label
    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)
    action = menu.menuAction()
    if action:
        action.leo_menu_label = label
    else:
        g.trace('no action for menu', label)
    return menu
#@+node:ekr.20110605121601.18353: *9* LeoQtMenu.new_menu
def new_menu(self, parent, tearoff=False, label=''):  # label is for debugging.
    """Wrapper for the Tkinter new_menu menu method."""
    c, leoFrame = self.c, self.frame
    # Parent can be None, in which case it will be added to the menuBar.
    menu = QtMenuWrapper(c, leoFrame, parent, label)
    return menu
#@+node:ekr.20110605121601.18354: *8* LeoQtMenu.Methods with other spellings
#@+node:ekr.20110605121601.18355: *9* LeoQtMenu.clearAccel
def clearAccel(self, menu, name):
    pass
    # if not menu:
        # return
    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")
    # menu.entryconfig(realName,accelerator='')
#@+node:ekr.20110605121601.18356: *9* LeoQtMenu.createMenuBar
def createMenuBar(self, frame):
    """
    (LeoQtMenu) Create all top-level menus.
    The menuBar itself has already been created.
    """
    self.createMenusFromTables()
        # This is LeoMenu.createMenusFromTables.
#@+node:ekr.20110605121601.18357: *9* LeoQtMenu.createOpenWithMenu
def createOpenWithMenu(self, parent, label, index, amp_index):
    """
    Create the File:Open With submenu.

    This is called from LeoMenu.createOpenWithMenuFromTable.
    """
    # Use the existing Open With menu if possible.
    menu = self.getMenu('openwith')
    if not menu:
        menu = self.new_menu(parent, tearoff=False, label=label)
        menu.insert_cascade(parent, index, label, menu, underline=amp_index)
    return menu
#@+node:ekr.20110605121601.18358: *9* LeoQtMenu.disable/enableMenu (not used)
def disableMenu(self, menu, name):
    self.enableMenu(menu, name, False)

def enableMenu(self, menu, name, val):
    """Enable or disable the item in the menu with the given name."""
    if menu and name:
        val = bool(val)
        for action in menu.actions():
            s = g.checkUnicode(action.text()).replace('&', '')
            if s.startswith(name):
                action.setEnabled(val)
                break
#@+node:ekr.20110605121601.18359: *9* LeoQtMenu.getMenuLabel
def getMenuLabel(self, menu, name):
    """Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item."""
    # At present, it is valid to always return None.
#@+node:ekr.20110605121601.18360: *9* LeoQtMenu.setMenuLabel
def setMenuLabel(self, menu, name, label, underline=-1):

    def munge(s):
        return (s or '').replace('&', '')

    # menu is a QtMenuWrapper.

    if not menu: return
    realName = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@+node:ekr.20110605121601.18361: *7* LeoQtMenu.activateMenu & helper
def activateMenu(self, menuName):
    """Activate the menu with the given name"""
    menu = self.getMenu(menuName)
        # Menu is a QtMenuWrapper, a subclass of both QMenu and LeoQtMenu.
    if menu:
        self.activateAllParentMenus(menu)
    else:
        g.trace(f"No such menu: {menuName}")
#@+node:ekr.20120922041923.10607: *8* LeoQtMenu.activateAllParentMenus
def activateAllParentMenus(self, menu):
    """menu is a QtMenuWrapper.  Activate it and all parent menus."""
    parent = menu.parent()
    action = menu.menuAction()
    if action:
        if parent and isinstance(parent, QtWidgets.QMenuBar):
            parent.setActiveAction(action)
        elif parent:
            self.activateAllParentMenus(parent)
            parent.setActiveAction(action)
        else:
            g.trace(f"can not happen: no parent for {menu}")
    else:
        g.trace(f"can not happen: no action for {menu}")
#@+node:ekr.20120922041923.10613: *7* LeoQtMenu.deactivateMenuBar
# def deactivateMenuBar (self):
    # """Activate the menu with the given name"""
    # menubar = self.c.frame.top.leo_menubar
    # menubar.setActiveAction(None)
    # menubar.repaint()
#@+node:ekr.20110605121601.18362: *7* LeoQtMenu.getMacHelpMenu
def getMacHelpMenu(self, table):
    return None
#@+node:ekr.20110605121601.18363: *6* class LeoQTreeWidget (QTreeWidget)
class LeoQTreeWidget(QtWidgets.QTreeWidget):
    # To do: Generate @auto or @file nodes when appropriate.

    def __init__(self, c, parent):
        super().__init__(parent)
        self.setAcceptDrops(True)
        enable_drag = c.config.getBool('enable-tree-dragging')
        self.setDragEnabled(bool(enable_drag))
        self.c = c
        self.was_alt_drag = False
        self.was_control_drag = False

    def __repr__(self):
        return f"LeoQTreeWidget: {id(self)}"

    __str__ = __repr__
    # This is called during drags.

    def dragMoveEvent(self, ev):
        pass
    @others
#@+node:ekr.20111022222228.16980: *7* LeoQTreeWidget: Event handlers
#@+node:ekr.20110605121601.18364: *8* LeoQTreeWidget.dragEnterEvent & helper
def dragEnterEvent(self, ev):
    """Export c.p's tree as a Leo mime-data."""
    c = self.c
    if not ev:
        g.trace('no event!')
        return
    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!')
        return
    c.endEditing()
    # Fix bug 135: cross-file drag and drop is broken.
    # This handler may be called several times for the same drag.
    # Only the first should should set g.app.drag_source.
    if g.app.dragging:
        pass
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        self.setText(md)
    # Always accept the drag, even if we are already dragging.
    ev.accept()
#@+node:ekr.20110605121601.18384: *9* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    md.setText(f"{fn},{s}")
#@+node:ekr.20110605121601.18365: *8* LeoQTreeWidget.dropEvent & helpers
def dropEvent(self, ev):
    """Handle a drop event in the QTreeWidget."""
    if not ev:
        return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods & QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods & QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # #59: Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        pass
    else:
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
#@+node:ekr.20110605121601.18366: *9* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    """
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    """
    c = self.c
    fn, s = self.parseText(md)
    if not s or not fn:
        return
    if fn == self.fileName():
        if p and p == c.p:
            pass
        elif g.os_path_exists(fn):
            self.intraFileDrop(fn, c.p, p)
    else:
        self.interFileDrop(fn, p, s)
#@+node:ekr.20110605121601.18367: *10* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    """Paste the mime data after (or as the first child of) p."""
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(s)
        # Paste the node after the presently selected node.
    if not pasted:
        return
    if c.config.getBool('inter-outline-drag-moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged()
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged()
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw(pasted)
    c.recolor()
#@+node:ekr.20110605121601.18368: *10* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    """Move p1 after (or as the first child of) p2."""
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag:
                p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag:
                p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if ok:
        undoData = u.beforeMoveNode(p1)
        p1.setDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            for z in p1.self_and_subtree():
                z.setDirty()
        c.setChanged()
        u.afterMoveNode(p1, 'Drag', undoData)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw(p1)
        else:
            c.redraw(p2)
#@+node:ekr.20110605121601.18383: *10* LeoQTreeWidget.parseText
def parseText(self, md):
    """Parse md.text() into (fn,s)"""
    fn = ''
    s = md.text()
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[:i]
            s = s[i + 1 :]
    return fn, s
#@+node:ekr.20110605121601.18369: *9* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    """Handle a drop when md.urls()."""
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',):  # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
    if changed:
        c.setChanged()
        u.afterChangeGroup(c.p, undoType, reportFlag=False)
        c.redraw()
#@+node:ekr.20110605121601.18370: *10* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    """Read the file given by the url and put it in the outline."""
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb')  # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print(
        f"not found: {fn}", nodeLink=p.get_UNL(with_proto=True, with_count=True))
    return False
#@+node:ekr.20110605121601.18371: *11* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    """
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    """
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False  # Don't set the changed marker in the original file.
    u, undoType = c.undoer, 'Drag File'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
        parent = p
    elif p.h.startswith('@path '):
        # #60: create relative paths & urls when dragging files.
        p2 = p.insertAsNthChild(0)
        p.expand()
        parent = p
    else:
        p2 = p.insertAfter()
        parent = p.parent()
    # #60: create relative paths & urls when dragging files.
    aList = g.get_directives_dict_list(parent)
    path = g.scanAtPathDirectives(c, aList)
    if path:
        fn = os.path.relpath(fn, path)
        fn = g.toUnicodeFileEncoding(fn)
    self.createAtFileNode(fn, p2, s)
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
    return True  # The original .leo file has changed.
#@+node:ekr.20110605121601.18372: *12* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    """
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    """
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
#@+node:ekr.20110605121601.18373: *13* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    """
    Make p an @auto node and create the tree using s, the file's contents.
    """
    c = self.c; at = c.atFileCommands
    p.h = f"@auto {fn}"
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty()  # Don't automatically rewrite this node.
#@+node:ekr.20110605121601.18374: *13* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = f"@edit {fn}"
    p.clearDirty()  # Don't automatically rewrite this node.
#@+node:ekr.20110605121601.18375: *13* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    """Make p an @file node and create the tree using
    s, the file's contents.
    """
    c = self.c; at = c.atFileCommands
    p.h = f"@file {fn}"
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True)  # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = ''  # Safe: will not cause a write later.
        p.clearDirty()  # Don't automatically rewrite this node.
#@+node:ekr.20141007223054.18004: *13* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    """Copy all nodes from fn, a .leo file, to the children of p."""
    c = self.c
    p.h = f"From {g.shortFileName(fn)}"
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(s)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
#@+node:ekr.20120309075544.9882: *13* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3:  # Don't just strip off c:\.
        p.h = abs_fn[len(prefix) :].strip()
    else:
        p.h = f"@url file://{fn}"
#@+node:ekr.20110605121601.18377: *13* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    """Return true if fn (a file name) can be parsed with an @auto parser."""
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
#@+node:ekr.20120309075544.9881: *13* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict)
        val = ext not in keys
    return val
#@+node:ekr.20141007223054.18003: *13* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    """Return true if fn (a file name) represents an entire .leo file."""
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
#@+node:ekr.20110605121601.18376: *13* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    """
    Return true if the file whose contents is s
    was created from an @thin or @file tree.
    """
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    # Like at.isFileLike.
    j, k = g.getLine(s, i)
    line = s[j:k]
    valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
    return valid and new_df and isThin
#@+node:ekr.20110605121601.18378: *13* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
#@+node:ekr.20110605121601.18379: *11* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    """Insert fn as an @path node after p."""
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
#@+node:ekr.20110605121601.18380: *10* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    """Insert the url in an @url node after p."""
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@url'
    p2.b = s
    p2.clearDirty()  # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
#@+node:ekr.20110605121601.18381: *7* LeoQTreeWidget: utils
#@+node:ekr.20110605121601.18382: *8* LeoQTreeWidget.dump
def dump(self, ev, p, tag):
    if ev:
        md = ev.mimeData()
        s = g.checkUnicode(md.text(), encoding='utf-8')
        g.trace('md.text:', repr(s) if len(s) < 100 else len(s))
        for url in md.urls() or []:
            g.trace('     url:', url)
            g.trace('  url.fn:', url.toLocalFile())
            g.trace('url.text:', url.toString())
    else:
        g.trace('', tag, '** no event!')
#@+node:ekr.20141007223054.18002: *8* LeoQTreeWidget.fileName
def fileName(self):
    """Return the commander's filename."""
    return self.c.fileName() or '<unsaved file>'
#@+node:ekr.20110605121601.18385: *6* class LeoQtSpellTab
class LeoQtSpellTab:
    @others
#@+node:ekr.20110605121601.18386: *7* LeoQtSpellTab.__init__
def __init__(self, c, handler, tabName):
    """Ctor for LeoQtSpellTab class."""
    self.c = c
    top = c.frame.top
    self.handler = handler
    # hack:
    handler.workCtrl = leoFrame.StringTextWrapper(c, 'spell-workctrl')
    self.tabName = tabName
    if hasattr(top, 'leo_spell_label'):
        self.wordLabel = top.leo_spell_label
        self.listBox = top.leo_spell_listBox
        self.fillbox([])
    else:
        self.handler.loaded = False
#@+node:ekr.20110605121601.18389: *7* Event handlers
#@+node:ekr.20110605121601.18390: *8* onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""
    self.handler.add()
#@+node:ekr.20110605121601.18391: *8* onChangeButton & onChangeThenFindButton
def onChangeButton(self, event=None):
    """Handle a click in the Change button in the Spell tab."""
    state = self.updateButtons()
    if state:
        self.handler.change()
    self.updateButtons()

def onChangeThenFindButton(self, event=None):
    """Handle a click in the "Change, Find" button in the Spell tab."""
    state = self.updateButtons()
    if state:
        self.handler.change()
        if self.handler.change():
            self.handler.find()
        self.updateButtons()
#@+node:ekr.20110605121601.18392: *8* onFindButton
def onFindButton(self):
    """Handle a click in the Find button in the Spell tab."""
    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18393: *8* onHideButton
def onHideButton(self):
    """Handle a click in the Hide button in the Spell tab."""
    self.handler.hide()
#@+node:ekr.20110605121601.18394: *8* onIgnoreButton
def onIgnoreButton(self, event=None):
    """Handle a click in the Ignore button in the Check Spelling dialog."""
    self.handler.ignore()
#@+node:ekr.20110605121601.18395: *8* onMap
def onMap(self, event=None):
    """Respond to a Tk <Map> event."""
    self.update(show=False, fill=False)
#@+node:ekr.20110605121601.18396: *8* onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18397: *7* Helpers
#@+node:ekr.20110605121601.18398: *8* bringToFront (LeoQtSpellTab)
def bringToFront(self):
    self.c.frame.log.selectTab('Spell')
#@+node:ekr.20110605121601.18399: *8* fillbox (LeoQtSpellTab)
def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""
    self.suggestions = alts
    if not word: word = ""
    self.wordLabel.setText("Suggestions for: " + word)
    self.listBox.clear()
    if self.suggestions:
        self.listBox.addItems(self.suggestions)
        self.listBox.setCurrentRow(0)
#@+node:ekr.20110605121601.18400: *8* getSuggestion (LeoQtSpellTab)
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    idx = self.listBox.currentRow()
    value = self.suggestions[idx]
    return value
#@+node:ekr.20141113094129.13: *8* setFocus (LeoQtSpellTab)
def setFocus(self):
    """Actually put focus in the tab."""
    # Not a great idea: there is no indication of focus.
    c = self.c
    if c.frame and c.frame.top and hasattr(c.frame.top, 'spellFrame'):
        w = self.c.frame.top.spellFrame
        c.widgetWantsFocus(w)
#@+node:ekr.20110605121601.18401: *8* update (LeoQtSpellTab)
def update(self, show=True, fill=False):
    """Update the Spell Check dialog."""
    c = self.c
    if fill:
        self.fillbox([])
    self.updateButtons()
    if show:
        self.bringToFront()
        c.bodyWantsFocus()
#@+node:ekr.20110605121601.18402: *8* updateButtons (spellTab)
def updateButtons(self):
    """Enable or disable buttons in the Check Spelling dialog."""
    c = self.c
    top, w = c.frame.top, c.frame.body.wrapper
    state = self.suggestions and w.hasSelection()
    top.leo_spell_btn_Change.setDisabled(not state)
    top.leo_spell_btn_FindChange.setDisabled(not state)
    return state
#@+node:ekr.20110605121601.18438: *6* class LeoQtTreeTab
class LeoQtTreeTab:
    """
    A class representing a so-called tree-tab.

    Actually, it represents a combo box
    """
    @others
#@+node:ekr.20110605121601.18439: *7*  Birth & death
#@+node:ekr.20110605121601.18440: *8*  ctor (LeoQtTreeTab)
def __init__(self, c, iconBar):
    """Ctor for LeoQtTreeTab class."""

    self.c = c
    self.cc = c.chapterController
    assert self.cc
    self.iconBar = iconBar
    self.lockout = False  # True: do not redraw.
    self.tabNames = []
        # The list of tab names. Changes when tabs are renamed.
    self.w = None  # The QComboBox
    # self.reloadSettings()
    self.createControl()
#@+node:ekr.20110605121601.18441: *8* tt.createControl (defines class LeoQComboBox)
def createControl(self):


    class LeoQComboBox(QtWidgets.QComboBox):
        """Create a subclass in order to handle focusInEvents."""

        def __init__(self, tt):
            self.leo_tt = tt
            super().__init__()
            # Fix #458: Chapters drop-down list is not automatically resized.
            self.setSizeAdjustPolicy(self.AdjustToContents)

        def focusInEvent(self, event):
            self.leo_tt.setNames()
            QtWidgets.QComboBox.focusInEvent(self, event)  # Call the base class

    tt = self
    frame = QtWidgets.QLabel('Chapters: ')
    tt.iconBar.addWidget(frame)
    tt.w = w = LeoQComboBox(tt)
    tt.setNames()
    tt.iconBar.addWidget(w)

    def onIndexChanged(s, tt=tt):
        if isinstance(s, int):
            s = '' if s == -1 else tt.w.currentText()
        else:  # s is the tab name.
            pass
        if s and not tt.cc.selectChapterLockout:
            tt.selectTab(s)

    # A change: the argument could now be an int instead of a string.

    w.currentIndexChanged.connect(onIndexChanged)
#@+node:ekr.20110605121601.18443: *7* tt.createTab
def createTab(self, tabName, select=True):
    """LeoQtTreeTab."""
    tt = self
    # Avoid a glitch during initing.
    if tabName != 'main' and tabName not in tt.tabNames:
        tt.tabNames.append(tabName)
        tt.setNames()
#@+node:ekr.20110605121601.18444: *7* tt.destroyTab
def destroyTab(self, tabName):
    """LeoQtTreeTab."""
    tt = self
    if tabName in tt.tabNames:
        tt.tabNames.remove(tabName)
        tt.setNames()
#@+node:ekr.20110605121601.18445: *7* tt.selectTab
def selectTab(self, tabName):
    """LeoQtTreeTab."""
    tt, c, cc = self, self.c, self.cc
    exists = tabName in self.tabNames
    c.treeWantsFocusNow()
        # Fix #969. Somehow this is important.
    if not exists:
        tt.createTab(tabName)  # Calls tt.setNames()
    if tt.lockout:
        return
    cc.selectChapterByName(tabName)
    c.redraw()
    c.outerUpdate()
#@+node:ekr.20110605121601.18446: *7* tt.setTabLabel
def setTabLabel(self, tabName):
    """LeoQtTreeTab."""
    w = self.w
    i = w.findText(tabName)
    if i > -1:
        w.setCurrentIndex(i)
#@+node:ekr.20110605121601.18447: *7* tt.setNames
def setNames(self):
    """LeoQtTreeTab: Recreate the list of items."""
    w = self.w
    names = self.cc.setAllChapterNames()
    w.clear()
    w.insertItems(0, names)
#@+node:ekr.20110605121601.18448: *6* class LeoTabbedTopLevel (LeoBaseTabWidget)
class LeoTabbedTopLevel(LeoBaseTabWidget):
    """ Toplevel frame for tabbed ui """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        ## middle click close on tabs -- JMP 20140505
        self.setMovable(False)
        tb = QtTabBarWrapper(self)
        self.setTabBar(tb)
#@+node:peckj.20140505102552.10377: *6* class QtTabBarWrapper (QTabBar)
class QtTabBarWrapper(QtWidgets.QTabBar):
    @others
#@+node:peckj.20140516114832.10108: *7* __init__
def __init__(self, parent=None):
    super().__init__(parent)
    self.setMovable(True)
#@+node:peckj.20140516114832.10109: *7* mouseReleaseEvent (QtTabBarWrapper)
def mouseReleaseEvent(self, event):
    # middle click close on tabs -- JMP 20140505
    # closes Launchpad bug: https://bugs.launchpad.net/leo-editor/+bug/1183528
    if event.button() == QtCore.Qt.MidButton:
        self.tabCloseRequested.emit(self.tabAt(event.pos()))
    QtWidgets.QTabBar.mouseReleaseEvent(self, event)
#@+node:ekr.20110605121601.18458: *6* class QtMenuWrapper (LeoQtMenu,QMenu)
class QtMenuWrapper(LeoQtMenu, QtWidgets.QMenu):
    @others
#@+node:ekr.20110605121601.18459: *7* ctor and __repr__(QtMenuWrapper)
def __init__(self, c, frame, parent, label):
    """ctor for QtMenuWrapper class."""
    assert c
    assert frame
    if parent is None:
        parent = c.frame.top.menuBar()
    #
    # For reasons unknown, the calls must be in this order.
    # Presumably, the order of base classes also matters(!)
    LeoQtMenu.__init__(self, c, frame, label)
    QtWidgets.QMenu.__init__(self, parent)
    label = label.replace('&', '').lower()
    self.leo_menu_label = label
    action = self.menuAction()
    if action:
        action.leo_menu_label = label
    self.aboutToShow.connect(self.onAboutToShow)

def __repr__(self):
    return f"<QtMenuWrapper {self.leo_menu_label}>"
#@+node:ekr.20110605121601.18460: *7* onAboutToShow & helpers (QtMenuWrapper)
def onAboutToShow(self, *args, **keys):

    name = self.leo_menu_label
    if not name: return
    for action in self.actions():
        commandName = hasattr(action, 'leo_command_name') and action.leo_command_name
        if commandName:
            self.leo_update_shortcut(action, commandName)
            self.leo_enable_menu_item(action, commandName)
            self.leo_update_menu_label(action, commandName)
#@+node:ekr.20120120095156.10261: *8* leo_enable_menu_item
def leo_enable_menu_item(self, action, commandName):
    func = self.c.frame.menu.enable_dict.get(commandName)
    if action and func:
        val = func()
        action.setEnabled(bool(val))
#@+node:ekr.20120124115444.10190: *8* leo_update_menu_label
def leo_update_menu_label(self, action, commandName):
    c = self.c
    if action and commandName == 'mark':
        action.setText('UnMark' if c.p.isMarked() else 'Mark')
        self.leo_update_shortcut(action, commandName)
            # Set the proper shortcut.
#@+node:ekr.20120120095156.10260: *8* leo_update_shortcut
def leo_update_shortcut(self, action, commandName):

    c = self.c; k = c.k
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key, aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for bi in aList:
                # Don't show mode-related bindings.
                if not bi.isModeBinding():
                    accel = k.prettyPrintKey(bi.stroke)
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText(f"{s}\t{', '.join(result)}")
        else:
            action.setText(s)
    else:
        g.trace(f"can not happen: no action for {commandName}")
#@+node:ekr.20110605121601.18461: *6* class QtSearchWidget
class QtSearchWidget:
    """A dummy widget class to pass to Leo's core find code."""

    def __init__(self):
        self.insertPoint = 0
        self.selection = 0, 0
        self.wrapper = self
        self.body = self
        self.text = None
#@+node:ekr.20110605121601.18464: *6* class TabbedFrameFactory
class TabbedFrameFactory:
    """
    'Toplevel' frame builder for tabbed toplevel interface

    This causes Leo to maintain only one toplevel window,
    with multiple tabs for documents
    """
    @others
#@+node:ekr.20110605121601.18465: *7* frameFactory.__init__	 & __repr__
def __init__(self):
    # will be created when first frame appears
    # DynamicWindow => Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {}
        # Keys are DynamicWindows, values are frames.
    self.masterFrame = None
    self.createTabCommands()
#@+node:ekr.20110605121601.18466: *7* frameFactory.createFrame (changed, makes dw)
def createFrame(self, leoFrame):

    c = leoFrame.c
    tabw = self.masterFrame
    dw = DynamicWindow(c, tabw)
    self.leoFrames[dw] = leoFrame
    # Shorten the title.
    title = os.path.basename(c.mFileName) if c.mFileName else leoFrame.title
    tip = leoFrame.title
    dw.setWindowTitle(tip)
    idx = tabw.addTab(dw, title)
    if tip:
        tabw.setTabToolTip(idx, tip)
    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    g.app.gui.setFilter(c, dw, dw, tag='tabbed-frame')
    #
    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() > 1)
    tabw.setTabsClosable(c.config.getBool('outline-tabs-show-close', True))
    if True:  # #1327: Must always do this.
        dw.show()
        tabw.show()
    return dw
#@+node:ekr.20110605121601.18468: *7* frameFactory.createMaster
def createMaster(self):

    window = self.masterFrame = LeoTabbedTopLevel(factory=self)
    tabbar = window.tabBar()
    g.app.gui.attachLeoIcon(window)
    try:
        tabbar.setTabsClosable(True)
        tabbar.tabCloseRequested.connect(self.slotCloseRequest)
    except AttributeError:
        pass  # Qt 4.4 does not support setTabsClosable
    window.currentChanged.connect(self.slotCurrentChanged)
    if 'size' in g.app.debug:
        g.trace(
            f"minimized: {g.app.start_minimized}, "
            f"maximized: {g.app.start_maximized}, "
            f"fullscreen: {g.app.start_fullscreen}")
    #
    # #1189: We *can* (and should) minimize here, to eliminate flash.
    if g.app.start_minimized:
        window.showMinimized()
#@+node:ekr.20110605121601.18472: *7* frameFactory.createTabCommands
def detachTab(self, wdg):
    """ Detach specified tab as individual toplevel window """
    del self.leoFrames[wdg]
    wdg.setParent(None)
    wdg.show()

def createTabCommands(self):
    << Commands for tabs >>
#@+node:ekr.20110605121601.18473: *8* << Commands for tabs >>
@g.command('tab-detach')
def tab_detach(event):
    """ Detach current tab from tab bar """
    if len(self.leoFrames) < 2:
        g.es_print_error("Can't detach last tab")
        return
    c = event['c']
    f = c.frame
    tabwidget = g.app.gui.frameFactory.masterFrame
    tabwidget.detach(tabwidget.indexOf(f.top))
    f.top.setWindowTitle(f.title + ' [D]')

# this is actually not tab-specific, move elsewhere?

@g.command('close-others')
def close_others(event):
    """Close all windows except the present window."""
    myc = event['c']
    for c in g.app.commanders():
        if c is not myc:
            c.close()

def tab_cycle(offset):

    tabw = self.masterFrame
    cur = tabw.currentIndex()
    count = tabw.count()
    # g.es("cur: %s, count: %s, offset: %s" % (cur,count,offset))
    cur += offset
    if cur < 0:
        cur = count - 1
    elif cur >= count:
        cur = 0
    tabw.setCurrentIndex(cur)
    self.focusCurrentBody()

@g.command('tab-cycle-next')
def tab_cycle_next(event):
    """ Cycle to next tab """
    tab_cycle(1)

@g.command('tab-cycle-previous')
def tab_cycle_previous(event):
    """ Cycle to next tab """
    tab_cycle(-1)
#@+node:ekr.20110605121601.18467: *7* frameFactory.deleteFrame
def deleteFrame(self, wdg):

    if not wdg:
        return
    if wdg not in self.leoFrames:
        # probably detached tab
        self.masterFrame.delete(wdg)
        return
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]
    wdg2 = tabw.currentWidget()
    if wdg2:
        g.app.selectLeoWindow(wdg2.leo_c)
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() > 1)
#@+node:ekr.20110605121601.18471: *7* frameFactory.focusCurrentBody
def focusCurrentBody(self):
    """ Focus body control of current tab """
    tabw = self.masterFrame
    w = tabw.currentWidget()
    w.setFocus()
    f = self.leoFrames[w]
    c = f.c
    c.bodyWantsFocusNow()
    # Fix bug 690260: correct the log.
    g.app.log = f.log
#@+node:ekr.20110605121601.18469: *7* frameFactory.setTabForCommander
def setTabForCommander(self, c):
    tabw = self.masterFrame  # a QTabWidget
    for dw in self.leoFrames:  # A dict whose keys are DynamicWindows.
        if dw.leo_c == c:
            for i in range(tabw.count()):
                if tabw.widget(i) == dw:
                    tabw.setCurrentIndex(i)
                    break
            break
#@+node:ekr.20110605121601.18470: *7* frameFactory.signal handlers
def slotCloseRequest(self, idx):

    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    c.close(new_c=None)
        # 2012/03/04: Don't set the frame here.
        # Wait until the next slotCurrentChanged event.
        # This keeps the log and the QTabbedWidget in sync.

def slotCurrentChanged(self, idx):
    # Two events are generated, one for the tab losing focus,
    # and another event for the tab gaining focus.
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if not f:
        return
    tabw.setWindowTitle(f.title)
    # Don't do this: it would break --minimize.
        # g.app.selectLeoWindow(f.c)
    # Fix bug 690260: correct the log.
    g.app.log = f.log
    # Redraw the tab.
    c = f.c
    if c:
        c.redraw()
#@+node:ekr.20140907085654.18699: *5* @file ../plugins/qt_gui.py
"""This file contains the gui wrapper for Qt: g.app.gui."""
<< imports >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20140918102920.17891: *6* << imports >> (qt_gui.py)
import leo.core.leoColor as leoColor
import leo.core.leoGlobals as g
import leo.core.leoGui as leoGui
from leo.core.leoQt import isQt5, Qsci, QString, QtCore, QtGui, QtWidgets
    # This import causes pylint to fail on this file and on leoBridge.py.
    # The failure is in astroid: raw_building.py.
import leo.plugins.qt_events as qt_events
import leo.plugins.qt_frame as qt_frame
import leo.plugins.qt_idle_time as qt_idle_time
import leo.plugins.qt_text as qt_text
import datetime
import functools
import re
import sys
if 1:
    # This defines the commands defined by @g.command.
    # pylint: disable=unused-import
    import leo.plugins.qt_commands as qt_commands
    assert qt_commands
#@+node:ekr.20110605121601.18134: *6* init (qt_gui.py)
def init():

    if g.app.unitTesting:  # Not Ok for unit testing!
        return False
    if not QtCore:
        return False
    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    g.app.gui = LeoQtGui()
    g.app.gui.finishCreate()
    g.plugin_signon(__name__)
    return True
#@+node:ekr.20140907085654.18700: *6* class LeoQtGui(leoGui.LeoGui)
class LeoQtGui(leoGui.LeoGui):
    """A class implementing Leo's Qt gui."""
    @others
#@+node:ekr.20110605121601.18477: *7*  qt_gui.__init__ (sets qtApp)
def __init__(self):
    """Ctor for LeoQtGui class."""
    super().__init__('qt')
         # Initialize the base class.
    self.active = True
    self.consoleOnly = False  # Console is separate from the log.
    self.iconimages = {}
    self.globalFindDialog = None
    self.idleTimeClass = qt_idle_time.IdleTime
    self.insert_char_flag = False  # A flag for eventFilter.
    self.mGuiName = 'qt'
    self.main_window = None
        # The *singleton* QMainWindow.
    self.plainTextWidget = qt_text.PlainTextWrapper
    self.styleSheetManagerClass = StyleSheetManager
        # For c.idle_focus_helper and activate/deactivate events.
    #
    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)
    # Create objects...
    self.qtApp = QtWidgets.QApplication(sys.argv)
    self.reloadSettings()
    self.appIcon = self.getIconImage('leoapp32.png')
    #
    # Define various classes key stokes.
    << define FKeys >>
    << define ignoreChars >>
    << define specialChars >>
    # Put up the splash screen()
    if (g.app.use_splash_screen and
        not g.app.batchMode and
        not g.app.silentMode and
        not g.unitTesting
    ):
        self.splashScreen = self.createSplashScreen()
    self.frameFactory = qt_frame.TabbedFrameFactory()
        # qtFrame.finishCreate does all the other work.

def reloadSettings(self):
    pass
#@+node:ekr.20180419110303.1: *8* << define FKeys >>
self.FKeys = [
    'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']
    # These do not generate keystrokes on MacOs.
#@+node:ekr.20180419105250.1: *8* << define ignoreChars >>
# Always ignore these characters
self.ignoreChars = [
    # These are in ks.special characters.
    # They should *not* be ignored.
        # 'Left', 'Right', 'Up', 'Down',
        # 'Next', 'Prior',
        # 'Home', 'End',
        # 'Delete', 'Escape',
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    # F-Keys are also ok.
        # 'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_0', 'KP_1', 'KP_2', 'KP_3', 'KP_4', 'KP_5', 'KP_6', 'KP_7', 'KP_8', 'KP_9',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1', 'KP_F2', 'KP_F3', 'KP_F4',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        # Keypad chars should be have been converted to other keys.
        # Users should just bind to the corresponding normal keys.
    'CapsLock', 'Caps_Lock',
    'NumLock', 'Num_Lock',
    'ScrollLock',
    'Alt_L', 'Alt_R',
    'Control_L', 'Control_R',
    'Meta_L', 'Meta_R',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
        # Clearly, these should never be generated.
    'Break', 'Pause', 'Sys_Req',
        # These are real keys, but they don't mean anything.
    'Begin', 'Clear',
        # Don't know what these are.
]
#@+node:ekr.20180419081404.1: *8* << define specialChars >>
# Keys whose names must never be inserted into text.
self.specialChars = [
    # These are *not* special keys.
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    'Left', 'Right', 'Up', 'Down',
        # Arrow keys
    'Next', 'Prior',
        # Page up/down keys.
    'Home', 'End',
        # Home end keys.
    'Delete', 'Escape',
        # Others.
    'Enter', 'Insert', 'Ins',
        # These should only work if bound.
    'Menu',
        # #901.
    'PgUp', 'PgDn',
        # #868.
]
#@+node:ekr.20110605121601.18484: *7*  qt_gui.destroySelf (calls qtApp.quit)
def destroySelf(self):

    QtCore.pyqtRemoveInputHook()
    if 'shutdown' in g.app.debug:
        g.pr('LeoQtGui.destroySelf: calling qtApp.Quit')
    self.qtApp.quit()
#@+node:ekr.20110605121601.18485: *7* qt_gui.Clipboard
#@+node:ekr.20160917125946.1: *8* qt_gui.replaceClipboardWith
def replaceClipboardWith(self, s):
    """Replace the clipboard with the string s."""
    cb = self.qtApp.clipboard()
    if cb:
        # cb.clear()  # unnecessary, breaks on some Qt versions
        s = g.toUnicode(s)
        QtWidgets.QApplication.processEvents()
        # Fix #241: QMimeData object error
        cb.setText(QString(s))
        QtWidgets.QApplication.processEvents()
    else:
        g.trace('no clipboard!')
#@+node:ekr.20160917125948.1: *8* qt_gui.getTextFromClipboard
def getTextFromClipboard(self):
    """Get a unicode string from the clipboard."""
    cb = self.qtApp.clipboard()
    if cb:
        QtWidgets.QApplication.processEvents()
        return cb.text()
    g.trace('no clipboard!')
    return ''
#@+node:ekr.20160917130023.1: *8* qt_gui.setClipboardSelection
def setClipboardSelection(self, s):
    """
    Set the clipboard selection to s.
    There are problems with PyQt5.
    """
    if isQt5:
        # Alas, returning s reopens #218.
        return
    if s:
        # This code generates a harmless, but annoying warning on PyQt5.
        cb = self.qtApp.clipboard()
        cb.setText(QString(s), mode=cb.Selection)
#@+node:ekr.20110605121601.18487: *7* qt_gui.Dialogs & panels
#@+node:ekr.20110605121601.18488: *8* qt_gui.alert
def alert(self, c, message):
    if g.unitTesting: return
    b = QtWidgets.QMessageBox
    d = b(None)
    d.setWindowTitle('Alert')
    d.setText(message)
    d.setIcon(b.Warning)
    d.addButton('Ok', b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20110605121601.18489: *8* qt_gui.makeFilter
def makeFilter(self, filetypes):
    """Return the Qt-style dialog filter from filetypes list."""
    filters = ['%s (%s)' % (z) for z in filetypes]
        # Careful: the second %s is *not* replaced.
    return ';;'.join(filters)
#@+node:ekr.20150615211522.1: *8* qt_gui.openFindDialog & helpers
def openFindDialog(self, c):
    if g.unitTesting:
        return
    d = self.globalFindDialog
    if not d:
        d = self.createFindDialog(c)
        self.globalFindDialog = d
        # Fix #516: Do the following only once...
        d.setStyleSheet(c.active_stylesheet)
        # Set the commander's FindTabManager.
        assert g.app.globalFindTabManager
        c.ftm = g.app.globalFindTabManager
        fn = c.shortFileName() or 'Untitled'
        d.setWindowTitle(f"Find in {fn}")
    c.inCommand = False
    if d.isVisible():
        # The order is important, and tricky.
        d.focusWidget()
        d.show()
        d.raise_()
        d.activateWindow()
    else:
        d.show()
        d.exec_()
#@+node:ekr.20150619053138.1: *9* qt_gui.createFindDialog
def createFindDialog(self, c):
    """Create and init a non-modal Find dialog."""
    g.app.globalFindTabManager = c.findCommands.ftm
    top = c.frame.top  # top is the DynamicWindow class.
    w = top.findTab
    d = QtWidgets.QDialog()
    # Fix #516: Hide the dialog. Never delete it.

    def closeEvent(event, d=d):
        event.ignore()
        d.hide()

    d.closeEvent = closeEvent
    layout = QtWidgets.QVBoxLayout(d)
    layout.addWidget(w)
    self.attachLeoIcon(d)
    d.setLayout(layout)
    c.styleSheetManager.set_style_sheets(w=d)
    g.app.gui.setFilter(c, d, d, 'find-dialog')
        # This makes most standard bindings available.
    d.setModal(False)
    return d
#@+node:ekr.20110605121601.18492: *8* qt_gui.panels
def createComparePanel(self, c):
    """Create a qt color picker panel."""
    return None  # This window is optional.

def createFindTab(self, c, parentFrame):
    """Create a qt find tab in the indicated frame."""
    pass  # Now done in dw.createFindTab.

def createLeoFrame(self, c, title):
    """Create a new Leo frame."""
    gui = self
    return qt_frame.LeoQtFrame(c, title, gui)

def createSpellTab(self, c, spellHandler, tabName):
    return qt_frame.LeoQtSpellTab(c, spellHandler, tabName)
#@+node:ekr.20110605121601.18493: *8* qt_gui.runAboutLeoDialog
def runAboutLeoDialog(self, c, version, theCopyright, url, email):
    """Create and run a qt About Leo dialog."""
    if g.unitTesting:
        return
    b = QtWidgets.QMessageBox
    d = b(c.frame.top)
    d.setText(f"{version}\n{theCopyright}\n{url}\n{email}")
    d.setIcon(b.Information)
    yes = d.addButton('Ok', b.YesRole)
    d.setDefaultButton(yes)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20110605121601.18496: *8* qt_gui.runAskDateTimeDialog
def runAskDateTimeDialog(self, c, title,
    message='Select Date/Time',
    init=None,
    step_min=None
):
    """Create and run a qt date/time selection dialog.

    init - a datetime, default now
    step_min - a dict, keys are QtWidgets.QDateTimeEdit Sections, like
      QtWidgets.QDateTimeEdit.MinuteSection, and values are integers,
      the minimum amount that section of the date/time changes
      when you roll the mouse wheel.

    E.g. (5 minute increments in minute field):

        print g.app.gui.runAskDateTimeDialog(c, 'When?',
          message="When is it?",
          step_min={QtWidgets.QDateTimeEdit.MinuteSection: 5})

    """


    class DateTimeEditStepped(QtWidgets.QDateTimeEdit):
        """QDateTimeEdit which allows you to set minimum steps on fields, e.g.
          DateTimeEditStepped(parent, {QtWidgets.QDateTimeEdit.MinuteSection: 5})
        for a minimum 5 minute increment on the minute field.
        """

        def __init__(self, parent=None, init=None, step_min=None):
            if step_min is None: step_min = {}
            self.step_min = step_min
            if init:
                super().__init__(init, parent)
            else:
                super().__init__(parent)

        def stepBy(self, step):
            cs = self.currentSection()
            if cs in self.step_min and abs(step) < self.step_min[cs]:
                step = self.step_min[cs] if step > 0 else -self.step_min[cs]
            QtWidgets.QDateTimeEdit.stepBy(self, step)


    class Calendar(QtWidgets.QDialog):

        def __init__(self,
            parent=None,
            message='Select Date/Time',
            init=None,
            step_min=None
        ):
            if step_min is None: step_min = {}
            super().__init__(parent)
            layout = QtWidgets.QVBoxLayout()
            self.setLayout(layout)
            layout.addWidget(QtWidgets.QLabel(message))
            self.dt = DateTimeEditStepped(init=init, step_min=step_min)
            self.dt.setCalendarPopup(True)
            layout.addWidget(self.dt)
            buttonBox = QtWidgets.QDialogButtonBox(
                QtWidgets.QDialogButtonBox.Ok |
                QtWidgets.QDialogButtonBox.Cancel)
            layout.addWidget(buttonBox)
            buttonBox.accepted.connect(self.accept)
            buttonBox.rejected.connect(self.reject)

    if g.unitTesting: return None
    if step_min is None: step_min = {}
    b = Calendar
    if not init:
        init = datetime.datetime.now()
    d = b(c.frame.top, message=message, init=init, step_min=step_min)
    d.setStyleSheet(c.active_stylesheet)
    d.setWindowTitle(title)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    if val != d.Accepted:
        return None
    return d.dt.dateTime().toPyDateTime()
#@+node:ekr.20110605121601.18494: *8* qt_gui.runAskLeoIDDialog (not used)
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    if g.unitTesting: return None
    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs/bzr login name is a good choice.\n\n" +
        "Leo uses this id to uniquely identify nodes.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    parent = None
    title = 'Enter Leo id'
    s, ok = QtWidgets.QInputDialog.getText(parent, title, message)
    return s
#@+node:ekr.20110605121601.18491: *8* qt_gui.runAskOkCancelNumberDialog
def runAskOkCancelNumberDialog(
    self, c, title, message, cancelButtonText=None, okButtonText=None):
    """Create and run askOkCancelNumber dialog ."""
    if g.unitTesting: return None
    # n,ok = QtWidgets.QInputDialog.getDouble(None,title,message)
    d = QtWidgets.QInputDialog()
    d.setStyleSheet(c.active_stylesheet)
    d.setWindowTitle(title)
    d.setLabelText(message)
    if cancelButtonText:
        d.setCancelButtonText(cancelButtonText)
    if okButtonText:
        d.setOkButtonText(okButtonText)
    self.attachLeoIcon(d)
    ok = d.exec_()
    n = d.textValue()
    try:
        n = float(n)
    except ValueError:
        n = None
    return n if ok else None
#@+node:ekr.20110605121601.18490: *8* qt_gui.runAskOkCancelStringDialog
def runAskOkCancelStringDialog(self, c, title, message, cancelButtonText=None,
                               okButtonText=None, default="", wide=False):
    """Create and run askOkCancelString dialog.

    wide - edit a long string
    """
    if g.unitTesting: return None
    d = QtWidgets.QInputDialog()
    d.setStyleSheet(c.active_stylesheet)
    d.setWindowTitle(title)
    d.setLabelText(message)
    d.setTextValue(default)
    if wide:
        d.resize(int(g.windows()[0].get_window_info()[0] * .9), 100)
    if cancelButtonText:
        d.setCancelButtonText(cancelButtonText)
    if okButtonText:
        d.setOkButtonText(okButtonText)
    self.attachLeoIcon(d)
    ok = d.exec_()
    return str(d.textValue()) if ok else None
#@+node:ekr.20110605121601.18495: *8* qt_gui.runAskOkDialog
def runAskOkDialog(self, c, title, message=None, text="Ok"):
    """Create and run a qt askOK dialog ."""
    if g.unitTesting:
        return
    b = QtWidgets.QMessageBox
    d = b(c.frame.top)
    stylesheet = getattr(c, 'active_stylesheet', None)
    if stylesheet:
        d.setStyleSheet(stylesheet)
    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    d.addButton(text, b.YesRole)
    c.in_qt_dialog = True
    d.exec_()
    c.in_qt_dialog = False
#@+node:ekr.20110605121601.18497: *8* qt_gui.runAskYesNoCancelDialog
def runAskYesNoCancelDialog(self, c, title,
    message=None,
    yesMessage="&Yes",
    noMessage="&No",
    yesToAllMessage=None,
    defaultButton="Yes",
    cancelMessage=None,
):
    """Create and run an askYesNo dialog."""
    if g.unitTesting:
        return None
    b = QtWidgets.QMessageBox
    d = b(c.frame.top)
    stylesheet = getattr(c, 'active_stylesheet', None)
    if stylesheet:
        d.setStyleSheet(stylesheet)
    if message: d.setText(message)
    d.setIcon(b.Warning)
    d.setWindowTitle(title)
    yes = d.addButton(yesMessage, b.YesRole)
    no = d.addButton(noMessage, b.NoRole)
    yesToAll = d.addButton(yesToAllMessage, b.YesRole) if yesToAllMessage else None
    if cancelMessage:
        cancel = d.addButton(cancelMessage, b.RejectRole)
    else:
        cancel = d.addButton(b.Cancel)
    if defaultButton == "Yes": d.setDefaultButton(yes)
    elif defaultButton == "No": d.setDefaultButton(no)
    else: d.setDefaultButton(cancel)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    if val == 0: val = 'yes'
    elif val == 1: val = 'no'
    elif yesToAll and val == 2: val = 'yes-to-all'
    else: val = 'cancel'
    return val
#@+node:ekr.20110605121601.18498: *8* qt_gui.runAskYesNoDialog
def runAskYesNoDialog(self, c, title, message=None, yes_all=False, no_all=False):
    """
    Create and run an askYesNo dialog.
    Return one of ('yes','yes-all','no','no-all')

    :Parameters:
    - `c`: commander
    - `title`: dialog title
    - `message`: dialog message
    - `yes_all`: bool - show YesToAll button
    - `no_all`: bool - show NoToAll button
    """
    if g.unitTesting: return None
    b = QtWidgets.QMessageBox
    buttons = b.Yes | b.No
    if yes_all:
        buttons |= b.YesToAll
    if no_all:
        buttons |= b.NoToAll
    d = b(c.frame.top)
    d.setStyleSheet(c.active_stylesheet)
    d.setStandardButtons(buttons)
    d.setWindowTitle(title)
    if message: d.setText(message)
    d.setIcon(b.Information)
    d.setDefaultButton(b.Yes)
    c.in_qt_dialog = True
    val = d.exec_()
    c.in_qt_dialog = False
    return {
        b.Yes: 'yes',
        b.No: 'no',
        b.YesToAll: 'yes-all',
        b.NoToAll: 'no-all'
    }.get(val, 'no')
#@+node:ekr.20110605121601.18499: *8* qt_gui.runOpenDirectoryDialog
def runOpenDirectoryDialog(self, title, startdir):
    """Create and run an Qt open directory dialog ."""
    parent = None
    d = QtWidgets.QFileDialog()
    self.attachLeoIcon(d)
    s = d.getExistingDirectory(parent, title, startdir)
    return s
#@+node:ekr.20110605121601.18500: *8* qt_gui.runOpenFileDialog & helper
def runOpenFileDialog(self, c,
    title,
    filetypes,
    defaultextension='',
    multiple=False,
    startpath=None,
    callback=None,
        # New in Leo 6.0.  If a callback is given, use the pyzo file browser.
):
    """
    Create and run an Qt open file dialog.
    """
    # pylint: disable=arguments-differ
    if g.unitTesting:
        return ''
    #
    # 2018/03/14: Bug fixes:
    # - Use init_dialog_folder only if a path is not given
    # - *Never* Use os.curdir by default!
    if not startpath:
        startpath = g.init_dialog_folder(c, c.p, use_at_path=True)
            # Returns c.last_dir or os.curdir
    if callback:
        dialog = self.PyzoFileDialog()
        dialog.init()
        dialog.open_dialog(c, callback, defaultextension, startpath)
        return None
    #
    # No callback: use the legacy file browser.
    filter_ = self.makeFilter(filetypes)
    dialog = QtWidgets.QFileDialog()
    dialog.setStyleSheet(c.active_stylesheet)
    self.attachLeoIcon(dialog)
    func = dialog.getOpenFileNames if multiple else dialog.getOpenFileName
    c.in_qt_dialog = True
    try:
        val = func(parent=None, caption=title, directory=startpath, filter=filter_)
    finally:
        c.in_qt_dialog = False
    if isQt5:  # this is a *Py*Qt change rather than a Qt change
        val, junk_selected_filter = val
    if multiple:
        files = [g.os_path_normslashes(s) for s in val]
        if files:
            c.last_dir = g.os_path_dirname(files[-1])
        return files
    s = g.os_path_normslashes(val)
    if s:
        c.last_dir = g.os_path_dirname(s)
    return s
#@+node:ekr.20190518102229.1: *9* class PyzoFileDialog
class PyzoFileDialog:
    """A class supporting the pyzo file dialog."""

    file_browser = None
        # A module.
    @others
#@+node:ekr.20190518102720.1: *10* pfd.init & helpers
def init(self):
    """
    Initialize the browser code, using the actual pyzo if possible, or the
    code in leo/external/pyzo otherwise.    
    """
    if g.app.pluginsController.isLoaded('pyzo_support.py'):
        self.init_real_pyzo()
    else:
        self.init_internal_pyzo()
#@+node:ekr.20190518102823.1: *11* pfd.init_internal_pyzo
def init_internal_pyzo(self):
    """
    Init the internal version of pyzo in leo/external/pyzo.
    """
    # Adjust sys.path.
    g.trace()
    path = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    assert g.os_path_exists(path), repr(path)
    if not path in sys.path:
        sys.path.append(path)
    #
    # Imports.
    # pylint: disable=import-error
    import pyzo
    import pyzo.core.menu as menu
    pyzo.core.menu = menu
        # Looks weird, but needed to import pyzoFileBrowser.
    import pyzo.tools.pyzoFileBrowser as fb
    self.file_browser = fb
        # For open_dialog.
    #
    # Instantiate the browser.
    from pyzo.core.main import loadIcons
    loadIcons()
        # Required to instantiate PyzoFileBrowser.
#@+node:ekr.20190518110307.1: *11* pfd.init_real_pyzo
def init_real_pyzo(self):
    """Init the real pyzo, which has already been inited by pyzo_support.py"""
    # pylint: disable=import-error
    g.trace()
    if 0:  # Probably already done.
        import pyzo
        import pyzo.core.menu as menu
        pyzo.core.menu = menu
            # Looks weird, but needed to import pyzoFileBrowser.
    import pyzo.tools.pyzoFileBrowser as fb
    self.file_browser = fb
        # For open_dialog.
#@+node:ekr.20190518103005.1: *10* pfd.open_dialog
def open_dialog(self, c, callback, defaultextension, startpath, parent=None):
    """Open pyzo's file browser."""
    w = self.file_browser.PyzoFileBrowser(parent=parent)
        # Instantiate a file browser.
    g.app.permanentScriptDict['file_browser'] = w
        # Save reference to the window so it won't disappear.
    g.trace('startpath:', startpath)
    g.app.gui.attachLeoIcon(w)
    w.setPath(startpath)
        # Tell it what to look at.
    w.setStyleSheet("background: #657b83;")
        # Use dark background.
    #
    # Monkey patch double-clicks.
    tree = w._browsers[0]._tree

    def double_click_callback(event, self=tree):
        # From Tree.mouseDoubleClickEvent
        item = self.itemAt(event.x(), event.y())
            # item is a tree.DirItem or tree.FileItem
            # item._proxy is a DirProxy or FileProxy.
        path = item._proxy.path()
        if g.os_path_isfile(path):
            callback(c, False, path)
                # This is the open_completer function.

    tree.mouseDoubleClickEvent = double_click_callback
    #
    # Show it!
    w.show()
#@+node:ekr.20110605121601.18501: *8* qt_gui.runPropertiesDialog
def runPropertiesDialog(self,
    title='Properties',
    data=None,
    callback=None,
    buttons=None
):
    """Dispay a modal TkPropertiesDialog"""
    if data is None: data = {}
    g.warning('Properties menu not supported for Qt gui')
    result = 'Cancel'
    return result, data
#@+node:ekr.20110605121601.18502: *8* qt_gui.runSaveFileDialog
def runSaveFileDialog(
    self, c, initialfile='', title='Save', filetypes=None, defaultextension=''):
    """Create and run an Qt save file dialog ."""
    if filetypes is None:
        filetypes = []
    if g.unitTesting:
        return ''
    parent = None
    filter_ = self.makeFilter(filetypes)
    d = QtWidgets.QFileDialog()
    d.setStyleSheet(c.active_stylesheet)
    self.attachLeoIcon(d)
    c.in_qt_dialog = True
    obj = d.getSaveFileName(
        parent,
        title,
        # os.curdir,
        g.init_dialog_folder(c, c.p, use_at_path=True),
        filter_)
    c.in_qt_dialog = False
    # Very bizarre: PyQt5 version can return a tuple!
    s = obj[0] if isinstance(obj, (list, tuple)) else obj
    s = s or ''
    if s:
        c.last_dir = g.os_path_dirname(s)
    return s
#@+node:ekr.20110605121601.18503: *8* qt_gui.runScrolledMessageDialog
def runScrolledMessageDialog(self,
    short_title='',
    title='Message',
    label='',
    msg='',
    c=None, **keys
):
    # pylint: disable=dangerous-default-value
    # How are we supposed to avoid **keys?
    if g.unitTesting: return None

    def send(title=title, label=label, msg=msg, c=c, keys=keys):
        return g.doHook('scrolledMessage',
            short_title=short_title, title=title,
            label=label, msg=msg, c=c, **keys)

    if not c or not c.exists:
        << no c error>>
    else:
        retval = send()
        if retval: return retval
        << load viewrendered plugin >>
        retval = send()
        if retval: return retval
        << no dialog error >>
    << emergency fallback >>
#@+node:ekr.20110605121601.18504: *9* << no c error>>
g.es_print_error('%s\n%s\n\t%s' % (
    "The qt plugin requires calls to g.app.gui.scrolledMessageDialog to include 'c'",
    "as a keyword argument",
    g.callers()
))
#@+node:ekr.20110605121601.18505: *9* << load viewrendered plugin >>
pc = g.app.pluginsController
# Load viewrendered (and call vr.onCreate) *only* if not already loaded.
if (
    not pc.isLoaded('viewrendered.py')
    and not pc.isLoaded('viewrendered2.py')
    and not pc.isLoaded('viewrendered3.py')
):
    vr = pc.loadOnePlugin('viewrendered.py')
    if vr:
        g.blue('viewrendered plugin loaded.')
        vr.onCreate('tag', {'c': c})
#@+node:ekr.20110605121601.18506: *9* << no dialog error >>
g.es_print_error(
    f'No handler for the "scrolledMessage" hook.\n\t{g.callers()}')
#@+node:ekr.20110605121601.18507: *9* << emergency fallback >>
b = QtWidgets.QMessageBox
d = b(None)  # c.frame.top)
d.setWindowFlags(QtCore.Qt.Dialog)
    # That is, not a fixed size dialog.
d.setWindowTitle(title)
if msg: d.setText(msg)
d.setIcon(b.Information)
d.addButton('Ok', b.YesRole)
c.in_qt_dialog = True
d.exec_()
c.in_qt_dialog = False
#@+node:ekr.20110607182447.16456: *7* qt_gui.Event handlers
#@+node:ekr.20190824094650.1: *8* qt_gui.close_event
def close_event(self, event):

    noclose = False
    if g.app.sessionManager and g.app.loaded_session:
        g.app.sessionManager.save_snapshot()
    for c in g.app.commanders():
        allow = c.exists and g.app.closeLeoWindow(c.frame)
        if not allow:
            noclose = True
    if noclose:
        event.ignore()
    else:
        event.accept()
#@+node:ekr.20110605121601.18481: *8* qt_gui.onDeactiveEvent
# deactivated_name = ''

deactivated_widget = None

def onDeactivateEvent(self, event, c, obj, tag):
    """
    Gracefully deactivate the Leo window.
    Called several times for each window activation.
    """
    w = self.get_focus()
    w_name = w and w.objectName()
    if 'focus' in g.app.debug:
        g.trace(repr(w_name))
    self.active = False
        # Used only by c.idle_focus_helper.
    #
    # Careful: never save headline widgets.
    if w_name == 'headline':
        self.deactivated_widget = c.frame.tree.treeWidget
    else:
        self.deactivated_widget = w if w_name else None
    #
    # Causes problems elsewhere...
        # if c.exists and not self.deactivated_name:
            # self.deactivated_name = self.widget_name(self.get_focus())
            # self.active = False
            # c.k.keyboardQuit(setFocus=False)
    g.doHook('deactivate', c=c, p=c.p, v=c.p, event=event)
#@+node:ekr.20110605121601.18480: *8* qt_gui.onActivateEvent
# Called from eventFilter

def onActivateEvent(self, event, c, obj, tag):
    """
    Restore the focus when the Leo window is activated.
    Called several times for each window activation.
    """
    trace = 'focus' in g.app.debug
    w = self.get_focus() or self.deactivated_widget
    self.deactivated_widget = None
    w_name = w and w.objectName()
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    # Fix #359: Leo hangs in LeoQtEventFilter.eventFilter
    # #1273: add teest on c.vim_mode.
    if c.exists and c.vim_mode and c.vimCommands and not self.active and not g.app.killed:
        c.vimCommands.on_activate()
    self.active = True
        # Used only by c.idle_focus_helper.
    if g.isMac:
        pass  # Fix #757: MacOS: replace-then-find does not work in headlines.
    else:
        # Leo 5.6: Recover from missing focus.
        # c.idle_focus_handler can't do this.
        if w and w_name in ('log-widget', 'richTextEdit', 'treeWidget'):
            # Restore focus **only** to body or tree
            if trace: g.trace('==>', w_name)
            c.widgetWantsFocusNow(w)
        else:
            if trace: g.trace(repr(w_name), '==> BODY')
            c.bodyWantsFocusNow()
    # Cause problems elsewhere.
        # if c.exists and self.deactivated_name:
            # self.active = True
            # w_name = self.deactivated_name
            # self.deactivated_name = None
            # if c.p.v:
                # c.p.v.restoreCursorAndScroll()
            # if w_name.startswith('tree') or w_name.startswith('head'):
                # c.treeWantsFocusNow()
            # else:
                # c.bodyWantsFocusNow()
    g.doHook('activate', c=c, p=c.p, v=c.p, event=event)
#@+node:ekr.20130921043420.21175: *8* qt_gui.setFilter
# w's type is in (DynamicWindow,QMinibufferWrapper,LeoQtLog,LeoQtTree,
# QTextEditWrapper,LeoQTextBrowser,LeoQuickSearchWidget,cleoQtUI)

def setFilter(self, c, obj, w, tag):
    """
    Create an event filter in obj.
    w is a wrapper object, not necessarily a QWidget.
    """
    # gui = self
    assert isinstance(obj, QtWidgets.QWidget), obj
    theFilter = qt_events.LeoQtEventFilter(c, w=w, tag=tag)
    obj.installEventFilter(theFilter)
    w.ev_filter = theFilter
        # Set the official ivar in w.
#@+node:ekr.20110605121601.18508: *7* qt_gui.Focus
#@+node:ekr.20190601055031.1: *8* qt_gui.ensure_commander_visible
def ensure_commander_visible(self, c1):
    """
    Check to see if c.frame is in a tabbed ui, and if so, make sure
    the tab is visible
    """
    # pylint: disable=arguments-differ
    #
    # START: copy from Code-->Startup & external files-->
    # @file runLeo.py -->run & helpers-->doPostPluginsInit & helpers (runLeo.py)
    # For the qt gui, select the first-loaded tab.
    if 'focus' in g.app.debug:
        g.trace(c1)
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            c = c1
            factory.setTabForCommander(c)
            c.bodyWantsFocusNow()
    # END: copy
#@+node:ekr.20190601054958.1: *8* qt_gui.get_focus
def get_focus(self, c=None, raw=False, at_idle=False):
    """Returns the widget that has focus."""
    # pylint: disable=arguments-differ
    trace = 'focus' in g.app.debug
    trace_idle = False
    trace = trace and (trace_idle or not at_idle)
    app = QtWidgets.QApplication
    w = app.focusWidget()
    if w and not raw and isinstance(w, qt_text.LeoQTextBrowser):
        has_w = getattr(w, 'leo_wrapper', None)
        if has_w:
            if trace: g.trace(w)
        elif c:
            # Kludge: DynamicWindow creates the body pane
            # with wrapper = None, so return the LeoQtBody.
            w = c.frame.body
    if trace:
        name = w.objectName() if hasattr(w, 'objectName') else w.__class__.__name__
        g.trace('(LeoQtGui)', name)
    return w
#@+node:ekr.20190601054959.1: *8* qt_gui.set_focus
def set_focus(self, c, w):
    """Put the focus on the widget."""
    # pylint: disable=arguments-differ
    if not w:
        return
    if getattr(w, 'widget', None):
        if not isinstance(w, QtWidgets.QWidget):
            # w should be a wrapper.
            w = w.widget
    if 'focus' in g.app.debug:
        name = w.objectName() if hasattr(w, 'objectName') else w.__class__.__name__
        g.trace('(LeoQtGui)', name)
    w.setFocus()
#@+node:ekr.20110605121601.18510: *7* qt_gui.getFontFromParams
size_warnings = []

def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    """Required to handle syntax coloring."""
    if isinstance(size, str):
        if size.endswith('pt'):
            size = size[:-2].strip()
        elif size.endswith('px'):
            if size not in self.size_warnings:
                self.size_warnings.append(size)
                g.es(f"px ignored in font setting: {size}")
            size = size[:-2].strip()
    try:
        size = int(size)
    except Exception:
        size = 0
    if size < 1: size = defaultSize
    d = {
        'black': QtGui.QFont.Black,
        'bold': QtGui.QFont.Bold,
        'demibold': QtGui.QFont.DemiBold,
        'light': QtGui.QFont.Light,
        'normal': QtGui.QFont.Normal,
    }
    weight_val = d.get(weight.lower(), QtGui.QFont.Normal)
    italic = slant == 'italic'
    if not family:
        family = g.app.config.defaultFontFamily
    if not family:
        family = 'DejaVu Sans Mono'
    try:
        font = QtGui.QFont(family, size, weight_val, italic)
        if sys.platform.startswith('linux'):
            font.setHintingPreference(font.PreferFullHinting)
        # g.es(font,font.hintingPreference())
        return font
    except Exception:
        g.es("exception setting font", g.callers(4))
        g.es(
            f"family: {family}\n"
            f"  size: {size}\n"
            f" slant: {slant}\n"
            f"weight: {weight}")
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@+node:ekr.20110605121601.18511: *7* qt_gui.getFullVersion
def getFullVersion(self, c=None):
    """Return the PyQt version (for signon)"""
    try:
        qtLevel = f"version {QtCore.QT_VERSION_STR}"
    except Exception:
        # g.es_exception()
        qtLevel = '<qtLevel>'
    return f"PyQt {qtLevel}"
#@+node:ekr.20110605121601.18514: *7* qt_gui.Icons
#@+node:ekr.20110605121601.18515: *8* qt_gui.attachLeoIcon
def attachLeoIcon(self, window):
    """Attach a Leo icon to the window."""
    #icon = self.getIconImage('leoApp.ico')
    if self.appIcon:
        window.setWindowIcon(self.appIcon)
#@+node:ekr.20110605121601.18516: *8* qt_gui.getIconImage
def getIconImage(self, name):
    """Load the icon and return it."""
    # Return the image from the cache if possible.
    if name in self.iconimages:
        image = self.iconimages.get(name)
        return image
    try:
        iconsDir = g.os_path_join(g.app.loadDir, "..", "Icons")
        homeIconsDir = g.os_path_join(g.app.homeLeoDir, "Icons")
        for theDir in (homeIconsDir, iconsDir):
            fullname = g.os_path_finalize_join(theDir, name)
            if g.os_path_exists(fullname):
                if 0:  # Not needed: use QTreeWidget.setIconsize.
                    pixmap = QtGui.QPixmap()
                    pixmap.load(fullname)
                    image = QtGui.QIcon(pixmap)
                else:
                    image = QtGui.QIcon(fullname)
                self.iconimages[name] = image
                return image
        # No image found.
        return None
    except Exception:
        g.es_print("exception loading:", fullname)
        g.es_exception()
        return None
#@+node:ekr.20110605121601.18517: *8* qt_gui.getImageImage
@functools.lru_cache(maxsize=128)
def getImageImage(self, name):
    """Load the image in file named `name` and return it."""
    fullname = self.getImageFinder(name)
    try:
        pixmap = QtGui.QPixmap()
        pixmap.load(fullname)
        return pixmap
    except Exception:
        g.es("exception loading:", name)
        g.es_exception()
        return None
#@+node:tbrown.20130316075512.28478: *8* qt_gui.getImageFinder
dump_given = False
@functools.lru_cache(maxsize=128)
def getImageFinder(self, name):
    """Theme aware image (icon) path searching."""
    trace = 'themes' in g.app.debug
    exists = g.os_path_exists
    getString = g.app.config.getString

    def dump(var, val):
        print(f"{var:20}: {val}")

    join = g.os_path_join
    #
    # "Just works" for --theme and theme .leo files *provided* that
    # theme .leo files actually contain these settings!
    #
    theme_name1 = getString('color-theme')
    theme_name2 = getString('theme-name')
    roots = [
        g.os_path_join(g.computeHomeDir(), '.leo'),
        g.computeLeoDir(),
    ]
    theme_subs = [
        "themes/{theme}/Icons",
        "themes/{theme}",
        "Icons/{theme}",
    ]
    bare_subs = ["Icons", "."]
        # "." for icons referred to as Icons/blah/blah.png
    paths = []
    for theme_name in (theme_name1, theme_name2):
        for root in roots:
            for sub in theme_subs:
                paths.append(join(root, sub.format(theme=theme_name)))
    for root in roots:
        for sub in bare_subs:
            paths.append(join(root, sub))
    table = [z for z in paths if exists(z)]
    if trace and not self.dump_given:
        self.dump_given = True
        getString = g.app.config.getString
        g.trace('\n...')
        # dump('g.app.theme_color', g.app.theme_color)
        dump('@string color_theme', getString('color-theme'))
        # dump('g.app.theme_name', g.app.theme_name)
        dump('@string theme_name', getString('theme-name'))
        print('directory table...')
        g.printObj(table)
        print('')
    for base_dir in table:
        path = join(base_dir, name)
        if exists(path):
            if trace: g.trace(f"{name} is  in {base_dir}\n")
            return path
        if trace:
            g.trace(name, 'not in', base_dir)
    g.trace('not found:', name)
    return None
#@+node:ekr.20110605121601.18518: *8* qt_gui.getTreeImage
@functools.lru_cache(maxsize=128)
def getTreeImage(self, c, path):
    image = QtGui.QPixmap(path)
    if image.height() > 0 and image.width() > 0:
        return image, image.height()
    return None, None
#@+node:ekr.20131007055150.17608: *7* qt_gui.insertKeyEvent
def insertKeyEvent(self, event, i):
    """Insert the key given by event in location i of widget event.w."""
    import leo.core.leoGui as leoGui
    assert isinstance(event, leoGui.LeoKeyEvent)
    qevent = event.event
    assert isinstance(qevent, QtGui.QKeyEvent)
    qw = getattr(event.w, 'widget', None)
    if qw and isinstance(qw, QtWidgets.QTextEdit):
        if 1:
            # Assume that qevent.text() *is* the desired text.
            # This means we don't have to hack eventFilter.
            qw.insertPlainText(qevent.text())
        else:
            # Make no such assumption.
            # We would like to use qevent to insert the character,
            # but this would invoke eventFilter again!
            # So set this flag for eventFilter, which will
            # return False, indicating that the widget must handle
            # qevent, which *presumably* is the best that can be done.
            g.app.gui.insert_char_flag = True
#@+node:ekr.20190819072045.1: *7* qt_gui.make_main_window
def make_main_window(self):
    """Make the *singleton* QMainWindow."""
    window = QtWidgets.QMainWindow()
    window.setObjectName('LeoGlobalMainWindow')
    # Calling window.show() here causes flash.
    self.attachLeoIcon(window)
    # Monkey-patch
    window.closeEvent = self.close_event
        # Use self: g.app.gui does not exist yet.
    self.runAtIdle(self.set_main_window_style_sheet)
        # No StyleSheetManager exists yet.
    return window

def set_main_window_style_sheet(self):
    """Style the main window, using the first .leo file."""
    commanders = g.app.commanders()
    if commanders:
        c = commanders[0]
        ssm = c.styleSheetManager
        ssm.set_style_sheets(w=self.main_window)
        self.main_window.setWindowTitle(c.frame.title)  # #1506.
    else:
        g.trace("No open commanders!")
#@+node:ekr.20110605121601.18528: *7* qt_gui.makeScriptButton
def makeScriptButton(self, c,
    args=None,
    p=None,  # A node containing the script.
    script=None,  # The script itself.
    buttonText=None,
    balloonText='Script Button',
    shortcut=None, bg='LightSteelBlue1',
    define_g=True, define_name='__main__', silent=False,  # Passed on to c.executeScript.
):
    """
    Create a script button for the script in node p.
    The button's text defaults to p.headString."""
    k = c.k
    if p and not buttonText: buttonText = p.h.strip()
    if not buttonText: buttonText = 'Unnamed Script Button'
    << create the button b >>
    << define the callbacks for b >>

    b.configure(command=executeScriptCallback)
    if shortcut:
        << bind the shortcut to executeScriptCallback >>
    << create press-buttonText-button command >>
#@+node:ekr.20110605121601.18529: *8* << create the button b >>
iconBar = c.frame.getIconBarObject()
b = iconBar.add(text=buttonText)
#@+node:ekr.20110605121601.18530: *8* << define the callbacks for b >>
def deleteButtonCallback(event=None, b=b, c=c):
    if b: b.pack_forget()
    c.bodyWantsFocus()

def executeScriptCallback(event=None,
    b=b,
    c=c,
    buttonText=buttonText,
    p=p and p.copy(),
    script=script
):
    if c.disableCommandsMessage:
        g.blue('', c.disableCommandsMessage)
    else:
        g.app.scriptDict = {'script_gnx': p.gnx}
        c.executeScript(args=args, p=p, script=script,
        define_g=define_g, define_name=define_name, silent=silent)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es('removing', f"'{buttonText}'", 'button at its request')
            b.pack_forget()
    # Do not assume the script will want to remain in this commander.

#@+node:ekr.20110605121601.18531: *8* << bind the shortcut to executeScriptCallback >>
# In qt_gui.makeScriptButton.
func = executeScriptCallback
if shortcut:
    shortcut = g.KeyStroke(shortcut)
ok = k.bindKey('button', shortcut, func, buttonText)
if ok:
    g.blue('bound @button', buttonText, 'to', shortcut)
#@+node:ekr.20110605121601.18532: *8* << create press-buttonText-button command >> qt_gui.makeScriptButton
# #1121. Like sc.cleanButtonText
buttonCommandName = f"press-{buttonText.replace(' ', '-').strip('-')}-button"
#
# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName, executeScriptCallback, pane='button')
#@+node:ekr.20170612065255.1: *7* qt_gui.put_help
def put_help(self, c, s, short_title=''):
    """Put the help command."""
    s = g.adjustTripleString(s.rstrip(), c.tab_width)
    if s.startswith('<') and not s.startswith('<<'):
        pass  # how to do selective replace??
    pc = g.app.pluginsController
    table = (
        'viewrendered3.py',
        'viewrendered2.py',
        'viewrendered.py',
    )
    for name in table:
        if pc.isLoaded(name):
            vr = pc.loadOnePlugin(name)
            break
    else:
        vr = pc.loadOnePlugin('viewrendered.py')
    if vr:
        kw = {
            'c': c,
            'flags': 'rst',
            'kind': 'rst',
            'label': '',
            'msg': s,
            'name': 'Apropos',
            'short_title': short_title,
            'title': ''}
        vr.show_scrolled_message(tag='Apropos', kw=kw)
        c.bodyWantsFocus()
        if g.unitTesting:
            vr.close_rendering_pane(event={'c': c})
    elif g.unitTesting:
        pass
    else:
        g.es(s)
    return vr  # For unit tests
#@+node:ekr.20110605121601.18521: *7* qt_gui.runAtIdle
def runAtIdle(self, aFunc):
    """This can not be called in some contexts."""
    QtCore.QTimer.singleShot(0, aFunc)
#@+node:ekr.20110605121601.18483: *7* qt_gui.runMainLoop & runWithIpythonKernel
#@+node:ekr.20130930062914.16000: *8* qt_gui.runMainLoop
def runMainLoop(self):
    """Start the Qt main loop."""
    g.app.gui.dismiss_splash_screen()
    g.app.gui.show_tips()
    if self.script:
        log = g.app.log
        if log:
            g.pr('Start of batch script...\n')
            log.c.executeScript(script=self.script)
            g.pr('End of batch script')
        else:
            g.pr('no log, no commander for executeScript in LeoQtGui.runMainLoop')
    elif g.app.useIpython and g.app.ipython_inited:
        self.runWithIpythonKernel()
    else:
        # This can be alarming when using Python's -i option.
        sys.exit(self.qtApp.exec_())
#@+node:ekr.20130930062914.16001: *8* qt_gui.runWithIpythonKernel (commands)
def runWithIpythonKernel(self):
    """Init Leo to run in an IPython shell."""
    try:
        import leo.core.leoIPython as leoIPython
        g.app.ipk = leoIPython.InternalIPKernel()
        g.app.ipk.run()
    except Exception:
        g.es_exception()
        print('can not init leo.core.leoIPython.py')
        sys.exit(1)
#@+node:ekr.20200304125716.1: *7* qt_gui.onContextMenu
def onContextMenu(self, c, w, point):
    """LeoQtGui: Common context menu handling."""
    # #1286.
    handlers = g.tree_popup_handlers
    menu = QtWidgets.QMenu()
    menuPos = w.mapToGlobal(point)
    if not handlers:
        menu.addAction("No popup handlers")
    p = c.p.copy()
    done = set()
    for handler in handlers:
        # every handler has to add it's QActions by itself
        if handler in done:
            # do not run the same handler twice
            continue
        try:
            handler(c, p, menu)
        except Exception:
            g.es_print('Exception executing right-click handler')
            g.es_exception()
    menu.popup(menuPos)
    self._contextmenu = menu
#@+node:ekr.20190822174038.1: *7* qt_gui.set_top_geometry
already_sized = False

def set_top_geometry(self, w, h, x, y):
    """Set the geometry of the main window."""
    if 'size' in g.app.debug:
        g.trace('(qt_gui) already_sized', self.already_sized, w, h, x, y)
    if not self.already_sized:
        self.already_sized = True
        self.main_window.setGeometry(QtCore.QRect(x, y, w, h))
#@+node:ekr.20180117053546.1: *7* qt_gui.show_tips & helpers
@g.command('show-next-tip')
def show_next_tip(self, event=None):
    g.app.gui.show_tips(force=True)


class DialogWithCheckBox(QtWidgets.QMessageBox):

    def __init__(self, controller, tip):
        super().__init__()
        c = g.app.log.c
        self.leo_checked = True
        self.setObjectName('TipMessageBox')
        self.setIcon(self.Information)
        # self.setMinimumSize(5000, 4000)
            # Doesn't work.
            # Prevent the dialog from jumping around when
            # selecting multiple tips.
        self.setWindowTitle('Leo Tips')
        self.setText(repr(tip))
        self.next_tip_button = self.addButton('Show Next Tip', self.ActionRole)
        self.setStandardButtons(self.Ok)  # | self.Close)
        self.setDefaultButton(self.Ok)
        c.styleSheetManager.set_style_sheets(w=self)
        if isQt5:
            # Workaround #693.
            layout = self.layout()
            cb = QtWidgets.QCheckBox()
            cb.setObjectName('TipCheckbox')
            cb.setText('Show Tip On Startup')
            cb.setCheckState(2)
            cb.stateChanged.connect(controller.onClick)
            layout.addWidget(cb, 4, 0, -1, -1)
            if 0:  # Does not work well.
                sizePolicy = QtWidgets.QSizePolicy
                vSpacer = QtWidgets.QSpacerItem(
                    200, 200, sizePolicy.Minimum, sizePolicy.Expanding)
                layout.addItem(vSpacer)

def show_tips(self, force=False):
    import leo.core.leoTips as leoTips
    if g.app.unitTesting:
        return
    c = g.app.log and g.app.log.c
    if not c:
        g.pr('qt_gui:show_tips: NO g.app.log')
        return  # pyzo guard.
    self.show_tips_flag = c.config.getBool('show-tips', default=False)
    if not force and not self.show_tips_flag:
        return
    tm = leoTips.TipManager()
    if 1:  # QMessageBox is always a modal dialog.
        while True:
            tip = tm.get_next_tip()
            m = self.DialogWithCheckBox(controller=self, tip=tip)
            c.in_qt_dialog = True
            m.exec_()
            c.in_qt_dialog = False
            b = m.clickedButton()
            self.update_tips_setting()
            if b != m.next_tip_button:
                break
    else:
        m.buttonClicked.connect(self.onButton)
        m.setModal(False)
        m.show()
#@+node:ekr.20180117080131.1: *8* onButton (not used)
def onButton(self, m):
    m.hide()
#@+node:ekr.20180117073603.1: *8* onClick
def onClick(self, state):
    self.show_tips_flag = bool(state)
#@+node:ekr.20180117083930.1: *9* update_tips_setting
def update_tips_setting(self):
    c = g.app.log.c
    if c and self.show_tips_flag != c.config.getBool('show-tips', default=False):
        c.config.setUserSetting('@bool show-tips', self.show_tips_flag)
#@+node:ekr.20180127103142.1: *8* onNext
def onNext(self, *args, **keys):
    g.trace(args, keys)
    return True
#@+node:ekr.20111215193352.10220: *7* qt_gui.Splash Screen
#@+node:ekr.20110605121601.18479: *8* qt_gui.createSplashScreen
def createSplashScreen(self):
    """Put up a splash screen with the Leo logo."""
    from leo.core.leoQt import QtCore
    qt = QtCore.Qt
    splash = None
    if sys.platform.startswith('win'):
        table = ('SplashScreen.jpg', 'SplashScreen.png', 'SplashScreen.ico')
    else:
        table = ('SplashScreen.xpm',)
    for name in table:
        fn = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', name)
        if g.os_path_exists(fn):
            pm = QtGui.QPixmap(fn)
            if not pm.isNull():
                splash = QtWidgets.QSplashScreen(pm, qt.WindowStaysOnTopHint)
                splash.show()
                # This sleep is required to do the repaint.
                QtCore.QThread.msleep(10)
                splash.repaint()
                break
    return splash
#@+node:ekr.20110613103140.16424: *8* qt_gui.dismiss_splash_screen
def dismiss_splash_screen(self):

    gui = self
    # Warning: closing the splash screen must be done in the main thread!
    if g.unitTesting:
        return
    if gui.splashScreen:
        gui.splashScreen.hide()
        # gui.splashScreen.deleteLater()
        gui.splashScreen = None
#@+node:ekr.20140825042850.18411: *7* qt_gui.Utils...
#@+node:ekr.20110605121601.18522: *8* qt_gui.isTextWidget/Wrapper
def isTextWidget(self, w):
    """Return True if w is some kind of Qt text widget."""
    if Qsci:
        return isinstance(w, (Qsci.QsciScintilla, QtWidgets.QTextEdit)), w
    return isinstance(w, QtWidgets.QTextEdit), w

def isTextWrapper(self, w):
    """Return True if w is a Text widget suitable for text-oriented commands."""
    if w is None:
        return False
    if isinstance(w, (g.NullObject, g.TracingNullObject)):
        return True
    return getattr(w, 'supportsHighLevelInterface', None)
#@+node:ekr.20110605121601.18527: *8* qt_gui.widget_name
def widget_name(self, w):
    # First try the widget's getName method.
    if not 'w':
        name = '<no widget>'
    elif hasattr(w, 'getName'):
        name = w.getName()
    elif hasattr(w, 'objectName'):
        name = str(w.objectName())
    elif hasattr(w, '_name'):
        name = w._name
    else:
        name = repr(w)
    return name
#@+node:ekr.20111027083744.16532: *8* qt_gui.enableSignalDebugging
if isQt5:
    # To do: https://doc.qt.io/qt-5/qsignalspy.html
    from PyQt5.QtTest import QSignalSpy
    assert QSignalSpy
else:
    # enableSignalDebugging(emitCall=foo) and spy your signals until you're sick to your stomach.
    _oldConnect = QtCore.QObject.connect
    _oldDisconnect = QtCore.QObject.disconnect
    _oldEmit = QtCore.QObject.emit

    def _wrapConnect(self, callableObject):
        """Returns a wrapped call to the old version of QtCore.QObject.connect"""

        @staticmethod
        def call(*args):
            callableObject(*args)
            self._oldConnect(*args)

        return call

    def _wrapDisconnect(self, callableObject):
        """Returns a wrapped call to the old version of QtCore.QObject.disconnect"""

        @staticmethod
        def call(*args):
            callableObject(*args)
            self._oldDisconnect(*args)

        return call

    def enableSignalDebugging(self, **kwargs):
        """Call this to enable Qt Signal debugging. This will trap all
        connect, and disconnect calls."""
        f = lambda * args: None
        connectCall = kwargs.get('connectCall', f)
        disconnectCall = kwargs.get('disconnectCall', f)
        emitCall = kwargs.get('emitCall', f)

        def printIt(msg):

            def call(*args):
                print(msg, args)

            return call

        # Monkey-patch.

        QtCore.QObject.connect = self._wrapConnect(connectCall)
        QtCore.QObject.disconnect = self._wrapDisconnect(disconnectCall)

        def new_emit(self, *args):
            emitCall(self, *args)
            self._oldEmit(self, *args)

        QtCore.QObject.emit = new_emit
#@+node:ekr.20190819091957.1: *7* qt_gui.Widgets...
#@+node:ekr.20190819094016.1: *8* qt_gui.createButton
def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(label)
    return w
#@+node:ekr.20190819091122.1: *8* qt_gui.createFrame
def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    """Create a Qt Frame."""
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    w.setObjectName(name)
    return w
#@+node:ekr.20190819091851.1: *8* qt_gui.createGrid
def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
    w.setSpacing(spacing)
    w.setObjectName(name)
    return w
#@+node:ekr.20190819093830.1: *8* qt_gui.createHLayout & createVLayout
def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setObjectName(name)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setObjectName(name)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    return vLayout
#@+node:ekr.20190819094302.1: *8* qt_gui.createLabel
def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    w.setObjectName(name)
    w.setText(label)
    return w
#@+node:ekr.20190819092523.1: *8* qt_gui.createTabWidget
def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setObjectName(name)
    return w
#@+node:ekr.20190819091214.1: *8* qt_gui.setSizePolicy
def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
#@+node:tbrown.20150724090431.1: *6* class StyleClassManager
class StyleClassManager:
    style_sclass_property = 'style_class'  # name of QObject property for styling
    @others
#@+node:tbrown.20150724090431.2: *7* update_view
def update_view(self, w):
    """update_view - Make Qt apply w's style

    :param QWidgit w: widgit to style
    """

    w.setStyleSheet("/* */")  # forces visual update
#@+node:tbrown.20150724090431.3: *7* add_sclass
def add_sclass(self, w, prop):
    """Add style class or list of classes prop to QWidget w"""
    if not prop:
        return
    props = self.sclasses(w)
    if isinstance(prop, str):
        props.append(prop)
    else:
        props.extend(prop)

    self.set_sclasses(w, props)
#@+node:tbrown.20150724090431.4: *7* clear_sclasses
def clear_sclasses(self, w):
    """Remove all style classes from QWidget w"""
    w.setProperty(self.style_sclass_property, '')
#@+node:tbrown.20150724090431.5: *7* has_sclass
def has_sclass(self, w, prop):
    """Check for style class or list of classes prop on QWidget w"""
    if not prop:
        return None
    props = self.sclasses(w)
    if isinstance(prop, str):
        ans = [prop in props]
    else:
        ans = [i in props for i in prop]
    return all(ans)
#@+node:tbrown.20150724090431.6: *7* remove_sclass
def remove_sclass(self, w, prop):
    """Remove style class or list of classes prop from QWidget w"""
    if not prop:
        return
    props = self.sclasses(w)
    if isinstance(prop, str):
        props = [i for i in props if i != prop]
    else:
        props = [i for i in props if i not in prop]

    self.set_sclasses(w, props)
#@+node:tbrown.20150724090431.7: *7* sclass_tests
def sclass_tests(self):
    """Test style class property manipulation functions"""

    # pylint: disable=len-as-condition


    class Test_W:
        """simple standin for QWidget for testing"""

        def __init__(self):
            self.x = ''

        def property(self, name, default=None):
            return self.x or default

        def setProperty(self, name, value):
            self.x = value

    w = Test_W()

    assert not self.has_sclass(w, 'nonesuch')
    assert not self.has_sclass(w, ['nonesuch'])
    assert not self.has_sclass(w, ['nonesuch', 'either'])
    assert len(self.sclasses(w)) == 0

    self.add_sclass(w, 'test')

    assert not self.has_sclass(w, 'nonesuch')
    assert self.has_sclass(w, 'test')
    assert self.has_sclass(w, ['test'])
    assert not self.has_sclass(w, ['test', 'either'])
    assert len(self.sclasses(w)) == 1

    self.add_sclass(w, 'test')
    assert len(self.sclasses(w)) == 1
    self.add_sclass(w, ['test', 'test', 'other'])
    assert len(self.sclasses(w)) == 2
    assert self.has_sclass(w, 'test')
    assert self.has_sclass(w, 'other')
    assert self.has_sclass(w, ['test', 'other', 'test'])
    assert not self.has_sclass(w, ['test', 'other', 'nonesuch'])

    self.remove_sclass(w, ['other', 'nothere'])
    assert self.has_sclass(w, 'test')
    assert not self.has_sclass(w, 'other')
    assert len(self.sclasses(w)) == 1

    self.toggle_sclass(w, 'third')
    assert len(self.sclasses(w)) == 2
    assert self.has_sclass(w, ['test', 'third'])
    self.toggle_sclass(w, 'third')
    assert len(self.sclasses(w)) == 1
    assert not self.has_sclass(w, ['test', 'third'])

    self.clear_sclasses(w)
    assert len(self.sclasses(w)) == 0
    assert not self.has_sclass(w, 'test')
#@+node:tbrown.20150724090431.8: *7* sclasses
def sclasses(self, w):
    """return list of style classes for QWidget w"""
    return str(w.property(self.style_sclass_property) or '').split()
#@+node:tbrown.20150724090431.9: *7* set_sclasses
def set_sclasses(self, w, classes):
    """Set style classes for QWidget w to list in classes"""
    w.setProperty(self.style_sclass_property, f" {' '.join(set(classes))} ")
#@+node:tbrown.20150724090431.10: *7* toggle_sclass
def toggle_sclass(self, w, prop):
    """Toggle style class or list of classes prop on QWidget w"""
    if not prop:
        return
    props = set(self.sclasses(w))

    if isinstance(prop, str):
        prop = set([prop])
    else:
        prop = set(prop)

    current = props.intersection(prop)
    props.update(prop)
    props = props.difference(current)

    self.set_sclasses(w, props)
#@+node:ekr.20140913054442.17860: *6* class StyleSheetManager
class StyleSheetManager:
    """A class to manage (reload) Qt style sheets."""
    @others
#@+node:ekr.20180316091829.1: *7*  ssm.Birth
#@+node:ekr.20140912110338.19371: *8* ssm.__init__
def __init__(self, c, safe=False):
    """Ctor the ReloadStyle class."""
    self.c = c
    self.color_db = leoColor.leo_color_database
    self.safe = safe
    self.settings_p = g.findNodeAnywhere(c, '@settings')
    self.mng = StyleClassManager()
    # This warning is inappropriate in some contexts.
        # if not self.settings_p:
            # g.es("No '@settings' node found in outline.  See:")
            # g.es("http://leoeditor.com/tutorial-basics.html#configuring-leo")
#@+node:ekr.20170222051716.1: *8* ssm.reload_settings
def reload_settings(self, sheet=None):
    """
    Recompute and apply the stylesheet.
    Called automatically by the reload-settings commands.
    """
    if not sheet:
        sheet = self.get_style_sheet_from_settings()
    if sheet:
        w = self.get_master_widget()
        w.setStyleSheet(sheet)
    # self.c.redraw()

reloadSettings = reload_settings
#@+node:ekr.20180316091500.1: *7* ssm.Paths...
#@+node:ekr.20180316065346.1: *8* ssm.compute_icon_directories
def compute_icon_directories(self):
    """
    Return a list of *existing* directories that could contain theme-related icons.
    """
    exists = g.os_path_exists
    home = g.app.homeDir
    join = g.os_path_finalize_join
    leo = join(g.app.loadDir, '..')
    table = [
        join(home, '.leo', 'Icons'),
        # join(home, '.leo'),
        join(leo, 'themes', 'Icons'),
        join(leo, 'themes'),
        join(leo, 'Icons'),
    ]
    table = [z for z in table if exists(z)]
    for directory in self.compute_theme_directories():
        if directory not in table:
            table.append(directory)
        directory2 = join(directory, 'Icons')
        if directory2 not in table:
            table.append(directory2)
    return [g.os_path_normslashes(z) for z in table if g.os_path_exists(z)]
#@+node:ekr.20180315101238.1: *8* ssm.compute_theme_directories
def compute_theme_directories(self):
    """
    Return a list of *existing* directories that could contain theme .leo files.
    """
    lm = g.app.loadManager
    table = lm.computeThemeDirectories()[:]
    directory = g.os_path_normslashes(g.app.theme_directory)
    if directory and directory not in table:
        table.insert(0, directory)
    return table
        # All entries are known to exist and have normalized slashes.
#@+node:ekr.20170307083738.1: *8* ssm.find_icon_path
def find_icon_path(self, setting):
    """Return the path to the open/close indicator icon."""
    c = self.c
    s = c.config.getString(setting)
    if not s:
        return None  # Not an error.
    for directory in self.compute_icon_directories():
        path = g.os_path_finalize_join(directory, s)
        if g.os_path_exists(path):
            return path
    g.es_print('no icon found for:', setting)
    return None
#@+node:ekr.20180316091920.1: *7* ssm.Settings
#@+node:ekr.20110605121601.18176: *8* ssm.default_style_sheet
def default_style_sheet(self):
    """Return a reasonable default style sheet."""
    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    g.trace('===== using default style sheet =====')
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {
    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
QsciScintilla {
    background-color: pink;
}
'''
#@+node:ekr.20140916170549.19551: *8* ssm.get_data
def get_data(self, setting):
    """Return the value of the @data node for the setting."""
    c = self.c
    return c.config.getData(setting, strip_comments=False, strip_data=False) or []
#@+node:ekr.20140916170549.19552: *8* ssm.get_style_sheet_from_settings
def get_style_sheet_from_settings(self):
    """
    Scan for themes or @data qt-gui-plugin-style-sheet nodes.
    Return the text of the relevant node.
    """
    aList1 = self.get_data('qt-gui-plugin-style-sheet')
    aList2 = self.get_data('qt-gui-user-style-sheet')
    if aList2: aList1.extend(aList2)
    sheet = ''.join(aList1)
    sheet = self.expand_css_constants(sheet)
    return sheet
#@+node:ekr.20140915194122.19476: *8* ssm.print_style_sheet
def print_style_sheet(self):
    """Show the top-level style sheet."""
    w = self.get_master_widget()
    sheet = w.styleSheet()
    print(f"style sheet for: {w}...\n\n{sheet}")
#@+node:ekr.20110605121601.18175: *8* ssm.set_style_sheets
def set_style_sheets(self, all=True, top=None, w=None):
    """Set the master style sheet for all widgets using config settings."""
    if g.app.loadedThemes:
        return
    c = self.c
    if top is None: top = c.frame.top
    selectors = ['qt-gui-plugin-style-sheet']
    if all:
        selectors.append('qt-gui-user-style-sheet')
    sheets = []
    for name in selectors:
        sheet = c.config.getData(name, strip_comments=False)
            # don't strip `#selector_name { ...` type syntax
        if sheet:
            if '\n' in sheet[0]:
                sheet = ''.join(sheet)
            else:
                sheet = '\n'.join(sheet)
        if sheet and sheet.strip():
            line0 = f"\n/* ===== From {name} ===== */\n\n"
            sheet = line0 + sheet
            sheets.append(sheet)
    if sheets:
        sheet = "\n".join(sheets)
        # store *before* expanding, so later expansions get new zoom
        c.active_stylesheet = sheet
        sheet = self.expand_css_constants(sheet)
        if not sheet: sheet = self.default_style_sheet()
        if w is None:
            w = self.get_master_widget(top)
        w.setStyleSheet(sheet)
#@+node:ekr.20180316091943.1: *7* ssm.Stylesheet
# Computations on stylesheets themeselves.
#@+node:ekr.20140915062551.19510: *8* ssm.expand_css_constants & helpers
css_warning_given = False

def expand_css_constants(self, sheet, font_size_delta=None, settingsDict=None):
    """Expand @ settings into their corresponding constants."""
    trace_dict = False
    c = self.c
    # Warn once if the stylesheet uses old style style-sheet comment
    if settingsDict is None:
        settingsDict = c.config.settingsDict
    if trace_dict:
        g.trace('===== settingsDict.keys()...')
        g.printObj(sorted(settingsDict.keys()))
    constants, deltas = self.adjust_sizes(font_size_delta, settingsDict)
    sheet = self.replace_indicator_constants(sheet)
    for pass_n in range(10):
        to_do = self.find_constants_referenced(sheet)
        if not to_do:
            break
        old_sheet = sheet
        sheet = self.do_pass(constants, deltas, settingsDict, sheet, to_do)
        if sheet == old_sheet:
            break
    else:
       g.trace('Too many iterations')
    if to_do:
        g.trace('Unresolved @constants')
        g.printObj(to_do)
    sheet = self.resolve_urls(sheet)
    sheet = sheet.replace('\\\n', '')  # join lines ending in \
    return sheet
#@+node:ekr.20150617085045.1: *9* ssm.adjust_sizes
def adjust_sizes(self, font_size_delta, settingsDict):
    """Adjust constants to reflect c._style_deltas."""
    c = self.c
    constants = {}  # old: self.find_constants_defined(sheet)
    deltas = c._style_deltas
    # legacy
    if font_size_delta:
        deltas['font-size-body'] = font_size_delta
    for delta in c._style_deltas:
        # adjust @font-size-body by font_size_delta
        # easily extendable to @font-size-*
        val = c.config.getString(delta)
        passes = 10
        while passes and val and val.startswith('@'):
            key = g.app.config.canonicalizeSettingName(val[1:])
            val = settingsDict.get(key)
            if val:
                val = val.val
            passes -= 1
        if deltas[delta] and (val is not None):
            size = ''.join(i for i in val if i in '01234567890.')
            units = ''.join(i for i in val if i not in '01234567890.')
            size = max(1, int(size) + deltas[delta])
            constants['@' + delta] = f"{size}{units}"
    return constants, deltas
#@+node:ekr.20180316093159.1: *9* ssm.do_pass
def do_pass(self, constants, deltas, settingsDict, sheet, to_do):

    to_do.sort(key=len, reverse=True)
    for const in to_do:
        value = None
        if const in constants:
            # This constant is about to be removed.
            value = constants[const]
            if const[1:] not in deltas and not self.css_warning_given:
                self.css_warning_given = True
                g.es_print(f"'{const}' from style-sheet comment definition, ")
                g.es_print("please use regular @string / @color type @settings.")
        else:
            key = g.app.config.canonicalizeSettingName(const[1:])
                # lowercase, without '@','-','_', etc.
            value = settingsDict.get(key)
            if value is not None:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                    # value = '%s /* %s */' % (value.val, key)
                value = value.val
            elif key in self.color_db:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                value = self.color_db.get(key)
                    # value = '%s /* %s */' % (value, key)
        if value:
            # Partial fix for #780.
            try:
                sheet = re.sub(
                    const + "(?![-A-Za-z0-9_])",
                        # don't replace shorter constants occuring in larger
                    value,
                    sheet,
                )
            except Exception:
                g.es_print('Exception handling style sheet')
                g.es_print(sheet)
                g.es_exception()
        else:
            pass
            # tricky, might be an undefined identifier, but it might
            # also be a @foo in a /* comment */, where it's harmless.
            # So rely on whoever calls .setStyleSheet() to do the right thing.
    return sheet
#@+node:tbrown.20131120093739.27085: *9* ssm.find_constants_referenced
def find_constants_referenced(self, text):
    """find_constants - Return a list of constants referenced in the supplied text,
    constants match::

        @[A-Za-z_][-A-Za-z0-9_]*
        i.e. @foo_1-5

    :Parameters:
    - `text`: text to search
    """
    aList = sorted(set(re.findall(r"@[A-Za-z_][-A-Za-z0-9_]*", text)))
    # Exempt references to Leo constructs.
    for s in ('@button', '@constants', '@data', '@language'):
        if s in aList:
            aList.remove(s)
    return aList
#@+node:tbrown.20130411121812.28335: *9* ssm.find_constants_defined (no longer used)
def find_constants_defined(self, text):
    r"""find_constants - Return a dict of constants defined in the supplied text.

    NOTE: this supports a legacy way of specifying @<identifiers>, regular
    @string and @color settings should be used instead, so calling this
    wouldn't be needed.  expand_css_constants() issues a warning when
    @<identifiers> are found in the output of this method.

    Constants match::

        ^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$
        i.e.
        @foo_1-5=a
            @foo_1-5 = a more here

    :Parameters:
    - `text`: text to search
    """
    pattern = re.compile(r"^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$")
    ans = {}
    text = text.replace('\\\n', '')  # merge lines ending in \
    for line in text.split('\n'):
        test = pattern.match(line)
        if test:
            ans.update([test.groups()])
    # constants may refer to other constants, de-reference here
    change = True
    level = 0
    while change and level < 10:
        level += 1
        change = False
        for k in ans:
            # pylint: disable=unnecessary-lambda
            # process longest first so @solarized-base0 is not replaced
            # when it's part of @solarized-base03
            for o in sorted(ans, key=lambda x: len(x), reverse=True):
                if o in ans[k]:
                    change = True
                    ans[k] = ans[k].replace(o, ans[o])
    if level == 10:
        print("Ten levels of recursion processing styles, abandoned.")
        g.es("Ten levels of recursion processing styles, abandoned.")
    return ans
#@+node:ekr.20150617090104.1: *9* ssm.replace_indicator_constants
def replace_indicator_constants(self, sheet):
    """
    In the stylesheet, replace (if they exist)::

        image: @tree-image-closed
        image: @tree-image-open

    by::

        url(path/closed.png)
        url(path/open.png)

    path can be relative to ~ or to leo/Icons.

    Assuming that ~/myIcons/closed.png exists, either of these will work::

        @string tree-image-closed = nodes-dark/triangles/closed.png
        @string tree-image-closed = myIcons/closed.png

    Return the updated stylesheet.
    """
    close_path = self.find_icon_path('tree-image-closed')
    open_path = self.find_icon_path('tree-image-open')
    # Make all substitutions in the stylesheet.
    table = (
        (open_path, re.compile(r'\bimage:\s*@tree-image-open', re.IGNORECASE)),
        (close_path, re.compile(r'\bimage:\s*@tree-image-closed', re.IGNORECASE)),
        # (open_path,  re.compile(r'\bimage:\s*at-tree-image-open', re.IGNORECASE)),
        # (close_path, re.compile(r'\bimage:\s*at-tree-image-closed', re.IGNORECASE)),
    )
    for path, pattern in table:
        for mo in pattern.finditer(sheet):
            old = mo.group(0)
            new = f"image: url({path})"
            sheet = sheet.replace(old, new)
    return sheet
#@+node:ekr.20180320054305.1: *9* ssm.resolve_urls
def resolve_urls(self, sheet):
    """Resolve all relative url's so they use absolute paths."""
    trace = 'themes' in g.app.debug
    pattern = re.compile(r'url\((.*)\)')
    join = g.os_path_finalize_join
    directories = self.compute_icon_directories()
    paths_traced = False
    if trace:
        paths_traced = True
        g.trace('Search paths...')
        g.printObj(directories)
    # Pass 1: Find all replacements without changing the sheet.
    replacements = []
    for mo in pattern.finditer(sheet):
        url = mo.group(1)
        if url.startswith(':/'):
            url = url[2:]
        elif g.os_path_isabs(url):
            if trace: g.trace('ABS:', url)
            continue
        for directory in directories:
            path = join(directory, url)
            if g.os_path_exists(path):
                if trace: g.trace(f"{url:35} ==> {path}")
                old = mo.group(0)
                new = f"url({path})"
                replacements.append((old, new),)
                break
        else:
            g.trace(f"{url:35} ==> NOT FOUND")
            if not paths_traced:
                paths_traced = True
                g.trace('Search paths...')
                g.printObj(directories)
    # Pass 2: Now we can safely make the replacements.
    for old, new in reversed(replacements):
        sheet = sheet.replace(old, new)
    return sheet
#@+node:ekr.20140912110338.19372: *8* ssm.munge
def munge(self, stylesheet):
    """
    Return the stylesheet without extra whitespace.

    To avoid false mismatches, this should approximate what Qt does.
    To avoid false matches, this should not munge too much.
    """
    s = ''.join([s.lstrip().replace('  ', ' ').replace(' \n', '\n')
        for s in g.splitLines(stylesheet)])
    return s.rstrip()
        # Don't care about ending newline.
#@+node:ekr.20180317062556.1: *7* sss.Theme files
#@+node:ekr.20180316092116.1: *7* ssm.Widgets
#@+node:ekr.20140913054442.19390: *8* ssm.get_master_widget
def get_master_widget(self, top=None):
    """
    Carefully return the master widget.
    c.frame.top is a DynamicWindow.
    """
    if top is None:
        top = self.c.frame.top
    master = top.leo_master or top
    return master
#@+node:ekr.20140913054442.19391: *8* ssm.set selected_style_sheet
def set_selected_style_sheet(self):
    """For manual testing: update the stylesheet using c.p.b."""
    if not g.unitTesting:
        c = self.c
        sheet = c.p.b
        sheet = self.expand_css_constants(sheet)
        w = self.get_master_widget(c.frame.top)
        w.setStyleSheet(sheet)
#@+node:ekr.20140907103315.18777: *5* @file ../plugins/qt_idle_time.py
@first # -*- coding: utf-8 -*-
"""Leo's Qt idle-time code."""
import leo.core.leoGlobals as g
import time
from leo.core.leoQt import QtCore
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20141028061518.24: *6* class IdleTime
class IdleTime:
    """
    A class that executes a handler with a given delay at idle time. The
    handler takes a single argument, the IdleTime instance::

        def handler(timer):
            '''IdleTime handler.  timer is an IdleTime instance.'''
            delta_t = timer.time-timer.starting_time
            g.trace(timer.count,timer.c.shortFileName(),'%2.4f' % (delta_t))
            if timer.count >= 5:
                g.trace('done')
                timer.stop()

        # Execute handler every 500 msec. at idle time.
        timer = g.IdleTime(c,handler,delay=500)
        if timer: timer.start()

    Timer instances are completely independent::

        def handler1(timer):
            delta_t = timer.time-timer.starting_time
            g.trace('%2s %s %2.4f' % (timer.count,timer.c.shortFileName(),delta_t))
            if timer.count >= 5:
                g.trace('done')
                timer.stop()

        def handler2(timer):
            delta_t = timer.time-timer.starting_time
            g.trace('%2s %s %2.4f' % (timer.count,timer.c.shortFileName(),delta_t))
            if timer.count >= 10:
                g.trace('done')
                timer.stop()

        timer1 = g.IdleTime(c,handler1,delay=500)
        timer2 = g.IdleTime(c,handler2,delay=1000)
        if timer1 and timer2:
            timer1.start()
            timer2.start()
    """
    @others
#@+node:ekr.20140825042850.18406: *7* IdleTime.__init__
def __init__(self, handler, delay=500, tag=None):
    """ctor for IdleTime class."""
    # For use by handlers...
    self.count = 0
        # The number of times handler has been called.
    self.starting_time = None
        # Time that the timer started.
    self.time = None
        # Time that the handle is called.
    self.tag = tag
        # An arbitrary string/object for use during debugging.
    # For use by the IdleTime class...
    self.delay = delay
        # The argument to self.timer.start:
        # 0 for idle time, otherwise a delay in msec.
    self.enabled = False
        # True: run the timer continuously.
    self.handler = handler
        # The user-provided idle-time handler.
    self.waiting_for_idle = False
        # True if we have already waited for the minimum delay\
    # Create the timer, but do not fire it.
    self.timer = QtCore.QTimer()
    self.timer.timeout.connect(self.at_idle_time)
    # Add this instance to the global idle_timers.list.
    # This reference prevents this instance from being destroyed.
    g.app.idle_timers.append(self)
#@+node:ekr.20140825102404.18525: *7* IdleTime.__repr__
def __repr__(self):
    """IdleTime repr."""
    tag = self.tag
    if tag:
        return f"<IdleTime: {tag if isinstance(tag, str) else repr(tag)}>"
    return f"<IdleTime: id: {id(self)}>"

__str__ = __repr__
#@+node:ekr.20140825042850.18407: *7* IdleTime.at_idle_time
def at_idle_time(self):
    """Call self.handler not more than once every self.delay msec."""
    if g.app.killed:
        self.stop()
    elif self.enabled:
        if self.waiting_for_idle:
            # At idle time: call the handler.
            self.call_handler()
        # Requeue the timer with the appropriate delay.
        # 0 means wait until idle time.
        self.waiting_for_idle = not self.waiting_for_idle
        if self.timer.isActive():
            self.timer.stop()
        self.timer.start(0 if self.waiting_for_idle else self.delay)
    elif self.timer.isActive():
        self.timer.stop()
#@+node:ekr.20140825042850.18408: *7* IdleTime.call_handler
def call_handler(self):
    """Carefully call the handler."""
    try:
        self.count += 1
        self.time = time.time()
        self.handler(self)
    except Exception:
        g.es_exception()
        self.stop()
#@+node:ekr.20140825080012.18529: *7* IdleTime.destroy_self
def destroy_self(self):
    """Remove the instance from g.app.idle_timers."""
    if not g.app.killed and self in g.app.idle_timers:
        g.app.idle_timers.remove(self)
#@+node:ekr.20140825042850.18409: *7* IdleTime.start & stop
def start(self):
    """Start idle-time processing"""
    self.enabled = True
    if self.starting_time is None:
        self.starting_time = time.time()
    # Wait at least self.delay msec, then wait for idle time.
    self.last_delay = self.delay
    self.timer.start(self.delay)

def stop(self):
    """Stop idle-time processing. May be called during shutdown."""
    self.enabled = False
    if hasattr(self, 'timer') and self.timer.isActive():
        self.timer.stop()
#@+node:ekr.20140907123524.18777: *5* @file ../plugins/qt_quickheadlines.py
@first # -*- coding: utf-8 -*-
"""qt_quickheadlines plugin."""
__qh = None  # For quick headlines.
import leo.core.leoGlobals as g
from leo.core.leoQt import QtCore, QtWidgets
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20140907123524.18778: *6* install_qt_quickheadlines_tab
def install_qt_quickheadlines_tab(c):
    global __qh
    __qh = QuickHeadlines(c)

g.insqh = install_qt_quickheadlines_tab
#@+node:ekr.20110605121601.18534: *6* class QuickHeadlines
class QuickHeadlines:

    def __init__(self, c):
        self.c = c
        tabw = c.frame.top.tabWidget
        self.listWidget = QtWidgets.QListWidget(tabw)
        tabw.addTab(self.listWidget, "Headlines")
        c.frame.top.treeWidget.itemSelectionChanged.connect(self.req_update)
        self.requested = False

    def req_update(self):
        """ prevent too frequent updates (only one/100 msec) """
        if self.requested:
            return
        QtCore.QTimer.singleShot(100, self.update)
        self.requested = True

    def update(self):
        g.trace("quickheadlines update")
        self.requested = False
        self.listWidget.clear()
        p = self.c.currentPosition()
        for n in p.children():
            self.listWidget.addItem(n.h)
#@+node:ekr.20140831085423.18598: *5* @file ../plugins/qt_text.py
@first # -*- coding: utf-8 -*-
"""Text classes for the Qt version of Leo"""
import leo.core.leoGlobals as g
import time
assert time
from leo.core.leoQt import isQt5, QtCore, QtGui, Qsci, QtWidgets
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20191001084541.1: *6*  zoom commands
#@+node:tbrown.20130411145310.18857: *7* @g.command("zoom-in")
@g.command("zoom-in")
def zoom_in(event=None, delta=1):
    """increase body font size by one

    @font-size-body must be present in the stylesheet
    """
    zoom_helper(event, delta=1)
#@+node:ekr.20191001084646.1: *7* @g.command("zoom-out")
@g.command("zoom-out")
def zoom_out(event=None):
    """decrease body font size by one

    @font-size-body must be present in the stylesheet
    """
    # zoom_in(event=event, delta=-1)
    zoom_helper(event=event, delta=-1)
#@+node:ekr.20191001084612.1: *7* zoom_helper
def zoom_helper(event, delta):
    """
    Common helper for zoom commands.
    """
    c = event.get('c')
    if not c:
        return
    wrapper = c.frame.body.wrapper
    #
    # For performance, don't c.styleSheetManager.reload_style_sheets().
    # Apply to body widget directly
    c._style_deltas['font-size-body'] += delta
    ssm = c.styleSheetManager
    sheet = ssm.expand_css_constants(c.active_stylesheet)
    wrapper.widget.setStyleSheet(sheet)
    #
    # #490: Honor language-specific settings.
    colorizer = getattr(c.frame.body, 'colorizer', None)
    if not colorizer:
        return
    c.zoom_delta = delta
    colorizer.configure_fonts()
    wrapper.setAllText(wrapper.getAllText())
        # Recolor everything.
#@+node:ekr.20140901062324.18719: *6*   class QTextMixin
class QTextMixin:
    """A minimal mixin class for QTextEditWrapper and QScintillaWrapper classes."""
    @others
#@+node:ekr.20140901062324.18732: *7* qtm.ctor & helper
def __init__(self, c=None):
    """Ctor for QTextMixin class"""
    self.c = c
    self.changingText = False  # A lockout for onTextChanged.
    self.enabled = True
    self.supportsHighLevelInterface = True
        # A flag for k.masterKeyHandler and isTextWrapper.
    self.tags = {}
    self.permanent = True  # False if selecting the minibuffer will make the widget go away.
    self.configDict = {}  # Keys are tags, values are colors (names or values).
    self.configUnderlineDict = {}  # Keys are tags, values are True
    # self.formatDict = {} # Keys are tags, values are actual QTextFormat objects.
    self.useScintilla = False  # This is used!
    self.virtualInsertPoint = None
    if c:
        self.injectIvars(c)
#@+node:ekr.20140901062324.18721: *8* qtm.injectIvars
def injectIvars(self, name='1', parentFrame=None):
    """Inject standard leo ivars into the QTextEdit or QsciScintilla widget."""
    w = self
    p = self.c.currentPosition()
    if name == '1':
        w.leo_p = None  # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    w.leo_frame = None
    w.leo_name = name
    w.leo_label = None
    return w
#@+node:ekr.20140901062324.18825: *7* qtm.getName
def getName(self):
    return self.name  # Essential.
#@+node:ekr.20140901122110.18733: *7* qtm.Event handlers
# These are independent of the kind of Qt widget.
#@+node:ekr.20140901062324.18716: *8* qtm.onCursorPositionChanged
def onCursorPositionChanged(self, event=None):
    c = self.c
    name = c.widget_name(self)
    # Apparently, this does not cause problems
    # because it generates no events in the body pane.
    if name.startswith('body'):
        if hasattr(c.frame, 'statusLine'):
            c.frame.statusLine.update()
#@+node:ekr.20140901062324.18714: *8* qtm.onTextChanged
def onTextChanged(self):
    """
    Update Leo after the body has been changed.

    tree.tree_select_lockout is True during the entire selection process.
    """
    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    w = self
    c = self.c; p = c.p
    tree = c.frame.tree
    if w.changingText:
        return
    if tree.tree_select_lockout:
        g.trace('*** LOCKOUT', g.callers())
        return
    if not p:
        return
    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText()  # Converts to unicode.
    # Get the previous values from the VNode.
    oldText = p.b
    if oldText == newText:
        # This can happen as the result of undo.
        # g.error('*** unexpected non-change')
        return
    i, j = p.v.selectionStart, p.v.selectionLength
    oldSel = (i, i + j)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p, undoType,
        oldText=oldText, newText=newText,
        oldSel=oldSel, newSel=newSel, oldYview=oldYview)
    # Update the VNode.
    p.v.setBodyString(newText)
    if True:
        p.v.insertSpot = newInsert
        i, j = newSel
        i, j = self.toPythonIndex(i), self.toPythonIndex(j)
        if i > j: i, j = j, i
        p.v.selectionStart, p.v.selectionLength = (i, j - i)
    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged()
    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)
#@+node:ekr.20140901122110.18734: *7* qtm.Generic high-level interface
# These call only wrapper methods.
#@+node:ekr.20140902181058.18645: *8* qtm.Enable/disable
def disable(self):
    self.enabled = False

def enable(self, enabled=True):
    self.enabled = enabled
#@+node:ekr.20140902181058.18644: *8* qtm.Clipboard
def clipboard_append(self, s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)

def clipboard_clear(self):
    g.app.gui.replaceClipboardWith('')
#@+node:ekr.20140901062324.18698: *8* qtm.setFocus
def setFocus(self):
    """QTextMixin"""
    if 'focus' in g.app.debug:
        print('BaseQTextWrapper.setFocus', self.widget)
    # Call the base class
    assert isinstance(self.widget, (
        QtWidgets.QTextBrowser,
        QtWidgets.QLineEdit,
        QtWidgets.QTextEdit,
        Qsci and Qsci.QsciScintilla,
    )), self.widget
    QtWidgets.QTextBrowser.setFocus(self.widget)
#@+node:ekr.20140901062324.18717: *8* qtm.Generic text
#@+node:ekr.20140901062324.18703: *9* qtm.appendText
def appendText(self, s):
    """QTextMixin"""
    s2 = self.getAllText()
    self.setAllText(s2 + s)
    self.setInsertPoint(len(s2))
#@+node:ekr.20140901141402.18706: *9* qtm.delete
def delete(self, i, j=None):
    """QTextMixin"""
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i > j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    # Bug fix: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
#@+node:ekr.20140901062324.18827: *9* qtm.deleteTextSelection
def deleteTextSelection(self):
    """QTextMixin"""
    i, j = self.getSelectionRange()
    self.delete(i, j)
#@+node:ekr.20110605121601.18102: *9* qtm.get
def get(self, i, j=None):
    """QTextMixin"""
    # 2012/04/12: fix the following two bugs by using the vanilla code:
    # https://bugs.launchpad.net/leo-editor/+bug/979142
    # https://bugs.launchpad.net/leo-editor/+bug/971166
    s = self.getAllText()
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    return s[i:j]
#@+node:ekr.20140901062324.18704: *9* qtm.getLastPosition & getLength
def getLastPosition(self, s=None):
    """QTextMixin"""
    return len(self.getAllText()) if s is None else len(s)

def getLength(self, s=None):
    """QTextMixin"""
    return len(self.getAllText()) if s is None else len(s)
#@+node:ekr.20140901062324.18705: *9* qtm.getSelectedText
def getSelectedText(self):
    """QTextMixin"""
    i, j = self.getSelectionRange()
    if i == j:
        return ''
    s = self.getAllText()
    return s[i:j]
#@+node:ekr.20140901141402.18702: *9* qtm.insert
def insert(self, i, s):
    """QTextMixin"""
    s2 = self.getAllText()
    i = self.toPythonIndex(i)
    self.setAllText(s2[:i] + s + s2[i:])
    self.setInsertPoint(i + len(s))
    return i
#@+node:ekr.20140902084950.18634: *9* qtm.seeInsertPoint
def seeInsertPoint(self):
    """Ensure the insert point is visible."""
    self.see(self.getInsertPoint())
        # getInsertPoint defined in client classes.
#@+node:ekr.20140902135648.18668: *9* qtm.selectAllText
def selectAllText(self, s=None):
    """QTextMixin."""
    self.setSelectionRange(0, self.getLength(s))
#@+node:ekr.20140901141402.18710: *9* qtm.toPythonIndex
def toPythonIndex(self, index, s=None):
    """QTextMixin"""
    if s is None:
        s = self.getAllText()
    i = g.toPythonIndex(s, index)
    return i
#@+node:ekr.20140901141402.18704: *9* qtm.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    """QTextMixin"""
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
#@+node:ekr.20140901062324.18729: *8* qtm.rememberSelectionAndScroll
def rememberSelectionAndScroll(self):

    w = self
    v = self.c.p.v  # Always accurate.
    v.insertSpot = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if i > j: i, j = j, i
    assert(i <= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = w.getYScrollPosition()
#@+node:ekr.20140901062324.18712: *8* qtm.tag_configure
def tag_configure(self, *args, **keys):

    if len(args) == 1:
        key = args[0]
        self.tags[key] = keys
        val = keys.get('foreground')
        underline = keys.get('underline')
        if val:
            self.configDict[key] = val
        if underline:
            self.configUnderlineDict[key] = True
    else:
        g.trace('oops', args, keys)

tag_config = tag_configure
#@+node:ekr.20110605121601.18058: *6*  class QLineEditWrapper(QTextMixin)
class QLineEditWrapper(QTextMixin):
    """
    A class to wrap QLineEdit widgets.

    The QHeadlineWrapper class is a subclass that merely
    redefines the do-nothing check method here.
    """
    @others
#@+node:ekr.20110605121601.18060: *7* qlew.Birth
def __init__(self, widget, name, c=None):
    """Ctor for QLineEditWrapper class."""
    super().__init__(c)
    self.widget = widget
    self.name = name
    self.baseClassName = 'QLineEditWrapper'

def __repr__(self):
    return f"<QLineEditWrapper: widget: {self.widget}"

__str__ = __repr__
#@+node:ekr.20140901191541.18599: *7* qlew.check
def check(self):
    """
    QLineEditWrapper.
    """
    return True
#@+node:ekr.20110605121601.18118: *7* qlew.Widget-specific overrides
#@+node:ekr.20110605121601.18120: *8* qlew.getAllText
def getAllText(self):
    """QHeadlineWrapper."""
    if self.check():
        w = self.widget
        return w.text()
    return ''
#@+node:ekr.20110605121601.18121: *8* qlew.getInsertPoint
def getInsertPoint(self):
    """QHeadlineWrapper."""
    if self.check():
        return self.widget.cursorPosition()
    return 0
#@+node:ekr.20110605121601.18122: *8* qlew.getSelectionRange
def getSelectionRange(self, sort=True):
    """QHeadlineWrapper."""
    w = self.widget
    if self.check():
        if w.hasSelectedText():
            i = w.selectionStart()
            s = w.selectedText()
            j = i + len(s)
        else:
            i = j = w.cursorPosition()
        return i, j
    return 0, 0
#@+node:ekr.20110605121601.18123: *8* qlew.hasSelection
def hasSelection(self):
    """QHeadlineWrapper."""
    if self.check():
        return self.widget.hasSelectedText()
    return False
#@+node:ekr.20110605121601.18124: *8* qlew.see & seeInsertPoint
def see(self, i):
    """QHeadlineWrapper."""
    pass

def seeInsertPoint(self):
    """QHeadlineWrapper."""
    pass
#@+node:ekr.20110605121601.18125: *8* qlew.setAllText
def setAllText(self, s):
    """Set all text of a Qt headline widget."""
    if self.check():
        w = self.widget
        w.setText(s)
#@+node:ekr.20110605121601.18128: *8* qlew.setFocus
def setFocus(self):
    """QHeadlineWrapper."""
    if self.check():
        g.app.gui.set_focus(self.c, self.widget)
#@+node:ekr.20110605121601.18129: *8* qlew.setInsertPoint
def setInsertPoint(self, i, s=None):
    """QHeadlineWrapper."""
    if not self.check(): return
    w = self.widget
    if s is None:
        s = w.text()
    i = self.toPythonIndex(i)
    i = max(0, min(i, len(s)))
    w.setCursorPosition(i)
#@+node:ekr.20110605121601.18130: *8* qlew.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    """QHeadlineWrapper."""
    if not self.check(): return
    w = self.widget
    if i > j: i, j = j, i
    if s is None:
        s = w.text()
    n = len(s)
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        insert = j
    else:
        insert = self.toPythonIndex(insert)
        insert = max(0, min(insert, n))
    if i == j:
        w.setCursorPosition(i)
    else:
        length = j - i
        # Set selection is a QLineEditMethod
        if insert < j:
            w.setSelection(j, -length)
        else:
            w.setSelection(i, length)
# setSelectionRangeHelper = setSelectionRange
#@+node:ekr.20150403094619.1: *6* class LeoLineTextWidget(QFrame)
class LeoLineTextWidget(QtWidgets.QFrame):
    """
    A QFrame supporting gutter line numbers.
    
    This class *has* a QTextEdit.
    """
    @others
#@+node:ekr.20150403094706.9: *7* __init__(LeoLineTextWidget)
def __init__(self, c, e, *args):
    """Ctor for LineTextWidget."""
    super().__init__(*args)
    self.c = c
    self.setFrameStyle(self.StyledPanel | self.Sunken)
    self.edit = e  # A QTextEdit
    e.setFrameStyle(self.NoFrame)
    # e.setAcceptRichText(False)
    self.number_bar = NumberBar(c, e)
    hbox = QtWidgets.QHBoxLayout(self)
    hbox.setSpacing(0)
    hbox.setContentsMargins(0, 0, 0, 0)
    hbox.addWidget(self.number_bar)
    hbox.addWidget(e)
    e.installEventFilter(self)
    e.viewport().installEventFilter(self)
#@+node:ekr.20150403094706.10: *7* eventFilter
def eventFilter(self, obj, event):
    """
    Update the line numbers for all events on the text edit and the viewport.
    This is easier than connecting all necessary signals.
    """
    if obj in (self.edit, self.edit.viewport()):
        self.number_bar.update()
        return False
    return QtWidgets.QFrame.eventFilter(obj, event)
#@+node:ekr.20110605121601.18005: *6* class LeoQTextBrowser (QtWidgets.QTextBrowser)
if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
#@+node:ekr.20110605121601.18006: *7*  lqtb.ctor
def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
#@+node:ekr.20110605121601.18007: *7* lqtb. __repr__ & __str__
def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
#@+node:ekr.20110605121601.18008: *7* lqtb.Auto completion
#@+node:ekr.20110605121601.18009: *8* class LeoQListWidget(QListWidget)
class LeoQListWidget(QtWidgets.QListWidget):
    @others
#@+node:ekr.20110605121601.18010: *9* lqlw.ctor
def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
#@+node:ekr.20110605121601.18011: *9* lqlw.closeEvent
def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
#@+node:ekr.20110605121601.18012: *9* lqlw.end_completer
def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
#@+node:ekr.20141024170936.7: *9* lqlw.get_selection
def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
#@+node:ekr.20110605121601.18013: *9* lqlw.keyPressEvent
def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
#@+node:ekr.20110605121601.18014: *9* lqlw.select_callback
def select_callback(self):
    """Called when user selects an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) > 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.frame.body.onBodyChanged('Typing')
    self.end_completer()
#@+node:tbrown.20111011094944.27031: *9* lqlw.tab_callback
def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) < 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 <= i < len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j > i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
#@+node:ekr.20110605121601.18015: *9* lqlw.set_position
def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
#@+node:ekr.20110605121601.18016: *9* lqlw.show_completions
def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
#@+node:ekr.20110605121601.18017: *8* lqtb.lqtb.init_completer
def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
#@+node:ekr.20110605121601.18018: *8* lqtb.redirections to LeoQListWidget
def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
#@+node:ekr.20141103061944.31: *7* lqtb.get/setXScrollPosition
def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20111002125540.7021: *7* lqtb.get/setYScrollPosition
def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18019: *7* lqtb.leo_dumpButton
def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
#@+node:ekr.20200304130514.1: *7* lqtb.onContextMenu
def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
#@+node:ekr.20120925061642.13506: *7* lqtb.onSliderChanged
def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
#@+node:tbrown.20130411145310.18855: *7* lqtb.wheelEvent
def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier & event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta < 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
#@+node:ekr.20150403094706.2: *6* class NumberBar(QFrame)
class NumberBar(QtWidgets.QFrame):
    @others
#@+node:ekr.20150403094706.3: *7* NumberBar.__init__
def __init__(self, c, e, *args):
    """Ctor for NumberBar class."""
    super().__init__(*args)
    self.c = c
    self.edit = e
        # A QTextEdit.
    self.d = e.document()
        # A QTextDocument.
    self.fm = self.fontMetrics()
        # A QFontMetrics
    self.image = QtGui.QImage(g.app.gui.getImageImage(
        g.os_path_finalize_join(g.app.loadDir,
            '..', 'Icons', 'Tango', '16x16', 'actions', 'stop.png')))
    self.highest_line = 0
        # The highest line that is currently visibile.
    # Set the name to gutter so that the QFrame#gutter style sheet applies.
    self.offsets = []
    self.setObjectName('gutter')
    self.reloadSettings()
#@+node:ekr.20181005093003.1: *7* NumberBar.reloadSettings
def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.w_adjust = c.config.getInt('gutter-w-adjust') or 12
        # Extra width for column.
    self.y_adjust = c.config.getInt('gutter-y-adjust') or 10
        # The y offset of the first line of the gutter.
#@+node:ekr.20181005085507.1: *7* NumberBar.mousePressEvent
def mousePressEvent(self, event):

    c = self.c

    def find_line(y):
        n, last_y = 0, 0
        for n, y2 in self.offsets:
            if last_y <= y < y2:
                return n
            last_y = y2
        return n if self.offsets else 0

    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    path = xdb.canonic(g.fullPath(c, c.p))
    if not path:
        return
    n = find_line(event.y())
    if not xdb.checkline(path, n):
        g.trace('FAIL checkline', path, n)
        return
    if xdb.has_breakpoint(path, n):
        xdb.qc.put(f"clear {path}:{n}")
    else:
        xdb.qc.put(f"b {path}:{n}")
#@+node:ekr.20150403094706.5: *7* NumberBar.update
def update(self, *args):
    """
    Updates the number bar to display the current set of numbers.
    Also, adjusts the width of the number bar if necessary.
    """
    # w_adjust is used to compensate for the current line being bold.
    # Always allocate room for 2 columns
    width = self.fm.width(str(max(1000, self.highest_line))) + self.w_adjust
    if self.width() != width:
        self.setFixedWidth(width)
    QtWidgets.QWidget.update(self, *args)
#@+node:ekr.20150403094706.6: *7* NumberBar.paintEvent
def paintEvent(self, event):
    """
    Enhance QFrame.paintEvent.
    Paint all visible text blocks in the editor's document.
    """
    e = self.edit
    d = self.d
    layout = d.documentLayout()
    # Compute constants.
    current_block = d.findBlock(e.textCursor().position())
    scroll_y = e.verticalScrollBar().value()
    page_bottom = scroll_y + e.viewport().height()
    # Paint each visible block.
    painter = QtGui.QPainter(self)
    block = d.begin()
    n = i = 0
    c = self.c
    translation = c.user_dict.get('line_number_translation', [])
    self.offsets = []
    while block.isValid():
        i = translation[n] if n < len(translation) else n + 1
        n += 1
        top_left = layout.blockBoundingRect(block).topLeft()
        if top_left.y() > page_bottom:
            break  # Outside the visible area.
        bold = block == current_block
        self.paintBlock(bold, i, painter, top_left, scroll_y)
        block = block.next()
    self.highest_line = i
    painter.end()
    QtWidgets.QWidget.paintEvent(self, event)
        # Propagate the event.
#@+node:ekr.20150403094706.7: *7* NumberBar.paintBlock
def paintBlock(self, bold, n, painter, top_left, scroll_y):
    """Paint n, right justified in the line number field."""
    c = self.c
    if bold:
        self.setBold(painter, True)
    s = str(n)
    pad = max(4, len(str(self.highest_line))) - len(s)
    s = ' ' * pad + s
    # x = self.width() - self.fm.width(s) - self.w_adjust
    x = 0
    y = round(top_left.y()) - scroll_y + self.fm.ascent() + self.y_adjust
    self.offsets.append((n, y),)
    painter.drawText(x, y, s)
    if bold:
        self.setBold(painter, False)
    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    if not xdb.has_breakpoints():
        return
    path = g.fullPath(c, c.p)
    if xdb.has_breakpoint(path, n):
        target_r = QtCore.QRect(
            self.fm.width(s) + 16,
            top_left.y() + self.y_adjust - 2,
            16.0, 16.0)
        if self.image:
            source_r = QtCore.QRect(0.0, 0.0, 16.0, 16.0)
            painter.drawImage(target_r, self.image, source_r)
        else:
            painter.drawEllipse(target_r)
#@+node:ekr.20150403094706.8: *7* NumberBar.setBold
def setBold(self, painter, flag):
    """Set or clear bold facing in the painter, depending on flag."""
    font = painter.font()
    font.setBold(flag)
    painter.setFont(font)
#@+node:ekr.20140901141402.18700: *6* class PlainTextWrapper(QTextMixin)
class PlainTextWrapper(QTextMixin):
    """A Qt class for use by the find code."""

    def __init__(self, widget):
        """Ctor for the PlainTextWrapper class."""
        super().__init__()
        self.widget = widget
#@+node:ekr.20110605121601.18116: *6* class QHeadlineWrapper (QLineEditWrapper)
class QHeadlineWrapper(QLineEditWrapper):
    """
    A wrapper class for QLineEdit widgets in QTreeWidget's.
    This class just redefines the check method.
    """
    @others
#@+node:ekr.20110605121601.18117: *7* qhw.Birth
def __init__(self, c, item, name, widget):
    """The ctor for the QHeadlineWrapper class."""
    assert isinstance(widget, QtWidgets.QLineEdit), widget
    super().__init__(widget, name, c)
    # Set ivars.
    self.c = c
    self.item = item
    self.name = name
    self.permanent = False  # Warn the minibuffer that we can go away.
    self.widget = widget
    # Set the signal.
    g.app.gui.setFilter(c, self.widget, self, tag=name)

def __repr__(self):
    return f"QHeadlineWrapper: {id(self)}"
#@+node:ekr.20110605121601.18119: *7* qhw.check
def check(self):
    """Return True if the tree item exists and it's edit widget exists."""
    tree = self.c.frame.tree
    try:
        e = tree.treeWidget.itemWidget(self.item, 0)
    except RuntimeError:
        return False
    valid = tree.isValidItem(self.item)
    result = valid and e == self.widget
    return result
#@+node:ekr.20110605121601.18131: *6* class QMinibufferWrapper (QLineEditWrapper)
class QMinibufferWrapper(QLineEditWrapper):

    def __init__(self, c):
        """Ctor for QMinibufferWrapper class."""
        self.c = c
        w = c.frame.top.lineEdit  # QLineEdit
        super().__init__(widget=w, name='minibuffer', c=c)
        assert self.widget
        g.app.gui.setFilter(c, w, self, tag='minibuffer')
        # Monkey-patch the event handlers
        << define mouseReleaseEvent >>

        w.mouseReleaseEvent = mouseReleaseEvent

    def setStyleClass(self, style_class):
        self.widget.setProperty('style_class', style_class)
        #
        # to get the appearance to change because of a property
        # change, unlike a focus or hover change, we need to
        # re-apply the stylesheet.  But re-applying at the top level
        # is too CPU hungry, so apply just to this widget instead.
        # It may lag a bit when the style's edited, but the new top
        # level sheet will get pushed down quite frequently.
        self.widget.setStyleSheet(self.c.frame.top.styleSheet())

    def setSelectionRange(self, i, j, insert=None, s=None):
        QLineEditWrapper.setSelectionRange(self, i, j, insert, s)
        insert = j if insert is None else insert
        if self.widget:
            self.widget._sel_and_insert = (i, j, insert)
#@+node:ekr.20110605121601.18132: *7* << define mouseReleaseEvent >> (QMinibufferWrapper)
def mouseReleaseEvent(event, self=self):
    """Override QLineEdit.mouseReleaseEvent.

    Simulate alt-x if we are not in an input state.
    """
    assert isinstance(self, QMinibufferWrapper), self
    assert isinstance(self.widget, QtWidgets.QLineEdit), self.widget
    c, k = self.c, self.c.k
    if not k.state.kind:
        # c.widgetWantsFocusNow(w) # Doesn't work.
        event2 = g.app.gui.create_key_event(c, w=c.frame.body.wrapper)
        k.fullCommand(event2)
        # c.outerUpdate() # Doesn't work.

#@+node:ekr.20110605121601.18103: *6* class QScintillaWrapper(QTextMixin)
class QScintillaWrapper(QTextMixin):
    """
    A wrapper for QsciScintilla supporting the high-level interface.

    This widget will likely always be less capable the QTextEditWrapper.
    To do:
    - Fix all Scintilla unit-test failures.
    - Add support for all scintilla lexers.
    """
    @others
#@+node:ekr.20110605121601.18105: *7* qsciw.ctor
def __init__(self, widget, c, name=None):
    """Ctor for the QScintillaWrapper class."""
    super().__init__(c)
    self.baseClassName = 'QScintillaWrapper'
    self.c = c
    self.name = name
    self.useScintilla = True
    self.widget = widget
    # Complete the init.
    self.set_config()
    # Set the signal.
    g.app.gui.setFilter(c, widget, self, tag=name)
#@+node:ekr.20110605121601.18106: *7* qsciw.set_config
def set_config(self):
    """Set QScintillaWrapper configuration options."""
    c, w = self.c, self.widget
    n = c.config.getInt('qt-scintilla-zoom-in')
    if n not in (None, 1, 0):
        w.zoomIn(n)
    w.setUtf8(True)  # Important.
    if 1:
        w.setBraceMatching(2)  # Sloppy
    else:
        w.setBraceMatching(0)  # wrapper.flashCharacter creates big problems.
    if 0:
        w.setMarginWidth(1, 40)
        w.setMarginLineNumbers(1, True)
    w.setIndentationWidth(4)
    w.setIndentationsUseTabs(False)
    w.setAutoIndent(True)
#@+node:ekr.20110605121601.18107: *7* qsciw.WidgetAPI
#@+node:ekr.20140901062324.18593: *8* qsciw.delete
def delete(self, i, j=None):
    """Delete s[i:j]"""
    w = self.widget
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    self.setSelectionRange(i, j)
    try:
        self.changingText = True  # Disable onTextChanged
        w.replaceSelectedText('')
    finally:
        self.changingText = False
#@+node:ekr.20140901062324.18594: *8* qsciw.flashCharacter (disabled)
def flashCharacter(self, i, bg='white', fg='red', flashes=2, delay=50):
    """Flash the character at position i."""
    if 0:  # This causes a lot of problems: Better to use Scintilla matching.
        # This causes problems during unit tests:
        # The selection point isn't restored in time.
        if g.app.unitTesting:
            return
        @others
        # Numbered color names don't work in Ubuntu 8.10, so...

        if bg and bg[-1].isdigit() and bg[0] != '#': bg = bg[:-1]
        if fg and fg[-1].isdigit() and fg[0] != '#': fg = fg[:-1]
        # w = self.widget # A QsciScintilla widget.
        self.flashCount = flashes
        self.flashIndex1 = self.getInsertPoint()
        self.flashIndex = self.toPythonIndex(i)
        self.flashBg = None if bg.lower() == 'same' else bg
        self.flashFg = None if fg.lower() == 'same' else fg
        addFlashCallback()
#@+node:ekr.20140902084950.18635: *9* after
def after(func, delay=delay):
    """Run func after the given delay."""
    QtCore.QTimer.singleShot(delay, func)
#@+node:ekr.20140902084950.18636: *9* addFlashCallback
def addFlashCallback(self=self):
    i = self.flashIndex
    w = self.widget
    self.setSelectionRange(i, i + 1)
    if self.flashBg:
        w.setSelectionBackgroundColor(QtGui.QColor(self.flashBg))
    if self.flashFg:
        w.setSelectionForegroundColor(QtGui.QColor(self.flashFg))
    self.flashCount -= 1
    after(removeFlashCallback)
#@+node:ekr.20140902084950.18637: *9* removeFlashCallback
def removeFlashCallback(self=self):
    """Remove the extra selections."""
    self.setInsertPoint(self.flashIndex)
    w = self.widget
    if self.flashCount > 0:
        after(addFlashCallback)
    else:
        w.resetSelectionBackgroundColor()
        self.setInsertPoint(self.flashIndex1)
        w.setFocus()
#@+node:ekr.20140901062324.18595: *8* qsciw.get
def get(self, i, j=None):
    # Fix the following two bugs by using vanilla code:
    # https://bugs.launchpad.net/leo-editor/+bug/979142
    # https://bugs.launchpad.net/leo-editor/+bug/971166
    s = self.getAllText()
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    return s[i:j]
#@+node:ekr.20110605121601.18108: *8* qsciw.getAllText
def getAllText(self):
    """Get all text from a QsciScintilla widget."""
    w = self.widget
    return w.text()
#@+node:ekr.20110605121601.18109: *8* qsciw.getInsertPoint
def getInsertPoint(self):
    """Get the insertion point from a QsciScintilla widget."""
    w = self.widget
    i = int(w.SendScintilla(w.SCI_GETCURRENTPOS))
    return i
#@+node:ekr.20110605121601.18110: *8* qsciw.getSelectionRange
def getSelectionRange(self, sort=True):
    """Get the selection range from a QsciScintilla widget."""
    w = self.widget
    i = int(w.SendScintilla(w.SCI_GETCURRENTPOS))
    j = int(w.SendScintilla(w.SCI_GETANCHOR))
    if sort and i > j: i, j = j, i
    return i, j
#@+node:ekr.20140901062324.18599: *8* qsciw.getX/YScrollPosition (to do)
def getXScrollPosition(self):
    # w = self.widget
    return 0  # Not ready yet.

def getYScrollPosition(self):
    # w = self.widget
    return 0  # Not ready yet.
#@+node:ekr.20110605121601.18111: *8* qsciw.hasSelection
def hasSelection(self):
    """Return True if a QsciScintilla widget has a selection range."""
    return self.widget.hasSelectedText()
#@+node:ekr.20140901062324.18601: *8* qsciw.insert
def insert(self, i, s):
    """Insert s at position i."""
    w = self.widget
    i = self.toPythonIndex(i)
    w.SendScintilla(w.SCI_SETSEL, i, i)
    w.SendScintilla(w.SCI_ADDTEXT, len(s), g.toEncodedString(s))
    i += len(s)
    w.SendScintilla(w.SCI_SETSEL, i, i)
    return i
#@+node:ekr.20140901062324.18603: *8* qsciw.linesPerPage
def linesPerPage(self):
    """Return the number of lines presently visible."""
    # Not used in Leo's core. Not tested.
    w = self.widget
    return int(w.SendScintilla(w.SCI_LINESONSCREEN))
#@+node:ekr.20140901062324.18604: *8* qsciw.scrollDelegate (maybe)
if 0:  # Not yet.

    def scrollDelegate(self, kind):
        """
        Scroll a QTextEdit up or down one page.
        direction is in ('down-line','down-page','up-line','up-page')
        """
        c = self.c
        w = self.widget
        vScroll = w.verticalScrollBar()
        h = w.size().height()
        lineSpacing = w.fontMetrics().lineSpacing()
        n = h / lineSpacing
        n = max(2, n - 3)
        if kind == 'down-half-page': delta = n / 2
        elif kind == 'down-line': delta = 1
        elif kind == 'down-page': delta = n
        elif kind == 'up-half-page': delta = -n / 2
        elif kind == 'up-line': delta = -1
        elif kind == 'up-page': delta = -n
        else:
            delta = 0
            g.trace('bad kind:', kind)
        val = vScroll.value()
        vScroll.setValue(val + (delta * lineSpacing))
        c.bodyWantsFocus()
#@+node:ekr.20110605121601.18112: *8* qsciw.see
def see(self, i):
    """Ensure insert point i is visible in a QsciScintilla widget."""
    # Ok for now.  Using SCI_SETYCARETPOLICY might be better.
    w = self.widget
    s = self.getAllText()
    i = self.toPythonIndex(i)
    row, col = g.convertPythonIndexToRowCol(s, i)
    w.ensureLineVisible(row)
#@+node:ekr.20110605121601.18113: *8* qsciw.setAllText
def setAllText(self, s):
    """Set the text of a QScintilla widget."""
    w = self.widget
    assert isinstance(w, Qsci.QsciScintilla), w
    w.setText(s)
    # w.update()
#@+node:ekr.20110605121601.18114: *8* qsciw.setInsertPoint
def setInsertPoint(self, i, s=None):
    """Set the insertion point in a QsciScintilla widget."""
    w = self.widget
    i = self.toPythonIndex(i)
    # w.SendScintilla(w.SCI_SETCURRENTPOS,i)
    # w.SendScintilla(w.SCI_SETANCHOR,i)
    w.SendScintilla(w.SCI_SETSEL, i, i)
#@+node:ekr.20110605121601.18115: *8* qsciw.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    """Set the selection range in a QsciScintilla widget."""
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    insert = j if insert is None else self.toPythonIndex(insert)
    if insert >= i:
        w.SendScintilla(w.SCI_SETSEL, i, j)
    else:
        w.SendScintilla(w.SCI_SETSEL, j, i)
#@+node:ekr.20140901062324.18609: *8* qsciw.setX/YScrollPosition (to do)
def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
#@+node:ekr.20110605121601.18071: *6* class QTextEditWrapper(QTextMixin)
class QTextEditWrapper(QTextMixin):
    """A wrapper for a QTextEdit/QTextBrowser supporting the high-level interface."""
    @others
#@+node:ekr.20110605121601.18073: *7* qtew.ctor & helpers
def __init__(self, widget, name, c=None):
    """Ctor for QTextEditWrapper class. widget is a QTextEdit/QTextBrowser."""
    super().__init__(c)
    # Make sure all ivars are set.
    self.baseClassName = 'QTextEditWrapper'
    self.c = c
    self.name = name
    self.widget = widget
    self.useScintilla = False
    # Complete the init.
    if c and widget:
        self.widget.setUndoRedoEnabled(False)
        self.set_config()
        self.set_signals()
        
#@+node:ekr.20110605121601.18076: *8* qtew.set_config
def set_config(self):
    """Set configuration options for QTextEdit."""
    w = self.widget
    w.setWordWrapMode(QtGui.QTextOption.NoWrap)
    # tab stop in pixels - no config for this (yet)
    w.setTabStopWidth(24)
#@+node:ekr.20140901062324.18566: *8* qtew.set_signals (should be distributed?)
def set_signals(self):
    """Set up signals."""
    c, name = self.c, self.name
    if name in ('body', 'rendering-pane-wrapper') or name.startswith('head'):
        # Hook up qt events.
        g.app.gui.setFilter(c, self.widget, self, tag=name)
    if name == 'body':
        w = self.widget
        w.textChanged.connect(self.onTextChanged)
        w.cursorPositionChanged.connect(self.onCursorPositionChanged)
    if name in ('body', 'log'):
        # Monkey patch the event handler.
        @others
        self.widget.mouseReleaseEvent = mouseReleaseEvent
#@+node:ekr.20140901062324.18565: *9* mouseReleaseEvent (monkey-patch) QTextEditWrapper
def mouseReleaseEvent(event, self=self):
    """
    Monkey patch for self.widget (QTextEditWrapper) mouseReleaseEvent.
    """
    assert isinstance(self, QTextEditWrapper), self
    assert isinstance(self.widget, QtWidgets.QTextEdit), self.widget
    QtWidgets.QTextEdit.mouseReleaseEvent(self.widget, event)
        # Call the base class.
    c = self.c
    setattr(event, 'c', c)
    # Open the url on a control-click.
    if QtCore.Qt.ControlModifier & event.modifiers():
        g.openUrlOnClick(event)
    else:
        if name == 'body':
            c.p.v.insertSpot = c.frame.body.wrapper.getInsertPoint()
        g.doHook("bodyclick2", c=c, p=c.p, v=c.p)
        # Do *not* change the focus! This would rip focus away from tab panes.
        c.k.keyboardQuit(setFocus=False)
#@+node:ekr.20200312052821.1: *7* qtew.repr
def __repr__(self):
    # Add a leading space to align with StringTextWrapper.
    return f" <QTextEditWrapper: {id(self)} {self.name}>"
    
__str__ = __repr__
#@+node:ekr.20110605121601.18078: *7* qtew.High-level interface
# These are all widget-dependent
#@+node:ekr.20110605121601.18079: *8* qtew.delete (avoid call to setAllText)
def delete(self, i, j=None):
    """QTextEditWrapper."""
    w = self.widget
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    if i > j: i, j = j, i
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    try:
        self.changingText = True  # Disable onTextChanged
        old_i, old_j = self.getSelectionRange()
        if i == old_i and j == old_j:
            # Work around an apparent bug in cursor.movePosition.
            cursor.removeSelectedText()
        elif i == j:
            pass
        else:
            cursor.setPosition(i)
            moveCount = abs(j - i)
            cursor.movePosition(cursor.Right, cursor.KeepAnchor, moveCount)
            w.setTextCursor(cursor)  # Bug fix: 2010/01/27
            cursor.removeSelectedText()
    finally:
        self.changingText = False
    sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18080: *8* qtew.flashCharacter
def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75):
    """QTextEditWrapper."""
    # numbered color names don't work in Ubuntu 8.10, so...
    if bg[-1].isdigit() and bg[0] != '#':
        bg = bg[:-1]
    if fg[-1].isdigit() and fg[0] != '#':
        fg = fg[:-1]
    # This might causes problems during unit tests.
    # The selection point isn't restored in time.
    if g.app.unitTesting:
        return
    w = self.widget  # A QTextEdit.
    e = QtGui.QTextCursor

    def after(func):
        QtCore.QTimer.singleShot(delay, func)

    def addFlashCallback(self=self, w=w):
        i = self.flashIndex
        cursor = w.textCursor()  # Must be the widget's cursor.
        cursor.setPosition(i)
        cursor.movePosition(e.Right, e.KeepAnchor, 1)
        extra = w.ExtraSelection()
        extra.cursor = cursor
        if self.flashBg: extra.format.setBackground(QtGui.QColor(self.flashBg))
        if self.flashFg: extra.format.setForeground(QtGui.QColor(self.flashFg))
        self.extraSelList = [extra]  # keep the reference.
        w.setExtraSelections(self.extraSelList)
        self.flashCount -= 1
        after(removeFlashCallback)

    def removeFlashCallback(self=self, w=w):
        w.setExtraSelections([])
        if self.flashCount > 0:
            after(addFlashCallback)
        else:
            w.setFocus()

    self.flashCount = flashes
    self.flashIndex = i
    self.flashBg = None if bg.lower() == 'same' else bg
    self.flashFg = None if fg.lower() == 'same' else fg
    addFlashCallback()
#@+node:ekr.20110605121601.18081: *8* qtew.getAllText
def getAllText(self):
    """QTextEditWrapper."""
    w = self.widget
    return w.toPlainText()
#@+node:ekr.20110605121601.18082: *8* qtew.getInsertPoint
def getInsertPoint(self):
    """QTextEditWrapper."""
    return self.widget.textCursor().position()
#@+node:ekr.20110605121601.18083: *8* qtew.getSelectionRange
def getSelectionRange(self, sort=True):
    """QTextEditWrapper."""
    w = self.widget
    tc = w.textCursor()
    i, j = tc.selectionStart(), tc.selectionEnd()
    return i, j
#@+node:ekr.20110605121601.18084: *8* qtew.getX/YScrollPosition
# **Important**: There is a Qt bug here: the scrollbar position
# is valid only if cursor is visible.  Otherwise the *reported*
# scrollbar position will be such that the cursor *is* visible.

def getXScrollPosition(self):
    """QTextEditWrapper: Get the horizontal scrollbar position."""
    w = self.widget
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def getYScrollPosition(self):
    """QTextEditWrapper: Get the vertical scrollbar position."""
    w = self.widget
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos
#@+node:ekr.20110605121601.18085: *8* qtew.hasSelection
def hasSelection(self):
    """QTextEditWrapper."""
    return self.widget.textCursor().hasSelection()
#@+node:ekr.20110605121601.18089: *8* qtew.insert (avoid call to setAllText)
def insert(self, i, s):
    """QTextEditWrapper."""
    w = self.widget
    i = self.toPythonIndex(i)
    cursor = w.textCursor()
    try:
        self.changingText = True  # Disable onTextChanged.
        cursor.setPosition(i)
        cursor.insertText(s)
        w.setTextCursor(cursor)  # Bug fix: 2010/01/27
    finally:
        self.changingText = False
#@+node:ekr.20110605121601.18077: *8* qtew.leoMoveCursorHelper & helper
def leoMoveCursorHelper(self, kind, extend=False, linesPerPage=15):
    """QTextEditWrapper."""
    w = self.widget
    tc = QtGui.QTextCursor
    d = {
        'begin-line': tc.StartOfLine,  # Was start-line
        'down': tc.Down,
        'end': tc.End,
        'end-line': tc.EndOfLine,  # Not used.
        'exchange': True,  # Dummy.
        'home': tc.Start,
        'left': tc.Left,
        'page-down': tc.Down,
        'page-up': tc.Up,
        'right': tc.Right,
        'up': tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = tc.KeepAnchor if extend else tc.MoveAnchor
    if not op:
        g.trace(f"can not happen: bad kind: {kind}")
        return
    if kind in ('page-down', 'page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange':  # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos, tc.MoveAnchor)
        cursor.setPosition(anchor, tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op, mode)
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    # #218.
    cursor = w.textCursor()
    sel = cursor.selection().toPlainText()
    if sel and hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(sel)
    self.c.frame.updateStatusLine()
#@+node:btheado.20120129145543.8180: *9* qtew.pageUpDown
def pageUpDown(self, op, moveMode):
    """
    The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
    and not externally accessible. Since Leo has its own keyhandling
    functionality, this code emulates the QTextEdit paging. This is a
    straight port of the C++ code found in the pageUpDown method of
    gui/widgets/qtextedit.cpp.
    """
    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
#@+node:ekr.20110605121601.18087: *8* qtew.linesPerPage
def linesPerPage(self):
    """QTextEditWrapper."""
    # Not used in Leo's core.
    w = self.widget
    h = w.size().height()
    lineSpacing = w.fontMetrics().lineSpacing()
    n = h / lineSpacing
    return n
#@+node:ekr.20110605121601.18088: *8* qtew.scrollDelegate
def scrollDelegate(self, kind):
    """
    Scroll a QTextEdit up or down one page.
    direction is in ('down-line','down-page','up-line','up-page')
    """
    c = self.c
    w = self.widget
    vScroll = w.verticalScrollBar()
    h = w.size().height()
    lineSpacing = w.fontMetrics().lineSpacing()
    n = h / lineSpacing
    n = max(2, n - 3)
    if kind == 'down-half-page': delta = n / 2
    elif kind == 'down-line': delta = 1
    elif kind == 'down-page': delta = n
    elif kind == 'up-half-page': delta = -n / 2
    elif kind == 'up-line': delta = -1
    elif kind == 'up-page': delta = -n
    else:
        delta = 0
        g.trace('bad kind:', kind)
    val = vScroll.value()
    vScroll.setValue(val + (delta * lineSpacing))
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18090: *8* qtew.see & seeInsertPoint
def see(self, i):
    """Make sure position i is visible."""
    w = self.widget
    w.ensureCursorVisible()

def seeInsertPoint(self):
    """Make sure the insert point is visible."""
    self.widget.ensureCursorVisible()
#@+node:ekr.20110605121601.18092: *8* qtew.setAllText
def setAllText(self, s):
    """Set the text of body pane."""
    w = self.widget
    try:
        self.changingText = True  # Disable onTextChanged.
        w.setReadOnly(False)
        w.setPlainText(s)
    finally:
        self.changingText = False
#@+node:ekr.20110605121601.18095: *8* qtew.setInsertPoint
def setInsertPoint(self, i, s=None):
    # Fix bug 981849: incorrect body content shown.
    # Use the more careful code in setSelectionRange.
    self.setSelectionRange(i=i, j=i, insert=i, s=s)
#@+node:ekr.20110605121601.18096: *8* qtew.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    """Set the selection range and the insert point."""
    #
    # Part 1
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    if s is None:
        s = self.getAllText()
    n = len(s)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        ins = max(i, j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0, min(ins, n))
    #
    # Part 2:
    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j, tc.KeepAnchor)
    elif ins == i:
        # Put the insert point at i
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    else:
        # 2014/08/21: It doesn't seem possible to put the insert point somewhere else!
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    w.setTextCursor(tc)
    # #218.
    if hasattr(g.app.gui, 'setClipboardSelection'):
        if s[i:j]:
            g.app.gui.setClipboardSelection(s[i:j])
    #
    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v  # Always accurate.
    v.insertSpot = ins
    if i > j: i, j = j, i
    assert(i <= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = w.verticalScrollBar().value()
#@+node:ekr.20141103061944.40: *8* qtew.setXScrollPosition
def setXScrollPosition(self, pos):
    """Set the position of the horizonatl scrollbar."""
    if pos is not None:
        w = self.widget
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18098: *8* qtew.setYScrollPosition
def setYScrollPosition(self, pos):
    """Set the vertical scrollbar position."""
    if pos is not None:
        w = self.widget
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18100: *8* qtew.toPythonIndex
def toPythonIndex(self, index, s=None):
    """This is much faster than versions using g.toPythonIndex."""
    w = self
    te = self.widget
    if index is None:
        return 0
    if isinstance(index, int):
        return index
    if index == '1.0':
        return 0
    if index == 'end':
        return w.getLastPosition()
    doc = te.document()
    data = index.split('.')
    if len(data) == 2:
        row, col = data
        row, col = int(row), int(col)
        bl = doc.findBlockByNumber(row - 1)
        return bl.position() + col
    g.trace(f"bad string index: {index}")
    return 0
#@+node:ekr.20110605121601.18101: *8* qtew.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    w = self
    if index == '1.0':
        return 0, 0, 0
    if index == 'end':
        index = w.getLastPosition()
    te = self.widget
    doc = te.document()
    i = w.toPythonIndex(index)
    bl = doc.findBlock(i)
    row = bl.blockNumber()
    col = i - bl.position()
    return i, row, col
#@+node:ekr.20140907131341.18707: *5* @file ../plugins/qt_tree.py
@first # -*- coding: utf-8 -*-
"""Leo's Qt tree class."""
<< imports >>
@others
@language python
@tabwidth -4
@pagewidth 80
#@+node:ekr.20140907131341.18709: *6* << imports >> (qt_tree.py)
import leo.core.leoGlobals as g
import leo.core.leoFrame as leoFrame
import leo.core.leoNodes as leoNodes
import leo.core.leoPlugins as leoPlugins  # Uses leoPlugins.TryNext.
import leo.plugins.qt_text as qt_text
from leo.core.leoQt import QtConst, QtCore, QtGui, QtWidgets
import re
import time
assert time
#@+node:ekr.20160514120051.1: *6* class LeoQtTree
class LeoQtTree(leoFrame.LeoTree):
    """Leo Qt tree class"""
    @others
#@+node:ekr.20110605121601.18404: *7* qtree.Birth
#@+node:ekr.20110605121601.18405: *8* qtree.__init__
def __init__(self, c, frame):
    """Ctor for the LeoQtTree class."""
    super().__init__(frame)
    self.c = c
    # Widget independent status ivars...
    self.prev_v = None
    self.redrawCount = 0  # Count for debugging.
    self.revertHeadline = None  # Previous headline text for abortEditLabel.
    self.busy = False
    # Debugging...
    self.traceCallersFlag = False  # Enable traceCallers method.
    # Associating items with position and vnodes...
    self.items = []
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.nodeIconsDict = {} # keys are gnx, values are declutter generated icons
    self.position2itemDict = {}
    self.vnode2itemsDict = {}  # values are lists of items.
    self.editWidgetsDict = {}  # keys are native edit widgets, values are wrappers.
    self.reloadSettings()
    # Components.
    self.canvas = self  # An official ivar used by Leo's core.
    self.headlineWrapper = qt_text.QHeadlineWrapper  # This is a class.
    self.treeWidget = w = frame.top.treeWidget  # An internal ivar.
        # w is a LeoQTreeWidget, a subclass of QTreeWidget.
    #
    # "declutter", node appearance tweaking
    self.declutter_patterns = None  # list of pairs of patterns for decluttering
    self.declutter_data = {}
    self.loaded_images = {}
    if 0:  # Drag and drop
        w.setDragEnabled(True)
        w.viewport().setAcceptDrops(True)
        w.showDropIndicator = True
        w.setAcceptDrops(True)
        w.setDragDropMode(w.InternalMove)
        if 1:  # Does not work

            def dropMimeData(self, data, action, row, col, parent):
                g.trace()

            # w.dropMimeData = dropMimeData

            def mimeData(self, indexes):
                g.trace()

    # Early inits...

    try:
        w.headerItem().setHidden(True)
    except Exception:
        pass
    n = c.config.getInt('icon-height') or 16
    w.setIconSize(QtCore.QSize(160, n))
#@+node:ekr.20110605121601.17866: *8* qtree.get_name
def getName(self):
    """Return the name of this widget: must start with "canvas"."""
    return 'canvas(tree)'
#@+node:ekr.20110605121601.18406: *8* qtree.initAfterLoad
def initAfterLoad(self):
    """Do late-state inits."""
    # Called by Leo's core.
    c = self.c
    # w = c.frame.top
    tw = self.treeWidget
    tw.itemDoubleClicked.connect(self.onItemDoubleClicked)
    tw.itemClicked.connect(self.onItemClicked)
    tw.itemSelectionChanged.connect(self.onTreeSelect)
    tw.itemCollapsed.connect(self.onItemCollapsed)
    tw.itemExpanded.connect(self.onItemExpanded)
    tw.customContextMenuRequested.connect(self.onContextMenu)
    # tw.onItemChanged.connect(self.onItemChanged)
    g.app.gui.setFilter(c, tw, self, tag='tree')
    # 2010/01/24: Do not set this here.
    # The read logic sets c.changed to indicate nodes have changed.
    # c.clearChanged()
#@+node:ekr.20110605121601.17871: *8* qtree.reloadSettings
def reloadSettings(self):
    """LeoQtTree."""
    c = self.c
    self.auto_edit = c.config.getBool('single-click-auto-edits-headline', False)
    self.enable_drag_messages = c.config.getBool("enable-drag-messages")
    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_declutter = c.config.getBool('tree-declutter', default=False)
#@+node:ekr.20110605121601.17940: *8* qtree.wrapQLineEdit
def wrapQLineEdit(self, w):
    """A wretched kludge for MacOs k.masterMenuHandler."""
    c = self.c
    if isinstance(w, QtWidgets.QLineEdit):
        wrapper = self.edit_widget(c.p)
    else:
        wrapper = w
    return wrapper
#@+node:ekr.20110605121601.17868: *7* qtree.Debugging & tracing
def error(self, s):
    if not g.app.unitTesting:
        g.trace('LeoQtTree Error: ', s, g.callers())

def traceItem(self, item):
    if item:
        # A QTreeWidgetItem.
        return f"item {id(item)}: {self.getItemText(item)}"
    return '<no item>'

def traceCallers(self):
    if self.traceCallersFlag:
        return g.callers(5, excludeCaller=True)
    return ''
#@+node:ekr.20110605121601.17872: *7* qtree.Drawing
#@+node:ekr.20110605121601.18408: *8* qtree.clear
def clear(self):
    """Clear all widgets in the tree."""
    w = self.treeWidget
    w.clear()
#@+node:ekr.20180810052056.1: *8* qtree.drawVisible & helpers (not used)
def drawVisible(self, p):
    """
    Add only the visible nodes to the outline.
    
    Not used, as this causes scrolling issues.
    """
    t1 = time.process_time()
    c = self.c
    parents = []
    # Clear the widget.
    w = self.treeWidget
    w.clear()
    # Clear the dicts.
    self.initData()
    if c.hoistStack:
        first_p = c.hoistStack[-1].p
        target_p = first_p.nodeAfterTree().visBack(c)
    else:
        first_p = c.rootPosition()
        target_p = None
    n = 0
    for p in self.yieldVisible(first_p, target_p):
        n += 1
        level = p.level()
        parent_item = w if level == 0 else parents[level - 1]
        item = QtWidgets.QTreeWidgetItem(parent_item)
        item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
        item.setChildIndicatorPolicy(
            item.ShowIndicator if p.hasChildren()
            else item.DontShowIndicator)
        item.setExpanded(bool(p.hasChildren() and p.isExpanded()))
        self.items.append(item)
        # Update parents.
        parents = [] if level == 0 else parents[:level]
        parents.append(item)
        # Update the dicts.
        itemHash = self.itemHash(item)
        self.item2positionDict[itemHash] = p.copy()
        self.item2vnodeDict[itemHash] = p.v
        self.position2itemDict[p.key()] = item
        d = self.vnode2itemsDict
        v = p.v
        aList = d.get(v, [])
        aList.append(item)
        d[v] = aList
        # Enter the headline.
        item.setText(0, p.h)
        if self.use_declutter:
            item._real_text = p.h
        # Draw the icon.
        v.iconVal = v.computeIcon()
        icon = self.getCompositeIconImage(p, v.iconVal)
        if icon:
            self.setItemIcon(item, icon)
        # Set current item.
        if p == c.p:
            w.setCurrentItem(item)
    # Useful, for now.
    t2 = time.process_time()
    if t2 - t1 > 0.1:
        g.trace(f"{n} nodes, {t2 - t1:5.2f} sec")
#@+node:ekr.20180810052056.2: *9* qtree.yieldVisible (not used)
def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) > 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) <= 1 and (v.statusBits & v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 < len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 < len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
#@+node:ekr.20180810052056.3: *9* qtree.slowYieldVisible
def slowYieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    while p:
        yield p
        if p == target_p:
            return
        p.moveToVisNext(c)
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
#@+node:ekr.20110605121601.17873: *8* qtree.full_redraw & helpers
def full_redraw(self, p=None):
    """
    Redraw all visible nodes of the tree.
    Preserve the vertical scrolling unless scroll is True.
    """
    c = self.c
    if g.app.disable_redraw:
        return None
    if self.busy:
        return None
    # Cancel the delayed redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.currentPosition()
    elif c.hoistStack and p.h.startswith('@chapter') and p.hasChildren():
        # Make sure the current position is visible.
        # Part of fix of bug 875323: Hoist an @chapter node leaves a non-visible node selected.
        p = p.firstChild()
        c.frame.tree.select(p)
        c.setCurrentPosition(p)
    else:
        c.setCurrentPosition(p)
    assert not self.busy, g.callers()
    self.redrawCount += 1
    self.initData()
    try:
        self.busy = True
        self.drawTopTree(p)
    finally:
        self.busy = False
    self.setItemForCurrentPosition()
    return p  # Return the position, which may have changed.

# Compatibility

redraw = full_redraw
redraw_now = full_redraw
#@+node:vitalije.20200329160945.1: *9* tree declutter code
#@+node:tbrown.20150807090639.1: *10* qtree.declutter_node & helpers
def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    
    returns composite icon for this node
    """
    dd = self.declutter_data
    iconVal = p.v.computeIcon()
    iconName = f'box{iconVal:02d}.png'
    loaded_images = self.loaded_images
    @others
    if (p.h, iconVal) in dd:
        text, new_icons = dd[(p.h, iconVal)]
        item.setText(0, text)
        new_icons = sorted_icons(p) + new_icons
    else:
        text = p.h
        new_icons = []
        for pattern, cmds in self.get_declutter_patterns():
            m = pattern.match(text) or pattern.search(text)
            if m:
                apply_declutter_rules(cmds)
        dd[(p.h, iconVal)] = item.text(0), new_icons
        new_icons = sorted_icons(p) + new_icons
        preload_images()
    self.nodeIconsDict[p.gnx] = new_icons
    h = ':'.join(new_icons)
    icon = g.app.gui.iconimages.get(h)
    if not icon:
        preload_images()
        images = [loaded_images.get(x) for x in new_icons]
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
#@+node:vitalije.20200329153544.1: *11* sorted_icons
def sorted_icons(p):
    '''
    Returns a list of icon filenames for this node.
    The list is sorted to owner the 'where' key of image dicts.
    '''
    icons = c.editCommands.getIconList(p)
    a = [x['file'] for x in icons if x['where'] == 'beforeIcon']
    a.append(iconName)
    a.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
    return a
#@+node:ekr.20171122064635.1: *11* declutter_replace
def declutter_replace(arg, cmd):
    """
    Execute cmd and return True if cmd is any replace command.
    """
    # pylint: disable=undefined-loop-variable
    if cmd == 'REPLACE':
        s = pattern.sub(arg, text)
        item.setText(0, s)
        return True
    if cmd == 'REPLACE-HEAD':
        s = text[: m.start()]
        item.setText(0, s.rstrip())
        return True
    if cmd == 'REPLACE-TAIL':
        s = text[m.end() :]
        item.setText(0, s.lstrip())
        return True
    if cmd == 'REPLACE-REST':
        s = text[:m.start] + text[m.end() :]
        item.setText(0, s.strip())
        return True
    return False
#@+node:ekr.20171122055719.1: *11* declutter_style
def declutter_style(arg, cmd):
    """Handle style options."""
    arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
    if cmd == 'ICON':
        new_icons.append(arg)
    elif cmd == 'BG':
        item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FG':
        item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FONT':
        item.setFont(0, QtGui.QFont(arg))
    elif cmd == 'ITALIC':
        font = item.font(0)
        font.setItalic(bool(int(arg)))
        item.setFont(0, font)
    elif cmd == 'WEIGHT':
        arg = getattr(QtGui.QFont, arg, 75)
        font = item.font(0)
        font.setWeight(arg)
        item.setFont(0, font)
    elif cmd == 'PX':
        font = item.font(0)
        font.setPixelSize(int(arg))
        item.setFont(0, font)
    elif cmd == 'PT':
        font = item.font(0)
        font.setPointSize(int(arg))
        item.setFont(0, font)
#@+node:vitalije.20200327163522.1: *11* apply_declutter_rules
def apply_declutter_rules(cmds):
    """Applies all commands for the matched rule."""
    for cmd, arg in cmds:
        if not declutter_replace(arg, cmd):
            declutter_style(arg, cmd)
#@+node:vitalije.20200329162015.1: *11* preload_images
def preload_images():
    for f in new_icons:
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
#@+node:vitalije.20200327162532.1: *10* qtree.get_declutter_patterns
def get_declutter_patterns(self):
    "Initializes self.declutter_patterns from configuration and returns it"
    if self.declutter_patterns is not None:
        return self.declutter_patterns
    c = self.c
    patterns = []
    warned = False
    lines = c.config.getData("tree-declutter-patterns")
    for line in lines:
        try:
            cmd, arg = line.split(None, 1)
        except ValueError:
            # Allow empty arg, and guard against user errors.
            cmd = line.strip()
            arg = ''
        if cmd.startswith('#'):
            pass
        elif cmd == 'RULE':
            patterns.append((re.compile(arg), []))
        else:
            if patterns:
                patterns[-1][1].append((cmd, arg))
            elif not warned:
                warned = True
                g.log('Declutter patterns must start with RULE*',
                    color='error')
    self.declutter_patterns = patterns
    return patterns
#@+node:ekr.20110605121601.17874: *9* qtree.drawChildren
def drawChildren(self, p, parent_item):
    """Draw the children of p if they should be expanded."""
    if not p:
        g.trace('can not happen: no p')
        return
    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child, parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child, parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
#@+node:ekr.20110605121601.17875: *9* qtree.drawNode
def drawNode(self, p, parent_item):
    """Draw the node p."""
    c = self.c
    v = p.v
    # Allocate the QTreeWidgetItem.
    item = self.createTreeItem(p, parent_item)
    #
    # Update the data structures.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy()  # was item
    self.item2vnodeDict[itemHash] = v  # was item
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item not in aList:
        aList.append(item)
    d[v] = aList
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)
    # #1310: Add a tool tip.
    item.setToolTip(0, p.h)
    if self.use_declutter:
        icon = self.declutter_node(c, p, item)
        if icon:
            item.setIcon(0, icon)
        return item
    # Draw the icon.
    v.iconVal = v.computeIcon()
    icon = self.getCompositeIconImage(p, v.iconVal)
        # **Slow**, but allows per-vnode icons.
    if icon:
        item.setIcon(0, icon)
    return item
#@+node:ekr.20110605121601.17876: *9* qtree.drawTopTree
def drawTopTree(self, p):
    """Draw the tree rooted at p."""
    trace = 'drawing' in g.app.debug and not g.unitTesting
    if trace:
        t1 = time.process_time()
    c = self.c
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    if trace:
        t2 = time.process_time()
        g.trace(f"{t2 - t1:5.2f} sec.", g.callers(5))
#@+node:ekr.20110605121601.17877: *9* qtree.drawTree
def drawTree(self, p, parent_item=None):
    if g.app.gui.isNullGui:
        return
    # Draw the (visible) parent node.
    item = self.drawNode(p, parent_item)
    # Draw all the visible children.
    self.drawChildren(p, parent_item=item)
#@+node:ekr.20110605121601.17878: *9* qtree.initData
def initData(self):
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
#@+node:ekr.20110605121601.17880: *8* qtree.redraw_after_contract
def redraw_after_contract(self, p):

    if self.busy:
        return
    self.update_expansion(p)
#@+node:ekr.20110605121601.17881: *8* qtree.redraw_after_expand
def redraw_after_expand(self, p):

    if 0:  # Does not work. Newly visible nodes do not show children correctly.
        c = self.c
        c.selectPosition(p)
        self.update_expansion(p)
    else:
        self.full_redraw(p)
            # Don't try to shortcut this!
#@+node:ekr.20110605121601.17882: *8* qtree.redraw_after_head_changed
def redraw_after_head_changed(self):

    if self.busy:
        return
    p = self.c.p
    if p:
        h = p.h  # 2010/02/09: Fix bug 518823.
        for item in self.vnode2items(p.v):
            if self.isValidItem(item):
                self.setItemText(item, h)
    # Bug fix: 2009/10/06
    self.redraw_after_icons_changed()
#@+node:ekr.20110605121601.17883: *8* qtree.redraw_after_icons_changed
def redraw_after_icons_changed(self):

    if self.busy:
        return
    self.redrawCount += 1  # To keep a unit test happy.
    c = self.c
    try:
        self.busy = True
            # Suppress call to setHeadString in onItemChanged!
        self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings(copy=False):
            # Updates icons in p and all visible descendants of p.
            self.updateVisibleIcons(p)
    finally:
        self.busy = False
#@+node:ekr.20110605121601.17884: *8* qtree.redraw_after_select
def redraw_after_select(self, p=None):
    """Redraw the entire tree when an invisible node is selected."""
    if self.busy:
        return
    self.full_redraw(p)
    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
#@+node:ekr.20140907201613.18986: *8* qtree.repaint (not used)
def repaint(self):
    """Repaint the widget."""
    w = self.treeWidget
    w.repaint()
    w.resizeColumnToContents(0)  # 2009/12/22
#@+node:ekr.20180817043619.1: *8* qtree.update_expansion
def update_expansion(self, p):
    """Update expansion bits for p, including all clones."""
    c = self.c
    w = self.treeWidget
    expand = c.shouldBeExpanded(p)
    if 'drawing' in g.app.debug:
        g.trace('expand' if expand else 'contract')
    item = self.position2itemDict.get(p.key())
    if p:
        try:
            # These generate events, which would trigger a full redraw.
            self.busy = True
            if expand:
                w.expandItem(item)
            else:
                w.collapseItem(item)
        finally:
            self.busy = False
        w.repaint()
    else:
        g.trace('NO P')
        c.redraw()
#@+node:ekr.20110605121601.17885: *7* qtree.Event handlers
#@+node:ekr.20110605121601.17887: *8*  qtree.Click Box
#@+node:ekr.20110605121601.17888: *9* qtree.onClickBoxClick
def onClickBoxClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook("boxclick1", c=c, p=p, event=event)
    g.doHook("boxclick2", c=c, p=p, event=event)
    c.outerUpdate()
#@+node:ekr.20110605121601.17889: *9* qtree.onClickBoxRightClick
def onClickBoxRightClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook("boxrclick1", c=c, p=p, event=event)
    g.doHook("boxrclick2", c=c, p=p, event=event)
    c.outerUpdate()
#@+node:ekr.20110605121601.17890: *9* qtree.onPlusBoxRightClick
def onPlusBoxRightClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook('rclick-popup', c=c, p=p, event=event, context_menu='plusbox')
    c.outerUpdate()
#@+node:ekr.20110605121601.17891: *8*  qtree.Icon Box
# For Qt, there seems to be no way to trigger these events.
#@+node:ekr.20110605121601.17892: *9* qtree.onIconBoxClick
def onIconBoxClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook("iconclick1", c=c, p=p, event=event)
    g.doHook("iconclick2", c=c, p=p, event=event)
    c.outerUpdate()
#@+node:ekr.20110605121601.17893: *9* qtree.onIconBoxRightClick
def onIconBoxRightClick(self, event, p=None):
    """Handle a right click in any outline widget."""
    if self.busy:
        return
    c = self.c
    g.doHook("iconrclick1", c=c, p=p, event=event)
    g.doHook("iconrclick2", c=c, p=p, event=event)
    c.outerUpdate()
#@+node:ekr.20110605121601.17894: *9* qtree.onIconBoxDoubleClick
def onIconBoxDoubleClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    if not p: p = c.p
    if not g.doHook("icondclick1", c=c, p=p, event=event):
        self.endEditLabel()
        self.OnIconDoubleClick(p)  # Call the method in the base class.
    g.doHook("icondclick2", c=c, p=p, event=event)
    c.outerUpdate()
#@+node:ekr.20110605121601.18437: *8* qtree.onContextMenu
def onContextMenu(self, point):
    """LeoQtTree: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.c, self.treeWidget
    g.app.gui.onContextMenu(c, w, point)
#@+node:ekr.20110605121601.17912: *8* qtree.onHeadChanged
# Tricky code: do not change without careful thought and testing.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None):
    """Officially change a headline."""
    c = self.c; u = c.undoer
    if not p:
        return
    item = self.getCurrentItem()
    if not item:
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        return
    s = e.text()
    self.closeEditorHelper(e, item)
    oldHead = p.h
    changed = s != oldHead
    if g.doHook("headkey1", c=c, p=c.p, v=c.p, s=s, changed=changed):
        return
    if changed:
        # New in Leo 4.10.1.
        << truncate s if it has multiple lines >>
        p.initHeadString(s)
        item.setText(0, s)  # Required to avoid full redraw.
        # #1310: update the tooltip.
        item.setToolTip(0, p.h)
        undoData = u.beforeChangeNodeContents(p, oldHead=oldHead)
        if not c.changed: c.setChanged()
        # We must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p)
        p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData, inHead=True)
    g.doHook("headkey2", c=c, p=c.p, v=c.p, s=s, changed=changed)
    # This is a crucial shortcut.
    if g.unitTesting: return
    if changed:
        self.redraw_after_head_changed()
    if 0:  # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    p.v.contentModified()
    c.outerUpdate()
#@+node:ekr.20120409185504.10028: *9* << truncate s if it has multiple lines >>
# Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[:-1]
# Warn if there are multiple lines.
i = s.find('\n')
if i > -1:
    s = s[:i]
    if s != oldHead:
        g.warning("truncating headline to one line")
limit = 1000
if len(s) > limit:
    s = s[:limit]
    if s != oldHead:
        g.warning("truncating headline to", limit, "characters")
#@+node:ekr.20110605121601.17896: *8* qtree.onItemClicked
def onItemClicked(self, item, col, auto_edit=False):
    """Handle a click in a BaseNativeTree widget item."""
    # This is called after an item is selected.
    if self.busy:
        return
    c = self.c
    try:
        self.busy = True
        p = self.item2position(item)
        if p:
            auto_edit = self.prev_v == p.v
                # Fix #1049.
            self.prev_v = p.v
            event = None
            #
            # Careful. We may have switched gui during unit testing.
            if hasattr(g.app.gui, 'qtApp'):
                mods = g.app.gui.qtApp.keyboardModifiers()
                isCtrl = bool(mods & QtConst.ControlModifier)
                # We could also add support for QtConst.ShiftModifier, QtConst.AltModifier
                # & QtConst.MetaModifier.
                if isCtrl:
                    if g.doHook("iconctrlclick1", c=c, p=p, event=event) is None:
                        c.frame.tree.OnIconCtrlClick(p)
                            # Call the base class method.
                    g.doHook("iconctrlclick2", c=c, p=p, event=event)
                else:
                    # 2014/02/21: generate headclick1/2 instead of iconclick1/2
                    g.doHook("headclick1", c=c, p=p, event=event)
                    g.doHook("headclick2", c=c, p=p, event=event)
        else:
            auto_edit = None
            g.trace('*** no p')
        # 2011/05/27: click here is like ctrl-g.
        c.k.keyboardQuit(setFocus=False)
        c.treeWantsFocus()  # 2011/05/08: Focus must stay in the tree!
        c.outerUpdate()
        # 2011/06/01: A second *single* click on a selected node
        # enters editing state.
        if auto_edit and self.auto_edit:
            e, wrapper = self.createTreeEditorForItem(item)
        # 2014/10/26: Reset find vars.
        c.findCommands.reset_state_ivars()
    finally:
        self.busy = False
#@+node:ekr.20110605121601.17895: *8* qtree.onItemCollapsed
def onItemCollapsed(self, item):

    if self.busy:
        return
    c = self.c
    p = self.item2position(item)
    if not p:
        self.error('no p')
        return
    # Do **not** set lockouts here.
    # Only methods that actually generate events should set lockouts.
    if p.isExpanded():
        p.contract()
        c.redraw_after_contract(p)
    self.select(p)
    c.outerUpdate()
#@+node:ekr.20110605121601.17897: *8* qtree.onItemDoubleClicked
def onItemDoubleClicked(self, item, col):
    """Handle a double click in a BaseNativeTree widget item."""
    if self.busy:  # Required.
        return
    c = self.c
    try:
        self.busy = True
        e, wrapper = self.createTreeEditorForItem(item)
        if not e:
            g.trace('*** no e')
        p = self.item2position(item)
    # 2011/07/28: End the lockout here, not at the end.
    finally:
        self.busy = False
    if not p:
        self.error('no p')
        return
    # 2014/02/21: generate headddlick1/2 instead of icondclick1/2.
    if g.doHook("headdclick1", c=c, p=p, event=None) is None:
        c.frame.tree.OnIconDoubleClick(p)  # Call the base class method.
    g.doHook("headclick2", c=c, p=p, event=None)
    c.outerUpdate()
#@+node:ekr.20110605121601.17898: *8* qtree.onItemExpanded
def onItemExpanded(self, item):
    """Handle and tree-expansion event."""
    if self.busy:  # Required
        return
    c = self.c
    p = self.item2position(item)
    if not p:
        self.error('no p')
        return
    # Do **not** set lockouts here.
    # Only methods that actually generate events should set lockouts.
    if not p.isExpanded():
        p.expand()
        c.redraw_after_expand(p)
    self.select(p)
    c.outerUpdate()
#@+node:ekr.20110605121601.17899: *8* qtree.onTreeSelect
def onTreeSelect(self):
    """Select the proper position when a tree node is selected."""
    if self.busy:  # Required
        return
    c = self.c
    item = self.getCurrentItem()
    p = self.item2position(item)
    if not p:
        self.error(f"no p for item: {item}")
        return
    # Do **not** set lockouts here.
    # Only methods that actually generate events should set lockouts.
    self.select(p)
        # This is a call to LeoTree.select(!!)
    c.outerUpdate()
#@+node:ekr.20110605121601.17900: *8* qtree.OnPopup & allies
def OnPopup(self, p, event):
    """Handle right-clicks in the outline.

    This is *not* an event handler: it is called from other event handlers."""
    # Note: "headrclick" hooks handled by VNode callback routine.
    if event:
        c = self.c
        c.setLog()
        if not g.doHook("create-popup-menu", c=c, p=p, event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items", c=c, p=p, event=event):
            self.enablePopupMenuItems(p, event)
        if not g.doHook("show-popup-menu", c=c, p=p, event=event):
            self.showPopupMenu(event)
    return "break"
#@+node:ekr.20110605121601.17901: *9* qtree.OnPopupFocusLost
@language rest
@
On Linux we must do something special to make the popup menu "unpost" if the
mouse is clicked elsewhere. So we have to catch the <FocusOut> event and
explicitly unpost. In order to process the <FocusOut> event, we need to be able
to find the reference to the popup window again, so this needs to be an
attribute of the tree object; hence, "self.popupMenu".

Aside: though Qt tries to be muli-platform, the interaction with different
window managers does cause small differences that will need to be compensated by
system specific application code. :-(
@c
@language python

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self, event=None):
    # self.popupMenu.unpost()
    pass
#@+node:ekr.20110605121601.17902: *9* qtree.createPopupMenu
def createPopupMenu(self, event):
    """This might be a placeholder for plugins.  Or not :-)"""
#@+node:ekr.20110605121601.17903: *9* qtree.enablePopupMenuItems
def enablePopupMenuItems(self, p, event):
    """Enable and disable items in the popup menu."""
#@+node:ekr.20110605121601.17904: *9* qtree.showPopupMenu
def showPopupMenu(self, event):
    """Show a popup menu."""
#@+node:ekr.20110605121601.17944: *7* qtree.Focus
def getFocus(self):
    return g.app.gui.get_focus(self.c)  # Bug fix: 2009/6/30

findFocus = getFocus

def setFocus(self):
    g.app.gui.set_focus(self.c, self.treeWidget)
#@+node:ekr.20110605121601.18409: *7* qtree.Icons
#@+node:ekr.20110605121601.18410: *8* qtree.drawIcon
def drawIcon(self, p):
    """Redraw the icon at p."""
    return self.updateIcon(p)
    # the following code is wrong. It constructs a new item
    # and assignes the icon to it. However this item is never
    # added to the treeWidget so it is soon garbage collected
        # w = self.treeWidget
        # itemOrTree = self.position2item(p) or w
        # item = QtWidgets.QTreeWidgetItem(itemOrTree)
        # icon = self.getIcon(p)
        # self.setItemIcon(item, icon)
#@+node:ekr.20110605121601.18411: *8* qtree.getIcon & helper
def getIcon(self, p):
    """Return the proper icon for position p."""
    if self.use_declutter:
        item = self.position2item(p)
        return item and self.declutter_node(self.c, p, item)
    p.v.iconVal = iv = p.v.computeIcon()
    return self.getCompositeIconImage(p, iv)


#@+node:vitalije.20200329153148.1: *9* qtree.icon_filenames_for_node
def icon_filenames_for_node(self, p, val):
    '''Prepares and returns a list of icon filenames
       related to this node.
    '''
    nicon = f'box{val:02d}.png'
    fnames = self.nodeIconsDict.get(p.gnx)
    if not fnames:
        icons = self.c.editCommands.getIconList(p)
        fnames = [x['file'] for x in icons if x['where'] == 'beforeIcon']
        fnames.append(nicon)
        fnames.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
        self.nodeIconsDict[p.gnx] = fnames
    pat = re.compile(r'^box\d\d\.png$')
    loaded_images = self.loaded_images
    for i, f in enumerate(fnames):
        if pat.match(f):
            fnames[i] = nicon
            self.nodeIconsDict[p.gnx] = fnames
            f = nicon
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
    return fnames
#@+node:vitalije.20200329153154.1: *9* qtree.make_composite_icon
def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
#@+node:ekr.20110605121601.18412: *9* qtree.getCompositeIconImage
def getCompositeIconImage(self, p, val):
    """Get the icon at position p."""
    fnames = self.icon_filenames_for_node(p, val)
    h = ':'.join(fnames)
    icon = g.app.gui.iconimages.get(h)
    loaded_images = self.loaded_images
    images = list(map(loaded_images.get, fnames))
    if not icon:
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
#@+node:ekr.20110605121601.17950: *8* qtree.setItemIcon
def setItemIcon(self, item, icon):

    valid = item and self.isValidItem(item)
    if icon and valid:
        # Important: do not set lockouts here.
        # This will generate changed events,
        # but there is no itemChanged event handler.
        item.setIcon(0, icon)

#@+node:ekr.20110605121601.17951: *8* qtree.updateIcon
def updateIcon(self, p, force=False):
    """Update p's icon."""
    if not p: return
    val = p.v.computeIcon()
    # The force arg is needed:
    # Leo's core may have updated p.v.iconVal.
    if not force:
        if p.v.iconVal == val:
            return
    else:
        self.nodeIconsDict.pop(p.gnx, None)
        icon = self.getIcon(p)  # sets p.v.iconVal
        # Update all cloned items.
        items = self.vnode2items(p.v)
        # if not items: g.trace(f'no-items for {p.h}[{p.gnx}]')
        for item in items:
            self.setItemIcon(item, icon)
#@+node:ekr.20110605121601.17952: *8* qtree.updateVisibleIcons
def updateVisibleIcons(self, p):
    """Update the icon for p and the icons
    for all visible descendants of p."""
    self.updateIcon(p, force=True)
    if p.hasChildren() and p.isExpanded():
        for child in p.children():
            self.updateVisibleIcons(child)
#@+node:ekr.20110605121601.18414: *7* qtree.Items
#@+node:ekr.20110605121601.17943: *8*  qtree.item dict getters
def itemHash(self, item):
    return f"{repr(item)} at {str(id(item))}"

def item2position(self, item):
    itemHash = self.itemHash(item)
    p = self.item2positionDict.get(itemHash)  # was item
    return p

def item2vnode(self, item):
    itemHash = self.itemHash(item)
    return self.item2vnodeDict.get(itemHash)  # was item

def position2item(self, p):
    item = self.position2itemDict.get(p.key())
    return item

def vnode2items(self, v):
    return self.vnode2itemsDict.get(v, [])

def isValidItem(self, item):
    itemHash = self.itemHash(item)
    return itemHash in self.item2vnodeDict  # was item.
#@+node:ekr.20110605121601.18415: *8* qtree.childIndexOfItem
def childIndexOfItem(self, item):
    parent = item and item.parent()
    if parent:
        n = parent.indexOfChild(item)
    else:
        w = self.treeWidget
        n = w.indexOfTopLevelItem(item)
    return n
#@+node:ekr.20110605121601.18416: *8* qtree.childItems
def childItems(self, parent_item):
    """
    Return the list of child items of the parent item,
    or the top-level items if parent_item is None.
    """
    if parent_item:
        n = parent_item.childCount()
        items = [parent_item.child(z) for z in range(n)]
    else:
        w = self.treeWidget
        n = w.topLevelItemCount()
        items = [w.topLevelItem(z) for z in range(n)]
    return items
#@+node:ekr.20110605121601.18417: *8* qtree.closeEditorHelper
def closeEditorHelper(self, e, item):
    'End editing of the underlying QLineEdit widget for the headline.' ''
    w = self.treeWidget
    if e:
        w.closeEditor(e, QtWidgets.QAbstractItemDelegate.NoHint)
        try:
            # work around https://bugs.launchpad.net/leo-editor/+bug/1041906
            # underlying C/C++ object has been deleted
            w.setItemWidget(item, 0, None)
                # Make sure e is never referenced again.
            w.setCurrentItem(item)
        except RuntimeError:
            if 1:  # Testing.
                g.es_exception()
            else:
                # Recover silently even if there is a problem.
                pass
#@+node:ekr.20110605121601.18418: *8* qtree.connectEditorWidget & helper
def connectEditorWidget(self, e, item):
    if not e:
        return g.trace('can not happen: no e')
    # Hook up the widget.
    wrapper = self.getWrapper(e, item)

    def editingFinishedCallback(e=e, item=item, self=self, wrapper=wrapper):
        c = self.c
        w = self.treeWidget
        self.onHeadChanged(p=c.p, e=e)
        w.setCurrentItem(item)

    e.editingFinished.connect(editingFinishedCallback)
    return wrapper  # 2011/02/12
#@+node:ekr.20110605121601.18419: *8* qtree.contractItem & expandItem
def contractItem(self, item):
    self.treeWidget.collapseItem(item)

def expandItem(self, item):
    self.treeWidget.expandItem(item)
#@+node:ekr.20110605121601.18420: *8* qtree.createTreeEditorForItem
def createTreeEditorForItem(self, item):

    w = self.treeWidget
    w.setCurrentItem(item)  # Must do this first.
    if self.use_declutter:
        item.setText(0, item._real_text)
    w.editItem(item)
    e = w.itemWidget(item, 0)
    e.setObjectName('headline')
    wrapper = self.connectEditorWidget(e, item)
    self.sizeTreeEditor(self.c, e)
    return e, wrapper
#@+node:ekr.20110605121601.18421: *8* qtree.createTreeItem
def createTreeItem(self, p, parent_item):

    w = self.treeWidget
    itemOrTree = parent_item or w
    item = QtWidgets.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable | item.DontShowIndicatorWhenChildless)
    try:
        g.visit_tree_item(self.c, p, item)
    except leoPlugins.TryNext:
        pass
    #print "item",item
    return item
#@+node:ekr.20110605121601.18422: *8* qtree.editLabelHelper
def editLabelHelper(self, item, selectAll=False, selection=None):
    """
    Help nativeTree.editLabel do gui-specific stuff.
    """
    c, vc = self.c, self.c.vimCommands
    w = self.treeWidget
    w.setCurrentItem(item)
        # Must do this first.
        # This generates a call to onTreeSelect.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item, 0)  # A QLineEdit.
    if e:
        s = e.text(); len_s = len(s)
        if s == 'newHeadline': selectAll = True
        if selection:
            # pylint: disable=unpacking-non-sequence
            # Fix bug https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
            # Note: negative lengths are allowed.
            i, j, ins = selection
            if ins is None:
                start, n = i, abs(i - j)
                # This case doesn't happen for searches.
            elif ins == j:
                start, n = i, j - i
            else:
                start = start, n = j, i - j
        elif selectAll: start, n, ins = 0, len_s, len_s
        else: start, n, ins = len_s, 0, len_s
        e.setObjectName('headline')
        e.setSelection(start, n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        wrapper = self.connectEditorWidget(e, item)  # Hook up the widget.
        if vc and c.vim_mode:  #  and selectAll
            # For now, *always* enter insert mode.
            if vc.is_text_wrapper(wrapper):
                vc.begin_insert_mode(w=wrapper)
            else:
                g.trace('not a text widget!', wrapper)
    return e, wrapper
#@+node:ekr.20110605121601.18423: *8* qtree.getCurrentItem
def getCurrentItem(self):
    w = self.treeWidget
    return w.currentItem()
#@+node:ekr.20110605121601.18424: *8* qtree.getItemText
def getItemText(self, item):
    """Return the text of the item."""
    return item.text(0) if item else '<no item>'
#@+node:ekr.20110605121601.18425: *8* qtree.getParentItem
def getParentItem(self, item):
    return item and item.parent()
#@+node:ekr.20110605121601.18426: *8* qtree.getSelectedItems
def getSelectedItems(self):
    w = self.treeWidget
    return w.selectedItems()
#@+node:ekr.20110605121601.18427: *8* qtree.getTreeEditorForItem
def getTreeEditorForItem(self, item):
    """Return the edit widget if it exists.
    Do *not* create one if it does not exist.
    """
    w = self.treeWidget
    e = w.itemWidget(item, 0)
    return e
#@+node:ekr.20110605121601.18428: *8* qtree.getWrapper
def getWrapper(self, e, item):
    """Return headlineWrapper that wraps e (a QLineEdit)."""
    c = self.c
    if e:
        wrapper = self.editWidgetsDict.get(e)
        if wrapper:
            pass
        else:
            if item:
                # 2011/02/12: item can be None.
                wrapper = self.headlineWrapper(c, item, name='head', widget=e)
                self.editWidgetsDict[e] = wrapper
        return wrapper
    g.trace('no e')
    return None
#@+node:ekr.20110605121601.18429: *8* qtree.nthChildItem
def nthChildItem(self, n, parent_item):
    children = self.childItems(parent_item)
    if n < len(children):
        item = children[n]
    else:
        # This is **not* an error.
        # It simply means that we need to redraw the tree.
        item = None
    return item
#@+node:ekr.20110605121601.18430: *8* qtree.scrollToItem
def scrollToItem(self, item):
    """
    Scroll the tree widget so that item is visible.
    Leo's core no longer calls this method.
    """
    w = self.treeWidget
    hPos, vPos = self.getScroll()
    w.scrollToItem(item, w.EnsureVisible)
        # Fix #265: Erratic scrolling bug.
        # w.PositionAtCenter causes unwanted scrolling.
    self.setHScroll(0)
        # Necessary
#@+node:ekr.20110605121601.18431: *8* qtree.setCurrentItemHelper
def setCurrentItemHelper(self, item):
    w = self.treeWidget
    w.setCurrentItem(item)
#@+node:ekr.20110605121601.18432: *8* qtree.setItemText
def setItemText(self, item, s):
    if item:
        item.setText(0, s)
        if self.use_declutter:
            item._real_text = s
#@+node:tbrown.20160406221505.1: *8* qtree.sizeTreeEditor
@staticmethod
def sizeTreeEditor(c, editor):
    """Size a QLineEdit in a tree headline so scrolling occurs"""
    # space available in tree widget
    space = c.frame.tree.treeWidget.size().width()
    # left hand edge of editor within tree widget
    used = editor.geometry().x() + 4  # + 4 for edit cursor
    # limit width to available space
    editor.resize(space - used, editor.size().height())
#@+node:ekr.20110605121601.18433: *7* qtree.Scroll bars
#@+node:ekr.20110605121601.18434: *8* qtree.getSCroll
def getScroll(self):
    """Return the hPos,vPos for the tree's scrollbars."""
    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    vScroll = w.verticalScrollBar()
    hPos = hScroll.sliderPosition()
    vPos = vScroll.sliderPosition()
    return hPos, vPos
#@+node:btheado.20111110215920.7164: *8* qtree.scrollDelegate
def scrollDelegate(self, kind):
    """
    Scroll a QTreeWidget up or down or right or left.
    kind is in ('down-line','down-page','up-line','up-page', 'right', 'left')
    """
    c = self.c; w = self.treeWidget
    if kind in ('left', 'right'):
        hScroll = w.horizontalScrollBar()
        if kind == 'right':
            delta = hScroll.pageStep()
        else:
            delta = -hScroll.pageStep()
        hScroll.setValue(hScroll.value() + delta)
    else:
        vScroll = w.verticalScrollBar()
        h = w.size().height()
        lineSpacing = w.fontMetrics().lineSpacing()
        n = h / lineSpacing
        if kind == 'down-half-page': delta = n / 2
        elif kind == 'down-line': delta = 1
        elif kind == 'down-page': delta = n
        elif kind == 'up-half-page': delta = -n / 2
        elif kind == 'up-line': delta = -1
        elif kind == 'up-page': delta = -n
        else:
            delta = 0
            g.trace('bad kind:', kind)
        val = vScroll.value()
        vScroll.setValue(val + delta)
    c.treeWantsFocus()
#@+node:ekr.20110605121601.18435: *8* qtree.setH/VScroll
def setHScroll(self, hPos):

    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    hScroll.setValue(hPos)

def setVScroll(self, vPos):

    w = self.treeWidget
    vScroll = w.verticalScrollBar()
    vScroll.setValue(vPos)
#@+node:ekr.20110605121601.17905: *7* qtree.Selecting & editing
#@+node:ekr.20110605121601.17908: *8* qtree.edit_widget
def edit_widget(self, p):
    """Returns the edit widget for position p."""
    item = self.position2item(p)
    if item:
        e = self.getTreeEditorForItem(item)
        if e:
            # Create a wrapper widget for Leo's core.
            w = self.getWrapper(e, item)
            return w
        # This is not an error
        # But warning: calling this method twice might not work!
        return None
    return None
#@+node:ekr.20110605121601.17909: *8* qtree.editLabel
def editLabel(self, p, selectAll=False, selection=None):
    """Start editing p's headline."""
    if self.busy:
        return None
    c = self.c
    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.
    item = self.position2item(p)
    if item:
        if self.use_declutter:
            item.setText(0, item._real_text)
        e, wrapper = self.editLabelHelper(item, selectAll, selection)
    else:
        e, wrapper = None, None
        self.error(f"no item for {p}")
    if e:
        self.sizeTreeEditor(c, e)
        # A nice hack: just set the focus request.
        c.requestedFocusWidget = e
    return e, wrapper
#@+node:ekr.20110605121601.17910: *8* qtree.editPosition (no longer used)
# def editPosition(self):
    # c = self.c
    # p = c.currentPosition()
    # ew = self.edit_widget(p)
    # return p if ew else None
#@+node:ekr.20110605121601.17911: *8* qtree.endEditLabel
def endEditLabel(self):
    """Override LeoTree.endEditLabel.

    End editing of the presently-selected headline."""
    c = self.c; p = c.currentPosition()
    self.onHeadChanged(p)
#@+node:ekr.20110605121601.17915: *8* qtree.getSelectedPositions
def getSelectedPositions(self):
    items = self.getSelectedItems()
    pl = leoNodes.PosList(self.item2position(it) for it in items)
    return pl
#@+node:ekr.20110605121601.17914: *8* qtree.setHeadline
def setHeadline(self, p, s):
    """Force the actual text of the headline widget to p.h."""
    # This is used by unit tests to force the headline and p into alignment.
    if not p:
        return
    # Don't do this here: the caller should do it.
    # p.setHeadString(s)
    e = self.edit_widget(p)
    if e:
        e.setAllText(s)
    else:
        item = self.position2item(p)
        if item:
            self.setItemText(item, s)
#@+node:ekr.20110605121601.17913: *8* qtree.setItemForCurrentPosition
def setItemForCurrentPosition(self):
    """Select the item for c.p"""
    c = self.c; p = c.currentPosition()
    if self.busy:
        return None
    if not p:
        return None
    item = self.position2item(p)
    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        return None
    item2 = self.getCurrentItem()
    if item == item2:
        return item
    try:
        self.busy = True
        self.treeWidget.setCurrentItem(item)
            # This generates gui events, so we must use a lockout.
    finally:
        self.busy = False
    return item
#@+node:ekr.20190613080606.1: *8* qtree.unselectItem
def unselectItem(self, p):

    item = self.position2item(p)
    if item:
        item.setSelected(False)
#@+node:ekr.20110605121601.18002: *5* @file ../plugins/qtGui.py
"""qt gui plugin."""
@language python
@tabwidth -4
print('===== qtGui.py: this module is no longer used.')
#@+node:ekr.20161223152017.1: *5* @edit ../plugins/qt_quicksearch.py
@language python
# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'qt_quicksearch.ui'
#
# Created: Sat Mar 14 22:38:41 2009
#      by: PyQt4 UI code generator 4.4.2
#
# WARNING! All changes made in this file will be lost!

from leo.core.leoQt import isQt5, QtCore, QtWidgets  # QtGui,
QtGui = QtWidgets


class Ui_LeoQuickSearchWidget:

    def setupUi(self, LeoQuickSearchWidget):
        LeoQuickSearchWidget.setObjectName("LeoQuickSearchWidget")
        LeoQuickSearchWidget.resize(868, 572)
        self.verticalLayout_2 = QtGui.QVBoxLayout(LeoQuickSearchWidget)
        self.verticalLayout_2.setContentsMargins(0, 1, 0, 1)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtGui.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.lineEdit = QtGui.QLineEdit(LeoQuickSearchWidget)
        #self.lineEdit.setObjectName("lineEdit")
        self.lineEdit.setObjectName("lineEditNav")
        self.verticalLayout.addWidget(self.lineEdit)
        self.listWidget = QtGui.QListWidget(LeoQuickSearchWidget)
        self.listWidget.setObjectName("listWidget")
        self.verticalLayout.addWidget(self.listWidget)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.retranslateUi(LeoQuickSearchWidget)
        QtCore.QMetaObject.connectSlotsByName(LeoQuickSearchWidget)

    def retranslateUi(self, LeoQuickSearchWidget):
        # pylint: disable=no-member
        if isQt5:
            # QApplication.UnicodeUTF8 no longer exists.
            LeoQuickSearchWidget.setWindowTitle(
                QtWidgets.QApplication.translate("LeoQuickSearchWidget", "Form", None))
        else:
            LeoQuickSearchWidget.setWindowTitle(
                QtGui.QApplication.translate("LeoQuickSearchWidget", "Form",
                None, QtGui.QApplication.UnicodeUTF8))
#@+node:ekr.20161223152353.1: *5* @edit ../plugins/qt_quicksearch_sub.py
@language python
# Created: Wed Aug 26 08:43:59 2015
#      by: PyQt4 UI code generator 4.10.4
#
# WARNING! All changes made in this file will be lost!
#from PyQt4 import QtCore, QtGui
from leo.core.leoQt import isQt5, QtCore, QtWidgets  # QtGui,
QtGui = QtWidgets


class Ui_LeoQuickSearchWidget:

    def setupUi(self, LeoQuickSearchWidget):
        LeoQuickSearchWidget.setObjectName("LeoQuickSearchWidget")
        LeoQuickSearchWidget.resize(868, 572)
        self.verticalLayout_2 = QtGui.QVBoxLayout(LeoQuickSearchWidget)
        self.verticalLayout_2.setContentsMargins(0, 1, 0, 1)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtGui.QGridLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.showParents = QtGui.QCheckBox(LeoQuickSearchWidget)
        self.showParents.setChecked(True)
        self.showParents.setObjectName("showParents")
        self.verticalLayout.addWidget(self.showParents, 0, 2, 1, 1)
        self.lineEdit = QtGui.QLineEdit(LeoQuickSearchWidget)
        self.lineEdit.setObjectName("lineEditNav")
        self.verticalLayout.addWidget(self.lineEdit, 0, 0, 1, 1)
        self.listWidget = QtGui.QListWidget(LeoQuickSearchWidget)
        sizePolicy = QtGui.QSizePolicy(
            QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.listWidget.sizePolicy().hasHeightForWidth())
        self.listWidget.setSizePolicy(sizePolicy)
        self.listWidget.setObjectName("listWidget")
        self.verticalLayout.addWidget(self.listWidget, 2, 0, 1, 4)
        self.comboBox = QtGui.QComboBox(LeoQuickSearchWidget)
        self.comboBox.setObjectName("comboBox")
        self.comboBox.addItem("All")
        self.comboBox.addItem("Subtree")
        self.comboBox.addItem("File")
        self.comboBox.addItem("Chapter")
        self.comboBox.addItem("Node")
        self.verticalLayout.addWidget(self.comboBox, 0, 1, 1, 1)
        self.verticalLayout_2.addLayout(self.verticalLayout)

        self.retranslateUi(LeoQuickSearchWidget)
        QtCore.QMetaObject.connectSlotsByName(LeoQuickSearchWidget)
        LeoQuickSearchWidget.setTabOrder(self.lineEdit, self.comboBox)
        LeoQuickSearchWidget.setTabOrder(self.comboBox, self.showParents)
        LeoQuickSearchWidget.setTabOrder(self.showParents, self.listWidget)

    def retranslateUi(self, LeoQuickSearchWidget):
        # pylint: disable=no-member
        if isQt5:
            # QApplication.UnicodeUTF8 no longer exists.
            self.showParents.setText(
                QtWidgets.QApplication.translate(
                    "LeoQuickSearchWidget",
                    "Show Parents",
                    None))
            LeoQuickSearchWidget.setWindowTitle(
                QtWidgets.QApplication.translate(
                    "LeoQuickSearchWidget",
                    "Form",
                    None))
        else:
            LeoQuickSearchWidget.setWindowTitle(
                QtGui.QApplication.translate(
                    "LeoQuickSearchWidget", "Form",
                    None,
                    QtGui.QApplication.UnicodeUTF8))
            self.showParents.setText(
                QtGui.QApplication.translate(
                    "LeoQuickSearchWidget",
                    "Show Parents",
                    None,
                    QtGui.QApplication.UnicodeUTF8))
#@+node:ekr.20140831085423.18598: *4* @file ../plugins/qt_text.py
@first # -*- coding: utf-8 -*-
"""Text classes for the Qt version of Leo"""
import leo.core.leoGlobals as g
import time
assert time
from leo.core.leoQt import isQt5, QtCore, QtGui, Qsci, QtWidgets
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20191001084541.1: *5*  zoom commands
#@+node:tbrown.20130411145310.18857: *6* @g.command("zoom-in")
@g.command("zoom-in")
def zoom_in(event=None, delta=1):
    """increase body font size by one

    @font-size-body must be present in the stylesheet
    """
    zoom_helper(event, delta=1)
#@+node:ekr.20191001084646.1: *6* @g.command("zoom-out")
@g.command("zoom-out")
def zoom_out(event=None):
    """decrease body font size by one

    @font-size-body must be present in the stylesheet
    """
    # zoom_in(event=event, delta=-1)
    zoom_helper(event=event, delta=-1)
#@+node:ekr.20191001084612.1: *6* zoom_helper
def zoom_helper(event, delta):
    """
    Common helper for zoom commands.
    """
    c = event.get('c')
    if not c:
        return
    wrapper = c.frame.body.wrapper
    #
    # For performance, don't c.styleSheetManager.reload_style_sheets().
    # Apply to body widget directly
    c._style_deltas['font-size-body'] += delta
    ssm = c.styleSheetManager
    sheet = ssm.expand_css_constants(c.active_stylesheet)
    wrapper.widget.setStyleSheet(sheet)
    #
    # #490: Honor language-specific settings.
    colorizer = getattr(c.frame.body, 'colorizer', None)
    if not colorizer:
        return
    c.zoom_delta = delta
    colorizer.configure_fonts()
    wrapper.setAllText(wrapper.getAllText())
        # Recolor everything.
#@+node:ekr.20140901062324.18719: *5*   class QTextMixin
class QTextMixin:
    """A minimal mixin class for QTextEditWrapper and QScintillaWrapper classes."""
    @others
#@+node:ekr.20140901062324.18732: *6* qtm.ctor & helper
def __init__(self, c=None):
    """Ctor for QTextMixin class"""
    self.c = c
    self.changingText = False  # A lockout for onTextChanged.
    self.enabled = True
    self.supportsHighLevelInterface = True
        # A flag for k.masterKeyHandler and isTextWrapper.
    self.tags = {}
    self.permanent = True  # False if selecting the minibuffer will make the widget go away.
    self.configDict = {}  # Keys are tags, values are colors (names or values).
    self.configUnderlineDict = {}  # Keys are tags, values are True
    # self.formatDict = {} # Keys are tags, values are actual QTextFormat objects.
    self.useScintilla = False  # This is used!
    self.virtualInsertPoint = None
    if c:
        self.injectIvars(c)
#@+node:ekr.20140901062324.18721: *7* qtm.injectIvars
def injectIvars(self, name='1', parentFrame=None):
    """Inject standard leo ivars into the QTextEdit or QsciScintilla widget."""
    w = self
    p = self.c.currentPosition()
    if name == '1':
        w.leo_p = None  # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    w.leo_frame = None
    w.leo_name = name
    w.leo_label = None
    return w
#@+node:ekr.20140901062324.18825: *6* qtm.getName
def getName(self):
    return self.name  # Essential.
#@+node:ekr.20140901122110.18733: *6* qtm.Event handlers
# These are independent of the kind of Qt widget.
#@+node:ekr.20140901062324.18716: *7* qtm.onCursorPositionChanged
def onCursorPositionChanged(self, event=None):
    c = self.c
    name = c.widget_name(self)
    # Apparently, this does not cause problems
    # because it generates no events in the body pane.
    if name.startswith('body'):
        if hasattr(c.frame, 'statusLine'):
            c.frame.statusLine.update()
#@+node:ekr.20140901062324.18714: *7* qtm.onTextChanged
def onTextChanged(self):
    """
    Update Leo after the body has been changed.

    tree.tree_select_lockout is True during the entire selection process.
    """
    # Important: usually w.changingText is True.
    # This method very seldom does anything.
    w = self
    c = self.c; p = c.p
    tree = c.frame.tree
    if w.changingText:
        return
    if tree.tree_select_lockout:
        g.trace('*** LOCKOUT', g.callers())
        return
    if not p:
        return
    newInsert = w.getInsertPoint()
    newSel = w.getSelectionRange()
    newText = w.getAllText()  # Converts to unicode.
    # Get the previous values from the VNode.
    oldText = p.b
    if oldText == newText:
        # This can happen as the result of undo.
        # g.error('*** unexpected non-change')
        return
    i, j = p.v.selectionStart, p.v.selectionLength
    oldSel = (i, i + j)
    oldYview = None
    undoType = 'Typing'
    c.undoer.setUndoTypingParams(p, undoType,
        oldText=oldText, newText=newText,
        oldSel=oldSel, newSel=newSel, oldYview=oldYview)
    # Update the VNode.
    p.v.setBodyString(newText)
    if True:
        p.v.insertSpot = newInsert
        i, j = newSel
        i, j = self.toPythonIndex(i), self.toPythonIndex(j)
        if i > j: i, j = j, i
        p.v.selectionStart, p.v.selectionLength = (i, j - i)
    # No need to redraw the screen.
    if not self.useScintilla:
        c.recolor()
    if not c.changed and c.frame.initComplete:
        c.setChanged()
    c.frame.body.updateEditors()
    c.frame.tree.updateIcon(p)
#@+node:ekr.20140901122110.18734: *6* qtm.Generic high-level interface
# These call only wrapper methods.
#@+node:ekr.20140902181058.18645: *7* qtm.Enable/disable
def disable(self):
    self.enabled = False

def enable(self, enabled=True):
    self.enabled = enabled
#@+node:ekr.20140902181058.18644: *7* qtm.Clipboard
def clipboard_append(self, s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)

def clipboard_clear(self):
    g.app.gui.replaceClipboardWith('')
#@+node:ekr.20140901062324.18698: *7* qtm.setFocus
def setFocus(self):
    """QTextMixin"""
    if 'focus' in g.app.debug:
        print('BaseQTextWrapper.setFocus', self.widget)
    # Call the base class
    assert isinstance(self.widget, (
        QtWidgets.QTextBrowser,
        QtWidgets.QLineEdit,
        QtWidgets.QTextEdit,
        Qsci and Qsci.QsciScintilla,
    )), self.widget
    QtWidgets.QTextBrowser.setFocus(self.widget)
#@+node:ekr.20140901062324.18717: *7* qtm.Generic text
#@+node:ekr.20140901062324.18703: *8* qtm.appendText
def appendText(self, s):
    """QTextMixin"""
    s2 = self.getAllText()
    self.setAllText(s2 + s)
    self.setInsertPoint(len(s2))
#@+node:ekr.20140901141402.18706: *8* qtm.delete
def delete(self, i, j=None):
    """QTextMixin"""
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    # This allows subclasses to use this base class method.
    if i > j: i, j = j, i
    s = self.getAllText()
    self.setAllText(s[:i] + s[j:])
    # Bug fix: Significant in external tests.
    self.setSelectionRange(i, i, insert=i)
#@+node:ekr.20140901062324.18827: *8* qtm.deleteTextSelection
def deleteTextSelection(self):
    """QTextMixin"""
    i, j = self.getSelectionRange()
    self.delete(i, j)
#@+node:ekr.20110605121601.18102: *8* qtm.get
def get(self, i, j=None):
    """QTextMixin"""
    # 2012/04/12: fix the following two bugs by using the vanilla code:
    # https://bugs.launchpad.net/leo-editor/+bug/979142
    # https://bugs.launchpad.net/leo-editor/+bug/971166
    s = self.getAllText()
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    return s[i:j]
#@+node:ekr.20140901062324.18704: *8* qtm.getLastPosition & getLength
def getLastPosition(self, s=None):
    """QTextMixin"""
    return len(self.getAllText()) if s is None else len(s)

def getLength(self, s=None):
    """QTextMixin"""
    return len(self.getAllText()) if s is None else len(s)
#@+node:ekr.20140901062324.18705: *8* qtm.getSelectedText
def getSelectedText(self):
    """QTextMixin"""
    i, j = self.getSelectionRange()
    if i == j:
        return ''
    s = self.getAllText()
    return s[i:j]
#@+node:ekr.20140901141402.18702: *8* qtm.insert
def insert(self, i, s):
    """QTextMixin"""
    s2 = self.getAllText()
    i = self.toPythonIndex(i)
    self.setAllText(s2[:i] + s + s2[i:])
    self.setInsertPoint(i + len(s))
    return i
#@+node:ekr.20140902084950.18634: *8* qtm.seeInsertPoint
def seeInsertPoint(self):
    """Ensure the insert point is visible."""
    self.see(self.getInsertPoint())
        # getInsertPoint defined in client classes.
#@+node:ekr.20140902135648.18668: *8* qtm.selectAllText
def selectAllText(self, s=None):
    """QTextMixin."""
    self.setSelectionRange(0, self.getLength(s))
#@+node:ekr.20140901141402.18710: *8* qtm.toPythonIndex
def toPythonIndex(self, index, s=None):
    """QTextMixin"""
    if s is None:
        s = self.getAllText()
    i = g.toPythonIndex(s, index)
    return i
#@+node:ekr.20140901141402.18704: *8* qtm.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    """QTextMixin"""
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row, col = g.convertPythonIndexToRowCol(s, i)
    return i, row, col
#@+node:ekr.20140901062324.18729: *7* qtm.rememberSelectionAndScroll
def rememberSelectionAndScroll(self):

    w = self
    v = self.c.p.v  # Always accurate.
    v.insertSpot = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if i > j: i, j = j, i
    assert(i <= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = w.getYScrollPosition()
#@+node:ekr.20140901062324.18712: *7* qtm.tag_configure
def tag_configure(self, *args, **keys):

    if len(args) == 1:
        key = args[0]
        self.tags[key] = keys
        val = keys.get('foreground')
        underline = keys.get('underline')
        if val:
            self.configDict[key] = val
        if underline:
            self.configUnderlineDict[key] = True
    else:
        g.trace('oops', args, keys)

tag_config = tag_configure
#@+node:ekr.20110605121601.18058: *5*  class QLineEditWrapper(QTextMixin)
class QLineEditWrapper(QTextMixin):
    """
    A class to wrap QLineEdit widgets.

    The QHeadlineWrapper class is a subclass that merely
    redefines the do-nothing check method here.
    """
    @others
#@+node:ekr.20110605121601.18060: *6* qlew.Birth
def __init__(self, widget, name, c=None):
    """Ctor for QLineEditWrapper class."""
    super().__init__(c)
    self.widget = widget
    self.name = name
    self.baseClassName = 'QLineEditWrapper'

def __repr__(self):
    return f"<QLineEditWrapper: widget: {self.widget}"

__str__ = __repr__
#@+node:ekr.20140901191541.18599: *6* qlew.check
def check(self):
    """
    QLineEditWrapper.
    """
    return True
#@+node:ekr.20110605121601.18118: *6* qlew.Widget-specific overrides
#@+node:ekr.20110605121601.18120: *7* qlew.getAllText
def getAllText(self):
    """QHeadlineWrapper."""
    if self.check():
        w = self.widget
        return w.text()
    return ''
#@+node:ekr.20110605121601.18121: *7* qlew.getInsertPoint
def getInsertPoint(self):
    """QHeadlineWrapper."""
    if self.check():
        return self.widget.cursorPosition()
    return 0
#@+node:ekr.20110605121601.18122: *7* qlew.getSelectionRange
def getSelectionRange(self, sort=True):
    """QHeadlineWrapper."""
    w = self.widget
    if self.check():
        if w.hasSelectedText():
            i = w.selectionStart()
            s = w.selectedText()
            j = i + len(s)
        else:
            i = j = w.cursorPosition()
        return i, j
    return 0, 0
#@+node:ekr.20110605121601.18123: *7* qlew.hasSelection
def hasSelection(self):
    """QHeadlineWrapper."""
    if self.check():
        return self.widget.hasSelectedText()
    return False
#@+node:ekr.20110605121601.18124: *7* qlew.see & seeInsertPoint
def see(self, i):
    """QHeadlineWrapper."""
    pass

def seeInsertPoint(self):
    """QHeadlineWrapper."""
    pass
#@+node:ekr.20110605121601.18125: *7* qlew.setAllText
def setAllText(self, s):
    """Set all text of a Qt headline widget."""
    if self.check():
        w = self.widget
        w.setText(s)
#@+node:ekr.20110605121601.18128: *7* qlew.setFocus
def setFocus(self):
    """QHeadlineWrapper."""
    if self.check():
        g.app.gui.set_focus(self.c, self.widget)
#@+node:ekr.20110605121601.18129: *7* qlew.setInsertPoint
def setInsertPoint(self, i, s=None):
    """QHeadlineWrapper."""
    if not self.check(): return
    w = self.widget
    if s is None:
        s = w.text()
    i = self.toPythonIndex(i)
    i = max(0, min(i, len(s)))
    w.setCursorPosition(i)
#@+node:ekr.20110605121601.18130: *7* qlew.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    """QHeadlineWrapper."""
    if not self.check(): return
    w = self.widget
    if i > j: i, j = j, i
    if s is None:
        s = w.text()
    n = len(s)
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        insert = j
    else:
        insert = self.toPythonIndex(insert)
        insert = max(0, min(insert, n))
    if i == j:
        w.setCursorPosition(i)
    else:
        length = j - i
        # Set selection is a QLineEditMethod
        if insert < j:
            w.setSelection(j, -length)
        else:
            w.setSelection(i, length)
# setSelectionRangeHelper = setSelectionRange
#@+node:ekr.20150403094619.1: *5* class LeoLineTextWidget(QFrame)
class LeoLineTextWidget(QtWidgets.QFrame):
    """
    A QFrame supporting gutter line numbers.
    
    This class *has* a QTextEdit.
    """
    @others
#@+node:ekr.20150403094706.9: *6* __init__(LeoLineTextWidget)
def __init__(self, c, e, *args):
    """Ctor for LineTextWidget."""
    super().__init__(*args)
    self.c = c
    self.setFrameStyle(self.StyledPanel | self.Sunken)
    self.edit = e  # A QTextEdit
    e.setFrameStyle(self.NoFrame)
    # e.setAcceptRichText(False)
    self.number_bar = NumberBar(c, e)
    hbox = QtWidgets.QHBoxLayout(self)
    hbox.setSpacing(0)
    hbox.setContentsMargins(0, 0, 0, 0)
    hbox.addWidget(self.number_bar)
    hbox.addWidget(e)
    e.installEventFilter(self)
    e.viewport().installEventFilter(self)
#@+node:ekr.20150403094706.10: *6* eventFilter
def eventFilter(self, obj, event):
    """
    Update the line numbers for all events on the text edit and the viewport.
    This is easier than connecting all necessary signals.
    """
    if obj in (self.edit, self.edit.viewport()):
        self.number_bar.update()
        return False
    return QtWidgets.QFrame.eventFilter(obj, event)
#@+node:ekr.20110605121601.18005: *5* class LeoQTextBrowser (QtWidgets.QTextBrowser)
if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
#@+node:ekr.20110605121601.18006: *6*  lqtb.ctor
def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
#@+node:ekr.20110605121601.18007: *6* lqtb. __repr__ & __str__
def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
#@+node:ekr.20110605121601.18008: *6* lqtb.Auto completion
#@+node:ekr.20110605121601.18009: *7* class LeoQListWidget(QListWidget)
class LeoQListWidget(QtWidgets.QListWidget):
    @others
#@+node:ekr.20110605121601.18010: *8* lqlw.ctor
def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
#@+node:ekr.20110605121601.18011: *8* lqlw.closeEvent
def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
#@+node:ekr.20110605121601.18012: *8* lqlw.end_completer
def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
#@+node:ekr.20141024170936.7: *8* lqlw.get_selection
def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
#@+node:ekr.20110605121601.18013: *8* lqlw.keyPressEvent
def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
#@+node:ekr.20110605121601.18014: *8* lqlw.select_callback
def select_callback(self):
    """Called when user selects an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) > 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.frame.body.onBodyChanged('Typing')
    self.end_completer()
#@+node:tbrown.20111011094944.27031: *8* lqlw.tab_callback
def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) < 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 <= i < len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j > i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
#@+node:ekr.20110605121601.18015: *8* lqlw.set_position
def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
#@+node:ekr.20110605121601.18016: *8* lqlw.show_completions
def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
#@+node:ekr.20110605121601.18017: *7* lqtb.lqtb.init_completer
def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
#@+node:ekr.20110605121601.18018: *7* lqtb.redirections to LeoQListWidget
def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
#@+node:ekr.20141103061944.31: *6* lqtb.get/setXScrollPosition
def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20111002125540.7021: *6* lqtb.get/setYScrollPosition
def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18019: *6* lqtb.leo_dumpButton
def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
#@+node:ekr.20200304130514.1: *6* lqtb.onContextMenu
def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
#@+node:ekr.20120925061642.13506: *6* lqtb.onSliderChanged
def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
#@+node:tbrown.20130411145310.18855: *6* lqtb.wheelEvent
def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier & event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta < 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
#@+node:ekr.20150403094706.2: *5* class NumberBar(QFrame)
class NumberBar(QtWidgets.QFrame):
    @others
#@+node:ekr.20150403094706.3: *6* NumberBar.__init__
def __init__(self, c, e, *args):
    """Ctor for NumberBar class."""
    super().__init__(*args)
    self.c = c
    self.edit = e
        # A QTextEdit.
    self.d = e.document()
        # A QTextDocument.
    self.fm = self.fontMetrics()
        # A QFontMetrics
    self.image = QtGui.QImage(g.app.gui.getImageImage(
        g.os_path_finalize_join(g.app.loadDir,
            '..', 'Icons', 'Tango', '16x16', 'actions', 'stop.png')))
    self.highest_line = 0
        # The highest line that is currently visibile.
    # Set the name to gutter so that the QFrame#gutter style sheet applies.
    self.offsets = []
    self.setObjectName('gutter')
    self.reloadSettings()
#@+node:ekr.20181005093003.1: *6* NumberBar.reloadSettings
def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.w_adjust = c.config.getInt('gutter-w-adjust') or 12
        # Extra width for column.
    self.y_adjust = c.config.getInt('gutter-y-adjust') or 10
        # The y offset of the first line of the gutter.
#@+node:ekr.20181005085507.1: *6* NumberBar.mousePressEvent
def mousePressEvent(self, event):

    c = self.c

    def find_line(y):
        n, last_y = 0, 0
        for n, y2 in self.offsets:
            if last_y <= y < y2:
                return n
            last_y = y2
        return n if self.offsets else 0

    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    path = xdb.canonic(g.fullPath(c, c.p))
    if not path:
        return
    n = find_line(event.y())
    if not xdb.checkline(path, n):
        g.trace('FAIL checkline', path, n)
        return
    if xdb.has_breakpoint(path, n):
        xdb.qc.put(f"clear {path}:{n}")
    else:
        xdb.qc.put(f"b {path}:{n}")
#@+node:ekr.20150403094706.5: *6* NumberBar.update
def update(self, *args):
    """
    Updates the number bar to display the current set of numbers.
    Also, adjusts the width of the number bar if necessary.
    """
    # w_adjust is used to compensate for the current line being bold.
    # Always allocate room for 2 columns
    width = self.fm.width(str(max(1000, self.highest_line))) + self.w_adjust
    if self.width() != width:
        self.setFixedWidth(width)
    QtWidgets.QWidget.update(self, *args)
#@+node:ekr.20150403094706.6: *6* NumberBar.paintEvent
def paintEvent(self, event):
    """
    Enhance QFrame.paintEvent.
    Paint all visible text blocks in the editor's document.
    """
    e = self.edit
    d = self.d
    layout = d.documentLayout()
    # Compute constants.
    current_block = d.findBlock(e.textCursor().position())
    scroll_y = e.verticalScrollBar().value()
    page_bottom = scroll_y + e.viewport().height()
    # Paint each visible block.
    painter = QtGui.QPainter(self)
    block = d.begin()
    n = i = 0
    c = self.c
    translation = c.user_dict.get('line_number_translation', [])
    self.offsets = []
    while block.isValid():
        i = translation[n] if n < len(translation) else n + 1
        n += 1
        top_left = layout.blockBoundingRect(block).topLeft()
        if top_left.y() > page_bottom:
            break  # Outside the visible area.
        bold = block == current_block
        self.paintBlock(bold, i, painter, top_left, scroll_y)
        block = block.next()
    self.highest_line = i
    painter.end()
    QtWidgets.QWidget.paintEvent(self, event)
        # Propagate the event.
#@+node:ekr.20150403094706.7: *6* NumberBar.paintBlock
def paintBlock(self, bold, n, painter, top_left, scroll_y):
    """Paint n, right justified in the line number field."""
    c = self.c
    if bold:
        self.setBold(painter, True)
    s = str(n)
    pad = max(4, len(str(self.highest_line))) - len(s)
    s = ' ' * pad + s
    # x = self.width() - self.fm.width(s) - self.w_adjust
    x = 0
    y = round(top_left.y()) - scroll_y + self.fm.ascent() + self.y_adjust
    self.offsets.append((n, y),)
    painter.drawText(x, y, s)
    if bold:
        self.setBold(painter, False)
    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    if not xdb.has_breakpoints():
        return
    path = g.fullPath(c, c.p)
    if xdb.has_breakpoint(path, n):
        target_r = QtCore.QRect(
            self.fm.width(s) + 16,
            top_left.y() + self.y_adjust - 2,
            16.0, 16.0)
        if self.image:
            source_r = QtCore.QRect(0.0, 0.0, 16.0, 16.0)
            painter.drawImage(target_r, self.image, source_r)
        else:
            painter.drawEllipse(target_r)
#@+node:ekr.20150403094706.8: *6* NumberBar.setBold
def setBold(self, painter, flag):
    """Set or clear bold facing in the painter, depending on flag."""
    font = painter.font()
    font.setBold(flag)
    painter.setFont(font)
#@+node:ekr.20140901141402.18700: *5* class PlainTextWrapper(QTextMixin)
class PlainTextWrapper(QTextMixin):
    """A Qt class for use by the find code."""

    def __init__(self, widget):
        """Ctor for the PlainTextWrapper class."""
        super().__init__()
        self.widget = widget
#@+node:ekr.20110605121601.18116: *5* class QHeadlineWrapper (QLineEditWrapper)
class QHeadlineWrapper(QLineEditWrapper):
    """
    A wrapper class for QLineEdit widgets in QTreeWidget's.
    This class just redefines the check method.
    """
    @others
#@+node:ekr.20110605121601.18117: *6* qhw.Birth
def __init__(self, c, item, name, widget):
    """The ctor for the QHeadlineWrapper class."""
    assert isinstance(widget, QtWidgets.QLineEdit), widget
    super().__init__(widget, name, c)
    # Set ivars.
    self.c = c
    self.item = item
    self.name = name
    self.permanent = False  # Warn the minibuffer that we can go away.
    self.widget = widget
    # Set the signal.
    g.app.gui.setFilter(c, self.widget, self, tag=name)

def __repr__(self):
    return f"QHeadlineWrapper: {id(self)}"
#@+node:ekr.20110605121601.18119: *6* qhw.check
def check(self):
    """Return True if the tree item exists and it's edit widget exists."""
    tree = self.c.frame.tree
    try:
        e = tree.treeWidget.itemWidget(self.item, 0)
    except RuntimeError:
        return False
    valid = tree.isValidItem(self.item)
    result = valid and e == self.widget
    return result
#@+node:ekr.20110605121601.18131: *5* class QMinibufferWrapper (QLineEditWrapper)
class QMinibufferWrapper(QLineEditWrapper):

    def __init__(self, c):
        """Ctor for QMinibufferWrapper class."""
        self.c = c
        w = c.frame.top.lineEdit  # QLineEdit
        super().__init__(widget=w, name='minibuffer', c=c)
        assert self.widget
        g.app.gui.setFilter(c, w, self, tag='minibuffer')
        # Monkey-patch the event handlers
        << define mouseReleaseEvent >>

        w.mouseReleaseEvent = mouseReleaseEvent

    def setStyleClass(self, style_class):
        self.widget.setProperty('style_class', style_class)
        #
        # to get the appearance to change because of a property
        # change, unlike a focus or hover change, we need to
        # re-apply the stylesheet.  But re-applying at the top level
        # is too CPU hungry, so apply just to this widget instead.
        # It may lag a bit when the style's edited, but the new top
        # level sheet will get pushed down quite frequently.
        self.widget.setStyleSheet(self.c.frame.top.styleSheet())

    def setSelectionRange(self, i, j, insert=None, s=None):
        QLineEditWrapper.setSelectionRange(self, i, j, insert, s)
        insert = j if insert is None else insert
        if self.widget:
            self.widget._sel_and_insert = (i, j, insert)
#@+node:ekr.20110605121601.18132: *6* << define mouseReleaseEvent >> (QMinibufferWrapper)
def mouseReleaseEvent(event, self=self):
    """Override QLineEdit.mouseReleaseEvent.

    Simulate alt-x if we are not in an input state.
    """
    assert isinstance(self, QMinibufferWrapper), self
    assert isinstance(self.widget, QtWidgets.QLineEdit), self.widget
    c, k = self.c, self.c.k
    if not k.state.kind:
        # c.widgetWantsFocusNow(w) # Doesn't work.
        event2 = g.app.gui.create_key_event(c, w=c.frame.body.wrapper)
        k.fullCommand(event2)
        # c.outerUpdate() # Doesn't work.

#@+node:ekr.20110605121601.18103: *5* class QScintillaWrapper(QTextMixin)
class QScintillaWrapper(QTextMixin):
    """
    A wrapper for QsciScintilla supporting the high-level interface.

    This widget will likely always be less capable the QTextEditWrapper.
    To do:
    - Fix all Scintilla unit-test failures.
    - Add support for all scintilla lexers.
    """
    @others
#@+node:ekr.20110605121601.18105: *6* qsciw.ctor
def __init__(self, widget, c, name=None):
    """Ctor for the QScintillaWrapper class."""
    super().__init__(c)
    self.baseClassName = 'QScintillaWrapper'
    self.c = c
    self.name = name
    self.useScintilla = True
    self.widget = widget
    # Complete the init.
    self.set_config()
    # Set the signal.
    g.app.gui.setFilter(c, widget, self, tag=name)
#@+node:ekr.20110605121601.18106: *6* qsciw.set_config
def set_config(self):
    """Set QScintillaWrapper configuration options."""
    c, w = self.c, self.widget
    n = c.config.getInt('qt-scintilla-zoom-in')
    if n not in (None, 1, 0):
        w.zoomIn(n)
    w.setUtf8(True)  # Important.
    if 1:
        w.setBraceMatching(2)  # Sloppy
    else:
        w.setBraceMatching(0)  # wrapper.flashCharacter creates big problems.
    if 0:
        w.setMarginWidth(1, 40)
        w.setMarginLineNumbers(1, True)
    w.setIndentationWidth(4)
    w.setIndentationsUseTabs(False)
    w.setAutoIndent(True)
#@+node:ekr.20110605121601.18107: *6* qsciw.WidgetAPI
#@+node:ekr.20140901062324.18593: *7* qsciw.delete
def delete(self, i, j=None):
    """Delete s[i:j]"""
    w = self.widget
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    self.setSelectionRange(i, j)
    try:
        self.changingText = True  # Disable onTextChanged
        w.replaceSelectedText('')
    finally:
        self.changingText = False
#@+node:ekr.20140901062324.18594: *7* qsciw.flashCharacter (disabled)
def flashCharacter(self, i, bg='white', fg='red', flashes=2, delay=50):
    """Flash the character at position i."""
    if 0:  # This causes a lot of problems: Better to use Scintilla matching.
        # This causes problems during unit tests:
        # The selection point isn't restored in time.
        if g.app.unitTesting:
            return
        @others
        # Numbered color names don't work in Ubuntu 8.10, so...

        if bg and bg[-1].isdigit() and bg[0] != '#': bg = bg[:-1]
        if fg and fg[-1].isdigit() and fg[0] != '#': fg = fg[:-1]
        # w = self.widget # A QsciScintilla widget.
        self.flashCount = flashes
        self.flashIndex1 = self.getInsertPoint()
        self.flashIndex = self.toPythonIndex(i)
        self.flashBg = None if bg.lower() == 'same' else bg
        self.flashFg = None if fg.lower() == 'same' else fg
        addFlashCallback()
#@+node:ekr.20140902084950.18635: *8* after
def after(func, delay=delay):
    """Run func after the given delay."""
    QtCore.QTimer.singleShot(delay, func)
#@+node:ekr.20140902084950.18636: *8* addFlashCallback
def addFlashCallback(self=self):
    i = self.flashIndex
    w = self.widget
    self.setSelectionRange(i, i + 1)
    if self.flashBg:
        w.setSelectionBackgroundColor(QtGui.QColor(self.flashBg))
    if self.flashFg:
        w.setSelectionForegroundColor(QtGui.QColor(self.flashFg))
    self.flashCount -= 1
    after(removeFlashCallback)
#@+node:ekr.20140902084950.18637: *8* removeFlashCallback
def removeFlashCallback(self=self):
    """Remove the extra selections."""
    self.setInsertPoint(self.flashIndex)
    w = self.widget
    if self.flashCount > 0:
        after(addFlashCallback)
    else:
        w.resetSelectionBackgroundColor()
        self.setInsertPoint(self.flashIndex1)
        w.setFocus()
#@+node:ekr.20140901062324.18595: *7* qsciw.get
def get(self, i, j=None):
    # Fix the following two bugs by using vanilla code:
    # https://bugs.launchpad.net/leo-editor/+bug/979142
    # https://bugs.launchpad.net/leo-editor/+bug/971166
    s = self.getAllText()
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    return s[i:j]
#@+node:ekr.20110605121601.18108: *7* qsciw.getAllText
def getAllText(self):
    """Get all text from a QsciScintilla widget."""
    w = self.widget
    return w.text()
#@+node:ekr.20110605121601.18109: *7* qsciw.getInsertPoint
def getInsertPoint(self):
    """Get the insertion point from a QsciScintilla widget."""
    w = self.widget
    i = int(w.SendScintilla(w.SCI_GETCURRENTPOS))
    return i
#@+node:ekr.20110605121601.18110: *7* qsciw.getSelectionRange
def getSelectionRange(self, sort=True):
    """Get the selection range from a QsciScintilla widget."""
    w = self.widget
    i = int(w.SendScintilla(w.SCI_GETCURRENTPOS))
    j = int(w.SendScintilla(w.SCI_GETANCHOR))
    if sort and i > j: i, j = j, i
    return i, j
#@+node:ekr.20140901062324.18599: *7* qsciw.getX/YScrollPosition (to do)
def getXScrollPosition(self):
    # w = self.widget
    return 0  # Not ready yet.

def getYScrollPosition(self):
    # w = self.widget
    return 0  # Not ready yet.
#@+node:ekr.20110605121601.18111: *7* qsciw.hasSelection
def hasSelection(self):
    """Return True if a QsciScintilla widget has a selection range."""
    return self.widget.hasSelectedText()
#@+node:ekr.20140901062324.18601: *7* qsciw.insert
def insert(self, i, s):
    """Insert s at position i."""
    w = self.widget
    i = self.toPythonIndex(i)
    w.SendScintilla(w.SCI_SETSEL, i, i)
    w.SendScintilla(w.SCI_ADDTEXT, len(s), g.toEncodedString(s))
    i += len(s)
    w.SendScintilla(w.SCI_SETSEL, i, i)
    return i
#@+node:ekr.20140901062324.18603: *7* qsciw.linesPerPage
def linesPerPage(self):
    """Return the number of lines presently visible."""
    # Not used in Leo's core. Not tested.
    w = self.widget
    return int(w.SendScintilla(w.SCI_LINESONSCREEN))
#@+node:ekr.20140901062324.18604: *7* qsciw.scrollDelegate (maybe)
if 0:  # Not yet.

    def scrollDelegate(self, kind):
        """
        Scroll a QTextEdit up or down one page.
        direction is in ('down-line','down-page','up-line','up-page')
        """
        c = self.c
        w = self.widget
        vScroll = w.verticalScrollBar()
        h = w.size().height()
        lineSpacing = w.fontMetrics().lineSpacing()
        n = h / lineSpacing
        n = max(2, n - 3)
        if kind == 'down-half-page': delta = n / 2
        elif kind == 'down-line': delta = 1
        elif kind == 'down-page': delta = n
        elif kind == 'up-half-page': delta = -n / 2
        elif kind == 'up-line': delta = -1
        elif kind == 'up-page': delta = -n
        else:
            delta = 0
            g.trace('bad kind:', kind)
        val = vScroll.value()
        vScroll.setValue(val + (delta * lineSpacing))
        c.bodyWantsFocus()
#@+node:ekr.20110605121601.18112: *7* qsciw.see
def see(self, i):
    """Ensure insert point i is visible in a QsciScintilla widget."""
    # Ok for now.  Using SCI_SETYCARETPOLICY might be better.
    w = self.widget
    s = self.getAllText()
    i = self.toPythonIndex(i)
    row, col = g.convertPythonIndexToRowCol(s, i)
    w.ensureLineVisible(row)
#@+node:ekr.20110605121601.18113: *7* qsciw.setAllText
def setAllText(self, s):
    """Set the text of a QScintilla widget."""
    w = self.widget
    assert isinstance(w, Qsci.QsciScintilla), w
    w.setText(s)
    # w.update()
#@+node:ekr.20110605121601.18114: *7* qsciw.setInsertPoint
def setInsertPoint(self, i, s=None):
    """Set the insertion point in a QsciScintilla widget."""
    w = self.widget
    i = self.toPythonIndex(i)
    # w.SendScintilla(w.SCI_SETCURRENTPOS,i)
    # w.SendScintilla(w.SCI_SETANCHOR,i)
    w.SendScintilla(w.SCI_SETSEL, i, i)
#@+node:ekr.20110605121601.18115: *7* qsciw.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    """Set the selection range in a QsciScintilla widget."""
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    insert = j if insert is None else self.toPythonIndex(insert)
    if insert >= i:
        w.SendScintilla(w.SCI_SETSEL, i, j)
    else:
        w.SendScintilla(w.SCI_SETSEL, j, i)
#@+node:ekr.20140901062324.18609: *7* qsciw.setX/YScrollPosition (to do)
def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
#@+node:ekr.20110605121601.18071: *5* class QTextEditWrapper(QTextMixin)
class QTextEditWrapper(QTextMixin):
    """A wrapper for a QTextEdit/QTextBrowser supporting the high-level interface."""
    @others
#@+node:ekr.20110605121601.18073: *6* qtew.ctor & helpers
def __init__(self, widget, name, c=None):
    """Ctor for QTextEditWrapper class. widget is a QTextEdit/QTextBrowser."""
    super().__init__(c)
    # Make sure all ivars are set.
    self.baseClassName = 'QTextEditWrapper'
    self.c = c
    self.name = name
    self.widget = widget
    self.useScintilla = False
    # Complete the init.
    if c and widget:
        self.widget.setUndoRedoEnabled(False)
        self.set_config()
        self.set_signals()
        
#@+node:ekr.20110605121601.18076: *7* qtew.set_config
def set_config(self):
    """Set configuration options for QTextEdit."""
    w = self.widget
    w.setWordWrapMode(QtGui.QTextOption.NoWrap)
    # tab stop in pixels - no config for this (yet)
    w.setTabStopWidth(24)
#@+node:ekr.20140901062324.18566: *7* qtew.set_signals (should be distributed?)
def set_signals(self):
    """Set up signals."""
    c, name = self.c, self.name
    if name in ('body', 'rendering-pane-wrapper') or name.startswith('head'):
        # Hook up qt events.
        g.app.gui.setFilter(c, self.widget, self, tag=name)
    if name == 'body':
        w = self.widget
        w.textChanged.connect(self.onTextChanged)
        w.cursorPositionChanged.connect(self.onCursorPositionChanged)
    if name in ('body', 'log'):
        # Monkey patch the event handler.
        @others
        self.widget.mouseReleaseEvent = mouseReleaseEvent
#@+node:ekr.20140901062324.18565: *8* mouseReleaseEvent (monkey-patch) QTextEditWrapper
def mouseReleaseEvent(event, self=self):
    """
    Monkey patch for self.widget (QTextEditWrapper) mouseReleaseEvent.
    """
    assert isinstance(self, QTextEditWrapper), self
    assert isinstance(self.widget, QtWidgets.QTextEdit), self.widget
    QtWidgets.QTextEdit.mouseReleaseEvent(self.widget, event)
        # Call the base class.
    c = self.c
    setattr(event, 'c', c)
    # Open the url on a control-click.
    if QtCore.Qt.ControlModifier & event.modifiers():
        g.openUrlOnClick(event)
    else:
        if name == 'body':
            c.p.v.insertSpot = c.frame.body.wrapper.getInsertPoint()
        g.doHook("bodyclick2", c=c, p=c.p, v=c.p)
        # Do *not* change the focus! This would rip focus away from tab panes.
        c.k.keyboardQuit(setFocus=False)
#@+node:ekr.20200312052821.1: *6* qtew.repr
def __repr__(self):
    # Add a leading space to align with StringTextWrapper.
    return f" <QTextEditWrapper: {id(self)} {self.name}>"
    
__str__ = __repr__
#@+node:ekr.20110605121601.18078: *6* qtew.High-level interface
# These are all widget-dependent
#@+node:ekr.20110605121601.18079: *7* qtew.delete (avoid call to setAllText)
def delete(self, i, j=None):
    """QTextEditWrapper."""
    w = self.widget
    i = self.toPythonIndex(i)
    if j is None: j = i + 1
    j = self.toPythonIndex(j)
    if i > j: i, j = j, i
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    cursor = w.textCursor()
    try:
        self.changingText = True  # Disable onTextChanged
        old_i, old_j = self.getSelectionRange()
        if i == old_i and j == old_j:
            # Work around an apparent bug in cursor.movePosition.
            cursor.removeSelectedText()
        elif i == j:
            pass
        else:
            cursor.setPosition(i)
            moveCount = abs(j - i)
            cursor.movePosition(cursor.Right, cursor.KeepAnchor, moveCount)
            w.setTextCursor(cursor)  # Bug fix: 2010/01/27
            cursor.removeSelectedText()
    finally:
        self.changingText = False
    sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18080: *7* qtew.flashCharacter
def flashCharacter(self, i, bg='white', fg='red', flashes=3, delay=75):
    """QTextEditWrapper."""
    # numbered color names don't work in Ubuntu 8.10, so...
    if bg[-1].isdigit() and bg[0] != '#':
        bg = bg[:-1]
    if fg[-1].isdigit() and fg[0] != '#':
        fg = fg[:-1]
    # This might causes problems during unit tests.
    # The selection point isn't restored in time.
    if g.app.unitTesting:
        return
    w = self.widget  # A QTextEdit.
    e = QtGui.QTextCursor

    def after(func):
        QtCore.QTimer.singleShot(delay, func)

    def addFlashCallback(self=self, w=w):
        i = self.flashIndex
        cursor = w.textCursor()  # Must be the widget's cursor.
        cursor.setPosition(i)
        cursor.movePosition(e.Right, e.KeepAnchor, 1)
        extra = w.ExtraSelection()
        extra.cursor = cursor
        if self.flashBg: extra.format.setBackground(QtGui.QColor(self.flashBg))
        if self.flashFg: extra.format.setForeground(QtGui.QColor(self.flashFg))
        self.extraSelList = [extra]  # keep the reference.
        w.setExtraSelections(self.extraSelList)
        self.flashCount -= 1
        after(removeFlashCallback)

    def removeFlashCallback(self=self, w=w):
        w.setExtraSelections([])
        if self.flashCount > 0:
            after(addFlashCallback)
        else:
            w.setFocus()

    self.flashCount = flashes
    self.flashIndex = i
    self.flashBg = None if bg.lower() == 'same' else bg
    self.flashFg = None if fg.lower() == 'same' else fg
    addFlashCallback()
#@+node:ekr.20110605121601.18081: *7* qtew.getAllText
def getAllText(self):
    """QTextEditWrapper."""
    w = self.widget
    return w.toPlainText()
#@+node:ekr.20110605121601.18082: *7* qtew.getInsertPoint
def getInsertPoint(self):
    """QTextEditWrapper."""
    return self.widget.textCursor().position()
#@+node:ekr.20110605121601.18083: *7* qtew.getSelectionRange
def getSelectionRange(self, sort=True):
    """QTextEditWrapper."""
    w = self.widget
    tc = w.textCursor()
    i, j = tc.selectionStart(), tc.selectionEnd()
    return i, j
#@+node:ekr.20110605121601.18084: *7* qtew.getX/YScrollPosition
# **Important**: There is a Qt bug here: the scrollbar position
# is valid only if cursor is visible.  Otherwise the *reported*
# scrollbar position will be such that the cursor *is* visible.

def getXScrollPosition(self):
    """QTextEditWrapper: Get the horizontal scrollbar position."""
    w = self.widget
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def getYScrollPosition(self):
    """QTextEditWrapper: Get the vertical scrollbar position."""
    w = self.widget
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos
#@+node:ekr.20110605121601.18085: *7* qtew.hasSelection
def hasSelection(self):
    """QTextEditWrapper."""
    return self.widget.textCursor().hasSelection()
#@+node:ekr.20110605121601.18089: *7* qtew.insert (avoid call to setAllText)
def insert(self, i, s):
    """QTextEditWrapper."""
    w = self.widget
    i = self.toPythonIndex(i)
    cursor = w.textCursor()
    try:
        self.changingText = True  # Disable onTextChanged.
        cursor.setPosition(i)
        cursor.insertText(s)
        w.setTextCursor(cursor)  # Bug fix: 2010/01/27
    finally:
        self.changingText = False
#@+node:ekr.20110605121601.18077: *7* qtew.leoMoveCursorHelper & helper
def leoMoveCursorHelper(self, kind, extend=False, linesPerPage=15):
    """QTextEditWrapper."""
    w = self.widget
    tc = QtGui.QTextCursor
    d = {
        'begin-line': tc.StartOfLine,  # Was start-line
        'down': tc.Down,
        'end': tc.End,
        'end-line': tc.EndOfLine,  # Not used.
        'exchange': True,  # Dummy.
        'home': tc.Start,
        'left': tc.Left,
        'page-down': tc.Down,
        'page-up': tc.Up,
        'right': tc.Right,
        'up': tc.Up,
    }
    kind = kind.lower()
    op = d.get(kind)
    mode = tc.KeepAnchor if extend else tc.MoveAnchor
    if not op:
        g.trace(f"can not happen: bad kind: {kind}")
        return
    if kind in ('page-down', 'page-up'):
        self.pageUpDown(op, mode)
    elif kind == 'exchange':  # exchange-point-and-mark
        cursor = w.textCursor()
        anchor = cursor.anchor()
        pos = cursor.position()
        cursor.setPosition(pos, tc.MoveAnchor)
        cursor.setPosition(anchor, tc.KeepAnchor)
        w.setTextCursor(cursor)
    else:
        if not extend:
            # Fix an annoyance. Make sure to clear the selection.
            cursor = w.textCursor()
            cursor.clearSelection()
            w.setTextCursor(cursor)
        w.moveCursor(op, mode)
    self.seeInsertPoint()
    self.rememberSelectionAndScroll()
    # #218.
    cursor = w.textCursor()
    sel = cursor.selection().toPlainText()
    if sel and hasattr(g.app.gui, 'setClipboardSelection'):
        g.app.gui.setClipboardSelection(sel)
    self.c.frame.updateStatusLine()
#@+node:btheado.20120129145543.8180: *8* qtew.pageUpDown
def pageUpDown(self, op, moveMode):
    """
    The QTextEdit PageUp/PageDown functionality seems to be "baked-in"
    and not externally accessible. Since Leo has its own keyhandling
    functionality, this code emulates the QTextEdit paging. This is a
    straight port of the C++ code found in the pageUpDown method of
    gui/widgets/qtextedit.cpp.
    """
    control = self.widget
    cursor = control.textCursor()
    moved = False
    lastY = control.cursorRect(cursor).top()
    distance = 0
    # move using movePosition to keep the cursor's x
    while True:
        y = control.cursorRect(cursor).top()
        distance += abs(y - lastY)
        lastY = y
        moved = cursor.movePosition(op, moveMode)
        if (not moved or distance >= control.height()):
            break
    tc = QtGui.QTextCursor
    sb = control.verticalScrollBar()
    if moved:
        if (op == tc.Up):
            cursor.movePosition(tc.Down, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepSub)
        else:
            cursor.movePosition(tc.Up, moveMode)
            sb.triggerAction(QtWidgets.QAbstractSlider.SliderPageStepAdd)
    control.setTextCursor(cursor)
#@+node:ekr.20110605121601.18087: *7* qtew.linesPerPage
def linesPerPage(self):
    """QTextEditWrapper."""
    # Not used in Leo's core.
    w = self.widget
    h = w.size().height()
    lineSpacing = w.fontMetrics().lineSpacing()
    n = h / lineSpacing
    return n
#@+node:ekr.20110605121601.18088: *7* qtew.scrollDelegate
def scrollDelegate(self, kind):
    """
    Scroll a QTextEdit up or down one page.
    direction is in ('down-line','down-page','up-line','up-page')
    """
    c = self.c
    w = self.widget
    vScroll = w.verticalScrollBar()
    h = w.size().height()
    lineSpacing = w.fontMetrics().lineSpacing()
    n = h / lineSpacing
    n = max(2, n - 3)
    if kind == 'down-half-page': delta = n / 2
    elif kind == 'down-line': delta = 1
    elif kind == 'down-page': delta = n
    elif kind == 'up-half-page': delta = -n / 2
    elif kind == 'up-line': delta = -1
    elif kind == 'up-page': delta = -n
    else:
        delta = 0
        g.trace('bad kind:', kind)
    val = vScroll.value()
    vScroll.setValue(val + (delta * lineSpacing))
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18090: *7* qtew.see & seeInsertPoint
def see(self, i):
    """Make sure position i is visible."""
    w = self.widget
    w.ensureCursorVisible()

def seeInsertPoint(self):
    """Make sure the insert point is visible."""
    self.widget.ensureCursorVisible()
#@+node:ekr.20110605121601.18092: *7* qtew.setAllText
def setAllText(self, s):
    """Set the text of body pane."""
    w = self.widget
    try:
        self.changingText = True  # Disable onTextChanged.
        w.setReadOnly(False)
        w.setPlainText(s)
    finally:
        self.changingText = False
#@+node:ekr.20110605121601.18095: *7* qtew.setInsertPoint
def setInsertPoint(self, i, s=None):
    # Fix bug 981849: incorrect body content shown.
    # Use the more careful code in setSelectionRange.
    self.setSelectionRange(i=i, j=i, insert=i, s=s)
#@+node:ekr.20110605121601.18096: *7* qtew.setSelectionRange
def setSelectionRange(self, i, j, insert=None, s=None):
    """Set the selection range and the insert point."""
    #
    # Part 1
    w = self.widget
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    if s is None:
        s = self.getAllText()
    n = len(s)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        ins = max(i, j)
    else:
        ins = self.toPythonIndex(insert)
        ins = max(0, min(ins, n))
    #
    # Part 2:
    # 2010/02/02: Use only tc.setPosition here.
    # Using tc.movePosition doesn't work.
    tc = w.textCursor()
    if i == j:
        tc.setPosition(i)
    elif ins == j:
        # Put the insert point at j
        tc.setPosition(i)
        tc.setPosition(j, tc.KeepAnchor)
    elif ins == i:
        # Put the insert point at i
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    else:
        # 2014/08/21: It doesn't seem possible to put the insert point somewhere else!
        tc.setPosition(j)
        tc.setPosition(i, tc.KeepAnchor)
    w.setTextCursor(tc)
    # #218.
    if hasattr(g.app.gui, 'setClipboardSelection'):
        if s[i:j]:
            g.app.gui.setClipboardSelection(s[i:j])
    #
    # Remember the values for v.restoreCursorAndScroll.
    v = self.c.p.v  # Always accurate.
    v.insertSpot = ins
    if i > j: i, j = j, i
    assert(i <= j)
    v.selectionStart = i
    v.selectionLength = j - i
    v.scrollBarSpot = w.verticalScrollBar().value()
#@+node:ekr.20141103061944.40: *7* qtew.setXScrollPosition
def setXScrollPosition(self, pos):
    """Set the position of the horizonatl scrollbar."""
    if pos is not None:
        w = self.widget
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18098: *7* qtew.setYScrollPosition
def setYScrollPosition(self, pos):
    """Set the vertical scrollbar position."""
    if pos is not None:
        w = self.widget
        sb = w.verticalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18100: *7* qtew.toPythonIndex
def toPythonIndex(self, index, s=None):
    """This is much faster than versions using g.toPythonIndex."""
    w = self
    te = self.widget
    if index is None:
        return 0
    if isinstance(index, int):
        return index
    if index == '1.0':
        return 0
    if index == 'end':
        return w.getLastPosition()
    doc = te.document()
    data = index.split('.')
    if len(data) == 2:
        row, col = data
        row, col = int(row), int(col)
        bl = doc.findBlockByNumber(row - 1)
        return bl.position() + col
    g.trace(f"bad string index: {index}")
    return 0
#@+node:ekr.20110605121601.18101: *7* qtew.toPythonIndexRowCol
def toPythonIndexRowCol(self, index):
    w = self
    if index == '1.0':
        return 0, 0, 0
    if index == 'end':
        index = w.getLastPosition()
    te = self.widget
    doc = te.document()
    i = w.toPythonIndex(index)
    bl = doc.findBlock(i)
    row = bl.blockNumber()
    col = i - bl.position()
    return i, row, col
#@+node:ekr.20140907123524.18774: *4* @file ../plugins/qt_frame.py
@first # -*- coding: utf-8 -*-
"""Leo's qt frame classes."""
<< imports >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20110605121601.18003: *5*  << imports >> (qt_frame.py)
import leo.core.leoGlobals as g
import leo.core.leoColor as leoColor
import leo.core.leoColorizer as leoColorizer
import leo.core.leoFrame as leoFrame
import leo.core.leoMenu as leoMenu
import leo.commands.gotoCommands as gotoCommands
from leo.core.leoQt import isQt5, QtCore, QtGui, QtWidgets
from leo.core.leoQt import Qsci
import leo.plugins.qt_events as qt_events
import leo.plugins.qt_text as qt_text
import leo.plugins.qt_tree as qt_tree
from leo.plugins.mod_scripting import build_rclick_tree
import os
import sys
import platform
from collections import defaultdict
try:
    import leo.plugins.nested_splitter as nested_splitter
    splitter_class = nested_splitter.NestedSplitter
    nested_splitter.NestedSplitter.enabled = False
        # Disable special behavior, turned back on by associated plugin.
except ImportError:
    print('Can not import nested_splitter')
    splitter_class = QtWidgets.QSplitter
#@+node:ekr.20200303082457.1: *5* top-level commands (qt_frame.py)
#@+node:ekr.20200303082511.6: *6* 'contract-body-pane' & 'expand-outline-pane'
@g.command('contract-body-pane')
@g.command('expand-outline-pane')
def contractBodyPane(event):
    '''Contract the body pane. Expand the outline/log splitter.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = min(1.0, f.ratio + 0.1)
    f.divideLeoSplitter1(r)
    
expandOutlinePane = contractBodyPane
#@+node:ekr.20200303084048.1: *6* 'contract-log-pane'
@g.command('contract-log-pane')
def contractLogPane(event):
    '''Contract the log pane. Expand the outline pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = min(1.0, f.secondary_ratio + 0.1)
    f.divideLeoSplitter2(r)
#@+node:ekr.20200303084225.1: *6* 'contract-outline-pane' & 'expand-body-pane'
@g.command('contract-outline-pane')
@g.command('expand-body-pane')
def contractOutlinePane(event):
    '''Contract the outline pane. Expand the body pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = max(0.0, f.ratio - 0.1)
    f.divideLeoSplitter1(r)

expandBodyPane = contractOutlinePane
#@+node:ekr.20200303084226.1: *6* 'expand-log-pane'
@g.command('expand-log-pane')
def expandLogPane(event):
    '''Expand the log pane. Contract the outline pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = max(0.0, f.secondary_ratio - 0.1)
    f.divideLeoSplitter2(r)
#@+node:ekr.20200303084610.1: *6* 'hide-body-pane'
@g.command('hide-body-pane')
def hideBodyPane(event):
    '''Hide the body pane. Fully expand the outline/log splitter.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter1(1.0)
#@+node:ekr.20200303084625.1: *6* 'hide-log-pane'
@g.command('hide-log-pane')
def hideLogPane(event):
    '''Hide the log pane. Fully expand the outline pane.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter2(1.0)
#@+node:ekr.20200303082511.7: *6* 'hide-outline-pane'
@g.command('hide-outline-pane')
def hideOutlinePane(event):
    '''Hide the outline/log splitter. Fully expand the body pane.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter1(0.0)

#@+node:ekr.20110605121601.18137: *5* class  DynamicWindow (QMainWindow)
class DynamicWindow(QtWidgets.QMainWindow):
    """
    A class representing all parts of the main Qt window.
    
    c.frame.top is a DynamicWindow.
    c.frame.top.leo_master is a LeoTabbedTopLevel.
    c.frame.top.parent() is a QStackedWidget()

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    """
    @others
#@+node:ekr.20110605121601.18138: *6*  dw.ctor & reloadSettings
def __init__(self, c, parent=None):
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    if 'startup' in g.app.debug:
        print('DynamicWindow.__init__', c.shortFileName())
    super().__init__(parent)
    self.leo_c = c
    self.leo_master = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
#@+node:ekr.20110605121601.18172: *6* dw.do_leo_spell_btn_*
def doSpellBtn(self, btn):
    """Execute btn, a button handler."""
    # Make *sure* this never crashes.
    try:
        tab = self.leo_c.spellCommands.handler.tab
        button = getattr(tab, btn)
        button()
    except Exception:
        g.es_exception()

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@+node:ekr.20110605121601.18140: *6* dw.closeEvent
def closeEvent(self, event):
    """Handle a close event in the Leo window."""
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        event.accept()
        return
    if c.inCommand:
        c.requestCloseWindow = True
        return
    ok = g.app.closeLeoWindow(c.frame)
    if ok:
        event.accept()
    else:
        event.ignore()
#@+node:ekr.20110605121601.18139: *6* dw.construct & helpers
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')
        # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
#@+node:ekr.20140915062551.19519: *7* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
#@+node:ekr.20110605121601.18141: *6* dw.createMainWindow & helpers
def createMainWindow(self):
    """
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    """
    self.setMainWindowOptions()
    #
    # Legacy code: will not go away.
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        # Top pane contains only outline.  Bottom pane contains body and log panes.
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        # Top pane contains outline and log panes.
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(self)
    # Signals...
    QtCore.QMetaObject.connectSlotsByName(self)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18142: *7* dw.top-level
#@+node:ekr.20190118150859.10: *8* dw.addNewEditor
def addNewEditor(self, name):
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    #
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame
        # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    
#@+node:ekr.20110605121601.18143: *8* dw.createBodyPane
def createBodyPane(self, parent):
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=QtWidgets.QSizePolicy.Expanding,
         vPolicy=QtWidgets.QSizePolicy.Expanding,
    )
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
 
#@+node:ekr.20110605121601.18144: *8* dw.createCentralWidget
def createCentralWidget(self):
    """Create the central widget."""
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
    return w
#@+node:ekr.20110605121601.18145: *8* dw.createLogPane & helpers (legacy)
def createLogPane(self, parent):
    """Create all parts of Leo's log pane."""
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    #
    # #516 and #1507: Create a Find tab unless we are using a dialog.
    #
    # Careful: @bool minibuffer-ding-mode overrides @bool use-find-dialog.
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if use_minibuffer or not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Complete the Find tab in LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
#@+node:ekr.20131118172620.16858: *9* dw.finishCreateLogPane
def finishCreateLogPane(self):
    """It's useful to create this late, because c.config is now valid."""
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
#@+node:ekr.20110605121601.18146: *8* dw.createMainLayout
def createMainLayout(self, parent):
    """Create the layout for Leo's main window."""
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setObjectName('main_splitter')
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setObjectName('secondary_splitter')
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18147: *8* dw.createMenuBar
def createMenuBar(self):
    """Create Leo's menu bar."""
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
#@+node:ekr.20110605121601.18148: *8* dw.createMiniBuffer (class VisLineEdit)
def createMiniBuffer(self, parent):
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            super().focusInEvent(event)
                # Call the base class method.

        def focusOutEvent(self, event):
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
        # Transfers focus request from label to lineEdit.
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
#@+node:ekr.20110605121601.18149: *8* dw.createOutlinePane
def createOutlinePane(self, parent):
    """Create the widgets and ivars for Leo's outline."""
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
#@+node:ekr.20110605121601.18150: *8* dw.createStatusBar
def createStatusBar(self, parent):
    """Create the widgets and ivars for Leo's status area."""
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
#@+node:ekr.20110605121601.18212: *8* dw.packLabel
def packLabel(self, w, n=None):
    """
    Pack w into the body frame's QVGridLayout.
    
    The type of w does not affect the following code. In fact, w is a
    QTextBrowser possibly packed inside a LeoLineTextWidget.
    """
    c = self.leo_c
    #
    # Reuse the grid layout in the body frame.
    grid = self.leo_body_frame.layout()
    # Pack the label and the text widget.
    label = QtWidgets.QLineEdit(None)
    label.setObjectName('editorLabel')
    label.setText(c.p.h)
    if n is None:
        n = c.frame.body.numberOfEditors
    n = max(0, n - 1)
    grid.addWidget(label, 0, n)
    grid.addWidget(w, 1, n)
    grid.setRowStretch(0, 0)  # Don't grow the label vertically.
    grid.setRowStretch(1, 1)  # Give row 1 as much as vertical room as possible.
    # Inject the ivar.
    w.leo_label = label
#@+node:ekr.20110605121601.18151: *8* dw.setMainWindowOptions
def setMainWindowOptions(self):
    """Set default options for Leo's main window."""
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
#@+node:ekr.20110605121601.18152: *7* dw.widgets
#@+node:ekr.20110605121601.18153: *8* dw.createButton
def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18154: *8* dw.createCheckBox
def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18155: *8* dw.createFrame
def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    """Create a Qt Frame."""
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18156: *8* dw.createGrid
def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18157: *8* dw.createHLayout & createVLayout
def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
#@+node:ekr.20110605121601.18158: *8* dw.createLabel
def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18159: *8* dw.createLineEdit
def createLineEdit(self, parent, name, disabled=True):

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled  # Inject the ivar.
    return w
#@+node:ekr.20110605121601.18160: *8* dw.createRadioButton
def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18161: *8* dw.createStackedWidget
def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18162: *8* dw.createTabWidget
def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18163: *8* dw.createText (creates QTextBrowser)
def createText(self, parent, name,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18164: *8* dw.createTreeWidget
def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18165: *7* dw.log tabs
#@+node:ekr.20110605121601.18167: *8* dw.createSpellTab
def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for (ivar, label, row, col) in table:
        name = f"spell_{label}_button"
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, f"do_leo_spell_btn_{ivar}")
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, f"leo_spell_btn_{ivar}", button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent  # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox  # Must exist
    self.leo_spell_label = lab  # Must exist (!!)
#@+node:ekr.20110605121601.18166: *8* dw.createFindTab & helpers
def createFindTab(self, parent, tab_widget):
    """Create a Find Tab in the given parent."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0  # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget  # A scrollArea.
    ftm.init_widgets()
#@+node:ekr.20131118152731.16847: *9* dw.create_find_grid
def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
#@+node:ekr.20131118152731.16849: *9* dw.create_find_header
def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
#@+node:ekr.20131118152731.16848: *9* dw.create_find_findbox
def create_find_findbox(self, grid, parent, row):
    """Create the Find: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(
        parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16850: *9* dw.create_find_replacebox
def create_find_replacebox(self, grid, parent, row):
    """Create the Replace: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(
        parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:')  # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16851: *9* dw.create_find_checkboxes
def create_find_checkboxes(self, grid, parent, max_row2, row):
    """Create check boxes and radio buttons."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&', '').lower()
        return f"{kind}{name}"

    # Rows for check boxes, radio buttons & execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &Word', 0, 0),
        ('rb', '&Entire outline', 0, 1),
        # Second row.
        ('box', '&Ignore case', 1, 0),
        ('rb', '&Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &Around', 2, 0),
        ('rb', '&Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&Xp', 3, 0),
        ('box', 'search &Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &Finds', 4, 0),
        ('box', 'search &Body', 4, 1),
        # Sixth row.
        ('box', 'mark &Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
#@+node:ekr.20131118152731.16852: *9* dw.create_find_buttons
def create_find_buttons(self, grid, parent, max_row2, row):
    """
    Per #1342, this method now creates labels, not real buttons.
    """
    dw, k = self, self.leo_c.k

    # Create Buttons in column 2 (Leo 4.11.1.)
    table = (
        (0, 2, 'findButton', 'find-next'),
        (1, 2, 'findPreviousButton', 'find-prev'),
        (2, 2, 'findAllButton', 'find-all'),
        (3, 2, 'changeButton', 'replace'),
        (4, 2, 'changeThenFindButton', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'replace-all'),
    )
    for row2, col, func_name, cmd_name in table:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = f"{cmd_name}:  {k.prettyPrintKey(stroke)}"
        else:
            label = cmd_name
        # #1342: Create a label, not a button.
        w = dw.createLabel(parent, cmd_name, label)
        w.setObjectName('find-label')
        grid.addWidget(w, row + row2, col)
    row += max_row2
    row += 2
    return row
#@+node:ekr.20131118152731.16853: *9* dw.create_help_row
def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: <alt-x>help-for-find-commands<return>')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
#@+node:ekr.20150618072619.1: *9* dw.create_find_status
if 0:

    def create_find_status(self, grid, parent, row):
        """Create the status line."""
        dw = self
        status_label = dw.createLabel(parent, 'status-label', 'Status')
        status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
        grid.addWidget(status_label, row, 0)
        grid.addWidget(status_line, row, 1, 1, 2)
        # Official ivars.
        dw.find_status_label = status_label
        dw.find_status_edit = status_line
#@+node:ekr.20131118172620.16891: *9* dw.override_events
def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(
        c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(
        c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)

    if 0:  # #1342: These are no longer needed, because there are no buttons.
        table = (
            ('findNextCommand', 'find-next'),
            ('findPrevCommand', 'find-prev'),
            ('findAll', 'find-all'),
            ('changeCommand', 'replace'),
            ('changeThenFind', 'replace-then-find'),
            ('changeAll', 'replace-all'),
        )
        for func_name, cmd_name in table:
            ivar = f"{cmd_name}-{'button'}"
            ivar = ivar.replace('-', '_')
            w = getattr(ftm, ivar, None)
            func = getattr(fc, func_name, None)
            if w and func:
                next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
                EventWrapper(c, w=w, next_w=next_w, func=func)
            else:
                g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
#@+node:ekr.20131118172620.16892: *10* class EventWrapper
class EventWrapper:

    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper
    @others
#@+node:ekr.20131120054058.16281: *11* create_d
def create_d(self):
    """Create self.d dictionary."""
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
#@+node:ekr.20131118172620.16893: *11* wrapper
def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    if type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16894: *11* keyPress (EventWrapper)
def keyPress(self, event):

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16895: *11* keyRelease
def keyRelease(self, event):
    return self.oldEvent(event)
#@+node:ekr.20110605121601.18168: *7* dw.utils
#@+node:ekr.20110605121601.18169: *8* dw.setName
def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
#@+node:ekr.20110605121601.18170: *8* dw.setSizePolicy
def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
#@+node:ekr.20110605121601.18171: *8* dw.tr
def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    return QtWidgets.QApplication.translate(
        'MainWindow',
        s,
        None,
        QtWidgets.QApplication.UnicodeUTF8)
#@+node:ekr.20110605121601.18173: *6* dw.select
def select(self, c):
    """Select the window or tab for c."""
    # Called from the save commands.
    self.leo_master.select(c)
#@+node:ekr.20110605121601.18178: *6* dw.setGeometry (legacy)
def setGeometry(self, rect):
    """Set the window geometry, but only once when using the qt gui."""
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
        # Only set the geometry once, even for new files.
        if not hasattr(m, 'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            super().setGeometry(rect)
    else:
        super().setGeometry(rect)
#@+node:ekr.20110605121601.18177: *6* dw.setLeoWindowIcon
def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
    g.app.gui.attachLeoIcon(self)
#@+node:ekr.20110605121601.18174: *6* dw.setSplitDirection
def setSplitDirection(self, main_splitter, secondary_splitter, orientation):
    """Set the orientations of the splitters in the Leo main window."""
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    h, v = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
#@+node:ekr.20130804061744.12425: *6* dw.setWindowTitle
if 0:  # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
#@+node:ekr.20131117054619.16698: *5* class FindTabManager
class FindTabManager:
    """A helper class for the LeoFind class."""
    @others
#@+node:ekr.20131117120458.16794: *6*  ftm.ctor
def __init__(self, c):
    """Ctor for the FindTabManager class."""
    self.c = c
    self.entry_focus = None  # The widget that had focus before find-pane entered.
    # Find/change text boxes.
    self.find_findbox = None
    self.find_replacebox = None
    # Check boxes.
    self.check_box_ignore_case = None
    self.check_box_mark_changes = None
    self.check_box_mark_finds = None
    self.check_box_regexp = None
    self.check_box_search_body = None
    self.check_box_search_headline = None
    self.check_box_whole_word = None
    self.check_box_wrap_around = None
    # Radio buttons
    self.radio_button_entire_outline = None
    self.radio_button_node_only = None
    self.radio_button_suboutline_only = None
    # Push buttons
    self.find_next_button = None
    self.find_prev_button = None
    self.find_all_button = None
    self.help_for_find_commands_button = None
    self.replace_button = None
    self.replace_then_find_button = None
    self.replace_all_button = None
#@+node:ekr.20131117164142.16853: *6* ftm.text getters/setters
def getFindText(self):
    return self.find_findbox.text()

def getReplaceText(self):
    return self.find_replacebox.text()

getChangeText = getReplaceText

def setFindText(self, s):
    w = self.find_findbox
    s = g.checkUnicode(s)
    w.clear()
    w.insert(s)

def setReplaceText(self, s):
    w = self.find_replacebox
    s = g.checkUnicode(s)
    w.clear()
    w.insert(s)

setChangeText = setReplaceText
#@+node:ekr.20131119185305.16478: *6* ftm.clear_focus & init_focus & set_entry_focus
def clear_focus(self):
    self.entry_focus = None
    self.find_findbox.clearFocus()

def init_focus(self):
    self.set_entry_focus()
    w = self.find_findbox
    w.setFocus()
    s = w.text()
    w.setSelection(0, len(s))

def set_entry_focus(self):
    # Remember the widget that had focus, changing headline widgets
    # to the tree pane widget.  Headline widgets can disappear!
    c = self.c
    w = g.app.gui.get_focus(raw=True)
    if w != c.frame.body.wrapper.widget:
        w = c.frame.tree.treeWidget
    self.entry_focus = w
#@+node:ekr.20150619082825.1: *6* ftm.set_ignore_case
def set_ignore_case(self, aBool):
    """Set the ignore-case checkbox to the given value."""
    c = self.c
    c.findCommands.ignore_case = aBool
    w = self.check_box_ignore_case
    w.setChecked(aBool)
#@+node:ekr.20131117120458.16789: *6* ftm.init_widgets (creates callbacks)
def init_widgets(self):
    """
    Init widgets and ivars from c.config settings.
    Create callbacks that always keep the LeoFind ivars up to date.
    """
    c = self.c
    find = c.findCommands
    # Find/change text boxes.
    table = (
        ('find_findbox', 'find_text', '<find pattern here>'),
        ('find_replacebox', 'change_text', ''),
    )
    for ivar, setting_name, default in table:
        s = c.config.getString(setting_name) or default
        w = getattr(self, ivar)
        w.insert(s)
        if find.minibuffer_mode:
            w.clearFocus()
        else:
            w.setSelection(0, len(s))
    # Check boxes.
    table = (
        ('ignore_case', self.check_box_ignore_case),
        ('mark_changes', self.check_box_mark_changes),
        ('mark_finds', self.check_box_mark_finds),
        ('pattern_match', self.check_box_regexp),
        ('search_body', self.check_box_search_body),
        ('search_headline', self.check_box_search_headline),
        ('whole_word', self.check_box_whole_word),
        ('wrap', self.check_box_wrap_around),
    )
    for setting_name, w in table:
        val = c.config.getBool(setting_name, default=False)
        # The setting name is also the name of the LeoFind ivar.
        assert hasattr(find, setting_name), setting_name
        setattr(find, setting_name, val)
        if val:
            w.toggle()

        def check_box_callback(n, setting_name=setting_name, w=w):
            # The focus has already change when this gets called.
            # focus_w = QtWidgets.QApplication.focusWidget()
            val = w.isChecked()
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            # Too kludgy: we must use an accurate setting.
            # It would be good to have an "about to change" signal.
            # Put focus in minibuffer if minibuffer find is in effect.
            c.bodyWantsFocusNow()

        w.stateChanged.connect(check_box_callback)
    # Radio buttons
    table = (
        ('node_only', 'node_only', self.radio_button_node_only),
        ('entire_outline', None, self.radio_button_entire_outline),
        ('suboutline_only', 'suboutline_only', self.radio_button_suboutline_only),
    )
    for setting_name, ivar, w in table:
        val = c.config.getBool(setting_name, default=False)
        # The setting name is also the name of the LeoFind ivar.
        if ivar is not None:
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            w.toggle()

        def radio_button_callback(n, ivar=ivar, setting_name=setting_name, w=w):
            val = w.isChecked()
            find.radioButtonsChanged = True
            if ivar:
                assert hasattr(find, ivar), ivar
                setattr(find, ivar, val)

        w.toggled.connect(radio_button_callback)
    # Ensure one radio button is set.
    if not find.node_only and not find.suboutline_only:
        w = self.radio_button_entire_outline
        w.toggle()
#@+node:ekr.20131117120458.16792: *6* ftm.set_radio_button
def set_radio_button(self, name):
    """Set the value of the radio buttons"""
    c = self.c
    find = c.findCommands
    d = {
        # Name is not an ivar. Set by find.setFindScope... commands.
        'node-only': self.radio_button_node_only,
        'entire-outline': self.radio_button_entire_outline,
        'suboutline-only': self.radio_button_suboutline_only,
    }
    w = d.get(name)
    assert w
    # Most of the work will be done in the radio button callback.
    if not w.isChecked():
        w.toggle()
    if find.minibuffer_mode:
        find.showFindOptionsInStatusArea()
#@+node:ekr.20131117120458.16791: *6* ftm.toggle_checkbox
@nobeautify

def toggle_checkbox(self,checkbox_name):
    """Toggle the value of the checkbox whose name is given."""
    c = self.c
    find = c.findCommands
    if not find:
        return
    d = {
        'ignore_case':     self.check_box_ignore_case,
        'mark_changes':    self.check_box_mark_changes,
        'mark_finds':      self.check_box_mark_finds,
        'pattern_match':   self.check_box_regexp,
        'search_body':     self.check_box_search_body,
        'search_headline': self.check_box_search_headline,
        'whole_word':      self.check_box_whole_word,
        'wrap':            self.check_box_wrap_around,
    }
    w = d.get(checkbox_name)
    assert w
    assert hasattr(find,checkbox_name),checkbox_name
    w.toggle() # The checkbox callback toggles the ivar.
    if find.minibuffer_mode:
        find.showFindOptionsInStatusArea()
#@+node:ekr.20131115120119.17376: *5* class LeoBaseTabWidget(QTabWidget)
class LeoBaseTabWidget(QtWidgets.QTabWidget):
    """Base class for all QTabWidgets in Leo."""
    @others
#@+node:ekr.20131115120119.17390: *6* qt_base_tab.__init__
def __init__(self, *args, **kwargs):

    #
    # Called from frameFactory.createMaster.
    #
    self.factory = kwargs.get('factory')
    if self.factory:
        del kwargs['factory']
    super().__init__(*args, **kwargs)
    self.detached = []
    self.setMovable(True)

    def tabContextMenu(point):
        index = self.tabBar().tabAt(point)
        if index < 0:  # or (self.count() < 1 and not self.detached):
            return
        menu = QtWidgets.QMenu()
        # #310: Create new file on right-click in file tab in UI.
        if True:
            a = menu.addAction("New Outline")
            a.triggered.connect(lambda checked: self.new_outline(index))
        if self.count() > 1:
            a = menu.addAction("Detach")
            a.triggered.connect(lambda checked: self.detach(index))
            a = menu.addAction("Horizontal tile")
            a.triggered.connect(
                lambda checked: self.tile(index, orientation='H'))
            a = menu.addAction("Vertical tile")
            a.triggered.connect(
                lambda checked: self.tile(index, orientation='V'))
        if self.detached:
            a = menu.addAction("Re-attach All")
            a.triggered.connect(lambda checked: self.reattach_all())
        menu.exec_(self.mapToGlobal(point))

    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(tabContextMenu)
#@+node:ekr.20180123082452.1: *6* qt_base_tab.new_outline
def new_outline(self, index):
    """Open a new outline tab."""
    w = self.widget(index)
    c = w.leo_c
    c.new()
#@+node:ekr.20131115120119.17391: *6* qt_base_tab.detach
def detach(self, index):
    """detach tab (from tab's context menu)"""
    w = self.widget(index)
    name = self.tabText(index)
    self.detached.append((name, w))
    self.factory.detachTab(w)
    icon = g.app.gui.getImageFinder("application-x-leo-outline.png")
    icon = QtGui.QIcon(icon)
    if icon:
        w.window().setWindowIcon(icon)
    c = w.leo_c
    if c.styleSheetManager:
        c.styleSheetManager.set_style_sheets(w=w)
    if platform.system() == 'Windows':
        w.move(20, 20)
            # Windows (XP and 7) put the windows title bar off screen.
    return w
#@+node:ekr.20131115120119.17392: *6* qt_base_tab.tile
def tile(self, index, orientation='V'):
    """detach tab and tile with parent window"""
    w = self.widget(index)
    window = w.window()
    # window.showMaximized()
    # this doesn't happen until we've returned to main even loop
    # user needs to do it before using this function
    fg = window.frameGeometry()
    geom = window.geometry()
    x, y, fw, fh = fg.x(), fg.y(), fg.width(), fg.height()
    ww, wh = geom.width(), geom.height()
    w = self.detach(index)
    if window.isMaximized():
        window.showNormal()
    if orientation == 'V':
        # follow MS Windows convention for which way is horizontal/vertical
        window.resize(ww / 2, wh)
        window.move(x, y)
        w.resize(ww / 2, wh)
        w.move(x + fw / 2, y)
    else:
        window.resize(ww, wh / 2)
        window.move(x, y)
        w.resize(ww, wh / 2)
        w.move(x, y + fh / 2)
#@+node:ekr.20131115120119.17393: *6* qt_base_tab.reattach_all
def reattach_all(self):
    """reattach all detached tabs"""
    for name, w in self.detached:
        self.addTab(w, name)
        self.factory.leoFrames[w] = w.leo_c.frame
    self.detached = []
#@+node:ekr.20131115120119.17394: *6* qt_base_tab.delete
def delete(self, w):
    """called by TabbedFrameFactory to tell us a detached tab
    has been deleted"""
    self.detached = [i for i in self.detached if i[1] != w]
#@+node:ekr.20131115120119.17395: *6* qt_base_tab.setChanged
def setChanged(self, c, changed):
    """Set the changed indicator in c's tab."""
    # Find the tab corresponding to c.
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    if i < 0: return
    s = self.tabText(i)
    if len(s) > 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i, title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i, title)
#@+node:ekr.20131115120119.17396: *6* qt_base_tab.setTabName
def setTabName(self, c, fileName):
    """Set the tab name for c's tab to fileName."""
    # Find the tab corresponding to c.
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    if i > -1:
        self.setTabText(i, g.shortFileName(fileName))
#@+node:ekr.20131115120119.17397: *6* qt_base_tab.closeEvent
def closeEvent(self, event):
    """Handle a close event."""
    g.app.gui.close_event(event)
#@+node:ekr.20131115120119.17398: *6* qt_base_tab.select (leoTabbedTopLevel)
def select(self, c):
    """Select the tab for c."""
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    # Fix bug 844953: tell Unity which menu to use.
        # c.enableMenuBar()
#@+node:ekr.20110605121601.18180: *5* class LeoQtBody(leoFrame.LeoBody)
class LeoQtBody(leoFrame.LeoBody):
    """A class that represents the body pane of a Qt window."""
    @others
#@+node:ekr.20150521061618.1: *6* LeoQtBody.cmd (decorator)
def cmd(name):
    """Command decorator for the c.frame.body class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'body'])
#@+node:ekr.20110605121601.18181: *6* LeoQtBody.Birth
#@+node:ekr.20110605121601.18182: *7* LeoQtBody.ctor
def __init__(self, frame, parentFrame):
    """Ctor for LeoQtBody class."""
    # Call the base class constructor.
    super().__init__(frame, parentFrame)
    c = self.c
    assert c.frame == frame and frame.c == c
    self.reloadSettings()
    self.set_widget()
        # Sets self.widget and self.wrapper.
    self.setWrap(c.p)
    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
    # For renderer panes.
    self.canvasRenderer = None
    self.canvasRendererLabel = None
    self.canvasRendererVisible = False
    self.textRenderer = None
    self.textRendererLabel = None
    self.textRendererVisible = False
    self.textRendererWrapper = None
#@+node:ekr.20110605121601.18185: *8* LeoQtBody.get_name
def getName(self):
    return 'body-widget'
#@+node:ekr.20140901062324.18562: *8* LeoQtBody.reloadSettings
def reloadSettings(self):
    c = self.c
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_gutter = c.config.getBool('use-gutter', default=False)
#@+node:ekr.20160309074124.1: *8* LeoQtBody.set_invisibles
def set_invisibles(self, c):
    """Set the show-invisibles bit in the document."""
    d = c.frame.body.wrapper.widget.document()
    option = QtGui.QTextOption()
    if c.frame.body.colorizer.showInvisibles:
        option.setFlags(QtGui.QTextOption.ShowTabsAndSpaces)
    d.setDefaultTextOption(option)
#@+node:ekr.20140901062324.18563: *8* LeoQtBody.set_widget
def set_widget(self):
    """Set the actual gui widget."""
    c = self.c
    top = c.frame.top
    sw = getattr(top, 'stackedWidget', None)
    if sw:
        sw.setCurrentIndex(1)
    if self.useScintilla and not Qsci:
        g.trace('Can not import Qsci: ignoring @bool qt-use-scintilla')
    if self.useScintilla and Qsci:
        self.widget = c.frame.top.scintilla_widget
            # A Qsci.QsciSintilla object.
            # dw.createText sets self.scintilla_widget
        self.wrapper = qt_text.QScintillaWrapper(self.widget, name='body', c=c)
        self.colorizer = leoColorizer.QScintillaColorizer(
            c, self.widget, self.wrapper)
    else:
        self.widget = top.richTextEdit  # A LeoQTextBrowser
        self.wrapper = qt_text.QTextEditWrapper(self.widget, name='body', c=c)
        self.widget.setAcceptRichText(False)
        self.colorizer = leoColorizer.make_colorizer(c, self.widget, self.wrapper)
#@+node:ekr.20110605121601.18183: *8* LeoQtBody.setWrap
def setWrap(self, p=None, force=False):
    """Set **only** the wrap bits in the body."""
    if not p or self.useScintilla:
        return
    c = self.c
    w = c.frame.body.wrapper.widget
    option, qt = QtGui.QTextOption, QtCore.Qt
    if force:
        wrap = option.WrapAtWordBoundaryOrAnywhere
    else:
        wrap = g.scanAllAtWrapDirectives(c, p)
        w.setHorizontalScrollBarPolicy(
            qt.ScrollBarAlwaysOff if wrap else qt.ScrollBarAsNeeded)
        wrap = option.WrapAtWordBoundaryOrAnywhere if wrap else option.NoWrap
            # was option WordWrap
    w.setWordWrapMode(wrap)
#@+node:ekr.20110605121601.18193: *6* LeoQtBody.Editors
#@+node:ekr.20110605121601.18194: *7* LeoQtBody.entries
#@+node:ekr.20110605121601.18195: *8* LeoQtBody.add_editor_command
# An override of leoFrame.addEditor.

@cmd('editor-add')
@cmd('add-editor')
def add_editor_command(self, event=None):
    """Add another editor to the body pane."""
    c, p = self.c, self.c.p
    d = self.editorWrappers
    dw = c.frame.top
    wrapper = c.frame.body.wrapper  # A QTextEditWrapper
    widget = wrapper.widget
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.totalNumberOfEditors == 2:
        d ['1'] = wrapper
        # Pack the original body editor.
        # Fix #1021: Pack differently depending on whether the gutter exists.
        if self.use_gutter:
            dw.packLabel(widget.parent(), n=1)
            widget.leo_label = widget.parent().leo_label
        else:
            dw.packLabel(widget, n=1)
    name = f"{self.totalNumberOfEditors}"
    f, wrapper = dw.addNewEditor(name)
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(widget), widget
    assert isinstance(f, QtWidgets.QFrame), f
    d[name] = wrapper
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        keys = list(d.keys())
        old_name = keys[0]
        old_wrapper = d.get(old_name)
        old_w = old_wrapper.widget
        self.injectIvars(f, old_name, p, old_wrapper)
        self.updateInjectedIvars(old_w, p)
        self.selectLabel(old_wrapper)
             # Immediately create the label in the old editor.
    # Switch editors.
    c.frame.body.wrapper = wrapper
    self.selectLabel(wrapper)
    self.selectEditor(wrapper)
    self.updateEditors()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18197: *8* LeoQtBody.assignPositionToEditor
def assignPositionToEditor(self, p):
    """Called *only* from tree.select to select the present body editor."""
    c = self.c
    wrapper = c.frame.body.wrapper
    w = wrapper and wrapper.widget
        # Careful: w may not exist during unit testing.
    if w:
        self.updateInjectedIvars(w, p)
        self.selectLabel(wrapper)
#@+node:ekr.20110605121601.18198: *8* LeoQtBody.cycleEditorFocus
# Use the base class method.
#@+node:ekr.20110605121601.18199: *8* LeoQtBody.delete_editor_command
@cmd('delete-editor')
@cmd('editor-delete')
def delete_editor_command(self, event=None):
    """Delete the presently selected body text editor."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    # Fix bug 228: make *sure* the old text is saved.
    c.p.b = wrapper.getAllText()
    name = getattr(w, 'leo_name', None)
    if len(list(d.keys())) <= 1 or name == '1':
        g.warning('can not delete main editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        label = getattr(w, 'leo_label', None)
        if label:
            self.unpackWidget(layout, label)
    w.leo_label = None
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18200: *8* LeoQtBody.findEditorForChapter
def findEditorForChapter(self, chapter, p):
    """Return an editor to be assigned to chapter."""
    c, d = self.c, self.editorWrappers
    values = list(d.values())
    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w, 'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w, 'leo_p') and w.leo_p and w.leo_p == p
            ):
                return w
    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w, 'leo_chapter') and w.leo_chapter == chapter:
            return w
    # As a last resort, return the present editor widget.
    return c.frame.body.wrapper
#@+node:ekr.20110605121601.18201: *8* LeoQtBody.select/unselectLabel
def unselectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    pass
    # self.createChapterIvar(wrapper)

def selectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    c = self.c
    w = wrapper.widget
    label = getattr(w, 'leo_label', None)
    if label:
        label.setEnabled(True)
        label.setText(c.p.h)
        label.setEnabled(False)
#@+node:ekr.20110605121601.18202: *8* LeoQtBody.selectEditor & helpers
selectEditorLockout = False

def selectEditor(self, wrapper):
    """Select editor w and node w.leo_p."""
    # pylint: disable=arguments-differ
    trace = 'select' in g.app.debug and not g.unitTesting
    tag = 'qt_body.selectEditor'
    c = self.c
    if not wrapper:
        return c.frame.body.wrapper
    if self.selectEditorLockout:
        return None
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if trace:
        print(f"{tag:>30}: {wrapper} {c.p.h}")
    if wrapper and wrapper == c.frame.body.wrapper:
        self.deactivateEditors(wrapper)
        if hasattr(w, 'leo_p') and w.leo_p and w.leo_p != c.p:
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        return None
    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False
    return val  # Don't put a return in a finally clause.
#@+node:ekr.20110605121601.18203: *9* LeoQtBody.selectEditorHelper
def selectEditorHelper(self, wrapper):

    c = self.c
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if not w.leo_p:
        g.trace('no w.leo_p')
        return 'break'
    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget(w.leo_p, wrapper)  # switches colorizers.
    c.frame.body.wrapper = wrapper
    # 2014/09/04: Must set both wrapper.widget and body.widget.
    c.frame.body.wrapper.widget = w
    c.frame.body.widget = w
    w.leo_active = True
    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)
    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w, 'leo_p') and w.leo_p):
        g.trace('***** no w.leo_p', w)
        return None
    p = w.leo_p
    assert p, p
    c.expandAllAncestors(p)
    c.selectPosition(p)
        # Calls assignPositionToEditor.
        # Calls p.v.restoreCursorAndScroll.
    c.redraw()
    c.recolor()
    c.bodyWantsFocus()
    return None
#@+node:ekr.20110605121601.18205: *8* LeoQtBody.updateEditors
# Called from addEditor and assignPositionToEditor

def updateEditors(self):
    c, p = self.c, self.c.p;
    body = p.b
    d = self.editorWrappers
    if len(list(d.keys())) < 2:
        return  # There is only the main widget
    w0 = c.frame.body.wrapper
    i, j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w, 'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p, wrapper)
            sb.setSliderPosition(pos)
    c.bodyWantsFocus()
    w0.setSelectionRange(i, j, insert=ins)
    sb0.setSliderPosition(pos0)
#@+node:ekr.20110605121601.18206: *7* LeoQtBody.utils
#@+node:ekr.20110605121601.18207: *8* LeoQtBody.computeLabel
def computeLabel(self, w):
    if hasattr(w, 'leo_label') and w.leo_label:  # 2011/11/12
        s = w.leo_label.text()
    else:
        s = ''
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        s = f"{w.leo_chapter}: {s}"
    return s
#@+node:ekr.20110605121601.18208: *8* LeoQtBody.createChapterIvar
def createChapterIvar(self, w):
    c = self.c; cc = c.chapterController
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        pass
    elif cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
#@+node:ekr.20110605121601.18209: *8* LeoQtBody.deactivateEditors
def deactivateEditors(self, wrapper):
    """Deactivate all editors except wrapper's editor."""
    d = self.editorWrappers
    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2, 'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            self.onFocusOut(w2)
#@+node:ekr.20110605121601.18210: *8* LeoQtBody.ensurePositionExists
def ensurePositionExists(self, w):
    """Return True if w.leo_p exists or can be reconstituted."""
    c = self.c
    if c.positionExists(w.leo_p):
        return True
    for p2 in c.all_unique_positions():
        if p2.v and p2.v == w.leo_p.v:
            w.leo_p = p2.copy()
            return True
    # This *can* happen when selecting a deleted node.
    w.leo_p = c.p.copy()
    return False
#@+node:ekr.20110605121601.18211: *8* LeoQtBody.injectIvars
def injectIvars(self, parentFrame, name, p, wrapper):

    trace = g.app.debug == 'select' and not g.app.unitTesting
    tag = 'qt_body.injectIvars'
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if trace:
        print(f"{tag:>30}: {wrapper!r} {g.callers(1)}")
    # Inject ivars
    if name == '1':
        w.leo_p = None  # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in JEditColorizer ctor.
    w.leo_frame = parentFrame
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    w.leo_wrapper = wrapper
#@+node:ekr.20110605121601.18213: *8* LeoQtBody.recolorWidget (QScintilla only)
def recolorWidget(self, p, wrapper):
    """Support QScintillaColorizer.colorize."""
    # pylint: disable=arguments-differ
    c = self.c
    colorizer = c.frame.body.colorizer
    if p and colorizer and hasattr(colorizer, 'colorize'):
        g.trace('=====', hasattr(colorizer, 'colorize'), p.h, g.callers())
        old_wrapper = c.frame.body.wrapper
        c.frame.body.wrapper = wrapper
        try:
            colorizer.colorize(p)
        finally:
            # Restore.
            c.frame.body.wrapper = old_wrapper
#@+node:ekr.20110605121601.18214: *8* LeoQtBody.switchToChapter
def switchToChapter(self, w):
    """select w.leo_chapter."""
    c = self.c; cc = c.chapterController
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
#@+node:ekr.20110605121601.18216: *8* LeoQtBody.unpackWidget
def unpackWidget(self, layout, w):

    index = layout.indexOf(w)
    if index == -1:
        return
    item = layout.itemAt(index)
    if item:
        item.setGeometry(QtCore.QRect(0, 0, 0, 0))
        layout.removeItem(item)
#@+node:ekr.20110605121601.18215: *8* LeoQtBody.updateInjectedIvars
def updateInjectedIvars(self, w, p):

    c = self.c
    cc = c.chapterController
    assert g.isTextWidget(w), w
    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
    w.leo_p = p.copy()
#@+node:ekr.20110605121601.18223: *6* LeoQtBody.Event handlers
#@+node:ekr.20110930174206.15472: *7* LeoQtBody.onFocusIn
def onFocusIn(self, obj):
    """Handle a focus-in event in the body pane."""
    trace = 'select' in g.app.debug and not g.unitTesting
    tag = 'qt_body.onFocusIn'
    if obj.objectName() == 'richTextEdit':
        wrapper = getattr(obj, 'leo_wrapper', None)
        if trace:
            print(f"{tag:>30}: {wrapper}")
        if wrapper and wrapper != self.wrapper:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in', obj)
        if hasattr(obj, 'leo_copy_button') and obj.leo_copy_button:
            obj.setReadOnly(True)
        else:
            obj.setReadOnly(False)
        obj.setFocus()  # Weird, but apparently necessary.
#@+node:ekr.20110930174206.15473: *7* LeoQtBody.onFocusOut
def onFocusOut(self, obj):
    """Handle a focus-out event in the body pane."""
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out', obj)
        obj.setReadOnly(True)
#@+node:ekr.20110605121601.18224: *7* LeoQtBody.qtBody.onFocusColorHelper (revised)
# badFocusColors = []

def onFocusColorHelper(self, kind, obj):
    """Handle changes of style when focus changes."""
    c, vc = self.c, self.c.vimCommands
    if vc and c.vim_mode:
        try:
            assert kind in ('focus-in', 'focus-out')
            w = c.frame.body.wrapper.widget
            vc.set_border(w=w, activeFlag=kind == 'focus-in')
        except Exception:
            # g.es_exception()
            pass
#@+node:ekr.20110605121601.18217: *6* LeoQtBody.Renderer panes
#@+node:ekr.20110605121601.18218: *7* LeoQtBody.hideCanvasRenderer
def hideCanvasRenderer(self, event=None):
    """Hide canvas pane."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name), 'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) <= 1: return
    #
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    w.leo_label = None
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label:  # 2011/11/12
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None  # 2011/11/12
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18219: *7* LeoQtBody.hideTextRenderer
def hideCanvas(self, event=None):
    """Hide canvas pane."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name), 'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) <= 1: return
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    w.leo_label = None
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label:
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18220: *7* LeoQtBody.packRenderer
def packRenderer(self, f, name, w):
    n = max(1, self.numberOfEditors)
    assert isinstance(f, QtWidgets.QFrame), f
    layout = f.layout()
    f.setObjectName(f"{name} Frame")
    # Create the text: to do: use stylesheet to set font, height.
    lab = QtWidgets.QLineEdit(f)
    lab.setObjectName(f"{name} Label")
    lab.setText(name)
    # Pack the label and the widget.
    layout.addWidget(lab, 0, max(0, n - 1), QtCore.Qt.AlignVCenter)
    layout.addWidget(w, 1, max(0, n - 1))
    layout.setRowStretch(0, 0)
    layout.setRowStretch(1, 1)  # Give row 1 as much as possible.
    return lab
#@+node:ekr.20110605121601.18221: *7* LeoQtBody.showCanvasRenderer
# An override of leoFrame.addEditor.

def showCanvasRenderer(self, event=None):
    """Show the canvas area in the body pane, creating it if necessary."""
    c = self.c
    f = c.frame.top.leo_body_inner_frame
    assert isinstance(f, QtWidgets.QFrame), f
    if not self.canvasRenderer:
        name = 'Graphics Renderer'
        self.canvasRenderer = w = QtWidgets.QGraphicsView(f)
        w.setObjectName(name)
    if not self.canvasRendererVisible:
        self.canvasRendererLabel = self.packRenderer(f, name, w)
        self.canvasRendererVisible = True
#@+node:ekr.20110605121601.18222: *7* LeoQtBody.showTextRenderer
# An override of leoFrame.addEditor.

def showTextRenderer(self, event=None):
    """Show the canvas area in the body pane, creating it if necessary."""
    c = self.c
    f = c.frame.top.leo_body_inner_frame
    assert isinstance(f, QtWidgets.QFrame), f
    if not self.textRenderer:
        name = 'Text Renderer'
        self.textRenderer = w = qt_text.LeoQTextBrowser(f, c, self)
        w.setObjectName(name)
        self.textRendererWrapper = qt_text.QTextEditWrapper(
            w, name='text-renderer', c=c)
    if not self.textRendererVisible:
        self.textRendererLabel = self.packRenderer(f, name, w)
        self.textRendererVisible = True
#@+node:ekr.20110605121601.18245: *5* class LeoQtFrame (leoFrame)
class LeoQtFrame(leoFrame.LeoFrame):
    """A class that represents a Leo window rendered in qt."""
    @others
#@+node:ekr.20110605121601.18246: *6*  qtFrame.Birth & Death
#@+node:ekr.20110605121601.18247: *7* qtFrame.__init__ & reloadSettings
def __init__(self, c, title, gui):

    super().__init__(c, gui)
    assert self.c == c
    leoFrame.LeoFrame.instances += 1  # Increment the class var.
    # Official ivars...
    self.iconBar = None
    self.iconBarClass = self.QtIconBarClass
    self.initComplete = False  # Set by initCompleteHint().
    self.minibufferVisible = True
    self.statusLineClass = self.QtStatusLineClass
    self.title = title
    self.setIvars()
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.cursorStay = c.config.getBool("cursor-stay-on-paste", default=True)
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_chapter_tabs = c.config.getBool('use-chapter-tabs')
#@+node:ekr.20110605121601.18248: *8* qtFrame.setIvars
def setIvars(self):
    # "Official ivars created in createLeoFrame and its allies.
    self.bar1 = None
    self.bar2 = None
    self.body = None
    self.f1 = self.f2 = None
    self.findPanel = None  # Inited when first opened.
    self.iconBarComponentName = 'iconBar'
    self.iconFrame = None
    self.log = None
    self.canvas = None
    self.outerFrame = None
    self.statusFrame = None
    self.statusLineComponentName = 'statusLine'
    self.statusText = None
    self.statusLabel = None
    self.top = None  # This will be a class Window object.
    self.tree = None
    # Used by event handlers...
    self.controlKeyIsDown = False  # For control-drags
    self.isActive = True
    self.redrawCount = 0
    self.wantedWidget = None
    self.wantedCallbackScheduled = False
    self.scrollWay = None
#@+node:ekr.20110605121601.18249: *7* qtFrame.__repr__
def __repr__(self):
    return f"<LeoQtFrame: {self.title}>"
#@+node:ekr.20150509040227.1: *7* qtFrame.cmd (decorator)
def cmd(name):
    """Command decorator for the LeoQtFrame class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame',])
#@+node:ekr.20110605121601.18250: *7* qtFrame.finishCreate & helpers
def finishCreate(self):
    """Finish creating the outline's frame."""
    # Called from app.newCommander, Commands.__init__
    c = self.c
    assert c
    frameFactory = g.app.gui.frameFactory
    if not frameFactory.masterFrame:
        frameFactory.createMaster()
    self.top = frameFactory.createFrame(leoFrame=self)
    self.createIconBar()  # A base class method.
    self.createSplitterComponents()
    self.createStatusLine()  # A base class method.
    self.createFirstTreeNode()  # Call the base-class method.
    self.menu = LeoQtMenu(c, self, label='top-level-menu')
    g.app.windowList.append(self)
    self.setQtStyle()
    self.miniBufferWidget = qt_text.QMinibufferWrapper(c)
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18251: *8* qtFrame.createSplitterComponents
def createSplitterComponents(self):

    c = self.c
    self.tree = qt_tree.LeoQtTree(c, self)
    self.log = LeoQtLog(self, None)
    self.body = LeoQtBody(self, None)
    self.splitVerticalFlag, ratio, secondary_ratio = self.initialRatios()
    self.resizePanesToRatio(ratio, secondary_ratio)
#@+node:ekr.20190412044556.1: *8* qtFrame.setQtStyle
def setQtStyle(self):
    """
    Set the default Qt style.  Based on pyzo code.
    
    Copyright (C) 2013-2018, the Pyzo development team

    Pyzo is distributed under the terms of the (new) BSD License.
    The full license can be found in 'license.txt'.
    """
    c = self.c
    trace = 'themes' in g.app.debug
    #
    # Get the requested style name.
    stylename = c.config.getString('qt-style-name') or ''
    if trace: g.trace(repr(stylename))
    if not stylename:
        return
    #
    # Return if the style does not exist.
    styles = [z.lower() for z in QtWidgets.QStyleFactory.keys()]
    if stylename.lower() not in styles:
        g.es_print(f"ignoring unknown Qt style name: {stylename!r}")
        g.printObj(styles)
        return
    #
    # Change the style and palette.
    QtWidgets.qApp.nativePalette = QtWidgets.qApp.palette()
    qstyle = QtWidgets.qApp.setStyle(stylename)
    if not qstyle:
        g.es_print(f"failed to set Qt style name: {stylename!r}")
        return
    g.app.gui.qtApp.setPalette(QtWidgets.qApp.nativePalette)
    # g.es_print('set qt style: %r' % stylename)
#@+node:ekr.20110605121601.18252: *7* qtFrame.initCompleteHint
def initCompleteHint(self):
    """A kludge: called to enable text changed events."""
    self.initComplete = True
#@+node:ekr.20110605121601.18253: *7* Destroying the qtFrame
#@+node:ekr.20110605121601.18254: *8* qtFrame.destroyAllObjects (not used)
def destroyAllObjects(self):
    """Clear all links to objects in a Leo window."""
    frame = self; c = self.c
    # g.printGcAll()
    # Do this first.
    << clear all vnodes in the tree >>
    if 1:
        # Destroy all ivars in subcommanders.
        g.clearAllIvars(c.atFileCommands)
        if c.chapterController:  # New in Leo 4.4.3 b1.
            g.clearAllIvars(c.chapterController)
        g.clearAllIvars(c.fileCommands)
        g.clearAllIvars(c.keyHandler)  # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.importCommands)
        g.clearAllIvars(c.tangleCommands)
        g.clearAllIvars(c.undoer)
        g.clearAllIvars(c)
    if 0:  # No need.
        tree = frame.tree; body = self.body
        g.clearAllIvars(body.colorizer)
        g.clearAllIvars(body)
        g.clearAllIvars(tree)
#@+node:ekr.20110605121601.18255: *9* << clear all vnodes in the tree>> (qtFrame)
vList = [z for z in c.all_unique_nodes()]
for v in vList:
    g.clearAllIvars(v)
vList = []  # Remove these references immediately.
#@+node:ekr.20110605121601.18256: *8* qtFrame.destroySelf
def destroySelf(self):
    # Remember these: we are about to destroy all of our ivars!
    c, top = self.c, self.top
    if hasattr(g.app.gui, 'frameFactory'):
        g.app.gui.frameFactory.deleteFrame(top)
    # Indicate that the commander is no longer valid.
    c.exists = False
    if 0:  # We can't do this unless we unhook the event filter.
        # Destroys all the objects of the commander.
        self.destroyAllObjects()
    c.exists = False  # Make sure this one ivar has not been destroyed.
    # print('destroySelf: qtFrame: %s' % c,g.callers(4))
    top.close()
#@+node:ekr.20110605121601.18257: *6* qtFrame.class QtStatusLineClass
class QtStatusLineClass:
    """A class representing the status line."""
    @others
#@+node:ekr.20110605121601.18258: *7* QtStatusLineClass.ctor
def __init__(self, c, parentFrame):
    """Ctor for LeoQtFrame class."""
    self.c = c
    self.statusBar = c.frame.top.statusBar
    self.lastFcol = 0
    self.lastRow = 0
    self.lastCol = 0
    # Create the text widgets.
    self.textWidget1 = w1 = QtWidgets.QLineEdit(self.statusBar)
    self.textWidget2 = w2 = QtWidgets.QLineEdit(self.statusBar)
    w1.setObjectName('status1')
    w2.setObjectName('status2')
    w1.setReadOnly(True)
    w2.setReadOnly(True)
    splitter = QtWidgets.QSplitter()
    self.statusBar.addWidget(splitter, True)
    sizes = c.config.getString('status-line-split-sizes') or '1 2'
    sizes = [int(i) for i in sizes.replace(',', ' ').split()]
    # pylint: disable=consider-using-ternary
    for n, i in enumerate(sizes):
        w = [w1, w2][n]
        policy = w.sizePolicy()
        policy.setHorizontalStretch(i)
        policy.setHorizontalPolicy(policy.Minimum)
        w.setSizePolicy(policy)
    splitter.addWidget(w1)
    splitter.addWidget(w2)
    c.status_line_unl_mode = 'original'

    def cycle_unl_mode():
        if c.status_line_unl_mode == 'original':
            c.status_line_unl_mode = 'canonical'
        else:
            c.status_line_unl_mode = 'original'
        verbose = c.status_line_unl_mode == 'canonical'
        w2.setText(c.p.get_UNL(with_proto=verbose, with_index=verbose))

    def add_item(event, w2=w2):
        menu = w2.createStandardContextMenu()
        menu.addSeparator()
        menu.addAction("Toggle UNL mode", cycle_unl_mode)
        menu.exec_(event.globalPos())

    w2.contextMenuEvent = add_item
    self.put('')
    self.update()
#@+node:ekr.20110605121601.18260: *7* QtStatusLineClass.clear, get & put/1
def clear(self):
    self.put('')

def get(self):
    return self.textWidget2.text()

def put(self, s, bg=None, fg=None):
    self.put_helper(s, self.textWidget2, bg, fg)

def put1(self, s, bg=None, fg=None):
    self.put_helper(s, self.textWidget1, bg, fg)

styleSheetCache = {}
    # Keys are widgets, values are stylesheets.

def put_helper(self, s, w, bg=None, fg=None):
    """Put string s in the indicated widget, with proper colors."""
    c = self.c
    bg = bg or c.config.getColor('status-bg') or 'white'
    fg = fg or c.config.getColor('status-fg') or 'black'
    if True:
        # Work around #804. w is a QLineEdit.
        w.setStyleSheet(f"background: {bg}; color: {fg};")
    else:
        # Rather than put(msg, explicit_color, explicit_color) we should use
        # put(msg, status) where status is None, 'info', or 'fail'.
        # Just as a quick hack to avoid dealing with propagating those changes
        # back upstream, infer status like this:
        if (
            fg == c.config.getColor('find-found-fg') and
            bg == c.config.getColor('find-found-bg')
        ):
            status = 'info'
        elif (
            fg == c.config.getColor('find-not-found-fg') and
            bg == c.config.getColor('find-not-found-bg')
        ):
            status = 'fail'
        else:
            status = None
        d = self.styleSheetCache
        if status != d.get(w, '__undefined__'):
            d[w] = status
            c.styleSheetManager.mng.remove_sclass(w, ['info', 'fail'])
            c.styleSheetManager.mng.add_sclass(w, status)
            c.styleSheetManager.mng.update_view(w)  # force appearance update
    w.setText(s)
#@+node:chris.20180320072817.1: *7* QtStatusLineClass.update & helpers
def update(self):
    if g.app.killed: return
    c, body = self.c, self.c.frame.body
    if not c.p:
        return
    te = body.widget
    if not isinstance(te, QtWidgets.QTextEdit):
        return
    cursor = te.textCursor()
    block = cursor.block()
    row = block.blockNumber() + 1
    col, fcol = self.compute_columns(block, cursor)
    words = len(c.p.b.split(None))
    self.put_status_line(col, fcol, row, words)
    self.lastRow = row
    self.lastCol = col
    self.lastFcol = fcol
#@+node:ekr.20190118082646.1: *8* qstatus.compute_columns
def compute_columns(self, block, cursor):

    c = self.c
    line = block.text()
    col = cursor.columnNumber()
    offset = c.p.textOffset()
    fcol_offset = 0
    s2 = line[0:col]
    col = g.computeWidth(s2, c.tab_width)
    #
    # #195: fcol when using @first directive is inaccurate
    i = line.find('<<')
    j = line.find('>>')
    if -1 < i < j or g.match_word(line.strip(), 0, '@others'):
        offset = None
    else:
        for tag in ('@first ', '@last '):
            if line.startswith(tag):
                fcol_offset = len(tag)
                break
    #
    # fcol is '' if there is no ancestor @<file> node.
    fcol = None if offset is None else max(0, col + offset - fcol_offset)
    return col, fcol
#@+node:chris.20180320072817.2: *8* qstatus.file_line (not used)
def file_line(self):
    """
    Return the line of the first line of c.p in its external file.
    Return None if c.p is not part of an external file.
    """
    c, p = self.c, self.c.p
    if p:
        goto = gotoCommands.GoToCommands(c)
        return goto.find_node_start(p)
    return None
#@+node:ekr.20190118082047.1: *8* qstatus.put_status_line
def put_status_line(self, col, fcol, row, words):

    if 1:
        fcol_part = '' if fcol is None else f" fcol: {fcol}"
        # For now, it seems to0 difficult to get alignment *exactly* right.
        self.put1(f"line: {row:d} col: {col:d} {fcol_part} words: {words}")
    else:
        # #283 is not ready yet, and probably will never be.
        fline = self.file_line()
        fline = '' if fline is None else fline + row
        self.put1(
            f"fline: {fline:2} line: {row:2d} col: {col:2} fcol: {fcol:2}")
#@+node:ekr.20110605121601.18262: *6* qtFrame.class QtIconBarClass
class QtIconBarClass:
    """A class representing the singleton Icon bar"""
    @others
#@+node:ekr.20110605121601.18263: *7*  ctor & reloadSettings (QtIconBarClass)
def __init__(self, c, parentFrame):
    """Ctor for QtIconBarClass."""
    # Copy ivars
    self.c = c
    self.parentFrame = parentFrame
    # Status ivars.
    self.actions = []
    self.chapterController = None
    self.toolbar = self
    self.w = c.frame.top.iconBar  # A QToolBar.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.buttonColor = c.config.getString('qt-button-color')
    self.toolbar_orientation = c.config.getString('qt-toolbar-location')
#@+node:ekr.20110605121601.18264: *7*  do-nothings (QtIconBarClass)
# These *are* called from Leo's core.

def addRow(self, height=None):
    pass  # To do.

def getNewFrame(self):
    return None  # To do
#@+node:ekr.20110605121601.18265: *7* add (QtIconBarClass)
def add(self, *args, **keys):
    """Add a button to the icon bar."""
    c = self.c
    if not self.w:
        return None
    command = keys.get('command')
    text = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction = keys.get('qaction')
    if not text and not qaction:
        g.es('bad toolbar item')
    kind = keys.get('kind') or 'generic-button'
    # imagefile = keys.get('imagefile')
    # image = keys.get('image')


    class leoIconBarButton(QtWidgets.QWidgetAction):

        def __init__(self, parent, text, toolbar):
            super().__init__(parent)
            self.button = None  # set below
            self.text = text
            self.toolbar = toolbar

        def createWidget(self, parent):
            self.button = b = QtWidgets.QPushButton(self.text, parent)
            self.button.setProperty('button_kind', kind)  # for styling
            return b

    if qaction is None:
        action = leoIconBarButton(parent=self.w, text=text, toolbar=self)
        button_name = text
    else:
        action = qaction
        button_name = action.text()
    self.w.addAction(action)
    self.actions.append(action)
    b = self.w.widgetForAction(action)
    # Set the button's object name so we can use the stylesheet to color it.
    if not button_name: button_name = 'unnamed'
    button_name = button_name + '-button'
    b.setObjectName(button_name)
    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(checked, action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtWidgets.QAction('Remove Button', b)
    b.addAction(rb)
    rb.triggered.connect(delete_callback)
    if command:

        def button_callback(event, c=c, command=command):
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        b.clicked.connect(button_callback)
    return action
#@+node:ekr.20110605121601.18266: *7* addRowIfNeeded
def addRowIfNeeded(self):
    """Add a new icon row if there are too many widgets."""
    # n = g.app.iconWidgetCount
    # if n >= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()
    # g.app.iconWidgetCount += 1
#@+node:ekr.20110605121601.18267: *7* addWidget
def addWidget(self, w):
    self.w.addWidget(w)
#@+node:ekr.20110605121601.18268: *7* clear (QtIconBarClass)
def clear(self):
    """Destroy all the widgets in the icon bar"""
    self.w.clear()
    self.actions = []
    g.app.iconWidgetCount = 0
#@+node:ekr.20110605121601.18269: *7* createChaptersIcon
def createChaptersIcon(self):

    c = self.c
    f = c.frame
    if f.use_chapters and f.use_chapter_tabs:
        return LeoQtTreeTab(c, f.iconBar)
    return None
#@+node:ekr.20110605121601.18270: *7* deleteButton
def deleteButton(self, w):
    """ w is button """
    self.w.removeAction(w)
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@+node:ekr.20141031053508.14: *7* goto_command (QtIconBarClass)
def goto_command(self, controller, gnx):
    """
    Select the node corresponding to the given gnx.
    controller is a ScriptingController instance.
    """
    # Fix bug 74: command_p may be in another outline.
    c = self.c
    c2, p = controller.open_gnx(c, gnx)
    if p:
        assert c2.positionExists(p)
        if c == c2:
            c2.selectPosition(p)
        else:
            g.app.selectLeoWindow(c2)
            # Fix #367: Process events before selecting.
            g.app.gui.qtApp.processEvents()
            c2.selectPosition(p)
    else:
        g.trace('not found', gnx)
#@+node:ekr.20110605121601.18271: *7* setCommandForButton (@rclick nodes) & helper
# qtFrame.QtIconBarClass.setCommandForButton

def setCommandForButton(
    self, button, command, command_p, controller, gnx, script):
    """
    Set the "Goto Script" rlick item of an @button button.
    Called from mod_scripting.py plugin.

    button is a leoIconBarButton.
    command is a callback, defined in mod_scripting.py.
    command_p exists only if the @button node exists in the local .leo file.
    gnx is the gnx of the @button node.
    script is a static script for common @button nodes.
    """
    if not command:
        return
    # Fix bug 74: use the controller and gnx arguments.
    b = button.button
    b.clicked.connect(command)

    def goto_callback(checked, controller=controller, gnx=gnx):
        self.goto_command(controller, gnx)

    b.goto_script = gts = QtWidgets.QAction('Goto Script', b)
    b.addAction(gts)
    gts.triggered.connect(goto_callback)
    rclicks = build_rclick_tree(command_p, top_level=True)
    self.add_rclick_menu(b, rclicks, controller, script=script)
#@+node:ekr.20141031053508.15: *8* add_rclick_menu (QtIconBarClass)
def add_rclick_menu(self, action_container, rclicks, controller,
    top_level=True,
    button=None,
    script=None
):
    c = controller.c
    top_offset = -2  # insert before the remove button and goto script items
    if top_level:
        button = action_container
    for rc in rclicks:
        # pylint: disable=cell-var-from-loop
        headline = rc.position.h[8:].strip()
        act = QtWidgets.QAction(headline, action_container)
        if '---' in headline and headline.strip().strip('-') == '':
            act.setSeparator(True)
        elif rc.position.b.strip():

            def cb(checked, p=rc.position, button=button):
                controller.executeScriptFromButton(
                    b=button,
                    buttonText=p.h[8:].strip(),
                    p=p,
                    script=script,
                )
                if c.exists:
                    c.outerUpdate()

            act.triggered.connect(cb)
        else:  # recurse submenu
            sub_menu = QtWidgets.QMenu(action_container)
            act.setMenu(sub_menu)
            self.add_rclick_menu(sub_menu, rc.children, controller,
                top_level=False, button=button)
        if top_level:
            # insert act before Remove Button
            action_container.insertAction(
                action_container.actions()[top_offset], act)
        else:
            action_container.addAction(act)
    if top_level and rclicks:
        act = QtWidgets.QAction('---', action_container)
        act.setSeparator(True)
        action_container.insertAction(
            action_container.actions()[top_offset], act)
        action_container.setText(
            action_container.text() +
            (c.config.getString('mod-scripting-subtext') or '')
        )
#@+node:ekr.20110605121601.18274: *6* qtFrame.Configuration
#@+node:ekr.20110605121601.18275: *7* qtFrame.configureBar
def configureBar(self, bar, verticalFlag):
    c = self.c
    # Get configuration settings.
    w = c.config.getInt("split-bar-width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief", "relief")
    if not relief: relief = "flat"
    color = c.config.getColor("split-bar-color")
    if not color: color = "LightSteelBlue2"
    try:
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(
                relief=relief, height=w, bg=color, cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(
                relief=relief, width=w, bg=color, cursor="sb_h_double_arrow")
    except Exception:
        # Could be a user error. Use all defaults
        g.es("exception in user configuration for splitbar")
        g.es_exception()
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(height=7, cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(width=7, cursor="sb_h_double_arrow")
#@+node:ekr.20110605121601.18276: *7* qtFrame.configureBarsFromConfig
def configureBarsFromConfig(self):
    c = self.c
    w = c.config.getInt("split-bar-width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief", "relief")
    if not relief or relief == "": relief = "flat"
    color = c.config.getColor("split-bar-color")
    if not color or color == "": color = "LightSteelBlue2"
    if self.splitVerticalFlag:
        bar1, bar2 = self.bar1, self.bar2
    else:
        bar1, bar2 = self.bar2, self.bar1
    try:
        bar1.configure(relief=relief, height=w, bg=color)
        bar2.configure(relief=relief, width=w, bg=color)
    except Exception:
        # Could be a user error.
        g.es("exception in user configuration for splitbar")
        g.es_exception()
#@+node:ekr.20110605121601.18277: *7* qtFrame.reconfigureFromConfig
def reconfigureFromConfig(self):
    """Init the configuration of the Qt frame from settings."""
    c, frame = self.c, self
    frame.configureBarsFromConfig()
    frame.setTabWidth(c.tab_width)
    c.redraw()
#@+node:ekr.20110605121601.18278: *7* qtFrame.setInitialWindowGeometry
def setInitialWindowGeometry(self):
    """Set the position and size of the frame to config params."""
    c = self.c
    h = c.config.getInt("initial-window-height") or 500
    w = c.config.getInt("initial-window-width") or 600
    x = c.config.getInt("initial-window-left") or 50  # #1190: was 10
    y = c.config.getInt("initial-window-top") or 50  # #1190: was 10
    if h and w and x and y:
        if 'size' in g.app.debug:
            g.trace(w, h, x, y)
        self.setTopGeometry(w, h, x, y)
#@+node:ekr.20110605121601.18279: *7* qtFrame.setTabWidth
def setTabWidth(self, w):
    # A do-nothing because tab width is set automatically.
    # It *is* called from Leo's core.
    pass
#@+node:ekr.20110605121601.18280: *7* qtFrame.setWrap
def setWrap(self, p=None, force=False):
    return self.c.frame.body.setWrap(p, force)
#@+node:ekr.20110605121601.18281: *7* qtFrame.reconfigurePanes
def reconfigurePanes(self):
    c, f = self.c, self
    if f.splitVerticalFlag:
        r = c.config.getRatio("initial-vertical-ratio")
        if r is None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial-vertical-secondary-ratio")
        if r2 is None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial-horizontal-ratio")
        if r is None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial-horizontal-secondary-ratio")
        if r2 is None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    f.resizePanesToRatio(r, r2)
#@+node:ekr.20110605121601.18282: *7* qtFrame.resizePanesToRatio
def resizePanesToRatio(self, ratio, ratio2):
    """Resize splitter1 and splitter2 using the given ratios."""
    # pylint: disable=arguments-differ
    self.divideLeoSplitter1(ratio)
    self.divideLeoSplitter2(ratio2)
#@+node:ekr.20110605121601.18283: *7* qtFrame.divideLeoSplitter1/2
def divideLeoSplitter1(self, frac):
    """Divide the main splitter."""
    layout = self.c and self.c.free_layout
    if not layout:
        return
    w = layout.get_main_splitter()
    if w:
        self.divideAnySplitter(frac, w)

def divideLeoSplitter2(self, frac):
    """Divide the secondary splitter."""
    layout = self.c and self.c.free_layout
    if not layout:
        return
    w = layout.get_secondary_splitter()
    if w:
        self.divideAnySplitter(frac, w)
#@+node:ekr.20110605121601.18284: *7* qtFrame.divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter(self, frac, splitter):
    """Set the splitter sizes."""
    sizes = splitter.sizes()
    if len(sizes) != 2:
        g.trace(f"{len(sizes)} widget(s) in {id(splitter)}")
        return
    if frac > 1 or frac < 0:
        g.trace(f"split ratio [{frac}] out of range 0 <= frac <= 1")
        return
    s1, s2 = sizes
    s = s1 + s2
    s1 = int(s * frac + 0.5)
    s2 = s - s1
    splitter.setSizes([s1, s2])
#@+node:ekr.20110605121601.18285: *6* qtFrame.Event handlers
#@+node:ekr.20110605121601.18286: *7* qtFrame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    f = self; c = f.c
    if c.inCommand:
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@+node:ekr.20110605121601.18287: *7* qtFrame.OnControlKeyUp/Down
def OnControlKeyDown(self, event=None):
    self.controlKeyIsDown = True

def OnControlKeyUp(self, event=None):
    self.controlKeyIsDown = False
#@+node:ekr.20110605121601.18290: *7* qtFrame.OnActivateTree
def OnActivateTree(self, event=None):
    pass
#@+node:ekr.20110605121601.18291: *7* qtFrame.OnBodyClick, OnBodyRClick (not used)
# At present, these are not called,
# but they could be called by LeoQTextBrowser.

def OnBodyClick(self, event=None):
    g.trace()
    try:
        c = self.c; p = c.currentPosition()
        if g.doHook("bodyclick1", c=c, p=p, event=event):
            g.doHook("bodyclick2", c=c, p=p, event=event)
            return
        c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodyclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self, event=None):
    try:
        c = self.c; p = c.currentPosition()
        if g.doHook("bodyrclick1", c=c, p=p, event=event):
            g.doHook("bodyrclick2", c=c, p=p, event=event)
            return
        c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodyrclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("iconrclick")
#@+node:ekr.20110605121601.18292: *7* qtFrame.OnBodyDoubleClick (Events) (not used)
# Not called

def OnBodyDoubleClick(self, event=None):
    try:
        c = self.c; p = c.currentPosition()
        if event and not g.doHook("bodydclick1", c=c, p=p, event=event):
            c.editCommands.extendToWord(event)  # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodydclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("bodydclick")
    return "break"  # Restore this to handle proper double-click logic.
#@+node:ekr.20110605121601.18293: *6* qtFrame.Gui-dependent commands
#@+node:ekr.20110605121601.18301: *7* qtFrame.Window Menu...
#@+node:ekr.20110605121601.18302: *8* qtFrame.toggleActivePane
@cmd('toggle-active-pane')
def toggleActivePane(self, event=None):
    """Toggle the focus between the outline and body panes."""
    frame = self; c = frame.c
    w = c.get_focus()
    w_name = g.app.gui.widget_name(w)
    if w_name in ('canvas', 'tree', 'treeWidget'):
        c.endEditing()
        c.bodyWantsFocus()
    else:
        c.treeWantsFocus()
#@+node:ekr.20110605121601.18303: *8* qtFrame.cascade
@cmd('cascade-windows')
def cascade(self, event=None):
    """Cascade all Leo windows."""
    x, y, delta = 50, 50, 50
    for frame in g.app.windowList:
        w = frame and frame.top
        if w:
            r = w.geometry()  # a Qt.Rect
            # 2011/10/26: Fix bug 823601: cascade-windows fails.
            w.setGeometry(QtCore.QRect(x, y, r.width(), r.height()))
            # Compute the new offsets.
            x += 30; y += 30
            if x > 200:
                x = 10 + delta; y = 40 + delta
                delta += 10
#@+node:ekr.20110605121601.18304: *8* qtFrame.equalSizedPanes
@cmd('equal-sized-panes')
def equalSizedPanes(self, event=None):
    """Make the outline and body panes have the same size."""
    self.resizePanesToRatio(0.5, self.secondary_ratio)
#@+node:ekr.20110605121601.18305: *8* qtFrame.hideLogWindow
def hideLogWindow(self, event=None):
    """Hide the log pane."""
    self.divideLeoSplitter2(0.99)
#@+node:ekr.20110605121601.18306: *8* qtFrame.minimizeAll
@cmd('minimize-all')
def minimizeAll(self, event=None):
    """Minimize all Leo's windows."""
    for frame in g.app.windowList:
        self.minimize(frame)

def minimize(self, frame):
    # This unit test will fail when run externally.
    if frame and frame.top:
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['minimize-all'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMinimized)
#@+node:ekr.20110605121601.18307: *8* qtFrame.toggleSplitDirection
@cmd('toggle-split-direction')
def toggleSplitDirection(self, event=None):
    """Toggle the split direction in the present Leo window."""
    if hasattr(self.c, 'free_layout'):
        self.c.free_layout.get_top_splitter().rotate()
#@+node:ekr.20110605121601.18308: *8* qtFrame.resizeToScreen
@cmd('resize-to-screen')
def resizeToScreen(self, event=None):
    """Resize the Leo window so it fill the entire screen."""
    frame = self
    # This unit test will fail when run externally.
    if frame and frame.top:
        # frame.top.leo_master is a LeoTabbedTopLevel.
        # frame.top is a DynamicWindow.
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['resize-to-screen'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMaximized)
#@+node:ekr.20110605121601.18309: *7* qtFrame.Help Menu...
#@+node:ekr.20110605121601.18310: *8* qtFrame.leoHelp
@cmd('open-offline-tutorial')
def leoHelp(self, event=None):
    """Open Leo's offline tutorial."""
    frame = self; c = frame.c
    theFile = g.os_path_join(g.app.loadDir, "..", "doc", "sbooks.chm")
    if g.os_path_exists(theFile) and sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")
        if answer == "yes":
            try:
                url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                import webbrowser
                os.chdir(g.app.loadDir)
                webbrowser.open_new(url)
            except Exception:
                if 0:
                    g.es("exception downloading", "sbooks.chm")
                    g.es_exception()
#@+node:ekr.20160424080647.1: *6* qtFrame.Properties
# The ratio and secondary_ratio properties are read-only.
#@+node:ekr.20160424080815.2: *7* qtFrame.ratio property
def __get_ratio(self):
    """Return splitter ratio of the main splitter."""
    c = self.c
    free_layout = c.free_layout
    if free_layout:
        w = free_layout.get_main_splitter()
        if w:
            aList = w.sizes()
            if len(aList) == 2:
                n1, n2 = aList
                # 2017/06/07: guard against division by zero.
                ratio = 0.5 if n1 + n2 == 0 else float(n1) / float(n1 + n2)
                return ratio
    return 0.5

ratio = property(
    __get_ratio,  # No setter.
    doc="qtFrame.ratio property")
#@+node:ekr.20160424080815.3: *7* qtFrame.secondary_ratio property
def __get_secondary_ratio(self):
    """Return the splitter ratio of the secondary splitter."""
    c = self.c
    free_layout = c.free_layout
    if free_layout:
        w = free_layout.get_secondary_splitter()
        if w:
            aList = w.sizes()
            if len(aList) == 2:
                n1, n2 = aList
                ratio = float(n1) / float(n1 + n2)
                return ratio
    return 0.5

secondary_ratio = property(
    __get_secondary_ratio,  # no setter.
    doc="qtFrame.secondary_ratio property")
#@+node:ekr.20110605121601.18311: *6* qtFrame.Qt bindings...
#@+node:ekr.20190611053431.1: *7* qtFrame.bringToFront
def bringToFront(self):
    if 'size' in g.app.debug:
        g.trace()
    self.lift()
#@+node:ekr.20190611053431.2: *7* qtFrame.deiconify
def deiconify(self):
    """Undo --minimized"""
    if 'size' in g.app.debug:
        g.trace(
            'top:', bool(self.top),
            'isMinimized:', self.top and self.top.isMinimized())
    if self.top and self.top.isMinimized():  # Bug fix: 400739.
        self.lift()
#@+node:ekr.20190611053431.4: *7* qtFrame.get_window_info
def get_window_info(self):
    """Return the geometry of the top window."""
    if getattr(self.top, 'leo_master', None):
        f = self.top.leo_master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x, y = topLeft.x(), topLeft.y()
    w, h = rect.width(), rect.height()
    if 'size' in g.app.debug:
        g.trace('\n', w, h, x, y)
    return w, h, x, y
#@+node:ekr.20190611053431.3: *7* qtFrame.getFocus
def getFocus(self):
    return g.app.gui.get_focus(self.c)  # Bug fix: 2009/6/30.
#@+node:ekr.20190611053431.7: *7* qtFrame.getTitle
def getTitle(self):
    # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
    # For qt, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
    w = self.top.leo_master if g.app.qt_use_tabs else self.top
    return w.windowTitle()
#@+node:ekr.20190611053431.5: *7* qtFrame.iconify
def iconify(self):
    if 'size' in g.app.debug:
        g.trace(bool(self.top))
    if self.top: self.top.showMinimized()
#@+node:ekr.20190611053431.6: *7* qtFrame.lift
def lift(self):
    if 'size' in g.app.debug:
        g.trace(bool(self.top), self.top and self.top.isMinimized())
    if not self.top:
        return
    if self.top.isMinimized():  # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()
#@+node:ekr.20190611053431.8: *7* qtFrame.setTitle
def setTitle(self, s):
    # pylint: disable=arguments-differ
    if self.top:
        # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
        # When using tabs, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
        w = self.top.leo_master if g.app.qt_use_tabs else self.top
        w.setWindowTitle(s)
#@+node:ekr.20190611053431.9: *7* qtFrame.setTopGeometry
def setTopGeometry(self, w, h, x, y):
    # self.top is a DynamicWindow.
    if 'size' in g.app.debug:
        g.trace(bool(self.top), w, h, x, y)
    if self.top:
        self.top.setGeometry(QtCore.QRect(x, y, w, h))
#@+node:ekr.20190611053431.10: *7* qtFrame.update
def update(self, *args, **keys):
    if 'size' in g.app.debug:
        g.trace(bool(self.top))
    self.top.update()
#@+node:ekr.20110605121601.18312: *5* class LeoQtLog (LeoLog)
class LeoQtLog(leoFrame.LeoLog):
    """A class that represents the log pane of a Qt window."""
    @others
#@+node:ekr.20150717102609.1: *6* LeoQtLog.cmd (decorator)
def cmd(name):
    """Command decorator for the c.frame.log class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'log'])
#@+node:ekr.20110605121601.18313: *6* LeoQtLog.Birth
#@+node:ekr.20110605121601.18314: *7* LeoQtLog.__init__ & reloadSettings
def __init__(self, frame, parentFrame):
    """Ctor for LeoQtLog class."""
    super().__init__(frame, parentFrame)
        # Calls createControl.
    assert self.logCtrl is None, self.logCtrl  # Set in finishCreate.
        # Important: depeding on the log *tab*,
        # logCtrl may be either a wrapper or a widget.
    self.c = c = frame.c
        # Also set in the base constructor, but we need it here.
    self.contentsDict = {}
        # Keys are tab names.  Values are widgets.
    self.eventFilters = []
        # Apparently needed to make filters work!
    self.logDict = {}
        # Keys are tab names text widgets.  Values are the widgets.
    self.logWidget = None
        # Set in finishCreate.
    self.menu = None
        # A menu that pops up on right clicks in the hull or in tabs.
    self.tabWidget = tw = c.frame.top.tabWidget
        # The Qt.QTabWidget that holds all the tabs.
    #
    # Bug 917814: Switching Log Pane tabs is done incompletely.
    tw.currentChanged.connect(self.onCurrentChanged)
    if 0:  # Not needed to make onActivateEvent work.
        # Works only for .tabWidget, *not* the individual tabs!
        theFilter = qt_events.LeoQtEventFilter(c, w=tw, tag='tabWidget')
        tw.installEventFilter(theFilter)
    #
    # 2013/11/15: Partial fix for bug 1251755: Log-pane refinements
    tw.setMovable(True)
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.wrap = bool(c.config.getBool('log-pane-wraps'))
#@+node:ekr.20110605121601.18315: *7* LeoQtLog.finishCreate
def finishCreate(self):
    """Finish creating the LeoQtLog class."""
    c, log, w = self.c, self, self.tabWidget
    #
    # Create the log tab as the leftmost tab.
    log.createTab('Log')
    self.logWidget = logWidget = self.contentsDict.get('Log')
    option = QtGui.QTextOption
    logWidget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
    w.insertTab(0, logWidget, 'Log')
        # Required.
    #
    # set up links in log handling
    logWidget.setTextInteractionFlags(
        QtCore.Qt.LinksAccessibleByMouse |
        QtCore.Qt.TextEditable |
        QtCore.Qt.TextSelectableByMouse
    )
    logWidget.setOpenLinks(False)
    logWidget.setOpenExternalLinks(False)
    logWidget.anchorClicked.connect(self.linkClicked)
    #
    # Show the spell tab.
    c.spellCommands.openSpellTab()
    #
    #794: Clicking Find Tab should do exactly what pushing Ctrl-F does

    def tab_callback(index):
        name = w.tabText(index)
        if name == 'Find':
            c.findCommands.startSearch(event=None)

    w.currentChanged.connect(tab_callback)
    # #1286.
    w.customContextMenuRequested.connect(self.onContextMenu)
#@+node:ekr.20110605121601.18316: *7* LeoQtLog.getName
def getName(self):
    return 'log'  # Required for proper pane bindings.
#@+node:ekr.20150717102728.1: *6* LeoQtLog.Commands
@cmd('clear-log')
def clearLog(self, event=None):
    """Clear the log pane."""
    w = self.logCtrl.widget  # w is a QTextBrowser
    if w:
        w.clear()
#@+node:ekr.20110605121601.18333: *6* LeoQtLog.color tab stuff
def createColorPicker(self, tabName):
    g.warning('color picker not ready for qt')
#@+node:ekr.20110605121601.18334: *6* LeoQtLog.font tab stuff
#@+node:ekr.20110605121601.18335: *7* LeoQtLog.createFontPicker
def createFontPicker(self, tabName):
    # log = self
    QFont = QtGui.QFont
    font, ok = QtWidgets.QFontDialog.getFont()
    if not (font and ok): return
    style = font.style()
    table = (
        (QFont.StyleNormal, 'normal'),
        (QFont.StyleItalic, 'italic'),
        (QFont.StyleOblique, 'oblique'))
    for val, name in table:
        if style == val:
            style = name
            break
    else:
        style = ''
    weight = font.weight()
    table = (
        (QFont.Light, 'light'),
        (QFont.Normal, 'normal'),
        (QFont.DemiBold, 'demibold'),
        (QFont.Bold, 'bold'),
        (QFont.Black, 'black'))
    for val, name in table:
        if weight == val:
            weight = name
            break
    else:
        weight = ''
    table = (
        ('family', str(font.family())),
        ('size  ', font.pointSize()),
        ('style ', style),
        ('weight', weight),
    )
    for key, val in table:
        if val: g.es(key, val, tabName='Fonts')
#@+node:ekr.20110605121601.18339: *7* LeoQtLog.hideFontTab
def hideFontTab(self, event=None):
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@+node:ekr.20111120124732.10184: *6* LeoQtLog.isLogWidget
def isLogWidget(self, w):
    val = w == self or w in list(self.contentsDict.values())
    return val
#@+node:tbnorth.20171220123648.1: *6* LeoQtLog.linkClicked
def linkClicked(self, link):
    """linkClicked - link clicked in log

    :param QUrl link: link that was clicked
    """
    # see addition of '/' in LeoQtLog.put()
    url = s = g.toUnicode(link.toString())
    if platform.system() == 'Windows':
        for scheme in 'file', 'unl':
            if s.startswith(scheme + ':///') and s[len(scheme) + 5] == ':':
                url = s.replace(':///', '://', 1)
                break
    g.handleUrl(url, c=self.c)
#@+node:ekr.20120304214900.9940: *6* LeoQtLog.onCurrentChanged
def onCurrentChanged(self, idx):

    tabw = self.tabWidget
    w = tabw.widget(idx)
    #
    # #917814: Switching Log Pane tabs is done incompletely
    wrapper = getattr(w, 'leo_log_wrapper', None)
    #
    # #1161: Don't change logs unless the wrapper is correct.
    if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
        self.logCtrl = wrapper
#@+node:ekr.20200304132424.1: *6* LeoQtLog.onContextMenu
def onContextMenu(self, point):
    """LeoQtLog: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.c, self
    g.app.gui.onContextMenu(c, w, point)
#@+node:ekr.20110605121601.18321: *6* LeoQtLog.put & putnl
#@+node:ekr.20110605121601.18322: *7* LeoQtLog.put
def put(self, s, color=None, tabName='Log', from_redirect=False, nodeLink=None):
    """
    Put s to the Qt Log widget, converting to html.
    All output to the log stream eventually comes here.

    The from_redirect keyword argument is no longer used.
    """
    c = self.c
    if g.app.quitting or not c or not c.exists:
        return
    # Note: g.actualColor does all color translation.
    if color:
        color = leoColor.getColor(color)
    if not color:
        # #788: First, fall back to 'log_black_color', not 'black.
        color = c.config.getColor('log-black-color')
        if not color:
            # Should never be necessary.
            color = 'black'
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    wrapper = self.logCtrl
    if not isinstance(wrapper, qt_text.QTextEditWrapper):
        g.trace('BAD wrapper', wrapper.__class__.__name__)
        return
    w = wrapper.widget
    if not isinstance(w, QtWidgets.QTextEdit):
        g.trace('BAD widget', w.__class__.__name__)
        return
    sb = w.horizontalScrollBar()
    s = s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    # #884: Always convert leading blanks and tabs to &nbsp.
    n = len(s) - len(s.lstrip())
    if n > 0 and s.strip():
        s = '&nbsp;' * (n) + s[n:]
    if not self.wrap:
        # Convert all other blanks to &nbsp;
        s = s.replace(' ', '&nbsp;')
    s = s.replace('\n', '<br>')
        # The caller is responsible for newlines!
    s = f'<font color="{color}">{s}</font>'
    if nodeLink:
        url = nodeLink
        for scheme in 'file', 'unl':
            # QUrl requires paths start with '/'
            if url.startswith(
                scheme + '://') and not url.startswith(scheme + ':///'):
                url = url.replace('://', ':///', 1)
        s = f'<a href="{url}" title="{nodeLink}">{s}</a>'
    w.insertHtml(s)
    w.moveCursor(QtGui.QTextCursor.End)
    sb.setSliderPosition(0)  # Force the slider to the initial position.
    w.repaint()  # Slow, but essential.
#@+node:ekr.20110605121601.18323: *7* LeoQtLog.putnl
def putnl(self, tabName='Log'):
    """Put a newline to the Qt log."""
    #
    # This is not called normally.
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    wrapper = self.logCtrl
    if not isinstance(wrapper, qt_text.QTextEditWrapper):
        g.trace('BAD wrapper', wrapper.__class__.__name__)
        return
    w = wrapper.widget
    if not isinstance(w, QtWidgets.QTextEdit):
        g.trace('BAD widget', w.__class__.__name__)
        return
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    # Not needed!
        # contents = w.toHtml()
        # w.setHtml(contents + '\n')
    w.moveCursor(QtGui.QTextCursor.End)
    sb.setSliderPosition(pos)
    w.repaint()  # Slow, but essential.
#@+node:ekr.20150205181818.5: *7* LeoQtLog.scrollToEnd
def scrollToEnd(self, tabName='Log'):
    """Scroll the log to the end."""
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    w = self.logCtrl.widget
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint()  # Slow, but essential.
#@+node:ekr.20120913110135.10613: *6* LeoQtLog.putImage
#@+node:ekr.20110605121601.18324: *6* LeoQtLog.Tab
#@+node:ekr.20110605121601.18325: *7* LeoQtLog.clearTab
def clearTab(self, tabName, wrap='none'):
    w = self.logDict.get(tabName)
    if w:
        w.clear()  # w is a QTextBrowser.
#@+node:ekr.20110605121601.18326: *7* LeoQtLog.createTab
def createTab(self, tabName, createText=True, widget=None, wrap='none'):
    """
    Create a new tab in tab widget
    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c
    if widget is None:
        widget = qt_text.LeoQTextBrowser(parent=None, c=c, wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = qt_text.QTextEditWrapper(widget=widget, name='log', c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
        option = QtGui.QTextOption
        widget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
        widget.setReadOnly(False)  # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
        # Set binding on all log pane widgets.
        g.app.gui.setFilter(c, widget, self, tag='log')
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget, tabName)
    else:
        # #1161: Don't set the wrapper unless it has the correct type.
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        if isinstance(contents, qt_text.QTextEditWrapper):
            widget.leo_log_wrapper = widget
                # The leo_log_wrapper is the widget itself.
        else:
            widget.leo_log_wrapper = None
                # Tell the truth.
        g.app.gui.setFilter(c, widget, contents, 'tabWidget')
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents, tabName)
    return contents
#@+node:ekr.20110605121601.18328: *7* LeoQtLog.deleteTab
def deleteTab(self, tabName, force=False):
    """
    Delete the tab if it exists.  Otherwise do *nothing*.
    
    The spell code sets force=True if there is no spell dict.
    """
    c = self.c
    w = self.tabWidget
    if force and tabName != 'Spell':
        g.trace('can not force delete tab:', tabName)
        return
    i = self.findTabIndex(tabName)
    if i is None:
        return
    w.removeTab(i)
    self.selectTab('Log')
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20190603062456.1: *7* LeoQtLog.findTabIndex
def findTabIndex(self, tabName):
    """Return the tab index for tabName, or None."""
    w = self.tabWidget
    for i in range(w.count()):
        if tabName == w.tabText(i):
            return i
    return None
#@+node:ekr.20110605121601.18329: *7* LeoQtLog.hideTab
def hideTab(self, tabName):
    self.selectTab('Log')
#@+node:ekr.20111122080923.10185: *7* LeoQtLog.orderedTabNames
def orderedTabNames(self, LeoLog=None):  # Unused: LeoLog
    """Return a list of tab names in the order in which they appear in the QTabbedWidget."""
    w = self.tabWidget
    return [w.tabText(i) for i in range(w.count())]
#@+node:ekr.20110605121601.18330: *7* LeoQtLog.numberOfVisibleTabs
def numberOfVisibleTabs(self):
    return len([val for val in self.contentsDict.values() if val is not None])
        # **Note**: the base-class version of this uses frameDict.
#@+node:ekr.20110605121601.18331: *7* LeoQtLog.selectTab & helpers
def selectTab(self, tabName, createText=True, widget=None, wrap='none'):
    """Create the tab if necessary and make it active."""
    i = self.findTabIndex(tabName)
    if i is None:
        self.createTab(tabName, widget=widget, wrap=wrap)
        self.finishCreateTab(tabName)
    self.finishSelectTab(tabName)
#@+node:ekr.20190603064815.1: *8* LeoQtLog.finishCreateTab
def finishCreateTab(self, tabName):
    """Finish creating the given tab. Do not set focus!"""
    c = self.c
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('Can not happen', tabName)
        self.tabName = None
        return
    # # #1161.
    if tabName == 'Log':
        wrapper = None
        widget = self.contentsDict.get('Log')
            # a qt_text.QTextEditWrapper
        if widget:
            wrapper = getattr(widget, 'leo_log_wrapper', None)
            if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
                self.logCtrl = wrapper
        if not wrapper: g.trace('NO LOG WRAPPER')
    if tabName == 'Find':
        # Do *not* set focus here!
        # #1254861: Ctrl-f doesn't ensure find input field visible.
        if c.config.getBool('auto-scroll-find-tab', default=True):
            # This is the cause of unwanted scrolling.
            findbox = c.findCommands.ftm.find_findbox
            if hasattr(widget, 'ensureWidgetVisible'):
                widget.ensureWidgetVisible(findbox)
            else:
                findbox.setFocus()
    if tabName == 'Spell':
        # Set a flag for the spell system.
        widget = self.tabWidget.widget(i)
        self.frameDict['Spell'] = widget
#@+node:ekr.20190603064816.1: *8* LeoQtLog.finishSelectTab
def finishSelectTab(self, tabName):
    """Select the proper tab."""
    w = self.tabWidget
    # Special case for Spell tab.
    if tabName == 'Spell':
        return
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('can not happen', tabName)
        self.tabName = None
        return
    w.setCurrentIndex(i)
    self.tabName = tabName
#@+node:ekr.20110605121601.18340: *5* class LeoQtMenu (LeoMenu)
class LeoQtMenu(leoMenu.LeoMenu):

    @others
#@+node:ekr.20110605121601.18341: *6* LeoQtMenu.__init__
def __init__(self, c, frame, label):
    """ctor for LeoQtMenu class."""
    assert frame
    assert frame.c
    super().__init__(frame)
    self.leo_menu_label = label.replace('&', '').lower()
    self.frame = frame
    self.c = c
    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar is not None
    # Inject this dict into the commander.
    if not hasattr(c, 'menuAccels'):
        setattr(c, 'menuAccels', {})
    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant', 'menu_text_font_weight',
            c.config.defaultMenuFontSize)
#@+node:ekr.20120306130648.9848: *6* LeoQtMenu.__repr__
def __repr__(self):
    return f"<LeoQtMenu: {self.leo_menu_label}>"

__str__ = __repr__
#@+node:ekr.20110605121601.18342: *6* LeoQtMenu.Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20110605121601.18343: *7* LeoQtMenu.Methods with Tk spellings
#@+node:ekr.20110605121601.18344: *8* LeoQtMenu.add_cascade
def add_cascade(self, parent, label, menu, underline):
    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""
    # menu and parent are a QtMenuWrappers, subclasses of  QMenu.
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    menu.setTitle(label)
    if parent:
        parent.addMenu(menu)  # QMenu.addMenu.
    else:
        self.menuBar.addMenu(menu)
    label = label.replace('&', '').lower()
    menu.leo_menu_label = label
    return menu
#@+node:ekr.20110605121601.18345: *8* LeoQtMenu.add_command (Called by createMenuEntries)
def add_command(self, **keys):
    """Wrapper for the Tkinter add_command menu method."""
    # pylint: disable=arguments-differ
    accel = keys.get('accelerator') or ''
    command = keys.get('command') or ''
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    if n is None: n = -1
    menu = keys.get('menu') or self
    if not label:
        return
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = f"{label}\t{accel}"
    action = menu.addAction(label)
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName
    if command:

        def qt_add_command_callback(checked, label=label, command=command):
            return command()

        action.triggered.connect(qt_add_command_callback)
#@+node:ekr.20110605121601.18346: *8* LeoQtMenu.add_separator
def add_separator(self, menu):
    """Wrapper for the Tkinter add_separator menu method."""
    if menu:
        action = menu.addSeparator()
        action.leo_menu_label = '*seperator*'
#@+node:ekr.20110605121601.18347: *8* LeoQtMenu.delete
def delete(self, menu, realItemName='<no name>'):
    """Wrapper for the Tkinter delete menu method."""
    # if menu:
        # return menu.delete(realItemName)
#@+node:ekr.20110605121601.18348: *8* LeoQtMenu.delete_range
def delete_range(self, menu, n1, n2):
    """Wrapper for the Tkinter delete menu method."""
    # Menu is a subclass of QMenu and LeoQtMenu.
    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@+node:ekr.20110605121601.18349: *8* LeoQtMenu.destroy
def destroy(self, menu):
    """Wrapper for the Tkinter destroy menu method."""
    # Fixed bug https://bugs.launchpad.net/leo-editor/+bug/1193870
    if menu:
        menu.menuBar.removeAction(menu.menuAction())
#@+node:ekr.20110605121601.18350: *8* LeoQtMenu.index
def index(self, label):
    """Return the index of the menu with the given label."""
    return 0
#@+node:ekr.20110605121601.18351: *8* LeoQtMenu.insert
def insert(self, menuName, position, label, command, underline=None):

    menu = self.getMenu(menuName)
    if menu and label:
        n = underline or 0
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:

            def insert_callback(checked, label=label, command=command):
                command()

            action.triggered.connect(insert_callback)
#@+node:ekr.20110605121601.18352: *8* LeoQtMenu.insert_cascade
def insert_cascade(self, parent, index, label, menu, underline):
    """Wrapper for the Tkinter insert_cascade menu method."""
    menu.setTitle(label)
    label.replace('&', '').lower()
    menu.leo_menu_label = label  # was leo_label
    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)
    action = menu.menuAction()
    if action:
        action.leo_menu_label = label
    else:
        g.trace('no action for menu', label)
    return menu
#@+node:ekr.20110605121601.18353: *8* LeoQtMenu.new_menu
def new_menu(self, parent, tearoff=False, label=''):  # label is for debugging.
    """Wrapper for the Tkinter new_menu menu method."""
    c, leoFrame = self.c, self.frame
    # Parent can be None, in which case it will be added to the menuBar.
    menu = QtMenuWrapper(c, leoFrame, parent, label)
    return menu
#@+node:ekr.20110605121601.18354: *7* LeoQtMenu.Methods with other spellings
#@+node:ekr.20110605121601.18355: *8* LeoQtMenu.clearAccel
def clearAccel(self, menu, name):
    pass
    # if not menu:
        # return
    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")
    # menu.entryconfig(realName,accelerator='')
#@+node:ekr.20110605121601.18356: *8* LeoQtMenu.createMenuBar
def createMenuBar(self, frame):
    """
    (LeoQtMenu) Create all top-level menus.
    The menuBar itself has already been created.
    """
    self.createMenusFromTables()
        # This is LeoMenu.createMenusFromTables.
#@+node:ekr.20110605121601.18357: *8* LeoQtMenu.createOpenWithMenu
def createOpenWithMenu(self, parent, label, index, amp_index):
    """
    Create the File:Open With submenu.

    This is called from LeoMenu.createOpenWithMenuFromTable.
    """
    # Use the existing Open With menu if possible.
    menu = self.getMenu('openwith')
    if not menu:
        menu = self.new_menu(parent, tearoff=False, label=label)
        menu.insert_cascade(parent, index, label, menu, underline=amp_index)
    return menu
#@+node:ekr.20110605121601.18358: *8* LeoQtMenu.disable/enableMenu (not used)
def disableMenu(self, menu, name):
    self.enableMenu(menu, name, False)

def enableMenu(self, menu, name, val):
    """Enable or disable the item in the menu with the given name."""
    if menu and name:
        val = bool(val)
        for action in menu.actions():
            s = g.checkUnicode(action.text()).replace('&', '')
            if s.startswith(name):
                action.setEnabled(val)
                break
#@+node:ekr.20110605121601.18359: *8* LeoQtMenu.getMenuLabel
def getMenuLabel(self, menu, name):
    """Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item."""
    # At present, it is valid to always return None.
#@+node:ekr.20110605121601.18360: *8* LeoQtMenu.setMenuLabel
def setMenuLabel(self, menu, name, label, underline=-1):

    def munge(s):
        return (s or '').replace('&', '')

    # menu is a QtMenuWrapper.

    if not menu: return
    realName = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@+node:ekr.20110605121601.18361: *6* LeoQtMenu.activateMenu & helper
def activateMenu(self, menuName):
    """Activate the menu with the given name"""
    menu = self.getMenu(menuName)
        # Menu is a QtMenuWrapper, a subclass of both QMenu and LeoQtMenu.
    if menu:
        self.activateAllParentMenus(menu)
    else:
        g.trace(f"No such menu: {menuName}")
#@+node:ekr.20120922041923.10607: *7* LeoQtMenu.activateAllParentMenus
def activateAllParentMenus(self, menu):
    """menu is a QtMenuWrapper.  Activate it and all parent menus."""
    parent = menu.parent()
    action = menu.menuAction()
    if action:
        if parent and isinstance(parent, QtWidgets.QMenuBar):
            parent.setActiveAction(action)
        elif parent:
            self.activateAllParentMenus(parent)
            parent.setActiveAction(action)
        else:
            g.trace(f"can not happen: no parent for {menu}")
    else:
        g.trace(f"can not happen: no action for {menu}")
#@+node:ekr.20120922041923.10613: *6* LeoQtMenu.deactivateMenuBar
# def deactivateMenuBar (self):
    # """Activate the menu with the given name"""
    # menubar = self.c.frame.top.leo_menubar
    # menubar.setActiveAction(None)
    # menubar.repaint()
#@+node:ekr.20110605121601.18362: *6* LeoQtMenu.getMacHelpMenu
def getMacHelpMenu(self, table):
    return None
#@+node:ekr.20110605121601.18363: *5* class LeoQTreeWidget (QTreeWidget)
class LeoQTreeWidget(QtWidgets.QTreeWidget):
    # To do: Generate @auto or @file nodes when appropriate.

    def __init__(self, c, parent):
        super().__init__(parent)
        self.setAcceptDrops(True)
        enable_drag = c.config.getBool('enable-tree-dragging')
        self.setDragEnabled(bool(enable_drag))
        self.c = c
        self.was_alt_drag = False
        self.was_control_drag = False

    def __repr__(self):
        return f"LeoQTreeWidget: {id(self)}"

    __str__ = __repr__
    # This is called during drags.

    def dragMoveEvent(self, ev):
        pass
    @others
#@+node:ekr.20111022222228.16980: *6* LeoQTreeWidget: Event handlers
#@+node:ekr.20110605121601.18364: *7* LeoQTreeWidget.dragEnterEvent & helper
def dragEnterEvent(self, ev):
    """Export c.p's tree as a Leo mime-data."""
    c = self.c
    if not ev:
        g.trace('no event!')
        return
    md = ev.mimeData()
    if not md:
        g.trace('No mimeData!')
        return
    c.endEditing()
    # Fix bug 135: cross-file drag and drop is broken.
    # This handler may be called several times for the same drag.
    # Only the first should should set g.app.drag_source.
    if g.app.dragging:
        pass
    else:
        g.app.dragging = True
        g.app.drag_source = c, c.p
        self.setText(md)
    # Always accept the drag, even if we are already dragging.
    ev.accept()
#@+node:ekr.20110605121601.18384: *8* LeoQTreeWidget.setText
def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    md.setText(f"{fn},{s}")
#@+node:ekr.20110605121601.18365: *7* LeoQTreeWidget.dropEvent & helpers
def dropEvent(self, ev):
    """Handle a drop event in the QTreeWidget."""
    if not ev:
        return
    md = ev.mimeData()
    if not md:
        g.trace('no mimeData!')
        return
    mods = int(ev.keyboardModifiers())
    self.was_alt_drag = (mods & QtCore.Qt.AltModifier) != 0
    self.was_control_drag = (mods & QtCore.Qt.ControlModifier) != 0
    c, tree = self.c, self.c.frame.tree
    p = None
    item = self.itemAt(ev.pos())
    if item:
        itemHash = tree.itemHash(item)
        p = tree.item2positionDict.get(itemHash)
    if not p:
        # #59: Drop at last node.
        p = c.rootPosition()
        while p.hasNext():
            p.moveToNext()
    formats = set(str(f) for f in md.formats())
    ev.setDropAction(QtCore.Qt.IgnoreAction)
    ev.accept()
    hookres = g.doHook("outlinedrop", c=c, p=p, dropevent=ev, formats=formats)
    if hookres:
        # A plugin handled the drop.
        pass
    else:
        if md.hasUrls():
            self.urlDrop(md, p)
        else:
            self.nodeDrop(md, p)
    g.app.dragging = False
#@+node:ekr.20110605121601.18366: *8* LeoQTreeWidget.nodeDrop & helpers
def nodeDrop(self, md, p):
    """
    Handle a drop event when not md.urls().
    This will happen when we drop an outline node.
    We get the copied text from md.text().
    """
    c = self.c
    fn, s = self.parseText(md)
    if not s or not fn:
        return
    if fn == self.fileName():
        if p and p == c.p:
            pass
        elif g.os_path_exists(fn):
            self.intraFileDrop(fn, c.p, p)
    else:
        self.interFileDrop(fn, p, s)
#@+node:ekr.20110605121601.18367: *9* LeoQTreeWidget.interFileDrop
def interFileDrop(self, fn, p, s):
    """Paste the mime data after (or as the first child of) p."""
    c = self.c
    u = c.undoer
    undoType = 'Drag Outline'
    isLeo = g.match(s, 0, g.app.prolog_prefix_string)
    if not isLeo:
        return
    c.selectPosition(p)
    pasted = c.fileCommands.getLeoOutlineFromClipboard(s)
        # Paste the node after the presently selected node.
    if not pasted:
        return
    if c.config.getBool('inter-outline-drag-moves'):
        src_c, src_p = g.app.drag_source
        if src_p.hasVisNext(src_c):
            nxt = src_p.getVisNext(src_c).v
        elif src_p.hasVisBack(src_c):
            nxt = src_p.getVisBack(src_c).v
        else:
            nxt = None
        if nxt is not None:
            src_p.doDelete()
            src_c.selectPosition(src_c.vnode2position(nxt))
            src_c.setChanged()
            src_c.redraw()
        else:
            g.es("Can't move last node out of outline")
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
        # 2011/02/27: Fix bug 690467.
    c.setChanged()
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back, 0)
    # c.setRootPosition(c.findRootPosition(pasted))
    u.afterInsertNode(pasted, undoType, undoData)
    c.redraw(pasted)
    c.recolor()
#@+node:ekr.20110605121601.18368: *9* LeoQTreeWidget.intraFileDrop
def intraFileDrop(self, fn, p1, p2):
    """Move p1 after (or as the first child of) p2."""
    as_child = self.was_alt_drag
    cloneDrag = self.was_control_drag
    c = self.c; u = c.undoer
    c.selectPosition(p1)
    if as_child or p2.hasChildren() and p2.isExpanded():
        # Attempt to move p1 to the first child of p2.
        # parent = p2

        def move(p1, p2):
            if cloneDrag:
                p1 = p1.clone()
            p1.moveToNthChildOf(p2, 0)
            p1.setDirty()
            return p1

    else:
        # Attempt to move p1 after p2.
        # parent = p2.parent()

        def move(p1, p2):
            if cloneDrag:
                p1 = p1.clone()
            p1.moveAfter(p2)
            p1.setDirty()
            return p1

    ok = (
        # 2011/10/03: Major bug fix.
        c.checkDrag(p1, p2) and
        c.checkMoveWithParentWithWarning(p1, p2, True))
    if ok:
        undoData = u.beforeMoveNode(p1)
        p1.setDirty()
        p1 = move(p1, p2)
        if cloneDrag:
            # Set dirty bits for ancestors of *all* cloned nodes.
            for z in p1.self_and_subtree():
                z.setDirty()
        c.setChanged()
        u.afterMoveNode(p1, 'Drag', undoData)
        if (not as_child or
            p2.isExpanded() or
            c.config.getBool("drag-alt-drag-expands") is not False
        ):
            c.redraw(p1)
        else:
            c.redraw(p2)
#@+node:ekr.20110605121601.18383: *9* LeoQTreeWidget.parseText
def parseText(self, md):
    """Parse md.text() into (fn,s)"""
    fn = ''
    s = md.text()
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[:i]
            s = s[i + 1 :]
    return fn, s
#@+node:ekr.20110605121601.18369: *8* LeoQTreeWidget.urlDrop & helpers
def urlDrop(self, md, p):
    """Handle a drop when md.urls()."""
    c, u, undoType = self.c, self.c.undoer, 'Drag Urls'
    urls = md.urls()
    if not urls:
        return
    c.undoer.beforeChangeGroup(c.p, undoType)
    changed = False
    for z in urls:
        url = QtCore.QUrl(z)
        scheme = url.scheme()
        if scheme == 'file':
            changed |= self.doFileUrl(p, url)
        elif scheme in ('http',):  # 'ftp','mailto',
            changed |= self.doHttpUrl(p, url)
    if changed:
        c.setChanged()
        u.afterChangeGroup(c.p, undoType, reportFlag=False)
        c.redraw()
#@+node:ekr.20110605121601.18370: *9* LeoQTreeWidget.doFileUrl & helper
def doFileUrl(self, p, url):
    """Read the file given by the url and put it in the outline."""
    # 2014/06/06: Work around a possible bug in QUrl.
        # fn = str(url.path()) # Fails.
    e = sys.getfilesystemencoding()
    fn = g.toUnicode(url.path(), encoding=e)
    if sys.platform.lower().startswith('win'):
        if fn.startswith('/'):
            fn = fn[1:]
    if os.path.isdir(fn):
        # Just insert an @path directory.
        self.doPathUrlHelper(fn, p)
        return True
    if g.os_path_exists(fn):
        try:
            f = open(fn, 'rb')  # 2012/03/09: use 'rb'
        except IOError:
            f = None
        if f:
            s = f.read()
            s = g.toUnicode(s)
            f.close()
            return self.doFileUrlHelper(fn, p, s)
    g.es_print(
        f"not found: {fn}", nodeLink=p.get_UNL(with_proto=True, with_count=True))
    return False
#@+node:ekr.20110605121601.18371: *10* LeoQTreeWidget.doFileUrlHelper & helper
def doFileUrlHelper(self, fn, p, s):
    """
    Insert s in an @file, @auto or @edit node after p.
    If fn is a .leo file, insert a node containing its top-level nodes as children.
    """
    c = self.c
    if self.isLeoFile(fn, s) and not self.was_control_drag:
        g.openWithFileName(fn, old_c=c)
        return False  # Don't set the changed marker in the original file.
    u, undoType = c.undoer, 'Drag File'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
        parent = p
    elif p.h.startswith('@path '):
        # #60: create relative paths & urls when dragging files.
        p2 = p.insertAsNthChild(0)
        p.expand()
        parent = p
    else:
        p2 = p.insertAfter()
        parent = p.parent()
    # #60: create relative paths & urls when dragging files.
    aList = g.get_directives_dict_list(parent)
    path = g.scanAtPathDirectives(c, aList)
    if path:
        fn = os.path.relpath(fn, path)
        fn = g.toUnicodeFileEncoding(fn)
    self.createAtFileNode(fn, p2, s)
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
    return True  # The original .leo file has changed.
#@+node:ekr.20110605121601.18372: *11* LeoQTreeWidget.createAtFileNode & helpers (QTreeWidget)
def createAtFileNode(self, fn, p, s):
    """
    Set p's headline, body text and possibly descendants
    based on the file's name fn and contents s.

    If the file is an thin file, create an @file tree.
    Othewise, create an @auto tree.
    If all else fails, create an @edit node.

    Give a warning if a node with the same headline already exists.
    """
    c = self.c
    c.init_error_dialogs()
    if self.isLeoFile(fn, s):
        self.createLeoFileTree(fn, p)
    elif self.isThinFile(fn, s):
        self.createAtFileTree(fn, p, s)
    elif self.isAutoFile(fn):
        self.createAtAutoTree(fn, p)
    elif self.isBinaryFile(fn):
        self.createUrlForBinaryFile(fn, p)
    else:
        self.createAtEditNode(fn, p)
    self.warnIfNodeExists(p)
    c.raise_error_dialogs(kind='read')
#@+node:ekr.20110605121601.18373: *12* LeoQTreeWidget.createAtAutoTree (QTreeWidget)
def createAtAutoTree(self, fn, p):
    """
    Make p an @auto node and create the tree using s, the file's contents.
    """
    c = self.c; at = c.atFileCommands
    p.h = f"@auto {fn}"
    at.readOneAtAutoNode(fn, p)
    # No error recovery should be needed here.
    p.clearDirty()  # Don't automatically rewrite this node.
#@+node:ekr.20110605121601.18374: *12* LeoQTreeWidget.createAtEditNode
def createAtEditNode(self, fn, p):
    c = self.c; at = c.atFileCommands
    # Use the full @edit logic, so dragging will be
    # exactly the same as reading.
    at.readOneAtEditNode(fn, p)
    p.h = f"@edit {fn}"
    p.clearDirty()  # Don't automatically rewrite this node.
#@+node:ekr.20110605121601.18375: *12* LeoQTreeWidget.createAtFileTree
def createAtFileTree(self, fn, p, s):
    """Make p an @file node and create the tree using
    s, the file's contents.
    """
    c = self.c; at = c.atFileCommands
    p.h = f"@file {fn}"
    # Read the file into p.
    ok = at.read(root=p.copy(),
        importFileName=None,
        fromString=s,
        atShadow=False,
        force=True)  # Disable caching.
    if not ok:
        g.error('Error reading', fn)
        p.b = ''  # Safe: will not cause a write later.
        p.clearDirty()  # Don't automatically rewrite this node.
#@+node:ekr.20141007223054.18004: *12* LeoQTreeWidget.createLeoFileTree
def createLeoFileTree(self, fn, p):
    """Copy all nodes from fn, a .leo file, to the children of p."""
    c = self.c
    p.h = f"From {g.shortFileName(fn)}"
    c.selectPosition(p)
    # Create a dummy first child of p.
    dummy_p = p.insertAsNthChild(0)
    c.selectPosition(dummy_p)
    c2 = g.openWithFileName(fn, old_c=c, gui=g.app.nullGui)
    for p2 in c2.rootPosition().self_and_siblings():
        c2.selectPosition(p2)
        s = c2.fileCommands.putLeoOutline()
        # Paste the outline after the selected node.
        c.fileCommands.getLeoOutlineFromClipboard(s)
    dummy_p.doDelete()
    c.selectPosition(p)
    p.v.contract()
    c2.close()
    g.app.forgetOpenFile(c2.fileName())
        # Necessary.
#@+node:ekr.20120309075544.9882: *12* LeoQTreeWidget.createUrlForBinaryFile
def createUrlForBinaryFile(self, fn, p):
    # Fix bug 1028986: create relative urls when dragging binary files to Leo.
    c = self.c
    base_fn = g.os_path_normcase(g.os_path_abspath(c.mFileName))
    abs_fn = g.os_path_normcase(g.os_path_abspath(fn))
    prefix = os.path.commonprefix([abs_fn, base_fn])
    if prefix and len(prefix) > 3:  # Don't just strip off c:\.
        p.h = abs_fn[len(prefix) :].strip()
    else:
        p.h = f"@url file://{fn}"
#@+node:ekr.20110605121601.18377: *12* LeoQTreeWidget.isAutoFile (LeoQTreeWidget)
def isAutoFile(self, fn):
    """Return true if fn (a file name) can be parsed with an @auto parser."""
    d = g.app.classDispatchDict
    junk, ext = g.os_path_splitext(fn)
    return d.get(ext)
#@+node:ekr.20120309075544.9881: *12* LeoQTreeWidget.isBinaryFile
def isBinaryFile(self, fn):
    # The default for unknown files is True. Not great, but safe.
    junk, ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext:
        val = False
    elif ext.startswith('~'):
        val = False
    elif ext in ('.css', '.htm', '.html', '.leo', '.txt'):
        val = False
    # elif ext in ('.bmp','gif','ico',):
        # val = True
    else:
        keys = (z.lower() for z in g.app.extension_dict)
        val = ext not in keys
    return val
#@+node:ekr.20141007223054.18003: *12* LeoQTreeWidget.isLeoFile
def isLeoFile(self, fn, s):
    """Return true if fn (a file name) represents an entire .leo file."""
    return fn.endswith('.leo') and s.startswith(g.app.prolog_prefix_string)
#@+node:ekr.20110605121601.18376: *12* LeoQTreeWidget.isThinFile
def isThinFile(self, fn, s):
    """
    Return true if the file whose contents is s
    was created from an @thin or @file tree.
    """
    c = self.c; at = c.atFileCommands
    # Skip lines before the @+leo line.
    i = s.find('@+leo')
    if i == -1:
        return False
    # Like at.isFileLike.
    j, k = g.getLine(s, i)
    line = s[j:k]
    valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
    return valid and new_df and isThin
#@+node:ekr.20110605121601.18378: *12* LeoQTreeWidget.warnIfNodeExists
def warnIfNodeExists(self, p):
    c = self.c; h = p.h
    for p2 in c.all_unique_positions():
        if p2.h == h and p2 != p:
            g.warning('Warning: duplicate node:', h)
            break
#@+node:ekr.20110605121601.18379: *10* LeoQTreeWidget.doPathUrlHelper
def doPathUrlHelper(self, fn, p):
    """Insert fn as an @path node after p."""
    c = self.c
    u, undoType = c.undoer, 'Drag Directory'
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@path ' + fn
    u.afterInsertNode(p2, undoType, undoData)
    c.selectPosition(p2)
#@+node:ekr.20110605121601.18380: *9* LeoQTreeWidget.doHttpUrl
def doHttpUrl(self, p, url):
    """Insert the url in an @url node after p."""
    c = self.c; u = c.undoer; undoType = 'Drag Url'
    s = str(url.toString()).strip()
    if not s: return False
    undoData = u.beforeInsertNode(p, pasteAsClone=False, copiedBunchList=[])
    if p.hasChildren() and p.isExpanded():
        p2 = p.insertAsNthChild(0)
    else:
        p2 = p.insertAfter()
    p2.h = '@url'
    p2.b = s
    p2.clearDirty()  # Don't automatically rewrite this node.
    u.afterInsertNode(p2, undoType, undoData)
    return True
#@+node:ekr.20110605121601.18381: *6* LeoQTreeWidget: utils
#@+node:ekr.20110605121601.18382: *7* LeoQTreeWidget.dump
def dump(self, ev, p, tag):
    if ev:
        md = ev.mimeData()
        s = g.checkUnicode(md.text(), encoding='utf-8')
        g.trace('md.text:', repr(s) if len(s) < 100 else len(s))
        for url in md.urls() or []:
            g.trace('     url:', url)
            g.trace('  url.fn:', url.toLocalFile())
            g.trace('url.text:', url.toString())
    else:
        g.trace('', tag, '** no event!')
#@+node:ekr.20141007223054.18002: *7* LeoQTreeWidget.fileName
def fileName(self):
    """Return the commander's filename."""
    return self.c.fileName() or '<unsaved file>'
#@+node:ekr.20110605121601.18385: *5* class LeoQtSpellTab
class LeoQtSpellTab:
    @others
#@+node:ekr.20110605121601.18386: *6* LeoQtSpellTab.__init__
def __init__(self, c, handler, tabName):
    """Ctor for LeoQtSpellTab class."""
    self.c = c
    top = c.frame.top
    self.handler = handler
    # hack:
    handler.workCtrl = leoFrame.StringTextWrapper(c, 'spell-workctrl')
    self.tabName = tabName
    if hasattr(top, 'leo_spell_label'):
        self.wordLabel = top.leo_spell_label
        self.listBox = top.leo_spell_listBox
        self.fillbox([])
    else:
        self.handler.loaded = False
#@+node:ekr.20110605121601.18389: *6* Event handlers
#@+node:ekr.20110605121601.18390: *7* onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""
    self.handler.add()
#@+node:ekr.20110605121601.18391: *7* onChangeButton & onChangeThenFindButton
def onChangeButton(self, event=None):
    """Handle a click in the Change button in the Spell tab."""
    state = self.updateButtons()
    if state:
        self.handler.change()
    self.updateButtons()

def onChangeThenFindButton(self, event=None):
    """Handle a click in the "Change, Find" button in the Spell tab."""
    state = self.updateButtons()
    if state:
        self.handler.change()
        if self.handler.change():
            self.handler.find()
        self.updateButtons()
#@+node:ekr.20110605121601.18392: *7* onFindButton
def onFindButton(self):
    """Handle a click in the Find button in the Spell tab."""
    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18393: *7* onHideButton
def onHideButton(self):
    """Handle a click in the Hide button in the Spell tab."""
    self.handler.hide()
#@+node:ekr.20110605121601.18394: *7* onIgnoreButton
def onIgnoreButton(self, event=None):
    """Handle a click in the Ignore button in the Check Spelling dialog."""
    self.handler.ignore()
#@+node:ekr.20110605121601.18395: *7* onMap
def onMap(self, event=None):
    """Respond to a Tk <Map> event."""
    self.update(show=False, fill=False)
#@+node:ekr.20110605121601.18396: *7* onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    c = self.c
    self.updateButtons()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18397: *6* Helpers
#@+node:ekr.20110605121601.18398: *7* bringToFront (LeoQtSpellTab)
def bringToFront(self):
    self.c.frame.log.selectTab('Spell')
#@+node:ekr.20110605121601.18399: *7* fillbox (LeoQtSpellTab)
def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""
    self.suggestions = alts
    if not word: word = ""
    self.wordLabel.setText("Suggestions for: " + word)
    self.listBox.clear()
    if self.suggestions:
        self.listBox.addItems(self.suggestions)
        self.listBox.setCurrentRow(0)
#@+node:ekr.20110605121601.18400: *7* getSuggestion (LeoQtSpellTab)
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    idx = self.listBox.currentRow()
    value = self.suggestions[idx]
    return value
#@+node:ekr.20141113094129.13: *7* setFocus (LeoQtSpellTab)
def setFocus(self):
    """Actually put focus in the tab."""
    # Not a great idea: there is no indication of focus.
    c = self.c
    if c.frame and c.frame.top and hasattr(c.frame.top, 'spellFrame'):
        w = self.c.frame.top.spellFrame
        c.widgetWantsFocus(w)
#@+node:ekr.20110605121601.18401: *7* update (LeoQtSpellTab)
def update(self, show=True, fill=False):
    """Update the Spell Check dialog."""
    c = self.c
    if fill:
        self.fillbox([])
    self.updateButtons()
    if show:
        self.bringToFront()
        c.bodyWantsFocus()
#@+node:ekr.20110605121601.18402: *7* updateButtons (spellTab)
def updateButtons(self):
    """Enable or disable buttons in the Check Spelling dialog."""
    c = self.c
    top, w = c.frame.top, c.frame.body.wrapper
    state = self.suggestions and w.hasSelection()
    top.leo_spell_btn_Change.setDisabled(not state)
    top.leo_spell_btn_FindChange.setDisabled(not state)
    return state
#@+node:ekr.20110605121601.18438: *5* class LeoQtTreeTab
class LeoQtTreeTab:
    """
    A class representing a so-called tree-tab.

    Actually, it represents a combo box
    """
    @others
#@+node:ekr.20110605121601.18439: *6*  Birth & death
#@+node:ekr.20110605121601.18440: *7*  ctor (LeoQtTreeTab)
def __init__(self, c, iconBar):
    """Ctor for LeoQtTreeTab class."""

    self.c = c
    self.cc = c.chapterController
    assert self.cc
    self.iconBar = iconBar
    self.lockout = False  # True: do not redraw.
    self.tabNames = []
        # The list of tab names. Changes when tabs are renamed.
    self.w = None  # The QComboBox
    # self.reloadSettings()
    self.createControl()
#@+node:ekr.20110605121601.18441: *7* tt.createControl (defines class LeoQComboBox)
def createControl(self):


    class LeoQComboBox(QtWidgets.QComboBox):
        """Create a subclass in order to handle focusInEvents."""

        def __init__(self, tt):
            self.leo_tt = tt
            super().__init__()
            # Fix #458: Chapters drop-down list is not automatically resized.
            self.setSizeAdjustPolicy(self.AdjustToContents)

        def focusInEvent(self, event):
            self.leo_tt.setNames()
            QtWidgets.QComboBox.focusInEvent(self, event)  # Call the base class

    tt = self
    frame = QtWidgets.QLabel('Chapters: ')
    tt.iconBar.addWidget(frame)
    tt.w = w = LeoQComboBox(tt)
    tt.setNames()
    tt.iconBar.addWidget(w)

    def onIndexChanged(s, tt=tt):
        if isinstance(s, int):
            s = '' if s == -1 else tt.w.currentText()
        else:  # s is the tab name.
            pass
        if s and not tt.cc.selectChapterLockout:
            tt.selectTab(s)

    # A change: the argument could now be an int instead of a string.

    w.currentIndexChanged.connect(onIndexChanged)
#@+node:ekr.20110605121601.18443: *6* tt.createTab
def createTab(self, tabName, select=True):
    """LeoQtTreeTab."""
    tt = self
    # Avoid a glitch during initing.
    if tabName != 'main' and tabName not in tt.tabNames:
        tt.tabNames.append(tabName)
        tt.setNames()
#@+node:ekr.20110605121601.18444: *6* tt.destroyTab
def destroyTab(self, tabName):
    """LeoQtTreeTab."""
    tt = self
    if tabName in tt.tabNames:
        tt.tabNames.remove(tabName)
        tt.setNames()
#@+node:ekr.20110605121601.18445: *6* tt.selectTab
def selectTab(self, tabName):
    """LeoQtTreeTab."""
    tt, c, cc = self, self.c, self.cc
    exists = tabName in self.tabNames
    c.treeWantsFocusNow()
        # Fix #969. Somehow this is important.
    if not exists:
        tt.createTab(tabName)  # Calls tt.setNames()
    if tt.lockout:
        return
    cc.selectChapterByName(tabName)
    c.redraw()
    c.outerUpdate()
#@+node:ekr.20110605121601.18446: *6* tt.setTabLabel
def setTabLabel(self, tabName):
    """LeoQtTreeTab."""
    w = self.w
    i = w.findText(tabName)
    if i > -1:
        w.setCurrentIndex(i)
#@+node:ekr.20110605121601.18447: *6* tt.setNames
def setNames(self):
    """LeoQtTreeTab: Recreate the list of items."""
    w = self.w
    names = self.cc.setAllChapterNames()
    w.clear()
    w.insertItems(0, names)
#@+node:ekr.20110605121601.18448: *5* class LeoTabbedTopLevel (LeoBaseTabWidget)
class LeoTabbedTopLevel(LeoBaseTabWidget):
    """ Toplevel frame for tabbed ui """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        ## middle click close on tabs -- JMP 20140505
        self.setMovable(False)
        tb = QtTabBarWrapper(self)
        self.setTabBar(tb)
#@+node:peckj.20140505102552.10377: *5* class QtTabBarWrapper (QTabBar)
class QtTabBarWrapper(QtWidgets.QTabBar):
    @others
#@+node:peckj.20140516114832.10108: *6* __init__
def __init__(self, parent=None):
    super().__init__(parent)
    self.setMovable(True)
#@+node:peckj.20140516114832.10109: *6* mouseReleaseEvent (QtTabBarWrapper)
def mouseReleaseEvent(self, event):
    # middle click close on tabs -- JMP 20140505
    # closes Launchpad bug: https://bugs.launchpad.net/leo-editor/+bug/1183528
    if event.button() == QtCore.Qt.MidButton:
        self.tabCloseRequested.emit(self.tabAt(event.pos()))
    QtWidgets.QTabBar.mouseReleaseEvent(self, event)
#@+node:ekr.20110605121601.18458: *5* class QtMenuWrapper (LeoQtMenu,QMenu)
class QtMenuWrapper(LeoQtMenu, QtWidgets.QMenu):
    @others
#@+node:ekr.20110605121601.18459: *6* ctor and __repr__(QtMenuWrapper)
def __init__(self, c, frame, parent, label):
    """ctor for QtMenuWrapper class."""
    assert c
    assert frame
    if parent is None:
        parent = c.frame.top.menuBar()
    #
    # For reasons unknown, the calls must be in this order.
    # Presumably, the order of base classes also matters(!)
    LeoQtMenu.__init__(self, c, frame, label)
    QtWidgets.QMenu.__init__(self, parent)
    label = label.replace('&', '').lower()
    self.leo_menu_label = label
    action = self.menuAction()
    if action:
        action.leo_menu_label = label
    self.aboutToShow.connect(self.onAboutToShow)

def __repr__(self):
    return f"<QtMenuWrapper {self.leo_menu_label}>"
#@+node:ekr.20110605121601.18460: *6* onAboutToShow & helpers (QtMenuWrapper)
def onAboutToShow(self, *args, **keys):

    name = self.leo_menu_label
    if not name: return
    for action in self.actions():
        commandName = hasattr(action, 'leo_command_name') and action.leo_command_name
        if commandName:
            self.leo_update_shortcut(action, commandName)
            self.leo_enable_menu_item(action, commandName)
            self.leo_update_menu_label(action, commandName)
#@+node:ekr.20120120095156.10261: *7* leo_enable_menu_item
def leo_enable_menu_item(self, action, commandName):
    func = self.c.frame.menu.enable_dict.get(commandName)
    if action and func:
        val = func()
        action.setEnabled(bool(val))
#@+node:ekr.20120124115444.10190: *7* leo_update_menu_label
def leo_update_menu_label(self, action, commandName):
    c = self.c
    if action and commandName == 'mark':
        action.setText('UnMark' if c.p.isMarked() else 'Mark')
        self.leo_update_shortcut(action, commandName)
            # Set the proper shortcut.
#@+node:ekr.20120120095156.10260: *7* leo_update_shortcut
def leo_update_shortcut(self, action, commandName):

    c = self.c; k = c.k
    if action:
        s = action.text()
        parts = s.split('\t')
        if len(parts) >= 2: s = parts[0]
        key, aList = c.config.getShortcut(commandName)
        if aList:
            result = []
            for bi in aList:
                # Don't show mode-related bindings.
                if not bi.isModeBinding():
                    accel = k.prettyPrintKey(bi.stroke)
                    result.append(accel)
                    # Break here if we want to show only one accerator.
            action.setText(f"{s}\t{', '.join(result)}")
        else:
            action.setText(s)
    else:
        g.trace(f"can not happen: no action for {commandName}")
#@+node:ekr.20110605121601.18461: *5* class QtSearchWidget
class QtSearchWidget:
    """A dummy widget class to pass to Leo's core find code."""

    def __init__(self):
        self.insertPoint = 0
        self.selection = 0, 0
        self.wrapper = self
        self.body = self
        self.text = None
#@+node:ekr.20110605121601.18464: *5* class TabbedFrameFactory
class TabbedFrameFactory:
    """
    'Toplevel' frame builder for tabbed toplevel interface

    This causes Leo to maintain only one toplevel window,
    with multiple tabs for documents
    """
    @others
#@+node:ekr.20110605121601.18465: *6* frameFactory.__init__	 & __repr__
def __init__(self):
    # will be created when first frame appears
    # DynamicWindow => Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {}
        # Keys are DynamicWindows, values are frames.
    self.masterFrame = None
    self.createTabCommands()
#@+node:ekr.20110605121601.18466: *6* frameFactory.createFrame (changed, makes dw)
def createFrame(self, leoFrame):

    c = leoFrame.c
    tabw = self.masterFrame
    dw = DynamicWindow(c, tabw)
    self.leoFrames[dw] = leoFrame
    # Shorten the title.
    title = os.path.basename(c.mFileName) if c.mFileName else leoFrame.title
    tip = leoFrame.title
    dw.setWindowTitle(tip)
    idx = tabw.addTab(dw, title)
    if tip:
        tabw.setTabToolTip(idx, tip)
    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    g.app.gui.setFilter(c, dw, dw, tag='tabbed-frame')
    #
    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() > 1)
    tabw.setTabsClosable(c.config.getBool('outline-tabs-show-close', True))
    if True:  # #1327: Must always do this.
        dw.show()
        tabw.show()
    return dw
#@+node:ekr.20110605121601.18468: *6* frameFactory.createMaster
def createMaster(self):

    window = self.masterFrame = LeoTabbedTopLevel(factory=self)
    tabbar = window.tabBar()
    g.app.gui.attachLeoIcon(window)
    try:
        tabbar.setTabsClosable(True)
        tabbar.tabCloseRequested.connect(self.slotCloseRequest)
    except AttributeError:
        pass  # Qt 4.4 does not support setTabsClosable
    window.currentChanged.connect(self.slotCurrentChanged)
    if 'size' in g.app.debug:
        g.trace(
            f"minimized: {g.app.start_minimized}, "
            f"maximized: {g.app.start_maximized}, "
            f"fullscreen: {g.app.start_fullscreen}")
    #
    # #1189: We *can* (and should) minimize here, to eliminate flash.
    if g.app.start_minimized:
        window.showMinimized()
#@+node:ekr.20110605121601.18472: *6* frameFactory.createTabCommands
def detachTab(self, wdg):
    """ Detach specified tab as individual toplevel window """
    del self.leoFrames[wdg]
    wdg.setParent(None)
    wdg.show()

def createTabCommands(self):
    << Commands for tabs >>
#@+node:ekr.20110605121601.18473: *7* << Commands for tabs >>
@g.command('tab-detach')
def tab_detach(event):
    """ Detach current tab from tab bar """
    if len(self.leoFrames) < 2:
        g.es_print_error("Can't detach last tab")
        return
    c = event['c']
    f = c.frame
    tabwidget = g.app.gui.frameFactory.masterFrame
    tabwidget.detach(tabwidget.indexOf(f.top))
    f.top.setWindowTitle(f.title + ' [D]')

# this is actually not tab-specific, move elsewhere?

@g.command('close-others')
def close_others(event):
    """Close all windows except the present window."""
    myc = event['c']
    for c in g.app.commanders():
        if c is not myc:
            c.close()

def tab_cycle(offset):

    tabw = self.masterFrame
    cur = tabw.currentIndex()
    count = tabw.count()
    # g.es("cur: %s, count: %s, offset: %s" % (cur,count,offset))
    cur += offset
    if cur < 0:
        cur = count - 1
    elif cur >= count:
        cur = 0
    tabw.setCurrentIndex(cur)
    self.focusCurrentBody()

@g.command('tab-cycle-next')
def tab_cycle_next(event):
    """ Cycle to next tab """
    tab_cycle(1)

@g.command('tab-cycle-previous')
def tab_cycle_previous(event):
    """ Cycle to next tab """
    tab_cycle(-1)
#@+node:ekr.20110605121601.18467: *6* frameFactory.deleteFrame
def deleteFrame(self, wdg):

    if not wdg:
        return
    if wdg not in self.leoFrames:
        # probably detached tab
        self.masterFrame.delete(wdg)
        return
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]
    wdg2 = tabw.currentWidget()
    if wdg2:
        g.app.selectLeoWindow(wdg2.leo_c)
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() > 1)
#@+node:ekr.20110605121601.18471: *6* frameFactory.focusCurrentBody
def focusCurrentBody(self):
    """ Focus body control of current tab """
    tabw = self.masterFrame
    w = tabw.currentWidget()
    w.setFocus()
    f = self.leoFrames[w]
    c = f.c
    c.bodyWantsFocusNow()
    # Fix bug 690260: correct the log.
    g.app.log = f.log
#@+node:ekr.20110605121601.18469: *6* frameFactory.setTabForCommander
def setTabForCommander(self, c):
    tabw = self.masterFrame  # a QTabWidget
    for dw in self.leoFrames:  # A dict whose keys are DynamicWindows.
        if dw.leo_c == c:
            for i in range(tabw.count()):
                if tabw.widget(i) == dw:
                    tabw.setCurrentIndex(i)
                    break
            break
#@+node:ekr.20110605121601.18470: *6* frameFactory.signal handlers
def slotCloseRequest(self, idx):

    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    c.close(new_c=None)
        # 2012/03/04: Don't set the frame here.
        # Wait until the next slotCurrentChanged event.
        # This keeps the log and the QTabbedWidget in sync.

def slotCurrentChanged(self, idx):
    # Two events are generated, one for the tab losing focus,
    # and another event for the tab gaining focus.
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if not f:
        return
    tabw.setWindowTitle(f.title)
    # Don't do this: it would break --minimize.
        # g.app.selectLeoWindow(f.c)
    # Fix bug 690260: correct the log.
    g.app.log = f.log
    # Redraw the tab.
    c = f.c
    if c:
        c.redraw()
#@+node:ekr.20180604114211.1: *3* Recent code
@nosearch
#@+node:ekr.20200415042619.1: *4*  Other
#@+node:ekr.20200222084016.1: *5* ----- logging protos
@language rest
@wrap

Use different ports.

@language python
#@+node:ekr.20170429152049.1: *6* app.listenToLog
@cmd('listen-to-log')
@cmd('log-listen')
def listenToLog(self, event=None):
    """
    A socket listener, listening on localhost. See:
    https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network

    Start this listener first, then start the broadcaster.

    leo/plugins/cursesGui2.py is a typical broadcaster.
    """
    app = self
    # Kill any previous listener.
    if app.log_listener:
        g.es_print('Killing previous listener')
        try:
            app.log_listener.kill()
        except Exception:
            g.es_exception()
        app.log_listener = None
    # Start a new listener.
    g.es_print('Starting log_listener.py')
    path = g.os_path_finalize_join(app.loadDir,
        '..', 'external', 'log_listener.py')
    app.log_listener = subprocess.Popen(
        [sys.executable, path],
        shell=False,
        universal_newlines=True,
    )
#@+node:ekr.20170429153135.1: *6* @file ../external/log_listener.py
'''
A socket listener, listening on localhost. See:
https://docs.python.org/2/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network

Leo's 'listen-for-log' command starts this listener.
Leo's 'kill-log-listener' command ends this listener.

Start this listener first, then start the broadcaster.

leo/plugins/cursesGui2.py is a typical broadcaster.
'''
<< log_listener imports >>
@others

start()
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20170429153432.1: *7* << log_listener imports >>
# import leo.core.leoGlobals as g
import logging
import logging.handlers
import pickle
import select
import socketserver as SocketServer
import struct
#@+node:ekr.20170429152049.2: *7* class LogRecordStreamHandler
class LogRecordStreamHandler(SocketServer.StreamRequestHandler):
    """Handler for a streaming logging request.

    This basically logs the record using whatever logging policy is
    configured locally.
    """

    @others
#@+node:ekr.20170429152049.3: *8* handle
def handle(self):
    """
    Handle multiple requests - each expected to be a 4-byte length,
    followed by the LogRecord in pickle format. Logs the record
    according to whatever policy is configured locally.
    """
    # print('listener started')
        # This isn't shown.
    while True:
        try:
            chunk = self.connection.recv(4)
        except ConnectionResetError:
            break
        if len(chunk) < 4:
            break
        slen = struct.unpack('>L', chunk)[0]
        chunk = self.connection.recv(slen)
        while len(chunk) < slen:
            chunk = chunk + self.connection.recv(slen - len(chunk))
        obj = self.unPickle(chunk)
        record = logging.makeLogRecord(obj)
        self.handleLogRecord(record)
    print('listener suspended')
        # This method can be re-invoked later.
#@+node:ekr.20170429152049.4: *8* unPickle
def unPickle(self, data):
    return pickle.loads(data)
#@+node:ekr.20170429152049.5: *8* handleLogRecord
def handleLogRecord(self, record):
    # if a name is specified, we use the named logger rather than the one
    # implied by the record.
    if self.server.logname is not None:
        name = self.server.logname
    else:
        name = record.name
    logger = logging.getLogger(name)
    # Do filtering at the client (other) end to save network bandwidth!
    logger.handle(record)
#@+node:ekr.20170429152049.6: *7* class LogRecordSocketReceiver
class LogRecordSocketReceiver(SocketServer.ThreadingTCPServer):
    """
    Simple TCP socket-based logging receiver suitable for testing.
    """
    allow_reuse_address = 1
    @others
#@+node:ekr.20170429152049.7: *8* __init__
def __init__(self,
    host='localhost',
    port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,
    handler=LogRecordStreamHandler,
):
    super().__init__((host, port), handler)
    self.abort = 0
    self.timeout = 1
    self.logname = None

#@+node:ekr.20170429152049.8: *8* serve_until_stopped
def serve_until_stopped(self):
    abort = 0
    while not abort:
        rd, wr, ex = select.select([self.socket.fileno()], [], [], self.timeout)
        if rd:
            self.handle_request()
        abort = self.abort
#@+node:ekr.20170429153814.1: *7* start
def start():
    '''Start the log listener.'''
    # format='%(relativeCreated)5d %(name)-15s %(levelname)-8s %(message)s'
    format = '%(message)s'  # To mimic g.trace.
    logging.basicConfig(format=format)
    tcpserver = LogRecordSocketReceiver()
    print('About to start TCP server...')
    tcpserver.serve_until_stopped()
#@+node:ekr.20200222083959.1: *6* script: log
import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
#@+node:ekr.20200222151754.1: *6* script: yoton "other end"
import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
#@+node:ekr.20190611095758.1: *5*  For 6.4
#@+node:ekr.20181027151243.1: *6* ===== #1006: 6.4: Allow @button and @command only from trusted directories
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
#@+node:ekr.20181027133311.1: *7* g.issueSecurityWarning
def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
#@+node:ekr.20140114145953.16691: *7* c.config.isLocalSetting
def isLocalSetting(self, setting, kind):
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
#@+node:ekr.20150514043850.8: *7* abbrev.init_settings (called from reload_settings)
def init_settings(self):
    """Called from AbbrevCommands.reload_settings aka reloadSettings."""
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning(f"@data {key}")
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
#@+node:ekr.20190306105229.1: *6* ===== #1032: 6.4: @clean cleans blank lines
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
#@+node:ekr.20080708094444.36: *7* x.propagate_changes
def propagate_changes(self, old_public_file, old_private_file):
    """
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    """
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s or '')  # #1466.
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace(f"can not happen: encoding mismatch: {at.encoding} {self.encoding}")
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace(f"\nprivate lines...{old_private_file}")
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace(f"\npublic lines...{old_public_file}")
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
#@+node:ekr.20080708094444.38: *7* x.propagate_changed_lines (main algorithm) & helpers
def propagate_changed_lines(
    self, new_public_lines, old_private_lines, marker, p=None):
    << docstring >>
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels & check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
#@+node:ekr.20150207044400.9: *8*  << docstring >>
"""
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
"""
#@+node:ekr.20150207111757.180: *8* x.dump_args
def dump_args(self):
    """Dump the argument lines."""
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
#@+node:ekr.20150207111757.178: *8* x.dump_lines
def dump_lines(self, lines, title):
    """Dump the given lines."""
    print(f"\n{title}...\n")
    for i, line in enumerate(lines):
        g.pr(f"{i:4} {line!r}")
#@+node:ekr.20150209044257.6: *8* x.init_data
def init_data(self):
    """
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    """
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i < len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i < len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
#@+node:ekr.20080708094444.40: *8* x.init_ivars
def init_ivars(self, new_public_lines, old_private_lines, marker):
    """Init all ivars used by propagate_changed_lines & its helpers."""
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = f"{x.delim1}@verbatim{x.delim2}\n"
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
#@+node:ekr.20150207044400.16: *8* x.op_bad
def op_bad(self, tag, ai, aj, bi, bj):
    """Report an unexpected opcode."""
    x = self
    x.error(f"unknown SequenceMatcher opcode: {tag!r}")
#@+node:ekr.20150207044400.12: *8* x.op_delete
def op_delete(self, tag, ai, aj, bi, bj):
    """Handle the 'delete' opcode."""
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
#@+node:ekr.20150207044400.13: *8* x.op_equal
def op_equal(self, tag, ai, aj, bi, bj):
    """Handle the 'equal' opcode."""
    x = self
    assert aj - ai == bj - bi and x.a[ai:aj] == x.b[bi:bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
#@+node:ekr.20150207044400.14: *8* x.op_insert
def op_insert(self, tag, ai, aj, bi, bj):
    """Handle the 'insert' opcode."""
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
#@+node:ekr.20150207044400.15: *8* x.op_replace
def op_replace(self, tag, ai, aj, bi, bj):
    """Handle the 'replace' opcode."""
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi:bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
#@+node:ekr.20150208060128.7: *8* x.preprocess
def preprocess(self, lines):
    """
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    """
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
#@+node:ekr.20150208223018.4: *8* x.put_plain_line
def put_plain_line(self, line):
    """Put a plain line to x.results, inserting verbatim lines if necessary."""
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print(f"put {repr(x.verbatim_line)}")
    x.results.append(line)
    if x.trace: print(f"put {line!r}")
#@+node:ekr.20150209044257.8: *8* x.put_sentinels
def put_sentinels(self, i):
    """Put all the sentinels to the results"""
    x = self
    if 0 <= i < len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace(f"{i:3} {sentinels}")
        x.results.extend(sentinels)
#@+node:ekr.20190109142026.1: *7* at.atFileToString
def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "<string-file>", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
#@+node:ekr.20041005105605.157: *7* at.putFile & helper
def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
#@+node:ekr.20041005105605.161: *7* at.putBody & helper
def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 & #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False  # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen=False,
        at_delims_seen=False,
        at_warning_given=False,
        has_at_others=False,
        in_code=True,
    )
    while i < len(s):
        next_i = g.skip_line(s, i)
        assert next_i > i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
#@+node:ekr.20041005105605.163: *8* at.putLine
def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i, p)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error(f"@all not valid in: {p.h}")
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error(f"multiple @others in: {p.h}")
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error(f"unmatched @end_raw directive: {p.h}")
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error(f"@verbatim is not a Leo directive: {p.h}")
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error(f"@comment and @delims in node {p.h}")
        at.putDirective(s, i, p)
    else:
        at.error(f"putBody: can not happen: unknown directive kind: {kind}")
#@+node:ekr.20041005105605.174: *7* at.putCodeLine
def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) > 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
#@+node:ekr.20041005105605.204: *7* at.os
def os(self, s):
    """
    Append a string to at.outputList.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
#@+node:ekr.20190505173053.1: *6* ===== #1132: 6.4: Alt-Up/Left sometimes don't work as expected
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1132

@language python
#@+node:ekr.20190506061636.1: *7*  Reference
#@+node:ekr.20031218072017.3395: *8* v.contract/expand/initExpandedBit/isExpanded
def contract(self):
    """Contract the node."""
    self.statusBits &= ~self.expandedBit

def expand(self):
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self):
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits & self.expandedBit) != 0
#@+node:ekr.20190506055928.1: *8* Found:expandedPositions
@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
#@+node:ekr.20131017174814.17480: *9* c.shouldBeExpanded
def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
#@+node:ekr.20060928062431: *9* c_oc.expandOnlyAncestorsOfNode
@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
#@+node:ekr.20131222112420.16371: *9* p.contract/expand/isExpanded
def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
#@+node:ekr.20180810052056.2: *9* qtree.yieldVisible (not used)
def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) > 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) <= 1 and (v.statusBits & v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 < len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 < len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
#@+node:ekr.20031218072017.3344: *9* v.__init
def __init__(self, context, gnx=None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString = 'newHeadline'
    self._bodyString = ''
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
#@+node:ekr.20190506060857.1: *7* ----- New and changed
#@+node:ekr.20090110073010.1: *7* c.redraw
@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
#@+node:ekr.20191206073301.1: *6* ===== #1451: 6.4: @clean not written
@language rest
@wrap

@clean and @auto may not always be updated reliably

https://github.com/leo-editor/leo-editor/issues/1451

#1361 may be the culprit
https://github.com/leo-editor/leo-editor/issues/1361

*** --trace=write

@language python
#@+node:ekr.20190111045822.1: *7* at.precheck (calls shouldPrompt...)
def precheck(self, fileName, root):
    """
    Check whether a dirty, potentially dangerous, file should be written.
    
    Return True if so.  Return False *and* issue a warning otherwise.
    """
    at = self
    #
    # #1450: First, check that the directory exists.
    theDir = g.os_path_dirname(fileName)
    if theDir and not g.os_path_exists(theDir):
        at.error(f"Directory not found:\n{theDir}")
        return False
    #
    # Now check the file.
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName)
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
#@+node:ekr.20190108112519.1: *7* at.reportEndOfWrite
def reportEndOfWrite(self, files, all, dirty):

    if g.unitTesting:
        return
    if files:
        g.es('finished')
    elif all:
        g.warning("no @<file> nodes in the selected tree")
    elif dirty:
        g.es("no dirty @<file> nodes in the selected tree")
#@+node:ekr.20120110174009.9965: *7* at.shouldPromptForDangerousWrite
def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if Leo should warn the user that p is an @<file> node that
    was not read during startup. Writing that file might cause data loss.
    
    See #50: https://github.com/leo-editor/leo-editor/issues/50
    '''
    trace = 'save' in g.app.debug
    sfn = g.shortFileName(fn)
    c = self.c
    efc = g.app.externalFilesController
    if p.isAtNoSentFileNode():
        # #1450.
        # No danger of overwriting a file.
        # It was never read.
        return False
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        if trace: g.trace('Return False: does not exist:', sfn)
        return False
    # #1347: Prompt if the external file is newer.
    if efc:
        # Like c.checkFileTimeStamp.
        if c.sqlite_connection and c.mFileName == fn:
            # sqlite database file is never actually overwriten by Leo,
            # so do *not* check its timestamp.
            pass
        elif efc.has_changed(c, fn):
            if trace: g.trace('Return True: changed:', sfn)
            return True
    if hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        for k in d:
            # Fix bug # #1469: make sure k still exists.
            if (
                os.path.exists(k) and os.path.samefile(k, fn)
                and p.h in d.get(k, set())
            ):
                d[fn] = d[k]
                if trace: g.trace('Return False: in p.v.at_read:', sfn)
                return False
        aSet = d.get(fn, set())
        if trace:
            g.trace(f"Return {p.h not in aSet()}: p.h not in aSet(): {sfn}")
        return p.h not in aSet
    if trace:
        g.trace('Return True: never read:', sfn)
    return True  # The file was never read.
#@+node:ekr.20041005105605.144: *7* at.write
def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @<file> node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
#@+node:ekr.20190108105509.1: *7* at.writePathChanged
def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
#@+node:ekr.20191207065251.1: *7* not changed
#@+node:ekr.20120427064024.10068: *8* app.Detecting already-open files
#@+node:ekr.20120427064024.10064: *9* app.checkForOpenFile
def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
#@+node:ekr.20120427064024.10066: *9* app.forgetOpenFile
def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
#@+node:ekr.20120427064024.10065: *9* app.rememberOpenFile
def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
#@+node:ekr.20150621062355.1: *9* app.runAlreadyOpenDialog
def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
#@+node:ekr.20090514111518.5661: *8* at.checkPythonCode & helpers
def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
#@+node:ekr.20090514111518.5663: *9* at.checkPythonSyntax
def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        body = body.replace('\r', '')
        fn = f"<node: {p.h}>"
        compile(body + '\n', fn, 'exec')
        return True
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
    return False
#@+node:ekr.20090514111518.5666: *10* at.syntaxError (leoAtFile)
def syntaxError(self, p, body):
    """Report a syntax error."""
    g.error(f"Syntax error in: {p.h}")
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = f"{p.get_UNL(with_proto=True, with_count=True)},-{j+1:d}"
        else:
            mark = ' '
            node_link = None
        text = f"{j+1:5}:{mark} {lines[j].rstrip()}"
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
#@+node:ekr.20161021084954.1: *9* at.runPyflakes
def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        import leo.commands.checkerCommands as checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
#@+node:ekr.20090514111518.5665: *9* at.tabNannyNode
def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("ParserError in", p.h)
        g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("IndentationError in", p.h)
        g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("TokenError in", p.h)
        g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        badline = nag.get_lineno()
        line = nag.get_line()
        message = nag.get_msg()
        g.error("indentation error in", p.h, "line", badline)
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
#@+node:ekr.20120112084820.10001: *8* at.rememberReadPath
def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@<file> type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
#@+node:ekr.20161021084954.1: *8* at.runPyflakes
def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        import leo.commands.checkerCommands as checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
#@+node:ekr.20031218072017.3351: *7* v.isAtIgnoreNode
def isAtIgnoreNode(self):
    """
    Returns True if:
        
    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
#@+node:ekr.20200401074555.1: *6* ===== #1557: fix mypy complaints
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1557

Create mypy command?

@language python
#@+node:ekr.20191021002252.1: *7* ----- mypy errors

(base) c:\leo.repo\leo-editor>mypy leo\core\runLeo.py

leo\external\__init__.py:3: error: Need type annotation for '__all__' (hint: "__all__: List[<type>] = ...")

leo\external\codewise.py:100: error: Cannot find module named '__builtin__'
leo\external\codewise.py:100: error: Name 'builtins' already defined (by an import)

leo\core\leoGlobals.py:34: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:39: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:43: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:309: error: Need type annotation for 'tree_popup_handlers' (hint: "tree_popup_handlers: List[<type>] = ...")
leo\core\leoGlobals.py:310: error: Need type annotation for 'user_dict' (hint: "user_dict: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:2088: error: Need type annotation for 'tracing_signatures' (hint: "tracing_signatures: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5'
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoGlobals.py:2603: note: (Stub files are from https://github.com/python/typeshed)
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4'
leo\core\leoGlobals.py:2702: error: No library stub file for module 'pylint'
leo\core\leoGlobals.py:2770: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:2771: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:2772: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:5261: error: Need type annotation for 'childrenModifiedSet' (hint: "childrenModifiedSet: Set[<type>] = ...")
leo\core\leoGlobals.py:5262: error: Need type annotation for 'contentModifiedSet' (hint: "contentModifiedSet: Set[<type>] = ...")
leo\core\leoGlobals.py:5767: error: Need type annotation for 'checkUnicode_dict' (hint: "checkUnicode_dict: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:5925: error: Need type annotation for 'unicode_warnings' (hint: "unicode_warnings: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:6814: error: Need type annotation for 'init_zodb_failed' (hint: "init_zodb_failed: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:6815: error: Need type annotation for 'init_zodb_db' (hint: "init_zodb_db: Dict[<type>, <type>] = ...")
leo\core\leoGlobals.py:6829: error: Cannot find module named 'ZODB'
leo\core\leoGlobals.py:6829: note: See https://mypy.readthedocs.io/en/latest/running_mypy.html#missing-imports
leo\core\leoGlobals.py:6964: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[<type>] = ...")

leo\plugins\importers\ipynb.py:7: error: No library stub file for module 'nbformat'

leo\core\leoVim.py:2054: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2058: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2062: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2075: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2080: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2088: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2093: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2097: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2102: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2106: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2110: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2121: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2141: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2147: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2155: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2160: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2167: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"

leo\core\leoUndo.py:1162: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"
leo\core\leoUndo.py:1441: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"

leo\core\leoFind.py:304: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:327: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:489: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:495: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:505: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:517: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:526: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:587: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:600: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:609: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:624: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:639: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:654: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:669: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:865: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:866: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:867: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:894: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:895: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:896: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:924: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:925: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:952: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:961: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:972: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:978: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1083: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1090: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1107: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1115: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1133: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1158: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1259: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1266: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1279: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1287: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1292: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1297: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1302: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1307: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1312: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1317: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1333: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1343: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1355: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1411: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"

leo\core\leoFind.py:2211: error: Need type annotation for 'debugIndices' (hint: "debugIndices: List[<type>] = ...")

leo\core\leoDebugger.py:75: error: No library stub file for standard library module 'bdb'

leo\commands\checkerCommands.py:12: error: No library stub file for module 'flake8'
leo\commands\checkerCommands.py:16: error: No library stub file for module 'pyflakes'
leo\commands\checkerCommands.py:487: error: No library stub file for module 'pylint'

leo\core\leoChapters.py:94: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:110: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:119: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"

leo\core\leoBeautify.py:11: error: Cannot find module named 'leoGlobals'
leo\core\leoBeautify.py:11: error: Name 'g' already defined (by an import)
leo\core\leoBeautify.py:18: error: Incompatible types in assignment (expression has type "Callable[[Any], Any]", variable has type "Type[Command]")
leo\core\leoBeautify.py:31: error: Cannot find module named 'black'

leo\core\leoIPython.py:35: error: Cannot find module named 'ipykernel.connect'
leo\core\leoIPython.py:40: error: Cannot find module named 'ipykernel.kernelapp'
leo\core\leoIPython.py:45: error: "None" has no attribute "ipython_inited"

leo\core\leoNodes.py:326: error: Incompatible types in assignment (expression has type "None", base class "object" defined the type as "Callable[[object], int]")

leo\core\leoQt.py:27: error: No library stub file for module 'PyQt5'
leo\core\leoQt.py:31: error: No library stub file for module 'PyQt4'
leo\core\leoQt.py:52: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:53: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:54: error: Name 'QtWidgets' already defined on line 44
leo\core\leoQt.py:55: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoQt.py:55: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:56: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:57: error: "None" has no attribute "Qt"
leo\core\leoQt.py:65: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:66: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:67: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoQt.py:67: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:68: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:82: error: "None" has no attribute "QT_VERSION_STR"
leo\core\leoQt.py:92: error: "None" has no attribute "QString"
leo\core\leoQt.py:96: error: No library stub file for module 'PyQt5.QtDeclarative'
leo\core\leoQt.py:96: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:100: error: No library stub file for module 'PyQt5.phonon'
leo\core\leoQt.py:100: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:101: error: "None" has no attribute "Phonon"
leo\core\leoQt.py:105: error: Name 'QtMultimedia' already defined on line 45
leo\core\leoQt.py:109: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:113: error: No library stub file for module 'PyQt5.QtSvg'
leo\core\leoQt.py:113: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:117: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:121: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:125: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:129: error: No library stub file for module 'PyQt5.QtWebKitWidgets'
leo\core\leoQt.py:129: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:135: error: No library stub file for module 'PyQt5.QtWebEngineWidgets'
leo\core\leoQt.py:135: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:136: error: "None" has no attribute "QWebView"
leo\core\leoQt.py:136: error: "None" has no attribute "QWebEngineView"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebSettings"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebEngineSettings"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebPage"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebEnginePage"
leo\core\leoQt.py:143: error: "None" has no attribute "QString"
leo\core\leoQt.py:147: error: No library stub file for module 'PyQt4.QtDeclarative'
leo\core\leoQt.py:147: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:153: error: No library stub file for module 'PyQt4.phonon'
leo\core\leoQt.py:153: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:154: error: Item "None" of "Optional[Any]" has no attribute "Phonon"
leo\core\leoQt.py:158: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:162: error: No library stub file for module 'PyQt4.QtSvg'
leo\core\leoQt.py:162: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:166: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:170: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:174: error: No library stub file for module 'PyQt4.QtWebKit'
leo\core\leoQt.py:174: error: Name 'QtWebKitWidgets' already defined on line 45

leo\core\leoCheck.py:1457: error: Need type annotation for 'assigns_d' (hint: "assigns_d: Dict[<type>, <type>] = ...")
leo\core\leoCheck.py:1458: error: Need type annotation for 'calls_d' (hint: "calls_d: Dict[<type>, <type>] = ...")
leo\core\leoCheck.py:1459: error: Need type annotation for 'classes_d' (hint: "classes_d: Dict[<type>, <type>] = ...")
leo\core\leoCheck.py:1460: error: Need type annotation for 'defs_d' (hint: "defs_d: Dict[<type>, <type>] = ...")
leo\core\leoCheck.py:1461: error: Need type annotation for 'returns_d' (hint: "returns_d: Dict[<type>, <type>] = ...")
leo\core\leoCheck.py:2047: error: Need type annotation for 'd' (hint: "d: Dict[<type>, <type>] = ...")

leo\plugins\nested_splitter.py:9: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\nested_splitter.py:26: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:51: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:108: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:130: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\nested_splitter.py:391: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\editpane\clicky_splitter.py:13: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\editpane\clicky_splitter.py:25: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\qt_text.py:416: error: Name 'QtWidgets.QFrame' is not defined
leo\plugins\qt_text.py:454: error: Name 'QtWidgets.QTextBrowser' is not defined
leo\plugins\qt_text.py:485: error: Name 'QtWidgets.QListWidget' is not defined
leo\plugins\qt_text.py:744: error: Name 'QtWidgets.QFrame' is not defined

leo\core\leoColorizer.py:23: error: No library stub file for module 'pygments'
leo\core\leoColorizer.py:339: error: Need type annotation for 'zoom_dict' (hint: "zoom_dict: Dict[<type>, <type>] = ...")
leo\core\leoColorizer.py:2325: error: Name 'QtGui.QSyntaxHighlighter' is not defined
leo\core\leoColorizer.py:2457: error: No library stub file for module 'pygments.styles'
leo\core\leoColorizer.py:2492: error: Name 'Qsci.QsciLexerCustom' is not defined
leo\core\leoColorizer.py:2588: error: Need type annotation for 'traced_dict' (hint: "traced_dict: Dict[<type>, <type>] = ...")
leo\core\leoColorizer.py:2618: error: Need type annotation for 'format_dict' (hint: "format_dict: Dict[<type>, <type>] = ...")
leo\core\leoColorizer.py:2620: error: Need type annotation for 'lexers_dict' (hint: "lexers_dict: Dict[<type>, <type>] = ...")
leo\core\leoColorizer.py:2622: error: Need type annotation for 'state_s_dict' (hint: "state_s_dict: Dict[<type>, <type>] = ...")
leo\core\leoColorizer.py:2624: error: Need type annotation for 'state_n_dict' (hint: "state_n_dict: Dict[<type>, <type>] = ...")
leo\core\leoColorizer.py:2690: error: No library stub file for module 'pygments.token'
leo\core\leoColorizer.py:2711: error: No library stub file for module 'pygments.lexers'
leo\core\leoColorizer.py:2730: error: No library stub file for module 'pygments.lexer'
leo\core\leoColorizer.py:3044: error: Name 'QtGui.QTextBlockUserData' is not defined
leo\core\leoColorizer.py:3064: error: Cannot assign to a type
leo\core\leoColorizer.py:3064: error: Incompatible types in assignment (expression has type "Type[NullObject]", variable has type "Type[PygmentsBlockUserData]")

leo\core\leoRst.py:20: error: "None" has no attribute "debug"
leo\core\leoRst.py:25: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:35: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:37: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:40: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:45: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:50: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:54: error: Cannot find module named 'SilverCity'
leo\core\leoRst.py:86: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "arguments"
leo\core\leoRst.py:92: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:97: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "content"
leo\core\leoRst.py:101: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:306: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"
leo\core\leoRst.py:501: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"

leo\core\leoPrinting.py:97: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:103: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:112: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:118: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:127: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:134: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:145: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:152: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:159: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:165: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:172: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:182: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:188: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:197: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:203: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:212: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:219: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:230: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:237: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:243: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:249: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:258: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"

leo\core\leoImport.py:16: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoImport.py:22: error: No library stub file for module 'lxml.html'
leo\core\leoImport.py:22: error: No library stub file for module 'lxml'

leo\core\leoFileCommands.py:1802: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1810: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1822: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1829: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"

leo\core\leoKeys.py:196: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:218: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:223: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:229: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:235: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:241: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:247: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:253: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:259: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:274: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:538: error: Cannot find module named 'jedi'
leo\core\leoKeys.py:2335: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2477: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2551: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2581: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2602: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2623: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2632: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2641: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2650: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2797: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3935: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3943: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"

leo\commands\spellCommands.py:15: error: Cannot find module named 'enchant'
leo\commands\convertCommands.py:1598: error: No library stub file for module 'nbformat'

leo\core\leoAtFile.py:239: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:971: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:979: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:987: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:996: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:2306: error: No library stub file for standard library module 'parser'

leo\core\leoCommands.py:20: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoCommands.py:736: error: Cannot find module named '_pytest.config'
leo\core\leoCommands.py:737: error: Cannot find module named '_pytest.assertion.rewrite'
leo\core\leoCommands.py:1990: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[<type>] = ...")

leo\core\leoApp.py:1036: error: Cannot find module named 'flexx'
leo\core\leoApp.py:1443: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1444: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1591: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1592: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"

leo\plugins\editpane\editpane.py:10: error: Cannot find module named 'OpenGL'
leo\plugins\editpane\editpane.py:66: error: Name 'QtWidgets.QWidget' is not defined

leo\core\leoFrame.py:905: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:962: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1030: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1044: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"

leo\core\runLeo.py:17: error: Argument 1 to "join" has incompatible type "Optional[str]"; expected "Union[str, _PathLike[str]]"
leo\core\runLeo.py:28: error: Incompatible types in assignment (expression has type "LeoApp", variable has type "None")

leo\plugins\mod_scripting.py:459: error: Cannot find module named 'rpdb2'
leo\plugins\mod_scripting.py:504: error: Cannot find module named 'leo.core.leoScriptModule'
leo\plugins\mod_scripting.py:1204: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1240: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1295: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1319: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"

leo\plugins\qt_events.py:46: error: Name 'QtCore.QObject' is not defined

leo\core\leoTest.py:27: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoTest.py:1711: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[<type>, <type>] = ...")
leo\core\leoTest.py:1712: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[<type>, <type>] = ...")
leo\core\leoTest.py:1713: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[<type>, <type>] = ...")

leo\plugins\cursesGui2.py:39: error: Cannot assign to a type
leo\plugins\cursesGui2.py:39: error: Incompatible types in assignment (expression has type "None", variable has type "Type[Tk]")
leo\plugins\cursesGui2.py:48: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen.utilNotify'
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen'
leo\plugins\cursesGui2.py:60: error: Cannot find module named 'npyscreen.wgwidget'
leo\plugins\cursesGui2.py:73: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:208: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:299: error: Name 'npyscreen.TreeData' is not defined
leo\plugins\cursesGui2.py:479: error: Name 'npyscreen.TreeLine' is not defined
leo\plugins\cursesGui2.py:699: error: Name 'npyscreen.MiniButtonPress' is not defined
leo\plugins\cursesGui2.py:1823: error: Need type annotation for 'set_focus_fail' (hint: "set_focus_fail: List[<type>] = ...")
leo\plugins\cursesGui2.py:2328: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreFrame"
leo\plugins\cursesGui2.py:2397: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreLog"
leo\plugins\cursesGui2.py:2724: error: Name 'npyscreen.NPSApp' is not defined
leo\plugins\cursesGui2.py:2741: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:2955: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:3103: error: Name 'npyscreen.Form' is not defined
leo\plugins\cursesGui2.py:3117: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3276: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3290: error: Name 'npyscreen.MLTree' is not defined
leo\plugins\cursesGui2.py:3952: error: Name 'npyscreen.TreeData' is not defined

leo\plugins\qt_frame.py:27: error: Cannot determine type of 'enabled'
leo\plugins\qt_frame.py:31: error: Cannot assign multiple types to name "splitter_class" without an explicit "Type[...]" annotation
leo\plugins\qt_frame.py:31: error: "None" has no attribute "QSplitter"
leo\plugins\qt_frame.py:38: error: Name 'QtWidgets.QMainWindow' is not defined
leo\plugins\qt_frame.py:1503: error: Name 'QtWidgets.QTabWidget' is not defined
leo\plugins\qt_frame.py:1737: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1738: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1793: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1794: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:2490: error: Need type annotation for 'styleSheetCache' (hint: "styleSheetCache: Dict[<type>, <type>] = ...")
leo\plugins\qt_frame.py:3010: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3022: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3038: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3047: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3063: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3077: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3093: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3321: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtLog"
leo\plugins\qt_frame.py:3923: error: Name 'QtWidgets.QTreeWidget' is not defined
leo\plugins\qt_frame.py:4632: error: Name 'QtWidgets.QTabBar' is not defined
leo\plugins\qt_frame.py:4647: error: Name 'QtWidgets.QMenu' is not defined

leo\core\leoConfig.py:37: error: Need type annotation for 'settingsDict' (hint: "settingsDict: Dict[<type>, <type>] = ...")
leo\core\leoConfig.py:2043: error: Need type annotation for 'no_menu_dict' (hint: "no_menu_dict: Dict[<type>, <type>] = ...")

leo\plugins\leoflexx.py:39: error: Cannot find module named 'flexx'
leo\plugins\leoflexx.py:40: error: Cannot find module named 'pscript'
leo\plugins\leoflexx.py:1186: error: Need type annotation for 'attributes' (hint: "attributes: Set[<type>] = ...")

leo\plugins\qt_gui.py:618: error: Cannot find module named 'pyzo'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core.menu'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools.pyzoFileBrowser'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools'
leo\plugins\qt_gui.py:627: error: Cannot find module named 'pyzo.core.main'
leo\plugins\qt_gui.py:989: error: Need type annotation for 'size_warnings' (hint: "size_warnings: List[<type>] = ...")
leo\plugins\qt_gui.py:1349: error: Name 'QtWidgets.QMessageBox' is not defined
leo\plugins\qt_gui.py:1487: error: No library stub file for module 'PyQt5.QtTest'
leo\plugins\qt_gui.py:1491: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1492: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1493: error: "None" has no attribute "QObject"

Found 360 errors in 40 files (checked 1 source file)
#@+node:ekr.20200505050955.1: *5* ===== mvc-prototype branch
@language rest
@wrap

- checkout the mvc-prototype branch

- open leo/core/LeoPyRef.leo in Leo and save this document as leo/core/LeoPyRef.db
  This should provide a large outline for the prototype to play with.

- python leo/extensions/myleoqt.py leo\core\leoPy.db
#@+node:vitalije.20200502083732.1: *6* @@@file ../extensions/myleoqt.py
#@+node:vitalije.20200502091628.1: *6* <<imports>>
from collections import defaultdict
import sys
import os
import pickle
from PyQt5 import QtCore, QtGui, QtWidgets
assert QtGui
import sqlite3
import time
import timeit
import unittest
from hypothesis.strategies import lists, integers, sampled_from, data
from hypothesis import given, settings
from datetime import timedelta
import random

# Set the path before importing Leo files.
LEO_INSTALLED_AT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if LEO_INSTALLED_AT not in sys.path:
    sys.path.append(LEO_INSTALLED_AT)
LEO_ICONS_DIR = os.path.join(LEO_INSTALLED_AT, 'leo', 'themes', 'light', 'Icons')
try:
    import leo.core.leoNodes as leoNodes
    import leo.core.leoGlobals as g
except ImportError:
    print('===== import error!')
g.app = g.bunch(nodeIndices=leoNodes.NodeIndices('vitalije'))

Q = QtCore.Qt
#@+node:vitalije.20200502103535.1: *6* draw_tree
def draw_tree(tree, root, icons):
    def additem(par, parItem):
        for ch in par.children:
            item = QtWidgets.QTreeWidgetItem()
            item.setFlags(item.flags() |
                          Q.ItemIsEditable |
                          item.DontShowIndicatorWhenChildless)
            parItem.addChild(item)
            item.setText(0, ch.h)
            item.setData(0, 1024, ch)
            item.setExpanded(ch.isExpanded())
            item.setIcon(0, icons[ch.computeIcon()])
            additem(ch, item)
    ritem = tree.invisibleRootItem()
    ritem.setData(0, 1024, root)
    additem(root, ritem)
#@+node:vitalije.20200508091419.1: *6* execute_script
def execute_script(self):
    c = self.c
    t = self.tree
    root = t.invisibleRootItem()
    curr = t.currentItem()
    currpath = path_to_item(root, curr)

    # now we need to replace current top level items
    # with the their clones so that we can preserve
    # the original ones for undo
    t.blockSignals(True)
    n = root.childCount()
    olditems = [root.takeChild(0) for x in range(n)]
    for item in olditems:
        root.addChild(item.clone())

    # let's find current item in the new tree
    ncurr = item_from_path(root, currpath)
    t.setCurrentItem(ncurr)
    t.blockSignals(False)

    # store old v-nodes data
    old_vs = set((x, x.h, x.b) for x in c.fileCommands.gnxDict.values())

    # new values for the redo operation
    # if the script finishes without exception
    # these values will be updated after the script finishes
    # for now they are the same as the old values
    newitems = olditems
    new_vs = old_vs
    newcurr = curr

    # some more data for the locals in script
    p = QtPosition(ncurr)
    v = p.v
    script = v.b

    @others

    try:
        exec(script, dict(c=c, v=v, p=p, tree=t, root=root))
        # update new values and redraw the tree
        nset = set((x, x.h, x.b) for x in c.fileCommands.gnxDict.values())
        new_vs =  nset - old_vs
        old_vs = old_vs - nset
        item = t.currentItem()
        newv = item.data(0, 1024)
        npath = path_to_item(root, item)
        self.redraw()

        newcurr = item_from_path(root, npath)
        # we want to keep the same node selected if possible
        # but script may delete previously selected node or
        # some other node so their position won't match
        if not newcurr or newcurr.data(0, 1024) != newv:
            # let's try to find item that points to the newv
            for item in iter_all_v_items(root, newv):
                newcurr = item
                break

        # remember the newitems for redo
        n2 = root.childCount()
        newitems = [root.child(i) for i in range(n2)]

        # select node if we found one to select
        if newcurr:
            t.setCurrentItem(newcurr)

    except KeyboardInterrupt:
        # sometimes script got into an infinite loop
        # or work too long
        undoexec()
        return
    except:
        g.es_print_exception()
        undoexec()
        return
    # script terminated successfully let's add undo/redo pair
    self.c.addUndo(undoexec, redoexec)
#@+node:vitalije.20200508104717.1: *7* undoexec
def undoexec():
    for v, h, b in old_vs:
        v.b = b
        v.h = h
    t.blockSignals(True)
    root.takeChildren()
    for item in olditems:
        root.addChild(item)
    reconnect_vnodes(root)
    t.blockSignals(False)
    t.setCurrentItem(curr)
#@+node:vitalije.20200508104721.1: *7* redoexec
def redoexec():
    for v, h, b in new_vs:
        v.b = b
        v.h = h
    t.blockSignals(True)
    root.takeChildren()
    for item in newitems:
        root.addChild(item)
    reconnect_vnodes(root)
    t.blockSignals(False)
    t.setCurrentItem(newcurr)
#@+node:vitalije.20200507182943.1: *6* test_select_and_commnads
@settings(max_examples=50, deadline=timedelta(seconds=4))
@given(data())
def test_select_and_commnads(data):
    app = demo2_app()

    index = data.draw(integers(min_value=0, max_value=10000))
    names = data.draw(lists(sampled_from(method_names), min_size=5,
                             max_size=100))

    select_item_at_index(app, index)
    a1, b1 = outline_shapes(app)
    for name in names:
        meth = getattr(app, name)
        meth()
        app.processEvents() #
        if method_names.index(name) > 3:
            # possible change in the outline
            a2, b2 = outline_shapes(app)
            assert a2 == b2
            if a1 != a2:
                # the change is real - let's undo it
                app.undo()
                a, b = outline_shapes(app)
                assert a == a1
                assert b == b1
                app.redo()
            a1, b1 = a2, b2
#@+node:ekr.20200724115109.1: *5*  leoInteg done
#@+node:ekr.20200724115026.1: *6* ===== leoInteg #92: Unnecessary commands
#@+node:ekr.20041224080039: *7* g.dictToString
def dictToString(d, indent='', tag=None):
    """Pretty print a Python dict to a string."""
    # pylint: disable=unnecessary-lambda
    if not d:
        return '{}'
    result = ['{\n']
    indent2 = indent + ' ' * 4
    n = 2 + len(indent) + max([len(repr(z)) for z in d.keys()])
    for i, key in enumerate(sorted(d, key=lambda z: repr(z))):
        pad = ' ' * max(0, (n - len(repr(key))))
        result.append(f"{pad}{key}:")
        result.append(objToString(d.get(key), indent=indent2))
        if i + 1 < len(d.keys()):
            result.append(',')
        result.append('\n')
    result.append(indent + '}')
    s = ''.join(result)
    return f"{tag}...\n{s}\n" if tag else s
#@+node:ekr.20150508134046.1: *7* g.new_cmd_decorator (decorator)
def new_cmd_decorator(name, ivars):
    """
    Return a new decorator for a command with the given name.
    Compute the class *instance* using the ivar string or list.
    
    Don't even think about removing the @cmd decorators!
    See https://github.com/leo-editor/leo-editor/issues/325
    """

    def _decorator(func):

        def new_cmd_wrapper(event):
            c = event.c
            self = g.ivars2instance(c, g, ivars)
            try:
                func(self, event=event)
                    # Don't use a keyword for self.
                    # This allows the VimCommands class to use vc instead.
            except Exception:
                g.es_exception()

        new_cmd_wrapper.__func_name__ = func.__name__ # For leoInteg.
        new_cmd_wrapper.__name__ = name
        new_cmd_wrapper.__doc__ = func.__doc__
        global_commands_dict[name] = new_cmd_wrapper
            # Put the *wrapper* into the global dict.
        return func
            # The decorator must return the func itself.

    return _decorator
#@+node:ekr.20171123095526.1: *7* g.commander_command (decorator)
class CommanderCommand:
    """
    A global decorator for creating commander commands, that is, commands
    that were formerly methods of the Commands class in leoCommands.py.
    
    Usage:

        @g.command('command-name')
        def command_name(self, *args, **kwargs):
            ...
        
    The decorator injects command_name into the Commander class and calls
    funcToMethod so the ivar will be injected in all future commanders.

    g can *not* be used anywhere in this class!
    """

    def __init__(self, name, **kwargs):
        """Ctor for command decorator class."""
        self.name = name

    def __call__(self, func):
        """Register command for all future commanders."""

        def commander_command_wrapper(event):
            c = event.get('c')
            method = getattr(c, func.__name__, None)
            method(event=event)

        # Inject ivars for plugins_menu.py.
        commander_command_wrapper.__func_name__ = func.__name__ # For leoInteg.
        commander_command_wrapper.__name__ = self.name
        commander_command_wrapper.__doc__ = func.__doc__
        global_commands_dict[self.name] = commander_command_wrapper
        if app:
            import leo.core.leoCommands as leoCommands
            funcToMethod(func, leoCommands.Commands)
            for c in app.commanders():
                c.k.registerCommand(self.name, func)
        # Inject ivars for plugins_menu.py.
        func.is_command = True
        func.command_name = self.name
        return func

commander_command = CommanderCommand
#@+node:ville.20090521164644.5924: *7* g.command (decorator)
class Command:
    """
    A global decorator for creating commands.

    This is the recommended way of defining all new commands, including
    commands that could befined inside a class. The typical usage is:

        @g.command('command-name')
        def A_Command(event):
            c = event.get('c')
            ...

    g can *not* be used anywhere in this class!
    """

    def __init__(self, name, **kwargs):
        """Ctor for command decorator class."""
        self.name = name

    def __call__(self, func):
        """Register command for all future commanders."""
        global_commands_dict[self.name] = func
        if app:
            for c in app.commanders():
                c.k.registerCommand(self.name, func)
        # Inject ivars for plugins_menu.py.
        func.__func_name__ = func.__name__ # For leoInteg.
        func.is_command = True
        func.command_name = self.name
        return func

command = Command
#@+node:ekr.20150325075144.1: *7* g.getLanguageFromPosition
def getLanguageAtPosition(c, p):
    """
    Return the language in effect at position p.
    This is always a lowercase language name, never None.
    """
    aList = g.get_directives_dict_list(p)
    d = g.scanAtCommentAndAtLanguageDirectives(aList)
    language = (
        d and d.get('language') or
        g.getLanguageFromAncestorAtFileNode(p) or
        c.config.getString('target-language') or
        'python'
    )
    return language.lower()
#@+node:ekr.20200405054814.1: *4*  For 6.3: done
#@+node:ekr.20200513063020.1: *5* #1269: Key handling
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1269

First commit: 4b8320485c0 2020-02-17 17:57:04

Last commit: 2507a1fcc70e 2020-05-26 07:54:34


@language python
@nosearch
#@+node:ekr.20200517131851.1: *6* ----- what I did
@nosearch
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1269

Major changes:
- c.doCommand no longer sets k.retVal.
- Removed k.commandExists: It was supposed to handle stuff after command names.
- Removed all dynamicMenu kwargs.
- Removed k.masterCommand!

Other changes:
- Eliminated k.newMinibufferWidget
- k.endCommand ignores its arguments and sets k.commandName = None
- Replace c.executeAnyCommand by try/except block.
- Remove unused k.argSelectedText ivar.
- Remove unused k.newMinibufferWidget ivar.
- Remove 'specialCallback' logic.
- Remove mouseClick kwarg from k.keyboardQuit.

@language python
#@+node:ekr.20200517130334.1: *6* ----- k ivars
#@+node:ekr.20061031131434.78: *7* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
#@+node:ekr.20061031131434.79: *7* k.defineInternalIvars
def defineInternalIvars(self):
    """Define internal ivars of the KeyHandlerClass class."""
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of BindingInfo objects.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are BindingInfo objects.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None  # New support for the demo.py plugin.
    self.demoPrevKey = None  # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
#@+node:ekr.20200523170857.1: *6* ----- Calls to k.keyboardQuit
@nosearch

# flattened, word, ignore-case, head, body

# found 25 nodes
#@+node:ekr.20200523170903.1: *7* No args
#@+node:ekr.20150514043850.32: *8* abbrev.toggleAbbrevMode
@cmd('toggle-abbrev-mode')
def toggleAbbrevMode(self, event=None):
    """Toggle abbreviation mode."""
    k = self.c.k
    k.abbrevOn = not k.abbrevOn
    k.keyboardQuit()
    if not g.unitTesting and not g.app.batchMode:
        g.es('Abbreviations are ' + 'on' if k.abbrevOn else 'off')
#@+node:ekr.20110512212836.14469: *8* ac.exit
def exit(self):

    c = self.c
    w = self.w or c.frame.body.wrapper
    c.k.keyboardQuit()
    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None  # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName, 'Modules', 'Info'):
            c.frame.log.deleteTab(name)
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i, j = w.getSelectionRange()
    w.setSelectionRange(i, j, insert=j)
    # Was in finish.
    c.frame.body.onBodyChanged('Typing')
    c.recolor()

finish = exit
abort = exit
#@+node:ekr.20150514043714.14: *8* BaseEdit.keyboardQuit
def keyboardQuit(self, event=None):
    """Clear the state and the minibuffer label."""
    return self.c.k.keyboardQuit()
#@+node:ekr.20150514063305.249: *8* ec.whatLine
@cmd('what-line')
def whatLine(self, event):
    """Print the line number of the line containing the cursor."""
    k = self.c.k
    w = self.editWidget(event)
    if w:
        s = w.getAllText()
        i = w.getInsertPoint()
        row, col = g.convertPythonIndexToRowCol(s, i)
        k.keyboardQuit()
        k.setStatusLabel(f"Line {row}")
#@+node:ekr.20170806094318.1: *8* efc.deleteFile
@cmd('file-delete')
def deleteFile(self, event):
    """Prompt for the name of a file and delete it."""
    k = self.c.k
    k.setLabelBlue('Delete File: ')
    k.extendLabel(os.getcwd() + os.sep)
    k.get1Arg(event, handler=self.deleteFile1)

def deleteFile1(self, event):
    k = self.c.k
    k.keyboardQuit()
    k.clearState()
    try:
        os.remove(k.arg)
        k.setStatusLabel(f"Deleted: {k.arg}")
    except Exception:
        k.setStatusLabel(f"Not Deleted: {k.arg}")
#@+node:ekr.20170806094318.9: *8* efc.makeDirectory
@cmd('directory-make')
def makeDirectory(self, event):
    """Prompt for the name of a directory and create it."""
    k = self.c.k
    k.setLabelBlue('Make Directory: ')
    k.extendLabel(os.getcwd() + os.sep)
    k.get1Arg(event, handler=self.makeDirectory1)
def makeDirectory1(self, event):
    k = self.c.k
    k.keyboardQuit()
    k.clearState()
    try:
        os.mkdir(k.arg)
        k.setStatusLabel(f"Created: {k.arg}")
    except Exception:
        k.setStatusLabel(f"Not Created: {k.arg}")
#@+node:ekr.20170806094318.14: *8* efc.removeDirectory
@cmd('directory-remove')
def removeDirectory(self, event):
    """Prompt for the name of a directory and delete it."""
    k = self.c.k
    k.setLabelBlue('Remove Directory: ')
    k.extendLabel(os.getcwd() + os.sep)
    k.get1Arg(event, handler=self.removeDirectory1)

def removeDirectory1(self, event):
    k = self.c.k
    k.keyboardQuit()
    k.clearState()
    try:
        os.rmdir(k.arg)
        k.setStatusLabel(f"Removed: {k.arg}")
    except Exception:
        k.setStatusLabel(f"Not Removed: {k.arg}")
#@+node:ekr.20150514063305.91: *8* executeSubprocess
def executeSubprocess(self, event, command):
    """Execute a command in a separate process."""
    trace = False
    import sys
    k = self.c.k
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL if trace else subprocess.PIPE,
            shell=sys.platform.startswith('win'),
        )
        out, err = p.communicate()
        for line in g.splitLines(out):
            g.es_print(g.toUnicode(line.rstrip()))
    except Exception:
        g.es_exception()
    k.keyboardQuit()
        # Inits vim mode too.
    g.es(f"Done: {command}")
#@+node:ekr.20131117164142.17015: *8* find.hideFindTab
@cmd('find-tab-hide')
def hideFindTab(self, event=None):
    """Hide the Find tab."""
    c = self.c
    if self.minibuffer_mode:
        c.k.keyboardQuit()
    else:
        self.c.frame.log.selectTab('Log')
#@+node:ekr.20140813052702.18200: *8* fnc.get_file_name (entry)
def get_file_name(self, event, callback, filterExt, prompt, tabName):
    """Get a file name, supporting file completion."""
    c, k = self.c, self.c.k
    tag = 'get-file-name'
    state = k.getState(tag)
    char = event.char if event else ''
    if state == 0:
        # Re-init all ivars.
        self.log = c.frame.log or g.NullObject()
        self.callback = callback
        self.filterExt = filterExt or ['.pyc', '.bin',]
        self.prompt = prompt
        self.tabName = tabName
        join = g.os_path_finalize_join
        finalize = g.os_path_finalize
        normslashes = g.os_path_normslashes
        # #467: Add setting for preferred directory.
        directory = c.config.getString('initial-chooser-directory')
        if directory:
            directory = finalize(directory)
            if not g.os_path_exists(directory):
                g.es_print('@string initial-chooser-directory not found',
                    normslashes(directory))
                directory = None
        if not directory:
            directory = finalize(os.curdir)
        # Init the label and state.
        tail = k.functionTail and k.functionTail.strip()
        label = join(directory, tail) if tail else directory + os.sep
        self.set_label(normslashes(label))
        k.setState(tag, 1, self.get_file_name)
        self.log.selectTab(self.tabName)
        junk, tabList = self.compute_tab_list()
        self.show_tab_list(tabList)
        c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n', 'Return'):
        self.log.deleteTab(self.tabName)
        path = self.get_label()
        k.keyboardQuit()
        if self.callback:
            # pylint: disable=not-callable
            self.callback(path)
        else:
            g.trace('no callback')
    elif char in ('\t', 'Tab'):
        self.do_tab()
        c.minibufferWantsFocus()
    elif char in ('\b', 'BackSpace'):
        self.do_back_space()
        c.minibufferWantsFocus()
    elif k.isPlainKey(char):
        self.do_char(char)
    else:
        pass
#@+node:ekr.20140816165728.18941: *8* ga.get_arg (entry) & helpers
def get_arg(self, event,
    returnKind=None, returnState=None, handler=None,
    tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << ga.get_arg docstring >>
    if tabList is None: tabList = []
    c, k = self.c, self.k
    state = k.getState('getArg')
    c.check_event(event)
    c.minibufferWantsFocusNow()
    char = event.char if event else ''
    if state > 0:
        k.setLossage(char, stroke)
    if state == 0:
        self.do_state_zero(completion, event, handler, oneCharacter,
            returnKind, returnState, tabList, useMinibuffer)
        return
    if char == 'Escape':
        k.keyboardQuit()
    elif self.should_end(char, stroke):
        self.do_end(event, char, stroke)
    elif char in ('\t', 'Tab'):
        self.do_tab(self.tabList, self.arg_completion)
    elif char in ('\b', 'BackSpace'):
        self.do_back_space(self.tabList, self.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        # Ignore only F-keys. Ignoring all except plain keys would kill unicode searches.
        pass
    else:
        self.do_char(event, char)
#@+node:ekr.20140822051549.18299: *9* << ga.get_arg docstring >>
"""
Accumulate an argument. Enter the given return state when done.

Ctrl-G will abort this processing at any time.

All commands needing user input call k.getArg, which just calls ga.get_arg.

The arguments to ga.get_arg are as follows:

event:              The event passed to the command.

returnKind=None:    A string.
returnState=None,   An int.
handler=None,       A function.

    When the argument is complete, ga.do_end does::

        if kind: k.setState(kind,n,handler)

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
#@+node:ekr.20161019060054.1: *9* ga.cancel_after_state
def cancel_after_state(self):

    self.after_get_arg_state = None
#@+node:ekr.20140816165728.18955: *9* ga.do_char
def do_char(self, event, char):
    """Handle a non-special character."""
    k = self.k
    k.updateLabel(event)
    # Any plain key resets tab cycling.
    self.reset_tab_cycling()
#@+node:ekr.20140817110228.18316: *9* ga.do_end
def do_end(self, event, char, stroke):
    """A return or escape has been seen."""
    k = self.k
    if char == '\t' and char in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if stroke and stroke in k.getArgEscapes:
        k.getArgEscapeFlag = True
    # Get the value.
    gui_arg = getattr(g.app.gui, 'curses_gui_arg', None)
    if k.oneCharacterArg:
        k.arg = char
    else:
        # A hack to support the curses gui.
        k.arg = gui_arg or self.get_label()
    kind, n, handler = self.after_get_arg_state
    if kind:
        k.setState(kind, n, handler)
    self.log.deleteTab('Completion')
    self.reset_tab_cycling()
    if handler:
        # pylint: disable=not-callable
        handler(event)
#@+node:ekr.20140817110228.18317: *9* ga.do_state_zero
def do_state_zero(self, completion, event, handler, oneCharacter,
    returnKind, returnState, tabList, useMinibuffer
):
    """Do state 0 processing."""
    c, k = self.c, self.k
    #
    # Set the ga globals...
    k.getArgEscapeFlag = False
    self.after_get_arg_state = returnKind, returnState, handler
    self.arg_completion = completion
    self.cycling_prefix = None
    self.handler = handler
    self.tabList = tabList[:] if tabList else []
    #
    # Set the k globals...
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    #
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg', 1, k.getArg)
    # pylint: disable=consider-using-ternary
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
#@+node:ekr.20140818103808.18234: *9* ga.should_end
def should_end(self, char, stroke):
    """Return True if ga.get_arg should return."""
    k = self.k
    return (
        char in ('\n', 'Return',) or
        k.oneCharacterArg or
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes
            # The Find Easter Egg.
    )
#@+node:ekr.20140818103808.18235: *9* ga.trace_state
def trace_state(self, char, completion, handler, state, stroke):
    """Trace the vars and ivars."""
    k = self.c.k
    g.trace(
        'state', state, 'char', repr(char), 'stroke', repr(stroke),
        # 'isPlain',k.isPlainKey(stroke),
        '\n',
        'escapes', k.getArgEscapes,
        'completion', self.arg_completion,
        'handler', self.handler and self.handler.__name__ or 'None',
    )
#@+node:ekr.20061031131434.111: *8* k.fullCommand (alt-x) & helper
@cmd('full-command')
def fullCommand(
    self,
    event,
    specialStroke=None,
    specialFunc=None,
    help=False,
    helpHandler=None,
):
    """Handle 'full-command' (alt-x) mode."""
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if state > 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event  # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt) :].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
    except Exception:
        g.es_exception()
        self.keyboardQuit()
#@+node:ekr.20061031131434.112: *9* k.callAltXFunction
def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
#@+node:ekr.20061031131434.152: *8* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
#@+node:ekr.20180418114300.1: *9* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:ekr.20180418114300.1: *8* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:ekr.20061031131434.130: *8* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
#@+node:ekr.20110605121601.18012: *8* lqlw.end_completer
def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
#@+node:ekr.20110605121601.18481: *8* qt_gui.onDeactiveEvent
# deactivated_name = ''

deactivated_widget = None

def onDeactivateEvent(self, event, c, obj, tag):
    """
    Gracefully deactivate the Leo window.
    Called several times for each window activation.
    """
    w = self.get_focus()
    w_name = w and w.objectName()
    if 'focus' in g.app.debug:
        g.trace(repr(w_name))
    self.active = False
        # Used only by c.idle_focus_helper.
    #
    # Careful: never save headline widgets.
    if w_name == 'headline':
        self.deactivated_widget = c.frame.tree.treeWidget
    else:
        self.deactivated_widget = w if w_name else None
    #
    # Causes problems elsewhere...
        # if c.exists and not self.deactivated_name:
            # self.deactivated_name = self.widget_name(self.get_focus())
            # self.active = False
            # c.k.keyboardQuit(setFocus=False)
    g.doHook('deactivate', c=c, p=c.p, v=c.p, event=event)
#@+node:ekr.20131017100903.16689: *8* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
#@+node:ekr.20150514063305.95: *8* shellCommandOnRegion
@cmd('shell-command-on-region')
def shellCommandOnRegion(self, event):
    """Execute a command taken from the selected text in a separate process."""
    k = self.c.k
    w = self.editWidget(event)
    if w:
        if w.hasSelection():
            command = w.getSelectedText()
            self.executeSubprocess(event, command)
        else:
            g.es('No text selected')
    k.keyboardQuit()
#@+node:ekr.20160918060654.1: *8* vc.on_activate
def on_activate(self):
    """Handle an activate event."""
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    self.quit()
    self.show_status()
    # This seems not to be needed.
        # self.c.k.keyboardQuit()
#@+node:ekr.20140807070500.18163: *8* vc.reset
def reset(self, setFocus):
    """
    Called from k.keyboardQuit when the user types Ctrl-G (setFocus = True).
    Also called when the user clicks the mouse (setFocus = False).
    """
    self.do_trace()
    if setFocus:
        # A hard reset.
        self.quit()
    elif 0:
        # Do *not* change state!
        g.trace('no change! state:', self.state, g.callers())
#@+node:ekr.20200523171047.1: *7* setFocus = False
#@+node:ekr.20140901062324.18565: *8* mouseReleaseEvent (monkey-patch) QTextEditWrapper
def mouseReleaseEvent(event, self=self):
    """
    Monkey patch for self.widget (QTextEditWrapper) mouseReleaseEvent.
    """
    assert isinstance(self, QTextEditWrapper), self
    assert isinstance(self.widget, QtWidgets.QTextEdit), self.widget
    QtWidgets.QTextEdit.mouseReleaseEvent(self.widget, event)
        # Call the base class.
    c = self.c
    setattr(event, 'c', c)
    # Open the url on a control-click.
    if QtCore.Qt.ControlModifier & event.modifiers():
        g.openUrlOnClick(event)
    else:
        if name == 'body':
            c.p.v.insertSpot = c.frame.body.wrapper.getInsertPoint()
        g.doHook("bodyclick2", c=c, p=c.p, v=c.p)
        # Do *not* change the focus! This would rip focus away from tab panes.
        c.k.keyboardQuit(setFocus=False)
#@+node:ekr.20110605121601.17896: *8* qtree.onItemClicked
def onItemClicked(self, item, col, auto_edit=False):
    """Handle a click in a BaseNativeTree widget item."""
    # This is called after an item is selected.
    if self.busy:
        return
    c = self.c
    try:
        self.busy = True
        p = self.item2position(item)
        if p:
            auto_edit = self.prev_v == p.v
                # Fix #1049.
            self.prev_v = p.v
            event = None
            #
            # Careful. We may have switched gui during unit testing.
            if hasattr(g.app.gui, 'qtApp'):
                mods = g.app.gui.qtApp.keyboardModifiers()
                isCtrl = bool(mods & QtConst.ControlModifier)
                # We could also add support for QtConst.ShiftModifier, QtConst.AltModifier
                # & QtConst.MetaModifier.
                if isCtrl:
                    if g.doHook("iconctrlclick1", c=c, p=p, event=event) is None:
                        c.frame.tree.OnIconCtrlClick(p)
                            # Call the base class method.
                    g.doHook("iconctrlclick2", c=c, p=p, event=event)
                else:
                    # 2014/02/21: generate headclick1/2 instead of iconclick1/2
                    g.doHook("headclick1", c=c, p=p, event=event)
                    g.doHook("headclick2", c=c, p=p, event=event)
        else:
            auto_edit = None
            g.trace('*** no p')
        # 2011/05/27: click here is like ctrl-g.
        c.k.keyboardQuit(setFocus=False)
        c.treeWantsFocus()  # 2011/05/08: Focus must stay in the tree!
        c.outerUpdate()
        # 2011/06/01: A second *single* click on a selected node
        # enters editing state.
        if auto_edit and self.auto_edit:
            e, wrapper = self.createTreeEditorForItem(item)
        # 2014/10/26: Reset find vars.
        c.findCommands.reset_state_ivars()
    finally:
        self.busy = False
#@+node:ekr.20200519035546.1: *6* ----- kwargs: ^def\b.*=
@nosearch

# flattened, ignore-case, regex, head, body

# found 39 nodes
#@+node:ekr.20200519084056.1: *7* Changed
#@+node:ekr.20061031131434.9: *8* ac.autoComplete
@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
#@+node:ekr.20061031131434.13: *8* ac.showCalltips
@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
#@+node:ekr.20140817110228.18321: *8* ga.compute_tab_list
# Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())

def compute_tab_list(self, tabList):
    """Compute and show the available completions."""
    # Support vim-mode commands.
    command = self.get_label()
    if self.is_command(command):
        tabList, common_prefix = g.itemsMatchingPrefixInList(command, tabList)
        return common_prefix, tabList
    #
    # For now, disallow further completions if something follows the command.
    command = self.get_command(command)
    return command, [command]
#@+node:ekr.20061031131434.103: *8* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
#@+node:ekr.20200519083958.1: *7* Harmless
#@+node:ekr.20200519035612.1: *8* Just event=None
#@+node:ekr.20061031131434.10: *9* ac.autoCompleteForce
@cmd('auto-complete-force')
def autoCompleteForce(self, event=None):
    """Show autocompletion, even if autocompletion is not presently enabled."""
    return self.autoComplete(event, force=True)
#@+node:ekr.20061031131434.12: *9* ac.enable/disable/toggleAutocompleter/Calltips
@cmd('disable-autocompleter')
def disableAutocompleter(self, event=None):
    """Disable the autocompleter."""
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

@cmd('disable-calltips')
def disableCalltips(self, event=None):
    """Disable calltips."""
    self.k.enable_calltips = False
    self.showCalltipsStatus()

@cmd('enable-autocompleter')
def enableAutocompleter(self, event=None):
    """Enable the autocompleter."""
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

@cmd('enable-calltips')
def enableCalltips(self, event=None):
    """Enable calltips."""
    self.k.enable_calltips = True
    self.showCalltipsStatus()

@cmd('toggle-autocompleter')
def toggleAutocompleter(self, event=None):
    """Toggle whether the autocompleter is enabled."""
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

@cmd('toggle-calltips')
def toggleCalltips(self, event=None):
    """Toggle whether calltips are enabled."""
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@+node:ekr.20110510071925.14586: *9* ac.init_qcompleter
def init_qcompleter(self, event=None):

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    w = self.c.frame.body.wrapper.widget
        # A LeoQTextBrowser.  May be none for unit tests.
    if w and options:
        self.qw = w
        self.qcompleter = w.init_completer(options)
        self.auto_completer_state_handler(event)
    else:
        if not g.unitTesting:
            g.warning('No completions')
        self.exit()
#@+node:ekr.20110511133940.14552: *9* ac.init_tabcompleter
def init_tabcompleter(self, event=None):
    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    if options:
        self.clearTabName()  # Creates the tabbed pane.
        self.auto_completer_state_handler(event)
    else:
        g.warning('No completions')
        self.exit()
#@+node:ekr.20061031131434.14: *9* ac.showCalltipsForce
@cmd('show-calltips-force')
def showCalltipsForce(self, event=None):
    """Show the calltips at the cursor, even if calltips are not presently enabled."""
    return self.showCalltips(event, force=True)
#@+node:ekr.20061031131434.161: *9* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
#@+node:ekr.20070613133500: *9* k.menuCommandKey
def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
#@+node:ekr.20061031131434.119: *9* k.printBindings & helper
@cmd('show-bindings')
def printBindings(self, event=None):
    """Print all the bindings presently in effect."""
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for bi in aList:
            s1 = '' if bi.pane == 'all' else bi.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = bi.commandName
            s4 = bi.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt',  # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl',  # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append(f"***** {prefix}...\n")
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result  # for unit test.
#@+node:ekr.20061031131434.120: *10* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    """Helper for k.printBindings"""
    c, lm = self.c, g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        letter = lm.computeBindingLetter(c, kind)
        pane = f"{pane if pane else 'all':4}: "
        left = pane + key  # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
#@+node:ekr.20120520174745.9867: *9* k.printButtons
@cmd('show-buttons')
def printButtons(self, event=None):
    """Print all @button and @command commands, their bindings and their source."""
    k = self; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = [f"{z[1]} {z[0]}" for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
#@+node:ekr.20061031131434.121: *9* k.printCommands
@cmd('show-commands')
def printCommands(self, event=None):
    """Print all the known commands and their bindings, if any."""
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = f"{pane} " if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es_print('', ''.join(lines), tabName=tabName)
#@+node:ekr.20061031131434.127: *9* k.simulateCommand
def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
#@+node:ekr.20061031131434.124: *9* k.toggle-input-state
@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    """The toggle-input-state command."""
    k = self; c = k.c
    default = c.config.getString('top-level-unbound-key-action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command'  # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
#@+node:ekr.20200519035912.1: *8* One kwarg besides event
#@+node:ekr.20061031131434.31: *9* ac.insert_string
def insert_string(self, s, select=False):
    """Insert s at the insertion point."""
    c = self.c
    w = self.w
    if not g.isTextWrapper(w):  # Bug fix: 2016/10/29.
        return
    c.widgetWantsFocusNow(w)
    i = w.getInsertPoint()
    w.insert(i, s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i, j, insert=j)
    c.frame.body.onBodyChanged('Typing')
    if self.use_qcompleter:
        if self.qw:
            c.widgetWantsFocusNow(self.qw.leo_qc)
#@+node:ekr.20140816165728.18965: *9* ga.do_back_space (entry)
# Called from k.fullCommand: with defaultTabList = list(c.commandsDict.keys())

def do_back_space(self, tabList, completion=True):
    """Handle a backspace and update the completion list."""
    k = self.k
    self.tabList = tabList[:] if tabList else []
    # Update the label.
    w = k.w
    i, j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if ins > len(k.mb_prefix):
        # Step 1: actually delete the character.
        i, j = w.getSelectionRange()
        if i == j:
            ins -= 1
            w.delete(ins)
            w.setSelectionRange(ins, ins, insert=ins)
        else:
            ins = i
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=ins)
    if w.getAllText().strip():
        junk, tabList = self.compute_tab_list(self.tabList)
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    if completion:
        # #323.
        common_prefix, tabList = self.compute_tab_list(tabList)
        self.show_tab_list(tabList)
        self.reset_tab_cycling()
#@+node:ekr.20140817110228.18323: *9* ga.do_tab (entry) & helpers
# Used by ga.get_arg and k.fullCommand.

def do_tab(self, tabList, completion=True):
    """Handle tab completion when the user hits a tab."""
    c = self.c
    if completion:
        tabList = self.tabList = tabList[:] if tabList else []
        common_prefix, tabList = self.compute_tab_list(tabList)
        if self.cycling_prefix and not self.cycling_prefix.startswith(common_prefix):
            self.cycling_prefix = common_prefix
        #
        # No tab cycling for completed commands having
        # a 'tab_callback' attribute.
        if len(tabList) == 1 and self.do_tab_callback():
            return
        # #323: *Always* call ga.do_tab_list.
        self.do_tab_cycling(common_prefix, tabList)
    c.minibufferWantsFocus()
#@+node:ekr.20140818145250.18235: *10* ga.do_tab_callback
def do_tab_callback(self):
    """
    If the command-name handler has a tab_callback,
    call handler.tab_callback() and return True.
    """
    c, k = self.c, self.k
    commandName, tail = k.getMinibufferCommandName()
    handler = c.commandsDict.get(commandName)
    if hasattr(handler, 'tab_callback'):
        self.reset_tab_cycling()
        k.functionTail = tail
            # For k.getFileName.
        handler.tab_callback()
        return True
    return False
#@+node:ekr.20140819050118.18317: *10* ga.do_tab_cycling
def do_tab_cycling(self, common_prefix, tabList):
    """Put the next (or first) completion in the minibuffer."""
    s = self.get_label()
    if not common_prefix:
        # Leave the minibuffer as it is.
        self.show_tab_list(tabList)
    # #323.
    elif (
        self.cycling_prefix and
        s.startswith(self.cycling_prefix) and
        sorted(self.cycling_tabList) == sorted(tabList)  # Bug fix: 2016/10/14
    ):
        n = self.cycling_index
        n = self.cycling_index = n + 1 if n + 1 < len(self.cycling_tabList) else 0
        self.set_label(self.cycling_tabList[n])
        self.show_tab_list(self.cycling_tabList)
    else:
        # Restart.
        self.show_tab_list(tabList)
        self.cycling_tabList = tabList[:]
        self.cycling_prefix = common_prefix
        self.set_label(common_prefix)
        if tabList and common_prefix == tabList[0]:
            self.cycling_index = 0
        else:
            self.cycling_index = -1
#@+node:ekr.20140819050118.18318: *10* ga.reset_tab_cycling
def reset_tab_cycling(self):
    """Reset all tab cycling ivars."""
    self.cycling_prefix = None
    self.cycling_index = -1
    self.cycling_tabList = []
#@+node:ekr.20061031131434.97: *9* k.completeAllBindings
def completeAllBindings(self, w=None):
    """
    Make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.
    """
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
#@+node:ekr.20061031170011.5: *9* k.getLabel
def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix) :]
    return s or ''
#@+node:ekr.20061031131434.198: *9* k.inState
def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    return k.state.kind and k.state.n is not None
#@+node:ekr.20080408060320.791: *9* k.killLine
def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
#@+node:ekr.20061031131434.191: *9* k.prettyPrintKey
def prettyPrintKey(self, stroke, brief=False):

    if not stroke:
        return ''
    if not g.assert_is(stroke, g.KeyStroke):
        return stroke
    return stroke.prettyPrint()
#@+node:ekr.20061031131434.82: *9* k.setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    defaultAction = c.config.getString('top-level-unbound-key-action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace(f"ignoring top_level_unbound_key_action setting: {defaultAction}")
        self.unboundKeyAction = 'insert'
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
#@+node:ekr.20061031131434.133: *9* k.setInputState
def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
#@+node:ekr.20061031170011.8: *9* k.setLabel
def setLabel(self, s, protect=False):
    """Set the label of the minibuffer."""
    c, k, w = self.c, self, self.w
    if w:
        # Support for the curses gui.
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            g.app.gui.set_minibuffer_label(c, s)
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
#@+node:ekr.20061031170011.10: *9* k.setLabelBlue
def setLabelBlue(self, label, protect=True):
    """Set the minibuffer label."""
    k, w = self, self.w
    if hasattr(g.app.gui, 'set_minibuffer_label'):
        g.app.gui.set_minibuffer_label(self.c, label)
    elif w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
#@+node:ekr.20061031170011.11: *9* k.setLabelGrey
def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@+node:ekr.20061031131434.199: *9* k.setState
def setState(self, kind, n, handler=None):

    k = self
    if kind and n is not None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
    # k.showStateAndMode()
#@+node:ekr.20200519082804.1: *8* More than one arg
#@+node:ekr.20080510153327.2: *9* k.setLabelRed
def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
#@+node:ekr.20061031131434.192: *9* k.showStateAndMode
def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    """Show the state and mode at the start of the minibuffer."""
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui:
        return
    if not w:
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            pass  # we don't need w
        else:
            w = g.app.gui.get_focus(c)
            if not w:
                return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w)  # A benign hack.
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = f"{mode.capitalize()} Mode"
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = f"{state.capitalize()} State"
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
#@+node:ekr.20140816165728.18968: *9* Wrappers for GetArg methods
# New in Leo 5.4

def getNextArg(self, handler):
    """
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    """
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    self.c.minibufferWantsFocusNow()

# New in Leo 5.4

def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << docstring for k.get1arg >>
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    """Convenience method mapping k.getArg to ga.get_arg."""
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    """Convenience method mapping k.doBackSpace to ga.do_back_space."""
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    """Convenience method mapping k.doTabCompletion to ga.do_tab."""
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    """
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    """
    return self.getArgInstance.get_minibuffer_command_name()
#@+node:ekr.20161020031633.1: *10* << docstring for k.get1arg >>
"""
k.get1Arg: Handle the next character the user types when accumulating
a user argument from the minibuffer. Ctrl-G will abort this processing
at any time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.

Example 1: get one argument from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

Example 2: get two arguments from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.extendLabel(' second prompt: ', select=False, protect=True)
        k.getNextArg(handler=self.myCommand2)

    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

k.get1Arg and k.getNextArg are a convenience methods. They simply pass
their arguments to the get_arg method of the singleton GetArg
instance. This docstring describes k.get1arg and k.getNextArg as if
they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n,
handler) though they aren't represented that way. When the state
machine in the GetArg class is active, the kind is 'getArg'. This
constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
#@+node:ekr.20200519035648.1: *7* More than one kwarg
#@+node:ekr.20140816165728.18952: *8* ga.__init__
def __init__(self, c, prompt='full-command: ', tabName='Completion'):
    """Ctor for GetArg class."""
    # Common ivars.
    self.c = c
    self.k = c.k
    assert c
    assert c.k
    self.log = c.frame.log or g.NullObject()
    self.tabName = tabName
    # State vars.
    self.after_get_arg_state = None, None, None
    self.arg_completion = True
    self.handler = None
    self.tabList = []
    # Tab cycling ivars...
    self.cycling_prefix = None
    self.cycling_index = -1
    self.cycling_tabList = []
    # The following are k globals.
        # k.arg.
        # k.argSelectedText
        # k.oneCharacterArg
#@+node:ekr.20061031131434.89: *8* k.bindKey & helpers
def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    """
    Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict
    and k.bindingsDict.

    tag gives the source of the binding.
    
    Return True if the binding was made successfully.
    """
    k = self
    if not shortcut:
        # Don't use this method to undo bindings.
        return False
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            assert shortcut, g.callers()
            stroke = g.KeyStroke(binding=shortcut)
        bi = g.BindingInfo(
            kind=tag,
            pane=pane,
            func=callback,
            commandName=commandName,
            stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, bi)
                # Updates k.masterBindingsDict
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(bi)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
        return True
    except Exception:  # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey  # For compatibility
#@+node:ekr.20120130074511.10228: *9* k.check_bind_key
def check_bind_key(self, commandName, pane, stroke):
    """
    Return True if the binding of stroke to commandName for the given
    pane can be made.
    """
    # k = self
    assert g.isStroke(stroke)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if stroke.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', f"{commandName} = {stroke}")
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', stroke, commandName, g.callers())
        return False
    return True
#@+node:ekr.20120130074511.10227: *9* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    """
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    """
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDict(  # was TypedDictOfLists.
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.BindingInfo,
        )
    inv_d = lm.invert(d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *9* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):

    k = self
    result = []
    for bi in aList:
        if pane in ('button', 'all', bi.pane):
            k.kill_one_shortcut(shortcut)
        else:
            result.append(bi)
    return result
#@+node:ekr.20061031131434.93: *9* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, bi):
    """Update k.masterBindingsDict for the stroke."""
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = bi
    k.masterBindingsDict[pane] = d
#@+node:ekr.20061031131434.94: *9* k.bindOpenWith
def bindOpenWith(self, d):
    """Register an open-with command."""
    k = self; c = k.c
    shortcut = d.get('shortcut') or ''
    name = d.get('name')
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = f"open-with-{name.lower()}"
    k.registerCommand(
        allowBinding=True,
        commandName=commandName,
        func=openWithCallback,
        pane='all',
        shortcut=shortcut,
    )
#@+node:ekr.20061031170011.9: *8* k.extendLabel
def extendLabel(self, s, select=False, protect=False):

    k = self; c = k.c; w = self.w
    if not (w and s):
        return
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
#@+node:ekr.20140813052702.18203: *8* k.getFileName
def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    """Get a file name from the minibuffer."""
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
#@+node:ekr.20200524135621.1: *6* ----- recent
#@+node:ekr.20061031131434.9: *7* ac.autoComplete
@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
#@+node:ekr.20061031131434.13: *7* ac.showCalltips
@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
#@+node:ekr.20031218072017.2817: *7* c.doCommand
command_count = 0

def doCommand(self, command_func, command_name, event):
    """
    Execute the given command function, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the
    command func if g.doHook("command1") returns False. This provides a
    simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # New in Leo 6.2. Set command_function and command_name ivars.
    self.command_function = command_func
    self.command_name = command_name
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return None
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True
        g.error('ignoring command: already executing a command.')
        return None
    g.app.commandInterruptFlag = False
    if not g.doHook("command1", c=c, p=p, label=command_name):
        try:
            c.inCommand = True
            try:
                return_value = command_func(event)
            except Exception:
                g.es_exception()
                return_value = None
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                ## c.k.funcReturn = return_value
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=command_name)
    return return_value
#@+node:ekr.20171123135625.30: *7* c_ec.indentBody (indent-region)
@g.commander_command('indent-region')
def indentBody(self, event=None):
    """
    The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.
    """
    c, undoType = self, 'Indent Region'
    w = c.frame.body.wrapper
    sel_1, sel_2 = w.getSelectionRange()
    # New in Leo 6.3.
    if sel_1 == sel_2:
        c.editCommands.selfInsertCommand(event)
        return
    ins = w.getInsertPoint()
    tab_width = c.getTabWidth(c.p)
    head, lines, tail, oldSel, oldYview = self.getBodyLines()
    changed, result = False, []
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line, 0, tab_width)
        s = g.computeLeadingWhitespace(width + abs(tab_width), tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)
    if changed:
        # Leo 5.6: preserve insert point.
        preserveSel = sel_1 == sel_2
        if preserveSel:
            ins += tab_width
            oldSel = ins, ins
        result = ''.join(result)
        c.updateBodyPane(head, result, tail, undoType, oldSel, oldYview, preserveSel)
#@+node:ekr.20150514063305.268: *7* ec.selfInsertCommand, helpers
# @cmd('self-insert-command')

def selfInsertCommand(self, event, action='insert'):
    """
    Insert a character in the body pane.

    This is the default binding for all keys in the body pane.
    It handles undo, bodykey events, tabs, back-spaces and bracket matching.
    """
    c, p = self.c, self.c.p
    w = self.editWidget(event)
    if not w:
        return
    << set local vars >>
    assert g.isStrokeOrNone(stroke)
    if g.doHook("bodykey1", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType):
        return
    if ch == '\t':
        self.updateTab(p, w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key.
        self.backwardDeleteCharacter(event)
    elif ch in ('\r', '\n'):
        ch = '\n'
        self.insertNewlineHelper(w, oldSel, undoType)
    elif ch in '\'"' and c.config.getBool('smart-quotes'):
        self.doSmartQuote(action, ch, oldSel, w)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p, w, ch, oldSel)
    elif ch:
        # Null chars must not delete the selection.
        self.doPlainChar(action, ch, event, inBrackets, oldSel, stroke, w)
    else:
        return
    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w, spot)
    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if changed:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel, oldText=oldText, oldYview=None)
    g.doHook("bodykey2", c=c, p=p, ch=ch, oldSel=oldSel, undoType=undoType)
#@+node:ekr.20150514063305.269: *8* << set local vars >> (selfInsertCommand)
stroke = event.stroke if event else None
ch = event.char if event else ''
if ch == 'Return':
    ch = '\n'  # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel = w.getSelectionRange() if name.startswith('body') else (None, None)
oldText = p.b if name.startswith('body') else ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.checkUnicode(ch) in brackets
#@+node:ekr.20160924135613.1: *8* ec.doPlainChar
def doPlainChar(self, action, ch, event, inBrackets, oldSel, stroke, w):
    c, p = self.c, self.c.p
    isPlain = stroke.find('Alt') == -1 and stroke.find('Ctrl') == -1
    i, j = oldSel
    if i > j: i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j: w.delete(i, j)
    elif action == 'overwrite': w.delete(i)
    if isPlain:
        ins = w.getInsertPoint()
        if self.autojustify > 0 and not inBrackets:
            # Support #14: auto-justify body text.
            s = w.getAllText()
            i = g.skip_to_start_of_line(s, ins)
            i, j = g.getLine(s, i)
            # Only insert a newline at the end of a line.
            if j - i >= self.autojustify and (ins >= len(s) or s[ins] == '\n'):
                # Find the start of the word.
                n = 0
                ins -= 1
                while ins - 1 > 0 and g.isWordChar(s[ins - 1]):
                    n += 1
                    ins -= 1
                sins = ins  # start of insert, to collect trailing whitespace
                while sins > 0 and s[sins - 1] in (' \t'):
                    sins -= 1
                oldSel = (sins, ins)
                self.insertNewlineHelper(w, oldSel, undoType=None)
                ins = w.getInsertPoint()
                ins += (n + 1)
        w.insert(ins, ch)
        w.setInsertPoint(ins + 1)
    else:
        g.app.gui.insertKeyEvent(event, i)
    if inBrackets and self.flashMatchingBrackets:
        self.flashMatchingBracketsHelper(c, ch, i, p, w)
#@+node:ekr.20150514063305.270: *8* ec.doPlainTab
def doPlainTab(self, s, i, tab_width, w):
    """Insert spaces equivalent to one tab."""
    start, end = g.getLine(s, i)
    s2 = s[start:i]
    width = g.computeWidth(s2, tab_width)
    if tab_width > 0:
        w.insert(i, '\t')
        ins = i + 1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i, ' ' * n)
        ins = i + n
    w.setSelectionRange(ins, ins, insert=ins)
#@+node:ekr.20180806045802.1: *8* ec.doSmartQuote
def doSmartQuote(self, action, ch, oldSel, w):
    """Convert a straight quote to a curly quote, depending on context."""
    i, j = oldSel
    if i > j:
        i, j = j, i
    # Use raw insert/delete to retain the coloring.
    if i != j:
        w.delete(i, j)
    elif action == 'overwrite':
        w.delete(i)
    ins = w.getInsertPoint()
    # Pick the correct curly quote.
    s = w.getAllText() or ""
    i2 = g.skip_to_start_of_line(s, max(0, ins - 1))
    open_curly = ins == i2 or ins > i2 and s[ins - 1] in ' \t'
        # not s[ins-1].isalnum()
    if open_curly:
        ch = '‘' if ch == "'" else "“"
    else:
        ch = '’' if ch == "'" else "”"
    w.insert(ins, ch)
    w.setInsertPoint(ins + 1)
#@+node:ekr.20150514063305.271: *8* ec.flashCharacter
def flashCharacter(self, w, i):
    """Flash the character at position i of widget w."""
    bg = self.bracketsFlashBg or 'DodgerBlue1'
    fg = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay = self.bracketsFlashDelay or 75
    w.flashCharacter(i, bg, fg, flashes, delay)
#@+node:ekr.20150514063305.272: *8* ec.flashMatchingBracketsHelper
def flashMatchingBracketsHelper(self, c, ch, i, p, w):
    """Flash matching brackets at char ch at position i at widget w."""
    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d[self.openBracketsList[z]] = self.closeBracketsList[z]
        # reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d[self.closeBracketsList[z]] = self.openBracketsList[z]
        # reverse = True # Search backward
    s = w.getAllText()
    # A partial fix for bug 127: Bracket matching is buggy.
    language = g.getLanguageAtPosition(c, p)
    if language == 'perl':
        return
    j = g.MatchBrackets(c, p, language).find_matching_bracket(ch, s, i)
    if j is not None:
        self.flashCharacter(w, j)
#@+node:ekr.20150514063305.273: *8* ec.initBracketMatcher
def initBracketMatcher(self, c):
    """Init the bracket matching code."""
    if len(self.openBracketsList) != len(self.closeBracketsList):
        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList = '([{'
        self.closeBracketsList = ')]}'
#@+node:ekr.20150514063305.274: *8* ec.insertNewlineHelper
def insertNewlineHelper(self, w, oldSel, undoType):

    c, p = self.c, self.c.p
    i, j = oldSel
    ch = '\n'
    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i, j)
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
    else:
        w.insert(i, ch)
        w.setInsertPoint(i + 1)
        if (c.autoindent_in_nocolor or
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p, w)
    w.seeInsertPoint()
#@+node:ekr.20150514063305.275: *8* ec.updateAutoIndent
def updateAutoIndent(self, p, w):
    """Handle auto indentation."""
    c = self.c
    tab_width = c.getTabWidth(p)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s, ins)
    i, j = g.getLine(s, i - 1)
    s = s[i : j - 1]
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s, 0, tab_width)
    if s and s[-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c, p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width]
        tabex = 0
        for i, ch in enumerate(s):
            if ch == '\t':
                tabex += tab_width - 1
            if ch in '([{':
                bracketWidths.append(i + tabex + 1)
            elif ch in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width, tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i, ws)
        w.setInsertPoint(i + len(ws))
        w.seeInsertPoint()
            # 2011/10/02: Fix cursor-movement bug.
#@+node:ekr.20150514063305.276: *8* ec.updateAutomatchBracket
def updateAutomatchBracket(self, p, w, ch, oldSel):

    c = self.c
    d = c.scanAllDirectives(p)
    i, j = oldSel
    language = d.get('language')
    s = w.getAllText()
    if ch in ('(', '[', '{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(': ')', '[': ']', '{': '}'}.get(ch)
        if i != j: w.delete(i, j)
        w.insert(i, ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins - 1)
    else:
        ins = w.getInsertPoint()
        ch2 = s[ins] if ins < len(s) else ''
        if ch2 in (')', ']', '}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins + 1)
        else:
            if i != j: w.delete(i, j)
            w.insert(i, ch)
            w.setInsertPoint(i + 1)
#@+node:ekr.20150514063305.277: *8* ec.updateTab
def updateTab(self, p, w, smartTab=True):
    """Add spaces equivalent to a tab."""
    c = self.c
    i, j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.
    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        tab_width = c.getTabWidth(p)
        # Get the preceeding characters.
        s = w.getAllText()
        start, end = g.getLine(s, i)
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        if doSmartTab:
            self.updateAutoIndent(p, w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s, i, tab_width, w)
        else:
            self.doPlainTab(s, i, tab_width, w)
#@+node:ekr.20200517130352.1: *6* ----- changed & new
#@+node:ekr.20061031131434.9: *7* ac.autoComplete
@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
#@+node:ekr.20061031131434.13: *7* ac.showCalltips
@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
#@+node:ekr.20031218072017.2817: *7* c.doCommand
command_count = 0

def doCommand(self, command_func, command_name, event):
    """
    Execute the given command function, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the
    command func if g.doHook("command1") returns False. This provides a
    simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # New in Leo 6.2. Set command_function and command_name ivars.
    self.command_function = command_func
    self.command_name = command_name
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return None
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True
        g.error('ignoring command: already executing a command.')
        return None
    g.app.commandInterruptFlag = False
    if not g.doHook("command1", c=c, p=p, label=command_name):
        try:
            c.inCommand = True
            try:
                return_value = command_func(event)
            except Exception:
                g.es_exception()
                return_value = None
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                ## c.k.funcReturn = return_value
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=command_name)
    return return_value
#@+node:ekr.20200522075411.1: *7* c.doCommandByName
def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
#@+node:ekr.20200523135601.1: *7* c.insertCharFromEvent
def insertCharFromEvent(self, event):
    """
    Handle the character given by event *without*
    executing any command that might be bound to it.
    
    What happens depends on which widget has focus.
    """
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
#@+node:ekr.20140817110228.18317: *7* ga.do_state_zero
def do_state_zero(self, completion, event, handler, oneCharacter,
    returnKind, returnState, tabList, useMinibuffer
):
    """Do state 0 processing."""
    c, k = self.c, self.k
    #
    # Set the ga globals...
    k.getArgEscapeFlag = False
    self.after_get_arg_state = returnKind, returnState, handler
    self.arg_completion = completion
    self.cycling_prefix = None
    self.handler = handler
    self.tabList = tabList[:] if tabList else []
    #
    # Set the k globals...
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    #
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg', 1, k.getArg)
    # pylint: disable=consider-using-ternary
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
#@+node:ekr.20061031131434.78: *7* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
#@+node:ekr.20180418114300.1: *7* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:ekr.20061031131434.130: *7* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
#@+node:ekr.20061031131434.146: *7* k.masterKeyHandler & helpers
def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    c, k = self.c, self
    # Setup...
    if 'keys' in g.app.debug:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    c.insertCharFromEvent(event)
#@+node:ekr.20200524151214.1: *8* Setup...
#@+node:ekr.20180418040158.1: *9* k.checkKeyEvent
def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
#@+node:ekr.20180418034305.1: *9* k.setEventWidget
def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
#@+node:ekr.20180418031417.1: *9* k.traceVars
def traceVars(self, event):

    trace = False and not g.unitTesting
    traceGC = False
    verbose = False
    k = self
    if not trace:
        return
    if traceGC:
        g.printNewObjects('masterKey 1')
    if verbose:
        char = event.char
        state = k.state.kind
        stroke = event.stroke
        g.trace(
            f"stroke: {stroke!r}, "
            f"char: {char!r}, "
            f"state: {state}, "
            f"state2: {k.unboundKeyAction}")
#@+node:ekr.20180418031118.1: *8* 1. k.isSpecialKey
def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) > 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
#@+node:ekr.20110609161752.16459: *8* 2. k.setLossage
def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
#@+node:ekr.20180418024449.1: *8* 3. k.doKeyboardQuit
def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
#@+node:ekr.20180418023827.1: *8* 4. k.doDemo
def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
#@+node:ekr.20091230094319.6244: *8* 5. k.doMode & helpers
def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        return val != 'do-standard-keys'
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    return True
#@+node:ekr.20061031131434.108: *9* k.callStateFunction
def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) < 32 or ord(ch) > 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
#@+node:ekr.20061031131434.152: *9* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
#@+node:ekr.20180418114300.1: *10* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:vitalije.20170708161511.1: *9* k.handleInputShortcut
def handleInputShortcut(self, event, stroke):
    c, k, p = self.c, self, self.c.p
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = c.undoer.beforeChangeNodeContents(p)
        w.setSelectionAreas(before, sel, after)
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        w.onBodyChanged('change shortcut')
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = c.undoer.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
#@+node:vitalije.20170709151653.1: *10* k.isInShortcutBodyLine
_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
#@+node:vitalije.20170709151658.1: *10* k.isEditShortcutSensible
def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
#@+node:vitalije.20170709202924.1: *10* k.editShortcut_do_bind_helper
def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
#@+node:ekr.20180418025241.1: *8* 6. k.doVim
def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    c = self.c
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        return ok
    return False
#@+node:ekr.20180418033838.1: *8* 7. k.doBinding & helpers
def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    c, k = self.c, self
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event.stroke, event.w)
    #
    # #327: ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
#@+node:ekr.20091230094319.6240: *9* k.getPaneBinding & helper
def getPaneBinding(self, stroke, w):

    k = self
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        val = k.getBindingHelper(key, name, stroke, w)
        if val:
            return val
    return None
#@+node:ekr.20180418105228.1: *10* getPaneBindingHelper
def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
#@+node:ekr.20160409035115.1: *9* k.searchTree
def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
#@+node:ekr.20061031131434.127: *7* k.simulateCommand
def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
#@+node:ekr.20190926103141.1: *7* lineScrollHelper
# by Brian Theado.

def lineScrollHelper(c, prefix1, prefix2, suffix):
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    c.inCommand = False
    c.k.simulateCommand(prefix1 + 'line' + suffix)
    ins2 = w.getInsertPoint()
    # If the cursor didn't change, then go to beginning/end of line
    if ins == ins2:
        c.k.simulateCommand(prefix2 + 'of-line' + suffix)
#@+node:ekr.20200725105311.1: *6* git diff revs: 4b8320485c0 2507a1fcc70
@ignore
@nosearch
#@+node:ekr.20200725110953.1: *7* changed
#@+node:ekr.20200725105318.47: *8* leo/core/leoAtFile.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -98,7 +98,7 @@
         at.startSentinelComment = ""
         at.tab_width = c.tab_width or -4
         at.writing_to_shadow_directory = False
-    #@+node:ekr.20041005105605.13: *4* at.initReadIvars (changed)
+    #@+node:ekr.20041005105605.13: *4* at.initReadIvars
     def initReadIvars(self, root, fileName,
         importFileName=None,
         perfectImportRoot=None,
@@ -166,6 +166,7 @@
         atShadow=False,
         defaultDirectory=None,
         forcePythonSentinels=False,
+        kind=None,
         sentinels=True,
     ):
         """
@@ -179,6 +180,7 @@
         assert at.underindentEscapeString is not None
         #
         # Copy args
+        at.kind = kind
         at.atEdit = atEdit
             # Used only by putBody.
         at.atShadow = atShadow
@@ -324,7 +326,7 @@
         # This method is the gateway to the shadow algorithm.
         x.updatePublicAndPrivateFiles(at.root, fn, shadow_fn)
         return shadow_fn
-    #@+node:ekr.20041005105605.21: *5* at.read & helpers (changed)
+    #@+node:ekr.20041005105605.21: *5* at.read & helpers
     def read(self, root, importFileName=None,
         fromString=None, atShadow=False, force=False
     ):
@@ -559,9 +561,9 @@
     def readOneAtAutoNode(self, fileName, p):
         '''Read an @auto file into p. Return the *new* position.'''
         at, c, ic = self, self.c, self.c.importCommands
-        at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-        at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-        fileName = g.os_path_finalize_join(at.default_directory, fileName)  # #1341.
+        # #1521 & #1341.
+        fileName = g.fullPath(c, p)
+        at.default_directory = g.os_path_dirname(fileName)
         if not g.os_path_exists(fileName):
             g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
             return p
@@ -604,9 +606,9 @@
         at = self
         c = at.c
         ic = c.importCommands
-        at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-        at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-        fn = g.os_path_finalize_join(at.default_directory, fn)  # #1341.
+        # #1521
+        fn = g.fullPath(c, p)
+        at.default_directory = g.os_path_dirname(fn)
         junk, ext = g.os_path_splitext(fn)
         # Fix bug 889175: Remember the full fileName.
         at.rememberReadPath(fn, p)
@@ -633,9 +635,9 @@
     def readOneAtAsisNode(self, fn, p):
         '''Read one @asis node. Used only by refresh-from-disk'''
         at, c = self, self.c
-        at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-        at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-        fn = g.os_path_finalize_join(at.default_directory, fn)  # #1341.
+        # #1521 & #1341.
+        fn = g.fullPath(c, p)
+        at.default_directory = g.os_path_dirname(fn)
         junk, ext = g.os_path_splitext(fn)
         # Remember the full fileName.
         at.rememberReadPath(fn, p)
@@ -722,12 +724,11 @@
                 f"can not happen: fn: {fn} != atShadowNodeName: "
                 f"{p.atShadowFileNodeName()}")
             return
-        # Fix bug 889175: Remember the full fileName.
-        fn = c.expand_path_expression(fn)  # #1341.
+        # #1521 & #1341.
+        fn = g.fullPath(c, p)
+        at.default_directory = g.os_path_dirname(fn)
+        # #889175: Remember the full fileName.
         at.rememberReadPath(fn, p)
-        at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-        at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-        fn = g.os_path_finalize_join(at.default_directory, fn)
         shadow_fn = x.shadowPathName(fn)
         shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
         # Delete all children.
@@ -736,7 +737,6 @@
         if shadow_exists:
             at.read(p, atShadow=True, force=force)
         else:
-            # if not g.unitTesting: g.es("reading:", p.h)
             ok = at.importAtShadowNode(fn, p)
             if ok:
                 # Create the private file automatically.
@@ -920,8 +920,7 @@
             s = at.read_lines[at.read_i]
             at.read_i += 1
             return s
-        return ''
-            # Not an error.
+        return ''  # Not an error.
#@verbatim
     #@+node:ekr.20041005105605.129: *5* at.scanHeader
     def scanHeader(self, fileName, giveErrors=True):
         """
@@ -1195,20 +1194,21 @@
         elif p.isAtAutoNode():
             at.writeOneAtAutoNode(p)
             # Do *not* clear the dirty bits the entries in @persistence tree here!
-        elif p.isAtCleanNode() or p.isAtNoSentFileNode():
-            at.write(p, sentinels=False)
+        elif p.isAtCleanNode():
+            at.write('@clean', p, sentinels=False)
+        elif p.isAtNoSentFileNode():
+            at.write('@nosent', p, sentinels=False)
         elif p.isAtEditNode():
             at.writeOneAtEditNode(p)
         elif p.isAtShadowFileNode():
             at.writeOneAtShadowNode(p)
         elif p.isAtThinFileNode() or p.isAtFileNode():
-            at.write(p)
+            at.write('@file', p)
         #
         # Clear the dirty bits in all descendant nodes.
         # The persistence data may still have to be written.
         for p2 in p.self_and_subtree(copy=False):
             p2.v.clearDirty()
-
#@verbatim
     #@+node:ekr.20190108105509.1: *7* at.writePathChanged
     def writePathChanged(self, p):
         '''
@@ -1221,9 +1221,9 @@
             return
         oldPath = g.os_path_normcase(at.getPathUa(p))
         newPath = g.os_path_normcase(g.fullPath(c, p))
-        try:  # #1367: samefile can throw IOError!
+        try:  # #1367: samefile can throw an exception.
             changed = oldPath and not os.path.samefile(oldPath, newPath)
-        except IOError:
+        except Exception:
             changed = True
         if not changed:
             return
@@ -1237,7 +1237,6 @@
         if not ok:
             raise IOError
         at.setPathUa(p, newPath)  # Remember that we have changed paths.
-
#@verbatim
     #@+node:ekr.20190109172025.1: *5* at.writeAtAutoContents
     def writeAtAutoContents(self, fileName, root):
         '''Common helper for atAutoToString and writeOneAtAutoNode.'''
@@ -1313,7 +1312,7 @@
         if s:
             put(s)
#@verbatim
     #@+node:ekr.20041005105605.144: *6* at.write
-    def write(self, root, sentinels=True):
+    def write(self, kind, root, sentinels=True):
         """Write a 4.x derived file.
         root is the position of an @<file> node.
         sentinels will be False for @clean and @nosent nodes.
@@ -1322,7 +1321,7 @@
         try:
             c.endEditing()
             fileName = at.initWriteIvars(
-                root, root.anyAtFileNodeName(), sentinels=sentinels)
+                root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
             if not fileName or not at.precheck(fileName, root):
                 if sentinels:
                     # Raise dialog warning of data loss.
@@ -1385,9 +1384,9 @@
         if p.isAtAsisFileNode():
             at.asisWrite(p)
         elif p.isAtNoSentFileNode():
-            at.write(p, sentinels=False)
+            at.write('@nosent', p, sentinels=False)
         elif p.isAtFileNode():
-            at.write(p)
+            at.write('@file', p)
         elif p.isAtAutoNode() or p.isAtAutoRstNode():
             g.es('Can not write missing @auto node', p.h, color='red')
         else:
@@ -1549,9 +1548,10 @@
             at.initWriteIvars(root, None,
                 atShadow=True,
                 defaultDirectory=g.os_path_dirname(full_path),
-                forcePythonSentinels=True)
+                forcePythonSentinels=True,
                     # Force python sentinels to suppress an error message.
                     # The actual sentinels will be set below.
+            )
             at.default_directory = g.os_path_dirname(full_path)
                 # Override.
             # Make sure we can compute the shadow directory.
@@ -1702,8 +1702,12 @@
         at, c = self, self.c
         try:
             c.endEditing()
-            at.initWriteIvars(root, "<string-file>",
-                forcePythonSentinels=forcePythonSentinels, sentinels=sentinels)
+            at.initWriteIvars(
+                root,
+                targetFileName="<string-file>",
+                forcePythonSentinels=forcePythonSentinels,
+                sentinels=sentinels,
+            )
             at.openOutputStream()
             at.putFile(root, fromString=s, sentinels=sentinels)
             result = at.closeOutputStream()
@@ -1985,10 +1989,18 @@
         # Write the lead-in sentinel only once.
         at.putLeadInSentinel(s, i, n1, delta)
         self.putRefAt(name, ref, delta)
+        n_refs = 0
         while 1:
             progress = i
             i = n2
+            n_refs += 1
             name, n1, n2 = at.findSectionName(s, i)
+            if self.kind == '@clean' and n_refs > 1:
+                # #1232: allow only one section reference per line in @clean.
+                i1, i2 = g.getLine(s, i)
+                line = s[i1:i2].rstrip()
+                at.writeError(f"Too many section references:\n{line!s}")
+                break
             if name:
                 ref = at.findReference(name, p)
                     # Issues error if not found.
@@ -1996,7 +2008,8 @@
                     middle_s = s[i:n1]
                     self.putAfterMiddleRef(middle_s, delta)
                     self.putRefAt(name, ref, delta)
-            else: break
+            else:
+                break
             assert progress < i
         self.putAfterLastRef(s, i, delta)
#@verbatim
     #@+node:ekr.20131224085853.16443: *7* at.findReference
@@ -2131,7 +2144,8 @@
         # Put the opening comment if we are using block comments.
         if at.endSentinelComment:
             at.putIndent(at.indent)
-            at.os(at.startSentinelComment); at.onl()
+            at.os(at.startSentinelComment)
+            at.onl()
#@verbatim
     #@+node:ekr.20041005105605.187: *4* Writing sentinels...
#@verbatim
     #@+node:ekr.20041005105605.188: *5* at.nodeSentinelText & helper
     def nodeSentinelText(self, p):
@@ -3092,8 +3106,10 @@
             d = p.v.at_read
             for k in d:
                 # Fix bug # #1469: make sure k still exists.
-                if os.path.exists(
-                    k) and os.path.samefile(k, fn) and p.h in d.get(k, set()):
+                if (
+                    os.path.exists(k) and os.path.samefile(k, fn)
+                    and p.h in d.get(k, set())
+                ):
                     d[fn] = d[k]
                     if trace: g.trace('Return False: in p.v.at_read:', sfn)
                     return False
@@ -3103,8 +3119,7 @@
             return p.h not in aSet
         if trace:
             g.trace('Return True: never read:', sfn)
-        return True
-            # The file was never read.
+        return True  # The file was never read.
#@verbatim
     #@+node:ekr.20041005105605.20: *4* at.warnOnReadOnlyFile
     def warnOnReadOnlyFile(self, fn):
         # os.access() may not exist on all platforms.
@@ -3115,7 +3130,6 @@
         if read_only:
             g.error("read only:", fn)
#@verbatim
     #@-others
-
 atFile = AtFile  # compatibility
#@verbatim
 #@+node:ekr.20180602102448.1: ** class FastAtRead
 class FastAtRead:
@@ -3133,7 +3147,6 @@
         self.root = None
         self.VNode = TestVNode if test else leoNodes.VNode
         self.test = test
-
#@verbatim
     #@+others
#@verbatim
     #@+node:ekr.20180602103135.3: *3* fast_at.get_patterns
#@verbatim
     #@@nobeautify
@@ -3186,7 +3199,6 @@
         else:
             assert root_v.gnx in gnx2vnode, root_v
             assert root_v.gnx in gnx2body, root_v
-            # Don't use items(): it doesn't exist in Python 2.
             for key in gnx2body:
                 body = gnx2body.get(key)
                 v = gnx2vnode.get(key)
@@ -3317,6 +3329,7 @@
             g.printObj([v3.h for v3 in parent_v.children])
             print('PARENTS...')
             g.printObj([v4.h for v4 in v.parents])
+
#@verbatim
         #@-<< define dump_v >>
 
         i = 0  # To keep pylint happy.
@@ -3397,11 +3410,13 @@
                     body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
                     stack.append((gnx, indent, body))
                     indent += m.end(1)
-                else:
+                    continue
+                if stack:
+                    # #1232: Only if the stack exists.
                     # close sentinel.
                     # m.group(2) is '-' because the pattern matched.
                     gnx, indent, body = stack.pop()
-                continue
+                    continue
#@verbatim
             #@-<< 4. handle section refs >>
#@verbatim
             #@afterref
  # clears in_doc.
@@ -3716,7 +3731,6 @@
#@verbatim
     #@-others
#@verbatim
 #@+node:ekr.20200204092455.1: ** class TestAtFile
 class TestAtFile(unittest.TestCase):
-
#@verbatim
     #@+others
#@verbatim
     #@+node:ekr.20200204104247.1: *3* Helpers
#@verbatim
     #@+node:ekr.20200204095726.1: *4* TestAtFile.bridge
@@ -3775,7 +3789,6 @@
         assert p1.b == "b_1_changed\n", repr(p1.b)
#@verbatim
     #@-others
#@verbatim
 #@-others
-
 if __name__ == '__main__':
     unittest.main()
#@verbatim
 #@@language python
@language python
#@+node:ekr.20200725105318.54: *9* Changed
#@+node:ekr.20200725105318.61: *10* at.initWriteIvars
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -3,6 +3,7 @@
     atShadow=False,
     defaultDirectory=None,
     forcePythonSentinels=False,
+    kind=None,
     sentinels=True,
 ):
     """
@@ -16,6 +17,7 @@
     assert at.underindentEscapeString is not None
     #
     # Copy args
+    at.kind = kind
     at.atEdit = atEdit
         # Used only by putBody.
     at.atShadow = atShadow
@language python
#@+node:ekr.20200725105318.62: *11* Old:at.initWriteIvars
def initWriteIvars(self, root, targetFileName,
    atEdit=False,
    atShadow=False,
    defaultDirectory=None,
    forcePythonSentinels=False,
    sentinels=True,
):
    """
    Compute default values of all write-related ivars.
    Return the finalized name of the output file.
    """
    at, c = self, self.c
    assert root
    self.initCommonIvars()
    assert at.checkPythonCodeOnWrite is not None
    assert at.underindentEscapeString is not None
    #
    # Copy args
    at.atEdit = atEdit
        # Used only by putBody.
    at.atShadow = atShadow
    at.root = root
    at.sentinels = sentinels
    #
    # Override initCommonIvars.
    if forcePythonSentinels:
        at.endSentinelComment = None
        at.startSentinelComment = "#"
    if g.app.unitTesting:
        at.output_newline = '\n'
    #
    # Set other ivars.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force-newlines-in-at-nosent-bodies')
        # For at.putBody only.
    at.outputList = []
        # For stream output.
    at.targetFileName = targetFileName
        # For at.writeError only.
    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    #
    # Overrides of at.scanAllDirectives...
    if defaultDirectory:
        at.default_directory = defaultDirectory
    if at.language == 'python':
        # Encoding directive overrides everything else.
        encoding = g.getPythonEncodingFromString(root.b)
        if encoding:
            at.encoding = encoding
    #
    # Clean root.v.
    if not at.errors and at.root:
        if hasattr(at.root.v, 'tnodeList'):
            delattr(at.root.v, 'tnodeList')
        at.root.v._p_changed = True
    #
    # Return the finalized file name.
    # #1341 and #1450.
    make_dirs = c and c.config and c.config.create_nonexistent_directories
    if at.default_directory:
        at.default_directory = c.expand_path_expression(at.default_directory)
        if make_dirs:
            ok = g.makeAllNonExistentDirectories(at.default_directory)
            if not ok:
                g.error(f"Did not create default directory: {at.default_directory}")
                return None
    # #1341 and #1450.
    targetFileName = c.expand_path_expression(targetFileName)
    if targetFileName:
        theDir = g.os_path_dirname(targetFileName)
        if theDir and make_dirs:
            ok = g.makeAllNonExistentDirectories(theDir)
            if not ok:
                g.trace(f"Did not create {theDir} for {targetFileName}")
                return None
    # #1341.
    return g.os_path_realpath(
        g.os_path_finalize_join(at.default_directory, targetFileName))
#@+node:ekr.20041005105605.15: *11* at.initWriteIvars
def initWriteIvars(self, root, targetFileName,
    atEdit=False,
    atShadow=False,
    defaultDirectory=None,
    forcePythonSentinels=False,
    kind=None,
    sentinels=True,
):
    """
    Compute default values of all write-related ivars.
    Return the finalized name of the output file.
    """
    at, c = self, self.c
    assert root
    self.initCommonIvars()
    assert at.checkPythonCodeOnWrite is not None
    assert at.underindentEscapeString is not None
    #
    # Copy args
    at.kind = kind
    at.atEdit = atEdit
        # Used only by putBody.
    at.atShadow = atShadow
    at.root = root
    at.sentinels = sentinels
    #
    # Override initCommonIvars.
    if forcePythonSentinels:
        at.endSentinelComment = None
        at.startSentinelComment = "#"
    if g.app.unitTesting:
        at.output_newline = '\n'
    #
    # Set other ivars.
    at.force_newlines_in_at_nosent_bodies = c.config.getBool(
        'force-newlines-in-at-nosent-bodies')
        # For at.putBody only.
    at.outputList = []
        # For stream output.
    at.targetFileName = targetFileName
        # For at.writeError only.
    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    #
    # Overrides of at.scanAllDirectives...
    if defaultDirectory:
        at.default_directory = defaultDirectory
    if at.language == 'python':
        # Encoding directive overrides everything else.
        encoding = g.getPythonEncodingFromString(root.b)
        if encoding:
            at.encoding = encoding
    #
    # Clean root.v.
    if not at.errors and at.root:
        if hasattr(at.root.v, 'tnodeList'):
            delattr(at.root.v, 'tnodeList')
        at.root.v._p_changed = True
    #
    # Return the finalized file name.
    # #1341 and #1450.
    make_dirs = c and c.config and c.config.create_nonexistent_directories
    if at.default_directory:
        at.default_directory = c.expand_path_expression(at.default_directory)
        if make_dirs:
            ok = g.makeAllNonExistentDirectories(at.default_directory)
            if not ok:
                g.error(f"Did not create default directory: {at.default_directory}")
                return None
    # #1341 and #1450.
    targetFileName = c.expand_path_expression(targetFileName)
    if targetFileName:
        theDir = g.os_path_dirname(targetFileName)
        if theDir and make_dirs:
            ok = g.makeAllNonExistentDirectories(theDir)
            if not ok:
                g.trace(f"Did not create {theDir} for {targetFileName}")
                return None
    # #1341.
    return g.os_path_realpath(
        g.os_path_finalize_join(at.default_directory, targetFileName))
#@+node:ekr.20200725105318.65: *10* at.readOneAtAutoNode
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,9 +1,9 @@
 def readOneAtAutoNode(self, fileName, p):
     '''Read an @auto file into p. Return the *new* position.'''
     at, c, ic = self, self.c, self.c.importCommands
-    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-    fileName = g.os_path_finalize_join(at.default_directory, fileName)  # #1341.
+    # #1521 & #1341.
+    fileName = g.fullPath(c, p)
+    at.default_directory = g.os_path_dirname(fileName)
     if not g.os_path_exists(fileName):
         g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
         return p
@language python
#@+node:ekr.20200725105318.66: *11* Old:at.readOneAtAutoNode
def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
    fileName = g.os_path_finalize_join(at.default_directory, fileName)  # #1341.
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
#@+node:ekr.20070909100252: *11* at.readOneAtAutoNode
def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    # #1521 & #1341.
    fileName = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fileName)
    if not g.os_path_exists(fileName):
        g.error(f"not found: {p.h!r}", nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    # if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = ''  # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error(f"errors inhibited read @auto {fileName}")
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
#@+node:ekr.20200725105318.67: *10* at.readOneAtEditNode
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -2,9 +2,9 @@
     at = self
     c = at.c
     ic = c.importCommands
-    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-    fn = g.os_path_finalize_join(at.default_directory, fn)  # #1341.
+    # #1521
+    fn = g.fullPath(c, p)
+    at.default_directory = g.os_path_dirname(fn)
     junk, ext = g.os_path_splitext(fn)
     # Fix bug 889175: Remember the full fileName.
     at.rememberReadPath(fn, p)
@language python
#@+node:ekr.20200725105318.68: *11* Old:at.readOneAtEditNode
def readOneAtEditNode(self, fn, p):
    at = self
    c = at.c
    ic = c.importCommands
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
    fn = g.os_path_finalize_join(at.default_directory, fn)  # #1341.
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'): head = '@language html\n'
    elif ext in ('.txt', '.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = f"@language {language}\n"
        else:
            head = '@nocolor\n'
    p.b = head + g.toUnicode(s, encoding=encoding, reportErrors='True')
    g.doHook('after-edit', p=p)
#@+node:ekr.20090225080846.3: *11* at.readOneAtEditNode
def readOneAtEditNode(self, fn, p):
    at = self
    c = at.c
    ic = c.importCommands
    # #1521
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'): head = '@language html\n'
    elif ext in ('.txt', '.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = f"@language {language}\n"
        else:
            head = '@nocolor\n'
    p.b = head + g.toUnicode(s, encoding=encoding, reportErrors='True')
    g.doHook('after-edit', p=p)
#@+node:ekr.20200725105318.69: *10* at.readOneAtAsisNode
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,9 +1,9 @@
 def readOneAtAsisNode(self, fn, p):
     '''Read one @asis node. Used only by refresh-from-disk'''
     at, c = self, self.c
-    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-    fn = g.os_path_finalize_join(at.default_directory, fn)  # #1341.
+    # #1521 & #1341.
+    fn = g.fullPath(c, p)
+    at.default_directory = g.os_path_dirname(fn)
     junk, ext = g.os_path_splitext(fn)
     # Remember the full fileName.
     at.rememberReadPath(fn, p)
@language python
#@+node:ekr.20200725105318.70: *11* Old:at.readOneAtAsisNode
def readOneAtAsisNode(self, fn, p):
    '''Read one @asis node. Used only by refresh-from-disk'''
    at, c = self, self.c
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
    fn = g.os_path_finalize_join(at.default_directory, fn)  # #1341.
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not c.isChanged() and p.b != old_body:
        c.setChanged()
#@+node:ekr.20190201104956.1: *11* at.readOneAtAsisNode
def readOneAtAsisNode(self, fn, p):
    '''Read one @asis node. Used only by refresh-from-disk'''
    at, c = self, self.c
    # #1521 & #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    # if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not c.isChanged() and p.b != old_body:
        c.setChanged()
#@+node:ekr.20200725105318.71: *10* at.readOneAtShadowNode & helper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -6,12 +6,11 @@
             f"can not happen: fn: {fn} != atShadowNodeName: "
             f"{p.atShadowFileNodeName()}")
         return
-    # Fix bug 889175: Remember the full fileName.
-    fn = c.expand_path_expression(fn)  # #1341.
+    # #1521 & #1341.
+    fn = g.fullPath(c, p)
+    at.default_directory = g.os_path_dirname(fn)
+    # #889175: Remember the full fileName.
     at.rememberReadPath(fn, p)
-    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
-    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
-    fn = g.os_path_finalize_join(at.default_directory, fn)
     shadow_fn = x.shadowPathName(fn)
     shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
     # Delete all children.
@@ -20,7 +19,6 @@
     if shadow_exists:
         at.read(p, atShadow=True, force=force)
     else:
-        # if not g.unitTesting: g.es("reading:", p.h)
         ok = at.importAtShadowNode(fn, p)
         if ok:
             # Create the private file automatically.
@language python
#@+node:ekr.20200725105318.72: *11* Old:at.readOneAtShadowNode & helper
def readOneAtShadowNode(self, fn, p, force=False):

    at = self; c = at.c; x = c.shadowController
    if not fn == p.atShadowFileNodeName():
        at.error(
            f"can not happen: fn: {fn} != atShadowNodeName: "
            f"{p.atShadowFileNodeName()}")
        return
    # Fix bug 889175: Remember the full fileName.
    fn = c.expand_path_expression(fn)  # #1341.
    at.rememberReadPath(fn, p)
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    at.default_directory = c.expand_path_expression(at.default_directory)  # #1341.
    fn = g.os_path_finalize_join(at.default_directory, fn)
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    if shadow_exists:
        at.read(p, atShadow=True, force=force)
    else:
        # if not g.unitTesting: g.es("reading:", p.h)
        ok = at.importAtShadowNode(fn, p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p)
#@+node:ekr.20080711093251.7: *11* at.readOneAtShadowNode & helper
def readOneAtShadowNode(self, fn, p, force=False):

    at = self; c = at.c; x = c.shadowController
    if not fn == p.atShadowFileNodeName():
        at.error(
            f"can not happen: fn: {fn} != atShadowNodeName: "
            f"{p.atShadowFileNodeName()}")
        return
    # #1521 & #1341.
    fn = g.fullPath(c, p)
    at.default_directory = g.os_path_dirname(fn)
    # #889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    if shadow_exists:
        at.read(p, atShadow=True, force=force)
    else:
        ok = at.importAtShadowNode(fn, p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p)
#@+node:ekr.20080712080505.1: *12* at.importAtShadowNode
def importAtShadowNode(self, fn, p):
    at = self; c = at.c; ic = c.importCommands
    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()
    # Import the outline, exactly as @auto does.
    ic.createOutline(fn, parent=p.copy(), atShadow=True)
    if ic.errors:
        g.error('errors inhibited read @shadow', fn)
    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
    # else: g.doHook('after-shadow', p = p)
    return ic.errors == 0
#@+node:ekr.20200725105318.75: *10* at.writeAllHelper & helper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -23,17 +23,18 @@
     elif p.isAtAutoNode():
         at.writeOneAtAutoNode(p)
         # Do *not* clear the dirty bits the entries in @persistence tree here!
-    elif p.isAtCleanNode() or p.isAtNoSentFileNode():
-        at.write(p, sentinels=False)
+    elif p.isAtCleanNode():
+        at.write('@clean', p, sentinels=False)
+    elif p.isAtNoSentFileNode():
+        at.write('@nosent', p, sentinels=False)
     elif p.isAtEditNode():
         at.writeOneAtEditNode(p)
     elif p.isAtShadowFileNode():
         at.writeOneAtShadowNode(p)
     elif p.isAtThinFileNode() or p.isAtFileNode():
-        at.write(p)
+        at.write('@file', p)
     #
     # Clear the dirty bits in all descendant nodes.
     # The persistence data may still have to be written.
     for p2 in p.self_and_subtree(copy=False):
         p2.v.clearDirty()
-
@language python
#@+node:ekr.20200725105318.76: *11* Old:at.writeAllHelper & helper
def writeAllHelper(self, p, root):
    '''
    Write one file for at.writeAll.
    
    Do *not* write @auto files unless p == root.
    
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    at = self
    at.root = root
    if p.isAtIgnoreNode():
        # Should have been handled in findFilesToWrite.
        g.trace(f"Can not happen: {p.h} is an @ignore node")
        return
    try:
        at.writePathChanged(p)
    except IOError:
        return
    # Tricky: @ignore not recognised in @asis nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p)
        # Do *not* clear the dirty bits the entries in @persistence tree here!
    elif p.isAtCleanNode() or p.isAtNoSentFileNode():
        at.write(p, sentinels=False)
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p)
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p)
    elif p.isAtThinFileNode() or p.isAtFileNode():
        at.write(p)
    #
    # Clear the dirty bits in all descendant nodes.
    # The persistence data may still have to be written.
    for p2 in p.self_and_subtree(copy=False):
        p2.v.clearDirty()

#@+node:ekr.20041005105605.149: *11* at.writeAllHelper & helper
def writeAllHelper(self, p, root):
    '''
    Write one file for at.writeAll.
    
    Do *not* write @auto files unless p == root.
    
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    at = self
    at.root = root
    if p.isAtIgnoreNode():
        # Should have been handled in findFilesToWrite.
        g.trace(f"Can not happen: {p.h} is an @ignore node")
        return
    try:
        at.writePathChanged(p)
    except IOError:
        return
    # Tricky: @ignore not recognised in @asis nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p)
        # Do *not* clear the dirty bits the entries in @persistence tree here!
    elif p.isAtCleanNode():
        at.write('@clean', p, sentinels=False)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p)
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p)
    elif p.isAtThinFileNode() or p.isAtFileNode():
        at.write('@file', p)
    #
    # Clear the dirty bits in all descendant nodes.
    # The persistence data may still have to be written.
    for p2 in p.self_and_subtree(copy=False):
        p2.v.clearDirty()
#@+node:ekr.20190108105509.1: *12* at.writePathChanged
def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
#@+node:ekr.20200725105318.79: *10* at.write
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,4 +1,4 @@
-def write(self, root, sentinels=True):
+def write(self, kind, root, sentinels=True):
     """Write a 4.x derived file.
     root is the position of an @<file> node.
     sentinels will be False for @clean and @nosent nodes.
@@ -7,7 +7,7 @@
     try:
         c.endEditing()
         fileName = at.initWriteIvars(
-            root, root.anyAtFileNodeName(), sentinels=sentinels)
+            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
         if not fileName or not at.precheck(fileName, root):
             if sentinels:
                 # Raise dialog warning of data loss.
@language python
#@+node:ekr.20200725105318.80: *11* Old:at.write
def write(self, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @<file> node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
#@+node:ekr.20041005105605.144: *11* at.write
def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @<file> node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
#@+node:ekr.20200725105318.81: *10* at.writeMissingNode
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -4,9 +4,9 @@
     if p.isAtAsisFileNode():
         at.asisWrite(p)
     elif p.isAtNoSentFileNode():
-        at.write(p, sentinels=False)
+        at.write('@nosent', p, sentinels=False)
     elif p.isAtFileNode():
-        at.write(p)
+        at.write('@file', p)
     elif p.isAtAutoNode() or p.isAtAutoRstNode():
         g.es('Can not write missing @auto node', p.h, color='red')
     else:
@language python
#@+node:ekr.20200725105318.82: *11* Old:at.writeMissingNode
def writeMissingNode(self, p):

    at = self
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtNoSentFileNode():
        at.write(p, sentinels=False)
    elif p.isAtFileNode():
        at.write(p)
    elif p.isAtAutoNode() or p.isAtAutoRstNode():
        g.es('Can not write missing @auto node', p.h, color='red')
    else:
        g.trace('can not happen: unknown @file node')
#@+node:ekr.20041005105605.152: *11* at.writeMissingNode
def writeMissingNode(self, p):

    at = self
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtNoSentFileNode():
        at.write('@nosent', p, sentinels=False)
    elif p.isAtFileNode():
        at.write('@file', p)
    elif p.isAtAutoNode() or p.isAtAutoRstNode():
        g.es('Can not write missing @auto node', p.h, color='red')
    else:
        g.trace('can not happen: unknown @file node')
#@+node:ekr.20200725105319.91: *8* leo/core/leoCommands.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -211,6 +211,7 @@
         self.abbrevCommands = None
         self.editCommands = None
         self.db = {}  # May be set to a PickleShare instance later.
+        self.bufferCommands = None
         self.chapterCommands = None
         self.controlCommands = None
         self.convertCommands = None
@@ -268,6 +269,7 @@
         import leo.core.leoChapters as leoChapters
         # User commands...
         import leo.commands.abbrevCommands as abbrevCommands
+        import leo.commands.bufferCommands as bufferCommands
         import leo.commands.checkerCommands as checkerCommands
         assert checkerCommands
             # To suppress a pyflakes warning.
@@ -329,6 +331,7 @@
         self.vimCommands            = leoVim.VimCommands(c)
         # User commands
         self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
+        self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
         self.controlCommands    = controlCommands.ControlCommandsClass(c)
         self.convertCommands    = convertCommands.ConvertCommandsClass(c)
         self.debugCommands      = debugCommands.DebugCommandsClass(c)
@@ -345,6 +348,7 @@
         self.subCommanders = [
             self.abbrevCommands,
             self.atFileCommands,
+            self.bufferCommands,
             self.chapterController,
             self.controlCommands,
             self.convertCommands,
@@ -654,15 +658,6 @@
             c.setCurrentDirectoryFromContext(p)
         else:
             p = None
-        # Do NOT define a subfunction here!
-        #
-        # On some, python 2.x versions it causes exec to cause a syntax error
-        # Workarounds that avoid the syntax error hurt performance.
-        # See http://stackoverflow.com/questions/4484872.
-
-            # def g_input_wrapper(message, c=c):
-                # return g.input_(message, c=c)
-
         d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
         if define_name: d['__name__'] = define_name
         d['script_args'] = args or []
@@ -878,7 +873,6 @@
                 p.moveToNodeAfterTree()
             else:
                 p.moveToThreadNext()
-
#@verbatim
     #@+node:ekr.20091001141621.6062: *5* c.all_unique_positions
     def all_unique_positions(self, copy=True):
         """
@@ -1100,25 +1094,21 @@
#@verbatim
     #@+node:ekr.20040307104131.3: *5* c.positionExists
     def positionExists(self, p, root=None, trace=False):
         """Return True if a position exists in c's tree"""
-        # Important: do not call p.isAncestorOf here.
-        c = self
-        if not p or not p.v:
-            return False
-        if root and p == root:
-            return True
-        p = p.copy()
-        while p.hasParent():
-            old_n, old_v = p._childIndex, p.v
-            p.moveToParent()
-            if root and p == root:
-                return True
-            if not old_v.isNthChildOf(old_n, p.v):
+        if not p or not p.v: return False
+
+        rstack = root.stack + [(root.v, root._childIndex)] if root else []
+        pstack = p.stack + [(p.v, p._childIndex)]
+
+        if len(rstack) > len(pstack): return False
+
+        par = self.hiddenRootNode
+        for j, x in enumerate(pstack):
+            if j < len(rstack) and x != rstack[j]: return False
+            v, i = x
+            if i >= len(par.children) or v is not par.children[i]:
                 return False
-        if root:
-            exists = p == root
-        else:
-            exists = p.v.isNthChildOf(p._childIndex, c.hiddenRootNode)
-        return exists
+            par = v
+        return True
#@verbatim
     #@+node:ekr.20160427153457.1: *6* c.dumpPosition
     def dumpPosition(self, p):
         """Dump position p and it's ancestors."""
@@ -1851,8 +1841,6 @@
     def updateSyntaxColorer(self, v):
         self.frame.body.updateSyntaxColorer(v)
#@verbatim
     #@+node:ekr.20180503110307.1: *4* c.interactive*
-
-
#@verbatim
     #@+node:ekr.20180504075937.1: *5* c.interactive
     def interactive(self, callback, event, prompts):
#@verbatim
         #@+<< c.interactive docstring >>
@@ -1887,7 +1875,6 @@
             f(callback, event, prompts)
         else:
             g.trace('At most 3 arguments are supported.')
-
#@verbatim
     #@+node:ekr.20180503111213.1: *5* c.interactive1
     def interactive1(self, callback, event, prompts):
 
@@ -1980,6 +1967,7 @@
         aList = g.get_directives_dict_list(p)
         path = c.scanAtPathDirectives(aList)
         return path
+
     # Not used in Leo's core.
 
     def getNodeFileName(self, p):
@@ -2143,7 +2131,7 @@
             if 'root' in d:
                 return 'doc' if start_in_doc else 'code'
         return None
-    #@+node:ekr.20190921130036.1: *3* c.expand_path_expression (new)
+    #@+node:ekr.20190921130036.1: *3* c.expand_path_expression
     def expand_path_expression(self, s):
         """Expand all {{anExpression}} in c's context."""
         c = self
@@ -2178,7 +2166,9 @@
         if g.isWindows:
             val = val.replace('\\', '/')
         return val
-    #@+node:ekr.20190921130036.2: *4* c.replace_path_expression (new)
+    #@+node:ekr.20190921130036.2: *4* c.replace_path_expression
+    replace_errors = []
+
     def replace_path_expression(self, expr):
         """ local function to replace a single path expression."""
         c = self
@@ -2194,10 +2184,16 @@
         # #1338: Don't report errors when called by g.getUrlFromNode.
         try:
             # pylint: disable=eval-used
-            val = eval(expr, d)
-            return g.toUnicode(val, encoding='utf-8')
+            path = eval(expr, d)
+            return g.toUnicode(path, encoding='utf-8')
         except Exception as e:
-            g.trace(f"{c.shortFileName()}: {e.__class__.__name__} in {c.p.h}: {expr!r}")
+            message = (
+                f"{c.shortFileName()}: {c.p.h}\n"
+                f"expression: {expr!s}\n"
+                f"     error: {e!s}")
+            if message not in self.replace_errors:
+                self.replace_errors.append(message)
+                g.trace(message)
             return expr
#@verbatim
     #@+node:ekr.20171123201514.1: *3* c.Executing commands & scripts
#@verbatim
     #@+node:ekr.20110605040658.17005: *4* c.check_event
@@ -2229,37 +2225,40 @@
#@verbatim
     #@+node:ekr.20031218072017.2817: *4* c.doCommand
     command_count = 0
 
-    def doCommand(self, command, label, event=None):
-        """
-        Execute the given command, invoking hooks and catching exceptions.
-
-        The code assumes that the "command1" hook has completely handled the command if
-        g.doHook("command1") returns False.
-        This provides a simple mechanism for overriding commands.
+    def doCommand(self, command_func, command_name, event):
+        """
+        Execute the given command function, invoking hooks and catching exceptions.
+
+        The code assumes that the "command1" hook has completely handled the
+        command func if g.doHook("command1") returns False. This provides a
+        simple mechanism for overriding commands.
         """
         c, p = self, self.p
         c.setLog()
         self.command_count += 1
+        # New in Leo 6.2. Set command_function and command_name ivars.
+        self.command_function = command_func
+        self.command_name = command_name
         # The presence of this message disables all commands.
         if c.disableCommandsMessage:
             g.blue(c.disableCommandsMessage)
-            return
+            return None
         if c.exists and c.inCommand and not g.unitTesting:
             g.app.commandInterruptFlag = True
             g.error('ignoring command: already executing a command.')
-            return
+            return None
         g.app.commandInterruptFlag = False
-        if label and event is None:  # Do this only for legacy commands.
-            if label == "cantredo": label = "redo"
-            if label == "cantundo": label = "undo"
-            g.app.commandName = label
-        if not g.doHook("command1", c=c, p=p, label=label):
+        if not g.doHook("command1", c=c, p=p, label=command_name):
             try:
                 c.inCommand = True
-                val = c.executeAnyCommand(command, event)
+                try:
+                    return_value = command_func(event)
+                except Exception:
+                    g.es_exception()
+                    return_value = None
                 if c and c.exists:  # Be careful: the command could destroy c.
                     c.inCommand = False
-                    c.k.funcReturn = val
+                    ## c.k.funcReturn = return_value
             except Exception:
                 c.inCommand = False
                 if g.app.unitTesting:
@@ -2275,29 +2274,128 @@
         # Be careful: the command could destroy c.
         if c and c.exists:
             p = c.p
-            g.doHook("command2", c=c, p=p, label=label)
-    #@+node:ekr.20171124074112.1: *4* c.executeAnyCommand
-    def executeAnyCommand(self, command, event):
-        """
-        Execute a command, no matter how defined.
+            g.doHook("command2", c=c, p=p, label=command_name)
+        return return_value
+    #@+node:ekr.20200522075411.1: *4* c.doCommandByName
+    def doCommandByName(self, command_name, event):
+        """
+        Execute one command, given the name of the command.
         
-        Supports @g.commander_command and @g.new_cmd_decorator and plain methods.
-        """
-        try:
-            return command(event)
-        except Exception:
-            g.es_exception()
+        The caller must do any required keystroke-only tasks.
+        
+        Return the result, if any, of the command.
+        """
+        c = self
+        # Get the command's function.
+        command_func = c.commandsDict.get(command_name.replace('&', ''))
+        if not command_func:
+            message = f"no command function for {command_name!r}"
+            if g.app.unitTesting or g.app.inBridge:
+                raise AttributeError(message)
+            g.es_print(message, color='red')
+            g.trace(g.callers())
             return None
-    #@+node:ekr.20051106040126: *4* c.executeMinibufferCommand
+        # Invoke the function.
+        val = c.doCommand(command_func, command_name, event)
+        if c.exists:
+            c.frame.updateStatusLine()
+        return val
+    #@+node:ekr.20200526074132.1: *4* c.executeMinibufferCommand
     def executeMinibufferCommand(self, commandName):
-        c = self; k = c.k
-        func = c.commandsDict.get(commandName)
-        if func:
-            event = g.app.gui.create_key_event(c)
-            k.masterCommand(commandName=None, event=event, func=func)
-            return k.funcReturn
-        g.error(f"no such command: {commandName} {g.callers()}")
-        return None
+        """Call c.doCommandByName, creating the required event."""
+        c = self
+        event = g.app.gui.create_key_event(c)
+        return c.doCommandByName(commandName, event)
+    #@+node:ekr.20200523135601.1: *4* c.insertCharFromEvent
+    def insertCharFromEvent(self, event):
+        """
+        Handle the character given by event *without*
+        executing any command that might be bound to it.
+        
+        What happens depends on which widget has focus.
+        """
+        c, k, w = self, self.k, event.widget
+        name = c.widget_name(w)
+        stroke = event.stroke
+        if not stroke:
+            return
+        #
+        # Part 1: Very late special cases.
+        #
+        # #1448
+        if stroke.isNumPadKey() and k.state.kind == 'getArg':
+            stroke.removeNumPadModifier()
+            k.getArg(event, stroke=stroke)
+            return
+        # Handle all unbound characters in command mode.
+        if k.unboundKeyAction == 'command':
+            w = g.app.gui.get_focus(c)
+            if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
+                c.onCanvasKey(event)
+            return
+        #
+        # Part 2: Filter out keys that should never be inserted by default.
+        #
+        # Ignore unbound F-keys.
+        if stroke.isFKey():
+            return
+        # Ignore unbound Alt/Ctrl keys.
+        if stroke.isAltCtrl():
+            if not k.enable_alt_ctrl_bindings:
+                return
+            if k.ignore_unbound_non_ascii_keys:
+                return
+        # #868
+        if stroke.isPlainNumPad():
+            stroke.removeNumPadModifier()
+            event.stroke = stroke
+        # #868
+        if stroke.isNumPadKey():
+            return
+        # Ignore unbound non-ascii character.
+        if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
+            return
+        # Never insert escape or insert characters.
+        if 'Escape' in stroke.s or 'Insert' in stroke.s:
+            return
+        #
+        # Part 3: Handle the event depending on the pane and state.
+        #
+        # Handle events in the body pane.
+        if name.startswith('body'):
+            action = k.unboundKeyAction
+            if action in ('insert', 'overwrite'):
+                c.editCommands.selfInsertCommand(event, action=action)
+                c.frame.updateStatusLine()
+            return
+        #
+        # Handle events in headlines.
+        if name.startswith('head'):
+            c.frame.tree.onHeadlineKey(event)
+            return
+        #
+        # Handle events in the background tree (not headlines).
+        if name.startswith('canvas'):
+            if event.char:
+                k.searchTree(event.char)
+            # Not exactly right, but it seems to be good enough.
+            elif not stroke:
+                c.onCanvasKey(event)
+            return
+        #
+        # Ignore all events outside the log pane.
+        if not name.startswith('log'):
+            return
+        #
+        # Make sure we can insert into w.
+        log_w = event.widget
+        if not hasattr(log_w, 'supportsHighLevelInterface'):
+            return
+        #
+        # Send the event to the text widget, not the LeoLog instance.
+        i = log_w.getInsertPoint()
+        s = stroke.toGuiChar()
+        log_w.insert(i, s)
#@verbatim
     #@+node:ekr.20131016084446.16724: *4* c.setComplexCommand
     def setComplexCommand(self, commandName):
         """Make commandName the command to be executed by repeat-complex-command."""
@@ -2351,6 +2449,7 @@
         minibufferCallback.source_c = source_c
             # For GetArgs.command_source
         return minibufferCallback
+
     #fix bobjack's spelling error
 
     universallCallback = universalCallback
@@ -2386,6 +2485,32 @@
             path = None
         return path
#@verbatim
     #@+node:ekr.20171124101444.1: *3* c.File
+    #@+node:ekr.20200305104646.1: *4* c.archivedPositionToPosition (new)
+    def archivedPositionToPosition(self, s):
+        """Convert an archived position (a string) to a position."""
+        c = self
+        s = g.toUnicode(s)
+        aList = s.split(',')
+        try:
+            aList = [int(z) for z in aList]
+        except Exception:
+            aList = None
+        if not aList:
+            return None
+        p = c.rootPosition()
+        level = 0
+        while level < len(aList):
+            i = aList[level]
+            while i > 0:
+                if p.hasNext():
+                    p.moveToNext()
+                    i -= 1
+                else:
+                    return None
+            level += 1
+            if level < len(aList):
+                p.moveToFirstChild()
+        return p
#@verbatim
     #@+node:ekr.20150422080541.1: *4* c.backup
     def backup(self, fileName=None, prefix=None, silent=False, useTimeStamp=True):
         """
@@ -3845,164 +3970,66 @@
         u.afterChangeGroup(parent, undoType, undoData)
         return parent  # actually the last created/found position
#@verbatim
     #@+node:ekr.20100802121531.5804: *4* c.deletePositionsInList
-    def deletePositionsInList(self, aList, callback=None, redraw=True):
-        """
-        Delete all vnodes corresponding to the positions in aList. If a
-        callback is given, the callback is called for every node in the list.
-
-        The callback takes one explicit argument, p. As usual, the callback can
-        bind values using keyword arguments.
-
-        This is *very* tricky code. The theory of operation section explains why.
-        """
-        #@+<< theory of operation >>
-        #@+node:ekr.20150312080344.8: *5* << theory of operation >> (deletePositionsInList)
-        #@@language rest
-        #@+at
-        # The Aha: the positions passed to p.deletePositionsInList only
-        # *specify* the desired changes; the only way to *make* those changes is
-        # to operate on vnodes!
-        #
-        # Consider this outline, containing no clones::
-        #
-        #     + ROOT
-        #       - A
-        #       - B
-        #
-        # The fundamental problem is this. If we delete node A, the index of
-        # node B in ROOT.children will change. This problem has (almost) nothing
-        # to do with clones or positions.
-        #
-        # To make this concrete, let's look at the *vnodes* that represent this
-        # tree. It is the vnodes, and *not* the positions, that represent all of
-        # Leo's data. Let ROOT, A and B be the vnodes corresponding to the nodes
-        # ROOT, A and B. ROOT.children will look like this at first::
-        #
-        #     ROOT.children = [A,B]
-        #
-        # That is, the children array contains references (links) to both A and
-        # B. After deleting A, we will have::
-        #
-        #     ROOT.children = [B]
-        #
-        # As you can see, the reference to B is at index 1 of ROOT.children
-        # before deleting A, and at index 0 of ROOT.children after deleting A.
-        # Thus, *any* position referring to B will become invalid after deleting
-        # A.
-        #
-        # Several people, including myself, have proposed an unsound
-        # solution--just delete positions in reverse order, so that B will be
-        # deleted before A. This idea has appeal, but it is wrong. Here is an
-        # outline that shows that there is *no* correct order for deleting
-        # positions. All A' nodes are clones of each other::
-        #
-        #     + ROOT
-        #       + A'
-        #         - B # at position p1
-        #       + A'
-        #         - B # at position p2
-        #
-        # **Important**: B is *not* a clone. Also note that there is only *one*
-        # node called A and *one* node called B. The children arrays will look
-        # like::
-        #
-        #     ROOT.children = [A,A]
-        #     A.children = [B]
-        #     B.children = []
-        #
-        # It surely must be reasonable to pass either *or both* positions p1 and
-        # p2 to p.deletePositionsInList. But after deleting the B corresponding
-        # to p1, the children arrays will look like:
-        #
-        #     ROOT.children = [A,A]
-        #     A.children = []
-        #     B.children = [] # B is no longer referenced anywhere!
-        #
-        # So if p.deletePositionsInList attempts to delete position p2 (from A),
-        # B will no longer appear in A.children!
-        #
-        # There are many other cases that we could discuss, but the conclusion
-        # in all cases is that we must use the positions passed to
-        # p.deletePositionsInList only as *hints* about what to do.
-        #
-        # Happily, there is a simple strategy that sidesteps all the
-        # difficulties:
-        #
-        # Step 1. Verify, *before* making any changes to the outline, that all
-        # the positions passed to p.deletePositionsInList *initially* make
-        # sense.
-        #
-        # Step 2. Treat each position as a "request" to delete *some* vnode from
-        # the children array in the *position's* parent vnode.
-        #
-        # This is just a bit subtle. Let me explain it in detail.
-        #
-        # First, recall that vnodes do not have unique parent vnodes. Because of
-        # clones, a vnode may may have *many* parents. Happily, every position
-        # *does* specify a unique parent (vnode) at that position.
-        #
-        # Second, as shown above, there is no way to order positions such that
-        # all later positions remain valid. As the example above shows, deleting
-        # (the vnode corresponding to) a position P may cause *all* later
-        # positions referring to P.v to refer to *already deleted* vnodes.
-        #
-        # In other words, we simply *must* ignore the child indices in
-        # positions. Given a position P, P.parent is well defined. So Step 2
-        # above will simply delete the *first* element in P.parent.children
-        # containing P.v.
-        #
-        # As we have seen, there may not even *be* any such element of
-        # P.parent.children: a previous delete may have already deleted the last
-        # item of P.parent.children equal to P.v. That should *not* be
-        # considered an error--Step 1 has ensured that all positions
-        # *originally* did make sense.
-        #
-        # Summary
-        #
-        # Positions passed to p.deletePositionsInList specify *vnodes* to be
-        # deleted from specific parents, but they do *not* specify at what index
-        # in the parent.children array (if any!) those vnodes are to be found.
-        # The algorithm will delete the *first* item in the children array that
-        # references the vnode to be deleted.
-        #
-        # This will almost always be good enough. In the unlikely event that
-        # more control is desired, p.deletePositionsInList can not possibly be
-        # used.
-        #
-        # The new emphasis on vnodes at last puts the problem an a completely
-        # solid foundation. Moreover, the new algorithm should be considerably
-        # faster than the old: there is no need to sort positions.
-        #@-<< theory of operation >>
-        c = self
-        # Verify all positions *before* altering the tree.
-        aList2 = []
-        for p in aList:
-            if c.positionExists(p):
-                aList2.append(p.copy())
-            else:
-                g.trace('invalid position', p)
-        if not aList2:
-            return  # Don't redraw the screen unless necessary!
-        # Delete p.v for all positions p in reversed(sorted(aList2)).
-        if callback:
-            for p in reversed(sorted(aList2)):
-                if c.positionExists(p):
-                    callback(p)
-        else:
-            for p in reversed(sorted(aList2)):
-                if c.positionExists(p):
-                    v = p.v
-                    parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
-                    if v in parent_v.children:
-                        childIndex = parent_v.children.index(v)
-                        v._cutLink(childIndex, parent_v)
-        # Make sure c.hiddenRootNode always has at least one child.
-        if not c.hiddenRootNode.children:
-            v = leoNodes.VNode(context=c)
-            v._addCopiedLink(childIndex=0, parent_v=c.hiddenRootNode)
+    def deletePositionsInList(self, aList, redraw=True):
+        """
+        Delete all vnodes corresponding to the positions in aList.
+
+        See "Theory of operation of c.deletePositionsInList" in LeoDocs.leo.
+        """
+        # New implementation by Vitalije 2020-03-17 17:29 
+        c = self
+        # Ensure all positions are valid.
+        aList = [p for p in aList if c.positionExists(p)]
+        if not aList:
+            return []
+
+        def p2link(p):
+            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
+            return p._childIndex, parent_v
+
+        links_to_be_cut = sorted(set(map(p2link, aList)), key=lambda x:-x[0])
+        undodata = []
+        for i, v in links_to_be_cut:
+            ch = v.children.pop(i)
+            ch.parents.remove(v)
+            undodata.append((v.gnx, i, ch.gnx))
         if redraw:
-            c.selectPosition(c.rootPosition())
-                # Calls redraw()
+            if not c.positionExists(c.p):
+                c.setCurrentPosition(c.rootPosition())
+            c.redraw()
+        return undodata
+
+    #@+node:vitalije.20200318161844.1: *4* c.undoableDeletePositions
+    def undoableDeletePositions(self, aList):
+        """
+        Deletes all vnodes corresponding to the positions in aList,
+        and make changes undoable.
+        """
+        c = self
+        u = c.undoer
+        data = c.deletePositionsInList(aList)
+        gnx2v = c.fileCommands.gnxDict
+        def undo():
+            for pgnx, i, chgnx in reversed(u.getBead(u.bead).data):
+                v = gnx2v[pgnx]
+                ch = gnx2v[chgnx]
+                v.children.insert(i, ch)
+                ch.parents.append(v)
+            if not c.positionExists(c.p):
+                c.setCurrentPosition(c.rootPosition())
+        def redo():
+            for pgnx, i, chgnx in u.getBead(u.bead + 1).data:
+                v = gnx2v[pgnx]
+                ch = v.children.pop(i)
+                ch.parents.remove(v)
+            if not c.positionExists(c.p):
+                c.setCurrentPosition(c.rootPosition())
+        u.pushBead(g.Bunch(
+            data=data,
+            undoType='delete nodes',
+            undoHelper=undo,
+            redoHelper=redo,
+        ))
#@verbatim
     #@+node:ekr.20091211111443.6265: *4* c.doBatchOperations & helpers
     def doBatchOperations(self, aList=None):
         # Validate aList and create the parents dict
@language python
#@+node:ekr.20200725105320.3: *9* Added
#@+node:ekr.20200522075411.1: *10* c.doCommandByName
def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
#@+node:ekr.20200526074132.1: *10* c.executeMinibufferCommand
def executeMinibufferCommand(self, commandName):
    """Call c.doCommandByName, creating the required event."""
    c = self
    event = g.app.gui.create_key_event(c)
    return c.doCommandByName(commandName, event)
#@+node:ekr.20200523135601.1: *10* c.insertCharFromEvent
def insertCharFromEvent(self, event):
    """
    Handle the character given by event *without*
    executing any command that might be bound to it.
    
    What happens depends on which widget has focus.
    """
    c, k, w = self, self.k, event.widget
    name = c.widget_name(w)
    stroke = event.stroke
    if not stroke:
        return
    #
    # Part 1: Very late special cases.
    #
    # #1448
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    # Handle all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Part 2: Filter out keys that should never be inserted by default.
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    # Ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl():
        if not k.enable_alt_ctrl_bindings:
            return
        if k.ignore_unbound_non_ascii_keys:
            return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        event.stroke = stroke
    # #868
    if stroke.isNumPadKey():
        return
    # Ignore unbound non-ascii character.
    if k.ignore_unbound_non_ascii_keys and not stroke.isPlainKey():
        return
    # Never insert escape or insert characters.
    if 'Escape' in stroke.s or 'Insert' in stroke.s:
        return
    #
    # Part 3: Handle the event depending on the pane and state.
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
            c.frame.updateStatusLine()
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree (not headlines).
    if name.startswith('canvas'):
        if event.char:
            k.searchTree(event.char)
        # Not exactly right, but it seems to be good enough.
        elif not stroke:
            c.onCanvasKey(event)
        return
    #
    # Ignore all events outside the log pane.
    if not name.startswith('log'):
        return
    #
    # Make sure we can insert into w.
    log_w = event.widget
    if not hasattr(log_w, 'supportsHighLevelInterface'):
        return
    #
    # Send the event to the text widget, not the LeoLog instance.
    i = log_w.getInsertPoint()
    s = stroke.toGuiChar()
    log_w.insert(i, s)
#@+node:ekr.20200305104646.1: *10* c.archivedPositionToPosition (new)
def archivedPositionToPosition(self, s):
    """Convert an archived position (a string) to a position."""
    c = self
    s = g.toUnicode(s)
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        aList = None
    if not aList:
        return None
    p = c.rootPosition()
    level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
    return p
#@+node:vitalije.20200318161844.1: *10* c.undoableDeletePositions
def undoableDeletePositions(self, aList):
    """
    Deletes all vnodes corresponding to the positions in aList,
    and make changes undoable.
    """
    c = self
    u = c.undoer
    data = c.deletePositionsInList(aList)
    gnx2v = c.fileCommands.gnxDict
    def undo():
        for pgnx, i, chgnx in reversed(u.getBead(u.bead).data):
            v = gnx2v[pgnx]
            ch = gnx2v[chgnx]
            v.children.insert(i, ch)
            ch.parents.append(v)
        if not c.positionExists(c.p):
            c.setCurrentPosition(c.rootPosition())
    def redo():
        for pgnx, i, chgnx in u.getBead(u.bead + 1).data:
            v = gnx2v[pgnx]
            ch = v.children.pop(i)
            ch.parents.remove(v)
        if not c.positionExists(c.p):
            c.setCurrentPosition(c.rootPosition())
    u.pushBead(g.Bunch(
        data=data,
        undoType='delete nodes',
        undoHelper=undo,
        redoHelper=redo,
    ))
#@+node:ekr.20200725105320.4: *9* Deleted
#@+node:ekr.20200725105320.5: *10* c.executeAnyCommand
def executeAnyCommand(self, command, event):
    """
    Execute a command, no matter how defined.
    
    Supports @g.commander_command and @g.new_cmd_decorator and plain methods.
    """
    try:
        return command(event)
    except Exception:
        g.es_exception()
        return None
#@+node:ekr.20200725105320.6: *10* c.executeMinibufferCommand
def executeMinibufferCommand(self, commandName):
    c = self; k = c.k
    func = c.commandsDict.get(commandName)
    if func:
        event = g.app.gui.create_key_event(c)
        k.masterCommand(commandName=None, event=event, func=func)
        return k.funcReturn
    g.error(f"no such command: {commandName} {g.callers()}")
    return None
#@+node:ekr.20200725105320.7: *10* << theory of operation >> (deletePositionsInList)
@language rest
@
The Aha: the positions passed to p.deletePositionsInList only
*specify* the desired changes; the only way to *make* those changes is
to operate on vnodes!

Consider this outline, containing no clones::

    + ROOT
      - A
      - B

The fundamental problem is this. If we delete node A, the index of
node B in ROOT.children will change. This problem has (almost) nothing
to do with clones or positions.

To make this concrete, let's look at the *vnodes* that represent this
tree. It is the vnodes, and *not* the positions, that represent all of
Leo's data. Let ROOT, A and B be the vnodes corresponding to the nodes
ROOT, A and B. ROOT.children will look like this at first::

    ROOT.children = [A,B]

That is, the children array contains references (links) to both A and
B. After deleting A, we will have::

    ROOT.children = [B]

As you can see, the reference to B is at index 1 of ROOT.children
before deleting A, and at index 0 of ROOT.children after deleting A.
Thus, *any* position referring to B will become invalid after deleting
A.

Several people, including myself, have proposed an unsound
solution--just delete positions in reverse order, so that B will be
deleted before A. This idea has appeal, but it is wrong. Here is an
outline that shows that there is *no* correct order for deleting
positions. All A' nodes are clones of each other::

    + ROOT
      + A'
        - B # at position p1
      + A'
        - B # at position p2

**Important**: B is *not* a clone. Also note that there is only *one*
node called A and *one* node called B. The children arrays will look
like::

    ROOT.children = [A,A]
    A.children = [B]
    B.children = []

It surely must be reasonable to pass either *or both* positions p1 and
p2 to p.deletePositionsInList. But after deleting the B corresponding
to p1, the children arrays will look like:

    ROOT.children = [A,A]
    A.children = []
    B.children = [] # B is no longer referenced anywhere!

So if p.deletePositionsInList attempts to delete position p2 (from A),
B will no longer appear in A.children!

There are many other cases that we could discuss, but the conclusion
in all cases is that we must use the positions passed to
p.deletePositionsInList only as *hints* about what to do.

Happily, there is a simple strategy that sidesteps all the
difficulties:

Step 1. Verify, *before* making any changes to the outline, that all
the positions passed to p.deletePositionsInList *initially* make
sense.

Step 2. Treat each position as a "request" to delete *some* vnode from
the children array in the *position's* parent vnode.

This is just a bit subtle. Let me explain it in detail.

First, recall that vnodes do not have unique parent vnodes. Because of
clones, a vnode may may have *many* parents. Happily, every position
*does* specify a unique parent (vnode) at that position.

Second, as shown above, there is no way to order positions such that
all later positions remain valid. As the example above shows, deleting
(the vnode corresponding to) a position P may cause *all* later
positions referring to P.v to refer to *already deleted* vnodes.

In other words, we simply *must* ignore the child indices in
positions. Given a position P, P.parent is well defined. So Step 2
above will simply delete the *first* element in P.parent.children
containing P.v.

As we have seen, there may not even *be* any such element of
P.parent.children: a previous delete may have already deleted the last
item of P.parent.children equal to P.v. That should *not* be
considered an error--Step 1 has ensured that all positions
*originally* did make sense.

Summary

Positions passed to p.deletePositionsInList specify *vnodes* to be
deleted from specific parents, but they do *not* specify at what index
in the parent.children array (if any!) those vnodes are to be found.
The algorithm will delete the *first* item in the children array that
references the vnode to be deleted.

This will almost always be good enough. In the unlikely event that
more control is desired, p.deletePositionsInList can not possibly be
used.

The new emphasis on vnodes at last puts the problem an a completely
solid foundation. Moreover, the new algorithm should be considerably
faster than the old: there is no need to sort positions.
#@+node:ekr.20200725105320.8: *9* Changed
#@+node:ekr.20200725105320.9: *10* c.initObjectIvars
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -3,6 +3,7 @@
     self.abbrevCommands = None
     self.editCommands = None
     self.db = {}  # May be set to a PickleShare instance later.
+    self.bufferCommands = None
     self.chapterCommands = None
     self.controlCommands = None
     self.convertCommands = None
@language python
#@+node:ekr.20200725105320.10: *11* Old:c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
#@+node:ekr.20120217070122.10468: *11* c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.bufferCommands = None
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
#@+node:ekr.20200725105320.11: *10* c.initObjects
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -33,6 +33,7 @@
     import leo.core.leoChapters as leoChapters
     # User commands...
     import leo.commands.abbrevCommands as abbrevCommands
+    import leo.commands.bufferCommands as bufferCommands
     import leo.commands.checkerCommands as checkerCommands
     assert checkerCommands
         # To suppress a pyflakes warning.
@@ -94,6 +95,7 @@
     self.vimCommands            = leoVim.VimCommands(c)
     # User commands
     self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
+    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
     self.controlCommands    = controlCommands.ControlCommandsClass(c)
     self.convertCommands    = convertCommands.ConvertCommandsClass(c)
     self.debugCommands      = debugCommands.DebugCommandsClass(c)
@@ -110,6 +112,7 @@
     self.subCommanders = [
         self.abbrevCommands,
         self.atFileCommands,
+        self.bufferCommands,
         self.chapterController,
         self.controlCommands,
         self.convertCommands,
@language python
#@+node:ekr.20200725105320.12: *11* Old:c.initObjects
@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '<hidden root vnode>'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
#@+node:ekr.20120217070122.10470: *11* c.initObjects
@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '<hidden root vnode>'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.bufferCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
#@+node:ekr.20200725105320.13: *10* c.executeScriptHelper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -5,15 +5,6 @@
         c.setCurrentDirectoryFromContext(p)
     else:
         p = None
-    # Do NOT define a subfunction here!
-    #
-    # On some, python 2.x versions it causes exec to cause a syntax error
-    # Workarounds that avoid the syntax error hurt performance.
-    # See http://stackoverflow.com/questions/4484872.
-
-        # def g_input_wrapper(message, c=c):
-            # return g.input_(message, c=c)
-
     d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
     if define_name: d['__name__'] = define_name
     d['script_args'] = args or []
@language python
#@+node:ekr.20200725105320.14: *11* Old:c.executeScriptHelper
def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy()  # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    # Do NOT define a subfunction here!
    #
    # On some, python 2.x versions it causes exec to cause a syntax error
    # Workarounds that avoid the syntax error hurt performance.
    # See http://stackoverflow.com/questions/4484872.

        # def g_input_wrapper(message, c=c):
            # return g.input_(message, c=c)

    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    #
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
#@+node:ekr.20171123135625.5: *11* c.executeScriptHelper
def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy()  # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    #
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
#@+node:ekr.20200725105320.15: *10* c.all_roots
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -22,4 +22,3 @@
             p.moveToNodeAfterTree()
         else:
             p.moveToThreadNext()
-
@language python
#@+node:ekr.20200725105320.16: *11* Old:c.all_roots
def all_roots(self, copy=True, predicate=None):
    """
    A generator yielding *all* the root positions in the outline that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The generator yields all **root** anywhere in the outline that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    """
    c = self
    if predicate is None:

        # pylint: disable=function-redefined

        def predicate(p):
            return p.isAnyAtFileNode()

    p = c.rootPosition()
    while p:
        if predicate(p):
            yield p.copy()  # 2017/02/19
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

#@+node:ekr.20161120121226.1: *11* c.all_roots
def all_roots(self, copy=True, predicate=None):
    """
    A generator yielding *all* the root positions in the outline that
    satisfy the given predicate. p.isAnyAtFileNode is the default
    predicate.

    The generator yields all **root** anywhere in the outline that satisfy
    the predicate. Once a root is found, the generator skips its subtree.
    """
    c = self
    if predicate is None:

        # pylint: disable=function-redefined

        def predicate(p):
            return p.isAnyAtFileNode()

    p = c.rootPosition()
    while p:
        if predicate(p):
            yield p.copy()  # 2017/02/19
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
#@+node:ekr.20200725105320.17: *10* c.positionExists
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,21 +1,17 @@
 def positionExists(self, p, root=None, trace=False):
     """Return True if a position exists in c's tree"""
-    # Important: do not call p.isAncestorOf here.
-    c = self
-    if not p or not p.v:
-        return False
-    if root and p == root:
-        return True
-    p = p.copy()
-    while p.hasParent():
-        old_n, old_v = p._childIndex, p.v
-        p.moveToParent()
-        if root and p == root:
-            return True
-        if not old_v.isNthChildOf(old_n, p.v):
+    if not p or not p.v: return False
+
+    rstack = root.stack + [(root.v, root._childIndex)] if root else []
+    pstack = p.stack + [(p.v, p._childIndex)]
+
+    if len(rstack) > len(pstack): return False
+
+    par = self.hiddenRootNode
+    for j, x in enumerate(pstack):
+        if j < len(rstack) and x != rstack[j]: return False
+        v, i = x
+        if i >= len(par.children) or v is not par.children[i]:
             return False
-    if root:
-        exists = p == root
-    else:
-        exists = p.v.isNthChildOf(p._childIndex, c.hiddenRootNode)
-    return exists
+        par = v
+    return True
@language python
#@+node:ekr.20200725105320.18: *11* Old:c.positionExists
def positionExists(self, p, root=None, trace=False):
    """Return True if a position exists in c's tree"""
    # Important: do not call p.isAncestorOf here.
    c = self
    if not p or not p.v:
        return False
    if root and p == root:
        return True
    p = p.copy()
    while p.hasParent():
        old_n, old_v = p._childIndex, p.v
        p.moveToParent()
        if root and p == root:
            return True
        if not old_v.isNthChildOf(old_n, p.v):
            return False
    if root:
        exists = p == root
    else:
        exists = p.v.isNthChildOf(p._childIndex, c.hiddenRootNode)
    return exists
#@+node:ekr.20040307104131.3: *11* c.positionExists
def positionExists(self, p, root=None, trace=False):
    """Return True if a position exists in c's tree"""
    if not p or not p.v: return False

    rstack = root.stack + [(root.v, root._childIndex)] if root else []
    pstack = p.stack + [(p.v, p._childIndex)]

    if len(rstack) > len(pstack): return False

    par = self.hiddenRootNode
    for j, x in enumerate(pstack):
        if j < len(rstack) and x != rstack[j]: return False
        v, i = x
        if i >= len(par.children) or v is not par.children[i]:
            return False
        par = v
    return True
#@+node:ekr.20160427153457.1: *12* c.dumpPosition
def dumpPosition(self, p):
    """Dump position p and it's ancestors."""
    g.trace('=====', p.h, p._childIndex)
    for i, data in enumerate(p.stack):
        v, childIndex = data
        print(f"{i} {childIndex} {v._headString}")
#@+node:ekr.20200725105320.19: *10* c.interactive*
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,2 +0,0 @@
-
-
@language python
#@+node:ekr.20200725105320.20: *11* Old:c.interactive*


#@+node:ekr.20180503110307.1: *11* c.interactive*
#@+node:ekr.20180504075937.1: *12* c.interactive
def interactive(self, callback, event, prompts):
    << c.interactive docstring >>
    #
    # This pathetic code should be generalized,
    # but it's not as easy as one might imagine.
    c = self
    d = {1: c.interactive1, 2: c.interactive2, 3: c.interactive3,}
    f = d.get(len(prompts))
    if f:
        f(callback, event, prompts)
    else:
        g.trace('At most 3 arguments are supported.')
#@+node:ekr.20180503131222.1: *13* << c.interactive docstring >>
"""
c.interactive: Prompt for up to three arguments from the minibuffer.

The number of prompts determines the number of arguments.

Use the @command decorator to define commands.  Examples:

    @g.command('i3')
    def i3_command(event):
        c = event.get('c')
        if not c: return
            
        def callback(args, c, event):
            g.trace(args)
            c.bodyWantsFocus()
    
        c.interactive(callback, event,
            prompts=['Arg1: ', ' Arg2: ', ' Arg3: '])
"""
#@+node:ekr.20180503111213.1: *12* c.interactive1
def interactive1(self, callback, event, prompts):

    c, k = self, self.k
    prompt = prompts[0]

    def state1(event):
        callback(args=[k.arg], c=c, event=event)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

    k.setLabelBlue(prompt)
    k.get1Arg(event, handler=state1)
#@+node:ekr.20180503111249.1: *12* c.interactive2
def interactive2(self, callback, event, prompts):

    c, d, k = self, {}, self.k
    prompt1, prompt2 = prompts

    def state1(event):
        d['arg1'] = k.arg
        k.extendLabel(prompt2, select=False, protect=True)
        k.getNextArg(handler=state2)

    def state2(event):
        callback(args=[d.get('arg1'), k.arg], c=c, event=event)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

    k.setLabelBlue(prompt1)
    k.get1Arg(event, handler=state1)
#@+node:ekr.20180503111249.2: *12* c.interactive3
def interactive3(self, callback, event, prompts):

    c, d, k = self, {}, self.k
    prompt1, prompt2, prompt3 = prompts

    def state1(event):
        d['arg1'] = k.arg
        k.extendLabel(prompt2, select=False, protect=True)
        k.getNextArg(handler=state2)

    def state2(event):
        d['arg2'] = k.arg
        k.extendLabel(prompt3, select=False, protect=True)
        k.get1Arg(event, handler=state3)
            # Restart.

    def state3(event):
        args = [d.get('arg1'), d.get('arg2'), k.arg]
        callback(args=args, c=c, event=event)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

    k.setLabelBlue(prompt1)
    k.get1Arg(event, handler=state1)
#@+node:ekr.20200725105320.21: *10* c.interactive
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -10,4 +10,3 @@
         f(callback, event, prompts)
     else:
         g.trace('At most 3 arguments are supported.')
-
@language python
#@+node:ekr.20200725105320.22: *11* Old:c.interactive
def interactive(self, callback, event, prompts):
    << c.interactive docstring >>
    #
    # This pathetic code should be generalized,
    # but it's not as easy as one might imagine.
    c = self
    d = {1: c.interactive1, 2: c.interactive2, 3: c.interactive3,}
    f = d.get(len(prompts))
    if f:
        f(callback, event, prompts)
    else:
        g.trace('At most 3 arguments are supported.')

#@+node:ekr.20180504075937.1: *11* c.interactive
def interactive(self, callback, event, prompts):
    << c.interactive docstring >>
    #
    # This pathetic code should be generalized,
    # but it's not as easy as one might imagine.
    c = self
    d = {1: c.interactive1, 2: c.interactive2, 3: c.interactive3,}
    f = d.get(len(prompts))
    if f:
        f(callback, event, prompts)
    else:
        g.trace('At most 3 arguments are supported.')
#@+node:ekr.20180503131222.1: *12* << c.interactive docstring >>
"""
c.interactive: Prompt for up to three arguments from the minibuffer.

The number of prompts determines the number of arguments.

Use the @command decorator to define commands.  Examples:

    @g.command('i3')
    def i3_command(event):
        c = event.get('c')
        if not c: return
            
        def callback(args, c, event):
            g.trace(args)
            c.bodyWantsFocus()
    
        c.interactive(callback, event,
            prompts=['Arg1: ', ' Arg2: ', ' Arg3: '])
"""
#@+node:ekr.20200725105320.23: *10* c.getNodePath & c.getNodeFileName
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -7,6 +7,7 @@
     aList = g.get_directives_dict_list(p)
     path = c.scanAtPathDirectives(aList)
     return path
+
 # Not used in Leo's core.
 
 def getNodeFileName(self, p):
@language python
#@+node:ekr.20200725105320.24: *11* Old:c.getNodePath & c.getNodeFileName
# Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.

def getNodePath(self, p):
    """Return the path in effect at node p."""
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path
# Not used in Leo's core.

def getNodeFileName(self, p):
    """
    Return the full file name at node p,
    including effects of all @path directives.
    Return None if p is no kind of @file node.
    """
    c = self
    path = g.scanAllAtPathDirectives(c, p)
    name = ''
    for p in p.self_and_parents(copy=False):
        name = p.anyAtFileNodeName()
        if name: break
    if name:
        # The commander method supports {{expr}}; the global function does not.
        path = c.expand_path_expression(path)  # #1341.
        name = c.expand_path_expression(name)  # #1341.
        name = g.os_path_finalize_join(path, name)
    return name
#@+node:ekr.20081006100835.1: *11* c.getNodePath & c.getNodeFileName
# Not used in Leo's core.
# Used by the UNl plugin.  Does not need to create a path.

def getNodePath(self, p):
    """Return the path in effect at node p."""
    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

# Not used in Leo's core.

def getNodeFileName(self, p):
    """
    Return the full file name at node p,
    including effects of all @path directives.
    Return None if p is no kind of @file node.
    """
    c = self
    path = g.scanAllAtPathDirectives(c, p)
    name = ''
    for p in p.self_and_parents(copy=False):
        name = p.anyAtFileNodeName()
        if name: break
    if name:
        # The commander method supports {{expr}}; the global function does not.
        path = c.expand_path_expression(path)  # #1341.
        name = c.expand_path_expression(name)  # #1341.
        name = g.os_path_finalize_join(path, name)
    return name
#@+node:ekr.20200725105320.25: *10* c.expand_path_expression
Only headline has changed
#@+node:ekr.20200725105320.26: *11* Old:c.expand_path_expression (new)
def expand_path_expression(self, s):
    """Expand all {{anExpression}} in c's context."""
    c = self
    if not s:
        return ''
    s = g.toUnicode(s)
    # find and replace repeated path expressions
    previ, aList = 0, []
    while previ < len(s):
        i = s.find('{{', previ)
        j = s.find('}}', previ)
        if -1 < i < j:
            # Add anything from previous index up to '{{'
            if previ < i:
                aList.append(s[previ:i])
            # Get expression and find substitute
            exp = s[i + 2 : j].strip()
            if exp:
                try:
                    s2 = c.replace_path_expression(exp)
                    aList.append(s2)
                except Exception:
                    g.es(f"Exception evaluating {{{{{exp}}}}} in {s.strip()}")
                    g.es_exception(full=True, c=c)
            # Prepare to search again after the last '}}'
            previ = j + 2
        else:
            # Add trailing fragment (fragile in case of mismatched '{{'/'}}')
            aList.append(s[previ:])
            break
    val = ''.join(aList)
    if g.isWindows:
        val = val.replace('\\', '/')
    return val
#@+node:ekr.20190921130036.1: *11* c.expand_path_expression
def expand_path_expression(self, s):
    """Expand all {{anExpression}} in c's context."""
    c = self
    if not s:
        return ''
    s = g.toUnicode(s)
    # find and replace repeated path expressions
    previ, aList = 0, []
    while previ < len(s):
        i = s.find('{{', previ)
        j = s.find('}}', previ)
        if -1 < i < j:
            # Add anything from previous index up to '{{'
            if previ < i:
                aList.append(s[previ:i])
            # Get expression and find substitute
            exp = s[i + 2 : j].strip()
            if exp:
                try:
                    s2 = c.replace_path_expression(exp)
                    aList.append(s2)
                except Exception:
                    g.es(f"Exception evaluating {{{{{exp}}}}} in {s.strip()}")
                    g.es_exception(full=True, c=c)
            # Prepare to search again after the last '}}'
            previ = j + 2
        else:
            # Add trailing fragment (fragile in case of mismatched '{{'/'}}')
            aList.append(s[previ:])
            break
    val = ''.join(aList)
    if g.isWindows:
        val = val.replace('\\', '/')
    return val
#@+node:ekr.20190921130036.2: *12* c.replace_path_expression
replace_errors = []

def replace_path_expression(self, expr):
    """ local function to replace a single path expression."""
    c = self
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    # #1338: Don't report errors when called by g.getUrlFromNode.
    try:
        # pylint: disable=eval-used
        path = eval(expr, d)
        return g.toUnicode(path, encoding='utf-8')
    except Exception as e:
        message = (
            f"{c.shortFileName()}: {c.p.h}\n"
            f"expression: {expr!s}\n"
            f"     error: {e!s}")
        if message not in self.replace_errors:
            self.replace_errors.append(message)
            g.trace(message)
        return expr
#@+node:ekr.20200725105320.27: *10* c.replace_path_expression
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,3 +1,5 @@
+replace_errors = []
+
 def replace_path_expression(self, expr):
     """ local function to replace a single path expression."""
     c = self
@@ -13,8 +15,14 @@
     # #1338: Don't report errors when called by g.getUrlFromNode.
     try:
         # pylint: disable=eval-used
-        val = eval(expr, d)
-        return g.toUnicode(val, encoding='utf-8')
+        path = eval(expr, d)
+        return g.toUnicode(path, encoding='utf-8')
     except Exception as e:
-        g.trace(f"{c.shortFileName()}: {e.__class__.__name__} in {c.p.h}: {expr!r}")
+        message = (
+            f"{c.shortFileName()}: {c.p.h}\n"
+            f"expression: {expr!s}\n"
+            f"     error: {e!s}")
+        if message not in self.replace_errors:
+            self.replace_errors.append(message)
+            g.trace(message)
         return expr
@language python
#@+node:ekr.20200725105320.28: *11* Old:c.replace_path_expression (new)
def replace_path_expression(self, expr):
    """ local function to replace a single path expression."""
    c = self
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    # #1338: Don't report errors when called by g.getUrlFromNode.
    try:
        # pylint: disable=eval-used
        val = eval(expr, d)
        return g.toUnicode(val, encoding='utf-8')
    except Exception as e:
        g.trace(f"{c.shortFileName()}: {e.__class__.__name__} in {c.p.h}: {expr!r}")
        return expr
#@+node:ekr.20190921130036.2: *11* c.replace_path_expression
replace_errors = []

def replace_path_expression(self, expr):
    """ local function to replace a single path expression."""
    c = self
    d = {
        'c': c,
        'g': g,
        # 'getString': c.config.getString,
        'p': c.p,
        'os': os,
        'sep': os.sep,
        'sys': sys,
    }
    # #1338: Don't report errors when called by g.getUrlFromNode.
    try:
        # pylint: disable=eval-used
        path = eval(expr, d)
        return g.toUnicode(path, encoding='utf-8')
    except Exception as e:
        message = (
            f"{c.shortFileName()}: {c.p.h}\n"
            f"expression: {expr!s}\n"
            f"     error: {e!s}")
        if message not in self.replace_errors:
            self.replace_errors.append(message)
            g.trace(message)
        return expr
#@+node:ekr.20200725105320.29: *10* c.doCommand
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,36 +1,39 @@
 command_count = 0
 
-def doCommand(self, command, label, event=None):
+def doCommand(self, command_func, command_name, event):
     """
-    Execute the given command, invoking hooks and catching exceptions.
+    Execute the given command function, invoking hooks and catching exceptions.
 
-    The code assumes that the "command1" hook has completely handled the command if
-    g.doHook("command1") returns False.
-    This provides a simple mechanism for overriding commands.
+    The code assumes that the "command1" hook has completely handled the
+    command func if g.doHook("command1") returns False. This provides a
+    simple mechanism for overriding commands.
     """
     c, p = self, self.p
     c.setLog()
     self.command_count += 1
+    # New in Leo 6.2. Set command_function and command_name ivars.
+    self.command_function = command_func
+    self.command_name = command_name
     # The presence of this message disables all commands.
     if c.disableCommandsMessage:
         g.blue(c.disableCommandsMessage)
-        return
+        return None
     if c.exists and c.inCommand and not g.unitTesting:
         g.app.commandInterruptFlag = True
         g.error('ignoring command: already executing a command.')
-        return
+        return None
     g.app.commandInterruptFlag = False
-    if label and event is None:  # Do this only for legacy commands.
-        if label == "cantredo": label = "redo"
-        if label == "cantundo": label = "undo"
-        g.app.commandName = label
-    if not g.doHook("command1", c=c, p=p, label=label):
+    if not g.doHook("command1", c=c, p=p, label=command_name):
         try:
             c.inCommand = True
-            val = c.executeAnyCommand(command, event)
+            try:
+                return_value = command_func(event)
+            except Exception:
+                g.es_exception()
+                return_value = None
             if c and c.exists:  # Be careful: the command could destroy c.
                 c.inCommand = False
-                c.k.funcReturn = val
+                ## c.k.funcReturn = return_value
         except Exception:
             c.inCommand = False
             if g.app.unitTesting:
@@ -46,4 +49,5 @@
     # Be careful: the command could destroy c.
     if c and c.exists:
         p = c.p
-        g.doHook("command2", c=c, p=p, label=label)
+        g.doHook("command2", c=c, p=p, label=command_name)
+    return return_value
@language python
#@+node:ekr.20200725105320.30: *11* Old:c.doCommand
command_count = 0

def doCommand(self, command, label, event=None):
    """
    Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True
        g.error('ignoring command: already executing a command.')
        return
    g.app.commandInterruptFlag = False
    if label and event is None:  # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label
    if not g.doHook("command1", c=c, p=p, label=label):
        try:
            c.inCommand = True
            val = c.executeAnyCommand(command, event)
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=label)
#@+node:ekr.20031218072017.2817: *11* c.doCommand
command_count = 0

def doCommand(self, command_func, command_name, event):
    """
    Execute the given command function, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the
    command func if g.doHook("command1") returns False. This provides a
    simple mechanism for overriding commands.
    """
    c, p = self, self.p
    c.setLog()
    self.command_count += 1
    # New in Leo 6.2. Set command_function and command_name ivars.
    self.command_function = command_func
    self.command_name = command_name
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.blue(c.disableCommandsMessage)
        return None
    if c.exists and c.inCommand and not g.unitTesting:
        g.app.commandInterruptFlag = True
        g.error('ignoring command: already executing a command.')
        return None
    g.app.commandInterruptFlag = False
    if not g.doHook("command1", c=c, p=p, label=command_name):
        try:
            c.inCommand = True
            try:
                return_value = command_func(event)
            except Exception:
                g.es_exception()
                return_value = None
            if c and c.exists:  # Be careful: the command could destroy c.
                c.inCommand = False
                ## c.k.funcReturn = return_value
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            g.es_print("exception executing command")
            g.es_exception(c=c)
        if c and c.exists:
            if c.requestCloseWindow:
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()
    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2", c=c, p=p, label=command_name)
    return return_value
#@+node:ekr.20200725105320.31: *10* c.universalCallback & minibufferCallback
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -45,6 +45,7 @@
     minibufferCallback.source_c = source_c
         # For GetArgs.command_source
     return minibufferCallback
+
 #fix bobjack's spelling error
 
 universallCallback = universalCallback
@language python
#@+node:ekr.20200725105320.32: *11* Old:c.universalCallback & minibufferCallback
def universalCallback(self, source_c, function):
    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """

    def minibufferCallback(event, function=function):
        # Avoid a pylint complaint.
        if hasattr(self, 'theContextMenuController'):
            cm = getattr(self, 'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None
        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}
        keywords['mb_event'] = event
        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
        # For g.getDocStringForFunction
    minibufferCallback.source_c = source_c
        # For GetArgs.command_source
    return minibufferCallback
#fix bobjack's spelling error

universallCallback = universalCallback
#@+node:bobjack.20080509080123.2: *11* c.universalCallback & minibufferCallback
def universalCallback(self, source_c, function):
    """Create a universal command callback.

    Create and return a callback that wraps a function with an rClick
    signature in a callback which adapts standard minibufer command
    callbacks to a compatible format.

    This also serves to allow rClick callback functions to handle
    minibuffer commands from sources other than rClick menus so allowing
    a single function to handle calls from all sources.

    A function wrapped in this wrapper can handle rclick generator
    and invocation commands and commands typed in the minibuffer.

    It will also be able to handle commands from the minibuffer even
    if rclick is not installed.
    """

    def minibufferCallback(event, function=function):
        # Avoid a pylint complaint.
        if hasattr(self, 'theContextMenuController'):
            cm = getattr(self, 'theContextMenuController')
            keywords = cm.mb_keywords
        else:
            cm = keywords = None
        if not keywords:
            # If rClick is not loaded or no keywords dict was provided
            #  then the command must have been issued in a minibuffer
            #  context.
            keywords = {'c': self, 'rc_phase': 'minibuffer'}
        keywords['mb_event'] = event
        retval = None
        try:
            retval = function(keywords)
        finally:
            if cm:
                # Even if there is an error:
                #   clear mb_keywords prior to next command and
                #   ensure mb_retval from last command is wiped
                cm.mb_keywords = None
                cm.mb_retval = retval

    minibufferCallback.__doc__ = function.__doc__
        # For g.getDocStringForFunction
    minibufferCallback.source_c = source_c
        # For GetArgs.command_source
    return minibufferCallback

#fix bobjack's spelling error

universallCallback = universalCallback
#@+node:ekr.20200725105320.33: *10* c.deletePositionsInList
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,41 +1,29 @@
-def deletePositionsInList(self, aList, callback=None, redraw=True):
+def deletePositionsInList(self, aList, redraw=True):
     """
-    Delete all vnodes corresponding to the positions in aList. If a
-    callback is given, the callback is called for every node in the list.
+    Delete all vnodes corresponding to the positions in aList.
 
-    The callback takes one explicit argument, p. As usual, the callback can
-    bind values using keyword arguments.
+    See "Theory of operation of c.deletePositionsInList" in LeoDocs.leo.
+    """
+    # New implementation by Vitalije 2020-03-17 17:29 
+    c = self
+    # Ensure all positions are valid.
+    aList = [p for p in aList if c.positionExists(p)]
+    if not aList:
+        return []
 
-    This is *very* tricky code. The theory of operation section explains why.
-    """
-    << theory of operation >>
-    c = self
-    # Verify all positions *before* altering the tree.
-    aList2 = []
-    for p in aList:
-        if c.positionExists(p):
-            aList2.append(p.copy())
-        else:
-            g.trace('invalid position', p)
-    if not aList2:
-        return  # Don't redraw the screen unless necessary!
-    # Delete p.v for all positions p in reversed(sorted(aList2)).
-    if callback:
-        for p in reversed(sorted(aList2)):
-            if c.positionExists(p):
-                callback(p)
-    else:
-        for p in reversed(sorted(aList2)):
-            if c.positionExists(p):
-                v = p.v
-                parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
-                if v in parent_v.children:
-                    childIndex = parent_v.children.index(v)
-                    v._cutLink(childIndex, parent_v)
-    # Make sure c.hiddenRootNode always has at least one child.
-    if not c.hiddenRootNode.children:
-        v = leoNodes.VNode(context=c)
-        v._addCopiedLink(childIndex=0, parent_v=c.hiddenRootNode)
+    def p2link(p):
+        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
+        return p._childIndex, parent_v
+
+    links_to_be_cut = sorted(set(map(p2link, aList)), key=lambda x:-x[0])
+    undodata = []
+    for i, v in links_to_be_cut:
+        ch = v.children.pop(i)
+        ch.parents.remove(v)
+        undodata.append((v.gnx, i, ch.gnx))
     if redraw:
-        c.selectPosition(c.rootPosition())
-            # Calls redraw()
+        if not c.positionExists(c.p):
+            c.setCurrentPosition(c.rootPosition())
+        c.redraw()
+    return undodata
+
@language python
#@+node:ekr.20200725105320.34: *11* Old:c.deletePositionsInList
def deletePositionsInList(self, aList, callback=None, redraw=True):
    """
    Delete all vnodes corresponding to the positions in aList. If a
    callback is given, the callback is called for every node in the list.

    The callback takes one explicit argument, p. As usual, the callback can
    bind values using keyword arguments.

    This is *very* tricky code. The theory of operation section explains why.
    """
    << theory of operation >>
    c = self
    # Verify all positions *before* altering the tree.
    aList2 = []
    for p in aList:
        if c.positionExists(p):
            aList2.append(p.copy())
        else:
            g.trace('invalid position', p)
    if not aList2:
        return  # Don't redraw the screen unless necessary!
    # Delete p.v for all positions p in reversed(sorted(aList2)).
    if callback:
        for p in reversed(sorted(aList2)):
            if c.positionExists(p):
                callback(p)
    else:
        for p in reversed(sorted(aList2)):
            if c.positionExists(p):
                v = p.v
                parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
                if v in parent_v.children:
                    childIndex = parent_v.children.index(v)
                    v._cutLink(childIndex, parent_v)
    # Make sure c.hiddenRootNode always has at least one child.
    if not c.hiddenRootNode.children:
        v = leoNodes.VNode(context=c)
        v._addCopiedLink(childIndex=0, parent_v=c.hiddenRootNode)
    if redraw:
        c.selectPosition(c.rootPosition())
            # Calls redraw()
#@+node:ekr.20100802121531.5804: *11* c.deletePositionsInList
def deletePositionsInList(self, aList, redraw=True):
    """
    Delete all vnodes corresponding to the positions in aList.

    See "Theory of operation of c.deletePositionsInList" in LeoDocs.leo.
    """
    # New implementation by Vitalije 2020-03-17 17:29 
    c = self
    # Ensure all positions are valid.
    aList = [p for p in aList if c.positionExists(p)]
    if not aList:
        return []

    def p2link(p):
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        return p._childIndex, parent_v

    links_to_be_cut = sorted(set(map(p2link, aList)), key=lambda x:-x[0])
    undodata = []
    for i, v in links_to_be_cut:
        ch = v.children.pop(i)
        ch.parents.remove(v)
        undodata.append((v.gnx, i, ch.gnx))
    if redraw:
        if not c.positionExists(c.p):
            c.setCurrentPosition(c.rootPosition())
        c.redraw()
    return undodata

#@+node:ekr.20200725105324.1: *8* leo/core/leoKeys.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -5,13 +5,11 @@
 """Gui-independent keystroke handling for Leo."""
 # pylint: disable=eval-used
 # pylint: disable=deprecated-method
-    # The new methods may not exist in Python 2.
#@verbatim
 #@+<< imports >>
#@verbatim
 #@+node:ekr.20061031131434.1: ** << imports >> (leoKeys)
 import leo.core.leoGlobals as g
 import leo.commands.gotoCommands as gotoCommands
 import leo.external.codewise as codewise
-# import glob
 import inspect
 import os
 import re
@@ -66,9 +64,7 @@
 #    bindings are as expeced.
 #
 # B. If k.getPaneBinding finds a command associated with the incoming
-#    keystroke, k.masterKeyHandler calls k.masterCommand to execute the
-#    command. k.masterCommand handles many complex. See the source code for
-#    details.
+#    keystroke, k.masterKeyHandler executes the command.
 #
 # C. If k.getPaneBinding fails to bind the incoming keystroke to a command,
 #    k.masterKeyHandler calls k.handleUnboundKeys to handle the keystroke.
@@ -194,21 +190,22 @@
     def autoComplete(self, event=None, force=False):
         """An event handler for autocompletion."""
         c, k = self.c, self.k
-        state = k.unboundKeyAction
         # pylint: disable=consider-using-ternary
         w = event and event.w or c.get_focus()
         self.force = force
-        if state not in ('insert', 'overwrite'):
+        if k.unboundKeyAction not in ('insert', 'overwrite'):
             return
-        # First, handle the invocation character as usual.
         if not force:
-            # Ctrl-period does *not* insert a period.
-            k.masterCommand(event=event)
+            # Ctrl-period does *not* insert a period,
+            # but plain periods *must* be inserted!
+            c.insertCharFromEvent(event)
+        if c.exists:
+            c.frame.updateStatusLine()
         # Allow autocompletion only in the body pane.
         if not c.widget_name(w).lower().startswith('body'):
             return
         self.language = g.scanForAtLanguage(c, c.p)
-        if w and (k.enable_autocompleter or force):  # self.language == 'python':
+        if w and (k.enable_autocompleter or force):
             self.w = w
             self.start(event)
#@verbatim
     #@+node:ekr.20061031131434.10: *4* ac.autoCompleteForce
@@ -256,17 +253,17 @@
     @cmd('show-calltips')
     def showCalltips(self, event=None, force=False):
         """Show the calltips at the cursor."""
-        c = self.c; k = c.k
+        c, k = self.c, self.c.k
         w = event and event.w
-        if not w: return
+        if not w:
+            return
         is_headline = c.widget_name(w).startswith('head')
         # Insert the calltip if possible, but not in headlines.
         if (k.enable_calltips or force) and not is_headline:
             self.w = w
             self.calltip()
         else:
-            # Just insert the invocation character as usual.
-            k.masterCommand(event=event)
+            c.insertCharFromEvent(event)
#@verbatim
     #@+node:ekr.20061031131434.14: *4* ac.showCalltipsForce
     @cmd('show-calltips-force')
     def showCalltipsForce(self, event=None):
@@ -325,6 +322,7 @@
         i = s.rfind('.', 0, -1)
         if i > -1:
             self.setTabName(s[0:i])
+
     # Underscores are not valid in Pmw tab names!
 
     def setTabName(self, s):
@@ -861,13 +859,13 @@
                 extend = common_prefix[len(prefix) :]
                 ins = w.getInsertPoint()
                 w.insert(ins, extend)
-        else:
-            if ch == '(' and k.enable_calltips:
-                # This calls self.exit if the '(' is valid.
-                self.calltip()
-            else:
-                self.insert_string(ch)
-                self.exit()
+            return
+        if ch == '(' and k.enable_calltips:
+            # This calls self.exit if the '(' is valid.
+            self.calltip()
+        else:
+            self.insert_string(ch)
+            self.exit()
#@verbatim
     #@+node:ekr.20061031131434.31: *4* ac.insert_string
     def insert_string(self, s, select=False):
         """Insert s at the insertion point."""
@@ -1238,7 +1236,7 @@
#@verbatim
     #@+node:ekr.20140817110228.18321: *3* ga.compute_tab_list
     # Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())
 
-    def compute_tab_list(self, tabList, backspace=False, allow_empty_completion=False):
+    def compute_tab_list(self, tabList):
         """Compute and show the available completions."""
         # Support vim-mode commands.
         command = self.get_label()
@@ -1484,7 +1482,6 @@
         self.tabList = tabList[:] if tabList else []
         #
         # Set the k globals...
-        k.argSelectedText = c.frame.body.wrapper.getSelectedText()
         k.functionTail = None
         k.oneCharacterArg = oneCharacter
         #
@@ -1636,27 +1633,18 @@
         self.setDefaultEditingAction()
#@verbatim
     #@+node:ekr.20061031131434.78: *5* k.defineExternallyVisibleIvars
     def defineExternallyVisibleIvars(self):
-        self.abbrevOn = False
-            # True: abbreviations are on.
-        self.arg = ''
-            # The value returned by k.getArg.
-        self.argSelectedText = ''  # The selected text in state 0.
-        self.commandName = None  # The name of the command being executed.
-        self.funcReturn = None  # For k.simulateCommand
-        self.functionTail = None  # For commands that take minibuffer arguments.
-        # These are true globals
+
+        self.abbrevOn = False  # True: abbreviations are on.
+        self.arg = ''  # The value returned by k.getArg.
+        self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
         self.getArgEscapes = []
-        self.getArgEscapeFlag = False  # A signal that the user escaped getArg in an unusual way.
-        self.givenArgs = []
-             # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
-        self.inputModeBindings = {}
         self.inputModeName = ''  # The name of the input mode, or None.
         self.modePrompt = ''  # The mode promopt.
-        self.negativeArg = False
-        self.newMinibufferWidget = None  # Usually the minibuffer restores focus.  This overrides this default.
-        # self.regx = g.bunch(iter=None,key=None)
-        self.repeatCount = None
         self.state = g.bunch(kind=None, n=None, handler=None)
+        
+        # Remove ???
+        self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
+        self.functionTail = None  # For commands that take minibuffer arguments.
#@verbatim
     #@+node:ekr.20061031131434.79: *5* k.defineInternalIvars
     def defineInternalIvars(self):
         """Define internal ivars of the KeyHandlerClass class."""
@@ -2246,7 +2234,7 @@
                 if stroke and not pane.endswith('-mode'):
                     k.bindKey(pane, stroke, command, commandName, tag=tag)
#@verbatim
     #@+node:ekr.20061031131434.103: *4* k.makeMasterGuiBinding
-    def makeMasterGuiBinding(self, stroke, w=None, trace=False):
+    def makeMasterGuiBinding(self, stroke, w=None):
         """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
         k = self; c = k.c; f = c.frame
         if w:
@@ -2278,7 +2266,6 @@
             h.remove(commandName)
         h.append(commandName)
         k.commandIndex = None
-
#@verbatim
     #@+node:ekr.20150402165918.1: *4* k.commandHistoryDown
     def commandHistoryFwd(self):
         """
@@ -2430,7 +2417,6 @@
 
         else:
             func = c.commandsDict.get(commandName)
-        k.newMinibufferWidget = None
         if func:
             # These must be done *after* getting the command.
             k.clearState()
@@ -2440,48 +2426,20 @@
             w = event and event.widget
             if hasattr(w, 'permanent') and not w.permanent:
                 # In a headline that is being edited.
-                # g.es('Can not execute commands from headlines')
                 c.endEditing()
                 c.bodyWantsFocusNow()
                 # Change the event widget so we don't refer to the to-be-deleted headline widget.
                 event.w = event.widget = c.frame.body.wrapper.widget
-                c.executeAnyCommand(func, event)
             else:
-                c.widgetWantsFocusNow(event and event.widget)
-                    # Important, so cut-text works, e.g.
-                c.executeAnyCommand(func, event)
-            k.endCommand(commandName)
+                c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
+            try:
+                func(event)
+            except Exception:
+                g.es_exception()
             return True
-        #
         # Show possible completions if the command does not exist.
-        if 1:  # Useful.
-            k.doTabCompletion(list(c.commandsDict.keys()))
-        else:  # Annoying.
-            k.keyboardQuit()
-            k.setStatusLabel(f"Command does not exist: {commandName}")
-            c.bodyWantsFocus()
+        k.doTabCompletion(list(c.commandsDict.keys()))
         return False
-    #@+node:ekr.20061031131434.113: *4* k.endCommand
-    def endCommand(self, commandName):
-        """Make sure Leo updates the widget following a command.
-
-        Never changes the minibuffer label: individual commands must do that.
-        """
-        k = self; c = k.c
-        # The command may have closed the window.
-        if g.app.quitting or not c.exists: return
-        # Set the best possible undoType: prefer explicit commandName to k.commandName.
-        commandName = commandName or k.commandName or ''
-        k.commandName = k.commandName or commandName or ''
-        if commandName:
-            if not k.inState():
-                k.commandName = None
-            if 0:  # Do *not* call this by default.  It interferes with undo.
-                c.frame.body.onBodyChanged(undoType='Typing')
-            if k.newMinibufferWidget:
-                c.widgetWantsFocusNow(k.newMinibufferWidget)
-                # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
-                k.newMinibufferWidget = None
#@verbatim
     #@+node:ekr.20061031131434.114: *3* k.Externally visible commands
#@verbatim
     #@+node:ekr.20070613133500: *4* k.menuCommandKey
     def menuCommandKey(self, event=None):
@@ -2621,7 +2579,7 @@
             k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
             k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
         else:
-            g.warning('no previous command')
+            g.warning('no previous minibuffer command')
#@verbatim
     #@+node:ekr.20131017100903.16689: *5* repeatComplexCommandHelper
     def repeatComplexCommandHelper(self, event):
         k = self; c = k.c
@@ -2630,7 +2588,11 @@
             last = k.mb_history[0]
             k.resetLabel()
             k.clearState()  # Bug fix.
-            c.commandsDict[last](event)
+            if last.isdigit():
+                # Special case: for the number Easter Egg.
+                c.goToLineNumber(int(last))
+            else:
+                c.commandsDict[last](event)
         else:
             k.keyboardQuit()
#@verbatim
     #@+node:ekr.20061031131434.123: *4* k.set-xxx-State
@@ -2811,17 +2773,11 @@
         return self.getArgInstance.get_minibuffer_command_name()
#@verbatim
     #@+node:ekr.20061031131434.130: *4* k.keyboardQuit
     @cmd('keyboard-quit')
-    def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
-        """
-        This method clears the state and the minibuffer label.
-
-        k.endCommand handles all other end-of-command chores.
-        """
+    def keyboardQuit(self, event=None, setFocus=True):
+        """Clears the state and the minibuffer label."""
         k = self; c = k.c
         if g.app.quitting:
             return
-        # 2011/05/30: We may be called from Qt event handlers.
-        # Make sure to end editing!
         c.endEditing()
         # Completely clear the mode.
         if setFocus:
@@ -2959,47 +2915,14 @@
                     if d.get(key) == commandName:
                         c.commandsDict[key] = c.commandsDict.get(commandName)
                         break
-    #@+node:ekr.20061031131434.127: *4* k.simulateCommand & k.commandExists
+    #@+node:ekr.20061031131434.127: *4* k.simulateCommand
     def simulateCommand(self, commandName, event=None):
         """Execute a Leo command by name."""
-        c, k = self.c, self
-        func = self.commandExists(commandName)
-        if func:
-            # Support @g.commander_command
-            c_func = getattr(c, func.__name__, None)
-            if c_func:
-                return c_func(event=event)
-            if event:
-                pass
-            elif commandName.startswith('specialCallback'):
-                event = None  # A legacy function.
-            else:  # Create a dummy event as a signal.
-                event = g.app.gui.create_key_event(c)
-            k.masterCommand(event=event, func=func)
-            if c.exists:
-                return k.funcReturn
-            return None
-        if g.app.unitTesting:
-            raise AttributeError(f"no such command: {commandName}")
-        if g.app.inBridge:
-            raise AttributeError(f"no such command: {commandName}")
-        g.error(f"simulateCommand: no command for {commandName}")
-        return None
-    #@+node:ekr.20170324143353.1: *5* k.commandExists
-    def commandExists(self, commandName):
-        """Return the command handler for the given command name, or None."""
-        c, k = self.c, self
-        commandName = commandName.strip()
-        if commandName:
-            aList = commandName.split(None)
-            if len(aList) == 1:
-                k.givenArgs = []
-            else:
-                commandName = aList[0]
-                k.givenArgs = aList[1:]
-            func = c.commandsDict.get(commandName)
-            return func
-        return None
+        c = self.c
+        if not event:
+            # Create a default key event.
+            event = g.app.gui.create_key_event(c)
+        c.doCommandByName(commandName, event)
#@verbatim
     #@+node:ekr.20140813052702.18203: *4* k.getFileName
     def getFileName(self, event, callback=None,
         filterExt=None, prompt='Enter File Name: ', tabName='Dired'
@@ -3011,7 +2934,7 @@
#@verbatim
     #@+node:ekr.20061031131434.146: *4* k.masterKeyHandler & helpers
     def masterKeyHandler(self, event):
         """The master key handler for almost all key bindings."""
-        k = self
+        c, k = self.c, self
         # Setup...
         if 'keys' in g.app.debug:
             g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
@@ -3021,6 +2944,8 @@
         # Order is very important here...
         if k.isSpecialKey(event):
             return
+        # Add *all* characters to the lossage.
+        k.setLossage(event.char, event.stroke)
         if k.doKeyboardQuit(event):
             return
         if k.doDemo(event):
@@ -3029,11 +2954,14 @@
             return
         if k.doVim(event):
             return
-        if k.doUnboundPlainKey(event):
+        if k.doBinding(event):
             return
-        k.doBinding(event)
-            # Calls handleUnboundKeys if no binding.
-    #@+node:ekr.20180418040158.1: *5* k.checkKeyEvent
+        # Handle abbreviations.
+        if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
+            return
+        c.insertCharFromEvent(event)
+    #@+node:ekr.20200524151214.1: *5* Setup...
+    #@+node:ekr.20180418040158.1: *6* k.checkKeyEvent
     def checkKeyEvent(self, event):
         """Perform sanity checks on the incoming event."""
         # These assert's should be safe, because eventFilter
@@ -3049,48 +2977,72 @@
         if event:
             assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
                 # A continuous unit test, better than "@test k.isPlainKey".
-
-    #@+node:ekr.20180418033838.1: *5* k.doBinding
-    def doBinding(self, event):
-        """
-        The last phase of k.masertKeyHandler.
-        Execute the command associated with stroke's binding.
-        Call k.handleUnboundKeys for killed or non-existent bindings.
+    #@+node:ekr.20180418034305.1: *6* k.setEventWidget
+    def setEventWidget(self, event):
+        """
+        A hack: redirect the event to the text part of the log.
+        """
+        c = self.c
+        w = event.widget
+        w_name = c.widget_name(w)
+        if w_name.startswith('log'):
+            event.widget = c.frame.log.logCtrl
+    #@+node:ekr.20180418031417.1: *6* k.traceVars
+    def traceVars(self, event):
+
+        trace = False and not g.unitTesting
+        traceGC = False
+        verbose = False
+        k = self
+        if not trace:
+            return
+        if traceGC:
+            g.printNewObjects('masterKey 1')
+        if verbose:
+            char = event.char
+            state = k.state.kind
+            stroke = event.stroke
+            g.trace(
+                f"stroke: {stroke!r}, "
+                f"char: {char!r}, "
+                f"state: {state}, "
+                f"state2: {k.unboundKeyAction}")
+    #@+node:ekr.20180418031118.1: *5* 1. k.isSpecialKey
+    def isSpecialKey(self, event):
+        """Return True if char is a special key."""
+        if not event:
+            # An empty event is not an error.
+            return False
+        # Fix #917.
+        if len(event.char) > 1 and not event.stroke.s:
+            # stroke.s was cleared, but not event.char.
+            return True
+        return event.char in g.app.gui.ignoreChars
+    #@+node:ekr.20110609161752.16459: *5* 2. k.setLossage
+    def setLossage(self, ch, stroke):
+
+        # k = self
+        if ch or stroke:
+            if len(g.app.lossage) > 99:
+                g.app.lossage.pop()
+        # This looks like a memory leak, but isn't.
+        g.app.lossage.insert(0, (ch, stroke),)
+    #@+node:ekr.20180418024449.1: *5* 3. k.doKeyboardQuit
+    def doKeyboardQuit(self, event):
+        """
+        A helper for k.masterKeyHandler: Handle keyboard-quit logic.
+        
+        return True if k.masterKeyHandler should return.
         """
         c, k = self.c, self
-        char, stroke, w = event.char, event.stroke, event.widget
-        #
-        # Use getPaneBindings for *all* keys.
-        #
-        bi = k.getPaneBinding(stroke, w)
-        #
-        # Call k.handleUnboudKeys for all killed bindings.
-        #
-        if bi and bi.commandName in k.killedBindings:
-            #327: ignore killed bindings.
-            k.handleUnboundKeys(event)
-            return
-        #
-        # Call k.masterCommandHandler if the binding exists.
-        #
-        if bi:
-            k.masterCommand(
-                event=event,
-                commandName=bi.commandName,
-                func=bi.func,
-                stroke=bi.stroke)
-            return
-        #
-        # Handle unbound keys in the tree (not headlines).
-        #
-        if c.widget_name(w).startswith('canvas'):
-            k.searchTree(char)
-            return
-        #
-        # No binding exists. Call k.handleUnboundKey.
-        #
-        k.handleUnboundKeys(event)
-    #@+node:ekr.20180418023827.1: *5* k.doDemo
+        stroke = getattr(event, 'stroke', None)
+        if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
+            if getattr(c, 'screenCastController', None):
+                c.screenCastController.quit()
+            c.doCommandByName('keyboard-quit', event)
+            return True
+        return False
+    #@+node:ekr.20180418023827.1: *5* 4. k.doDemo
     def doDemo(self, event):
         """
         Support the demo.py plugin.
@@ -3114,97 +3066,7 @@
             demo.prev_command()
             return True
         return False
-    #@+node:ekr.20061031131434.108: *5* k.callStateFunction
-    def callStateFunction(self, event):
-        """Call the state handler associated with this event."""
-        k = self
-        ch = event.char
-        #
-        # Defensive programming
-        #
-        if not k.state.kind:
-            return None
-        if not k.state.handler:
-            g.error('callStateFunction: no state function for', k.state.kind)
-            return None
-        #
-        # Handle auto-completion before checking for unbound keys.
-        #
-        if k.state.kind == 'auto-complete':
-            # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
-            val = k.state.handler(event)
-            return val
-        #
-        # Ignore unbound non-ascii keys.
-        #
-        if (
-            k.ignore_unbound_non_ascii_keys and
-            len(ch) == 1 and
-            ch and ch not in ('\b', '\n', '\r', '\t') and
-            (ord(ch) < 32 or ord(ch) > 128)
-        ):
-            return None
-        #
-        # Call the state handler.
-        #
-        val = k.state.handler(event)
-        if val != 'continue':
-            k.endCommand(k.commandName)
-        return val
-    #@+node:ekr.20180418025702.1: *5* k.doUnboundPlainKey & helper
-    def doUnboundPlainKey(self, event):
-        """
-        Handle unbound plain keys.
-        Return True if k.masterKeyHandler should return.
-        """
-        c, k = self.c, self
-        stroke, w = event.stroke, event.widget
-        #
-        # Ignore non-plain keys.
-        if not k.isPlainKey(stroke):
-            return False
-        #
-        # Ignore any keys in the background tree widget.
-        if c.widget_name(w).startswith('canvas'):
-            return False
-        #
-        # Ignore the char if it is bound to the auto-complete command.
-        if self.isAutoCompleteChar(stroke):
-            return False
-        #
-        # Handle the unbound key.
-        k.handleUnboundKeys(event)
-        return True
-    #@+node:ekr.20110209083917.16004: *6* k.isAutoCompleteChar
-    def isAutoCompleteChar(self, stroke):
-        """
-        Return True if stroke is bound to the auto-complete in
-        the insert or overwrite state.
-        """
-        k = self; state = k.unboundKeyAction
-        assert g.isStrokeOrNone(stroke)
-        if stroke and state in ('insert', 'overwrite'):
-            for key in (state, 'body', 'log', 'text', 'all'):
-                d = k.masterBindingsDict.get(key, {})
-                if d:
-                    bi = d.get(stroke)
-                    if bi:
-                        assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
-                        if bi.commandName == 'auto-complete':
-                            return True
-        return False
-    #@+node:ekr.20180418025241.1: *5* k.doVim
-    def doVim(self, event):
-        """
-        Handle vim mode.
-        Return True if k.masterKeyHandler should return.
-        """
-        c = self.c
-        if c.vim_mode and c.vimCommands:
-            ok = c.vimCommands.do_key(event)
-            return ok
-        return False
-    #@+node:ekr.20091230094319.6244: *5* k.doMode
+    #@+node:ekr.20091230094319.6244: *5* 5. k.doMode & helpers
     def doMode(self, event):
         """
         Handle mode bindings.
@@ -3270,171 +3132,38 @@
         if handler:
             handler(event)
         return True
-    #@+node:ekr.20091230094319.6240: *5* k.getPaneBinding & helper
-    def getPaneBinding(self, stroke, w):
-
+    #@+node:ekr.20061031131434.108: *6* k.callStateFunction
+    def callStateFunction(self, event):
+        """Call the state handler associated with this event."""
         k = self
-        if not g.assert_is(stroke, g.KeyStroke):
+        ch = event.char
+        #
+        # Defensive programming
+        if not k.state.kind:
             return None
-        for key, name in (
-            # Order here is similar to bindtags order.
-            ('command', None),
-            ('insert', None),
-            ('overwrite', None),
-            ('button', None),
-            ('body', 'body'),
-            ('text', 'head'),  # Important: text bindings in head before tree bindings.
-            ('tree', 'head'),
-            ('tree', 'canvas'),
-            ('log', 'log'),
-            ('text', 'log'),
-            ('text', None),
-            ('all', None),
-        ):
-            val = k.getBindingHelper(key, name, stroke, w)
-            if val:
-                return val
-        return None
-    #@+node:ekr.20180418105228.1: *6* getPaneBindingHelper
-    def getBindingHelper(self, key, name, stroke, w):
-        """Find a binding for the widget with the given name."""
-        c, k = self.c, self
-        #
-        # Return if the pane's name doesn't match the event's widget.
-        state = k.unboundKeyAction
-        w_name = c.widget_name(w)
-        pane_matches = (
-            name and w_name.startswith(name) or
-            key in ('command', 'insert', 'overwrite') and state == key or
-            key in ('text', 'all') and g.isTextWrapper(w) or
-            key in ('button', 'all')
-        )
-        if not pane_matches:
+        if not k.state.handler:
+            g.error('callStateFunction: no state function for', k.state.kind)
             return None
         #
-        # Return if there is no binding at all.
-        d = k.masterBindingsDict.get(key, {})
-        if not d:
-            return None
-        bi = d.get(stroke)
-        if not bi:
-            return None
+        # Handle auto-completion before checking for unbound keys.
+        if k.state.kind == 'auto-complete':
+            # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
+            val = k.state.handler(event)
+            return val
         #
-        # Ignore previous/next-line commands while editing headlines.
+        # Ignore unbound non-ascii keys.
         if (
-            key == 'text' and
-            name == 'head' and
-            bi.commandName in ('previous-line', 'next-line')
+            k.ignore_unbound_non_ascii_keys and
+            len(ch) == 1 and
+            ch and ch not in ('\b', '\n', '\r', '\t') and
+            (ord(ch) < 32 or ord(ch) > 128)
         ):
             return None
         #
-        # The binding has been found.
-        return bi
-    #@+node:ekr.20061031131434.110: *5* k.handleDefaultChar
-    def handleDefaultChar(self, event, stroke):
-        """
-        Handle an unbound key, based on the event's widget.
-        Do not assume that stroke exists.
-        """
-        c, k, w = self.c, self, event.widget
-        name = c.widget_name(w)
-        #
-        # Ignore unbound alt-ctrl key
-        if stroke and stroke.isAltCtrl() and k.ignore_unbound_non_ascii_keys:
-            g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
-            return
-        #
-        # Handle events in the body pane.
-        if name.startswith('body'):
-            action = k.unboundKeyAction
-            if action in ('insert', 'overwrite'):
-                c.editCommands.selfInsertCommand(event, action=action)
-            else:
-                pass  # Ignore the key
-            return
-        #
-        # Handle events in headlines.
-        if name.startswith('head'):
-            c.frame.tree.onHeadlineKey(event)
-            return
-        #
-        # Handle events in the background tree.
-        if name.startswith('canvas'):
-            if not stroke:  # Not exactly right, but it seems to be good enough.
-                c.onCanvasKey(event)
-            return
-        #
-        # Handle events in the log pane.
-        if name.startswith('log'):
-            # Make sure we can insert into w.
-            log_w = event.widget
-            if not hasattr(log_w, 'supportsHighLevelInterface'):
-                return
-            # Send the event to the text widget, not the LeoLog instance.
-            if not stroke:
-                stroke = event.stroke
-            if stroke:
-                i = log_w.getInsertPoint()
-                s = stroke.toGuiChar()
-                log_w.insert(i, s)
-            return
-        #
-        # Ignore all other events.
-    #@+node:vitalije.20170708161511.1: *5* k.handleInputShortcut
-    def handleInputShortcut(self, event, stroke):
-        c, k, p = self.c, self, self.c.p
-        k.clearState()
-        if p.h.startswith(('@shortcuts', '@mode')):
-            # line of text in body
-            w = c.frame.body
-            before, sel, after = w.getInsertLines()
-            m = k._cmd_handle_input_pattern.search(sel)
-            assert m  # edit-shortcut was invoked on a malformed body line
-            sel = f"{m.group(0)} {stroke.s}"
-            udata = c.undoer.beforeChangeNodeContents(p)
-            w.setSelectionAreas(before, sel, after)
-            c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
-            w.onBodyChanged('change shortcut')
-            cmdname = m.group(0).rstrip('= ')
-            k.editShortcut_do_bind_helper(stroke, cmdname)
-            return
-        if p.h.startswith(('@command', '@button')):
-            udata = c.undoer.beforeChangeNodeContents(p)
-            cmd = p.h.split('@key', 1)[0]
-            p.h = f"{cmd} @key={stroke.s}"
-            c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
-            try:
-                cmdname = cmd.split(' ', 1)[1].strip()
-                k.editShortcut_do_bind_helper(stroke, cmdname)
-            except IndexError:
-                pass
-            return
-        # this should never happen
-        g.error('not in settings node shortcut')
-    #@+node:vitalije.20170709151653.1: *6* k.isInShortcutBodyLine
-    _cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')
-
-    def isInShortcutBodyLine(self):
-        k = self; c = k.c; p = c.p
-        if p.h.startswith(('@shortcuts', '@mode')):
-            # line of text in body
-            w = c.frame.body
-            before, sel, after = w.getInsertLines()
-            m = k._cmd_handle_input_pattern.search(sel)
-            return bool(m)
-        return p.h.startswith(('@command', '@button'))
-    #@+node:vitalije.20170709151658.1: *6* k.isEditShortcutSensible
-    def isEditShortcutSensible(self):
-        k = self; c = k.c; p = c.p
-        return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
-    #@+node:vitalije.20170709202924.1: *6* k.editShortcut_do_bind_helper
-    def editShortcut_do_bind_helper(self, stroke, cmdname):
-        k = self; c = k.c
-        cmdfunc = c.commandsDict.get(cmdname)
-        if cmdfunc:
-            k.bindKey('all', stroke, cmdfunc, cmdname)
-            g.es('bound', stroke, 'to command', cmdname)
-    #@+node:ekr.20061031131434.152: *5* k.handleMiniBindings
+        # Call the state handler.
+        val = k.state.handler(event)
+        return val
+    #@+node:ekr.20061031131434.152: *6* k.handleMiniBindings
     def handleMiniBindings(self, event, state, stroke):
         """Find and execute commands bound to the event."""
         k = self
@@ -3476,11 +3205,10 @@
         #
         # No binding exists.
         return False
-    #@+node:ekr.20180418114300.1: *6* k.handleMinibufferHelper
+    #@+node:ekr.20180418114300.1: *7* k.handleMinibufferHelper
     def handleMinibufferHelper(self, event, pane, state, stroke):
         """
         Execute a pane binding in the minibuffer.
-        
         Return 'continue', 'ignore', 'found'
         """
         c, k = self.c, self
@@ -3491,24 +3219,15 @@
         if not bi:
             return 'continue'
         assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
-        #
-        # Special case the replace-string command in the minibuffer.
-        #
+        # Ignore the replace-string command in the minibuffer.
         if bi.commandName == 'replace-string' and state == 'getArg':
             return 'ignore'
-        #
         # Execute this command.
-        #
         if bi.commandName not in k.singleLineCommandList:
             k.keyboardQuit()
         else:
-            c.minibufferWantsFocus()  # New in Leo 4.5.
-        # Pass this on for macro recording.
-        k.masterCommand(
-            commandName=bi.commandName,
-            event=event,
-            func=bi.func,
-            stroke=stroke)
+            c.minibufferWantsFocus()
+            c.doCommandByName(bi.commandName, event)
         # Careful: the command could exit.
         if c.exists and not k.silentMode:
             # Use the state *after* executing the command.
@@ -3517,196 +3236,155 @@
             else:
                 c.bodyWantsFocus()
         return 'found'
-    #@+node:ekr.20180418031118.1: *5* k.isSpecialKey
-    def isSpecialKey(self, event):
-        """Return True if char is a special key."""
-        if not event:
-            # An empty event is not an error.
-            return False
-        # Fix #917.
-        if len(event.char) > 1 and not event.stroke.s:
-            # stroke.s was cleared, but not event.char.
+    #@+node:vitalije.20170708161511.1: *6* k.handleInputShortcut
+    def handleInputShortcut(self, event, stroke):
+        c, k, p = self.c, self, self.c.p
+        k.clearState()
+        if p.h.startswith(('@shortcuts', '@mode')):
+            # line of text in body
+            w = c.frame.body
+            before, sel, after = w.getInsertLines()
+            m = k._cmd_handle_input_pattern.search(sel)
+            assert m  # edit-shortcut was invoked on a malformed body line
+            sel = f"{m.group(0)} {stroke.s}"
+            udata = c.undoer.beforeChangeNodeContents(p)
+            w.setSelectionAreas(before, sel, after)
+            c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
+            w.onBodyChanged('change shortcut')
+            cmdname = m.group(0).rstrip('= ')
+            k.editShortcut_do_bind_helper(stroke, cmdname)
+            return
+        if p.h.startswith(('@command', '@button')):
+            udata = c.undoer.beforeChangeNodeContents(p)
+            cmd = p.h.split('@key', 1)[0]
+            p.h = f"{cmd} @key={stroke.s}"
+            c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
+            try:
+                cmdname = cmd.split(' ', 1)[1].strip()
+                k.editShortcut_do_bind_helper(stroke, cmdname)
+            except IndexError:
+                pass
+            return
+        # this should never happen
+        g.error('not in settings node shortcut')
+    #@+node:vitalije.20170709151653.1: *7* k.isInShortcutBodyLine
+    _cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')
+
+    def isInShortcutBodyLine(self):
+        k = self; c = k.c; p = c.p
+        if p.h.startswith(('@shortcuts', '@mode')):
+            # line of text in body
+            w = c.frame.body
+            before, sel, after = w.getInsertLines()
+            m = k._cmd_handle_input_pattern.search(sel)
+            return bool(m)
+        return p.h.startswith(('@command', '@button'))
+    #@+node:vitalije.20170709151658.1: *7* k.isEditShortcutSensible
+    def isEditShortcutSensible(self):
+        k = self; c = k.c; p = c.p
+        return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
+    #@+node:vitalije.20170709202924.1: *7* k.editShortcut_do_bind_helper
+    def editShortcut_do_bind_helper(self, stroke, cmdname):
+        k = self; c = k.c
+        cmdfunc = c.commandsDict.get(cmdname)
+        if cmdfunc:
+            k.bindKey('all', stroke, cmdfunc, cmdname)
+            g.es('bound', stroke, 'to command', cmdname)
+    #@+node:ekr.20180418025241.1: *5* 6. k.doVim
+    def doVim(self, event):
+        """
+        Handle vim mode.
+        Return True if k.masterKeyHandler should return.
+        """
+        c = self.c
+        if c.vim_mode and c.vimCommands:
+            ok = c.vimCommands.do_key(event)
+            return ok
+        return False
+    #@+node:ekr.20180418033838.1: *5* 7. k.doBinding & helpers
+    def doBinding(self, event):
+        """
+        Attempt to find a binding for the event's stroke.
+        If found, execute the command and return True
+        Otherwise, return False
+        """
+        c, k = self.c, self
+        #
+        # Use getPaneBindings for *all* keys.
+        bi = k.getPaneBinding(event.stroke, event.w)
+        #
+        # #327: ignore killed bindings.
+        if bi and bi.commandName in k.killedBindings:
+            return False  
+        #
+        # Execute the command if the binding exists.
+        if bi:
+            c.doCommandByName(bi.commandName, event)
             return True
-        return event.char in g.app.gui.ignoreChars
-    #@+node:ekr.20180418024449.1: *5* k.keyboardQuit
-    def doKeyboardQuit(self, event):
-        """
-        Handle keyboard-quit logic.
-        return True if k.masterKeyHandler should return.
-        """
+        #
+        # No binding exists.
+        return False
+    #@+node:ekr.20091230094319.6240: *6* k.getPaneBinding & helper
+    def getPaneBinding(self, stroke, w):
+
+        k = self
+        if not g.assert_is(stroke, g.KeyStroke):
+            return None
+        for key, name in (
+            # Order here is similar to bindtags order.
+            ('command', None),
+            ('insert', None),
+            ('overwrite', None),
+            ('button', None),
+            ('body', 'body'),
+            ('text', 'head'),  # Important: text bindings in head before tree bindings.
+            ('tree', 'head'),
+            ('tree', 'canvas'),
+            ('log', 'log'),
+            ('text', 'log'),
+            ('text', None),
+            ('all', None),
+        ):
+            val = k.getBindingHelper(key, name, stroke, w)
+            if val:
+                return val
+        return None
+    #@+node:ekr.20180418105228.1: *7* getPaneBindingHelper
+    def getBindingHelper(self, key, name, stroke, w):
+        """Find a binding for the widget with the given name."""
         c, k = self.c, self
-        stroke = event.stroke
-        if k.abortAllModesKey and stroke == k.abortAllModesKey:
-            if getattr(c, 'screenCastController', None):
-                c.screenCastController.quit()
-            k.masterCommand(
-                commandName='keyboard-quit',
-                event=event,
-                func=k.keyboardQuit,
-                stroke=stroke)
-            return True
-        return False
-    #@+node:ekr.20080510095819.1: *5* k.handleUnboundKeys
-    def handleUnboundKeys(self, event):
-
-        c, k = self.c, self
-        stroke = event.stroke
-        if not g.assert_is(stroke, g.KeyStroke):
-            return
-        # #1448: Very late special case for getArg state.
-        #        This is not needed for other states.
-        if stroke.isNumPadKey() and k.state.kind == 'getArg':
-            stroke.removeNumPadModifier()
-            k.getArg(event, stroke=stroke)
-            return
         #
-        # Ignore all unbound characters in command mode.
-        if k.unboundKeyAction == 'command':
-            w = g.app.gui.get_focus(c)
-            if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
-                c.onCanvasKey(event)
-            return
+        # Return if the pane's name doesn't match the event's widget.
+        state = k.unboundKeyAction
+        w_name = c.widget_name(w)
+        pane_matches = (
+            name and w_name.startswith(name) or
+            key in ('command', 'insert', 'overwrite') and state == key or
+            key in ('text', 'all') and g.isTextWrapper(w) or
+            key in ('button', 'all')
+        )
+        if not pane_matches:
+            return None
         #
-        # Ignore unbound F-keys.
-        if stroke.isFKey():
-            return
+        # Return if there is no binding at all.
+        d = k.masterBindingsDict.get(key, {})
+        if not d:
+            return None
+        bi = d.get(stroke)
+        if not bi:
+            return None
         #
-        #  Handle a normal character in insert/overwrite.
-        # <Return> is *not* a normal character.
+        # Ignore previous/next-line commands while editing headlines.
         if (
-            stroke and k.isPlainKey(stroke) and
-            k.unboundKeyAction in ('insert', 'overwrite')
+            key == 'text' and
+            name == 'head' and
+            bi.commandName in ('previous-line', 'next-line')
         ):
-            k.masterCommand(event=event, stroke=stroke)
-            return
+            return None
         #
-        # Always ignore unbound Alt/Ctrl keys.
-        if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
-            return
-        # #868
-        if stroke.isPlainNumPad():
-            stroke.removeNumPadModifier()
-            k.masterCommand(event=event, stroke=stroke)
-            return
-        # #868
-        if stroke.isNumPadKey():
-            # To have effect, these must be bound.
-            return
-        #
-        # Ignore unbound non-ascii character.
-        if (
-            k.ignore_unbound_non_ascii_keys and
-            not stroke.isPlainKey()
-        ):
-            return
-        #
-        # Never insert escape or insert characters.
-        if (
-            stroke and stroke.find('Escape') != -1 or
-            stroke and stroke.find('Insert') != -1
-        ):
-            return
-        #
-        # Let k.masterCommand handle the unbound character.
-        k.masterCommand(event=event, stroke=stroke)
-    #@+node:ekr.20061031131434.105: *5* k.masterCommand
-    def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
-        """
-        This is the central dispatching method.
-        All commands and keystrokes pass through here.
-        This returns None, but may set k.funcReturn.
-        """
-        c, k = self.c, self
-        if event: c.check_event(event)
-        c.setLog()
-        k.stroke = stroke  # Set this global for general use.
-        ch = event.char if event else ''
-        #
-        # Ignore all special keys.
-        if k.isSpecialKey(event):
-            return
-        #
-        # Compute func if not given.
-        # It is *not* an error for func to be None.
-        if commandName and not func:
-            func = c.commandsDict.get(commandName.replace('&', ''))
-            if not func:
-                g.es_print(f"no command for @item {commandName!r}", color='red')
-                return
-        commandName = commandName or func and func.__name__ or '<no function>'
-        if 'keys' in g.app.debug:
-            # A very important trace.
-            g.trace(commandName, 'stroke', stroke)
-        k.funcReturn = None  # For unit testing.
-        #
-        # Remember the key.
-        k.setLossage(ch, stroke)
-        #
-        # Handle keyboard-quit.
-        if k.abortAllModesKey and stroke == k.abortAllModesKey:
-            k.keyboardQuit()
-            k.endCommand(commandName)
-            return
-        #
-        # Ignore abbreviations.
-        if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
-            return
-        #
-        # Handle the func argument, if given.
-        if func:
-            if commandName.startswith('specialCallback'):
-                # The callback function will call c.doCommand.
-                val = func(event)
-                # Set k.funcReturn for k.simulateCommand..
-                k.funcReturn = k.funcReturn or val
-            else:
-                # Call c.doCommand directly.
-                c.doCommand(func, commandName, event=event)
-            if c.exists:
-                k.endCommand(commandName)
-                c.frame.updateStatusLine()
-            return
-        #
-        # Ignore unbound keys in a state.
-        if k.inState():
-            return
-        #
-        # Finally, call k.handleDefaultChar.
-        k.handleDefaultChar(event, stroke)
-        if c.exists:
-            c.frame.updateStatusLine()
-
-    #@+node:ekr.20180418034305.1: *5* k.setEventWidget
-    def setEventWidget(self, event):
-        """
-        A hack: redirect the event to the text part of the log.
-        """
-        c = self.c
-        w = event.widget
-        w_name = c.widget_name(w)
-        if w_name.startswith('log'):
-            event.widget = c.frame.log.logCtrl
-    #@+node:ekr.20180418031417.1: *5* k.traceVars
-    def traceVars(self, event):
-
-        trace = False and not g.unitTesting
-        traceGC = False
-        verbose = False
-        k = self
-        if not trace:
-            return
-        if traceGC:
-            g.printNewObjects('masterKey 1')
-        if verbose:
-            char = event.char
-            state = k.state.kind
-            stroke = event.stroke
-            g.trace(
-                f"stroke: {stroke!r}, "
-                f"char: {char!r}, "
-                f"state: {state}, "
-                f"state2: {k.unboundKeyAction}")
-    #@+node:ekr.20160409035115.1: *5* k.searchTree
+        # The binding has been found.
+        return bi
+    #@+node:ekr.20160409035115.1: *6* k.searchTree
     def searchTree(self, char):
         """Search all visible nodes for a headline starting with stroke."""
         if not char: return
@@ -3889,7 +3567,7 @@
             else:
                 w.insert(ins, ch)
                 i = ins + 1
-    #@+node:ekr.20120208064440.10190: *3* k.Modes (no change)
+    #@+node:ekr.20120208064440.10190: *3* k.Modes
#@verbatim
     #@+node:ekr.20061031131434.100: *4* k.addModeCommands (enterModeCallback)
     def addModeCommands(self):
         """Add commands created by @mode settings to c.commandsDict."""
@@ -3946,7 +3624,6 @@
         w = g.app.gui.get_focus(c)
         if w:
             c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
-        k.endCommand(k.stroke)
         k.inputModeName = None
         k.clearState()
         k.resetLabel()
@@ -3967,7 +3644,7 @@
         if k.inState():
             k.endMode()
         k.showStateAndMode()
-    #@+node:ekr.20061031131434.165: *4* k.modeHelp & helper (revise helper)
+    #@+node:ekr.20061031131434.165: *4* k.modeHelp & helper
     @cmd('mode-help')
     def modeHelp(self, event):
         """
@@ -4012,7 +3689,7 @@
         # This isn't perfect in variable-width fonts.
         for s1, s2 in data:
             g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
-    #@+node:ekr.20061031131434.164: *4* k.reinitMode (call k.createModeBindings???)
+    #@+node:ekr.20061031131434.164: *4* k.reinitMode
     def reinitMode(self, modeName):
         k = self
         d = k.modeBindingsDict
@@ -4024,7 +3701,7 @@
         else:
             # Do not set the status line here.
             k.setLabelBlue(modeName + ': ')  # ,protect=True)
-    #@+node:ekr.20120208064440.10199: *4* k.generalModeHandler (OLD)
+    #@+node:ekr.20120208064440.10199: *4* k.generalModeHandler
     def generalModeHandler(self, event,
         commandName=None,
         func=None,
@@ -4106,59 +3783,6 @@
         w = k.modeWidget if k.silentMode else k.w
         k.createModeBindings(modeName, d, w)
         k.showStateAndMode(prompt=prompt)
-    #@+node:ekr.20120208064440.10201: *4* k.NEWgeneralModeHandler (NEW MODES)
-    def NEWgeneralModeHandler(self, event,
-        commandName=None,
-        func=None,
-        modeName=None,
-        nextMode=None,
-        prompt=None
-    ):
-        """Handle a mode defined by an @mode node in leoSettings.leo."""
-        k = self; c = k.c
-        state = k.getState(modeName)
-        if state == 0:
-            k.inputModeName = modeName
-            k.modePrompt = prompt or modeName
-            k.modeWidget = event and event.widget
-            k.setState(modeName, 1, handler=k.generalModeHandler)
-            self.initMode(event, modeName)
-            # Careful: k.initMode can execute commands that will destroy a commander.
-            if g.app.quitting or not c.exists: return
-            if not k.silentMode:
-                if c.config.getBool('showHelpWhenEnteringModes'):
-                    k.modeHelp(event)
-                else:
-                    c.frame.log.hideTab('Mode')
-        elif not func:
-            g.trace('No func: improper key binding')
-        else:
-            if commandName == 'mode-help':
-                func(event)
-            else:
-                self.endMode()
-                # New in 4.4.1 b1: pass an event describing the original widget.
-                if event:
-                    event.w = event.widget = k.modeWidget
-                else:
-                    event = g.app.gui.create_key_event(c, w=k.modeWidget)
-                func(event)
-                if g.app.quitting or not c.exists:
-                    pass
-                elif nextMode in (None, 'none'):
-                    # Do *not* clear k.inputModeName or the focus here.
-                    # func may have put us in *another* mode.
-                    pass
-                elif nextMode == 'same':
-                    silent = k.silentMode
-                    k.setState(modeName, 1, handler=k.generalModeHandler)
-                    self.reinitMode(modeName)  # Re-enter this mode.
-                    k.silentMode = silent
-                else:
-                    k.silentMode = False  # All silent modes must do --> set-silent-mode.
-                    self.initMode(event, nextMode)  # Enter another mode.
-                    # Careful: k.initMode can execute commands that will destroy a commander.
-                    # if g.app.quitting or not c.exists: return
#@verbatim
     #@+node:ekr.20061031131434.181: *3* k.Shortcuts & bindings
#@verbatim
     #@+node:ekr.20061031131434.176: *4* k.computeInverseBindingDict
     def computeInverseBindingDict(self):
@@ -4222,15 +3846,6 @@
         if not g.assert_is(stroke, g.KeyStroke):
             return stroke
         return stroke.prettyPrint()
-    #@+node:ekr.20110609161752.16459: *4* k.setLossage
-    def setLossage(self, ch, stroke):
-
-        # k = self
-        if ch or stroke:
-            if len(g.app.lossage) > 99:
-                g.app.lossage.pop()
-        # This looks like a memory leak, but isn't.
-        g.app.lossage.insert(0, (ch, stroke),)
#@verbatim
     #@+node:ekr.20110606004638.16929: *4* k.stroke2char
     def stroke2char(self, stroke):
         """
@@ -4347,130 +3962,6 @@
#@verbatim
     #@+node:ekr.20110202111105.15439: *4* k.showStateCursor
     def showStateCursor(self, state, w):
         pass
-    #@+node:ekr.20061031131434.200: *3* k.universalDispatcher & helpers
-    def universalDispatcher(self, event):
-        """Handle accumulation of universal argument."""
-        #@+<< about repeat counts >>
-        #@+node:ekr.20061031131434.201: *4* << about repeat counts >>
-        #@@nocolor
-        #@+at  Any Emacs command can be given a numeric argument. Some commands interpret the
-        # argument as a repetition count. For example, giving an argument of ten to the
-        # key C-f (the command forward-char, move forward one character) moves forward ten
-        # characters. With these commands, no argument is equivalent to an argument of
-        # one. Negative arguments are allowed. Often they tell a command to move or act
-        # backwards.
-        #
-        # If your keyboard has a META key, the easiest way to specify a numeric argument
-        # is to type digits and/or a minus sign while holding down the the META key. For
-        # example,
-        #
-        # M-5 C-n
-        #
-        # moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
-        # Meta--, do this because they are keys bound to commands (digit-argument and
-        # negative-argument) that are defined to contribute to an argument for the next
-        # command.
-        #
-        # Another way of specifying an argument is to use the C-u (universal-argument)
-        # command followed by the digits of the argument. With C-u, you can type the
-        # argument digits without holding down shift keys. To type a negative argument,
-        # start with a minus sign. Just a minus sign normally means -1. C-u works on all
-        # terminals.
-        #
-        # C-u followed by a character which is neither a digit nor a minus sign has the
-        # special meaning of "multiply by four". It multiplies the argument for the next
-        # command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
-        # forward sixteen characters. This is a good way to move forward "fast", since it
-        # moves about 1/5 of a line in the usual size screen. Other useful combinations
-        # are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
-        # (make "a lot" of blank lines), and C-u C-k (kill four lines).
-        #
-        # Some commands care only about whether there is an argument and not about its
-        # value. For example, the command M-q (fill-paragraph) with no argument fills
-        # text; with an argument, it justifies the text as well. (See section Filling
-        # Text, for more information on M-q.) Just C-u is a handy way of providing an
-        # argument for such commands.
-        #
-        # Some commands use the value of the argument as a repeat count, but do something
-        # peculiar when there is no argument. For example, the command C-k (kill-line)
-        # with argument n kills n lines, including their terminating newlines. But C-k
-        # with no argument is special: it kills the text up to the next newline, or, if
-        # point is right at the end of the line, it kills the newline itself. Thus, two
-        # C-k commands with no arguments can kill a non-blank line, just like C-k with an
-        # argument of one. (See section Deletion and Killing, for more information on
-        # C-k.)
-        #
-        # A few commands treat a plain C-u differently from an ordinary argument. A few
-        # others may treat an argument of just a minus sign differently from an argument
-        # of -1. These unusual cases will be described when they come up; they are always
-        # to make the individual command more convenient to use.
-        #@-<< about repeat counts >>
-        k = self
-        state = k.getState('u-arg')
-        stroke = event.stroke if event else ''
-        if state == 0:
-            k.dispatchEvent = event
-            # The call should set the label.
-            k.setState('u-arg', 1, k.universalDispatcher)
-            k.repeatCount = 1
-        elif state == 1:
-            char = event.char if event else ''
-            if char == 'Escape':
-                k.keyboardQuit()
-            elif char == k.universalArgKey:
-                k.repeatCount = k.repeatCount * 4
-            elif char.isdigit() or char == '-':
-                k.updateLabel(event)
-            elif char in (
-                'Alt_L', 'Alt_R',
-                'Control_L', 'Control_R',
-                'Meta_L', 'Meta_R',
-                'Shift_L', 'Shift_R',
-            ):
-                k.updateLabel(event)
-            else:
-                # *Anything* other than C-u, '-' or a numeral is taken to be a command.
-                val = k.getLabel(ignorePrompt=True)
-                try: n = int(val) * k.repeatCount
-                except ValueError: n = 1
-                k.clearState()
-                event = k.dispatchEvent
-                k.executeNTimes(event, n)
-                k.keyboardQuit()
-        elif state == 2:
-            k.doControlU(event, stroke)
-    #@+node:ekr.20061031131434.202: *4* k.executeNTimes
-    def executeNTimes(self, event, n):
-
-        c, k = self.c, self
-        w = event and event.widget
-        stroke = event.stroke if event else ''
-        if not stroke: return
-        if stroke == k.fullCommandKey:
-            for z in range(n):
-                k.fullCommand(event)
-        else:
-            bi = k.getPaneBinding(stroke, event and event.widget)
-            if bi:
-                for z in range(n):
-                    event = g.app.gui.create_key_event(c, event=event, w=w)
-                    k.masterCommand(
-                        commandName=None,
-                        event=event,
-                        func=bi.func,
-                        stroke=stroke,
-                    )
-            else:
-                for z in range(n):
-                    k.masterKeyHandler(event)
-    #@+node:ekr.20061031131434.203: *4* doControlU
-    def doControlU(self, event, stroke):
-        k = self
-        ch = event.char if event else ''
-        k.setLabelBlue(f"Control-u {g.stripBrackets(stroke)}")
-        if ch == '(':
-            k.clearState()
-            k.resetLabel()
#@verbatim
     #@-others
#@verbatim
 #@+node:ekr.20120208064440.10150: ** class ModeInfo
 class ModeInfo:
@language python
#@+node:ekr.20200725105324.8: *9* Added
#@+node:ekr.20200524151214.1: *10* Setup...
#@+node:ekr.20180418040158.1: *11* k.checkKeyEvent
def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
#@+node:ekr.20180418034305.1: *11* k.setEventWidget
def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
#@+node:ekr.20180418031417.1: *11* k.traceVars
def traceVars(self, event):

    trace = False and not g.unitTesting
    traceGC = False
    verbose = False
    k = self
    if not trace:
        return
    if traceGC:
        g.printNewObjects('masterKey 1')
    if verbose:
        char = event.char
        state = k.state.kind
        stroke = event.stroke
        g.trace(
            f"stroke: {stroke!r}, "
            f"char: {char!r}, "
            f"state: {state}, "
            f"state2: {k.unboundKeyAction}")
#@+node:ekr.20200725105324.9: *9* Deleted
#@+node:ekr.20200725105324.10: *10* k.endCommand
def endCommand(self, commandName):
    """Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    """
    k = self; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
        if 0:  # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
#@+node:ekr.20200725105324.11: *10* k.commandExists
def commandExists(self, commandName):
    """Return the command handler for the given command name, or None."""
    c, k = self.c, self
    commandName = commandName.strip()
    if commandName:
        aList = commandName.split(None)
        if len(aList) == 1:
            k.givenArgs = []
        else:
            commandName = aList[0]
            k.givenArgs = aList[1:]
        func = c.commandsDict.get(commandName)
        return func
    return None
#@+node:ekr.20200725105324.12: *10* k.doUnboundPlainKey & helper
def doUnboundPlainKey(self, event):
    """
    Handle unbound plain keys.
    Return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke, w = event.stroke, event.widget
    #
    # Ignore non-plain keys.
    if not k.isPlainKey(stroke):
        return False
    #
    # Ignore any keys in the background tree widget.
    if c.widget_name(w).startswith('canvas'):
        return False
    #
    # Ignore the char if it is bound to the auto-complete command.
    if self.isAutoCompleteChar(stroke):
        return False
    #
    # Handle the unbound key.
    k.handleUnboundKeys(event)
    return True
#@+node:ekr.20200725105324.13: *10* k.isAutoCompleteChar
def isAutoCompleteChar(self, stroke):
    """
    Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.
    """
    k = self; state = k.unboundKeyAction
    assert g.isStrokeOrNone(stroke)
    if stroke and state in ('insert', 'overwrite'):
        for key in (state, 'body', 'log', 'text', 'all'):
            d = k.masterBindingsDict.get(key, {})
            if d:
                bi = d.get(stroke)
                if bi:
                    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
                    if bi.commandName == 'auto-complete':
                        return True
    return False
#@+node:ekr.20200725105324.14: *10* k.handleDefaultChar
def handleDefaultChar(self, event, stroke):
    """
    Handle an unbound key, based on the event's widget.
    Do not assume that stroke exists.
    """
    c, k, w = self.c, self, event.widget
    name = c.widget_name(w)
    #
    # Ignore unbound alt-ctrl key
    if stroke and stroke.isAltCtrl() and k.ignore_unbound_non_ascii_keys:
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
        return
    #
    # Handle events in the body pane.
    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert', 'overwrite'):
            c.editCommands.selfInsertCommand(event, action=action)
        else:
            pass  # Ignore the key
        return
    #
    # Handle events in headlines.
    if name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return
    #
    # Handle events in the background tree.
    if name.startswith('canvas'):
        if not stroke:  # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event)
        return
    #
    # Handle events in the log pane.
    if name.startswith('log'):
        # Make sure we can insert into w.
        log_w = event.widget
        if not hasattr(log_w, 'supportsHighLevelInterface'):
            return
        # Send the event to the text widget, not the LeoLog instance.
        if not stroke:
            stroke = event.stroke
        if stroke:
            i = log_w.getInsertPoint()
            s = stroke.toGuiChar()
            log_w.insert(i, s)
        return
    #
    # Ignore all other events.
#@+node:ekr.20200725105324.15: *10* k.handleUnboundKeys
def handleUnboundKeys(self, event):

    c, k = self.c, self
    stroke = event.stroke
    if not g.assert_is(stroke, g.KeyStroke):
        return
    # #1448: Very late special case for getArg state.
    #        This is not needed for other states.
    if stroke.isNumPadKey() and k.state.kind == 'getArg':
        stroke.removeNumPadModifier()
        k.getArg(event, stroke=stroke)
        return
    #
    # Ignore all unbound characters in command mode.
    if k.unboundKeyAction == 'command':
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return
    #
    # Ignore unbound F-keys.
    if stroke.isFKey():
        return
    #
    #  Handle a normal character in insert/overwrite.
    # <Return> is *not* a normal character.
    if (
        stroke and k.isPlainKey(stroke) and
        k.unboundKeyAction in ('insert', 'overwrite')
    ):
        k.masterCommand(event=event, stroke=stroke)
        return
    #
    # Always ignore unbound Alt/Ctrl keys.
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return
    # #868
    if stroke.isPlainNumPad():
        stroke.removeNumPadModifier()
        k.masterCommand(event=event, stroke=stroke)
        return
    # #868
    if stroke.isNumPadKey():
        # To have effect, these must be bound.
        return
    #
    # Ignore unbound non-ascii character.
    if (
        k.ignore_unbound_non_ascii_keys and
        not stroke.isPlainKey()
    ):
        return
    #
    # Never insert escape or insert characters.
    if (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        return
    #
    # Let k.masterCommand handle the unbound character.
    k.masterCommand(event=event, stroke=stroke)
#@+node:ekr.20200725105324.16: *10* k.masterCommand
def masterCommand(self, commandName=None, event=None, func=None, stroke=None):
    """
    This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    """
    c, k = self.c, self
    if event: c.check_event(event)
    c.setLog()
    k.stroke = stroke  # Set this global for general use.
    ch = event.char if event else ''
    #
    # Ignore all special keys.
    if k.isSpecialKey(event):
        return
    #
    # Compute func if not given.
    # It is *not* an error for func to be None.
    if commandName and not func:
        func = c.commandsDict.get(commandName.replace('&', ''))
        if not func:
            g.es_print(f"no command for @item {commandName!r}", color='red')
            return
    commandName = commandName or func and func.__name__ or '<no function>'
    if 'keys' in g.app.debug:
        # A very important trace.
        g.trace(commandName, 'stroke', stroke)
    k.funcReturn = None  # For unit testing.
    #
    # Remember the key.
    k.setLossage(ch, stroke)
    #
    # Handle keyboard-quit.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    #
    # Ignore abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, stroke):
        return
    #
    # Handle the func argument, if given.
    if func:
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand.
            val = func(event)
            # Set k.funcReturn for k.simulateCommand..
            k.funcReturn = k.funcReturn or val
        else:
            # Call c.doCommand directly.
            c.doCommand(func, commandName, event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        return
    #
    # Ignore unbound keys in a state.
    if k.inState():
        return
    #
    # Finally, call k.handleDefaultChar.
    k.handleDefaultChar(event, stroke)
    if c.exists:
        c.frame.updateStatusLine()

#@+node:ekr.20200725105324.17: *10* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
#@+node:ekr.20200725105324.18: *10* k.universalDispatcher & helpers
def universalDispatcher(self, event):
    """Handle accumulation of universal argument."""
    << about repeat counts >>
    k = self
    state = k.getState('u-arg')
    stroke = event.stroke if event else ''
    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg', 1, k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        char = event.char if event else ''
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L', 'Alt_R',
            'Control_L', 'Control_R',
            'Meta_L', 'Meta_R',
            'Shift_L', 'Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try: n = int(val) * k.repeatCount
            except ValueError: n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event, n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event, stroke)
#@+node:ekr.20200725105324.19: *10* << about repeat counts >>
@nocolor
@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@+node:ekr.20200725105324.20: *10* k.executeNTimes
def executeNTimes(self, event, n):

    c, k = self.c, self
    w = event and event.widget
    stroke = event.stroke if event else ''
    if not stroke: return
    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        bi = k.getPaneBinding(stroke, event and event.widget)
        if bi:
            for z in range(n):
                event = g.app.gui.create_key_event(c, event=event, w=w)
                k.masterCommand(
                    commandName=None,
                    event=event,
                    func=bi.func,
                    stroke=stroke,
                )
        else:
            for z in range(n):
                k.masterKeyHandler(event)
#@+node:ekr.20200725105324.21: *10* doControlU
def doControlU(self, event, stroke):
    k = self
    ch = event.char if event else ''
    k.setLabelBlue(f"Control-u {g.stripBrackets(stroke)}")
    if ch == '(':
        k.clearState()
        k.resetLabel()
#@+node:ekr.20200725105324.22: *9* Changed
#@+node:ekr.20200725105324.23: *10* leo/core/leoKeys.py:2507a1fcc70
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -2,7 +2,6 @@
 """Gui-independent keystroke handling for Leo."""
 # pylint: disable=eval-used
 # pylint: disable=deprecated-method
-    # The new methods may not exist in Python 2.
 << imports >>
 << Key bindings, an overview >>
 << about 'internal' bindings >>
@language python
#@+node:ekr.20200725105324.24: *11* Old:leo/core/leoKeys.py:2507a1fcc70
@first # -*- coding: utf-8 -*-
"""Gui-independent keystroke handling for Leo."""
# pylint: disable=eval-used
# pylint: disable=deprecated-method
    # The new methods may not exist in Python 2.
<< imports >>
<< Key bindings, an overview >>
<< about 'internal' bindings >>
<< about key dicts >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20061031131434: *11* @file leoKeys.py
@first # -*- coding: utf-8 -*-
"""Gui-independent keystroke handling for Leo."""
# pylint: disable=eval-used
# pylint: disable=deprecated-method
<< imports >>
<< Key bindings, an overview >>
<< about 'internal' bindings >>
<< about key dicts >>
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20061031131434.1: *12* << imports >> (leoKeys)
import leo.core.leoGlobals as g
import leo.commands.gotoCommands as gotoCommands
import leo.external.codewise as codewise
import inspect
import os
import re
import string
import sys
import time
assert time
#@+node:ekr.20130920121326.11281: *12* << Key bindings, an overview >>
@language rest
@
The big pictures of key bindings:

1. Code in leoKeys.py and in leoConfig.py converts user key settings to
   various Python **binding dictionaries** defined in leoKeys.py.

2. An instance of LeoQtEventFilter should be attached to all visible panes
   in Leo's main window. g.app.gui.setFilter does this.

3. LeoQtEventFilter.eventFilter calls k.masterKeyhandler for every
   keystroke. eventFilter passes only just the event argument to
   k.masterKeyHandler. The event arg gives both the widget in which the
   event occurs and the keystroke.

4. k.masterKeyHandler and its helpers use the event argument and the
   binding dictionaries to execute the Leo command (if any) associated with
   the incoming keystroke.

Important details:

1. g.app.gui.setFilter allows various traces and assertions to be made
   uniformly. The obj argument to setFilter is a QWidget object; the w
   argument to setFilter can be either the same as obj, or a Leo
   wrapper class. **Important**: the types of obj and w are not
   actually all that important, as discussed next.

2. The logic in k.masterKeyHandler and its helpers is long and involved:

A. k.getPaneBinding associates a command with the incoming keystroke based
   on a) the widget's name and b) whether the widget is a text widget
   (which depends on the type of the widget).

   To do this, k.getPaneBinding uses a **binding priority table**. This
   table is defined within k.getPaneBinding itself. The table indicates
   which of several possible bindings should have priority. For instance,
   if the widget is a text widget, a user binding for a 'text' widget takes
   priority over a default key binding. Similarly, if the widget is Leo's
   tree widget, a 'tree' binding has top priority. There are many other
   details encapsulated in the table. The exactly details of the binding
   priority table are open to debate, but in practice the resulting
   bindings are as expeced.

B. If k.getPaneBinding finds a command associated with the incoming
   keystroke, k.masterKeyHandler executes the command.

C. If k.getPaneBinding fails to bind the incoming keystroke to a command,
   k.masterKeyHandler calls k.handleUnboundKeys to handle the keystroke.
   Depending on the widget, and settings, and the keystroke,
   k.handleUnboundKeys may do nothing, or it may call k.masterCommand to
   insert a plain key into the widget.
#@+node:ekr.20061031131434.2: *12* << about 'internal' bindings >>
@language rest
@
Here are the rules for translating key bindings (in leoSettings.leo)
into keys for k.bindingsDict:

1. The case of plain letters is significant: a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore
   (with a warning) the shift prefix applied to any other binding,
   e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is
   *not* significant. Thus, the Shift- prefix is required if you want
   an upper-case letter (with the exception of 'bare' uppercase
   letters.)

The following table illustrates these rules. In each row, the first
entry is the key (for k.bindingsDict) and the other entries are
equivalents that the user may specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is
consistent with Tk's key-event specifiers). It is also, I think, the
least confusing set of rules.
#@+node:ekr.20061031131434.3: *12* << about key dicts >>
@language rest
@
ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
k.bindingsDict          shortcuts           lists of BindingInfo objects
k.masterBindingsDict    scope names (2)     Interior masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

New in Leo 4.7:
k.killedBindings is a list of command names for which bindings have been killed in local files.

Notes:

(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) Interior masterBindingDicts: Keys are strokes; values are BindingInfo objects.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of BindingInfo objects.
#@+node:ekr.20061031131434.4: *12* class AutoCompleterClass
class AutoCompleterClass:
    """A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    """
    @others
#@+node:ekr.20150509035140.1: *13* ac.cmd (decorator)
def cmd(name):
    """Command decorator for the AutoCompleter class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k', 'autoCompleter'])
#@+node:ekr.20061031131434.5: *13* ac.ctor & reloadSettings
def __init__(self, k):
    """Ctor for AutoCompleterClass class."""
    # Ivars...
    self.c = k.c
    self.k = k
    self.force = None
    self.language = None
    self.namespaces = []
        # additional namespaces to search for objects, other code
        # can append namespaces to this to extend scope of search
    self.qw = None
        # The object that supports qcompletion methods.
    self.tabName = None
        # The name of the main completion tab.
    self.verbose = False
        # True: print all members, regardless of how many there are.
    self.w = None
        # The widget that gets focus after autocomplete is done.
    self.warnings = {}
        # Keys are language names.
    # Codewise pre-computes...
    self.codewiseSelfList = []
        # The (global) completions for "self."
    self.completionsDict = {}
        # Keys are prefixes, values are completion lists.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    self.auto_tab = c.config.getBool('auto-tab-complete', True)
    self.forbid_invalid = c.config.getBool('forbid-invalid-completions', False)
    self.use_jedi = c.config.getBool('use-jedi', False)
    self.use_qcompleter = c.config.getBool('use-qcompleter', False)
        # True: show results in autocompleter tab.
        # False: show results in a QCompleter widget.
#@+node:ekr.20061031131434.8: *13* ac.Top level
#@+node:ekr.20061031131434.9: *14* ac.autoComplete
@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
#@+node:ekr.20061031131434.10: *14* ac.autoCompleteForce
@cmd('auto-complete-force')
def autoCompleteForce(self, event=None):
    """Show autocompletion, even if autocompletion is not presently enabled."""
    return self.autoComplete(event, force=True)
#@+node:ekr.20061031131434.12: *14* ac.enable/disable/toggleAutocompleter/Calltips
@cmd('disable-autocompleter')
def disableAutocompleter(self, event=None):
    """Disable the autocompleter."""
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

@cmd('disable-calltips')
def disableCalltips(self, event=None):
    """Disable calltips."""
    self.k.enable_calltips = False
    self.showCalltipsStatus()

@cmd('enable-autocompleter')
def enableAutocompleter(self, event=None):
    """Enable the autocompleter."""
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

@cmd('enable-calltips')
def enableCalltips(self, event=None):
    """Enable calltips."""
    self.k.enable_calltips = True
    self.showCalltipsStatus()

@cmd('toggle-autocompleter')
def toggleAutocompleter(self, event=None):
    """Toggle whether the autocompleter is enabled."""
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

@cmd('toggle-calltips')
def toggleCalltips(self, event=None):
    """Toggle whether calltips are enabled."""
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
#@+node:ekr.20061031131434.13: *14* ac.showCalltips
@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
#@+node:ekr.20061031131434.14: *14* ac.showCalltipsForce
@cmd('show-calltips-force')
def showCalltipsForce(self, event=None):
    """Show the calltips at the cursor, even if calltips are not presently enabled."""
    return self.showCalltips(event, force=True)
#@+node:ekr.20061031131434.15: *14* ac.showAutocompleter/CalltipsStatus
def showAutocompleterStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"autocompleter {'On' if k.enable_autocompleter else 'Off'}"
        g.red(s)

def showCalltipsStatus(self):
    """Show the autocompleter status."""
    k = self.k
    if not g.unitTesting:
        s = f"calltips {'On'}" if k.enable_calltips else 'Off'
        g.red(s)
#@+node:ekr.20061031131434.16: *13* ac.Helpers
#@+node:ekr.20110512212836.14469: *14* ac.exit
def exit(self):

    c = self.c
    w = self.w or c.frame.body.wrapper
    c.k.keyboardQuit()
    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None  # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName, 'Modules', 'Info'):
            c.frame.log.deleteTab(name)
    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i, j = w.getSelectionRange()
    w.setSelectionRange(i, j, insert=j)
    # Was in finish.
    c.frame.body.onBodyChanged('Typing')
    c.recolor()

finish = exit
abort = exit
#@+node:ekr.20061031131434.18: *14* ac.append/begin/popTabName
def appendTabName(self, word):
    self.setTabName(self.tabName + '.' + word)

def beginTabName(self, word):
    self.setTabName('AutoComplete ' + word)

def clearTabName(self):
    self.setTabName('AutoComplete ')

def popTabName(self):
    s = self.tabName
    i = s.rfind('.', 0, -1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!

def setTabName(self, s):
    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_', '') or ''
    c.frame.log.clearTab(self.tabName)
#@+node:ekr.20110509064011.14556: *14* ac.attr_matches
def attr_matches(self, s, namespace):
    """Compute matches when string s is of the form name.name....name.

    Evaluates s using eval(s,namespace)

    Assuming the text is of the form NAME.NAME....[NAME], and is evaluatable in
    the namespace, it will be evaluated and its attributes (as revealed by
    dir()) are used as possible completions.

    For class instances, class members are are also considered.)

    **Warning**: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """
    # Seems to work great. Catches things like ''.<tab>
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", s)
    if not m:
        return []
    expr, attr = m.group(1, 3)
    try:
        safe_expr = self.strip_brackets(expr)
        obj = eval(safe_expr, namespace)
    except Exception:
        return []
    # Build the result.
    words = dir(obj)
    n = len(attr)
    result = [f"{expr}.{w}" for w in words if w[:n] == attr]
    return result
#@+node:ekr.20061031131434.11: *14* ac.auto_completer_state_handler
def auto_completer_state_handler(self, event):
    """Handle all keys while autocompleting."""
    c, k, tag = self.c, self.k, 'auto-complete'
    state = k.getState(tag)
    ch = event.char if event else ''
    stroke = event.stroke if event else ''
    is_plain = k.isPlainKey(stroke)
    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag, 1, handler=self.auto_completer_state_handler)
        else:
            self.exit()
    elif ch in ('\n', 'Return'):
        self.exit()
    elif ch == 'Escape':
        self.exit()
    elif ch in ('\t', 'Tab'):
        self.compute_completion_list()
    elif ch in ('\b', 'BackSpace'):
        self.do_backspace()
    elif ch == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif ch == '?':
        self.info()
    elif ch == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = 'ON' if self.verbose else 'OFF'
        message = f"verbose completions {kind}"
        g.es_print(message)
        # This doesn't work because compute_completion_list clears the autocomplete tab.
        # self.put('', message, tabName=self.tabName)
        # This is almost invisible: the fg='red' is not honored.
        c.frame.putStatusLine(message, fg='red')
        self.compute_completion_list()
    # elif ch == 'Down' and hasattr(self,'onDown'):
        # self.onDown()
    # elif ch == 'Up' and hasattr(self,'onUp'):
        # self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch)
    elif stroke == k.autoCompleteForceKey:
        # This is probably redundant because completions will exist.
        # However, it doesn't hurt, and it may be useful rarely.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if tabList:
            self.show_completion_list(common_prefix, prefix, tabList)
        else:
            g.warning('No completions')
            self.exit()
    else:
        self.abort()
        return 'do-standard-keys'
    return None
#@+node:ekr.20061031131434.20: *14* ac.calltip & helpers
def calltip(self):
    """Show the calltips for the present prefix.
    ch is '(' if the user has just typed it.
    """
    obj, prefix = self.get_object()
    if obj:
        self.calltip_success(prefix, obj)
    else:
        self.calltip_fail(prefix)
    self.exit()
#@+node:ekr.20110512090917.14468: *15* ac.calltip_fail
def calltip_fail(self, prefix):
    """Evaluation of prefix failed."""
    self.insert_string('(')
#@+node:ekr.20110512090917.14469: *15* ac.calltip_success
def calltip_success(self, prefix, obj):
    try:
        # Get the parenthesized argument list.
        s1, s2, s3, s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1, s2, s3, s4)
    except Exception:
        self.insert_string('(')
        return
    # Clean s and insert it: don't include the opening "(".
    if g.match(s, 1, 'self,'):
        s = s[6:].strip()
    elif g.match_word(s, 1, 'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()
    self.insert_string("(", select=False)
    self.insert_string(s, select=True)
#@+node:ekr.20061031131434.28: *14* ac.compute_completion_list & helper
def compute_completion_list(self):
    """Return the autocompleter completion list."""
    prefix = self.get_autocompleter_prefix()
    key, options = self.get_cached_options(prefix)
    if not options:
        options = self.get_completions(prefix)
    tabList, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    if not common_prefix:
        tabList, common_prefix = g.itemsMatchingPrefixInList(
            prefix, options, matchEmptyPrefix=True)
    if tabList:
        self.show_completion_list(common_prefix, prefix, tabList)
    return common_prefix, prefix, tabList
#@+node:ekr.20110514051607.14524: *15* ac.get_cached_options
def get_cached_options(self, prefix):
    d = self.completionsDict
    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)
    while i > 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            return key, []
        options = d.get(key)
        if options:
            return key, options
    return None, []
#@+node:ekr.20061031131434.29: *14* ac.do_backspace
def do_backspace(self):
    """Delete the character and recompute the completion list."""
    c, w = self.c, self.w
    c.bodyWantsFocusNow()
    i = w.getInsertPoint()
    if i <= 0:
        self.exit()
        return
    w.delete(i - 1, i)
    w.setInsertPoint(i - 1)
    if i <= 1:
        self.exit()
    else:
        # Update the list. Abort if there is no prefix.
        common_prefix, prefix, tabList = self.compute_completion_list()
        if not prefix:
            self.exit()
#@+node:ekr.20110510133719.14548: *14* ac.do_qcompleter_tab (not used)
def do_qcompleter_tab(self, prefix, options):
    """Return the longest common prefix of all the options."""
    matches, common_prefix = g.itemsMatchingPrefixInList(
        prefix, options, matchEmptyPrefix=False)
    return common_prefix
#@+node:ekr.20110509064011.14561: *14* ac.get_autocompleter_prefix
def get_autocompleter_prefix(self):
    # Only the body pane supports auto-completion.
    w = self.c.frame.body.wrapper
    s = w.getAllText()
    if not s: return ''
    i = w.getInsertPoint() - 1
    i = j = max(0, i)
    while i >= 0 and (s[i].isalnum() or s[i] in '._'):
        i -= 1
    i += 1
    j += 1
    prefix = s[i:j]
    return prefix
#@+node:ekr.20110512212836.14471: *14* ac.get_completions & helpers
jedi_warning = False

def get_completions(self, prefix):
    """Return jedi or codewise completions."""
    d = self.completionsDict
    if self.use_jedi:
        try:
            import jedi
        except ImportError:
            if not self.jedi_warning:
                self.jedi_warning = False
                g.es_print('can not import jedi')
                g.es_print('ignoring @bool use_jedi = True')
        if jedi:
            aList = (
                self.get_jedi_completions(prefix) or
                    # Prefer the jedi completions.
                self.get_leo_completions(prefix))
            d[prefix] = aList
            return aList
    #
    # Not jedi. Use codewise.
    # Precompute the codewise completions for '.self'.
    if not self.codewiseSelfList:
        aList = self.get_codewise_completions('self.')
        self.codewiseSelfList = [z[5:] for z in aList]
        d['self.'] = self.codewiseSelfList
    # Use the cached list if it exists.
    aList = d.get(prefix)
    if aList:
        return aList
    aList = (
        self.get_leo_completions(prefix) or
            # Prefer the Leo completions.
        self.get_codewise_completions(prefix)
    )
    d[prefix] = aList
    return aList
#@+node:ekr.20110510120621.14539: *15* ac.get_codewise_completions & helpers
def get_codewise_completions(self, prefix):
    """Use codewise to generate a list of hits."""
    c = self.c
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", prefix)
    if m:
        varname = m.group(1)
        ivar = m.group(3)
        kind, aList = self.guess_class(c, varname)
    else:
        kind, aList = 'none', []
        varname, ivar = None, None
    if aList:
        if kind == 'class':
            hits = self.lookup_methods(aList, ivar)
            hits.extend(self.codewiseSelfList)
        elif kind == 'module':
            hits = self.lookup_modules(aList, ivar)
    else:
        aList2 = prefix.split('.')
        if aList2:
            func = aList2[-1]
            hits = self.lookup_functions(func)
        else:
            hits = []
    if 1:  # A kludge: add the prefix to each hit.
        hits = [f"{varname}.{z}" for z in hits]
    return hits
#@+node:ekr.20110510120621.14540: *16* ac.clean
def clean(self, hits):
    """Clean up hits, a list of ctags patterns, for use in completion lists."""
    # Just take the function name: ignore the signature & file.
    aList = list(set([z[0] for z in hits]))
    aList.sort()
    return aList
#@+node:ekr.20110512232915.14481: *16* ac.clean_for_display (not used)
def clean_for_display(self, hits):
    """Clean up hits, a list of ctags patterns, for display purposes."""
    aList = []
    for h in hits:
        s = h[0]
        # Display oriented: no good for completion list.
        fn = h[1].strip()
        if fn.startswith('/'):
            sig = fn[2:-4].strip()
        else:
            sig = fn
        aList.append(f"{s}: {sig}")
    aList = list(set(aList))
    aList.sort()
    return aList
#@+node:ekr.20110510120621.14542: *16* ac.guess_class
def guess_class(self, c, varname):
    """Return kind, class_list"""
    # if varname == 'g':
        # return 'module',['leoGlobals']
    if varname == 'p':
        return 'class', ['position']
    if varname == 'c':
        return 'class', ['Commands']
    if varname == 'self':
        # Return the nearest enclosing class.
        for p in c.p.parents():
            h = p.h
            m = re.search(r'class\s+(\w+)', h)
            if m:
                return 'class', [m.group(1)]
    if 1:
        aList = []
    else:
        # This is not needed now that we add the completions for 'self'.
        aList = ContextSniffer().get_classes(c.p.b, varname)
    return 'class', aList
#@+node:ekr.20110510120621.14543: *16* ac.lookup_functions/methods/modules
def lookup_functions(self, prefix):
    aList = codewise.cmd_functions([prefix])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_methods(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_members([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_modules(self, aList, prefix):  # prefix not used, only aList[0] used.
    aList = codewise.cmd_functions([aList[0]])
    hits = [z.split(None, 1) for z in aList if z.strip()]
    return self.clean(hits)
#@+node:ekr.20180519111302.1: *15* ac.get_jedi_completions & helper
def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 >= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0 - 1 : n0 + 30])
        print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1 + n0 + jedi_line,
                column=column,
                path=g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            )
            completions = script.completions()
            t3 = time.process_time()
        except ValueError:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 >= t2 >= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
#@+node:ekr.20180526211127.1: *16* ac.add_prefix
def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') > -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
#@+node:ekr.20110509064011.14557: *15* ac.get_leo_completions
def get_leo_completions(self, prefix):
    """Return completions in an environment defining c, g and p."""
    aList = []
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        aList.extend(self.attr_matches(prefix, d))
    aList.sort()
    return aList
#@+node:ekr.20110512090917.14466: *14* ac.get_leo_namespace
def get_leo_namespace(self, prefix):
    """
    Return an environment in which to evaluate prefix.
    Add some common standard library modules as needed.
    """
    k = self.k
    d = {'c': k.c, 'p': k.c.p, 'g': g}
    aList = prefix.split('.')
    if len(aList) > 1:
        name = aList[0]
        m = sys.modules.get(name)
        if m:
            d[name] = m
    return d
#@+node:ekr.20110512170111.14472: *14* ac.get_object
def get_object(self):
    """Return the object corresponding to the current prefix."""
    common_prefix, prefix1, aList = self.compute_completion_list()
    if not aList:
        return None, prefix1
    if len(aList) == 1:
        prefix = aList[0]
    else:
        prefix = common_prefix
    if prefix.endswith('.') and self.use_qcompleter:
        prefix += self.qcompleter.get_selection()
    safe_prefix = self.strip_brackets(prefix)
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        try:
            obj = eval(safe_prefix, d)
            break  # only reached if none of the exceptions below occur
        except AttributeError:
            obj = None
        except NameError:
            obj = None
        except SyntaxError:
            obj = None
        except Exception:
            g.es_exception()
            obj = None
    return obj, prefix
#@+node:ekr.20061031131434.38: *14* ac.info
def info(self):
    """Show the docstring for the present completion."""
    c = self.c
    obj, prefix = self.get_object()
    c.frame.log.clearTab('Info', wrap='word')
    put = lambda s: self.put('', s, tabName='Info')
    put(prefix)
    try:
        argspec = inspect.getargspec(obj)
        # uses None instead of empty list
        argn = len(argspec.args or [])
        defn = len(argspec.defaults or [])
        put("args:")
        simple_args = argspec.args[: argn - defn]
        if not simple_args:
            put('    (none)')
        else:
            put('    ' + ', '.join(' ' + i for i in simple_args))
        put("keyword args:")
        if not argspec.defaults:
            put('    (none)')
        for i in range(defn):
            arg = argspec.args[-defn + i]
            put(f"    {arg} = {repr(argspec.defaults[i])}")
        if argspec.varargs:
            put("varargs: *" + argspec.varargs)
        if argspec.keywords:
            put("keywords: **" + argspec.keywords)
        put('\n')  # separate docstring
    except TypeError:
        put('\n')  # not a callable
    doc = inspect.getdoc(obj)
    put(doc if doc else "No docstring for " + repr(prefix))
#@+node:ekr.20110510071925.14586: *14* ac.init_qcompleter
def init_qcompleter(self, event=None):

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    w = self.c.frame.body.wrapper.widget
        # A LeoQTextBrowser.  May be none for unit tests.
    if w and options:
        self.qw = w
        self.qcompleter = w.init_completer(options)
        self.auto_completer_state_handler(event)
    else:
        if not g.unitTesting:
            g.warning('No completions')
        self.exit()
#@+node:ekr.20110511133940.14552: *14* ac.init_tabcompleter
def init_tabcompleter(self, event=None):
    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    if options:
        self.clearTabName()  # Creates the tabbed pane.
        self.auto_completer_state_handler(event)
    else:
        g.warning('No completions')
        self.exit()
#@+node:ekr.20061031131434.39: *14* ac.insert_general_char
def insert_general_char(self, ch):

    k, w = self.k, self.w
    if g.isWordChar(ch):
        self.insert_string(ch)
        common_prefix, prefix, aList = self.compute_completion_list()
        if not aList:
            if self.forbid_invalid:
                # Delete the character we just inserted.
                self.do_backspace()
        # @bool auto_tab_complete is deprecated.
        # Auto-completion makes no sense if it is False.
        elif self.auto_tab and len(common_prefix) > len(prefix):
            extend = common_prefix[len(prefix) :]
            ins = w.getInsertPoint()
            w.insert(ins, extend)
        return
    if ch == '(' and k.enable_calltips:
        # This calls self.exit if the '(' is valid.
        self.calltip()
    else:
        self.insert_string(ch)
        self.exit()
#@+node:ekr.20061031131434.31: *14* ac.insert_string
def insert_string(self, s, select=False):
    """Insert s at the insertion point."""
    c = self.c
    w = self.w
    if not g.isTextWrapper(w):  # Bug fix: 2016/10/29.
        return
    c.widgetWantsFocusNow(w)
    i = w.getInsertPoint()
    w.insert(i, s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i, j, insert=j)
    c.frame.body.onBodyChanged('Typing')
    if self.use_qcompleter:
        if self.qw:
            c.widgetWantsFocusNow(self.qw.leo_qc)
#@+node:ekr.20110314115639.14269: *14* ac.is_leo_source_file
def is_leo_source_file(self):
    """Return True if this is one of Leo's source files."""
    c = self.c
    table = (z.lower() for z in (
        'leoDocs.leo',
        'LeoGui.leo', 'LeoGuiPluginsRef.leo',
        'leoPlugins.leo', 'leoPluginsRef.leo',
        'leoPy.leo', 'leoPyRef.leo',
        'myLeoSettings.leo', 'leoSettings.leo',
        'ekr.leo',
        # 'test.leo',
    ))
    return c.shortFileName().lower() in table
#@+node:ekr.20101101175644.5891: *14* ac.put
def put(self, *args, **keys):
    """Put s to the given tab.

    May be overridden in subclasses."""
    # print('autoCompleter.put',args,keys)
    if g.unitTesting:
        pass
    else:
        g.es(*args, **keys)
#@+node:ekr.20110511133940.14561: *14* ac.show_completion_list & helpers
def show_completion_list(self, common_prefix, prefix, tabList):
    c = self.c
    aList = common_prefix.split('.')
    header = '.'.join(aList[:-1])
    # "!" toggles self.verbose.
    if self.verbose or self.use_qcompleter or len(tabList) < 20:
        tabList = self.clean_completion_list(header, tabList,)
    else:
        tabList = self.get_summary_list(header, tabList)
    if self.use_qcompleter:
        # Put the completions in the QListView.
        if self.qw:
            self.qw.show_completions(tabList)
    else:
        # Update the tab name, creating the tab if necessary.
        c.widgetWantsFocus(self.w)
        c.frame.log.clearTab(self.tabName)
        self.beginTabName(header + '.' if header else '')
        s = '\n'.join(tabList)
        self.put('', s, tabName=self.tabName)
#@+node:ekr.20110513104728.14453: *15* ac.clean_completion_list
def clean_completion_list(self, header, tabList):
    """Return aList with header removed from the start of each list item."""
    return [
        z[len(header) + 1 :] if z.startswith(header) else z
            for z in tabList]
#@+node:ekr.20110513104728.14454: *15* ac.get_summary_list
def get_summary_list(self, header, tabList):
    """Show the possible starting letters,
    but only if there are more than one.
    """
    d = {}
    for z in tabList:
        tail = z[len(header) :] if z else ''
        if tail.startswith('.'): tail = tail[1:]
        ch = tail[0] if tail else ''
        if ch:
            n = d.get(ch, 0)
            d[ch] = n + 1
    aList = [f"{ch2} {d.get(ch2)}" for ch2 in sorted(d)]
    if len(aList) > 1:
        tabList = aList
    else:
        tabList = self.clean_completion_list(header, tabList)
    return tabList
#@+node:ekr.20061031131434.46: *14* ac.start
def start(self, event):
    # We don't need to clear this now that we don't use ContextSniffer.
    c = self.c
    if c.config.getBool('use-jedi', default=True):
        self.completionsDict = {}
    if self.use_qcompleter:
        self.init_qcompleter(event)
    else:
        self.init_tabcompleter(event)
#@+node:ekr.20110512170111.14471: *14* ac.strip_brackets
def strip_brackets(self, s):
    """Return s with all brackets removed.

    This (mostly) ensures that eval will not execute function calls, etc.
    """
    for ch in '[]{}()':
        s = s.replace(ch, '')
    return s
#@+node:ekr.20110312162243.14260: *12* class ContextSniffer
class ContextSniffer:
    """ Class to analyze surrounding context and guess class

    For simple dynamic code completion engines.
    """

    def __init__(self):
        self.vars = {}
            # Keys are var names; values are list of classes
    @others
#@+node:ekr.20110312162243.14261: *13* get_classes
def get_classes(self, s, varname):
    """Return a list of classes for string s."""
    self.push_declarations(s)
    aList = self.vars.get(varname, [])
    return aList
#@+node:ekr.20110312162243.14262: *13* set_small_context
# def set_small_context(self, body):
    # """ Set immediate function """
    # self.push_declarations(body)
#@+node:ekr.20110312162243.14263: *13* push_declarations & helper
def push_declarations(self, s):
    for line in s.splitlines():
        line = line.lstrip()
        if line.startswith('#'):
            line = line.lstrip('#')
            parts = line.split(':')
            if len(parts) == 2:
                a, b = parts
                self.declare(a.strip(), b.strip())
#@+node:ekr.20110312162243.14264: *14* declare
def declare(self, var, klass):
    vars = self.vars.get(var, [])
    if not vars:
        self.vars[var] = vars
    vars.append(klass)
#@+node:ekr.20140813052702.18194: *12* class FileNameChooser
class FileNameChooser:
    """A class encapsulation file selection & completion logic."""
    @others
#@+node:ekr.20140813052702.18195: *13* fnc.__init__
def __init__(self, c):
    """Ctor for FileNameChooser class."""
    self.c = c
    self.k = c.k
    assert c and c.k
    self.log = c.frame.log or g.NullObject()
    self.callback = None
    self.filterExt = None
    self.log = None  # inited later.
    self.prompt = None
    self.tabName = None
#@+node:ekr.20140813052702.18196: *13* fnc.compute_tab_list
def compute_tab_list(self):
    """Compute the list of completions."""
    path = self.get_label()
    # #215: insert-file-name doesn't process ~
    path = g.os_path_expanduser(path)
    sep = os.path.sep
    if g.os_path_exists(path):
        if g.os_path_isdir(path):
            if path.endswith(os.sep):
                aList = g.glob_glob(path + '*')
            else:
                aList = g.glob_glob(path + sep + '*')
            tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
        else:
            # An existing file.
            tabList = [path]
    else:
        if path and path.endswith(sep):
            path = path[:-1]
        aList = g.glob_glob(path + '*')
        tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
    if self.filterExt:
        for ext in self.filterExt:
            tabList = [z for z in tabList if not z.endswith(ext)]
    tabList = [g.os_path_normslashes(z) for z in tabList]
    junk, common_prefix = g.itemsMatchingPrefixInList(path, tabList)
    return common_prefix, tabList
#@+node:ekr.20140813052702.18197: *13* fnc.do_back_space
def do_back_space(self):
    """Handle a back space."""
    w = self.c.k.w
    if w and w.hasSelection():
        # s = w.getAllText()
        i, j = w.getSelectionRange()
        w.delete(i, j)
        s = self.get_label()
    else:
        s = self.get_label()
        if s:
            s = s[:-1]
        self.set_label(s)
    if s:
        common_prefix, tabList = self.compute_tab_list()
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    self.show_tab_list(tabList)
#@+node:ekr.20140813052702.18198: *13* fnc.do_char
def do_char(self, char):
    """Handle a non-special character."""
    w = self.c.k.w
    if w and w.hasSelection:
        # s = w.getAllText()
        i, j = w.getSelectionRange()
        w.delete(i, j)
        w.setInsertPoint(i)
        w.insert(i, char)
    else:
        self.extend_label(char)
    common_prefix, tabList = self.compute_tab_list()
    self.show_tab_list(tabList)
    if common_prefix:
        if 0:
            # This is a bit *too* helpful.
            # It's too easy to type ahead by mistake.
            # Instead, completion should happen only when the user types <tab>.
            self.set_label(common_prefix)
        # Recompute the tab list.
        common_prefix, tabList = self.compute_tab_list()
        self.show_tab_list(tabList)
        if len(tabList) == 1:
            # Automatically complete the typing only if there is only one item in the list.
            self.set_label(common_prefix)
    else:
        # Restore everything.
        self.set_label(self.get_label()[:-1])
        self.extend_label(char)
#@+node:ekr.20140813052702.18199: *13* fnc.do_tab
def do_tab(self):
    """Handle tab completion."""
    old = self.get_label()
    common_prefix, tabList = self.compute_tab_list()
    self.show_tab_list(tabList)
    if len(tabList) == 1:
        common_prefix = tabList[0]
        self.set_label(common_prefix)
    elif len(common_prefix) > len(old):
        self.set_label(common_prefix)
#@+node:ekr.20140813052702.18200: *13* fnc.get_file_name (entry)
def get_file_name(self, event, callback, filterExt, prompt, tabName):
    """Get a file name, supporting file completion."""
    c, k = self.c, self.c.k
    tag = 'get-file-name'
    state = k.getState(tag)
    char = event.char if event else ''
    if state == 0:
        # Re-init all ivars.
        self.log = c.frame.log or g.NullObject()
        self.callback = callback
        self.filterExt = filterExt or ['.pyc', '.bin',]
        self.prompt = prompt
        self.tabName = tabName
        join = g.os_path_finalize_join
        finalize = g.os_path_finalize
        normslashes = g.os_path_normslashes
        # #467: Add setting for preferred directory.
        directory = c.config.getString('initial-chooser-directory')
        if directory:
            directory = finalize(directory)
            if not g.os_path_exists(directory):
                g.es_print('@string initial-chooser-directory not found',
                    normslashes(directory))
                directory = None
        if not directory:
            directory = finalize(os.curdir)
        # Init the label and state.
        tail = k.functionTail and k.functionTail.strip()
        label = join(directory, tail) if tail else directory + os.sep
        self.set_label(normslashes(label))
        k.setState(tag, 1, self.get_file_name)
        self.log.selectTab(self.tabName)
        junk, tabList = self.compute_tab_list()
        self.show_tab_list(tabList)
        c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n', 'Return'):
        self.log.deleteTab(self.tabName)
        path = self.get_label()
        k.keyboardQuit()
        if self.callback:
            # pylint: disable=not-callable
            self.callback(path)
        else:
            g.trace('no callback')
    elif char in ('\t', 'Tab'):
        self.do_tab()
        c.minibufferWantsFocus()
    elif char in ('\b', 'BackSpace'):
        self.do_back_space()
        c.minibufferWantsFocus()
    elif k.isPlainKey(char):
        self.do_char(char)
    else:
        pass
#@+node:ekr.20140813052702.18201: *13* fnc.extend/get/set_label
def extend_label(self, s):
    """Extend the label by s."""
    self.c.k.extendLabel(s, select=False, protect=False)

def get_label(self):
    """Return the label, not including the prompt."""
    return self.c.k.getLabel(ignorePrompt=True)

def set_label(self, s):
    """Set the label after the prompt to s. The prompt never changes."""
    self.c.k.setLabel(self.prompt, protect=True)
    self.c.k.extendLabel(s or '', select=False, protect=False)
#@+node:ekr.20140813052702.18202: *13* fnc.show_tab_list
def show_tab_list(self, tabList):
    """Show the tab list in the log tab."""
    self.log.clearTab(self.tabName)
    s = g.os_path_finalize(os.curdir) + os.sep
    es = []
    for path in tabList:
        theDir, fileName = g.os_path_split(path)
        s = theDir if path.endswith(os.sep) else fileName
        s = fileName or g.os_path_basename(theDir) + os.sep
        es.append(s)
    g.es('', '\n'.join(es), tabName=self.tabName)
#@+node:ekr.20140816165728.18940: *12* class GetArg
class GetArg:
    """
    A class encapsulating all k.getArg logic.

    k.getArg maps to ga.get_arg, which gets arguments in the minibuffer.

    For details, see the docstring for ga.get_arg
    """
    @others
#@+node:ekr.20140818052417.18241: *13* ga.birth
#@+node:ekr.20140816165728.18952: *14* ga.__init__
def __init__(self, c, prompt='full-command: ', tabName='Completion'):
    """Ctor for GetArg class."""
    # Common ivars.
    self.c = c
    self.k = c.k
    assert c
    assert c.k
    self.log = c.frame.log or g.NullObject()
    self.tabName = tabName
    # State vars.
    self.after_get_arg_state = None, None, None
    self.arg_completion = True
    self.handler = None
    self.tabList = []
    # Tab cycling ivars...
    self.cycling_prefix = None
    self.cycling_index = -1
    self.cycling_tabList = []
    # The following are k globals.
        # k.arg.
        # k.argSelectedText
        # k.oneCharacterArg
#@+node:ekr.20140817110228.18321: *13* ga.compute_tab_list
# Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())

def compute_tab_list(self, tabList):
    """Compute and show the available completions."""
    # Support vim-mode commands.
    command = self.get_label()
    if self.is_command(command):
        tabList, common_prefix = g.itemsMatchingPrefixInList(command, tabList)
        return common_prefix, tabList
    #
    # For now, disallow further completions if something follows the command.
    command = self.get_command(command)
    return command, [command]
#@+node:ekr.20140816165728.18965: *13* ga.do_back_space (entry)
# Called from k.fullCommand: with defaultTabList = list(c.commandsDict.keys())

def do_back_space(self, tabList, completion=True):
    """Handle a backspace and update the completion list."""
    k = self.k
    self.tabList = tabList[:] if tabList else []
    # Update the label.
    w = k.w
    i, j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if ins > len(k.mb_prefix):
        # Step 1: actually delete the character.
        i, j = w.getSelectionRange()
        if i == j:
            ins -= 1
            w.delete(ins)
            w.setSelectionRange(ins, ins, insert=ins)
        else:
            ins = i
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=ins)
    if w.getAllText().strip():
        junk, tabList = self.compute_tab_list(self.tabList)
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    if completion:
        # #323.
        common_prefix, tabList = self.compute_tab_list(tabList)
        self.show_tab_list(tabList)
        self.reset_tab_cycling()
#@+node:ekr.20140817110228.18323: *13* ga.do_tab (entry) & helpers
# Used by ga.get_arg and k.fullCommand.

def do_tab(self, tabList, completion=True):
    """Handle tab completion when the user hits a tab."""
    c = self.c
    if completion:
        tabList = self.tabList = tabList[:] if tabList else []
        common_prefix, tabList = self.compute_tab_list(tabList)
        if self.cycling_prefix and not self.cycling_prefix.startswith(common_prefix):
            self.cycling_prefix = common_prefix
        #
        # No tab cycling for completed commands having
        # a 'tab_callback' attribute.
        if len(tabList) == 1 and self.do_tab_callback():
            return
        # #323: *Always* call ga.do_tab_list.
        self.do_tab_cycling(common_prefix, tabList)
    c.minibufferWantsFocus()
#@+node:ekr.20140818145250.18235: *14* ga.do_tab_callback
def do_tab_callback(self):
    """
    If the command-name handler has a tab_callback,
    call handler.tab_callback() and return True.
    """
    c, k = self.c, self.k
    commandName, tail = k.getMinibufferCommandName()
    handler = c.commandsDict.get(commandName)
    if hasattr(handler, 'tab_callback'):
        self.reset_tab_cycling()
        k.functionTail = tail
            # For k.getFileName.
        handler.tab_callback()
        return True
    return False
#@+node:ekr.20140819050118.18317: *14* ga.do_tab_cycling
def do_tab_cycling(self, common_prefix, tabList):
    """Put the next (or first) completion in the minibuffer."""
    s = self.get_label()
    if not common_prefix:
        # Leave the minibuffer as it is.
        self.show_tab_list(tabList)
    # #323.
    elif (
        self.cycling_prefix and
        s.startswith(self.cycling_prefix) and
        sorted(self.cycling_tabList) == sorted(tabList)  # Bug fix: 2016/10/14
    ):
        n = self.cycling_index
        n = self.cycling_index = n + 1 if n + 1 < len(self.cycling_tabList) else 0
        self.set_label(self.cycling_tabList[n])
        self.show_tab_list(self.cycling_tabList)
    else:
        # Restart.
        self.show_tab_list(tabList)
        self.cycling_tabList = tabList[:]
        self.cycling_prefix = common_prefix
        self.set_label(common_prefix)
        if tabList and common_prefix == tabList[0]:
            self.cycling_index = 0
        else:
            self.cycling_index = -1
#@+node:ekr.20140819050118.18318: *14* ga.reset_tab_cycling
def reset_tab_cycling(self):
    """Reset all tab cycling ivars."""
    self.cycling_prefix = None
    self.cycling_index = -1
    self.cycling_tabList = []
#@+node:ekr.20140816165728.18958: *13* ga.extend/get/set_label
# Not useful because k.entendLabel doesn't handle selected text.

if 0:

    def extend_label(self, s):
        """Extend the label by s."""
        self.c.k.extendLabel(s, select=False, protect=False)

def get_label(self):
    """Return the label, not including the prompt."""
    return self.c.k.getLabel(ignorePrompt=True)

def set_label(self, s):
    """Set the label after the prompt to s. The prompt never changes."""
    k = self.c.k
    # Using k.mb_prefix is simplest.  No ga.ivars need be inited.
    k.setLabel(k.mb_prefix, protect=True)
    k.extendLabel(s or '', select=False, protect=False)
#@+node:ekr.20140816165728.18941: *13* ga.get_arg (entry) & helpers
def get_arg(self, event,
    returnKind=None, returnState=None, handler=None,
    tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << ga.get_arg docstring >>
    if tabList is None: tabList = []
    c, k = self.c, self.k
    state = k.getState('getArg')
    c.check_event(event)
    c.minibufferWantsFocusNow()
    char = event.char if event else ''
    if state > 0:
        k.setLossage(char, stroke)
    if state == 0:
        self.do_state_zero(completion, event, handler, oneCharacter,
            returnKind, returnState, tabList, useMinibuffer)
        return
    if char == 'Escape':
        k.keyboardQuit()
    elif self.should_end(char, stroke):
        self.do_end(event, char, stroke)
    elif char in ('\t', 'Tab'):
        self.do_tab(self.tabList, self.arg_completion)
    elif char in ('\b', 'BackSpace'):
        self.do_back_space(self.tabList, self.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        # Ignore only F-keys. Ignoring all except plain keys would kill unicode searches.
        pass
    else:
        self.do_char(event, char)
#@+node:ekr.20140822051549.18299: *14* << ga.get_arg docstring >>
"""
Accumulate an argument. Enter the given return state when done.

Ctrl-G will abort this processing at any time.

All commands needing user input call k.getArg, which just calls ga.get_arg.

The arguments to ga.get_arg are as follows:

event:              The event passed to the command.

returnKind=None:    A string.
returnState=None,   An int.
handler=None,       A function.

    When the argument is complete, ga.do_end does::

        if kind: k.setState(kind,n,handler)

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
#@+node:ekr.20161019060054.1: *14* ga.cancel_after_state
def cancel_after_state(self):

    self.after_get_arg_state = None
#@+node:ekr.20140816165728.18955: *14* ga.do_char
def do_char(self, event, char):
    """Handle a non-special character."""
    k = self.k
    k.updateLabel(event)
    # Any plain key resets tab cycling.
    self.reset_tab_cycling()
#@+node:ekr.20140817110228.18316: *14* ga.do_end
def do_end(self, event, char, stroke):
    """A return or escape has been seen."""
    k = self.k
    if char == '\t' and char in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if stroke and stroke in k.getArgEscapes:
        k.getArgEscapeFlag = True
    # Get the value.
    gui_arg = getattr(g.app.gui, 'curses_gui_arg', None)
    if k.oneCharacterArg:
        k.arg = char
    else:
        # A hack to support the curses gui.
        k.arg = gui_arg or self.get_label()
    kind, n, handler = self.after_get_arg_state
    if kind:
        k.setState(kind, n, handler)
    self.log.deleteTab('Completion')
    self.reset_tab_cycling()
    if handler:
        # pylint: disable=not-callable
        handler(event)
#@+node:ekr.20140817110228.18317: *14* ga.do_state_zero
def do_state_zero(self, completion, event, handler, oneCharacter,
    returnKind, returnState, tabList, useMinibuffer
):
    """Do state 0 processing."""
    c, k = self.c, self.k
    #
    # Set the ga globals...
    k.getArgEscapeFlag = False
    self.after_get_arg_state = returnKind, returnState, handler
    self.arg_completion = completion
    self.cycling_prefix = None
    self.handler = handler
    self.tabList = tabList[:] if tabList else []
    #
    # Set the k globals...
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    #
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg', 1, k.getArg)
    # pylint: disable=consider-using-ternary
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
#@+node:ekr.20140818103808.18234: *14* ga.should_end
def should_end(self, char, stroke):
    """Return True if ga.get_arg should return."""
    k = self.k
    return (
        char in ('\n', 'Return',) or
        k.oneCharacterArg or
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes
            # The Find Easter Egg.
    )
#@+node:ekr.20140818103808.18235: *14* ga.trace_state
def trace_state(self, char, completion, handler, state, stroke):
    """Trace the vars and ivars."""
    k = self.c.k
    g.trace(
        'state', state, 'char', repr(char), 'stroke', repr(stroke),
        # 'isPlain',k.isPlainKey(stroke),
        '\n',
        'escapes', k.getArgEscapes,
        'completion', self.arg_completion,
        'handler', self.handler and self.handler.__name__ or 'None',
    )
#@+node:ekr.20140818074502.18222: *13* ga.get_command
def get_command(self, s):
    """Return the command part of a minibuffer contents s."""
    # #1121.
    if ' ' in s:
        return s[: s.find(' ')].strip()
    return s
#@+node:ekr.20140818085719.18227: *13* ga.get_minibuffer_command_name
def get_minibuffer_command_name(self):
    """Return the command name in the minibuffer."""
    s = self.get_label()
    command = self.get_command(s)
    tail = s[len(command) :]
    return command, tail
#@+node:ekr.20140818074502.18221: *13* ga.is_command
def is_command(self, s):
    """Return False if something, even a blank, follows a command."""
    # #1121: only ascii space terminates a command.
    return ' ' not in s
#@+node:ekr.20140816165728.18959: *13* ga.show_tab_list & helper
def show_tab_list(self, tabList):
    """Show the tab list in the log tab."""
    k = self.k
    self.log.clearTab(self.tabName)
    d = k.computeInverseBindingDict()
    data, legend, n = [], False, 0
    for commandName in tabList:
        dataList = d.get(commandName, [])
        if dataList:
            for z in dataList:
                pane, key = z
                s1a = '' if pane in ('all:', 'button:') else f"{pane} "
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = self.command_source(commandName)
                if s2 != ' ': legend = True
                s3 = commandName
                data.append((s1, s2, s3),)
                n = max(n, len(s1))
        else:
            # Bug fix: 2017/03/26
            data.append(('', ' ', commandName),)
    aList = ['%*s %s %s' % (-n, z1, z2, z3) for z1, z2, z3 in data]
    if legend:
        aList.extend([
            '',
            'legend:',
            'G leoSettings.leo',
            'M myLeoSettings.leo',
            'L local .leo File',
        ])
    g.es('', '\n'.join(aList), tabName=self.tabName)
#@+node:ekr.20150402034643.1: *14* ga.command_source
def command_source(self, commandName):
    """
    Return the source legend of an @button/@command node.
    'G' leoSettings.leo
    'M' myLeoSettings.leo
    'L' local .leo File
    ' ' not an @command or @button node
    """
    c = self.c
    if commandName.startswith('@'):
        d = c.commandsDict
        func = d.get(commandName)
        if hasattr(func, 'source_c'):
            c2 = func.source_c
            fn2 = c2.shortFileName().lower()
            if fn2.endswith('myleosettings.leo'):
                return 'M'
            if fn2.endswith('leosettings.leo'):
                return 'G'
            return 'L'
        return '?'
    return ' '
#@+node:ekr.20061031131434.74: *12* class KeyHandlerClass
class KeyHandlerClass:
    """
    A class to support emacs-style commands.
    c.k is an instance of this class.
    """
    @others
#@+node:ekr.20061031131434.75: *13*  k.Birth
#@+node:ekr.20061031131434.76: *14* k.__init__& helpers
def __init__(self, c):
    """Create a key handler for c."""
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.killedBindings = []
        # A list of commands whose bindings have been set to None in the local file.
    self.replace_meta_with_alt = False
        # True: (Mac only) swap Meta and Alt keys.
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines', 'sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.reloadSettings()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None  # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
#@+node:ekr.20061031131434.78: *15* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
#@+node:ekr.20061031131434.79: *15* k.defineInternalIvars
def defineInternalIvars(self):
    """Define internal ivars of the KeyHandlerClass class."""
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of BindingInfo objects.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.commandHistory = []
    self.commandIndex = 0
        # List/stack of previously executed commands.
        # Up arrow will select commandHistory[commandIndex]
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are BindingInfo objects.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.demoNextKey = None  # New support for the demo.py plugin.
    self.demoPrevKey = None  # New support for the demo.py plugin.
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
#@+node:ekr.20080509064108.7: *15* k.defineMultiLineCommands
def defineMultiLineCommands(self):
    k = self
    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RectangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
#@+node:ekr.20080509064108.6: *15* k.defineSingleLineCommands
def defineSingleLineCommands(self):
    k = self
    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home',  # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
            # 'negative-argument',
            # 'number-command',
            # 'number-command-0',
            # 'number-command-1',
            # 'number-command-2',
            # 'number-command-3',
            # 'number-command-4',
            # 'number-command-5',
            # 'number-command-6',
            # 'number-command-7',
            # 'number-command-8',
            # 'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',  # 2011/06/07
        'set-find-node-only',  # 2011/06/07
        'set-find-suboutline-only',  # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
    ]
#@+node:ekr.20150509035028.1: *14* k.cmd (decorator)
def cmd(name):
    """Command decorator for the leoKeys class."""
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'k',])
#@+node:ekr.20061031131434.80: *14* k.finishCreate & helpers
def finishCreate(self):
    """
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    """
    c, k = self.c, self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
        # Important: This must be called this now,
        # even though LM.laod calls g.app.makeAllBindings later.
    k.initCommandHistory()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
#@+node:ekr.20061101071425: *14* k.oops
def oops(self):

    g.trace('Should be defined in subclass:', g.callers(4))
#@+node:ekr.20120217070122.10479: *14* k.reloadSettings
def reloadSettings(self):
    # Part 1: These were in the ctor.
    c = self.c
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter = getBool('enable-autocompleter-initially')
    self.enable_calltips = getBool('enable-calltips-initially')
    self.ignore_unbound_non_ascii_keys = getBool('ignore-unbound-non-ascii-keys')
    self.minibuffer_background_color = getColor(
        'minibuffer-background-color') or 'lightblue'
    self.minibuffer_foreground_color = getColor(
        'minibuffer-foreground-color') or 'black'
    self.minibuffer_warning_color = getColor(
        'minibuffer-warning-color') or 'lightgrey'
    self.minibuffer_error_color = getColor('minibuffer-error-color') or 'red'
    self.replace_meta_with_alt = getBool('replace-meta-with-alt')
    self.warn_about_redefined_shortcuts = getBool('warn-about-redefined-shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings = c.config.getBool('enable-alt-ctrl-bindings')
    # Part 2: These were in finishCreate.
    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body-text-background-color') or 'white'
    fg = c.config.getColor('body-text-foreground-color') or 'black'
    self.command_mode_bg_color = getColor('command-mode-bg-color') or bg
    self.command_mode_fg_color = getColor('command-mode-fg-color') or fg
    self.insert_mode_bg_color = getColor('insert-mode-bg-color') or bg
    self.insert_mode_fg_color = getColor('insert-mode-fg-color') or fg
    self.overwrite_mode_bg_color = getColor('overwrite-mode-bg-color') or bg
    self.overwrite_mode_fg_color = getColor('overwrite-mode-fg-color') or fg
    self.unselected_body_bg_color = getColor('unselected-body-bg-color') or bg
    self.unselected_body_fg_color = getColor('unselected-body-fg-color') or bg
#@+node:ekr.20110209093958.15413: *14* k.setDefaultEditingKeyAction
def setDefaultEditingAction(self):
    k = self; c = k.c
    action = c.config.getString('default-editing-state') or 'insert'
    action.lower()
    if action not in ('command', 'insert', 'overwrite'):
        g.trace(f"ignoring default_editing_state: {action}")
        action = 'insert'
    self.defaultEditingAction = action
#@+node:ekr.20061031131434.82: *14* k.setDefaultUnboundKeyAction
def setDefaultUnboundKeyAction(self, allowCommandState=True):
    k = self; c = k.c
    defaultAction = c.config.getString('top-level-unbound-key-action') or 'insert'
    defaultAction.lower()
    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command', 'insert', 'overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace(f"ignoring top_level_unbound_key_action setting: {defaultAction}")
        self.unboundKeyAction = 'insert'
    self.defaultUnboundKeyAction = self.unboundKeyAction
    k.setInputState(self.defaultUnboundKeyAction)
#@+node:ekr.20061031131434.88: *13* k.Binding
#@+node:ekr.20061031131434.89: *14* k.bindKey & helpers
def bindKey(self, pane, shortcut, callback, commandName, modeFlag=False, tag=None):
    """
    Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict
    and k.bindingsDict.

    tag gives the source of the binding.
    
    Return True if the binding was made successfully.
    """
    k = self
    if not shortcut:
        # Don't use this method to undo bindings.
        return False
    if not k.check_bind_key(commandName, pane, shortcut):
        return False
    aList = k.bindingsDict.get(shortcut, [])
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s, stroke
        else:
            assert shortcut, g.callers()
            stroke = g.KeyStroke(binding=shortcut)
        bi = g.BindingInfo(
            kind=tag,
            pane=pane,
            func=callback,
            commandName=commandName,
            stroke=stroke)
        if shortcut:
            k.bindKeyToDict(pane, shortcut, bi)
                # Updates k.masterBindingsDict
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList, commandName, pane, shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(bi)
        if shortcut:
            assert stroke
            k.bindingsDict[stroke] = aList
        return True
    except Exception:  # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding', shortcut, 'to', commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey  # For compatibility
#@+node:ekr.20120130074511.10228: *15* k.check_bind_key
def check_bind_key(self, commandName, pane, stroke):
    """
    Return True if the binding of stroke to commandName for the given
    pane can be made.
    """
    # k = self
    assert g.isStroke(stroke)
    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter', 'leave'):
        if stroke.lower().find(s) > -1:
            g.warning('ignoring invalid key binding:', f"{commandName} = {stroke}")
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding', stroke, commandName, g.callers())
        return False
    return True
#@+node:ekr.20120130074511.10227: *15* k.kill_one_shortcut
def kill_one_shortcut(self, stroke):
    """
    Update the *configuration* dicts so that c.config.getShortcut(name)
    will return None for all names *presently* bound to the stroke.
    """
    k = self; c = k.c
    lm = g.app.loadManager
    if 0:
        # This does not fix 327: Create a way to unbind bindings
        assert stroke in (None, 'None', 'none') or g.isStroke(stroke), repr(stroke)
    else:
        # A crucial shortcut: inverting and uninverting dictionaries is slow.
        # Important: the comparison is valid regardless of the type of stroke.
        if stroke in (None, 'None', 'none'):
            return
        assert g.isStroke(stroke), stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDict(  # was TypedDictOfLists.
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.BindingInfo,
        )
    inv_d = lm.invert(d)
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
#@+node:ekr.20061031131434.92: *15* k.remove_conflicting_definitions
def remove_conflicting_definitions(self, aList, commandName, pane, shortcut):

    k = self
    result = []
    for bi in aList:
        if pane in ('button', 'all', bi.pane):
            k.kill_one_shortcut(shortcut)
        else:
            result.append(bi)
    return result
#@+node:ekr.20061031131434.93: *15* k.bindKeyToDict
def bindKeyToDict(self, pane, stroke, bi):
    """Update k.masterBindingsDict for the stroke."""
    # New in Leo 4.4.1: Allow redefintions.
    # Called from makeBindingsFromCommandsDict.
    k = self
    assert g.isStroke(stroke), stroke
    d = k.masterBindingsDict.get(pane, {})
    d[stroke] = bi
    k.masterBindingsDict[pane] = d
#@+node:ekr.20061031131434.94: *15* k.bindOpenWith
def bindOpenWith(self, d):
    """Register an open-with command."""
    k = self; c = k.c
    shortcut = d.get('shortcut') or ''
    name = d.get('name')
    # The first parameter must be event, and it must default to None.

    def openWithCallback(event=None, c=c, d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.

    commandName = f"open-with-{name.lower()}"
    k.registerCommand(
        allowBinding=True,
        commandName=commandName,
        func=openWithCallback,
        pane='all',
        shortcut=shortcut,
    )
#@+node:ekr.20061031131434.95: *14* k.checkBindings
def checkBindings(self):
    """
    Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course."""
    k = self; c = k.c
    if not c.config.getBool('warn-about-missing-settings'): return
    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&', '')
        if not c.config.exists(key, 'shortcut'):
            if abbrev:
                g.trace(f"No shortcut for abbrev {name} -> {abbrev} = {key}")
            else:
                g.trace(f"No shortcut for {name} = {key}")
#@+node:ekr.20061031131434.97: *14* k.completeAllBindings
def completeAllBindings(self, w=None):
    """
    Make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.
    """
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
#@+node:ekr.20061031131434.96: *14* k.completeAllBindingsForWidget
def completeAllBindingsForWidget(self, w):
    """Make all a master gui binding for widget w."""
    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        k.makeMasterGuiBinding(stroke, w=w)
#@+node:ekr.20070218130238: *14* k.dumpMasterBindingsDict
def dumpMasterBindingsDict(self):
    """Dump k.masterBindingsDict."""
    k = self; d = k.masterBindingsDict
    g.pr('\nk.masterBindingsDict...\n')
    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            bi = d2.get(key2)
            g.pr(f"{key2:20} {bi.commandName}")
#@+node:ekr.20061031131434.99: *14* k.initAbbrev & helper
def initAbbrev(self):
    k = self; c = k.c; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass  # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName, key)
#@+node:ekr.20130924035029.12741: *15* k.initOneAbbrev
def initOneAbbrev(self, commandName, key):
    """Enter key as an abbreviation for commandName in c.commandsDict."""
    c = self.c
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s', key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            c.commandsDict[key] = func
        else:
            g.warning('bad abbrev:', key, 'unknown command name:', commandName)
#@+node:ekr.20061031131434.101: *14* k.initSpecialIvars
def initSpecialIvars(self):
    """Set ivars for special keystrokes from previously-existing bindings."""
    c, k = self.c, self
    warn = c.config.getBool('warn-about-missing-settings')
    for ivar, commandName in (
        ('fullCommandKey', 'full-command'),
        ('abortAllModesKey', 'keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey', 'auto-complete-force'),
        ('demoNextKey', 'demo-next'),
        ('demoPrevKey', 'demo-prev'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList, found = aList or [], False
        for pane in ('text', 'all'):
            for bi in aList:
                if bi.pane == pane:
                    setattr(k, ivar, bi.stroke)
                    found = True; break
        if not found and warn:
            g.trace(f"no setting for {commandName}")
#@+node:ekr.20061031131434.98: *14* k.makeAllBindings
def makeAllBindings(self):
    """Make all key bindings in all of Leo's panes."""
    k = self
    k.bindingsDict = {}
    k.addModeCommands()
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
#@+node:ekr.20061031131434.102: *14* k.makeBindingsFromCommandsDict
def makeBindingsFromCommandsDict(self):
    """Add bindings for all entries in c.commandsDict."""
    c, k = self.c, self
    d = c.commandsDict
    #
    # Step 1: Create d2.
    # Keys are strokes. Values are lists of bi with bi.stroke == stroke.
    d2 = g.TypedDict(  # was TypedDictOfLists.
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,
        valType=g.BindingInfo,
    )
    for commandName in sorted(d):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for bi in aList:
            # Important: bi.stroke is already canonicalized.
            stroke = bi.stroke
            bi.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add_to_list(stroke, bi)
    #
    # Step 2: make the bindings.
    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for bi in aList2:
            commandName = bi.commandName
            command = c.commandsDict.get(commandName)
            tag = bi.kind
            pane = bi.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane, stroke, command, commandName, tag=tag)
#@+node:ekr.20061031131434.103: *14* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
#@+node:ekr.20150402111403.1: *13* k.Command history
#@+node:ekr.20150402111413.1: *14* k.addToCommandHistory
def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
#@+node:ekr.20150402165918.1: *14* k.commandHistoryDown
def commandHistoryFwd(self):
    """
    Move down the Command History - fall off the bottom (return empty string)
    if necessary
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        commandName = ''
        if i == len(h) - 1:
            # fall off the bottom
            i = None
        elif i is not None:
            # move to next down in list
            i += 1
            commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
#@+node:ekr.20150402171131.1: *14* k.commandHistoryUp
def commandHistoryBackwd(self):
    """
    Return the previous entry in the Command History - stay at the top
    if we are there
    """
    k = self
    h, i = k.commandHistory, k.commandIndex
    if h:
        if i is None:
            # first time in - set to last entry
            i = len(h) - 1
        elif i > 0:
            i -= 1
        commandName = h[i]
        k.commandIndex = i
        k.setLabel(k.mb_prefix + commandName)
#@+node:ekr.20150425143043.1: *14* k.initCommandHistory
def initCommandHistory(self):
    """Init command history from @data command-history nodes."""
    k, c = self, self.c
    aList = c.config.getData('history-list') or []
    for command in reversed(aList):
        k.addToCommandHistory(command)

def resetCommandHistory(self):
    """ reset the command history index to indicate that
        we are pointing 'past' the last entry
    """
    self.commandIndex = None
    #
#@+node:ekr.20150402111935.1: *14* k.sortCommandHistory
def sortCommandHistory(self):
    """Sort the command history."""
    k = self
    k.commandHistory.sort()
    k.commandIndex = None
#@+node:ekr.20061031131434.104: *13* k.Dispatching
#@+node:ekr.20061031131434.111: *14* k.fullCommand (alt-x) & helper
@cmd('full-command')
def fullCommand(
    self,
    event,
    specialStroke=None,
    specialFunc=None,
    help=False,
    helpHandler=None,
):
    """Handle 'full-command' (alt-x) mode."""
    try:
        k = self; c = k.c
        state = k.getState('full-command')
        helpPrompt = 'Help for command: '
        c.check_event(event)
        ch = char = event.char if event else ''
        stroke = event.stroke if event else ''
        if state > 0:
            k.setLossage(char, stroke)
        if state == 0:
            k.mb_event = event  # Save the full event for later.
            k.setState('full-command', 1, handler=k.fullCommand)
            prompt = helpPrompt if help else k.altX_prompt
            k.setLabelBlue(prompt)
            k.mb_help = help
            k.mb_helpHandler = helpHandler
            c.minibufferWantsFocus()
        elif char == 'Ins' or k.isFKey(char):
            pass
        elif char == 'Escape':
            k.keyboardQuit()
        elif char == 'Down':
            k.commandHistoryFwd()
        elif char == 'Up':
            k.commandHistoryBackwd()
        elif char in ('\n', 'Return'):
            # Fix bug 157: save and restore the selection.
            w = k.mb_event and k.mb_event.w
            if w and hasattr(w, 'hasSelection') and w.hasSelection():
                sel1, sel2 = w.getSelectionRange()
                ins = w.getInsertPoint()
                c.frame.log.deleteTab('Completion')
                w.setSelectionRange(sel1, sel2, insert=ins)
            else:
                c.frame.log.deleteTab('Completion')
                    # 2016/04/27
            if k.mb_help:
                s = k.getLabel()
                commandName = s[len(helpPrompt) :].strip()
                k.clearState()
                k.resetLabel()
                if k.mb_helpHandler: k.mb_helpHandler(commandName)
            else:
                s = k.getLabel(ignorePrompt=True)
                commandName = s.strip()
                ok = k.callAltXFunction(k.mb_event)
                if ok:
                    k.addToCommandHistory(commandName)
        elif char in ('\t', 'Tab'):
            k.doTabCompletion(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif char in ('\b', 'BackSpace'):
            k.doBackSpace(list(c.commandsDict.keys()))
            c.minibufferWantsFocus()
        elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
            if specialStroke:
                g.trace(specialStroke)
                specialFunc()
            c.minibufferWantsFocus()
        else:
            # Clear the list, any other character besides tab indicates that a new prefix is in effect.
            k.mb_tabList = []
            k.updateLabel(event)
            k.mb_tabListPrefix = k.getLabel()
            c.minibufferWantsFocus()
    except Exception:
        g.es_exception()
        self.keyboardQuit()
#@+node:ekr.20061031131434.112: *15* k.callAltXFunction
def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
#@+node:ekr.20061031131434.114: *13* k.Externally visible commands
#@+node:ekr.20070613133500: *14* k.menuCommandKey
def menuCommandKey(self, event=None):
    # This method must exist, but it never gets called.
    pass
#@+node:ekr.20061031131434.119: *14* k.printBindings & helper
@cmd('show-bindings')
def printBindings(self, event=None):
    """Print all the bindings presently in effect."""
    k = self; c = k.c
    d = k.bindingsDict; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] @mode, @button, @command

'''
    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend, c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke), stroke
        aList = d.get(stroke, [])
        for bi in aList:
            s1 = '' if bi.pane == 'all' else bi.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = bi.commandName
            s4 = bi.kind or '<no hash>'
            data.append((s1, s2, s3, s4),)
    # Print keys by type:
    result = []
    result.append('\n' + legend)
    for prefix in (
        'Alt+Ctrl+Shift', 'Alt+Ctrl', 'Alt+Shift', 'Alt',  # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift', 'Ctrl+Meta', 'Ctrl+Shift', 'Ctrl',  # Ctrl+Key: done by Ctrl.
        'Meta+Key', 'Meta+Shift', 'Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1, s2, s3, s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append(f"***** {prefix}...\n")
        self.printBindingsHelper(result, data2, prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result, data, prefix=None)
    if not g.unitTesting:
        g.es_print('', ''.join(result), tabName=tabName)
    k.showStateAndMode()
    return result  # for unit test.
#@+node:ekr.20061031131434.120: *15* printBindingsHelper
def printBindingsHelper(self, result, data, prefix):
    """Helper for k.printBindings"""
    c, lm = self.c, g.app.loadManager
    data.sort(key=lambda x: x[1])
    data2, n = [], 0
    for pane, key, commandName, kind in data:
        key = key.replace('+Key', '')
        letter = lm.computeBindingLetter(c, kind)
        pane = f"{pane if pane else 'all':4}: "
        left = pane + key  # pane and shortcut fields
        n = max(n, len(left))
        data2.append((letter, left, commandName),)
    for z in data2:
        letter, left, commandName = z
        result.append('%s %*s %s\n' % (letter, -n, left, commandName))
    if data:
        result.append('\n')
#@+node:ekr.20120520174745.9867: *14* k.printButtons
@cmd('show-buttons')
def printButtons(self, event=None):
    """Print all @button and @command commands, their bindings and their source."""
    k = self; c = k.c
    tabName = '@buttons && @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('', s, tabName=tabName)

    data = []
    for aList in [c.config.getButtons(), c.config.getCommands()]:
        for z in aList:
            p, script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h, tag),)
    for aList in [g.app.config.atLocalButtonsList, g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h, 'L'),)
    result = [f"{z[1]} {z[0]}" for z in sorted(data)]
    result.extend([
        '',
        'legend:',
        'G leoSettings.leo',
        'L local .leo File',
        'M myLeoSettings.leo',
    ])
    put('\n'.join(result))
#@+node:ekr.20061031131434.121: *14* k.printCommands
@cmd('show-commands')
def printCommands(self, event=None):
    """Print all the known commands and their bindings, if any."""
    k = self; c = k.c; tabName = 'Commands'
    c.frame.log.clearTab(tabName)
    inverseBindingDict = k.computeInverseBindingDict()
    data, n = [], 0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName, [('', ''),])
        for z in dataList:
            pane, key = z
            pane = f"{pane} " if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key', '')
            s1 = pane + key
            s2 = commandName
            n = max(n, len(s1))
            data.append((s1, s2),)
    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n, z1, z2) for z1, z2 in data]
    g.es_print('', ''.join(lines), tabName=tabName)
#@+node:ekr.20061031131434.122: *14* k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous minibuffer command')
#@+node:ekr.20131017100903.16689: *15* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
#@+node:ekr.20061031131434.123: *14* k.set-xxx-State
@cmd('set-command-state')
def setCommandState(self, event):
    """Enter the 'command' editing state."""
    k = self
    k.setInputState('command', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-insert-state')
def setInsertState(self, event):
    """Enter the 'insert' editing state."""
    k = self
    k.setInputState('insert', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()

@cmd('set-overwrite-state')
def setOverwriteState(self, event):
    """Enter the 'overwrite' editing state."""
    k = self
    k.setInputState('overwrite', set_border=True)
    # This command is also valid in headlines.
        # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.124: *14* k.toggle-input-state
@cmd('toggle-input-state')
def toggleInputState(self, event=None):
    """The toggle-input-state command."""
    k = self; c = k.c
    default = c.config.getString('top-level-unbound-key-action') or 'insert'
    state = k.unboundKeyAction
    if default == 'insert':
        state = 'command' if state == 'insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state == 'overwrite' else 'overwrite'
    else:
        state = 'insert' if state == 'command' else 'command'  # prefer insert to overwrite.
    k.setInputState(state)
    k.showStateAndMode()
#@+node:ekr.20061031131434.125: *13* k.Externally visible helpers
#@+node:ekr.20140816165728.18968: *14* Wrappers for GetArg methods
# New in Leo 5.4

def getNextArg(self, handler):
    """
    Get the next arg.  For example, after a Tab in the find commands.
    See the docstring for k.get1Arg for examples of its use.
    """
    # Replace the current handler.
    self.getArgInstance.after_get_arg_state = ('getarg', 1, handler)
    self.c.minibufferWantsFocusNow()

# New in Leo 5.4

def get1Arg(self, event, handler,
    # returnKind=None, returnState=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    << docstring for k.get1arg >>
    returnKind, returnState = None, None
    assert handler, g.callers()
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def getArg(self, event,
    returnKind=None, returnState=None, handler=None,
    prefix=None, tabList=None, completion=True, oneCharacter=False,
    stroke=None, useMinibuffer=True
):
    """Convenience method mapping k.getArg to ga.get_arg."""
    self.getArgInstance.get_arg(event, returnKind, returnState, handler,
        tabList, completion, oneCharacter, stroke, useMinibuffer)

def doBackSpace(self, tabList, completion=True):
    """Convenience method mapping k.doBackSpace to ga.do_back_space."""
    self.getArgInstance.do_back_space(tabList, completion)

def doTabCompletion(self, tabList):
    """Convenience method mapping k.doTabCompletion to ga.do_tab."""
    self.getArgInstance.do_tab(tabList)

def getMinibufferCommandName(self):
    """
    Convenience method mapping k.getMinibufferCommandName to
    ga.get_minibuffer_command_name.
    """
    return self.getArgInstance.get_minibuffer_command_name()
#@+node:ekr.20161020031633.1: *15* << docstring for k.get1arg >>
"""
k.get1Arg: Handle the next character the user types when accumulating
a user argument from the minibuffer. Ctrl-G will abort this processing
at any time.

Commands should use k.get1Arg to get the first minibuffer argument and
k.getNextArg to get all other arguments.

Before going into the many details, let's look at some examples. This
code will work in any class having a 'c' ivar bound to a commander.

Example 1: get one argument from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        # k.arg contains the argument.
        # Finish the command.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

Example 2: get two arguments from the user:

    @g.command('my-command')
    def myCommand(self, event):
        k = self.c.k
        k.setLabelBlue('first prompt: ')
        k.get1Arg(event, handler=self.myCommand1)

    def myCommand1(self, event):
        k = self.c.k
        self.arg1 = k.arg
        k.extendLabel(' second prompt: ', select=False, protect=True)
        k.getNextArg(handler=self.myCommand2)

    def myCommand2(self, event):
        k = self.c.k
        # k.arg contains second argument.
        # Finish the command, using self.arg1 and k.arg.
        ...
        # Reset the minibuffer.
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()

k.get1Arg and k.getNextArg are a convenience methods. They simply pass
their arguments to the get_arg method of the singleton GetArg
instance. This docstring describes k.get1arg and k.getNextArg as if
they were the corresponding methods of the GetArg class.

k.get1Arg is a state machine. Logically, states are tuples (kind, n,
handler) though they aren't represented that way. When the state
machine in the GetArg class is active, the kind is 'getArg'. This
constant has special meaning to Leo's key-handling code.

The arguments to k.get1Arg are as follows:

event:              The event passed to the command.

handler=None,       An executable. k.get1arg calls handler(event)
                    when the user completes the argument by typing
                    <Return> or (sometimes) <tab>.

tabList=[]:         A list of possible completions.

completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

"""
#@+node:ekr.20061031131434.130: *14* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
#@+node:ekr.20061031131434.126: *14* k.manufactureKeyPressForCommandName
def manufactureKeyPressForCommandName(self, w, commandName):
    """
    Implement a command by passing a keypress to the gui.
    
    **Only unit tests use this method.**
    """
    c, k = self.c, self
    stroke = k.getStrokeForCommandName(commandName)
    assert g.isStroke(stroke), (commandName, stroke.__class__.__name__)
    shortcut = stroke.s
    shortcut = g.checkUnicode(shortcut)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = f"no shortcut for {commandName}"
        if g.app.unitTesting:
            raise AttributeError(message)
        g.error(message)
#@+node:ekr.20071212104050: *14* k.overrideCommand
def overrideCommand(self, commandName, func):
    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            bi = d2.get(key2)
            if bi.commandName == commandName:
                bi.func = func
                d2[key2] = bi
#@+node:ekr.20061031131434.131: *14* k.registerCommand
def registerCommand(self, commandName, func,
    allowBinding=False,
    pane='all',
    shortcut=None,  # Must be None unless allowBindings is True.
    ** kwargs
):
    """
    Make the function available as a minibuffer command.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.
    
    Ignore the 'shortcut' arg unless 'allowBinding' is True.
    
    Only k.bindOpenWith and the mod_scripting.py plugin should set
    allowBinding.
    """
    c, k = self.c, self
    if not func:
        g.es_print('Null func passed to k.registerCommand\n', commandName)
        return
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != func.__name__:
        g.trace('redefining', commandName, f, '->', func)
    c.commandsDict[commandName] = func
    # Warn about deprecated arguments.
    if shortcut and not allowBinding:
        g.es_print('The "shortcut" keyword arg to k.registerCommand will be ignored')
        g.es_print('Called from', g.callers())
        shortcut = None
    for arg, val in kwargs.items():
        if val is not None:
            g.es_print(f'The "{arg}" keyword arg to k.registerCommand is deprecated')
            g.es_print('Called from', g.callers())
    # Make requested bindings, even if a warning has been given.
    # This maintains strict compatibility with existing plugins and scripts.
    k.registerCommandShortcut(
        commandName=commandName,
        func=func,
        pane=pane,
        shortcut=shortcut,
    )
#@+node:ekr.20171124043747.1: *14* k.registerCommandShortcut
def registerCommandShortcut(self, commandName, func, pane, shortcut):
    """
    Register a shortcut for the a command.
    
    **Important**: Bindings created here from plugins can not be overridden.
    This includes @command and @button bindings created by mod_scripting.py.
    """
    c, k = self.c, self
    is_local = c.shortFileName() not in ('myLeoSettings.leo', 'leoSettings.leo')
    assert not g.isStroke(shortcut)
    if shortcut:
        stroke = g.KeyStroke(binding=shortcut) if shortcut else None
    elif commandName.lower() == 'shortcut':  # Causes problems.
        stroke = None
    elif is_local:
        # 327: Don't get defaults when handling a local file.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk, aList = c.config.getShortcut(commandName)
        for bi in aList:
            if bi.stroke and not bi.pane.endswith('-mode'):
                stroke = bi.stroke
                pane = bi.pane  # 2015/05/11.
                break
    if stroke:
        k.bindKey(pane, stroke, func, commandName, tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke)  # Must be a stroke.
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict[key] = c.commandsDict.get(commandName)
                    break
#@+node:ekr.20061031131434.127: *14* k.simulateCommand
def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
#@+node:ekr.20140813052702.18203: *14* k.getFileName
def getFileName(self, event, callback=None,
    filterExt=None, prompt='Enter File Name: ', tabName='Dired'
):
    """Get a file name from the minibuffer."""
    k = self
    k.fnc.get_file_name(event, callback, filterExt, prompt, tabName)
#@+node:ekr.20061031131434.145: *13* k.Master event handlers
#@+node:ekr.20061031131434.146: *14* k.masterKeyHandler & helpers
def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    c, k = self.c, self
    # Setup...
    if 'keys' in g.app.debug:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    c.insertCharFromEvent(event)
#@+node:ekr.20200524151214.1: *15* Setup...
#@+node:ekr.20180418040158.1: *16* k.checkKeyEvent
def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
#@+node:ekr.20180418034305.1: *16* k.setEventWidget
def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
#@+node:ekr.20180418031417.1: *16* k.traceVars
def traceVars(self, event):

    trace = False and not g.unitTesting
    traceGC = False
    verbose = False
    k = self
    if not trace:
        return
    if traceGC:
        g.printNewObjects('masterKey 1')
    if verbose:
        char = event.char
        state = k.state.kind
        stroke = event.stroke
        g.trace(
            f"stroke: {stroke!r}, "
            f"char: {char!r}, "
            f"state: {state}, "
            f"state2: {k.unboundKeyAction}")
#@+node:ekr.20180418031118.1: *15* 1. k.isSpecialKey
def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) > 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
#@+node:ekr.20110609161752.16459: *15* 2. k.setLossage
def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
#@+node:ekr.20180418024449.1: *15* 3. k.doKeyboardQuit
def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
#@+node:ekr.20180418023827.1: *15* 4. k.doDemo
def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
#@+node:ekr.20091230094319.6244: *15* 5. k.doMode & helpers
def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        return val != 'do-standard-keys'
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    return True
#@+node:ekr.20061031131434.108: *16* k.callStateFunction
def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) < 32 or ord(ch) > 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
#@+node:ekr.20061031131434.152: *16* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
#@+node:ekr.20180418114300.1: *17* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:vitalije.20170708161511.1: *16* k.handleInputShortcut
def handleInputShortcut(self, event, stroke):
    c, k, p = self.c, self, self.c.p
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = c.undoer.beforeChangeNodeContents(p)
        w.setSelectionAreas(before, sel, after)
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        w.onBodyChanged('change shortcut')
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = c.undoer.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
#@+node:vitalije.20170709151653.1: *17* k.isInShortcutBodyLine
_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
#@+node:vitalije.20170709151658.1: *17* k.isEditShortcutSensible
def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
#@+node:vitalije.20170709202924.1: *17* k.editShortcut_do_bind_helper
def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
#@+node:ekr.20180418025241.1: *15* 6. k.doVim
def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    c = self.c
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        return ok
    return False
#@+node:ekr.20180418033838.1: *15* 7. k.doBinding & helpers
def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    c, k = self.c, self
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event.stroke, event.w)
    #
    # #327: ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
#@+node:ekr.20091230094319.6240: *16* k.getPaneBinding & helper
def getPaneBinding(self, stroke, w):

    k = self
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        val = k.getBindingHelper(key, name, stroke, w)
        if val:
            return val
    return None
#@+node:ekr.20180418105228.1: *17* getPaneBindingHelper
def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
#@+node:ekr.20160409035115.1: *16* k.searchTree
def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
#@+node:ekr.20061031170011.3: *13* k.Minibuffer
# These may be overridden, but this code is now gui-independent.
#@+node:ekr.20061031170011.9: *14* k.extendLabel
def extendLabel(self, s, select=False, protect=False):

    k = self; c = k.c; w = self.w
    if not (w and s):
        return
    c.widgetWantsFocusNow(w)
    w.insert('end', s)
    if select:
        i, j = k.getEditableTextRange()
        w.setSelectionRange(i, j, insert=j)
    if protect:
        k.protectLabel()
#@+node:ekr.20061031170011.13: *14* k.getEditableTextRange
def getEditableTextRange(self):
    k = self; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i, j
#@+node:ekr.20061031170011.5: *14* k.getLabel
def getLabel(self, ignorePrompt=False):
    k = self; w = self.w
    if not w: return ''
    s = w.getAllText()
    if ignorePrompt:
        return s[len(k.mb_prefix) :]
    return s or ''
#@+node:ekr.20080408060320.791: *14* k.killLine
def killLine(self, protect=True):
    k = self
    w = k.w
    s = w.getAllText()
    s = s[: len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n, n, insert=n)
    if protect:
        k.mb_prefix = s
#@+node:ekr.20061031131434.135: *14* k.minibufferWantsFocus
# def minibufferWantsFocus(self):
    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
#@+node:ekr.20061031170011.6: *14* k.protectLabel
def protectLabel(self):
    k = self; w = self.w
    if not w: return
    k.mb_prefix = w.getAllText()
#@+node:ekr.20061031170011.7: *14* k.resetLabel
def resetLabel(self):
    """Reset the minibuffer label."""
    k = self
    c, w = k.c, k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:
        w.setSelectionRange(0, 0, insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label=f"{state.capitalize()} State")
#@+node:ekr.20080408060320.790: *14* k.selectAll
def selectAll(self):
    """Select all the user-editable text of the minibuffer."""
    w = self.w
    i, j = self.getEditableTextRange()
    w.setSelectionRange(i, j, insert=j)
#@+node:ekr.20061031170011.8: *14* k.setLabel
def setLabel(self, s, protect=False):
    """Set the label of the minibuffer."""
    c, k, w = self.c, self, self.w
    if w:
        # Support for the curses gui.
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            g.app.gui.set_minibuffer_label(c, s)
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n, n, insert=n)
        if protect:
            k.mb_prefix = s
#@+node:ekr.20061031170011.10: *14* k.setLabelBlue
def setLabelBlue(self, label, protect=True):
    """Set the minibuffer label."""
    k, w = self, self.w
    if hasattr(g.app.gui, 'set_minibuffer_label'):
        g.app.gui.set_minibuffer_label(self.c, label)
    elif w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label, protect=protect)
#@+node:ekr.20061031170011.11: *14* k.setLabelGrey
def setLabelGrey(self, label=None):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_warning')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
#@+node:ekr.20080510153327.2: *14* k.setLabelRed
def setLabelRed(self, label=None, protect=False):
    k = self; w = self.w
    if not w: return
    w.setStyleClass('minibuffer_error')
    if label is not None:
        k.setLabel(label, protect)
#@+node:ekr.20140822051549.18298: *14* k.setStatusLabel
def setStatusLabel(self, s):
    """
    Set the label to s.

    Use k.setStatusLabel, not k.setLael, to report the status of a Leo
    command. This allows the option to use g.es instead of the minibuffer
    to report status.
    """
    k = self
    k.setLabel(s, protect=False)
#@+node:ekr.20061031170011.12: *14* k.updateLabel
def updateLabel(self, event):
    """
    Mimic what would happen with the keyboard and a Text editor
    instead of plain accumulation.
    """
    k = self; c = k.c; w = self.w
    ch = event.char if event else ''
    if ch and ch not in ('\n', '\r'):
        c.widgetWantsFocusNow(w)
        i, j = w.getSelectionRange()
        ins = w.getInsertPoint()
        if i != j:
            w.delete(i, j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i - 1)
                i -= 1
        else:
            w.insert(ins, ch)
            i = ins + 1
#@+node:ekr.20120208064440.10190: *13* k.Modes
#@+node:ekr.20061031131434.100: *14* k.addModeCommands (enterModeCallback)
def addModeCommands(self):
    """Add commands created by @mode settings to c.commandsDict."""
    k = self; c = k.c
    d = g.app.config.modeCommandsDict  # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = enterModeCallback
#@+node:ekr.20061031131434.157: *14* k.badMode
def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey(f"@mode {modeName} is not defined (or is empty)")
#@+node:ekr.20061031131434.158: *14* k.createModeBindings
def createModeBindings(self, modeName, d, w):
    """Create mode bindings for the named mode using dictionary d for w, a text widget."""
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode<{modeName}>",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
#@+node:ekr.20120208064440.10179: *14* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
#@+node:ekr.20061031131434.160: *14* k.enterNamedMode
def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False  # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
#@+node:ekr.20061031131434.161: *14* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
#@+node:ekr.20061031131434.165: *14* k.modeHelp & helper
@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
#@+node:ekr.20061031131434.166: *15* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
#@+node:ekr.20061031131434.164: *14* k.reinitMode
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
#@+node:ekr.20120208064440.10199: *14* k.generalModeHandler
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
#@+node:ekr.20061031131434.156: *13* k.Modes
#@+node:ekr.20061031131434.163: *14* k.initMode
def initMode(self, event, modeName):

    k = self; c = k.c
    if not modeName:
        g.trace('oops: no modeName')
        return
    d = g.app.config.modeCommandsDict.get('enter-' + modeName)
    if not d:
        self.badMode(modeName)
        return
    k.modeBindingsDict = d
    bi = d.get('*command-prompt*')
    prompt = bi.kind if bi else modeName
    k.inputModeName = modeName
    k.silentMode = False
    aList = d.get('*entry-commands*', [])
    if aList:
        for bi in aList:
            commandName = bi.commandName
            k.simulateCommand(commandName)
            # Careful, the command can kill the commander.
            if g.app.quitting or not c.exists: return
            # New in Leo 4.5: a startup command can immediately transfer to another mode.
            if commandName.startswith('enter-'):
                return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    k.showStateAndMode(prompt=prompt)
#@+node:ekr.20061031131434.181: *13* k.Shortcuts & bindings
#@+node:ekr.20061031131434.176: *14* k.computeInverseBindingDict
def computeInverseBindingDict(self):
    k = self
    d = {}
        # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke), repr(stroke)
        aList = k.bindingsDict.get(stroke, [])
        for bi in aList:
            shortcutList = k.bindingsDict.get(bi.commandName, [])
                # Bug fix: 2017/03/26.
            bi_list = k.bindingsDict.get(
                stroke, g.BindingInfo(kind='dummy', pane='all'))
                # Important: only bi.pane is required below.
            for bi in bi_list:
                pane = f"{bi.pane}:"
                data = (pane, stroke)
                if data not in shortcutList:
                    shortcutList.append(data)
            d[bi.commandName] = shortcutList
    return d
#@+node:ekr.20061031131434.179: *14* k.getShortcutForCommand/Name
def getStrokeForCommandName(self, commandName):
    k = self; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke, aList in k.bindingsDict.items():
            for bi in aList:
                if bi.commandName == commandName:
                    return stroke
    return None
#@+node:ekr.20090518072506.8494: *14* k.isFKey
def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert isinstance(stroke, str) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
#@+node:ekr.20061031131434.182: *14* k.isPlainKey
def isPlainKey(self, stroke):
    """Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key."""
    if not stroke:
        return False
    if not g.isStroke(stroke):
        # Happens during unit tests.
        stroke = g.KeyStroke(stroke)
    #
    # altgr combos (Alt+Ctrl) are always plain keys
    # g.KeyStroke does not handle this, because it has no "c" ivar.
    #
    if stroke.isAltCtrl() and not self.enable_alt_ctrl_bindings:
        return True
    return stroke.isPlainKey()
#@+node:ekr.20061031131434.191: *14* k.prettyPrintKey
def prettyPrintKey(self, stroke, brief=False):

    if not stroke:
        return ''
    if not g.assert_is(stroke, g.KeyStroke):
        return stroke
    return stroke.prettyPrint()
#@+node:ekr.20110606004638.16929: *14* k.stroke2char
def stroke2char(self, stroke):
    """
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    """
    if not stroke:
        return ''
    if not g.isStroke(stroke):
        # vim commands pass a plain key.
        stroke = g.KeyStroke(stroke)
    return stroke.toInsertableChar()
#@+node:ekr.20061031131434.193: *13* k.States
#@+node:ekr.20061031131434.194: *14* k.clearState
def clearState(self):
    """Clear the key handler state."""
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
#@+node:ekr.20061031131434.196: *14* k.getState
def getState(self, kind):
    k = self
    val = k.state.n if k.state.kind == kind else 0
    return val
#@+node:ekr.20061031131434.195: *14* k.getStateHandler
def getStateHandler(self):
    return self.state.handler
#@+node:ekr.20061031131434.197: *14* k.getStateKind
def getStateKind(self):
    return self.state.kind
#@+node:ekr.20061031131434.198: *14* k.inState
def inState(self, kind=None):
    k = self
    if kind:
        return k.state.kind == kind and k.state.n is not None
    return k.state.kind and k.state.n is not None
#@+node:ekr.20080511122507.4: *14* k.setDefaultInputState
def setDefaultInputState(self):
    k = self; state = k.defaultUnboundKeyAction
    k.setInputState(state)
#@+node:ekr.20110209093958.15411: *14* k.setEditingState
def setEditingState(self):
    k = self; state = k.defaultEditingAction
    k.setInputState(state)
#@+node:ekr.20061031131434.133: *14* k.setInputState
def setInputState(self, state, set_border=False):
    k = self
    k.unboundKeyAction = state
#@+node:ekr.20061031131434.199: *14* k.setState
def setState(self, kind, n, handler=None):

    k = self
    if kind and n is not None:
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        k.clearState()
    # k.showStateAndMode()
#@+node:ekr.20061031131434.192: *14* k.showStateAndMode
def showStateAndMode(self, w=None, prompt=None, setFocus=True):
    """Show the state and mode at the start of the minibuffer."""
    c, k = self.c, self
    state = k.unboundKeyAction
    mode = k.getStateKind()
    if not g.app.gui:
        return
    if not w:
        if hasattr(g.app.gui, 'set_minibuffer_label'):
            pass  # we don't need w
        else:
            w = g.app.gui.get_focus(c)
            if not w:
                return
    isText = g.isTextWrapper(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree, 'getWrapper'):
            if hasattr(w, 'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2, item=None)
            isText = bool(w)  # A benign hack.
    if mode:
        if mode in ('getArg', 'getFileName', 'full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = f"{mode.capitalize()} Mode"
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = f"{state.capitalize()} State"
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state, w)
    # 2015/07/11: reset the status line.
    if hasattr(c.frame.tree, 'set_status_line'):
        c.frame.tree.set_status_line(c.p)
#@+node:ekr.20110202111105.15439: *14* k.showStateCursor
def showStateCursor(self, state, w):
    pass
#@+node:ekr.20120208064440.10150: *12* class ModeInfo
class ModeInfo:

    def __repr__(self):
        return f"<ModeInfo {self.name}>"

    __str__ = __repr__
    @others
#@+node:ekr.20120208064440.10193: *13* mode_i. ctor
def __init__(self, c, name, aList):

    self.c = c
    self.d = {}  # The bindings in effect for this mode.
        # Keys are names of (valid) command names, values are BindingInfo objects.
    self.entryCommands = []
        # A list of BindingInfo objects.
    self.k = c.k
    self.name = self.computeModeName(name)
    self.prompt = self.computeModePrompt(self.name)
    self.init(name, aList)
#@+node:ekr.20120208064440.10152: *13* mode_i.computeModeName
def computeModeName(self, name):
    s = name.strip().lower()
    j = s.find(' ')
    if j > -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]
    i = s.find('::')
    if i > -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]
    return s + '-mode'
#@+node:ekr.20120208064440.10156: *13* mode_i.computeModePrompt
def computeModePrompt(self, name):
    assert name == self.name
    s = 'enter-' + name.replace(' ', '-')
    i = s.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = s[i + 2 :].strip()
    else:
        prompt = s
    return prompt
#@+node:ekr.20120208064440.10160: *13* mode_i.createModeBindings
def createModeBindings(self, w):
    """Create mode bindings for w, a text widget."""
    c, d, k, modeName = self.c, self.d, self.k, self.name
    for commandName in d:
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print(f"no such command: {commandName} Referenced from {modeName}")
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode<{modeName}>",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
#@+node:ekr.20120208064440.10195: *13* mode_i.createModeCommand
def createModeCommand(self):
    c = self.c
    key = 'enter-' + self.name.replace(' ', '-')

    def enterModeCallback(event=None, self=self):
        self.enterMode()

    c.commandsDict[key] = f = enterModeCallback
    g.trace('(ModeInfo)', f.__name__, key,
        'len(c.commandsDict.keys())', len(list(c.commandsDict.keys())))
#@+node:ekr.20120208064440.10180: *13* mode_i.enterMode
def enterMode(self):

    c, k = self.c, self.k
    c.inCommand = False
        # Allow inner commands in the mode.
    event = None
    k.generalModeHandler(event, modeName=self.name)
#@+node:ekr.20120208064440.10153: *13* mode_i.init
def init(self, name, dataList):
    """aList is a list of tuples (commandName,bi)."""
    c, d, modeName = self.c, self.d, self.name
    for name, bi in dataList:
        if not name:
            # An entry command: put it in the special *entry-commands* key.
            self.entryCommands.append(bi)
        elif bi is not None:
            # A regular shortcut.
            bi.pane = modeName
            aList = d.get(name, [])
            # Important: use previous bindings if possible.
            key2, aList2 = c.config.getShortcut(name)
            aList3 = [z for z in aList2 if z.pane != modeName]
            if aList3:
                aList.extend(aList3)
            aList.append(bi)
            d[name] = aList
#@+node:ekr.20120208064440.10158: *13* mode_i.initMode
def initMode(self):

    c, k = self.c, self.c.k
    k.inputModeName = self.name
    k.silentMode = False
    for bi in self.entryCommands:
        commandName = bi.commandName
        k.simulateCommand(commandName)
        # Careful, the command can kill the commander.
        if g.app.quitting or not c.exists: return
        # New in Leo 4.5: a startup command can immediately transfer to another mode.
        if commandName.startswith('enter-'):
            return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(self.name, self.d, w)
    k.showStateAndMode(prompt=self.name)
#@+node:ekr.20200725105324.25: *10* << imports >> (leoKeys)
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,7 +1,6 @@
 import leo.core.leoGlobals as g
 import leo.commands.gotoCommands as gotoCommands
 import leo.external.codewise as codewise
-# import glob
 import inspect
 import os
 import re
@language python
#@+node:ekr.20200725105324.26: *11* Old:<< imports >> (leoKeys)
import leo.core.leoGlobals as g
import leo.commands.gotoCommands as gotoCommands
import leo.external.codewise as codewise
# import glob
import inspect
import os
import re
import string
import sys
import time
assert time
#@+node:ekr.20061031131434.1: *11* << imports >> (leoKeys)
import leo.core.leoGlobals as g
import leo.commands.gotoCommands as gotoCommands
import leo.external.codewise as codewise
import inspect
import os
import re
import string
import sys
import time
assert time
#@+node:ekr.20200725105324.27: *10* << Key bindings, an overview >>
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -42,9 +42,7 @@
    bindings are as expeced.
 
 B. If k.getPaneBinding finds a command associated with the incoming
-   keystroke, k.masterKeyHandler calls k.masterCommand to execute the
-   command. k.masterCommand handles many complex. See the source code for
-   details.
+   keystroke, k.masterKeyHandler executes the command.
 
 C. If k.getPaneBinding fails to bind the incoming keystroke to a command,
    k.masterKeyHandler calls k.handleUnboundKeys to handle the keystroke.
@language python
#@+node:ekr.20200725105324.28: *11* Old:<< Key bindings, an overview >>
@language rest
@
The big pictures of key bindings:

1. Code in leoKeys.py and in leoConfig.py converts user key settings to
   various Python **binding dictionaries** defined in leoKeys.py.

2. An instance of LeoQtEventFilter should be attached to all visible panes
   in Leo's main window. g.app.gui.setFilter does this.

3. LeoQtEventFilter.eventFilter calls k.masterKeyhandler for every
   keystroke. eventFilter passes only just the event argument to
   k.masterKeyHandler. The event arg gives both the widget in which the
   event occurs and the keystroke.

4. k.masterKeyHandler and its helpers use the event argument and the
   binding dictionaries to execute the Leo command (if any) associated with
   the incoming keystroke.

Important details:

1. g.app.gui.setFilter allows various traces and assertions to be made
   uniformly. The obj argument to setFilter is a QWidget object; the w
   argument to setFilter can be either the same as obj, or a Leo
   wrapper class. **Important**: the types of obj and w are not
   actually all that important, as discussed next.

2. The logic in k.masterKeyHandler and its helpers is long and involved:

A. k.getPaneBinding associates a command with the incoming keystroke based
   on a) the widget's name and b) whether the widget is a text widget
   (which depends on the type of the widget).

   To do this, k.getPaneBinding uses a **binding priority table**. This
   table is defined within k.getPaneBinding itself. The table indicates
   which of several possible bindings should have priority. For instance,
   if the widget is a text widget, a user binding for a 'text' widget takes
   priority over a default key binding. Similarly, if the widget is Leo's
   tree widget, a 'tree' binding has top priority. There are many other
   details encapsulated in the table. The exactly details of the binding
   priority table are open to debate, but in practice the resulting
   bindings are as expeced.

B. If k.getPaneBinding finds a command associated with the incoming
   keystroke, k.masterKeyHandler calls k.masterCommand to execute the
   command. k.masterCommand handles many complex. See the source code for
   details.

C. If k.getPaneBinding fails to bind the incoming keystroke to a command,
   k.masterKeyHandler calls k.handleUnboundKeys to handle the keystroke.
   Depending on the widget, and settings, and the keystroke,
   k.handleUnboundKeys may do nothing, or it may call k.masterCommand to
   insert a plain key into the widget.
#@+node:ekr.20130920121326.11281: *11* << Key bindings, an overview >>
@language rest
@
The big pictures of key bindings:

1. Code in leoKeys.py and in leoConfig.py converts user key settings to
   various Python **binding dictionaries** defined in leoKeys.py.

2. An instance of LeoQtEventFilter should be attached to all visible panes
   in Leo's main window. g.app.gui.setFilter does this.

3. LeoQtEventFilter.eventFilter calls k.masterKeyhandler for every
   keystroke. eventFilter passes only just the event argument to
   k.masterKeyHandler. The event arg gives both the widget in which the
   event occurs and the keystroke.

4. k.masterKeyHandler and its helpers use the event argument and the
   binding dictionaries to execute the Leo command (if any) associated with
   the incoming keystroke.

Important details:

1. g.app.gui.setFilter allows various traces and assertions to be made
   uniformly. The obj argument to setFilter is a QWidget object; the w
   argument to setFilter can be either the same as obj, or a Leo
   wrapper class. **Important**: the types of obj and w are not
   actually all that important, as discussed next.

2. The logic in k.masterKeyHandler and its helpers is long and involved:

A. k.getPaneBinding associates a command with the incoming keystroke based
   on a) the widget's name and b) whether the widget is a text widget
   (which depends on the type of the widget).

   To do this, k.getPaneBinding uses a **binding priority table**. This
   table is defined within k.getPaneBinding itself. The table indicates
   which of several possible bindings should have priority. For instance,
   if the widget is a text widget, a user binding for a 'text' widget takes
   priority over a default key binding. Similarly, if the widget is Leo's
   tree widget, a 'tree' binding has top priority. There are many other
   details encapsulated in the table. The exactly details of the binding
   priority table are open to debate, but in practice the resulting
   bindings are as expeced.

B. If k.getPaneBinding finds a command associated with the incoming
   keystroke, k.masterKeyHandler executes the command.

C. If k.getPaneBinding fails to bind the incoming keystroke to a command,
   k.masterKeyHandler calls k.handleUnboundKeys to handle the keystroke.
   Depending on the widget, and settings, and the keystroke,
   k.handleUnboundKeys may do nothing, or it may call k.masterCommand to
   insert a plain key into the widget.
#@+node:ekr.20200725105324.29: *10* ac.autoComplete
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -2,20 +2,21 @@
 def autoComplete(self, event=None, force=False):
     """An event handler for autocompletion."""
     c, k = self.c, self.k
-    state = k.unboundKeyAction
     # pylint: disable=consider-using-ternary
     w = event and event.w or c.get_focus()
     self.force = force
-    if state not in ('insert', 'overwrite'):
+    if k.unboundKeyAction not in ('insert', 'overwrite'):
         return
-    # First, handle the invocation character as usual.
     if not force:
-        # Ctrl-period does *not* insert a period.
-        k.masterCommand(event=event)
+        # Ctrl-period does *not* insert a period,
+        # but plain periods *must* be inserted!
+        c.insertCharFromEvent(event)
+    if c.exists:
+        c.frame.updateStatusLine()
     # Allow autocompletion only in the body pane.
     if not c.widget_name(w).lower().startswith('body'):
         return
     self.language = g.scanForAtLanguage(c, c.p)
-    if w and (k.enable_autocompleter or force):  # self.language == 'python':
+    if w and (k.enable_autocompleter or force):
         self.w = w
         self.start(event)
@language python
#@+node:ekr.20200725105324.30: *11* Old:ac.autoComplete
@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    state = k.unboundKeyAction
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if state not in ('insert', 'overwrite'):
        return
    # First, handle the invocation character as usual.
    if not force:
        # Ctrl-period does *not* insert a period.
        k.masterCommand(event=event)
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):  # self.language == 'python':
        self.w = w
        self.start(event)
#@+node:ekr.20061031131434.9: *11* ac.autoComplete
@cmd('auto-complete')
def autoComplete(self, event=None, force=False):
    """An event handler for autocompletion."""
    c, k = self.c, self.k
    # pylint: disable=consider-using-ternary
    w = event and event.w or c.get_focus()
    self.force = force
    if k.unboundKeyAction not in ('insert', 'overwrite'):
        return
    if not force:
        # Ctrl-period does *not* insert a period,
        # but plain periods *must* be inserted!
        c.insertCharFromEvent(event)
    if c.exists:
        c.frame.updateStatusLine()
    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        return
    self.language = g.scanForAtLanguage(c, c.p)
    if w and (k.enable_autocompleter or force):
        self.w = w
        self.start(event)
#@+node:ekr.20200725105324.31: *10* ac.showCalltips
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,14 +1,14 @@
 @cmd('show-calltips')
 def showCalltips(self, event=None, force=False):
     """Show the calltips at the cursor."""
-    c = self.c; k = c.k
+    c, k = self.c, self.c.k
     w = event and event.w
-    if not w: return
+    if not w:
+        return
     is_headline = c.widget_name(w).startswith('head')
     # Insert the calltip if possible, but not in headlines.
     if (k.enable_calltips or force) and not is_headline:
         self.w = w
         self.calltip()
     else:
-        # Just insert the invocation character as usual.
-        k.masterCommand(event=event)
+        c.insertCharFromEvent(event)
@language python
#@+node:ekr.20200725105324.32: *11* Old:ac.showCalltips
@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c = self.c; k = c.k
    w = event and event.w
    if not w: return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event=event)
#@+node:ekr.20061031131434.13: *11* ac.showCalltips
@cmd('show-calltips')
def showCalltips(self, event=None, force=False):
    """Show the calltips at the cursor."""
    c, k = self.c, self.c.k
    w = event and event.w
    if not w:
        return
    is_headline = c.widget_name(w).startswith('head')
    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        c.insertCharFromEvent(event)
#@+node:ekr.20200725105324.33: *10* ac.append/begin/popTabName
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -12,6 +12,7 @@
     i = s.rfind('.', 0, -1)
     if i > -1:
         self.setTabName(s[0:i])
+
 # Underscores are not valid in Pmw tab names!
 
 def setTabName(self, s):
@language python
#@+node:ekr.20200725105324.34: *11* Old:ac.append/begin/popTabName
def appendTabName(self, word):
    self.setTabName(self.tabName + '.' + word)

def beginTabName(self, word):
    self.setTabName('AutoComplete ' + word)

def clearTabName(self):
    self.setTabName('AutoComplete ')

def popTabName(self):
    s = self.tabName
    i = s.rfind('.', 0, -1)
    if i > -1:
        self.setTabName(s[0:i])
# Underscores are not valid in Pmw tab names!

def setTabName(self, s):
    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_', '') or ''
    c.frame.log.clearTab(self.tabName)
#@+node:ekr.20061031131434.18: *11* ac.append/begin/popTabName
def appendTabName(self, word):
    self.setTabName(self.tabName + '.' + word)

def beginTabName(self, word):
    self.setTabName('AutoComplete ' + word)

def clearTabName(self):
    self.setTabName('AutoComplete ')

def popTabName(self):
    s = self.tabName
    i = s.rfind('.', 0, -1)
    if i > -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!

def setTabName(self, s):
    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_', '') or ''
    c.frame.log.clearTab(self.tabName)
#@+node:ekr.20200725105324.35: *10* ac.insert_general_char
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -14,10 +14,10 @@
             extend = common_prefix[len(prefix) :]
             ins = w.getInsertPoint()
             w.insert(ins, extend)
+        return
+    if ch == '(' and k.enable_calltips:
+        # This calls self.exit if the '(' is valid.
+        self.calltip()
     else:
-        if ch == '(' and k.enable_calltips:
-            # This calls self.exit if the '(' is valid.
-            self.calltip()
-        else:
-            self.insert_string(ch)
-            self.exit()
+        self.insert_string(ch)
+        self.exit()
@language python
#@+node:ekr.20200725105324.36: *11* Old:ac.insert_general_char
def insert_general_char(self, ch):

    k, w = self.k, self.w
    if g.isWordChar(ch):
        self.insert_string(ch)
        common_prefix, prefix, aList = self.compute_completion_list()
        if not aList:
            if self.forbid_invalid:
                # Delete the character we just inserted.
                self.do_backspace()
        # @bool auto_tab_complete is deprecated.
        # Auto-completion makes no sense if it is False.
        elif self.auto_tab and len(common_prefix) > len(prefix):
            extend = common_prefix[len(prefix) :]
            ins = w.getInsertPoint()
            w.insert(ins, extend)
    else:
        if ch == '(' and k.enable_calltips:
            # This calls self.exit if the '(' is valid.
            self.calltip()
        else:
            self.insert_string(ch)
            self.exit()
#@+node:ekr.20061031131434.39: *11* ac.insert_general_char
def insert_general_char(self, ch):

    k, w = self.k, self.w
    if g.isWordChar(ch):
        self.insert_string(ch)
        common_prefix, prefix, aList = self.compute_completion_list()
        if not aList:
            if self.forbid_invalid:
                # Delete the character we just inserted.
                self.do_backspace()
        # @bool auto_tab_complete is deprecated.
        # Auto-completion makes no sense if it is False.
        elif self.auto_tab and len(common_prefix) > len(prefix):
            extend = common_prefix[len(prefix) :]
            ins = w.getInsertPoint()
            w.insert(ins, extend)
        return
    if ch == '(' and k.enable_calltips:
        # This calls self.exit if the '(' is valid.
        self.calltip()
    else:
        self.insert_string(ch)
        self.exit()
#@+node:ekr.20200725105324.37: *10* ga.compute_tab_list
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,6 +1,6 @@
 # Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())
 
-def compute_tab_list(self, tabList, backspace=False, allow_empty_completion=False):
+def compute_tab_list(self, tabList):
     """Compute and show the available completions."""
     # Support vim-mode commands.
     command = self.get_label()
@language python
#@+node:ekr.20200725105324.38: *11* Old:ga.compute_tab_list
# Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())

def compute_tab_list(self, tabList, backspace=False, allow_empty_completion=False):
    """Compute and show the available completions."""
    # Support vim-mode commands.
    command = self.get_label()
    if self.is_command(command):
        tabList, common_prefix = g.itemsMatchingPrefixInList(command, tabList)
        return common_prefix, tabList
    #
    # For now, disallow further completions if something follows the command.
    command = self.get_command(command)
    return command, [command]
#@+node:ekr.20140817110228.18321: *11* ga.compute_tab_list
# Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())

def compute_tab_list(self, tabList):
    """Compute and show the available completions."""
    # Support vim-mode commands.
    command = self.get_label()
    if self.is_command(command):
        tabList, common_prefix = g.itemsMatchingPrefixInList(command, tabList)
        return common_prefix, tabList
    #
    # For now, disallow further completions if something follows the command.
    command = self.get_command(command)
    return command, [command]
#@+node:ekr.20200725105324.39: *10* ga.do_state_zero
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -13,7 +13,6 @@
     self.tabList = tabList[:] if tabList else []
     #
     # Set the k globals...
-    k.argSelectedText = c.frame.body.wrapper.getSelectedText()
     k.functionTail = None
     k.oneCharacterArg = oneCharacter
     #
@language python
#@+node:ekr.20200725105324.40: *11* Old:ga.do_state_zero
def do_state_zero(self, completion, event, handler, oneCharacter,
    returnKind, returnState, tabList, useMinibuffer
):
    """Do state 0 processing."""
    c, k = self.c, self.k
    #
    # Set the ga globals...
    k.getArgEscapeFlag = False
    self.after_get_arg_state = returnKind, returnState, handler
    self.arg_completion = completion
    self.cycling_prefix = None
    self.handler = handler
    self.tabList = tabList[:] if tabList else []
    #
    # Set the k globals...
    k.argSelectedText = c.frame.body.wrapper.getSelectedText()
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    #
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg', 1, k.getArg)
    # pylint: disable=consider-using-ternary
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
#@+node:ekr.20140817110228.18317: *11* ga.do_state_zero
def do_state_zero(self, completion, event, handler, oneCharacter,
    returnKind, returnState, tabList, useMinibuffer
):
    """Do state 0 processing."""
    c, k = self.c, self.k
    #
    # Set the ga globals...
    k.getArgEscapeFlag = False
    self.after_get_arg_state = returnKind, returnState, handler
    self.arg_completion = completion
    self.cycling_prefix = None
    self.handler = handler
    self.tabList = tabList[:] if tabList else []
    #
    # Set the k globals...
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    #
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg', 1, k.getArg)
    # pylint: disable=consider-using-ternary
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
#@+node:ekr.20200725105324.41: *10* k.defineExternallyVisibleIvars
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,22 +1,13 @@
 def defineExternallyVisibleIvars(self):
-    self.abbrevOn = False
-        # True: abbreviations are on.
-    self.arg = ''
-        # The value returned by k.getArg.
-    self.argSelectedText = ''  # The selected text in state 0.
-    self.commandName = None  # The name of the command being executed.
-    self.funcReturn = None  # For k.simulateCommand
-    self.functionTail = None  # For commands that take minibuffer arguments.
-    # These are true globals
+
+    self.abbrevOn = False  # True: abbreviations are on.
+    self.arg = ''  # The value returned by k.getArg.
+    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
     self.getArgEscapes = []
-    self.getArgEscapeFlag = False  # A signal that the user escaped getArg in an unusual way.
-    self.givenArgs = []
-         # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
-    self.inputModeBindings = {}
     self.inputModeName = ''  # The name of the input mode, or None.
     self.modePrompt = ''  # The mode promopt.
-    self.negativeArg = False
-    self.newMinibufferWidget = None  # Usually the minibuffer restores focus.  This overrides this default.
-    # self.regx = g.bunch(iter=None,key=None)
-    self.repeatCount = None
     self.state = g.bunch(kind=None, n=None, handler=None)
+    
+    # Remove ???
+    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
+    self.functionTail = None  # For commands that take minibuffer arguments.
@language python
#@+node:ekr.20200725105324.42: *11* Old:k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):
    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = ''  # The selected text in state 0.
    self.commandName = None  # The name of the command being executed.
    self.funcReturn = None  # For k.simulateCommand
    self.functionTail = None  # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False  # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = []
         # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None  # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None, n=None, handler=None)
#@+node:ekr.20061031131434.78: *11* k.defineExternallyVisibleIvars
def defineExternallyVisibleIvars(self):

    self.abbrevOn = False  # True: abbreviations are on.
    self.arg = ''  # The value returned by k.getArg.
    self.getArgEscapeFlag = False  # True: the user escaped getArg in an unusual way.
    self.getArgEscapes = []
    self.inputModeName = ''  # The name of the input mode, or None.
    self.modePrompt = ''  # The mode promopt.
    self.state = g.bunch(kind=None, n=None, handler=None)
    
    # Remove ???
    self.givenArgs = []  # Args specified after the command name in k.simulateCommand.
    self.functionTail = None  # For commands that take minibuffer arguments.
#@+node:ekr.20200725105324.43: *10* k.makeMasterGuiBinding
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,4 +1,4 @@
-def makeMasterGuiBinding(self, stroke, w=None, trace=False):
+def makeMasterGuiBinding(self, stroke, w=None):
     """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
     k = self; c = k.c; f = c.frame
     if w:
@language python
#@+node:ekr.20200725105324.44: *11* Old:k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None, trace=False):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
#@+node:ekr.20061031131434.103: *11* k.makeMasterGuiBinding
def makeMasterGuiBinding(self, stroke, w=None):
    """Make a master gui binding for stroke in pane w, or in all the standard widgets."""
    k = self; c = k.c; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = (
            f.tree
            and hasattr(f.tree, 'bindingWidget')
            and f.tree.bindingWidget
            or None)
        wrapper = f.body and hasattr(f.body, 'wrapper') and f.body.wrapper or None
        canvas = f.tree and hasattr(f.tree, 'canvas') and f.tree.canvas or None
        widgets = (c.miniBufferWidget, wrapper, canvas, bindingWidget)
    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke, [])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict[stroke] = aList
#@+node:ekr.20200725105324.45: *10* k.addToCommandHistory
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -6,4 +6,3 @@
         h.remove(commandName)
     h.append(commandName)
     k.commandIndex = None
-
@language python
#@+node:ekr.20200725105324.46: *11* Old:k.addToCommandHistory
def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None

#@+node:ekr.20150402111413.1: *11* k.addToCommandHistory
def addToCommandHistory(self, commandName):
    """Add a name to the command history."""
    k = self
    h = k.commandHistory
    if commandName in h:
        h.remove(commandName)
    h.append(commandName)
    k.commandIndex = None
#@+node:ekr.20200725105324.47: *10* k.callAltXFunction
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -12,7 +12,6 @@
 
     else:
         func = c.commandsDict.get(commandName)
-    k.newMinibufferWidget = None
     if func:
         # These must be done *after* getting the command.
         k.clearState()
@@ -22,24 +21,17 @@
         w = event and event.widget
         if hasattr(w, 'permanent') and not w.permanent:
             # In a headline that is being edited.
-            # g.es('Can not execute commands from headlines')
             c.endEditing()
             c.bodyWantsFocusNow()
             # Change the event widget so we don't refer to the to-be-deleted headline widget.
             event.w = event.widget = c.frame.body.wrapper.widget
-            c.executeAnyCommand(func, event)
         else:
-            c.widgetWantsFocusNow(event and event.widget)
-                # Important, so cut-text works, e.g.
-            c.executeAnyCommand(func, event)
-        k.endCommand(commandName)
+            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
+        try:
+            func(event)
+        except Exception:
+            g.es_exception()
         return True
-    #
     # Show possible completions if the command does not exist.
-    if 1:  # Useful.
-        k.doTabCompletion(list(c.commandsDict.keys()))
-    else:  # Annoying.
-        k.keyboardQuit()
-        k.setStatusLabel(f"Command does not exist: {commandName}")
-        c.bodyWantsFocus()
+    k.doTabCompletion(list(c.commandsDict.keys()))
     return False
@language python
#@+node:ekr.20200725105324.48: *11* Old:k.callAltXFunction
def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            # g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            c.executeAnyCommand(func, event)
        else:
            c.widgetWantsFocusNow(event and event.widget)
                # Important, so cut-text works, e.g.
            c.executeAnyCommand(func, event)
        k.endCommand(commandName)
        return True
    #
    # Show possible completions if the command does not exist.
    if 1:  # Useful.
        k.doTabCompletion(list(c.commandsDict.keys()))
    else:  # Annoying.
        k.keyboardQuit()
        k.setStatusLabel(f"Command does not exist: {commandName}")
        c.bodyWantsFocus()
    return False
#@+node:ekr.20061031131434.112: *11* k.callAltXFunction
def callAltXFunction(self, event):
    """Call the function whose name is in the minibuffer."""
    c, k = self.c, self
    k.mb_tabList = []
    commandName, tail = k.getMinibufferCommandName()
    k.functionTail = tail
    if commandName and commandName.isdigit():
        # The line number Easter Egg.

        def func(event=None):
            c.gotoCommands.find_file_line(n=int(commandName))

    else:
        func = c.commandsDict.get(commandName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0, commandName)
        w = event and event.widget
        if hasattr(w, 'permanent') and not w.permanent:
            # In a headline that is being edited.
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
        else:
            c.widgetWantsFocusNow(event and event.widget)  # So cut-text works, e.g.
        try:
            func(event)
        except Exception:
            g.es_exception()
        return True
    # Show possible completions if the command does not exist.
    k.doTabCompletion(list(c.commandsDict.keys()))
    return False
#@+node:ekr.20200725105324.49: *10* k.repeatComplexCommand & helper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -6,4 +6,4 @@
         k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
         k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
     else:
-        g.warning('no previous command')
+        g.warning('no previous minibuffer command')
@language python
#@+node:ekr.20200725105324.50: *11* Old:k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous command')
#@+node:ekr.20061031131434.122: *11* k.repeatComplexCommand & helper
@cmd('repeat-complex-command')
def repeatComplexCommand(self, event):
    """Repeat the previously executed minibuffer command."""
    k = self
    if k.mb_history:
        k.setState('last-full-command', 1, handler=k.repeatComplexCommandHelper)
        k.setLabelBlue(f"Redo: {str(k.mb_history[0])}")
    else:
        g.warning('no previous minibuffer command')
#@+node:ekr.20131017100903.16689: *12* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
#@+node:ekr.20200725105324.51: *10* repeatComplexCommandHelper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -5,6 +5,10 @@
         last = k.mb_history[0]
         k.resetLabel()
         k.clearState()  # Bug fix.
-        c.commandsDict[last](event)
+        if last.isdigit():
+            # Special case: for the number Easter Egg.
+            c.goToLineNumber(int(last))
+        else:
+            c.commandsDict[last](event)
     else:
         k.keyboardQuit()
@language python
#@+node:ekr.20200725105324.52: *11* Old:repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        c.commandsDict[last](event)
    else:
        k.keyboardQuit()
#@+node:ekr.20131017100903.16689: *11* repeatComplexCommandHelper
def repeatComplexCommandHelper(self, event):
    k = self; c = k.c
    char = event.char if event else ''
    if char in ('\n', 'Return') and k.mb_history:
        last = k.mb_history[0]
        k.resetLabel()
        k.clearState()  # Bug fix.
        if last.isdigit():
            # Special case: for the number Easter Egg.
            c.goToLineNumber(int(last))
        else:
            c.commandsDict[last](event)
    else:
        k.keyboardQuit()
#@+node:ekr.20200725105324.53: *10* k.keyboardQuit
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,15 +1,9 @@
 @cmd('keyboard-quit')
-def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
-    """
-    This method clears the state and the minibuffer label.
-
-    k.endCommand handles all other end-of-command chores.
-    """
+def keyboardQuit(self, event=None, setFocus=True):
+    """Clears the state and the minibuffer label."""
     k = self; c = k.c
     if g.app.quitting:
         return
-    # 2011/05/30: We may be called from Qt event handlers.
-    # Make sure to end editing!
     c.endEditing()
     # Completely clear the mode.
     if setFocus:
@language python
#@+node:ekr.20200725105324.54: *11* Old:k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True, mouseClick=False):
    """
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    """
    k = self; c = k.c
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
#@+node:ekr.20061031131434.130: *11* k.keyboardQuit
@cmd('keyboard-quit')
def keyboardQuit(self, event=None, setFocus=True):
    """Clears the state and the minibuffer label."""
    k = self; c = k.c
    if g.app.quitting:
        return
    c.endEditing()
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
    k.resetCommandHistory()
#@+node:ekr.20200725105324.55: *10* k.simulateCommand
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,25 +1,7 @@
 def simulateCommand(self, commandName, event=None):
     """Execute a Leo command by name."""
-    c, k = self.c, self
-    func = self.commandExists(commandName)
-    if func:
-        # Support @g.commander_command
-        c_func = getattr(c, func.__name__, None)
-        if c_func:
-            return c_func(event=event)
-        if event:
-            pass
-        elif commandName.startswith('specialCallback'):
-            event = None  # A legacy function.
-        else:  # Create a dummy event as a signal.
-            event = g.app.gui.create_key_event(c)
-        k.masterCommand(event=event, func=func)
-        if c.exists:
-            return k.funcReturn
-        return None
-    if g.app.unitTesting:
-        raise AttributeError(f"no such command: {commandName}")
-    if g.app.inBridge:
-        raise AttributeError(f"no such command: {commandName}")
-    g.error(f"simulateCommand: no command for {commandName}")
-    return None
+    c = self.c
+    if not event:
+        # Create a default key event.
+        event = g.app.gui.create_key_event(c)
+    c.doCommandByName(commandName, event)
@language python
#@+node:ekr.20200725105324.56: *11* Old:k.simulateCommand & k.commandExists
def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c, k = self.c, self
    func = self.commandExists(commandName)
    if func:
        # Support @g.commander_command
        c_func = getattr(c, func.__name__, None)
        if c_func:
            return c_func(event=event)
        if event:
            pass
        elif commandName.startswith('specialCallback'):
            event = None  # A legacy function.
        else:  # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c)
        k.masterCommand(event=event, func=func)
        if c.exists:
            return k.funcReturn
        return None
    if g.app.unitTesting:
        raise AttributeError(f"no such command: {commandName}")
    if g.app.inBridge:
        raise AttributeError(f"no such command: {commandName}")
    g.error(f"simulateCommand: no command for {commandName}")
    return None
#@+node:ekr.20061031131434.127: *11* k.simulateCommand
def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
#@+node:ekr.20200725105324.57: *10* k.masterKeyHandler & helpers
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,6 +1,6 @@
 def masterKeyHandler(self, event):
     """The master key handler for almost all key bindings."""
-    k = self
+    c, k = self.c, self
     # Setup...
     if 'keys' in g.app.debug:
         g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
@@ -10,6 +10,8 @@
     # Order is very important here...
     if k.isSpecialKey(event):
         return
+    # Add *all* characters to the lossage.
+    k.setLossage(event.char, event.stroke)
     if k.doKeyboardQuit(event):
         return
     if k.doDemo(event):
@@ -18,7 +20,9 @@
         return
     if k.doVim(event):
         return
-    if k.doUnboundPlainKey(event):
+    if k.doBinding(event):
         return
-    k.doBinding(event)
-        # Calls handleUnboundKeys if no binding.
+    # Handle abbreviations.
+    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
+        return
+    c.insertCharFromEvent(event)
@language python
#@+node:ekr.20200725105324.58: *11* Old:k.masterKeyHandler & helpers
def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    k = self
    # Setup...
    if 'keys' in g.app.debug:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doUnboundPlainKey(event):
        return
    k.doBinding(event)
        # Calls handleUnboundKeys if no binding.
#@+node:ekr.20061031131434.146: *11* k.masterKeyHandler & helpers
def masterKeyHandler(self, event):
    """The master key handler for almost all key bindings."""
    c, k = self.c, self
    # Setup...
    if 'keys' in g.app.debug:
        g.trace(repr(k.state.kind), repr(event.char), repr(event.stroke))
    k.checkKeyEvent(event)
    k.setEventWidget(event)
    k.traceVars(event)
    # Order is very important here...
    if k.isSpecialKey(event):
        return
    # Add *all* characters to the lossage.
    k.setLossage(event.char, event.stroke)
    if k.doKeyboardQuit(event):
        return
    if k.doDemo(event):
        return
    if k.doMode(event):
        return
    if k.doVim(event):
        return
    if k.doBinding(event):
        return
    # Handle abbreviations.
    if k.abbrevOn and c.abbrevCommands.expandAbbrev(event, event.stroke):
        return
    c.insertCharFromEvent(event)
#@+node:ekr.20200524151214.1: *12* Setup...
#@+node:ekr.20180418040158.1: *13* k.checkKeyEvent
def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
#@+node:ekr.20180418034305.1: *13* k.setEventWidget
def setEventWidget(self, event):
    """
    A hack: redirect the event to the text part of the log.
    """
    c = self.c
    w = event.widget
    w_name = c.widget_name(w)
    if w_name.startswith('log'):
        event.widget = c.frame.log.logCtrl
#@+node:ekr.20180418031417.1: *13* k.traceVars
def traceVars(self, event):

    trace = False and not g.unitTesting
    traceGC = False
    verbose = False
    k = self
    if not trace:
        return
    if traceGC:
        g.printNewObjects('masterKey 1')
    if verbose:
        char = event.char
        state = k.state.kind
        stroke = event.stroke
        g.trace(
            f"stroke: {stroke!r}, "
            f"char: {char!r}, "
            f"state: {state}, "
            f"state2: {k.unboundKeyAction}")
#@+node:ekr.20180418031118.1: *12* 1. k.isSpecialKey
def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) > 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
#@+node:ekr.20110609161752.16459: *12* 2. k.setLossage
def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
#@+node:ekr.20180418024449.1: *12* 3. k.doKeyboardQuit
def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
#@+node:ekr.20180418023827.1: *12* 4. k.doDemo
def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
#@+node:ekr.20091230094319.6244: *12* 5. k.doMode & helpers
def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        return val != 'do-standard-keys'
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    return True
#@+node:ekr.20061031131434.108: *13* k.callStateFunction
def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) < 32 or ord(ch) > 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
#@+node:ekr.20061031131434.152: *13* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
#@+node:ekr.20180418114300.1: *14* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:vitalije.20170708161511.1: *13* k.handleInputShortcut
def handleInputShortcut(self, event, stroke):
    c, k, p = self.c, self, self.c.p
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = c.undoer.beforeChangeNodeContents(p)
        w.setSelectionAreas(before, sel, after)
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        w.onBodyChanged('change shortcut')
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = c.undoer.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
#@+node:vitalije.20170709151653.1: *14* k.isInShortcutBodyLine
_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
#@+node:vitalije.20170709151658.1: *14* k.isEditShortcutSensible
def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
#@+node:vitalije.20170709202924.1: *14* k.editShortcut_do_bind_helper
def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
#@+node:ekr.20180418025241.1: *12* 6. k.doVim
def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    c = self.c
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        return ok
    return False
#@+node:ekr.20180418033838.1: *12* 7. k.doBinding & helpers
def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    c, k = self.c, self
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event.stroke, event.w)
    #
    # #327: ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
#@+node:ekr.20091230094319.6240: *13* k.getPaneBinding & helper
def getPaneBinding(self, stroke, w):

    k = self
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        val = k.getBindingHelper(key, name, stroke, w)
        if val:
            return val
    return None
#@+node:ekr.20180418105228.1: *14* getPaneBindingHelper
def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
#@+node:ekr.20160409035115.1: *13* k.searchTree
def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
#@+node:ekr.20200725105324.59: *10* k.checkKeyEvent
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -13,4 +13,3 @@
     if event:
         assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
             # A continuous unit test, better than "@test k.isPlainKey".
-
@language python
#@+node:ekr.20200725105324.60: *11* Old:k.checkKeyEvent
def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".

#@+node:ekr.20180418040158.1: *11* k.checkKeyEvent
def checkKeyEvent(self, event):
    """Perform sanity checks on the incoming event."""
    # These assert's should be safe, because eventFilter
    # calls k.masterKeyHandler inside a try/except block.
    c = self.c
    assert event is not None
    c.check_event(event)
    assert hasattr(event, 'char')
    assert hasattr(event, 'stroke')
    if not hasattr(event, 'widget'):
        event.widget = None
    assert g.isStrokeOrNone(event.stroke)
    if event:
        assert event.stroke.s not in g.app.gui.ignoreChars, repr(event.stroke.s)
            # A continuous unit test, better than "@test k.isPlainKey".
#@+node:ekr.20200725105324.61: *10* 7. k.doBinding & helpers
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,39 +1,22 @@
 def doBinding(self, event):
     """
-    The last phase of k.masertKeyHandler.
-    Execute the command associated with stroke's binding.
-    Call k.handleUnboundKeys for killed or non-existent bindings.
+    Attempt to find a binding for the event's stroke.
+    If found, execute the command and return True
+    Otherwise, return False
     """
     c, k = self.c, self
-    char, stroke, w = event.char, event.stroke, event.widget
     #
     # Use getPaneBindings for *all* keys.
+    bi = k.getPaneBinding(event.stroke, event.w)
     #
-    bi = k.getPaneBinding(stroke, w)
+    # #327: ignore killed bindings.
+    if bi and bi.commandName in k.killedBindings:
+        return False  
     #
-    # Call k.handleUnboudKeys for all killed bindings.
+    # Execute the command if the binding exists.
+    if bi:
+        c.doCommandByName(bi.commandName, event)
+        return True
     #
-    if bi and bi.commandName in k.killedBindings:
-        #327: ignore killed bindings.
-        k.handleUnboundKeys(event)
-        return
-    #
-    # Call k.masterCommandHandler if the binding exists.
-    #
-    if bi:
-        k.masterCommand(
-            event=event,
-            commandName=bi.commandName,
-            func=bi.func,
-            stroke=bi.stroke)
-        return
-    #
-    # Handle unbound keys in the tree (not headlines).
-    #
-    if c.widget_name(w).startswith('canvas'):
-        k.searchTree(char)
-        return
-    #
-    # No binding exists. Call k.handleUnboundKey.
-    #
-    k.handleUnboundKeys(event)
+    # No binding exists.
+    return False
@language python
#@+node:ekr.20200725105324.62: *11* Old:k.doBinding
def doBinding(self, event):
    """
    The last phase of k.masertKeyHandler.
    Execute the command associated with stroke's binding.
    Call k.handleUnboundKeys for killed or non-existent bindings.
    """
    c, k = self.c, self
    char, stroke, w = event.char, event.stroke, event.widget
    #
    # Use getPaneBindings for *all* keys.
    #
    bi = k.getPaneBinding(stroke, w)
    #
    # Call k.handleUnboudKeys for all killed bindings.
    #
    if bi and bi.commandName in k.killedBindings:
        #327: ignore killed bindings.
        k.handleUnboundKeys(event)
        return
    #
    # Call k.masterCommandHandler if the binding exists.
    #
    if bi:
        k.masterCommand(
            event=event,
            commandName=bi.commandName,
            func=bi.func,
            stroke=bi.stroke)
        return
    #
    # Handle unbound keys in the tree (not headlines).
    #
    if c.widget_name(w).startswith('canvas'):
        k.searchTree(char)
        return
    #
    # No binding exists. Call k.handleUnboundKey.
    #
    k.handleUnboundKeys(event)
#@+node:ekr.20180418033838.1: *11* 7. k.doBinding & helpers
def doBinding(self, event):
    """
    Attempt to find a binding for the event's stroke.
    If found, execute the command and return True
    Otherwise, return False
    """
    c, k = self.c, self
    #
    # Use getPaneBindings for *all* keys.
    bi = k.getPaneBinding(event.stroke, event.w)
    #
    # #327: ignore killed bindings.
    if bi and bi.commandName in k.killedBindings:
        return False  
    #
    # Execute the command if the binding exists.
    if bi:
        c.doCommandByName(bi.commandName, event)
        return True
    #
    # No binding exists.
    return False
#@+node:ekr.20091230094319.6240: *12* k.getPaneBinding & helper
def getPaneBinding(self, stroke, w):

    k = self
    if not g.assert_is(stroke, g.KeyStroke):
        return None
    for key, name in (
        # Order here is similar to bindtags order.
        ('command', None),
        ('insert', None),
        ('overwrite', None),
        ('button', None),
        ('body', 'body'),
        ('text', 'head'),  # Important: text bindings in head before tree bindings.
        ('tree', 'head'),
        ('tree', 'canvas'),
        ('log', 'log'),
        ('text', 'log'),
        ('text', None),
        ('all', None),
    ):
        val = k.getBindingHelper(key, name, stroke, w)
        if val:
            return val
    return None
#@+node:ekr.20180418105228.1: *13* getPaneBindingHelper
def getBindingHelper(self, key, name, stroke, w):
    """Find a binding for the widget with the given name."""
    c, k = self.c, self
    #
    # Return if the pane's name doesn't match the event's widget.
    state = k.unboundKeyAction
    w_name = c.widget_name(w)
    pane_matches = (
        name and w_name.startswith(name) or
        key in ('command', 'insert', 'overwrite') and state == key or
        key in ('text', 'all') and g.isTextWrapper(w) or
        key in ('button', 'all')
    )
    if not pane_matches:
        return None
    #
    # Return if there is no binding at all.
    d = k.masterBindingsDict.get(key, {})
    if not d:
        return None
    bi = d.get(stroke)
    if not bi:
        return None
    #
    # Ignore previous/next-line commands while editing headlines.
    if (
        key == 'text' and
        name == 'head' and
        bi.commandName in ('previous-line', 'next-line')
    ):
        return None
    #
    # The binding has been found.
    return bi
#@+node:ekr.20160409035115.1: *12* k.searchTree
def searchTree(self, char):
    """Search all visible nodes for a headline starting with stroke."""
    if not char: return
    c = self.c
    if not c.config.getBool('plain-key-outline-search'):
        return

    def match(p):
        """Return True if p contains char."""
        s = p.h.lower() if char.islower() else p.h
        return s.find(char) > -1

    # Start at c.p, then retry everywhere.

    for p in (c.p, c.rootPosition()):
        p = p.copy()
        if p == c.p and match(p):
            p.moveToVisNext(c)
        while p:
            if match(p):
                c.selectPosition(p)
                c.redraw()
                return
            p.moveToVisNext(c)

    # Too confusing for the user.
    # re_pat = re.compile(r'^@(\w)+[ \t](.+)')

    # def match(p, pattern):
        # s = p.h.lower()
        # if pattern:
            # m = pattern.search(s)
            # found = (s.startswith(char) or
                # m and m.group(2).lower().startswith(char))
        # else:
            # found = s.find(char) > -1
        # if found:
            # c.selectPosition(p)
            # c.redraw()
        # return found
#@+node:ekr.20200725105324.63: *10* 4. k.doDemo
Only headline has changed
#@+node:ekr.20200725105324.64: *11* Old:k.doDemo
def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
#@+node:ekr.20180418023827.1: *11* 4. k.doDemo
def doDemo(self, event):
    """
    Support the demo.py plugin.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    stroke = event.stroke
    demo = getattr(g.app, 'demo', None)
    if not demo:
        return False
    #
    # Shortcut everything so that demo-next or demo-prev won't alter of our ivars.
    if k.demoNextKey and stroke == k.demoNextKey:
        if demo.trace:
            g.trace('demo-next', stroke)
        demo.next_command()
        return True
    if k.demoPrevKey and stroke == k.demoPrevKey:
        if demo.trace:
            g.trace('demo-prev', stroke)
        demo.prev_command()
        return True
    return False
#@+node:ekr.20200725105324.65: *10* k.callStateFunction
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -4,7 +4,6 @@
     ch = event.char
     #
     # Defensive programming
-    #
     if not k.state.kind:
         return None
     if not k.state.handler:
@@ -12,14 +11,12 @@
         return None
     #
     # Handle auto-completion before checking for unbound keys.
-    #
     if k.state.kind == 'auto-complete':
         # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
         val = k.state.handler(event)
         return val
     #
     # Ignore unbound non-ascii keys.
-    #
     if (
         k.ignore_unbound_non_ascii_keys and
         len(ch) == 1 and
@@ -29,8 +26,5 @@
         return None
     #
     # Call the state handler.
-    #
     val = k.state.handler(event)
-    if val != 'continue':
-        k.endCommand(k.commandName)
     return val
@language python
#@+node:ekr.20200725105324.66: *11* Old:k.callStateFunction
def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    #
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    #
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    #
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) < 32 or ord(ch) > 128)
    ):
        return None
    #
    # Call the state handler.
    #
    val = k.state.handler(event)
    if val != 'continue':
        k.endCommand(k.commandName)
    return val
#@+node:ekr.20061031131434.108: *11* k.callStateFunction
def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) < 32 or ord(ch) > 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
#@+node:ekr.20200725105324.67: *10* 6. k.doVim
Only headline has changed
#@+node:ekr.20200725105324.68: *11* Old:k.doVim
def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    c = self.c
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        return ok
    return False
#@+node:ekr.20180418025241.1: *11* 6. k.doVim
def doVim(self, event):
    """
    Handle vim mode.
    Return True if k.masterKeyHandler should return.
    """
    c = self.c
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        return ok
    return False
#@+node:ekr.20200725105324.69: *10* 5. k.doMode & helpers
Only headline has changed
#@+node:ekr.20200725105324.70: *11* Old:k.doMode
def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        return val != 'do-standard-keys'
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    return True
#@+node:ekr.20091230094319.6244: *11* 5. k.doMode & helpers
def doMode(self, event):
    """
    Handle mode bindings.
    Return True if k.masterKeyHandler should return.
    """
    k = self
    state = k.state.kind
    stroke = event.stroke
    if not k.inState():
        return False
    #
    # First, honor minibuffer bindings for all except user modes.
    if state == 'input-shortcut':
        k.handleInputShortcut(event, stroke)
        return True
    if state in (
        'getArg', 'getFileName', 'full-command', 'auto-complete', 'vim-mode'
    ):
        if k.handleMiniBindings(event, state, stroke):
            return True
    #
    # Second, honor general modes.
    #
    if state == 'getArg':
        # New in Leo 5.8: Only call k.getArg for keys it can handle.
        if k.isPlainKey(stroke):
            k.getArg(event, stroke=stroke)
            return True
        if stroke.s in ('Escape', 'Tab', 'BackSpace'):
            k.getArg(event, stroke=stroke)
            return True
        return False
    if state in ('getFileName', 'get-file-name'):
        k.getFileName(event)
        return True
    if state in ('full-command', 'auto-complete'):
        val = k.callStateFunction(event)
            # Do the default state action.
            # Calls end-command.
        return val != 'do-standard-keys'
    #
    # Third, pass keys to user modes.
    #
    d = k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        bi = d.get(stroke)
        if bi:
            # Bound keys continue the mode.
            k.generalModeHandler(event,
                commandName=bi.commandName,
                func=bi.func,
                modeName=state,
                nextMode=bi.nextMode)
            return True
        # Unbound keys end mode.
        k.endMode()
        return False
    #
    # Fourth, call the state handler.
    #
    handler = k.getStateHandler()
    if handler:
        handler(event)
    return True
#@+node:ekr.20061031131434.108: *12* k.callStateFunction
def callStateFunction(self, event):
    """Call the state handler associated with this event."""
    k = self
    ch = event.char
    #
    # Defensive programming
    if not k.state.kind:
        return None
    if not k.state.handler:
        g.error('callStateFunction: no state function for', k.state.kind)
        return None
    #
    # Handle auto-completion before checking for unbound keys.
    if k.state.kind == 'auto-complete':
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        return val
    #
    # Ignore unbound non-ascii keys.
    if (
        k.ignore_unbound_non_ascii_keys and
        len(ch) == 1 and
        ch and ch not in ('\b', '\n', '\r', '\t') and
        (ord(ch) < 32 or ord(ch) > 128)
    ):
        return None
    #
    # Call the state handler.
    val = k.state.handler(event)
    return val
#@+node:ekr.20061031131434.152: *12* k.handleMiniBindings
def handleMiniBindings(self, event, state, stroke):
    """Find and execute commands bound to the event."""
    k = self
    #
    # Special case for bindings handled in k.getArg:
    if state == 'full-command' and stroke in ('Up', 'Down'):
        return False
    #
    # Ignore other special keys in the minibuffer.
    if state in ('getArg', 'full-command'):
        if stroke in (
            '\b', 'BackSpace',
            '\r', 'Linefeed',
            '\n', 'Return',
            '\t', 'Tab',
            'Escape',
        ):
            return False
        if k.isFKey(stroke):
            return False
    #
    # Ignore autocompletion state.
    if state.startswith('auto-'):
        return False
    #
    # Ignore plain key binding in the minibuffer.
    if not stroke or k.isPlainKey(stroke):
        return False
    #
    # Get the command, based on the pane.
    for pane in ('mini', 'all', 'text'):
        result = k.handleMinibufferHelper(event, pane, state, stroke)
        assert result in ('continue', 'found', 'ignore')
        if result == 'ignore':
            return False  # Let getArg handle it.
        if result == 'found':
            # Do not call k.keyboardQuit here!
            return True
    #
    # No binding exists.
    return False
#@+node:ekr.20180418114300.1: *13* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:vitalije.20170708161511.1: *12* k.handleInputShortcut
def handleInputShortcut(self, event, stroke):
    c, k, p = self.c, self, self.c.p
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m  # edit-shortcut was invoked on a malformed body line
        sel = f"{m.group(0)} {stroke.s}"
        udata = c.undoer.beforeChangeNodeContents(p)
        w.setSelectionAreas(before, sel, after)
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        w.onBodyChanged('change shortcut')
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    if p.h.startswith(('@command', '@button')):
        udata = c.undoer.beforeChangeNodeContents(p)
        cmd = p.h.split('@key', 1)[0]
        p.h = f"{cmd} @key={stroke.s}"
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    # this should never happen
    g.error('not in settings node shortcut')
#@+node:vitalije.20170709151653.1: *13* k.isInShortcutBodyLine
_cmd_handle_input_pattern = re.compile(r'[A-Za-z0-9_\-]+\s*=')

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
#@+node:vitalije.20170709151658.1: *13* k.isEditShortcutSensible
def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
#@+node:vitalije.20170709202924.1: *13* k.editShortcut_do_bind_helper
def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
#@+node:ekr.20200725105324.71: *10* k.handleMinibufferHelper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,7 +1,6 @@
 def handleMinibufferHelper(self, event, pane, state, stroke):
     """
     Execute a pane binding in the minibuffer.
-    
     Return 'continue', 'ignore', 'found'
     """
     c, k = self.c, self
@@ -12,24 +11,15 @@
     if not bi:
         return 'continue'
     assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
-    #
-    # Special case the replace-string command in the minibuffer.
-    #
+    # Ignore the replace-string command in the minibuffer.
     if bi.commandName == 'replace-string' and state == 'getArg':
         return 'ignore'
-    #
     # Execute this command.
-    #
     if bi.commandName not in k.singleLineCommandList:
         k.keyboardQuit()
     else:
-        c.minibufferWantsFocus()  # New in Leo 4.5.
-    # Pass this on for macro recording.
-    k.masterCommand(
-        commandName=bi.commandName,
-        event=event,
-        func=bi.func,
-        stroke=stroke)
+        c.minibufferWantsFocus()
+        c.doCommandByName(bi.commandName, event)
     # Careful: the command could exit.
     if c.exists and not k.silentMode:
         # Use the state *after* executing the command.
@language python
#@+node:ekr.20200725105324.72: *11* Old:k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    #
    # Special case the replace-string command in the minibuffer.
    #
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    #
    # Execute this command.
    #
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()  # New in Leo 4.5.
    # Pass this on for macro recording.
    k.masterCommand(
        commandName=bi.commandName,
        event=event,
        func=bi.func,
        stroke=stroke)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:ekr.20180418114300.1: *11* k.handleMinibufferHelper
def handleMinibufferHelper(self, event, pane, state, stroke):
    """
    Execute a pane binding in the minibuffer.
    Return 'continue', 'ignore', 'found'
    """
    c, k = self.c, self
    d = k.masterBindingsDict.get(pane)
    if not d:
        return 'continue'
    bi = d.get(stroke)
    if not bi:
        return 'continue'
    assert bi.stroke == stroke, f"bi: {bi} stroke: {stroke}"
    # Ignore the replace-string command in the minibuffer.
    if bi.commandName == 'replace-string' and state == 'getArg':
        return 'ignore'
    # Execute this command.
    if bi.commandName not in k.singleLineCommandList:
        k.keyboardQuit()
    else:
        c.minibufferWantsFocus()
        c.doCommandByName(bi.commandName, event)
    # Careful: the command could exit.
    if c.exists and not k.silentMode:
        # Use the state *after* executing the command.
        if k.state.kind:
            c.minibufferWantsFocus()
        else:
            c.bodyWantsFocus()
    return 'found'
#@+node:ekr.20200725105324.73: *10* 1. k.isSpecialKey
Only headline has changed
#@+node:ekr.20200725105324.74: *11* Old:k.isSpecialKey
def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) > 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
#@+node:ekr.20180418031118.1: *11* 1. k.isSpecialKey
def isSpecialKey(self, event):
    """Return True if char is a special key."""
    if not event:
        # An empty event is not an error.
        return False
    # Fix #917.
    if len(event.char) > 1 and not event.stroke.s:
        # stroke.s was cleared, but not event.char.
        return True
    return event.char in g.app.gui.ignoreChars
#@+node:ekr.20200725105324.75: *10* 3. k.doKeyboardQuit
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,17 +1,14 @@
 def doKeyboardQuit(self, event):
     """
-    Handle keyboard-quit logic.
+    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
+    
     return True if k.masterKeyHandler should return.
     """
     c, k = self.c, self
-    stroke = event.stroke
-    if k.abortAllModesKey and stroke == k.abortAllModesKey:
+    stroke = getattr(event, 'stroke', None)
+    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
         if getattr(c, 'screenCastController', None):
             c.screenCastController.quit()
-        k.masterCommand(
-            commandName='keyboard-quit',
-            event=event,
-            func=k.keyboardQuit,
-            stroke=stroke)
+        c.doCommandByName('keyboard-quit', event)
         return True
     return False
@language python
#@+node:ekr.20200725105324.76: *11* Old:k.keyboardQuit
def doKeyboardQuit(self, event):
    """
    Handle keyboard-quit logic.
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = event.stroke
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        k.masterCommand(
            commandName='keyboard-quit',
            event=event,
            func=k.keyboardQuit,
            stroke=stroke)
        return True
    return False
#@+node:ekr.20180418024449.1: *11* 3. k.doKeyboardQuit
def doKeyboardQuit(self, event):
    """
    A helper for k.masterKeyHandler: Handle keyboard-quit logic.
    
    return True if k.masterKeyHandler should return.
    """
    c, k = self.c, self
    stroke = getattr(event, 'stroke', None)
    if k.abortAllModesKey and stroke and stroke == k.abortAllModesKey:
        if getattr(c, 'screenCastController', None):
            c.screenCastController.quit()
        c.doCommandByName('keyboard-quit', event)
        return True
    return False
#@+node:ekr.20200725105324.77: *10* k.Modes
Only headline has changed
#@+node:ekr.20200725105324.78: *11* Old:k.Modes (no change)
#@+node:ekr.20120208064440.10190: *11* k.Modes
#@+node:ekr.20061031131434.100: *12* k.addModeCommands (enterModeCallback)
def addModeCommands(self):
    """Add commands created by @mode settings to c.commandsDict."""
    k = self; c = k.c
    d = g.app.config.modeCommandsDict  # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop

        def enterModeCallback(event=None, name=key):
            k.enterNamedMode(event, name)

        c.commandsDict[key] = enterModeCallback
#@+node:ekr.20061031131434.157: *12* k.badMode
def badMode(self, modeName):
    k = self
    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey(f"@mode {modeName} is not defined (or is empty)")
#@+node:ekr.20061031131434.158: *12* k.createModeBindings
def createModeBindings(self, modeName, d, w):
    """Create mode bindings for the named mode using dictionary d for w, a text widget."""
    k = self; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*', '*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:', commandName, 'Referenced from', modeName)
            continue
        aList = d.get(commandName, [])
        for bi in aList:
            stroke = bi.stroke
            # Important: bi.val is canonicalized.
            if stroke and stroke not in ('None', 'none', None):
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)
                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName, {})
                d2[stroke] = g.BindingInfo(
                    kind=f"mode<{modeName}>",
                    commandName=commandName,
                    func=func,
                    nextMode=bi.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
#@+node:ekr.20120208064440.10179: *12* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
#@+node:ekr.20061031131434.160: *12* k.enterNamedMode
def enterNamedMode(self, event, commandName):
    k = self; c = k.c
    modeName = commandName[6:]
    c.inCommand = False  # Allow inner commands in the mode.
    k.generalModeHandler(event, modeName=modeName)
#@+node:ekr.20061031131434.161: *12* k.exitNamedMode
@cmd('exit-named-mode')
def exitNamedMode(self, event=None):
    """Exit an input mode."""
    k = self
    if k.inState():
        k.endMode()
    k.showStateAndMode()
#@+node:ekr.20061031131434.165: *12* k.modeHelp & helper
@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
#@+node:ekr.20061031131434.166: *13* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
#@+node:ekr.20061031131434.164: *12* k.reinitMode
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
#@+node:ekr.20120208064440.10199: *12* k.generalModeHandler
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
#@+node:ekr.20200725105324.79: *10* k.endMode
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -3,7 +3,6 @@
     w = g.app.gui.get_focus(c)
     if w:
         c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
-    k.endCommand(k.stroke)
     k.inputModeName = None
     k.clearState()
     k.resetLabel()
@language python
#@+node:ekr.20200725105324.80: *11* Old:k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
#@+node:ekr.20120208064440.10179: *11* k.endMode
def endMode(self):
    k = self; c = k.c
    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode')  # Changes focus to the body pane
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()  # Restores focus.
    if w:
        c.widgetWantsFocusNow(w)
#@+node:ekr.20200725105324.81: *10* k.modeHelp & helper
Only headline has changed
#@+node:ekr.20200725105324.82: *11* Old:k.modeHelp & helper (revise helper)
@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
#@+node:ekr.20061031131434.165: *11* k.modeHelp & helper
@cmd('mode-help')
def modeHelp(self, event):
    """
    The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.
    """
    k = self; c = k.c
    c.endEditing()
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-' + k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
#@+node:ekr.20061031131434.166: *12* modeHelpHelper
def modeHelpHelper(self, d):
    k = self; c = k.c; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data, n = [], 0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*', '*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for bi in aList:
                stroke = bi.stroke
                if stroke not in (None, 'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n, len(s1))
                    data.append((s1, s2),)
    data.sort()
    modeName = k.inputModeName.replace('-', ' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('', f"{prompt.kind.strip()}\n\n", tabName=tabName)
    else:
        g.es('', f"{modeName} mode\n\n", tabName=tabName)
    # This isn't perfect in variable-width fonts.
    for s1, s2 in data:
        g.es('', '%*s %s' % (n, s1, s2), tabName=tabName)
#@+node:ekr.20200725105324.83: *10* k.reinitMode
Only headline has changed
#@+node:ekr.20200725105324.84: *11* Old:k.reinitMode (call k.createModeBindings???)
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
#@+node:ekr.20061031131434.164: *11* k.reinitMode
def reinitMode(self, modeName):
    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName, d, w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName + ': ')  # ,protect=True)
#@+node:ekr.20200725105324.85: *10* k.generalModeHandler
Only headline has changed
#@+node:ekr.20200725105324.86: *11* Old:k.generalModeHandler (OLD)
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
#@+node:ekr.20120208064440.10199: *11* k.generalModeHandler
def generalModeHandler(self, event,
    commandName=None,
    func=None,
    modeName=None,
    nextMode=None,
    prompt=None
):
    """Handle a mode defined by an @mode node in leoSettings.leo."""
    k = self; c = k.c
    state = k.getState(modeName)
    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName, 1, handler=k.generalModeHandler)
        self.initMode(event, modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c, w=k.modeWidget)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None, 'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName, 1, handler=k.generalModeHandler)
                self.reinitMode(modeName)  # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False  # All silent modes must do --> set-silent-mode.
                self.initMode(event, nextMode)  # Enter another mode.
#@+node:ekr.20200725105324.87: *10* 2. k.setLossage
Only headline has changed
#@+node:ekr.20200725105324.88: *11* Old:k.setLossage
def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
#@+node:ekr.20110609161752.16459: *11* 2. k.setLossage
def setLossage(self, ch, stroke):

    # k = self
    if ch or stroke:
        if len(g.app.lossage) > 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0, (ch, stroke),)
#@+node:ekr.20200725105324.89: *8* leo/core/leoMenu.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -2,7 +2,6 @@
#@verbatim
 #@+node:ekr.20031218072017.3749: * @file leoMenu.py
 """Gui-independent menu handling for Leo."""
 import leo.core.leoGlobals as g
-# import sys
#@verbatim
 #@+others
#@verbatim
 #@+node:ekr.20031218072017.3750: ** class LeoMenu
 class LeoMenu:
@@ -256,17 +255,12 @@
         if g.isascii(name):
             return ''.join([ch for ch in name.lower() if ch not in '& \t\n\r'])
         return ''.join([ch for ch in name if ch not in '& \t\n\r'])
-    #@+node:ekr.20051022044950: *4* LeoMenu.computeOldStyleShortcutKey
-    def computeOldStyleShortcutKey(self, s):
-        """Compute the old-style shortcut key for @shortcuts entries."""
-        # #1121: Allow Chinese characters in command names
-        return s.strip()
#@verbatim
     #@+node:ekr.20031218072017.1723: *4* LeoMenu.createMenuEntries & helpers
-    def createMenuEntries(self, menu, table, dynamicMenu=False):
+    def createMenuEntries(self, menu, table):
         """
         Create a menu entry from the table.
-        New in 4.4: this method shows the shortcut in the menu,
-        but this method **never** binds any shortcuts.
+        
+        This method shows the shortcut in the menu, but **never** binds any shortcuts.
         """
         c = self.c
         if g.app.unitTesting: return
@@ -274,11 +268,12 @@
         self.traceMenuTable(table)
         for data in table:
             label, command, done = self.getMenuEntryInfo(data, menu)
-            if done: continue
-            commandName = self.getMenuEntryBindings(command, dynamicMenu, label)
-            if not commandName: continue
-            masterMenuCallback = self.createMasterMenuCallback(
-                dynamicMenu, command, commandName)
+            if done:
+                continue
+            commandName = self.getMenuEntryBindings(command, label)
+            if not commandName:
+                continue
+            masterMenuCallback = self.createMasterMenuCallback(command, commandName)
             realLabel = self.getRealMenuName(label)
             amp_index = realLabel.find("&")
             realLabel = realLabel.replace("&", "")
@@ -289,54 +284,54 @@
                 commandName=commandName,
                 underline=amp_index)
#@verbatim
     #@+node:ekr.20111102072143.10016: *5* LeoMenu.createMasterMenuCallback
-    def createMasterMenuCallback(self, dynamicMenu, command, commandName):
-
-        # pylint: disable=no-else-return
-            # This code is simpler as it is.
-
-        c = self.c
-
-        def setWidget():
+    def createMasterMenuCallback(self, command, commandName):
+        """
+        Create a callback for the given args.
+        
+        - If command is a string, it is treated as a command name.
+        - Otherwise, it should be a callable representing the actual command.
+        """
+        c = self.c
+
+        def getWidget():
+            """Carefully return the widget that has focus."""
             w = c.frame.getFocus()
             if w and g.isMac:
-                 # 2012/01/11: redirect (MacOS only).
+                # Redirect (MacOS only).
                 wname = c.widget_name(w)
                 if wname.startswith('head'):
                     w = c.frame.tree.edit_widget(c.p)
-            # 2015/05/14: return a wrapper if possible.
+            # Return a wrapper if possible.
             if not g.isTextWrapper(w):
                 w = getattr(w, 'wrapper', w)
             return w
 
-        if dynamicMenu:
-            if command:
-
-                def masterDynamicMenuCallback(c=c, command=command):
-                    # 2012/01/07: set w here.
-                    w = setWidget()
-                    event = g.app.gui.create_key_event(c, w=w)
-                    return c.k.masterCommand(func=command, event=event)
-
-                return masterDynamicMenuCallback
-            else:
-                g.internalError('no callback for dynamic menu item.')
-
-                def dummyMasterMenuCallback():
-                    pass
-
-                return dummyMasterMenuCallback
-        else:
-
-            def masterStaticMenuCallback(c=c, commandName=commandName):
-                # 2011/10/28: Use only the command name to dispatch the command.
-                # 2012/01/07: Bug fix: set w here.
-                w = setWidget()
-                event = g.app.gui.create_key_event(c, w=w)
-                return c.k.masterCommand(commandName=commandName, event=event)
-
-            return masterStaticMenuCallback
+        if isinstance(command, str):
+            
+            def static_menu_callback():
+                event = g.app.gui.create_key_event(c, w=getWidget())
+                c.doCommandByName(commandName, event)
+
+            return static_menu_callback
+            
+        # The command must be a callable.
+        if not callable(command):
+
+            def dummy_menu_callback(event=None):
+                pass
+        
+            g.trace(f"bad command: {command!r}", color='red')
+            return dummy_menu_callback
+
+        # Create a command dynamically.
+
+        def dynamic_menu_callback():
+            event = g.app.gui.create_key_event(c, w=getWidget())
+            return c.doCommand(command, commandName, event)  # #1595
+
+        return dynamic_menu_callback
#@verbatim
     #@+node:ekr.20111028060955.16568: *5* LeoMenu.getMenuEntryBindings
-    def getMenuEntryBindings(self, command, dynamicMenu, label):
+    def getMenuEntryBindings(self, command, label):
         """Compute commandName from command."""
         c = self.c
         if isinstance(command, str):
@@ -344,11 +339,23 @@
             commandName = command
         else:
             # First, get the old-style name.
-            commandName = self.computeOldStyleShortcutKey(label)
+            # #1121: Allow Chinese characters in command names
+            commandName = label.strip()
         command = c.commandsDict.get(commandName)
         return commandName
#@verbatim
     #@+node:ekr.20111028060955.16565: *5* LeoMenu.getMenuEntryInfo
     def getMenuEntryInfo(self, data, menu):
+        """
+        Parse a single entry in the table passed to createMenuEntries.
+        
+        Table entries have the following formats:
+            
+        1. A string, used as the command name.
+        2. A 2-tuple: (command_name, command_func)
+        3. A 3-tuple: (command_name, menu_shortcut, command_func)
+        
+        Special case: If command_name is None or "-" it represents a menu separator.
+        """
         done = False
         if isinstance(data, str):
             # A single string is both the label and the command.
@@ -394,7 +401,7 @@
             else:
                 print(format % (data, ''))
#@verbatim
     #@+node:ekr.20031218072017.3784: *4* LeoMenu.createMenuItemsFromTable
-    def createMenuItemsFromTable(self, menuName, table, dynamicMenu=False):
+    def createMenuItemsFromTable(self, menuName, table):
 
         if g.app.gui.isNullGui:
             return
@@ -402,7 +409,7 @@
             menu = self.getMenu(menuName)
             if menu is None:
                 return
-            self.createMenuEntries(menu, table, dynamicMenu=dynamicMenu)
+            self.createMenuEntries(menu, table)
         except Exception:
             g.es_print("exception creating items for", menuName, "menu")
             g.es_exception()
@@ -534,33 +541,6 @@
             if menu:
                 self.destroy(menu)
                 self.destroyMenu(i)
-    #@+node:ekr.20031218072017.4117: *4* LeoMenu.defineMenuCallback
-    def defineMenuCallback(self, command, name, minibufferCommand):
-        # pylint: disable=no-else-return
-            # This code is simpler as it is.
-        c = self.c
-        if minibufferCommand:
-            # Create a dummy event as a signal to doCommand.
-            event = g.app.gui.create_key_event(c)
-            # The first parameter must be event, and it must default to None.
-
-            def minibufferMenuCallback(
-                event=event, self=self, command=command, label=name):
-                c = self.c
-                return c.doCommand(command, label, event)
-
-            return minibufferMenuCallback
-        else:
-            # The first parameter must be event, and it must default to None.
-
-            def legacyMenuCallback(event=None, self=self, command=command, label=name):
-                c = self.c  # 2012/03/04.
-                c.check_event(event)
-                return c.doCommand(command, label)
-
-            return legacyMenuCallback
-        # For pylint
-        return None
#@verbatim
     #@+node:ekr.20031218072017.3805: *4* LeoMenu.deleteMenu
     def deleteMenu(self, menuName):
         try:
@@ -626,6 +606,7 @@
 
     def add_separator(self, menu):
         self.oops()
+
     # def bind (self,bind_shortcut,callback):
     #     self.oops()
@language python
#@+node:ekr.20200725105324.96: *9* Deleted
#@+node:ekr.20200725105324.97: *10* LeoMenu.computeOldStyleShortcutKey
def computeOldStyleShortcutKey(self, s):
    """Compute the old-style shortcut key for @shortcuts entries."""
    # #1121: Allow Chinese characters in command names
    return s.strip()
#@+node:ekr.20200725105324.98: *10* LeoMenu.defineMenuCallback
def defineMenuCallback(self, command, name, minibufferCommand):
    # pylint: disable=no-else-return
        # This code is simpler as it is.
    c = self.c
    if minibufferCommand:
        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c)
        # The first parameter must be event, and it must default to None.

        def minibufferMenuCallback(
            event=event, self=self, command=command, label=name):
            c = self.c
            return c.doCommand(command, label, event)

        return minibufferMenuCallback
    else:
        # The first parameter must be event, and it must default to None.

        def legacyMenuCallback(event=None, self=self, command=command, label=name):
            c = self.c  # 2012/03/04.
            c.check_event(event)
            return c.doCommand(command, label)

        return legacyMenuCallback
    # For pylint
    return None
#@+node:ekr.20200725105324.99: *9* Changed
#@+node:ekr.20200725105324.100: *10* leo/core/leoMenu.py:2507a1fcc70
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,6 +1,5 @@
 """Gui-independent menu handling for Leo."""
 import leo.core.leoGlobals as g
-# import sys
 @others
 @language python
 @tabwidth -4
@language python
#@+node:ekr.20200725105324.101: *11* Old:leo/core/leoMenu.py:2507a1fcc70
"""Gui-independent menu handling for Leo."""
import leo.core.leoGlobals as g
# import sys
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20031218072017.3749: *11* @file leoMenu.py
"""Gui-independent menu handling for Leo."""
import leo.core.leoGlobals as g
@others
@language python
@tabwidth -4
@pagewidth 70
#@+node:ekr.20031218072017.3750: *12* class LeoMenu
class LeoMenu:
    """The base class for all Leo menus."""
    @others
#@+node:ekr.20120124042346.12938: *13* LeoMenu.Birth
def __init__(self, frame):
    self.c = frame.c
    self.enable_dict = {}  # Created by finishCreate.
    self.frame = frame
    self.isNull = False
    self.menus = {}  # Menu dictionary.
    self.menuShortcuts = {}

def finishCreate(self):
    self.define_enable_dict()
#@+node:ekr.20120124042346.12937: *14* LeoMenu.define_enable_table
@nobeautify

def define_enable_dict (self):

    # pylint: disable=unnecessary-lambda
    # The lambdas *are* necessary.
    c = self.c
    if not c.commandsDict:
        return # This is not an error: it happens during init.
    self.enable_dict = d = {

        # File menu...
            # 'revert':         True, # Revert is always enabled.
            # 'open-with':      True, # Open-With is always enabled.

        # Edit menu...
        'undo':                 c.undoer.canUndo,
        'redo':                 c.undoer.canRedo,
        'extract-names':        c.canExtractSectionNames,
        'extract':              c.canExtract,
        'match-brackets':       c.canFindMatchingBracket,

        # Top-level Outline menu...
        'cut-node':             c.canCutOutline,
        'delete-node':          c.canDeleteHeadline,
        'paste-node':           c.canPasteOutline,
        'paste-retaining-clones':   c.canPasteOutline,
        'clone-node':           c.canClone,
        'sort-siblings':        c.canSortSiblings,
        'hoist':                c.canHoist,
        'de-hoist':             c.canDehoist,

        # Outline:Expand/Contract menu...
        'contract-parent':      c.canContractParent,
        'contract-node':        lambda: c.p.hasChildren() and c.p.isExpanded(),
        'contract-or-go-left':  lambda: c.p.hasChildren() and c.p.isExpanded() or c.p.hasParent(),
        'expand-node':          lambda: c.p.hasChildren() and not c.p.isExpanded(),
        'expand-prev-level':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-next-level':    lambda: c.p.hasChildren(),
        'expand-to-level-1':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-or-go-right':   lambda: c.p.hasChildren(),

        # Outline:Move menu...
        'move-outline-down':    lambda: c.canMoveOutlineDown(),
        'move-outline-left':    lambda: c.canMoveOutlineLeft(),
        'move-outline-right':   lambda: c.canMoveOutlineRight(),
        'move-outline-up':      lambda: c.canMoveOutlineUp(),
        'promote':              lambda: c.canPromote(),
        'demote':               lambda: c.canDemote(),

        # Outline:Go To menu...
        'goto-prev-history-node':   lambda: c.nodeHistory.canGoToPrevVisited(),
        'goto-next-history-node':   lambda: c.nodeHistory.canGoToNextVisited(),
        'goto-prev-visible':        lambda: c.canSelectVisBack(),
        'goto-next-visible':        lambda: c.canSelectVisNext(),
        # These are too slow...
            # 'go-to-next-marked':  c.canGoToNextMarkedHeadline,
            # 'go-to-next-changed': c.canGoToNextDirtyHeadline,
        'goto-next-clone':          lambda: c.p.isCloned(),
        'goto-prev-node':           lambda: c.canSelectThreadBack(),
        'goto-next-node':           lambda: c.canSelectThreadNext(),
        'goto-parent':              lambda: c.p.hasParent(),
        'goto-prev-sibling':        lambda: c.p.hasBack(),
        'goto-next-sibling':        lambda: c.p.hasNext(),

        # Outline:Mark menu...
        'mark-subheads':            lambda: c.p.hasChildren(),
        # too slow...
            # 'mark-changed-items':   c.canMarkChangedHeadlines,
    }

    for i in range(1,9):
        d [f"expand-to-level-{i}"] = lambda: c.p.hasChildren()

    if 0: # Initial testing.
        commandKeys = list(c.commandsDict.keys())
        for key in sorted(d.keys()):
            if key not in commandKeys:
                g.trace(f"*** bad entry for {key}")
#@+node:ekr.20031218072017.3775: *13* LeoMenu.error and oops
def oops(self):
    g.pr("LeoMenu oops:", g.callers(4), "should be overridden in subclass")

def error(self, s):
    g.error('', s)
#@+node:ekr.20031218072017.3781: *13* LeoMenu.Gui-independent menu routines
#@+node:ekr.20060926213642: *14* LeoMenu.capitalizeMinibufferMenuName
@nobeautify

def capitalizeMinibufferMenuName(self, s, removeHyphens):
    result = []
    for i, ch in enumerate(s):
        prev =     s[i - 1] if i > 0 else ''
        prevprev = s[i - 2] if i > 1 else ''
        if (
            i == 0 or
            i == 1 and prev == '&' or
            prev == '-' or
            prev == '&' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)
#@+node:ekr.20031218072017.3785: *14* LeoMenu.createMenusFromTables & helpers
def createMenusFromTables(self):
    """(leoMenu) Usually over-ridden."""
    c = self.c
    aList = c.config.getMenusList()
    if aList:
        self.createMenusFromConfigList(aList)
    else:
        g.es_print('No @menu setting found')
#@+node:ekr.20070926135612: *15* LeoMenu.createMenusFromConfigList & helpers
def createMenusFromConfigList(self, aList):
    """
    Create menus from aList.
    The 'top' menu has already been created.
    """
    # Called from createMenuBar.
    c = self.c
    for z in aList:
        kind, val, val2 = z
        if kind.startswith('@menu'):
            name = kind[len('@menu') :].strip()
            if not self.handleSpecialMenus(name, parentName=None):
                # Fix #528: Don't create duplicate menu items.
                menu = self.createNewMenu(name)
                    # Create top-level menu.
                if menu:
                    self.createMenuFromConfigList(name, val, level=0)
                else:
                    g.trace('no menu', name)
        else:
            self.error(f"{kind} {val} not valid outside @menu tree")
    aList = c.config.getOpenWith()
    if aList:
        # a list of dicts.
        self.createOpenWithMenuFromTable(aList)
#@+node:ekr.20070927082205: *16* LeoMenu.createMenuFromConfigList
def createMenuFromConfigList(self, parentName, aList, level=0):
    """Build menu based on nested list

    List entries are either:

        ['@item', 'command-name', 'optional-view-name']

    or:

        ['@menu Submenu name', <nested list>, None]

    :param str parentName: name of menu under which to place this one
    :param list aList: list of entries as described above
    """
    parentMenu = self.getMenu(parentName)
    if not parentMenu:
        g.trace('NO PARENT', parentName, g.callers())
    table = []
    for z in aList:
        kind, val, val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu, table)
            if not self.handleSpecialMenus(name, parentName,
                alt_name=val2,  #848.
                table=table,
            ):
                menu = self.createNewMenu(name, parentName)
                    # Create submenu of parent menu.
                if menu:
                    # Partial fix for #528.
                    self.createMenuFromConfigList(name, val, level + 1)
            table = []
        elif kind == '@item':
            name = str(val)  # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2, name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:', kind)
    if table:
        self.createMenuEntries(parentMenu, table)
#@+node:ekr.20070927172712: *16* LeoMenu.handleSpecialMenus
def handleSpecialMenus(self, name, parentName, alt_name=None, table=None):
    """
    Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.
    """
    c = self.c
    if table is None: table = []
    name2 = name.replace('&', '').replace(' ', '').lower()
    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus", c=c, menu_name=name)
        return True
    if name2.startswith('recentfiles'):
        # Just create the menu.
        # createRecentFilesMenuItems will create the contents later.
        g.app.recentFilesManager.recentFilesMenuName = alt_name or name
            #848
        self.createNewMenu(alt_name or name, parentName)
        return True
    if name2 == 'help' and g.isMac:
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    return False
#@+node:ekr.20031218072017.3780: *14* LeoMenu.hasSelection
# Returns True if text in the outline or body text is selected.

def hasSelection(self):
    c = self.c; w = c.frame.body.wrapper
    if c.frame.body:
        first, last = w.getSelectionRange()
        return first != last
    return False
#@+node:ekr.20051022053758.1: *13* LeoMenu.Helpers
#@+node:ekr.20031218072017.3783: *14* LeoMenu.canonicalize*
def canonicalizeMenuName(self, name):

    # #1121 & #1188. Allow Chinese characters in command names
    if g.isascii(name):
        return ''.join([ch for ch in name.lower() if ch.isalnum()])
    return name

def canonicalizeTranslatedMenuName(self, name):

    # #1121 & #1188. Allow Chinese characters in command names
    if g.isascii(name):
        return ''.join([ch for ch in name.lower() if ch not in '& \t\n\r'])
    return ''.join([ch for ch in name if ch not in '& \t\n\r'])
#@+node:ekr.20031218072017.1723: *14* LeoMenu.createMenuEntries & helpers
def createMenuEntries(self, menu, table):
    """
    Create a menu entry from the table.
    
    This method shows the shortcut in the menu, but **never** binds any shortcuts.
    """
    c = self.c
    if g.app.unitTesting: return
    if not menu: return
    self.traceMenuTable(table)
    for data in table:
        label, command, done = self.getMenuEntryInfo(data, menu)
        if done:
            continue
        commandName = self.getMenuEntryBindings(command, label)
        if not commandName:
            continue
        masterMenuCallback = self.createMasterMenuCallback(command, commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&", "")
        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu, label=realLabel,
            accelerator='',  # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
#@+node:ekr.20111102072143.10016: *15* LeoMenu.createMasterMenuCallback
def createMasterMenuCallback(self, command, commandName):
    """
    Create a callback for the given args.
    
    - If command is a string, it is treated as a command name.
    - Otherwise, it should be a callable representing the actual command.
    """
    c = self.c

    def getWidget():
        """Carefully return the widget that has focus."""
        w = c.frame.getFocus()
        if w and g.isMac:
            # Redirect (MacOS only).
            wname = c.widget_name(w)
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        # Return a wrapper if possible.
        if not g.isTextWrapper(w):
            w = getattr(w, 'wrapper', w)
        return w

    if isinstance(command, str):
        
        def static_menu_callback():
            event = g.app.gui.create_key_event(c, w=getWidget())
            c.doCommandByName(commandName, event)

        return static_menu_callback
        
    # The command must be a callable.
    if not callable(command):

        def dummy_menu_callback(event=None):
            pass
    
        g.trace(f"bad command: {command!r}", color='red')
        return dummy_menu_callback

    # Create a command dynamically.

    def dynamic_menu_callback():
        event = g.app.gui.create_key_event(c, w=getWidget())
        return c.doCommand(command, commandName, event)  # #1595

    return dynamic_menu_callback
#@+node:ekr.20111028060955.16568: *15* LeoMenu.getMenuEntryBindings
def getMenuEntryBindings(self, command, label):
    """Compute commandName from command."""
    c = self.c
    if isinstance(command, str):
        # Command is really a command name.
        commandName = command
    else:
        # First, get the old-style name.
        # #1121: Allow Chinese characters in command names
        commandName = label.strip()
    command = c.commandsDict.get(commandName)
    return commandName
#@+node:ekr.20111028060955.16565: *15* LeoMenu.getMenuEntryInfo
def getMenuEntryInfo(self, data, menu):
    """
    Parse a single entry in the table passed to createMenuEntries.
    
    Table entries have the following formats:
        
    1. A string, used as the command name.
    2. A 2-tuple: (command_name, command_func)
    3. A 3-tuple: (command_name, menu_shortcut, command_func)
    
    Special case: If command_name is None or "-" it represents a menu separator.
    """
    done = False
    if isinstance(data, str):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0] == '*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s, removeHyphens)
        command = s.replace('&', '').lower()
        if label == '-':
            self.add_separator(menu)
            done = True  # That's all.
    else:
        ok = isinstance(data, (list, tuple)) and len(data) in (2, 3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label, command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label, junk, command = data
            if label in (None, '-'):
                self.add_separator(menu)
                done = True  # That's all.
        else:
            g.trace(f"bad data in menu table: {repr(data)}")
            done = True  # Ignore bad data
    return label, command, done
#@+node:ekr.20111028060955.16563: *15* LeoMenu.traceMenuTable
def traceMenuTable(self, table):

    trace = False and not g.unitTesting
    if not trace: return
    format = '%40s %s'
    g.trace('*' * 40)
    for data in table:
        if isinstance(data, (list, tuple)):
            n = len(data)
            if n == 2:
                print(format % (data[0], data[1]))
            elif n == 3:
                name, junk, func = data
                print(format % (name, func and func.__name__ or '<NO FUNC>'))
        else:
            print(format % (data, ''))
#@+node:ekr.20031218072017.3784: *14* LeoMenu.createMenuItemsFromTable
def createMenuItemsFromTable(self, menuName, table):

    if g.app.gui.isNullGui:
        return
    try:
        menu = self.getMenu(menuName)
        if menu is None:
            return
        self.createMenuEntries(menu, table)
    except Exception:
        g.es_print("exception creating items for", menuName, "menu")
        g.es_exception()
    g.app.menuWarningsGiven = True
#@+node:ekr.20031218072017.3804: *14* LeoMenu.createNewMenu
def createNewMenu(self, menuName, parentName="top", before=None):
    try:
        parent = self.getMenu(parentName)  # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            # Not an error.
            # g.error("menu already exists:", menuName)
            return None  # Fix #528.
        menu = self.new_menu(parent, tearoff=0, label=menuName)
        self.setMenu(menuName, menu)
        label = self.getRealMenuName(menuName)
        amp_index = label.find("&")
        label = label.replace("&", "")
        if before:  # Insert the menu before the "before" menu.
            index_label = self.getRealMenuName(before)
            amp_index = index_label.find("&")
            index_label = index_label.replace("&", "")
            index = parent.index(index_label)
            self.insert_cascade(
                parent, index=index, label=label, menu=menu, underline=amp_index)
        else:
            self.add_cascade(parent, label=label, menu=menu, underline=amp_index)
        return menu
    except Exception:
        g.es("exception creating", menuName, "menu")
        g.es_exception()
        return None
#@+node:ekr.20031218072017.4116: *14* LeoMenu.createOpenWithMenuFromTable & helpers
def createOpenWithMenuFromTable(self, table):
    """
    Table is a list of dictionaries, created from @openwith settings nodes.

    This menu code uses these keys:

        'name':     menu label.
        'shortcut': optional menu shortcut.

    efc.open_temp_file uses these keys:

        'args':     the command-line arguments to be used to open the file.
        'ext':      the file extension.
        'kind':     the method used to open the file, such as subprocess.Popen.
    """
    k = self.c.k
    if not table: return
    g.app.openWithTable = table  # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    if not parent:
        if not g.app.batchMode:
            g.error('', 'createOpenWithMenuFromTable:', 'no File menu')
        return
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&", "")
    try:
        index = parent.index(label)
        parent.delete(index)
    except Exception:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except Exception:
            g.trace('unexpected exception')
            g.es_exception()
            return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent, label, index, amp_index)
    if not openWithMenu:
        g.trace('openWithMenu returns None')
        return
    self.setMenu("Open With...", openWithMenu)
    # Create the menu items in of the Open With menu.
    self.createOpenWithMenuItemsFromTable(openWithMenu, table)
    for d in table:
        k.bindOpenWith(d)
#@+node:ekr.20051022043608.1: *15* LeoMenu.createOpenWithMenuItemsFromTable & callback
def createOpenWithMenuItemsFromTable(self, menu, table):
    """
    Create an entry in the Open with Menu from the table, a list of dictionaries.

    Each dictionary d has the following keys:

    'args':     the command-line arguments used to open the file.
    'ext':      not used here: used by efc.open_temp_file.
    'kind':     not used here: used by efc.open_temp_file.
    'name':     menu label.
    'shortcut': optional menu shortcut.
    """
    c = self.c
    if g.app.unitTesting: return
    for d in table:
        label = d.get('name')
        args = d.get('args', [])
        accel = d.get('shortcut') or ''
        if label and args:
            realLabel = self.getRealMenuName(label)
            underline = realLabel.find("&")
            realLabel = realLabel.replace("&", "")
            callback = self.defineOpenWithMenuCallback(d)
            c.add_command(menu,
                label=realLabel,
                accelerator=accel,
                command=callback,
                underline=underline)
#@+node:ekr.20031218072017.4118: *16* LeoMenu.defineOpenWithMenuCallback
def defineOpenWithMenuCallback(self, d):
    # The first parameter must be event, and it must default to None.

    def openWithMenuCallback(event=None, self=self, d=d):
        return self.c.openWith(d=d)

    return openWithMenuCallback
#@+node:tbrown.20080509212202.7: *14* LeoMenu.deleteRecentFilesMenuItems
def deleteRecentFilesMenuItems(self, menu):
    """Delete recent file menu entries"""
    rf = g.app.recentFilesManager
    # Why not just delete all the entries?
    recentFiles = rf.getRecentFiles()
    toDrop = len(recentFiles) + len(rf.getRecentFilesTable())
    self.delete_range(menu, 0, toDrop)
    for i in rf.groupedMenus:
        menu = self.getMenu(i)
        if menu:
            self.destroy(menu)
            self.destroyMenu(i)
#@+node:ekr.20031218072017.3805: *14* LeoMenu.deleteMenu
def deleteMenu(self, menuName):
    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu:", menuName)
    except Exception:
        g.es("exception deleting", menuName, "menu")
        g.es_exception()
#@+node:ekr.20031218072017.3806: *14* LeoMenu.deleteMenuItem
def deleteMenuItem(self, itemName, menuName="top"):
    """Delete itemName from the menu whose name is menuName."""
    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu, realItemName)
        else:
            g.es("menu not found:", menuName)
    except Exception:
        g.es("exception deleting", itemName, "from", menuName, "menu")
        g.es_exception()
#@+node:ekr.20031218072017.3782: *14* LeoMenu.get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName(self, menuName):
    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn, menuName)

def setRealMenuName(self, untrans, trans):
    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable(self, table):
    try:
        for untrans, trans in table:
            self.setRealMenuName(untrans, trans)
    except Exception:
        g.es("exception in", "setRealMenuNamesFromTable")
        g.es_exception()
#@+node:ekr.20031218072017.3807: *14* LeoMenu.getMenu, setMenu, destroyMenu
def getMenu(self, menuName):
    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)

def setMenu(self, menuName, menu):
    cmn = self.canonicalizeMenuName(menuName)
    self.menus[cmn] = menu

def destroyMenu(self, menuName):
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@+node:ekr.20031218072017.3808: *13* LeoMenu.Must be overridden in menu subclasses
#@+node:ekr.20031218072017.3809: *14* LeoMenu.9 Routines with Tk spellings
def add_cascade(self, parent, label, menu, underline):
    self.oops()

def add_command(self, menu, **keys):
    self.oops()

def add_separator(self, menu):
    self.oops()

# def bind (self,bind_shortcut,callback):
#     self.oops()

def delete(self, menu, realItemName):
    self.oops()

def delete_range(self, menu, n1, n2):
    self.oops()

def destroy(self, menu):
    self.oops()

def insert(
    self, menuName, position, label, command, underline=None):  # New in Leo 4.4.3 a1
    self.oops()

def insert_cascade(self, parent, index, label, menu, underline):
    self.oops()

def new_menu(self, parent, tearoff=0, label=''):
    # 2010: added label arg for pylint.
    self.oops()
#@+node:ekr.20031218072017.3810: *14* LeoMenu.9 Routines with new spellings
def activateMenu(self, menuName):  # New in Leo 4.4b2.
    self.oops()

def clearAccel(self, menu, name):
    self.oops()

def createMenuBar(self, frame):
    self.oops()

def createOpenWithMenu(self, parent, label, index, amp_index):
    self.oops()

def disableMenu(self, menu, name):
    self.oops()

def enableMenu(self, menu, name, val):
    self.oops()

def getMacHelpMenu(self, table):
    return None

def getMenuLabel(self, menu, name):
    self.oops()

def setMenuLabel(self, menu, name, label, underline=-1):
    self.oops()
#@+node:ekr.20031218072017.3811: *12* class NullMenu
class NullMenu(LeoMenu):
    """A null menu class for testing and batch execution."""
    @others
#@+node:ekr.20050104094308: *13* ctor (NullMenu)
def __init__(self, frame):
    super().__init__(frame)
    self.isNull = True
#@+node:ekr.20050104094029: *13* oops
def oops(self):
    pass
#@+node:ekr.20200725105324.102: *10* LeoMenu.createMenuEntries & helpers
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,8 +1,8 @@
-def createMenuEntries(self, menu, table, dynamicMenu=False):
+def createMenuEntries(self, menu, table):
     """
     Create a menu entry from the table.
-    New in 4.4: this method shows the shortcut in the menu,
-    but this method **never** binds any shortcuts.
+    
+    This method shows the shortcut in the menu, but **never** binds any shortcuts.
     """
     c = self.c
     if g.app.unitTesting: return
@@ -10,11 +10,12 @@
     self.traceMenuTable(table)
     for data in table:
         label, command, done = self.getMenuEntryInfo(data, menu)
-        if done: continue
-        commandName = self.getMenuEntryBindings(command, dynamicMenu, label)
-        if not commandName: continue
-        masterMenuCallback = self.createMasterMenuCallback(
-            dynamicMenu, command, commandName)
+        if done:
+            continue
+        commandName = self.getMenuEntryBindings(command, label)
+        if not commandName:
+            continue
+        masterMenuCallback = self.createMasterMenuCallback(command, commandName)
         realLabel = self.getRealMenuName(label)
         amp_index = realLabel.find("&")
         realLabel = realLabel.replace("&", "")
@language python
#@+node:ekr.20200725105324.103: *11* Old:LeoMenu.createMenuEntries & helpers
def createMenuEntries(self, menu, table, dynamicMenu=False):
    """
    Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.
    """
    c = self.c
    if g.app.unitTesting: return
    if not menu: return
    self.traceMenuTable(table)
    for data in table:
        label, command, done = self.getMenuEntryInfo(data, menu)
        if done: continue
        commandName = self.getMenuEntryBindings(command, dynamicMenu, label)
        if not commandName: continue
        masterMenuCallback = self.createMasterMenuCallback(
            dynamicMenu, command, commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&", "")
        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu, label=realLabel,
            accelerator='',  # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
#@+node:ekr.20031218072017.1723: *11* LeoMenu.createMenuEntries & helpers
def createMenuEntries(self, menu, table):
    """
    Create a menu entry from the table.
    
    This method shows the shortcut in the menu, but **never** binds any shortcuts.
    """
    c = self.c
    if g.app.unitTesting: return
    if not menu: return
    self.traceMenuTable(table)
    for data in table:
        label, command, done = self.getMenuEntryInfo(data, menu)
        if done:
            continue
        commandName = self.getMenuEntryBindings(command, label)
        if not commandName:
            continue
        masterMenuCallback = self.createMasterMenuCallback(command, commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&", "")
        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu, label=realLabel,
            accelerator='',  # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
#@+node:ekr.20111102072143.10016: *12* LeoMenu.createMasterMenuCallback
def createMasterMenuCallback(self, command, commandName):
    """
    Create a callback for the given args.
    
    - If command is a string, it is treated as a command name.
    - Otherwise, it should be a callable representing the actual command.
    """
    c = self.c

    def getWidget():
        """Carefully return the widget that has focus."""
        w = c.frame.getFocus()
        if w and g.isMac:
            # Redirect (MacOS only).
            wname = c.widget_name(w)
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        # Return a wrapper if possible.
        if not g.isTextWrapper(w):
            w = getattr(w, 'wrapper', w)
        return w

    if isinstance(command, str):
        
        def static_menu_callback():
            event = g.app.gui.create_key_event(c, w=getWidget())
            c.doCommandByName(commandName, event)

        return static_menu_callback
        
    # The command must be a callable.
    if not callable(command):

        def dummy_menu_callback(event=None):
            pass
    
        g.trace(f"bad command: {command!r}", color='red')
        return dummy_menu_callback

    # Create a command dynamically.

    def dynamic_menu_callback():
        event = g.app.gui.create_key_event(c, w=getWidget())
        return c.doCommand(command, commandName, event)  # #1595

    return dynamic_menu_callback
#@+node:ekr.20111028060955.16568: *12* LeoMenu.getMenuEntryBindings
def getMenuEntryBindings(self, command, label):
    """Compute commandName from command."""
    c = self.c
    if isinstance(command, str):
        # Command is really a command name.
        commandName = command
    else:
        # First, get the old-style name.
        # #1121: Allow Chinese characters in command names
        commandName = label.strip()
    command = c.commandsDict.get(commandName)
    return commandName
#@+node:ekr.20111028060955.16565: *12* LeoMenu.getMenuEntryInfo
def getMenuEntryInfo(self, data, menu):
    """
    Parse a single entry in the table passed to createMenuEntries.
    
    Table entries have the following formats:
        
    1. A string, used as the command name.
    2. A 2-tuple: (command_name, command_func)
    3. A 3-tuple: (command_name, menu_shortcut, command_func)
    
    Special case: If command_name is None or "-" it represents a menu separator.
    """
    done = False
    if isinstance(data, str):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0] == '*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s, removeHyphens)
        command = s.replace('&', '').lower()
        if label == '-':
            self.add_separator(menu)
            done = True  # That's all.
    else:
        ok = isinstance(data, (list, tuple)) and len(data) in (2, 3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label, command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label, junk, command = data
            if label in (None, '-'):
                self.add_separator(menu)
                done = True  # That's all.
        else:
            g.trace(f"bad data in menu table: {repr(data)}")
            done = True  # Ignore bad data
    return label, command, done
#@+node:ekr.20111028060955.16563: *12* LeoMenu.traceMenuTable
def traceMenuTable(self, table):

    trace = False and not g.unitTesting
    if not trace: return
    format = '%40s %s'
    g.trace('*' * 40)
    for data in table:
        if isinstance(data, (list, tuple)):
            n = len(data)
            if n == 2:
                print(format % (data[0], data[1]))
            elif n == 3:
                name, junk, func = data
                print(format % (name, func and func.__name__ or '<NO FUNC>'))
        else:
            print(format % (data, ''))
#@+node:ekr.20200725105324.104: *10* LeoMenu.createMasterMenuCallback
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,46 +1,46 @@
-def createMasterMenuCallback(self, dynamicMenu, command, commandName):
-
-    # pylint: disable=no-else-return
-        # This code is simpler as it is.
-
+def createMasterMenuCallback(self, command, commandName):
+    """
+    Create a callback for the given args.
+    
+    - If command is a string, it is treated as a command name.
+    - Otherwise, it should be a callable representing the actual command.
+    """
     c = self.c
 
-    def setWidget():
+    def getWidget():
+        """Carefully return the widget that has focus."""
         w = c.frame.getFocus()
         if w and g.isMac:
-             # 2012/01/11: redirect (MacOS only).
+            # Redirect (MacOS only).
             wname = c.widget_name(w)
             if wname.startswith('head'):
                 w = c.frame.tree.edit_widget(c.p)
-        # 2015/05/14: return a wrapper if possible.
+        # Return a wrapper if possible.
         if not g.isTextWrapper(w):
             w = getattr(w, 'wrapper', w)
         return w
 
-    if dynamicMenu:
-        if command:
+    if isinstance(command, str):
+        
+        def static_menu_callback():
+            event = g.app.gui.create_key_event(c, w=getWidget())
+            c.doCommandByName(commandName, event)
 
-            def masterDynamicMenuCallback(c=c, command=command):
-                # 2012/01/07: set w here.
-                w = setWidget()
-                event = g.app.gui.create_key_event(c, w=w)
-                return c.k.masterCommand(func=command, event=event)
+        return static_menu_callback
+        
+    # The command must be a callable.
+    if not callable(command):
 
-            return masterDynamicMenuCallback
-        else:
-            g.internalError('no callback for dynamic menu item.')
+        def dummy_menu_callback(event=None):
+            pass
+    
+        g.trace(f"bad command: {command!r}", color='red')
+        return dummy_menu_callback
 
-            def dummyMasterMenuCallback():
-                pass
+    # Create a command dynamically.
 
-            return dummyMasterMenuCallback
-    else:
+    def dynamic_menu_callback():
+        event = g.app.gui.create_key_event(c, w=getWidget())
+        return c.doCommand(command, commandName, event)  # #1595
 
-        def masterStaticMenuCallback(c=c, commandName=commandName):
-            # 2011/10/28: Use only the command name to dispatch the command.
-            # 2012/01/07: Bug fix: set w here.
-            w = setWidget()
-            event = g.app.gui.create_key_event(c, w=w)
-            return c.k.masterCommand(commandName=commandName, event=event)
-
-        return masterStaticMenuCallback
+    return dynamic_menu_callback
@language python
#@+node:ekr.20200725105324.105: *11* Old:LeoMenu.createMasterMenuCallback
def createMasterMenuCallback(self, dynamicMenu, command, commandName):

    # pylint: disable=no-else-return
        # This code is simpler as it is.

    c = self.c

    def setWidget():
        w = c.frame.getFocus()
        if w and g.isMac:
             # 2012/01/11: redirect (MacOS only).
            wname = c.widget_name(w)
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        # 2015/05/14: return a wrapper if possible.
        if not g.isTextWrapper(w):
            w = getattr(w, 'wrapper', w)
        return w

    if dynamicMenu:
        if command:

            def masterDynamicMenuCallback(c=c, command=command):
                # 2012/01/07: set w here.
                w = setWidget()
                event = g.app.gui.create_key_event(c, w=w)
                return c.k.masterCommand(func=command, event=event)

            return masterDynamicMenuCallback
        else:
            g.internalError('no callback for dynamic menu item.')

            def dummyMasterMenuCallback():
                pass

            return dummyMasterMenuCallback
    else:

        def masterStaticMenuCallback(c=c, commandName=commandName):
            # 2011/10/28: Use only the command name to dispatch the command.
            # 2012/01/07: Bug fix: set w here.
            w = setWidget()
            event = g.app.gui.create_key_event(c, w=w)
            return c.k.masterCommand(commandName=commandName, event=event)

        return masterStaticMenuCallback
#@+node:ekr.20111102072143.10016: *11* LeoMenu.createMasterMenuCallback
def createMasterMenuCallback(self, command, commandName):
    """
    Create a callback for the given args.
    
    - If command is a string, it is treated as a command name.
    - Otherwise, it should be a callable representing the actual command.
    """
    c = self.c

    def getWidget():
        """Carefully return the widget that has focus."""
        w = c.frame.getFocus()
        if w and g.isMac:
            # Redirect (MacOS only).
            wname = c.widget_name(w)
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        # Return a wrapper if possible.
        if not g.isTextWrapper(w):
            w = getattr(w, 'wrapper', w)
        return w

    if isinstance(command, str):
        
        def static_menu_callback():
            event = g.app.gui.create_key_event(c, w=getWidget())
            c.doCommandByName(commandName, event)

        return static_menu_callback
        
    # The command must be a callable.
    if not callable(command):

        def dummy_menu_callback(event=None):
            pass
    
        g.trace(f"bad command: {command!r}", color='red')
        return dummy_menu_callback

    # Create a command dynamically.

    def dynamic_menu_callback():
        event = g.app.gui.create_key_event(c, w=getWidget())
        return c.doCommand(command, commandName, event)  # #1595

    return dynamic_menu_callback
#@+node:ekr.20200725105324.106: *10* LeoMenu.getMenuEntryBindings
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,4 +1,4 @@
-def getMenuEntryBindings(self, command, dynamicMenu, label):
+def getMenuEntryBindings(self, command, label):
     """Compute commandName from command."""
     c = self.c
     if isinstance(command, str):
@@ -6,6 +6,7 @@
         commandName = command
     else:
         # First, get the old-style name.
-        commandName = self.computeOldStyleShortcutKey(label)
+        # #1121: Allow Chinese characters in command names
+        commandName = label.strip()
     command = c.commandsDict.get(commandName)
     return commandName
@language python
#@+node:ekr.20200725105324.107: *11* Old:LeoMenu.getMenuEntryBindings
def getMenuEntryBindings(self, command, dynamicMenu, label):
    """Compute commandName from command."""
    c = self.c
    if isinstance(command, str):
        # Command is really a command name.
        commandName = command
    else:
        # First, get the old-style name.
        commandName = self.computeOldStyleShortcutKey(label)
    command = c.commandsDict.get(commandName)
    return commandName
#@+node:ekr.20111028060955.16568: *11* LeoMenu.getMenuEntryBindings
def getMenuEntryBindings(self, command, label):
    """Compute commandName from command."""
    c = self.c
    if isinstance(command, str):
        # Command is really a command name.
        commandName = command
    else:
        # First, get the old-style name.
        # #1121: Allow Chinese characters in command names
        commandName = label.strip()
    command = c.commandsDict.get(commandName)
    return commandName
#@+node:ekr.20200725105325.1: *10* LeoMenu.getMenuEntryInfo
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,4 +1,15 @@
 def getMenuEntryInfo(self, data, menu):
+    """
+    Parse a single entry in the table passed to createMenuEntries.
+    
+    Table entries have the following formats:
+        
+    1. A string, used as the command name.
+    2. A 2-tuple: (command_name, command_func)
+    3. A 3-tuple: (command_name, menu_shortcut, command_func)
+    
+    Special case: If command_name is None or "-" it represents a menu separator.
+    """
     done = False
     if isinstance(data, str):
         # A single string is both the label and the command.
@language python
#@+node:ekr.20200725105325.2: *11* Old:LeoMenu.getMenuEntryInfo
def getMenuEntryInfo(self, data, menu):
    done = False
    if isinstance(data, str):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0] == '*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s, removeHyphens)
        command = s.replace('&', '').lower()
        if label == '-':
            self.add_separator(menu)
            done = True  # That's all.
    else:
        ok = isinstance(data, (list, tuple)) and len(data) in (2, 3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label, command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label, junk, command = data
            if label in (None, '-'):
                self.add_separator(menu)
                done = True  # That's all.
        else:
            g.trace(f"bad data in menu table: {repr(data)}")
            done = True  # Ignore bad data
    return label, command, done
#@+node:ekr.20111028060955.16565: *11* LeoMenu.getMenuEntryInfo
def getMenuEntryInfo(self, data, menu):
    """
    Parse a single entry in the table passed to createMenuEntries.
    
    Table entries have the following formats:
        
    1. A string, used as the command name.
    2. A 2-tuple: (command_name, command_func)
    3. A 3-tuple: (command_name, menu_shortcut, command_func)
    
    Special case: If command_name is None or "-" it represents a menu separator.
    """
    done = False
    if isinstance(data, str):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0] == '*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s, removeHyphens)
        command = s.replace('&', '').lower()
        if label == '-':
            self.add_separator(menu)
            done = True  # That's all.
    else:
        ok = isinstance(data, (list, tuple)) and len(data) in (2, 3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label, command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label, junk, command = data
            if label in (None, '-'):
                self.add_separator(menu)
                done = True  # That's all.
        else:
            g.trace(f"bad data in menu table: {repr(data)}")
            done = True  # Ignore bad data
    return label, command, done
#@+node:ekr.20200725105325.3: *10* LeoMenu.createMenuItemsFromTable
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -1,4 +1,4 @@
-def createMenuItemsFromTable(self, menuName, table, dynamicMenu=False):
+def createMenuItemsFromTable(self, menuName, table):
 
     if g.app.gui.isNullGui:
         return
@@ -6,7 +6,7 @@
         menu = self.getMenu(menuName)
         if menu is None:
             return
-        self.createMenuEntries(menu, table, dynamicMenu=dynamicMenu)
+        self.createMenuEntries(menu, table)
     except Exception:
         g.es_print("exception creating items for", menuName, "menu")
         g.es_exception()
@language python
#@+node:ekr.20200725105325.4: *11* Old:LeoMenu.createMenuItemsFromTable
def createMenuItemsFromTable(self, menuName, table, dynamicMenu=False):

    if g.app.gui.isNullGui:
        return
    try:
        menu = self.getMenu(menuName)
        if menu is None:
            return
        self.createMenuEntries(menu, table, dynamicMenu=dynamicMenu)
    except Exception:
        g.es_print("exception creating items for", menuName, "menu")
        g.es_exception()
    g.app.menuWarningsGiven = True
#@+node:ekr.20031218072017.3784: *11* LeoMenu.createMenuItemsFromTable
def createMenuItemsFromTable(self, menuName, table):

    if g.app.gui.isNullGui:
        return
    try:
        menu = self.getMenu(menuName)
        if menu is None:
            return
        self.createMenuEntries(menu, table)
    except Exception:
        g.es_print("exception creating items for", menuName, "menu")
        g.es_exception()
    g.app.menuWarningsGiven = True
#@+node:ekr.20200725105325.5: *10* LeoMenu.9 Routines with Tk spellings
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -6,6 +6,7 @@
 
 def add_separator(self, menu):
     self.oops()
+
 # def bind (self,bind_shortcut,callback):
 #     self.oops()
 
@language python
#@+node:ekr.20200725105325.6: *11* Old:LeoMenu.9 Routines with Tk spellings
def add_cascade(self, parent, label, menu, underline):
    self.oops()

def add_command(self, menu, **keys):
    self.oops()

def add_separator(self, menu):
    self.oops()
# def bind (self,bind_shortcut,callback):
#     self.oops()

def delete(self, menu, realItemName):
    self.oops()

def delete_range(self, menu, n1, n2):
    self.oops()

def destroy(self, menu):
    self.oops()

def insert(
    self, menuName, position, label, command, underline=None):  # New in Leo 4.4.3 a1
    self.oops()

def insert_cascade(self, parent, index, label, menu, underline):
    self.oops()

def new_menu(self, parent, tearoff=0, label=''):
    # 2010: added label arg for pylint.
    self.oops()
#@+node:ekr.20031218072017.3809: *11* LeoMenu.9 Routines with Tk spellings
def add_cascade(self, parent, label, menu, underline):
    self.oops()

def add_command(self, menu, **keys):
    self.oops()

def add_separator(self, menu):
    self.oops()

# def bind (self,bind_shortcut,callback):
#     self.oops()

def delete(self, menu, realItemName):
    self.oops()

def delete_range(self, menu, n1, n2):
    self.oops()

def destroy(self, menu):
    self.oops()

def insert(
    self, menuName, position, label, command, underline=None):  # New in Leo 4.4.3 a1
    self.oops()

def insert_cascade(self, parent, index, label, menu, underline):
    self.oops()

def new_menu(self, parent, tearoff=0, label=''):
    # 2010: added label arg for pylint.
    self.oops()
#@+node:ekr.20200725105328.3: *8* leo/core/leoVim.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -555,7 +555,7 @@
         self.quit()
         self.show_status()
         # This seems not to be needed.
-            # self.c.k.keyboardQuit(setFocus=True)
+            # self.c.k.keyboardQuit()
#@verbatim
     #@+node:ekr.20140802120757.17999: *5* vc.quit
     def quit(self):
         """
@@ -1737,9 +1737,9 @@
#@verbatim
     #@@nobeautify
#@verbatim
     #@@nocolor-node
#@verbatim
     #@+at
-    # 
+    #
     # First:
-    # 
+    #
     #     0               (motion) to first character in the line (also: <Home> key)
     # N   $               (motion) go to the last character in the line (N-1 lines lower) (also: <End> key)
     #     ^               (motion) go to first non-blank character in the line
@@ -1749,17 +1749,17 @@
     # N   /{pattern}[/[offset]]<CR>   (motion) search forward for the Nth occurrence of {pattern}
     # N   ?<CR>                       (motion) repeat last search, in the backward direction
     # N   ?{pattern}[?[offset]]<CR>   (motion) search backward for the Nth occurrence of {pattern}
-    # 
+    #
     # Later or never:
-    # 
+    #
     # N   CTRL-I          (motion) go to Nth newer position in jump list
     # N   CTRL-O          (motion) go to Nth older position in jump list
     # N   CTRL-T          (motion) Jump back from Nth older tag in tag list
-    # 
+    #
     # N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and <CR>)
     # N   _               (motion) down N-1 lines, on the first non-blank character
     # N   -               (motion) up N lines, on the first non-blank character
-    # 
+    #
     # N   (               (motion) N sentences backward
     # N   )               (motion) N sentences forward
     # N   {               (motion) N paragraphs backward
@@ -1775,15 +1775,15 @@
     #     `[              (motion) go to the start of the previously operated or put text
     #     `]              (motion) go to the end of the previously operated or put text
     #     ``              (motion) go to the position before the last jump
-    # 
+    #
     # N   %       (motion) goto line N percentage down in the file.
     #             N must be given, otherwise it is the % command.
     #     %       (motion) find the next brace, bracket, comment,
     #             or "#if"/ "#else"/"#endif" in this line and go to its match
-    # 
+    #
     # N   #       (motion) search backward for the identifier under the cursor
     # N   *       (motion) search forward for the identifier under the cursor
-    # 
+    #
     # N   [#      (motion) N times back to unclosed "#if" or "#else"
     # N   [(      (motion) N times back to unclosed '('
     # N   [*      (motion) N times back to start of comment "/*"
@language python
#@+node:ekr.20200725105328.10: *9* Changed
#@+node:ekr.20200725105328.11: *10* vc.on_activate
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -4,4 +4,4 @@
     self.quit()
     self.show_status()
     # This seems not to be needed.
-        # self.c.k.keyboardQuit(setFocus=True)
+        # self.c.k.keyboardQuit()
@language python
#@+node:ekr.20200725105328.12: *11* Old:vc.on_activate
def on_activate(self):
    """Handle an activate event."""
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    self.quit()
    self.show_status()
    # This seems not to be needed.
        # self.c.k.keyboardQuit(setFocus=True)
#@+node:ekr.20160918060654.1: *11* vc.on_activate
def on_activate(self):
    """Handle an activate event."""
    # Fix #270: Vim keys don't always work after double Alt+Tab.
    self.quit()
    self.show_status()
    # This seems not to be needed.
        # self.c.k.keyboardQuit()
#@+node:ekr.20200725105315.23: *8* leo/commands/editCommands.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -66,11 +66,11 @@
     w = c.frame.body.wrapper
     ins = w.getInsertPoint()
     c.inCommand = False
-    c.executeMinibufferCommand(prefix1 + 'line' + suffix)
+    c.k.simulateCommand(prefix1 + 'line' + suffix)
     ins2 = w.getInsertPoint()
     # If the cursor didn't change, then go to beginning/end of line
     if ins == ins2:
-        c.executeMinibufferCommand(prefix2 + 'of-line' + suffix)
+        c.k.simulateCommand(prefix2 + 'of-line' + suffix)
#@verbatim
 #@+node:ekr.20180504180134.1: ** @g.command('delete-trace-statements')
 @g.command('delete-trace-statements')
 def delete_trace_statements(event=None):
@@ -124,21 +124,18 @@
 @g.command('next-or-end-of-line')
 def nextOrEndOfLine(event):
     lineScrollHelper(event['c'], 'next-', 'end-', '')
-
#@verbatim
 #@+node:ekr.20190926103246.2: ** @g.command('next-or-end-of-line-extend-selection')
 # by Brian Theado.
 
 @g.command('next-or-end-of-line-extend-selection')
 def nextOrEndOfLineExtendSelection(event):
     lineScrollHelper(event['c'], 'next-', 'end-', '-extend-selection')
-
#@verbatim
 #@+node:ekr.20190926103246.1: ** @g.command('previous-or-beginning-of-line')
 # by Brian Theado.
 
 @g.command('previous-or-beginning-of-line')
 def previousOrBeginningOfLine(event):
     lineScrollHelper(event['c'], 'previous-', 'beginning-', '')
-
#@verbatim
 #@+node:ekr.20190926103246.3: ** @g.command('previous-or-beginning-of-line-extend-selection')
 # by Brian Theado.
 
@@ -673,7 +670,6 @@
             # Bug fix: 2011/05/23: set the fillColumn ivar!
             self.fillColumn = n = int(k.arg)
             k.setLabelGrey(f"fill column is: {n:d}")
-            k.commandName = f"set-fill-column {n:d}"
         except ValueError:
             k.resetLabel()
         c.widgetWantsFocus(w)
@@ -970,6 +966,8 @@
             # no difference between original and current list of dictionaries
             return
         self._setIconListHelper(p, l, p.v, setDirty)
+        if g.app.gui.guiName() == 'qt':
+            self.c.frame.tree.updateIcon(p, True)
#@verbatim
     #@+node:ekr.20150514063305.235: *6* ec._setIconListHelper
     def _setIconListHelper(self, p, subl, uaLoc, setDirty):
         """icon setting code common between v and t nodes
@@ -1306,7 +1304,7 @@
                 w.delete(ins - 1)
                 ins = ins - 1
                 w.setSelectionRange(ins, ins, insert=ins)
-    #@+node:ekr.20150514063305.255: *4* ec.cleanAllLines (changed)
+    #@+node:ekr.20150514063305.255: *4* ec.cleanAllLines
     @cmd('clean-all-lines')
     def cleanAllLines(self, event):
         """Clean all lines in the selected tree."""
@@ -1389,6 +1387,7 @@
     def backwardDeleteWord(self, event=None):
         """Delete the word in front of the cursor."""
         self.deleteWordHelper(event, forward=False)
+
     # Patch by NH2.
 
     @cmd('delete-word-smart')
@@ -1911,7 +1910,6 @@
         k.clearState()
         k.resetLabel()
         self.linesHelper(event, k.arg, 'flush')
-        k.commandName = f"flush-lines {k.arg}"
#@verbatim
     #@+node:ekr.20150514063305.282: *4* ec.keepLines (doesn't work)
     @cmd('keep-lines')
     def keepLines(self, event):
@@ -1931,7 +1929,6 @@
         k.clearState()
         k.resetLabel()
         self.linesHelper(event, k.arg, 'keep')
-        k.commandName = f"keep-lines {k.arg}"
#@verbatim
     #@+node:ekr.20150514063305.283: *4* ec.linesHelper
     def linesHelper(self, event, pattern, which):
         w = self.editWidget(event)
@@ -2137,7 +2134,6 @@
         def seek_special_start(i):
             return seek_until_changed(i, is_special, -1)
#@verbatim
         #@-others
-
         if smart:
             if forward:
                 if 0 <= i < n:
@@ -2252,7 +2248,6 @@
         """Extend the selection by moving the cursor to the beginning of the current
         or the end of the previous word."""
         self.moveWordHelper(event, extend=True, forward=False, smart=True)
-
#@verbatim
     #@+node:ekr.20170707072347.1: *4* ec.beginningOfLine/ExtendSelection
     @cmd('beginning-of-line')
     def beginningOfLine(self, event):
@@ -3596,7 +3591,7 @@
 
     swapCharacters = transposeCharacters
#@verbatim
     #@+node:ekr.20150514063305.348: *3* ec: uA's
-    #@+node:ekr.20150514063305.349: *4* ec.clearNodeUas & clearAllUas (changed)
+    #@+node:ekr.20150514063305.349: *4* ec.clearNodeUas & clearAllUas
     @cmd('clear-node-uas')
     def clearNodeUas(self, event=None):
         """Clear the uA's in the selected VNode."""
@language python
#@+node:ekr.20200725105315.388: *9* Changed
#@+node:ekr.20200725105315.389: *10* lineScrollHelper
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -4,9 +4,9 @@
     w = c.frame.body.wrapper
     ins = w.getInsertPoint()
     c.inCommand = False
-    c.executeMinibufferCommand(prefix1 + 'line' + suffix)
+    c.k.simulateCommand(prefix1 + 'line' + suffix)
     ins2 = w.getInsertPoint()
     # If the cursor didn't change, then go to beginning/end of line
     if ins == ins2:
-        c.executeMinibufferCommand(prefix2 + 'of-line' + suffix)
+        c.k.simulateCommand(prefix2 + 'of-line' + suffix)
#@verbatim
 #@+node:ekr.20180504180134.1: ** @g.command('delete-trace-statements')
@language python
#@+node:ekr.20200725105315.390: *11* Old:lineScrollHelper
# by Brian Theado.

def lineScrollHelper(c, prefix1, prefix2, suffix):
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    c.inCommand = False
    c.executeMinibufferCommand(prefix1 + 'line' + suffix)
    ins2 = w.getInsertPoint()
    # If the cursor didn't change, then go to beginning/end of line
    if ins == ins2:
        c.executeMinibufferCommand(prefix2 + 'of-line' + suffix)
#@verbatim
#@+node:ekr.20180504180134.1: ** @g.command('delete-trace-statements')
#@+node:ekr.20190926103141.1: *11* lineScrollHelper
# by Brian Theado.

def lineScrollHelper(c, prefix1, prefix2, suffix):
    w = c.frame.body.wrapper
    ins = w.getInsertPoint()
    c.inCommand = False
    c.k.simulateCommand(prefix1 + 'line' + suffix)
    ins2 = w.getInsertPoint()
    # If the cursor didn't change, then go to beginning/end of line
    if ins == ins2:
        c.k.simulateCommand(prefix2 + 'of-line' + suffix)
#@+node:ekr.20200725105315.391: *10* @g.command('next-or-end-of-line')
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -3,5 +3,4 @@
 @g.command('next-or-end-of-line')
 def nextOrEndOfLine(event):
     lineScrollHelper(event['c'], 'next-', 'end-', '')
-
#@verbatim
 #@+node:ekr.20190926103246.2: ** @g.command('next-or-end-of-line-extend-selection')
@language python
#@+node:ekr.20200725105315.392: *11* Old:@g.command('next-or-end-of-line')
# by Brian Theado.

@g.command('next-or-end-of-line')
def nextOrEndOfLine(event):
    lineScrollHelper(event['c'], 'next-', 'end-', '')

#@verbatim
#@+node:ekr.20190926103246.2: ** @g.command('next-or-end-of-line-extend-selection')
#@+node:ekr.20190926103245.1: *11* @g.command('next-or-end-of-line')
# by Brian Theado.

@g.command('next-or-end-of-line')
def nextOrEndOfLine(event):
    lineScrollHelper(event['c'], 'next-', 'end-', '')
#@+node:ekr.20200725105315.393: *10* @g.command('next-or-end-of-line-extend-selection')
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -3,5 +3,4 @@
 @g.command('next-or-end-of-line-extend-selection')
 def nextOrEndOfLineExtendSelection(event):
     lineScrollHelper(event['c'], 'next-', 'end-', '-extend-selection')
-
#@verbatim
 #@+node:ekr.20190926103246.1: ** @g.command('previous-or-beginning-of-line')
@language python
#@+node:ekr.20200725105315.394: *11* Old:@g.command('next-or-end-of-line-extend-selection')
# by Brian Theado.

@g.command('next-or-end-of-line-extend-selection')
def nextOrEndOfLineExtendSelection(event):
    lineScrollHelper(event['c'], 'next-', 'end-', '-extend-selection')

#@verbatim
#@+node:ekr.20190926103246.1: ** @g.command('previous-or-beginning-of-line')
#@+node:ekr.20190926103246.2: *11* @g.command('next-or-end-of-line-extend-selection')
# by Brian Theado.

@g.command('next-or-end-of-line-extend-selection')
def nextOrEndOfLineExtendSelection(event):
    lineScrollHelper(event['c'], 'next-', 'end-', '-extend-selection')
#@+node:ekr.20200725105315.395: *10* @g.command('previous-or-beginning-of-line')
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -3,5 +3,4 @@
 @g.command('previous-or-beginning-of-line')
 def previousOrBeginningOfLine(event):
     lineScrollHelper(event['c'], 'previous-', 'beginning-', '')
-
#@verbatim
 #@+node:ekr.20190926103246.3: ** @g.command('previous-or-beginning-of-line-extend-selection')
@language python
#@+node:ekr.20200725105315.396: *11* Old:@g.command('previous-or-beginning-of-line')
# by Brian Theado.

@g.command('previous-or-beginning-of-line')
def previousOrBeginningOfLine(event):
    lineScrollHelper(event['c'], 'previous-', 'beginning-', '')

#@verbatim
#@+node:ekr.20190926103246.3: ** @g.command('previous-or-beginning-of-line-extend-selection')
#@+node:ekr.20190926103246.1: *11* @g.command('previous-or-beginning-of-line')
# by Brian Theado.

@g.command('previous-or-beginning-of-line')
def previousOrBeginningOfLine(event):
    lineScrollHelper(event['c'], 'previous-', 'beginning-', '')
#@+node:ekr.20200725105315.397: *10* ec.setFillColumn
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -14,7 +14,6 @@
         # Bug fix: 2011/05/23: set the fillColumn ivar!
         self.fillColumn = n = int(k.arg)
         k.setLabelGrey(f"fill column is: {n:d}")
-        k.commandName = f"set-fill-column {n:d}"
     except ValueError:
         k.resetLabel()
     c.widgetWantsFocus(w)
@language python
#@+node:ekr.20200725105315.398: *11* Old:ec.setFillColumn
@cmd('set-fill-column')
def setFillColumn(self, event):
    """Set the fill column used by the center-line and center-region commands."""
    k = self.c.k
    self.w = self.editWidget(event)
    if self.w:
        k.setLabelBlue('Set Fill Column: ')
        k.get1Arg(event, handler=self.setFillColumn1)

def setFillColumn1(self, event):
    c, k, w = self.c, self.c.k, self.w
    k.clearState()
    try:
        # Bug fix: 2011/05/23: set the fillColumn ivar!
        self.fillColumn = n = int(k.arg)
        k.setLabelGrey(f"fill column is: {n:d}")
        k.commandName = f"set-fill-column {n:d}"
    except ValueError:
        k.resetLabel()
    c.widgetWantsFocus(w)
#@verbatim
    #@+node:ekr.20150514063305.217: *4* ec.centerRegion
#@+node:ekr.20150514063305.216: *11* ec.setFillColumn
@cmd('set-fill-column')
def setFillColumn(self, event):
    """Set the fill column used by the center-line and center-region commands."""
    k = self.c.k
    self.w = self.editWidget(event)
    if self.w:
        k.setLabelBlue('Set Fill Column: ')
        k.get1Arg(event, handler=self.setFillColumn1)

def setFillColumn1(self, event):
    c, k, w = self.c, self.c.k, self.w
    k.clearState()
    try:
        # Bug fix: 2011/05/23: set the fillColumn ivar!
        self.fillColumn = n = int(k.arg)
        k.setLabelGrey(f"fill column is: {n:d}")
    except ValueError:
        k.resetLabel()
    c.widgetWantsFocus(w)
#@+node:ekr.20200725105315.399: *10* ec.setIconList & helpers
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -8,4 +8,6 @@
         # no difference between original and current list of dictionaries
         return
     self._setIconListHelper(p, l, p.v, setDirty)
+    if g.app.gui.guiName() == 'qt':
+        self.c.frame.tree.updateIcon(p, True)
#@verbatim
     #@+node:ekr.20150514063305.235: *6* ec._setIconListHelper
@language python
#@+node:ekr.20200725105315.400: *11* Old:ec.setIconList & helpers
def setIconList(self, p, l, setDirty=True):
    """Set list of icons for position p to l"""
    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return
    self._setIconListHelper(p, l, p.v, setDirty)
#@verbatim
    #@+node:ekr.20150514063305.235: *6* ec._setIconListHelper
#@+node:ekr.20150514063305.234: *11* ec.setIconList & helpers
def setIconList(self, p, l, setDirty=True):
    """Set list of icons for position p to l"""
    current = self.getIconList(p)
    if not l and not current: return  # nothing to do
    lHash = ''.join([self.dHash(i) for i in l])
    cHash = ''.join([self.dHash(i) for i in current])
    if lHash == cHash:
        # no difference between original and current list of dictionaries
        return
    self._setIconListHelper(p, l, p.v, setDirty)
    if g.app.gui.guiName() == 'qt':
        self.c.frame.tree.updateIcon(p, True)
#@+node:ekr.20150514063305.235: *12* ec._setIconListHelper
def _setIconListHelper(self, p, subl, uaLoc, setDirty):
    """icon setting code common between v and t nodes

    p - postion
    subl - list of icons for the v or t node
    uaLoc - the v or t node
    """
    if subl:  # Update the uA.
        if not hasattr(uaLoc, 'unknownAttributes'):
            uaLoc.unknownAttributes = {}
        uaLoc.unknownAttributes['icons'] = list(subl)
        # g.es((p.h,uaLoc.unknownAttributes['icons']))
        uaLoc._p_changed = 1
        if setDirty:
            p.setDirty()
    else:  # delete the uA.
        if hasattr(uaLoc, 'unknownAttributes'):
            if 'icons' in uaLoc.unknownAttributes:
                del uaLoc.unknownAttributes['icons']
                uaLoc._p_changed = 1
                if setDirty:
                    p.setDirty()
#@+node:ekr.20200725105315.401: *10* ec.backwardDeleteCharacter
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -41,4 +41,4 @@
             w.delete(ins - 1)
             ins = ins - 1
             w.setSelectionRange(ins, ins, insert=ins)
-    #@+node:ekr.20150514063305.255: *4* ec.cleanAllLines (changed)
+    #@+node:ekr.20150514063305.255: *4* ec.cleanAllLines
@language python
#@+node:ekr.20200725105315.402: *11* Old:ec.backwardDeleteCharacter
@cmd('backward-delete-char')
def backwardDeleteCharacter(self, event=None):
    """Delete the character to the left of the cursor."""
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if wname.startswith('body'):
        self.beginCommand(w)
        try:
            tab_width = c.getTabWidth(c.p)
            changed = True
            if i != j:
                w.delete(i, j)
                w.setSelectionRange(i, i, insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins - 1)
                w.setSelectionRange(ins - 1, ins - 1, insert=ins - 1)
            else:
#@verbatim
                    #@+<< backspace with negative tab_width >>
#@verbatim
                    #@+node:ekr.20150514063305.254: *5* << backspace with negative tab_width >>
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=changed, setLabel=False)
                # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i, min(j, len(s)))
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins - 1)
            ins = ins - 1
            w.setSelectionRange(ins, ins, insert=ins)
#@verbatim
    #@+node:ekr.20150514063305.255: *4* ec.cleanAllLines (changed)
#@+node:ekr.20150514063305.253: *11* ec.backwardDeleteCharacter
@cmd('backward-delete-char')
def backwardDeleteCharacter(self, event=None):
    """Delete the character to the left of the cursor."""
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    wname = c.widget_name(w)
    ins = w.getInsertPoint()
    i, j = w.getSelectionRange()
    if wname.startswith('body'):
        self.beginCommand(w)
        try:
            tab_width = c.getTabWidth(c.p)
            changed = True
            if i != j:
                w.delete(i, j)
                w.setSelectionRange(i, i, insert=i)
            elif i == 0:
                changed = False
            elif tab_width > 0:
                w.delete(ins - 1)
                w.setSelectionRange(ins - 1, ins - 1, insert=ins - 1)
            else:
                << backspace with negative tab_width >>
        finally:
            self.endCommand(changed=changed, setLabel=False)
                # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        # Make sure we actually delete something if we can.
        s = w.getAllText()
        if i != j:
            j = max(i, min(j, len(s)))
            w.delete(i, j)
            w.setSelectionRange(i, i, insert=i)
        elif ins != 0:
            # Do nothing at the start of the headline.
            w.delete(ins - 1)
            ins = ins - 1
            w.setSelectionRange(ins, ins, insert=ins)
#@+node:ekr.20150514063305.254: *12* << backspace with negative tab_width >>
s = prev = w.getAllText()
ins = w.getInsertPoint()
i, j = g.getLine(s, ins)
s = prev = s[i:ins]
n = len(prev)
abs_width = abs(tab_width)
# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n, n2)
count = 0
while n2 > 0:
    n2 -= 1
    ch = prev[n - count - 1]
    if ch != ' ': break
    else: count += 1
# Make sure we actually delete something.
i = ins - (max(1, count))
w.delete(i, ins)
w.setSelectionRange(i, i, insert=i)
#@+node:ekr.20200725105315.403: *10* ec.delete-word & backward-delete-word
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -7,6 +7,7 @@
 def backwardDeleteWord(self, event=None):
     """Delete the word in front of the cursor."""
     self.deleteWordHelper(event, forward=False)
+
 # Patch by NH2.
 
 @cmd('delete-word-smart')
@language python
#@+node:ekr.20200725105315.404: *11* Old:ec.delete-word & backward-delete-word
@cmd('delete-word')
def deleteWord(self, event=None):
    """Delete the word at the cursor."""
    self.deleteWordHelper(event, forward=True)

@cmd('backward-delete-word')
def backwardDeleteWord(self, event=None):
    """Delete the word in front of the cursor."""
    self.deleteWordHelper(event, forward=False)
# Patch by NH2.

@cmd('delete-word-smart')
def deleteWordSmart(self, event=None):
    """Delete the word at the cursor, treating whitespace
    and symbols smartly."""
    self.deleteWordHelper(event, forward=True, smart=True)

@cmd('backward-delete-word-smart')
def backwardDeleteWordSmart(self, event=None):
    """Delete the word in front of the cursor, treating whitespace
    and symbols smartly."""
    self.deleteWordHelper(event, forward=False, smart=True)

def deleteWordHelper(self, event, forward, smart=False):
    # c = self.c
    w = self.editWidget(event)
    if not w:
        return
    self.beginCommand(w, undoType="delete-word")
    if w.hasSelection():
        from_pos, to_pos = w.getSelectionRange()
    else:
        from_pos = w.getInsertPoint()
        self.moveWordHelper(event, extend=False, forward=forward, smart=smart)
        to_pos = w.getInsertPoint()
    # For Tk GUI, make sure to_pos > from_pos
    if from_pos > to_pos:
        from_pos, to_pos = to_pos, from_pos
    w.delete(from_pos, to_pos)
    self.endCommand(changed=True, setLabel=True)
#@verbatim
    #@+node:ekr.20150514063305.259: *4* ec.deleteNextChar
#@+node:ekr.20150514063305.258: *11* ec.delete-word & backward-delete-word
@cmd('delete-word')
def deleteWord(self, event=None):
    """Delete the word at the cursor."""
    self.deleteWordHelper(event, forward=True)

@cmd('backward-delete-word')
def backwardDeleteWord(self, event=None):
    """Delete the word in front of the cursor."""
    self.deleteWordHelper(event, forward=False)

# Patch by NH2.

@cmd('delete-word-smart')
def deleteWordSmart(self, event=None):
    """Delete the word at the cursor, treating whitespace
    and symbols smartly."""
    self.deleteWordHelper(event, forward=True, smart=True)

@cmd('backward-delete-word-smart')
def backwardDeleteWordSmart(self, event=None):
    """Delete the word in front of the cursor, treating whitespace
    and symbols smartly."""
    self.deleteWordHelper(event, forward=False, smart=True)

def deleteWordHelper(self, event, forward, smart=False):
    # c = self.c
    w = self.editWidget(event)
    if not w:
        return
    self.beginCommand(w, undoType="delete-word")
    if w.hasSelection():
        from_pos, to_pos = w.getSelectionRange()
    else:
        from_pos = w.getInsertPoint()
        self.moveWordHelper(event, extend=False, forward=forward, smart=smart)
        to_pos = w.getInsertPoint()
    # For Tk GUI, make sure to_pos > from_pos
    if from_pos > to_pos:
        from_pos, to_pos = to_pos, from_pos
    w.delete(from_pos, to_pos)
    self.endCommand(changed=True, setLabel=True)
#@+node:ekr.20200725105315.405: *10* ec.flushLines (doesn't work)
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -16,5 +16,4 @@
     k.clearState()
     k.resetLabel()
     self.linesHelper(event, k.arg, 'flush')
-    k.commandName = f"flush-lines {k.arg}"
#@verbatim
     #@+node:ekr.20150514063305.282: *4* ec.keepLines (doesn't work)
@language python
#@+node:ekr.20200725105315.406: *11* Old:ec.flushLines (doesn't work)
@cmd('flush-lines')
def flushLines(self, event):
    """
    Delete each line that contains a match for regexp, operating on the
    text after point.

    In Transient Mark mode, if the region is active, the command operates
    on the region instead.
    """
    k = self.c.k
    k.setLabelBlue('Flush lines regexp: ')
    k.get1Arg(event, handler=self.flushLines1)

def flushLines1(self, event):
    k = self.c.k
    k.clearState()
    k.resetLabel()
    self.linesHelper(event, k.arg, 'flush')
    k.commandName = f"flush-lines {k.arg}"
#@verbatim
    #@+node:ekr.20150514063305.282: *4* ec.keepLines (doesn't work)
#@+node:ekr.20150514063305.281: *11* ec.flushLines (doesn't work)
@cmd('flush-lines')
def flushLines(self, event):
    """
    Delete each line that contains a match for regexp, operating on the
    text after point.

    In Transient Mark mode, if the region is active, the command operates
    on the region instead.
    """
    k = self.c.k
    k.setLabelBlue('Flush lines regexp: ')
    k.get1Arg(event, handler=self.flushLines1)

def flushLines1(self, event):
    k = self.c.k
    k.clearState()
    k.resetLabel()
    self.linesHelper(event, k.arg, 'flush')
#@+node:ekr.20200725105315.407: *10* ec.keepLines (doesn't work)
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -16,5 +16,4 @@
     k.clearState()
     k.resetLabel()
     self.linesHelper(event, k.arg, 'keep')
-    k.commandName = f"keep-lines {k.arg}"
#@verbatim
     #@+node:ekr.20150514063305.283: *4* ec.linesHelper
@language python
#@+node:ekr.20200725105315.408: *11* Old:ec.keepLines (doesn't work)
@cmd('keep-lines')
def keepLines(self, event):
    """
    Delete each line that does not contain a match for regexp, operating on
    the text after point.

    In Transient Mark mode, if the region is active, the command operates
    on the region instead.
    """
    k = self.c.k
    k.setLabelBlue('Keep lines regexp: ')
    k.get1Arg(event, handler=self.keepLines1)

def keepLines1(self, event):
    k = self.c.k
    k.clearState()
    k.resetLabel()
    self.linesHelper(event, k.arg, 'keep')
    k.commandName = f"keep-lines {k.arg}"
#@verbatim
    #@+node:ekr.20150514063305.283: *4* ec.linesHelper
#@+node:ekr.20150514063305.282: *11* ec.keepLines (doesn't work)
@cmd('keep-lines')
def keepLines(self, event):
    """
    Delete each line that does not contain a match for regexp, operating on
    the text after point.

    In Transient Mark mode, if the region is active, the command operates
    on the region instead.
    """
    k = self.c.k
    k.setLabelBlue('Keep lines regexp: ')
    k.get1Arg(event, handler=self.keepLines1)

def keepLines1(self, event):
    k = self.c.k
    k.clearState()
    k.resetLabel()
    self.linesHelper(event, k.arg, 'keep')
#@+node:ekr.20200725105315.409: *10* ec.moveWordHelper functions
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -36,4 +36,3 @@
 def seek_special_start(i):
     return seek_until_changed(i, is_special, -1)
#@verbatim
         #@-others
-
@language python
#@+node:ekr.20200725105315.410: *11* Old:ec.moveWordHelper functions
def is_alphanumeric(c):
    return alphanumeric_re.match(c) is not None

def is_whitespace(c):
    return whitespace_re.match(c) is not None

def is_simple_whitespace(c):
    return simple_whitespace_re.match(c) is not None

def is_line_break(c):
    return is_whitespace(c) and not is_simple_whitespace(c)

def is_special(c):
    return not is_alphanumeric(c) and not is_whitespace(c)

def seek_until_changed(i, match_function, step):
    while 0 <= i < n and match_function(s[i]):
        i += step
    return i

def seek_word_end(i):
    return seek_until_changed(i, is_alphanumeric, 1)

def seek_word_start(i):
    return seek_until_changed(i, is_alphanumeric, -1)

def seek_simple_whitespace_end(i):
    return seek_until_changed(i, is_simple_whitespace, 1)

def seek_simple_whitespace_start(i):
    return seek_until_changed(i, is_simple_whitespace, -1)

def seek_special_end(i):
    return seek_until_changed(i, is_special, 1)

def seek_special_start(i):
    return seek_until_changed(i, is_special, -1)
#@verbatim
        #@-others

#@+node:ekr.20150514063305.318: *11* ec.moveWordHelper functions
def is_alphanumeric(c):
    return alphanumeric_re.match(c) is not None

def is_whitespace(c):
    return whitespace_re.match(c) is not None

def is_simple_whitespace(c):
    return simple_whitespace_re.match(c) is not None

def is_line_break(c):
    return is_whitespace(c) and not is_simple_whitespace(c)

def is_special(c):
    return not is_alphanumeric(c) and not is_whitespace(c)

def seek_until_changed(i, match_function, step):
    while 0 <= i < n and match_function(s[i]):
        i += step
    return i

def seek_word_end(i):
    return seek_until_changed(i, is_alphanumeric, 1)

def seek_word_start(i):
    return seek_until_changed(i, is_alphanumeric, -1)

def seek_simple_whitespace_end(i):
    return seek_until_changed(i, is_simple_whitespace, 1)

def seek_simple_whitespace_start(i):
    return seek_until_changed(i, is_simple_whitespace, -1)

def seek_special_end(i):
    return seek_until_changed(i, is_special, 1)

def seek_special_start(i):
    return seek_until_changed(i, is_special, -1)
#@+node:ekr.20200725105315.411: *10* ec.backward*/ExtendSelection
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -18,5 +18,4 @@
     """Extend the selection by moving the cursor to the beginning of the current
     or the end of the previous word."""
     self.moveWordHelper(event, extend=True, forward=False, smart=True)
-
#@verbatim
     #@+node:ekr.20170707072347.1: *4* ec.beginningOfLine/ExtendSelection
@language python
#@+node:ekr.20200725105315.412: *11* Old:ec.backward*/ExtendSelection
@cmd('back-word')
def backwardWord(self, event):
    """Move the cursor to the previous word."""
    self.moveWordHelper(event, extend=False, forward=False)

@cmd('back-word-extend-selection')
def backwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous word."""
    self.moveWordHelper(event, extend=True, forward=False)

@cmd('back-word-smart')
def backwardWordSmart(self, event):
    """Move the cursor to the beginning of the current or the end of the previous word."""
    self.moveWordHelper(event, extend=False, forward=False, smart=True)

@cmd('back-word-smart-extend-selection')
def backwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the beginning of the current
    or the end of the previous word."""
    self.moveWordHelper(event, extend=True, forward=False, smart=True)

#@verbatim
    #@+node:ekr.20170707072347.1: *4* ec.beginningOfLine/ExtendSelection
#@+node:ekr.20150514063305.316: *11* ec.backward*/ExtendSelection
@cmd('back-word')
def backwardWord(self, event):
    """Move the cursor to the previous word."""
    self.moveWordHelper(event, extend=False, forward=False)

@cmd('back-word-extend-selection')
def backwardWordExtendSelection(self, event):
    """Extend the selection by moving the cursor to the previous word."""
    self.moveWordHelper(event, extend=True, forward=False)

@cmd('back-word-smart')
def backwardWordSmart(self, event):
    """Move the cursor to the beginning of the current or the end of the previous word."""
    self.moveWordHelper(event, extend=False, forward=False, smart=True)

@cmd('back-word-smart-extend-selection')
def backwardWordSmartExtendSelection(self, event):
    """Extend the selection by moving the cursor to the beginning of the current
    or the end of the previous word."""
    self.moveWordHelper(event, extend=True, forward=False, smart=True)
#@+node:ekr.20200725105315.413: *10* ec.swapCharacters & transeposeCharacters
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -14,4 +14,4 @@
 
 swapCharacters = transposeCharacters
#@verbatim
     #@+node:ekr.20150514063305.348: *3* ec: uA's
-    #@+node:ekr.20150514063305.349: *4* ec.clearNodeUas & clearAllUas (changed)
+    #@+node:ekr.20150514063305.349: *4* ec.clearNodeUas & clearAllUas
@language python
#@+node:ekr.20200725105315.414: *11* Old:ec.swapCharacters & transeposeCharacters
@cmd('transpose-chars')
def transposeCharacters(self, event):
    """Swap the characters at the cursor."""
    w = self.editWidget(event)
    if not w:
        return
    self.beginCommand(w, undoType='swap-characters')
    s = w.getAllText()
    i = w.getInsertPoint()
    if 0 < i < len(s):
        w.setAllText(s[: i - 1] + s[i] + s[i - 1] + s[i + 1 :])
        w.setSelectionRange(i, i, insert=i)
    self.endCommand(changed=True, setLabel=True)

swapCharacters = transposeCharacters
#@verbatim
    #@+node:ekr.20150514063305.348: *3* ec: uA's
#@verbatim
    #@+node:ekr.20150514063305.349: *4* ec.clearNodeUas & clearAllUas (changed)
#@+node:ekr.20150514063305.346: *11* ec.swapCharacters & transeposeCharacters
@cmd('transpose-chars')
def transposeCharacters(self, event):
    """Swap the characters at the cursor."""
    w = self.editWidget(event)
    if not w:
        return
    self.beginCommand(w, undoType='swap-characters')
    s = w.getAllText()
    i = w.getInsertPoint()
    if 0 < i < len(s):
        w.setAllText(s[: i - 1] + s[i] + s[i - 1] + s[i + 1 :])
        w.setSelectionRange(i, i, insert=i)
    self.endCommand(changed=True, setLabel=True)

swapCharacters = transposeCharacters
#@+node:ekr.20200725105314.42: *8* leo/commands/controlCommands.py
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -23,7 +23,6 @@
         """Ctor for ControlCommandsClass."""
         # pylint: disable=super-init-not-called
         self.c = c
-
#@verbatim
     #@+others
#@verbatim
     #@+node:ekr.20150514063305.91: *3* executeSubprocess
     def executeSubprocess(self, event, command):
@@ -35,8 +34,7 @@
             p = subprocess.Popen(
                 shlex.split(command),
                 stdout=subprocess.PIPE,
-                stderr=None if trace else subprocess.PIPE,
-                    # subprocess.DEVNULL is Python 3 only.
+                stderr=subprocess.DEVNULL if trace else subprocess.PIPE,
                 shell=sys.platform.startswith('win'),
             )
             out, err = p.communicate()
@@ -93,8 +91,6 @@
         k = self.c.k
         command = g.toUnicode(k.arg)
         if command:
-            # k.commandName = 'shell-command: %s' % command
-            # k.clearState()
             self.executeSubprocess(event, command)
#@verbatim
     #@+node:ekr.20150514063305.95: *3* shellCommandOnRegion
     @cmd('shell-command-on-region')
@@ -105,10 +101,8 @@
         if w:
             if w.hasSelection():
                 command = w.getSelectedText()
-                # k.commandName = 'shell-command: %s' % command
                 self.executeSubprocess(event, command)
             else:
-                # k.clearState()
                 g.es('No text selected')
         k.keyboardQuit()
#@verbatim
     #@+node:ekr.20150514063305.96: *3* actOnNode
@language python
#@+node:ekr.20200725105314.49: *9* Changed
#@+node:ekr.20200725105314.50: *10* class ControlCommandsClass
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -4,5 +4,4 @@
         """Ctor for ControlCommandsClass."""
         # pylint: disable=super-init-not-called
         self.c = c
-
     @others
@language python
#@+node:ekr.20200725105314.51: *11* Old:class ControlCommandsClass
class ControlCommandsClass(BaseEditCommandsClass):

    def __init__(self, c):
        """Ctor for ControlCommandsClass."""
        # pylint: disable=super-init-not-called
        self.c = c

    @others
#@+node:ekr.20160514095828.1: *11* class ControlCommandsClass
class ControlCommandsClass(BaseEditCommandsClass):

    def __init__(self, c):
        """Ctor for ControlCommandsClass."""
        # pylint: disable=super-init-not-called
        self.c = c
    @others
#@+node:ekr.20150514063305.91: *12* executeSubprocess
def executeSubprocess(self, event, command):
    """Execute a command in a separate process."""
    trace = False
    import sys
    k = self.c.k
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL if trace else subprocess.PIPE,
            shell=sys.platform.startswith('win'),
        )
        out, err = p.communicate()
        for line in g.splitLines(out):
            g.es_print(g.toUnicode(line.rstrip()))
    except Exception:
        g.es_exception()
    k.keyboardQuit()
        # Inits vim mode too.
    g.es(f"Done: {command}")
#@+node:ekr.20150514063305.92: *12* print plugins info...
@cmd('show-plugin-handlers')
def printPluginHandlers(self, event=None):
    """Print the handlers for each plugin."""
    g.app.pluginsController.printHandlers(self.c)

def printPlugins(self, event=None):
    """
    Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.
    """
    g.app.pluginsController.printPlugins(self.c)

@cmd('show-plugins-info')
def printPluginsInfo(self, event=None):
    """
    Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.
    """
    g.app.pluginsController.printPluginsInfo(self.c)
#@+node:ekr.20150514063305.93: *12* setSilentMode
@cmd('set-silent-mode')
def setSilentMode(self, event=None):
    """
    Set the mode to be run silently, without the minibuffer.
    The only use for this command is to put the following in an @mode node::

        --> set-silent-mode
    """
    self.c.k.silentMode = True
#@+node:ekr.20150514063305.94: *12* shellCommand (improved)
@cmd('shell-command')
def shellCommand(self, event):
    """Execute a shell command."""
    k = self.c.k
    k.setLabelBlue('shell-command: ')
    k.get1Arg(event, self.shellCommand1)

def shellCommand1(self, event):
    k = self.c.k
    command = g.toUnicode(k.arg)
    if command:
        self.executeSubprocess(event, command)
#@+node:ekr.20150514063305.95: *12* shellCommandOnRegion
@cmd('shell-command-on-region')
def shellCommandOnRegion(self, event):
    """Execute a command taken from the selected text in a separate process."""
    k = self.c.k
    w = self.editWidget(event)
    if w:
        if w.hasSelection():
            command = w.getSelectedText()
            self.executeSubprocess(event, command)
        else:
            g.es('No text selected')
    k.keyboardQuit()
#@+node:ekr.20150514063305.96: *12* actOnNode
@cmd('act-on-node')
def actOnNode(self, event):
    """
    Executes node-specific action, typically defined in a plugins as
    follows::

        import leo.core.leoPlugins

        def act_print_upcase(c,p,event):
            if not p.h.startswith('@up'):
                raise leo.core.leoPlugins.TryNext
            p.h = p.h.upper()

        g.act_on_node.add(act_print_upcase)

    This will upcase the headline when it starts with ``@up``.
    """
    g.act_on_node(self.c, self.c.p, event)
#@+node:ekr.20150514063305.97: *12* shutdown, saveBuffersKillEmacs & setShutdownHook
@cmd('save-buffers-kill-leo')
def shutdown(self, event):
    """Quit Leo, prompting to save any unsaved files first."""
    g.app.onQuit()

saveBuffersKillLeo = shutdown
#@+node:ekr.20150514063305.98: *12* suspend & iconifyFrame
@cmd('suspend')
def suspend(self, event):
    """Minimize the present Leo window."""
    w = self.editWidget(event)
    if not w: return
    self.c.frame.top.iconify()

@cmd('iconify-frame')
def iconifyFrame(self, event):
    """Minimize the present Leo window."""
    self.suspend(event)
#@+node:ekr.20200725105314.52: *10* executeSubprocess
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -7,8 +7,7 @@
         p = subprocess.Popen(
             shlex.split(command),
             stdout=subprocess.PIPE,
-            stderr=None if trace else subprocess.PIPE,
-                # subprocess.DEVNULL is Python 3 only.
+            stderr=subprocess.DEVNULL if trace else subprocess.PIPE,
             shell=sys.platform.startswith('win'),
         )
         out, err = p.communicate()
@language python
#@+node:ekr.20200725105314.53: *11* Old:executeSubprocess
def executeSubprocess(self, event, command):
    """Execute a command in a separate process."""
    trace = False
    import sys
    k = self.c.k
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=None if trace else subprocess.PIPE,
                # subprocess.DEVNULL is Python 3 only.
            shell=sys.platform.startswith('win'),
        )
        out, err = p.communicate()
        for line in g.splitLines(out):
            g.es_print(g.toUnicode(line.rstrip()))
    except Exception:
        g.es_exception()
    k.keyboardQuit()
        # Inits vim mode too.
    g.es(f"Done: {command}")
#@+node:ekr.20150514063305.91: *11* executeSubprocess
def executeSubprocess(self, event, command):
    """Execute a command in a separate process."""
    trace = False
    import sys
    k = self.c.k
    try:
        p = subprocess.Popen(
            shlex.split(command),
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL if trace else subprocess.PIPE,
            shell=sys.platform.startswith('win'),
        )
        out, err = p.communicate()
        for line in g.splitLines(out):
            g.es_print(g.toUnicode(line.rstrip()))
    except Exception:
        g.es_exception()
    k.keyboardQuit()
        # Inits vim mode too.
    g.es(f"Done: {command}")
#@+node:ekr.20200725105314.54: *10* shellCommand (improved)
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -9,6 +9,4 @@
     k = self.c.k
     command = g.toUnicode(k.arg)
     if command:
-        # k.commandName = 'shell-command: %s' % command
-        # k.clearState()
         self.executeSubprocess(event, command)
@language python
#@+node:ekr.20200725105314.55: *11* Old:shellCommand (improved)
@cmd('shell-command')
def shellCommand(self, event):
    """Execute a shell command."""
    k = self.c.k
    k.setLabelBlue('shell-command: ')
    k.get1Arg(event, self.shellCommand1)

def shellCommand1(self, event):
    k = self.c.k
    command = g.toUnicode(k.arg)
    if command:
        # k.commandName = 'shell-command: %s' % command
        # k.clearState()
        self.executeSubprocess(event, command)
#@+node:ekr.20150514063305.94: *11* shellCommand (improved)
@cmd('shell-command')
def shellCommand(self, event):
    """Execute a shell command."""
    k = self.c.k
    k.setLabelBlue('shell-command: ')
    k.get1Arg(event, self.shellCommand1)

def shellCommand1(self, event):
    k = self.c.k
    command = g.toUnicode(k.arg)
    if command:
        self.executeSubprocess(event, command)
#@+node:ekr.20200725105314.56: *10* shellCommandOnRegion
@ignore
@nosearch
@language patch
--- 4b8320485c0
+++ 2507a1fcc70
@@ -6,9 +6,7 @@
     if w:
         if w.hasSelection():
             command = w.getSelectedText()
-            # k.commandName = 'shell-command: %s' % command
             self.executeSubprocess(event, command)
         else:
-            # k.clearState()
             g.es('No text selected')
     k.keyboardQuit()
@language python
#@+node:ekr.20200725105314.57: *11* Old:shellCommandOnRegion
@cmd('shell-command-on-region')
def shellCommandOnRegion(self, event):
    """Execute a command taken from the selected text in a separate process."""
    k = self.c.k
    w = self.editWidget(event)
    if w:
        if w.hasSelection():
            command = w.getSelectedText()
            # k.commandName = 'shell-command: %s' % command
            self.executeSubprocess(event, command)
        else:
            # k.clearState()
            g.es('No text selected')
    k.keyboardQuit()
#@+node:ekr.20150514063305.95: *11* shellCommandOnRegion
@cmd('shell-command-on-region')
def shellCommandOnRegion(self, event):
    """Execute a command taken from the selected text in a separate process."""
    k = self.c.k
    w = self.editWidget(event)
    if w:
        if w.hasSelection():
            command = w.getSelectedText()
            self.executeSubprocess(event, command)
        else:
            g.es('No text selected')
    k.keyboardQuit()
#@+node:ekr.20200726040837.1: *5* #1440: Unify the ast and token worlds
@language rest
@wrap

Unify the ast and token worlds
https://github.com/leo-editor/leo-editor/issues/1440

@language python
#@+node:ekr.20200403083448.1: *5* #1559: Headline icons doubled
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1559

@language python
#@+node:ekr.20110605121601.18411: *6* qtree.getIcon & helper
def getIcon(self, p):
    """Return the proper icon for position p."""
    if self.use_declutter:
        item = self.position2item(p)
        return item and self.declutter_node(self.c, p, item)
    p.v.iconVal = iv = p.v.computeIcon()
    return self.getCompositeIconImage(p, iv)


#@+node:vitalije.20200329153148.1: *7* qtree.icon_filenames_for_node
def icon_filenames_for_node(self, p, val):
    '''Prepares and returns a list of icon filenames
       related to this node.
    '''
    nicon = f'box{val:02d}.png'
    fnames = self.nodeIconsDict.get(p.gnx)
    if not fnames:
        icons = self.c.editCommands.getIconList(p)
        fnames = [x['file'] for x in icons if x['where'] == 'beforeIcon']
        fnames.append(nicon)
        fnames.extend(x['file'] for x in icons if x['where'] == 'beforeHeadline')
        self.nodeIconsDict[p.gnx] = fnames
    pat = re.compile(r'^box\d\d\.png$')
    loaded_images = self.loaded_images
    for i, f in enumerate(fnames):
        if pat.match(f):
            fnames[i] = nicon
            self.nodeIconsDict[p.gnx] = fnames
            f = nicon
        if f not in loaded_images:
            loaded_images[f] = g.app.gui.getImageImage(f)
    return fnames
#@+node:vitalije.20200329153154.1: *7* qtree.make_composite_icon
def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
#@+node:ekr.20110605121601.18412: *7* qtree.getCompositeIconImage
def getCompositeIconImage(self, p, val):
    """Get the icon at position p."""
    fnames = self.icon_filenames_for_node(p, val)
    h = ':'.join(fnames)
    icon = g.app.gui.iconimages.get(h)
    loaded_images = self.loaded_images
    images = list(map(loaded_images.get, fnames))
    if not icon:
        icon = self.make_composite_icon(images)
        g.app.gui.iconimages[h] = icon
    return icon
#@+node:ekr.20200506165613.1: *5* #1563: abbreviations w/ German keyboards
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1563

The fix was to filter.doAltTweaks.

===== shift-tab (unindent-region) failed with the new code.

From https://en.m.wikipedia.org/wiki/German_keyboard_layout

- The positions of the "Z" and "Y" keys are switched.

- Part of the keyboard is adapted to include umlauted vowels (ä, ö, ü) and the sharp s (ß).

- German keyboards change the right Alt key into an Alt Gr key to access a third level of key assignments.

@language python
#@+node:ekr.20110605121601.18539: *6* filter.ctor
def __init__(self, c, w, tag=''):
    """Ctor for LeoQtEventFilter class."""
    super().__init__()
    self.c = c
    self.w = w  # A leoQtX object, *not* a Qt object.
    self.tag = tag
    # Debugging.
    self.keyIsActive = False
    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close-flash-brackets') or ''
    open_flashers = c.config.getString('open-flash-brackets') or ''
    self.flashers = open_flashers + close_flashers
    # #1563: Support German keyboards.
    self.use_german_keyboard = c.config.getBool('use-german-keyboard', default=False)
    # Support for ctagscompleter.py plugin.
    self.ctagscompleter_active = False
    self.ctagscompleter_onKey = None
#@+node:ekr.20180419154543.1: *6* filter.doAltTweaks
def doAltTweaks(self, actual_ch, keynum, mods, toString):
    """Turn AltGr and some Alt-Ctrl keys into plain keys."""
    qt = QtCore.Qt

    def removeAltCtrl(mods):
        for mod in ('Alt', 'Control'):
            if mod in mods:
                mods.remove(mod)
        return mods

    #
    # Remove Alt, Ctrl for AltGr keys.
    # See https://en.wikipedia.org/wiki/AltGr_key

    if keynum == qt.Key_AltGr:
        return removeAltCtrl(mods)
    #
    # Never alter complex characters.
    if len(actual_ch) != 1:
        return mods
    #
    # #1563: A hack for German keyboards:
    #        Remove *plain* Shift modifier for colon and semicolon.
    #        https://en.m.wikipedia.org/wiki/German_keyboard_layout
    if (
        self.use_german_keyboard
        and actual_ch in ":;" and 'Shift' in mods
        and 'Alt' not in mods and 'Control' not in mods
    ):
        mods.remove('Shift')
        # g.trace('mods', mods, 'ch', repr(actual_ch))
    #
    # Handle Alt-Ctrl modifiers for chars whose that are not ascii.
    # Testing: Alt-Ctrl-E is '€'.
    if ord(actual_ch) > 127 and 'Alt' in mods and 'Control' in mods:
        return removeAltCtrl(mods)
    return mods
#@+node:ekr.20200405053243.1: *5* #1564: open theme file fails on posix
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1564

@language python
#@+node:ekr.20180312043352.2: *6* c_file.open_theme_file
@g.commander_command('open-theme-file')
def open_theme_file(self, event):
    """Open a theme file in a new session and apply the theme."""
    c = event and event.get('c')
    if not c:
        return
    # Get the file name.
    themes_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'themes')
    fn = g.app.gui.runOpenFileDialog(c,
        title="Open Theme File",
        filetypes=[
            ("Leo files", "*.leo *.db"),
            ("All files", "*"),
        ],
        defaultextension=g.defaultLeoFileExtension(c),
        startpath=themes_dir,
    )
    if not fn:
        return
    leo_dir = g.os_path_finalize_join(g.app.loadDir, '..', '..')
    os.chdir(leo_dir)
    #
    # #1425: Open the theme file in a separate process.
    command = f'{g.sys.executable} {g.app.loadDir}/runLeo.py "{fn}"'
    g.execute_shell_commands(command) # #1564.
    os.chdir(leo_dir)
#@+node:ekr.20200405062013.1: *5* #1565: Announce TOG classes
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1565

@language python
#@+node:ekr.20200909165016.1: *5* #1570: tab pane disappears
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1570

PR: https://github.com/leo-editor/leo-editor/pull/1660

The fix was to LM.initWrapperLeoFile.

@language python
@nosearch
#@+node:ekr.20120223062418.10408: *6* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20200415040234.1: *5* #1571: headline icons (won't do)
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1571

@language python
@nosearch
#@+node:vitalije.20200329153154.1: *6* qtree.make_composite_icon
def make_composite_icon(self, images):
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    images = [x for x in images if x]
    height = max([i.height() for i in images])
    images = [i.scaledToHeight(height) for i in images]
    width = sum([i.width() for i in images]) + hsep * (len(images) - 1)
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba())  # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, 0, i)
        x += i.width() + hsep
    painter.end()
    return QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
#@+node:ekr.20200415042526.1: *5* #1575: cycle-editor-focus
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1575

@language python
#@+node:ekr.20200415041750.1: *6* LeoBody.cycleEditorFocus (restored)
@cmd('editor-cycle-focus')
@cmd('cycle-editor-focus')  # There is no LeoQtBody method
def cycleEditorFocus(self, event=None):
    """Cycle keyboard focus between the body text editors."""
    c = self.c
    d = self.editorWrappers
    w = c.frame.body.wrapper
    values = list(d.values())
    if len(values) > 1:
        i = values.index(w) + 1
        if i == len(values):
            i = 0
        w2 = values[i]
        assert(w != w2)
        self.selectEditor(w2)
        c.frame.body.wrapper = w2
#@+node:ekr.20200423120746.1: *5* #1581: read old .leo files
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1581

@language python
#@+node:ekr.20200425053310.1: *6* ----- handling .leo files
#@+node:ekr.20180602062323.7: *7* fast.readWithElementTree & helpers
# #1510: https://en.wikipedia.org/wiki/Valid_characters_in_XML.
translate_table = {z: None for z in range(20) if chr(z) not in '\t\r\n'}

def readWithElementTree(self, path, s):

    contents = g.toUnicode(s)
    contents = contents.translate(self.translate_table)
        # Fix #1036 and #1046.
    try:
        xroot = ElementTree.fromstring(contents)
    except Exception as e:
        # #970: Just report failure here.
        if path:
            message = f"bad .leo file: {g.shortFileName(path)}"
        else:
            message = 'The clipboard is not a vaild .leo file'
        g.es_print('\n' + message, color='red')
        g.es_print(g.toUnicode(e))
        print('')
        # #1510: Return a tuple.
        return None, None
    g_element = xroot.find('globals')
    v_elements = xroot.find('vnodes')
    t_elements = xroot.find('tnodes')
    gnx2body, gnx2ua = self.scanTnodes(t_elements)
    hidden_v = self.scanVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
    self.handleBits()
    return hidden_v, g_element
#@+node:ekr.20180624125321.1: *8* fast.handleBits (reads c.db)
def handleBits(self):
    """Restore the expanded and marked bits from c.db."""
    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
#@+node:ekr.20180606041211.1: *8* fast.resolveUa & helper
def resolveUa(self, attr, val, kind=None):  # Kind is for unit testing.
    """Parse an unknown attribute in a <v> or <t> element."""
    try:
        val = g.toEncodedString(val)
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None
    # Leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if isinstance(val, (str, bytes)):
            return g.toUnicode(val)
    try:
        binString = binascii.unhexlify(val)
            # Throws a TypeError if val is not a hex string.
    except Exception:
        # Assume that Leo 4.1 or above wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw', f"unit test failed: kind={kind}"
        else:
            g.trace(f"can not unhexlify {attr}={val}")
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        return val2
    except Exception:
        try:
            val2 = pickle.loads(binString, encoding='bytes')
            val2 = self.bytesToUnicode(val2)
            return val2
        except Exception:
            g.trace(f"can not unpickle {attr}={val}")
            return val
#@+node:ekr.20180606044154.1: *9* fast.bytesToUnicode
def bytesToUnicode(self, ob):
    """
    Recursively convert bytes objects in strings / lists / dicts to str
    objects, thanks to TNT
    http://stackoverflow.com/questions/22840092
    Needed for reading Python 2.7 pickles in Python 3.4.
    """
    # This is simpler than using isinstance.
    # pylint: disable=unidiomatic-typecheck
    t = type(ob)
    if t in (list, tuple):
        l = [str(i, 'utf-8') if type(i) is bytes else i for i in ob]
        l = [self.bytesToUnicode(i)
                if type(i) in (list, tuple, dict) else i
                    for i in l]
        ro = tuple(l) if t is tuple else l
    elif t is dict:
        byte_keys = [i for i in ob if type(i) is bytes]
        for bk in byte_keys:
            v = ob[bk]
            del(ob[bk])
            ob[str(bk, 'utf-8')] = v
        for k in ob:
            if type(ob[k]) is bytes:
                ob[k] = str(ob[k], 'utf-8')
            elif type(ob[k]) in (list, tuple, dict):
                ob[k] = self.bytesToUnicode(ob[k])
        ro = ob
    elif t is bytes:  # TNB added this clause
        ro = str(ob, 'utf-8')
    else:
        ro = ob
    return ro
#@+node:ekr.20180605062300.1: *8* fast.scanGlobals & helper
def scanGlobals(self, g_element):
    """Get global data from the cache, with reasonable defaults."""
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    if windowSize is not None:
        h, w = windowSize  # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    if windowSpot is None:
        x, y = d.get('left'), d.get('top')
    else:
        y, x = windowSpot  # #1263: (top, left)
    if 'size' in g.app.debug:
        g.trace(w, h, x, y, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(w, h, x, y)
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
#@+node:ekr.20180708060437.1: *9* fast.getGlobalData
def getGlobalData(self):
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
#@+node:ekr.20180602062323.8: *8* fast.scanTnodes
def scanTnodes(self, t_elements):

    gnx2body, gnx2ua = {}, defaultdict(dict)
    for e in t_elements:
        # First, find the gnx.
        gnx = e.attrib['tx']
        gnx2body[gnx] = e.text or ''
        # Next, scan for uA's for this gnx.
        for key, val in e.attrib.items():
            if key != 'tx':
                gnx2ua[gnx][key] = self.resolveUa(key, val)
    return gnx2body, gnx2ua
#@+node:ekr.20180602062323.9: *8* fast.scanVnodes & helper
def scanVnodes(self, gnx2body, gnx2vnode, gnx2ua, v_elements):

    c, fc = self.c, self.c.fileCommands
    << define v_element_visitor >>
    #
    # Create the hidden root vnode.

    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = '<hidden root vnode>'
    gnx2vnode[gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)
    return hidden_v
#@+node:ekr.20180605102822.1: *9* << define v_element_visitor >>
def v_element_visitor(parent_e, parent_v):
    """Visit the given element, creating or updating the parent vnode."""
    for e in parent_e:
        assert e.tag in ('v', 'vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        # #1581: Attempt to handle old Leo outlines.
        try:
            gnx = e.attrib['t']
            v = gnx2vnode.get(gnx)
        except KeyError:
            # g.trace('no "t" attrib')
            gnx = None
            v = None
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert g.isUnicode(body), body.__class__.__name__
            v._bodyString = body
        else:
            << Make a new vnode, linked to the parent >>
            << handle all other v attributes >>
            # Handle all inner elements.
            v_element_visitor(e, v)

#@+node:ekr.20180605075042.1: *10* << Make a new vnode, linked to the parent >>
v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode[gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert g.isUnicode(body), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
#@+node:ekr.20180605075113.1: *10* << handle all other v attributes >>
# Like fc.handleVnodeSaxAttrutes.
#
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnode/VnodeUnknownAttributes.
d = e.attrib
s = d.get('tnodeList', '')
tnodeList = s and s.split(',')
if tnodeList:
    # This tnodeList will be resolved later.
    v.tempTnodeList = tnodeList
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]
    # gnx2ua is a defaultdict(dict)
    # It might already exists because of tnode uA's.
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
#@+node:ekr.20180605102822.1: *7* << define v_element_visitor >>
def v_element_visitor(parent_e, parent_v):
    """Visit the given element, creating or updating the parent vnode."""
    for e in parent_e:
        assert e.tag in ('v', 'vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        # #1581: Attempt to handle old Leo outlines.
        try:
            gnx = e.attrib['t']
            v = gnx2vnode.get(gnx)
        except KeyError:
            # g.trace('no "t" attrib')
            gnx = None
            v = None
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert g.isUnicode(body), body.__class__.__name__
            v._bodyString = body
        else:
            << Make a new vnode, linked to the parent >>
            << handle all other v attributes >>
            # Handle all inner elements.
            v_element_visitor(e, v)

#@+node:ekr.20180605075042.1: *8* << Make a new vnode, linked to the parent >>
v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode[gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert g.isUnicode(body), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
#@+node:ekr.20180605075113.1: *8* << handle all other v attributes >>
# Like fc.handleVnodeSaxAttrutes.
#
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnode/VnodeUnknownAttributes.
d = e.attrib
s = d.get('tnodeList', '')
tnodeList = s and s.split(',')
if tnodeList:
    # This tnodeList will be resolved later.
    v.tempTnodeList = tnodeList
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]
    # gnx2ua is a defaultdict(dict)
    # It might already exists because of tnode uA's.
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
#@+node:ekr.20180602103135.3: *7* fast_at.get_patterns
@nobeautify

def get_patterns(self, delims):
    '''Create regex patterns for the given comment delims.'''
    # This must be a function, because of @comments & @delims.
    delim_start, delim_end = delims
    delims = re.escape(delim_start), re.escape(delim_end or '')
    delim1, delim2 = delims
    ref = g.angleBrackets(r'(.*)')
    patterns = (
        # The list of patterns, in alphabetical order.
        # These patterns must be mutually exclusive.
        fr'^\s*{delim1}@afterref{delim2}$',             # @afterref
        fr'^(\s*){delim1}@(\+|-)all\b(.*){delim2}$',    # @all
        fr'^\s*{delim1}@@c(ode)?{delim2}$',             # @c and @code
        fr'^\s*{delim1}@comment(.*){delim2}',           # @comment
        fr'^\s*{delim1}@delims(.*){delim2}',            # @delims
        fr'^\s*{delim1}@\+(at|doc)?(\s.*?)?{delim2}\n', # @doc or @
        fr'^\s*{delim1}@end_raw\s*{delim2}',            # @end_raw
        fr'^\s*{delim1}@@first{delim2}$',               # @first
        fr'^\s*{delim1}@@last{delim2}$',                # @last
        fr'^(\s*){delim1}@\+node:([^:]+): \*(\d+)?(\*?) (.*){delim2}$', # @node
        fr'^(\s*){delim1}@(\+|-)others\b(.*){delim2}$', # @others
        fr'^\s*{delim1}@raw(.*){delim2}',               # @raw
        fr'^(\s*){delim1}@(\+|-){ref}\s*{delim2}$'      # section ref
    )
    # Return the compiled patterns, in alphabetical order.
    return (re.compile(pattern) for pattern in patterns)
#@+node:ekr.20180602103135.8: *7* fast_at.scan_lines
def scan_lines(self, delims, first_lines, lines, path, start, test=False):
    '''Scan all lines of the file, creating vnodes.'''
    << init scan_lines >>
    << define dump_v >>

    i = 0  # To keep pylint happy.
    for i, line in enumerate(lines[start:]):
        # Order matters.
        << 1. common code for all lines >>
        << 2. short-circuit later tests >>
        << 3. handle @others >> # clears in_doc
        << 4. handle section refs >> # clears in_doc.
        # Order doesn't matter, but match more common sentinels first.
        << handle node_start >>
        << handle end of @doc & @code parts >>
        << handle @all >>
        << handle afterref >>
        << handle @first and @last >>
        << handle @comment >>
        << handle @delims >>
        << handle @raw >>
        << handle @-leo >>
        # These must be last, in this order.
        << Last 1. handle remaining @@ lines >>
        << Last 2. handle remaining @doc lines >>
        << Last 3. handle remaining @ lines >>
    else:
        # No @-leo sentinel
        return None, []
    # Handle @last lines.
    last_lines = lines[start + i :]
    if last_lines:
        last_lines = ['@last ' + z for z in last_lines]
        gnx2body[root_gnx] = gnx2body[root_gnx] + last_lines
    self.post_pass(gnx2body, gnx2vnode, root_v)
    return root_v, last_lines
#@+node:ekr.20180602103135.9: *8* << init scan_lines >>
#
# Simple vars...
afterref = False
    # A special verbatim line follows @afterref.
clone_v = None
    # The root of the clone tree.
    # When not None, we are scanning a clone and all it's descendants.
delim_start, delim_end = delims
    # The start/end delims.
doc_skip = (delim_start + '\n', delim_end + '\n')
    # To handle doc parts.
first_i = 0
    # Index into first array.
in_doc = False
    # True: in @doc parts.
in_raw = False
    # True: @raw seen.
is_cweb = delim_start == '@q@' and delim_end == '@>'
    # True: cweb hack in effect.
indent = 0
    # The current indentation.
level_stack = []
    # Entries are (vnode, in_clone_tree)
n_last_lines = 0
    # The number of @@last directives seen.
root_seen = False
    # False: The next +@node sentinel denotes the root, regardless of gnx.
    # Needed to handle #1065 so reads will not create spurious child nodes.
sentinel = delim_start + '@'
    # Faster than a regex!
stack = []
    # Entries are (gnx, indent, body)
    # Updated when at+others, at+<section>, or at+all is seen.
verbline = delim_start + '@verbatim' + delim_end + '\n'
    # The spelling of at-verbatim sentinel
verbatim = False
    # True: the next line must be added without change.
#
# Init the data for the root node.
#

#
# Init the parent vnode for testing.
#
if self.test:
    root_gnx = gnx = 'root-gnx'
        # The node that we are reading.
        # start with the gnx for the @file node.
    gnx_head = '<hidden top vnode>'
        # The headline of the root node.
    context = None
    parent_v = self.VNode(context=context, gnx=gnx)
    parent_v._headString = gnx_head
        # Corresponds to the @files node itself.
else:
    # Production.
    root_gnx = gnx = self.root.gnx
    context = self.c
    parent_v = self.root.v
root_v = parent_v
    # Does not change.
level_stack.append((root_v, False),)
#
# Init the gnx dict last.
#
gnx2vnode = self.gnx2vnode
    # Keys are gnx's, values are vnodes.
gnx2body = {}
    # Keys are gnxs, values are list of body lines.
gnx2vnode[gnx] = parent_v
    # Add gnx to the keys
gnx2body[gnx] = body = first_lines
    # Add gnx to the keys.
    # Body is the list of lines presently being accumulated.
#
# get the patterns.
data = self.get_patterns(delims)
after_pat, all_pat, code_pat, comment_pat, delims_pat, doc_pat, end_raw_pat, first_pat, last_pat, node_start_pat, others_pat, raw_pat, ref_pat = data

#@+node:ekr.20180613061743.1: *8* << define dump_v >>
def dump_v():
    """Dump the level stack and v."""
    print('----- LEVEL', level, v.h)
    print('       PARENT', parent_v.h)
    print('[')
    for i, data in enumerate(level_stack):
        v2, in_tree = data
        print(f"{i+1:2} {in_tree:5} {v2.h}")
    print(']')
    print('PARENT.CHILDREN...')
    g.printObj([v3.h for v3 in parent_v.children])
    print('PARENTS...')
    g.printObj([v4.h for v4 in v.parents])

#@+node:ekr.20180602103135.10: *8* << 1. common code for all lines >>
if verbatim:
    # We are in raw mode, or other special situation.
    # Previous line was verbatim sentinel. Append this line as it is.
    if afterref:
        afterref = False
        if body:  # a List of lines.
            body[-1] = body[-1].rstrip() + line
        else:
            body = [line]
        verbatim = False
    elif in_raw:
        m = end_raw_pat.match(line)
        if m:
            in_raw = False
            verbatim = False
        else:
             body.append(line)
             # Continue verbatim/raw mode.
    else:
        body.append(line)
        verbatim = False
    continue
if line == verbline:  # <delim>@verbatim.
    verbatim = True
    continue
#
# Strip the line only once.
strip_line = line.strip()
#
# Undo the cweb hack.
if is_cweb and line.startswith(sentinel):
    line = line[: len(sentinel)] + line[len(sentinel) :].replace('@@', '@')
# Adjust indentation.
if indent and line[:indent].isspace() and len(line) > indent:
    line = line[indent:]
#@+node:ekr.20180602103135.12: *8* << 2. short-circuit later tests >>
# This is valid because all following sections are either:
# 1. guarded by 'if in_doc' or
# 2. guarded by a pattern that matches the start of the sentinel.
#
if not in_doc and not strip_line.startswith(sentinel):
    # lstrip() is faster than using a regex!
    body.append(line)
    continue
#@+node:ekr.20180602103135.14: *8* << 3. handle @others >>
m = others_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':  # opening sentinel
        body.append(f"{m.group(1)}@others{m.group(3) or ''}\n")
        stack.append((gnx, indent, body))
        indent += m.end(1)  # adjust current identation
    else:  # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
#@+node:ekr.20180602103135.18: *8* << 4. handle section refs >>
m = ref_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':
        # open sentinel.
        body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
        stack.append((gnx, indent, body))
        indent += m.end(1)
        continue
    if stack:
        # #1232: Only if the stack exists.
        # close sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        continue
#@+node:ekr.20180602103135.19: *8* << handle node_start >>
m = node_start_pat.match(line)
if m:
    in_doc, in_raw = False, False
    gnx, head = m.group(2), m.group(5)
    level = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
        # m.group(3) is the level number, m.group(4) is the number of stars.
    v = gnx2vnode.get(gnx)
    #
    # Case 1: The root @file node. Don't change the headline.
    if not root_seen:
        # Fix #1064: The node represents the root, regardless of the gnx!
        root_seen = True
        clone_v = None
        gnx2body[gnx] = body = []
        if not v:
            # Fix #1064.
            v = root_v
            # This message is annoying when using git-diff.
                # if gnx != root_gnx:
                    # g.es_print("using gnx from external file: %s" % (v.h), color='blue')
            gnx2vnode[gnx] = v
            v.fileIndex = gnx
        v.children = []
        continue
    #
    # Case 2: We are scanning the descendants of a clone.
    parent_v, clone_v = level_stack[level - 2]
    if v and clone_v:
        # The last version of the body and headline wins..
        gnx2body[gnx] = body = []
        v._headString = head
        # Update the level_stack.
        level_stack = level_stack[: level - 1]
        level_stack.append((v, clone_v),)
        # Always clear the children!
        v.children = []
        parent_v.children.append(v)
        continue
    #
    # Case 3: we are not already scanning the descendants of a clone.
    if v:
        # The *start* of a clone tree. Reset the children.
        clone_v = v
        v.children = []
    else:
        # Make a new vnode.
        v = self.VNode(context=context, gnx=gnx)
    #
    # The last version of the body and headline wins.
    gnx2vnode[gnx] = v
    gnx2body[gnx] = body = []
    v._headString = head
    #
    # Update the stack.
    level_stack = level_stack[: level - 1]
    level_stack.append((v, clone_v),)
    #
    # Update the links.
    assert v != root_v
    parent_v.children.append(v)
    v.parents.append(parent_v)
    # dump_v()
    continue
#@+node:ekr.20180602103135.16: *8* << handle end of @doc & @code parts >>
if in_doc:
    # When delim_end exists the doc block:
    # - begins with the opening delim, alonw on its own line
    # - ends with the closing delim, alone on its own line.
    # Both of these lines should be skipped
    #
    # #1496: Retire the @doc convention.
    #        An empty line is no longer a sentinel.
    if delim_end and line in doc_skip:
        # doc_skip is (delim_start + '\n', delim_end + '\n')
        continue
    #
    # Check for @c or @code.
    m = code_pat.match(line)
    if m:
        in_doc = False
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
else:
    m = doc_pat.match(line)
    if m:
        # @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or ''  # Trailing text.
        if doc2:
            body.append(f"{doc}{doc2}\n")
        else:
            body.append(doc + '\n')
        # Enter @doc mode.
        in_doc = True
        continue
#@+node:ekr.20180602103135.13: *8* << handle @all >>
m = all_pat.match(line)
if m:
    # @all tells Leo's *write* code not to check for undefined sections.
    # Here, in the read code, we merely need to add it to the body.
    # Pushing and popping the stack may not be necessary, but it can't hurt.
    if m.group(2) == '+':  # opening sentinel
        body.append(f"{m.group(1)}@all{m.group(3) or ''}\n")
        stack.append((gnx, indent, body))
    else:  # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        gnx2body[gnx] = body
    continue
#@+node:ekr.20180603063102.1: *8* << handle afterref >>
m = after_pat.match(line)
if m:
    afterref = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
#@+node:ekr.20180606053919.1: *8* << handle @first and @last >>
m = first_pat.match(line)
if m:
    if 0 <= first_i < len(first_lines):
        body.append('@first ' + first_lines[first_i])
        first_i += 1
    else:
        g.trace(f"\ntoo many @first lines: {path}")
        print('@first is valid only at the start of @<file> nodes\n')
        g.printObj(first_lines, tag='first_lines')
        g.printObj(lines[start : i + 2], tag='lines[start:i+2]')
    continue
m = last_pat.match(line)
if m:
    n_last_lines += 1
    continue
#@+node:ekr.20180621050901.1: *8* << handle @comment >>
# http://leoeditor.com/directives.html#part-4-dangerous-directives
m = comment_pat.match(line)
if m:
    # <1, 2 or 3 comment delims>
    delims = m.group(1).strip()
    # Whatever happens, retain the @delims line.
    body.append(f"@comment {delims}\n")
    delim1, delim2, delim3 = g.set_delims_from_string(delims)
        # delim1 is always the single-line delimiter.
    if delim1:
        delim_start, delim_end = delim1, ''
    else:
        delim_start, delim_end = delim2, delim3
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__', '\n').replace('_', ' ')
    delim_end = delim_end.replace('__', '\n').replace('_', ' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@>'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns.
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
#@+node:ekr.20180608104836.1: *8* << handle @delims >>
m = delims_pat.match(line)
if m:
    # Get 1 or 2 comment delims
    # Whatever happens, retain the original @delims line.
    delims = m.group(1).strip()
    body.append(f"@delims {delims}\n")
    #
    # Parse the delims.
    delims_pat = re.compile(r'^([^ ]+)\s*([^ ]+)?')
    m2 = delims_pat.match(delims)
    if not m2:
        g.trace(f"Ignoring invalid @comment: {line!r}")
        continue
    delim_start = m2.group(1)
    delim_end = m2.group(2) or ''
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__', '\n').replace('_', ' ')
    delim_end = delim_end.replace('__', '\n').replace('_', ' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@>'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
#@+node:ekr.20180606080200.1: *8* << handle @raw >>
# http://leoeditor.com/directives.html#part-4-dangerous-directives
m = raw_pat.match(line)
if m:
    in_raw = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
#@+node:ekr.20180602103135.20: *8* << handle @-leo >>
if line.startswith(delim_start + '@-leo'):
    i += 1
    break
#@+node:ekr.20180603135602.1: *8* << Last 1. handle remaining @@ lines >>
# @first, @last, @delims and @comment generate @@ sentinels,
# So this must follow all of those.
if line.startswith(delim_start + '@@'):
    ii = len(delim_start) + 1  # on second '@'
    jj = line.rfind(delim_end) if delim_end else -1
    body.append(line[ii:jj] + '\n')
    continue
#@+node:ekr.20180606054325.1: *8* << Last 2. handle remaining @doc lines >>
if in_doc:
    if delim_end:
        # doc lines are unchanged.
        body.append(line)
        continue
    # Doc lines start with start_delim + one blank.
    # #1496: Retire the @doc convention:
    tail = line[len(delim_start) + 1 :]
    if tail.strip():
        body.append(tail)
    else:
        body.append('\n')
    continue
#@+node:ekr.20180602103135.17: *8* << Last 3. handle remaining @ lines >>
# Handle an apparent sentinel line.
# This *can* happen, as the result of the git-diff command.
#
# This assert verifies the short-circuit test.
assert strip_line.startswith(sentinel), (repr(sentinel), repr(line))
#
# This trace is less important, but interesting.
g.trace(
    f"{g.shortFileName(self.path)}: ignoring unexpected line: {line.strip()!r}")
# body.append(line)
#@+node:ekr.20200425053330.1: *6* ----- handling old external files
#@+node:ekr.20200424083150.1: *7* function: dump_stack
def dump_stack(tag):
    print(tag)
    for i, data in enumerate(stack):
        h, lines = data
        print(f"{i:>2} {len(lines):<3} {h.strip()}")
#@+node:ekr.20200424154303.1: *7* @g.command(import-legacy-external-file)
@g.command('import-legacy-external-files')
def import_legacy_external_files(event):
    """Prompt for legacy external files and import them."""
    c = event.get('c')
    if c:
        LegacyExternalFileImporter(c).prompt_for_files()
#@+node:ekr.20200424152850.1: *7* class LegacyExternalFileImporter
class LegacyExternalFileImporter:
    """
    A class to import external files written by versions of Leo earlier
    than 5.0.
    """
    # Sentinels to ignore, without the leading comment delim.
    ignore = ('@+at', '@-at', '@+leo', '@-leo', '@nonl', '@nl', '@-others')
    
    def __init__(self, c):
        self.c = c
    
    @others
#@+node:ekr.20200424093946.1: *8* class Node
class Node:
    
    def __init__(self, h, level):
        """Hold node data."""
        self.h = h.strip()
        self.level = level
        self.lines = []
#@+node:ekr.20200424092652.1: *8* legacy.add
def add(self, line, stack):
    """Add a line to the present node."""
    if stack:
        node = stack[-1]
        node.lines.append(line)
    else:
        print('orphan line: ', repr(line))
#@+node:ekr.20200424160847.1: *8* legacy.compute_delim1
def compute_delim1(self, path):
    """Return the opening comment delim for the given file."""
    junk, ext = os.path.splitext(path)
    if not ext:
        return None
    language = g.app.extension_dict.get(ext[1:])
    if not language:
        return None
    delim1, delim2, delim3 = g.set_delims_from_language(language)
    g.trace(language, delim1 or delim2)
    return delim1 or delim2
#@+node:ekr.20200424153139.1: *8* legacy.import_file
def import_file(self, path):
    """Import one legacy external file."""
    c = self.c
    root_h = g.shortFileName(path)
    delim1 = self.compute_delim1(path)
    if not delim1:
        g.es_print('unknown file extension:', color='red')
        g.es_print(path)
        return
    # Read the file into s.
    with open(path, 'r') as f:
        s = f.read()
    # Do nothing if the file is a newer external file.
    if delim1 + '@+leo-ver=4' not in s:
        g.es_print('not a legacy external file:', color='red')
        g.es_print(path)
        return
    # Compute the local ignore list for this file.
    ignore = tuple(delim1 + z for z in self.ignore)
    # Handle each line of the file.
    nodes = []  # An list of nodes, in file order.
    stack = []  # A stack of nodes.
    for line in g.splitLines(s):
        s = line.lstrip()
        lws = line[:len(line) - len(line.lstrip())]
        if s.startswith(delim1 + '@@'):
            self.add(lws + s[2:], stack)
        elif s.startswith(ignore):
            # Ignore these. Use comments instead of @doc bodies.
            pass
        elif (
            s.startswith(delim1 + '@+others') or
            s.startswith(delim1 + '@' + lws + '@+others')
        ):
            self.add(lws + '@others\n', stack)
        elif s.startswith(delim1 + '@<<'):
            n = len(delim1 + '@<<')
            self.add(lws + '<<' + s[n:].rstrip() + '\n', stack)
        elif s.startswith(delim1 + '@+node:'):
            # Compute the headline.
            if stack:
                h = s[8:]
                i = h.find(':')
                h = h[i+1:] if ':' in h else h
            else:
                h = root_h
            # Create a node and push it.
            node = self.Node(h, len(stack))
            nodes.append(node)
            stack.append(node)
        elif s.startswith(delim1 + '@-node'):
            # End the node.
            stack.pop()
        elif s.startswith(delim1 + '@'):
            print('oops:', repr(s))
        else:
            self.add(line, stack)
    if stack:
        print('Unbalanced node sentinels')
    # Generate nodes.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.h = f"imported file: {root_h}"
    stack = [root]
    for node in nodes:
        b = g.removeExtraLws(''.join(node.lines), -4)
        level = node.level
        if level == 0:
            root.h = root_h
            root.b = b
        else:
            parent = stack[level-1]
            p = parent.insertAsLastChild()
            p.b = b
            p.h = node.h
            # Good for debugging.
            # p.h = f"{level} {node.h}"  
            stack = stack[:level] + [p]
    c.selectPosition(root)
    root.expand()  # c.expandAllSubheads()
    c.redraw()
#@+node:ekr.20200424154553.1: *8* legacy.import_files
def import_files(self, paths):
    """Import zero or more files."""
    for path in paths:
        if os.path.exists(path):
            self.import_file(path)
        else:
            g.es_print(f"not found: {path!r}")
#@+node:ekr.20200424154416.1: *8* legacy.prompt_for_files
def prompt_for_files(self):
    """Prompt for a list of legacy external .py files and import them."""
    c = self.c
    types = [
        ("Legacy external files", "*.py"),
        ("All files", "*"),
    ]
    paths = g.app.gui.runOpenFileDialog(c,
        title="Import Legacy External Files",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()
    if paths:
        g.chdir(paths[0])
        self.import_files(paths)
#@+node:ekr.20200424153501.1: *6* script: import legacy file
import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
#@+node:ekr.20200519084322.1: *5* #1592: ctrl-click should ignore defs in @nosearch
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1592

- Changed find.findDefHelper.
- Added g.inAtNosearch.

@language python
@nosearch
#@+node:ekr.20160422071747.1: *6* find.doCloneFindAllHelper
def doCloneFindAllHelper(self, clones, count, flatten, p, skip):
    """Handle the cff or cfa at node p."""
    if g.inAtNosearch(p):
        p.moveToNodeAfterTree()
        return count
    found = self.findNextBatchMatch(p)
    if found:
        if not p in clones:
            clones.append(p.copy())
        count += 1
    if flatten:
        skip.add(p.v)
        p.moveToThreadNext()
    elif found:
        # Don't look at the node or it's descendants.
        for p2 in p.self_and_subtree(copy=False):
            skip.add(p2.v)
        p.moveToNodeAfterTree()
    else:
        p.moveToThreadNext()
    return count
#@+node:ekr.20150629125733.1: *6* findDefHelper & helpers
def findDefHelper(self, event, defFlag):
    """Find the definition of the class, def or var under the cursor."""
    c, find, ftm = self.c, self, self.ftm
    w = c.frame.body.wrapper
    if not w:
        return
    word = self.initFindDef(event)
    if not word:
        return
    save_sel = w.getSelectionRange()
    ins = w.getInsertPoint()
    # For the command, always start in the root position.
    old_p = c.p
    p = c.rootPosition()
    # Required.
    c.selectPosition(p)
    c.redraw()
    c.bodyWantsFocusNow()
    # Set up the search.
    if defFlag:
        prefix = 'class' if word[0].isupper() else 'def'
        find_pattern = prefix + ' ' + word
    else:
        find_pattern = word + ' ='
    find.find_text = find_pattern
    ftm.setFindText(find_pattern)
    # Save previous settings.
    find.saveBeforeFindDef(p)
    find.setFindDefOptions(p)
    self.find_seen = set()
    use_cff = c.config.getBool('find-def-creates-clones', default=False)
    count = 0
    if use_cff:
        count = find.findAll(clone_find_all=True, clone_find_all_flattened=True)
        found = count > 0
    else:
        # #1592.  Ignore hits under control of @nosearch
        while True:
            found = find.findNext(initFlag=False)
            if not found or not g.inAtNosearch(c.p):
                break
    if not found and defFlag:
        # Leo 5.7.3: Look for an alternative defintion of function/methods.
        word2 = self.switchStyle(word)
        if word2:
            find_pattern = prefix + ' ' + word2
            find.find_text = find_pattern
            ftm.setFindText(find_pattern)
            if use_cff:
                count = find.findAll(
                    clone_find_all=True, clone_find_all_flattened=True)
                found = count > 0
            else:
                # #1592.  Ignore hits under control of @nosearch
                while True:
                    found = find.findNext(initFlag=False)
                    if not found or not g.inAtNosearch(c.p):
                        break
    if found and use_cff:
        last = c.lastTopLevel()
        if count == 1:
            # It's annoying to create a clone in this case.
            # Undo the clone find and just select the proper node.
            last.doDelete()
            find.findNext(initFlag=False)
        else:
            c.selectPosition(last)
    if found:
        self.find_seen.add(c.p.v)
        self.restoreAfterFindDef()
            # Failing to do this causes massive confusion!
    else:
        c.selectPosition(old_p)
        self.restoreAfterFindDef()  # 2016/03/24
        i, j = save_sel
        c.redraw()
        w.setSelectionRange(i, j, insert=ins)
        c.bodyWantsFocusNow()
#@+node:ekr.20180511045458.1: *7* switchStyle
def switchStyle(self, word):
    """
    Switch between camelCase and underscore_style function defintiions.
    Return None if there would be no change.
    """
    s = word
    if s.find('_') > -1:
        if s.startswith('_'):
            # Don't return something that looks like a class.
            return None
        #
        # Convert to CamelCase
        s = s.lower()
        while s:
            i = s.find('_')
            if i == -1:
                break
            s = s[:i] + s[i + 1 :].capitalize()
        return s
    #
    # Convert to underscore_style.
    result = []
    for i, ch in enumerate(s):
        if i > 0 and ch.isupper():
            result.append('_')
        result.append(ch.lower())
    s = ''.join(result)
    return None if s == word else s
#@+node:ekr.20150629084611.1: *7* initFindDef
def initFindDef(self, event):
    """Init the find-def command. Return the word to find or None."""
    c = self.c
    w = c.frame.body.wrapper
    # First get the word.
    c.bodyWantsFocusNow()
    w = c.frame.body.wrapper
    if not w.hasSelection():
        c.editCommands.extendToWord(event, select=True)
    word = w.getSelectedText().strip()
    if not word:
        return None
    if keyword.iskeyword(word):
        return None
    # Return word, stripped of preceding class or def.
    for tag in ('class ', 'def '):
        found = word.startswith(tag) and len(word) > len(tag)
        if found:
            return word[len(tag) :].strip()
    return word
#@+node:ekr.20150629095633.1: *7* find.saveBeforeFindDef
def saveBeforeFindDef(self, p):
    """Save the find settings in effect before a find-def command."""
    if not self.find_def_data:
        self.find_def_data = g.Bunch(
            ignore_case=self.ignore_case,
            p=p.copy(),
            pattern_match=self.pattern_match,
            search_body=self.search_body,
            search_headline=self.search_headline,
            whole_word=self.whole_word,
        )
#@+node:ekr.20150629100600.1: *7* find.setFindDefOptions
def setFindDefOptions(self, p):
    """Set the find options needed for the find-def command."""
    self.ignore_case = False
    self.p = p.copy()
    self.pattern_match = False
    self.reverse = False
    self.search_body = True
    self.search_headline = False
    self.whole_word = True
#@+node:ekr.20150629095511.1: *7* find.restoreAfterFindDef
def restoreAfterFindDef(self):
    """Restore find settings in effect before a find-def command."""
    # pylint: disable=no-member
        # Bunch has these members
    b = self.find_def_data  # A g.Bunch
    if b:
        self.ignore_case = b.ignore_case
        self.p = b.p
        self.pattern_match = b.pattern_match
        self.reverse = False
        self.search_body = b.search_body
        self.search_headline = b.search_headline
        self.whole_word = b.whole_word
        self.find_def_data = None
#@+node:ekr.20200521075143.1: *6* g.inAtNosearch
def inAtNosearch(p):
    """Return True if p or p's ancestors contain an @nosearch directive."""
    for p in p.self_and_parents():
        if p.is_at_ignore() or re.search(r'(^@|\n@)nosearch\b', p.b):
            return True
    return False
#@+node:ekr.20200521061042.1: *6* test
get_arg
#@+node:ekr.20200525084601.1: *5* #1593: paste-as-template
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1593

@language python
#@+node:ekr.20200528131303.1: *6* ni.computeNewIndex
def computeNewIndex(self):
    """Return a new gnx."""
    t_s = self.update()
        # Updates self.lastTime and self.lastIndex.
    gnx = g.toUnicode(f"{self.userId}.{t_s}.{self.lastIndex:d}")
    return gnx
#@+node:vitalije.20200529105105.1: *6* c_oc.pasteAsTemplate
@g.commander_command('paste-as-template')
def pasteAsTemplate(self, event=None):
    c = self
    p = c.p
    @others
    xroot = ElementTree.fromstring(g.app.gui.getTextFromClipboard())
    xvnodes = xroot.find('vnodes')
    xtnodes = xroot.find('tnodes')

    bodies, uas = leoFileCommands.FastRead(c, {}).scanTnodes(xtnodes)

    root_gnx = xvnodes[0].attrib.get('t') # the gnx of copied node
    outside = { x.gnx for x in skip_root(c.hiddenRootNode) }
        # outside will contain gnxes of nodes that are outside the copied tree

    translation = { x: translate_gnx(x) for x in bodies }
        # we generate new gnx for each node in the copied tree

    seen = set(outside) # required for the treatment of local clones inside the copied tree

    heads = {}

    bunch = c.undoer.createCommonBunch(p)
    << prepare destination data >>

    pasted = do_paste(vpar, index)

    newp = leoNodes.Position(pasted, index, parStack)

    bunch.undoHelper = undoHelper
    bunch.redoHelper = redoHelper
    bunch.undoType = 'paste-retaining-outside-clones'

    newp.setDirty()
    c.undoer.pushBead(bunch)
    c.redraw(newp)
#@+node:vitalije.20200529112224.1: *7* skip_root
def skip_root(v):
    '''
    generates v nodes in the outline order
    but skips a subtree of the node with root_gnx
    '''
    if v.gnx != root_gnx:
        yield v
        for ch in v.children:
            yield from skip_root(ch)
#@+node:vitalije.20200529112459.1: *7* translate_gnx
def translate_gnx(gnx):
    '''
    allocates a new gnx for all nodes that
    are not found outside copied tree
    '''
    if gnx in outside:
        return gnx
    return g.app.nodeIndices.computeNewIndex()
#@+node:vitalije.20200529115141.1: *7* viter
def viter(parent_gnx, xv):
    '''
    iterates <v> nodes generating tuples:
        
        (parent_gnx, child_gnx, headline, body)
    
    skipping the descendants of already seen nodes.
    '''
    chgnx = xv.attrib.get('t')
    b = bodies[chgnx]
    gnx = translation.get(chgnx)
    if gnx in seen:
        yield parent_gnx, gnx, heads.get(gnx), b
    else:
        seen.add(gnx)
        h = xv[0].text
        heads[gnx] = h
        yield parent_gnx, gnx, h, b
        for xch in xv[1:]:
            yield from viter(gnx, xch)
#@+node:vitalije.20200529114857.1: *7* getv
gnx2v = c.fileCommands.gnxDict
def getv(gnx):
    '''
    returns a pair (vnode, is_new) for the given gnx.
    if node doesn't exist, creates a new one.
    '''
    v = gnx2v.get(gnx)
    if v is None:
        return leoNodes.VNode(c, gnx), True
    return v, False
#@+node:vitalije.20200529115539.1: *7* do_paste
def do_paste(vpar, index):
    '''
    pastes a new node as a child of vpar at given index 
    '''
    vpargnx = vpar.gnx
    # the first node is inserted at the given index
    # and the rest are just appended at parents children
    # to achieve this we first create a generator object
    rows = viter(vpargnx, xvnodes[0])

    # then we just take first tuple
    pgnx, gnx, h, b = next(rows)

    # create vnode
    v, _ = getv(gnx)
    v.h = h
    v.b = b

    # and finally insert it at the given index
    vpar.children.insert(index, v)
    v.parents.append(vpar)

    pasted = v # remember the first node as a return value

    # now we iterate the rest of tuples
    for pgnx, gnx, h, b in rows:

        # get or create a child `v`
        v, isNew = getv(gnx)
        if isNew:
            v.h = h
            v.b = b
            ua = uas.get(gnx)
            if ua:
                v.unknownAttributes = ua
        # get parent node `vpar`
        vpar = getv(pgnx)[0]

        # and link them
        vpar.children.append(v)
        v.parents.append(vpar)

    return pasted
#@+node:vitalije.20200529120440.1: *7* undoHelper
def undoHelper():
    v = vpar.children.pop(index)
    v.parents.remove(vpar)
    c.redraw(bunch.p)
#@+node:vitalije.20200529120537.1: *7* redoHelper
def redoHelper():
    vpar.children.insert(index, pasted)
    pasted.parents.append(vpar)
    c.redraw(newp)
#@+node:vitalije.20200529111500.1: *7* << prepare destination data >>
# destination data consists of 
#    1. vpar --- parent v node that should receive pasted child
#    2. index --- at which pasted child will be
#    3. parStack --- a stack for creating new position of the pasted node
#
# the new position will be:  Position(vpar.children[index], index, parStack)
# but it can't be calculated yet, before actual paste is done
if p.isExpanded():
    # paste as a first child of current position
    vpar = p.v
    index = 0
    parStack = p.stack + [(p.v, p._childIndex)]
else:
    # paste after the current position
    parStack = p.stack
    vpar = p.stack[-1][0] if p.stack else c.hiddenRootNode
    index = p._childIndex + 1

#@+node:ekr.20200525071619.1: *5* #1595: no command function for 'About...'
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1595

The fix was to createMasterMenuCallback

@language python
#@+node:ekr.20111102072143.10016: *6* LeoMenu.createMasterMenuCallback
def createMasterMenuCallback(self, command, commandName):
    """
    Create a callback for the given args.
    
    - If command is a string, it is treated as a command name.
    - Otherwise, it should be a callable representing the actual command.
    """
    c = self.c

    def getWidget():
        """Carefully return the widget that has focus."""
        w = c.frame.getFocus()
        if w and g.isMac:
            # Redirect (MacOS only).
            wname = c.widget_name(w)
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        # Return a wrapper if possible.
        if not g.isTextWrapper(w):
            w = getattr(w, 'wrapper', w)
        return w

    if isinstance(command, str):
        
        def static_menu_callback():
            event = g.app.gui.create_key_event(c, w=getWidget())
            c.doCommandByName(commandName, event)

        return static_menu_callback
        
    # The command must be a callable.
    if not callable(command):

        def dummy_menu_callback(event=None):
            pass
    
        g.trace(f"bad command: {command!r}", color='red')
        return dummy_menu_callback

    # Create a command dynamically.

    def dynamic_menu_callback():
        event = g.app.gui.create_key_event(c, w=getWidget())
        return c.doCommand(command, commandName, event)  # #1595

    return dynamic_menu_callback
#@+node:ekr.20200526073811.1: *5* #1596: executeMinibufferCommand
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1596

@language python
@nosearch
#@+node:ekr.20200526073956.1: *6* OLD: c.executeMinibufferCommand
def executeMinibufferCommand(self, commandName):
    c = self; k = c.k
    func = c.commandsDict.get(commandName)
    if func:
        event = g.app.gui.create_key_event(c)
        k.masterCommand(commandName=None, event=event, func=func)
        return k.funcReturn
    g.error(f"no such command: {commandName} {g.callers()}")
    return None
#@+node:ekr.20200522075411.1: *6* c.doCommandByName
def doCommandByName(self, command_name, event):
    """
    Execute one command, given the name of the command.
    
    The caller must do any required keystroke-only tasks.
    
    Return the result, if any, of the command.
    """
    c = self
    # Get the command's function.
    command_func = c.commandsDict.get(command_name.replace('&', ''))
    if not command_func:
        message = f"no command function for {command_name!r}"
        if g.app.unitTesting or g.app.inBridge:
            raise AttributeError(message)
        g.es_print(message, color='red')
        g.trace(g.callers())
        return None
    # Invoke the function.
    val = c.doCommand(command_func, command_name, event)
    if c.exists:
        c.frame.updateStatusLine()
    return val
#@+node:ekr.20200526074132.1: *6* c.executeMinibufferCommand
def executeMinibufferCommand(self, commandName):
    """Call c.doCommandByName, creating the required event."""
    c = self
    event = g.app.gui.create_key_event(c)
    return c.doCommandByName(commandName, event)
#@+node:ekr.20061031131434.127: *6* k.simulateCommand
def simulateCommand(self, commandName, event=None):
    """Execute a Leo command by name."""
    c = self.c
    if not event:
        # Create a default key event.
        event = g.app.gui.create_key_event(c)
    c.doCommandByName(commandName, event)
#@+node:ekr.20200615124204.1: *5* #1600: leoAst.py fails for python 3.8
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1600


class arguments(posonlyargs, args, vararg, kwonlyargs, kw_defaults, kwarg, defaults)

The arguments for a function. In Python 3:

args, posonlyargs and kwonlyargs are lists of arg nodes.

vararg and kwarg are single arg nodes, referring to the *args, **kwargs parameters.

kw_defaults is a list of default values for keyword-only arguments.
If one is None, the corresponding argument is required.

defaults is a list of default values for arguments that can be passed positionally.
If there are fewer defaults, they correspond to the last n arguments.

Changed in version 3.8: posonlyargs was introduced in Python 3.8

@language python
#@+node:ekr.20200706113629.1: *6* ----- not used
#@+node:ekr.20200706093815.1: *7* tog.FunctionType (Not used)
# -- not really an actual node but useful in Jython's typesystem.

def do_FunctionType(self, node):
    
    yield from self.gen_name(repr(node.value))
#@+node:ekr.20200706114206.1: *7* tog.NamedExpr (not used)
def do_NamedExpr(self, node):
    
    yield from self.gen_name(repr(node.value))
#@+node:ekr.20200706093430.1: *7* tog.TypeIgnore (not used)
def do_TypeIgnore(self, node):
    
    yield from self.gen_name(repr(node.value))
#@+node:ekr.20200706114007.1: *6* ----- recent
#@+node:ekr.20191227054856.1: *7* BaseTest.make_data
def make_data(self, contents, description=None):
    """Return (contents, tokens, tree) for the given contents."""
    contents = contents.lstrip('\\\n')
    if not contents:  # pragma: no cover
        return '', None, None
    t1 = get_time()
    self.update_counts('characters', len(contents))
    # Ensure all tests end in exactly one newline.
    contents = g.adjustTripleString(contents).rstrip() + '\n'
    # Create the TOG instance.
    self.tog = TokenOrderGenerator()
    self.tog.filename = description or g.callers(2).split(',')[0]
    # Pass 0: create the tokens and parse tree
    tokens = self.make_tokens(contents)
    if not tokens:  # pragma: no cover
        return '', None, None
    tree = self.make_tree(contents)
    if not tree:  # pragma: no cover
        return '', None, None
    if 0: # Sometimes useful.
        dump_contents(contents)
    if 0:  # Excellent traces for tracking down mysteries.
        dump_ast(tree)
    if 0:  # Sometimes useful.
        dump_tokens(tokens)
    self.balance_tokens(tokens)
    # Pass 1: create the links
    try:
        self.create_links(tokens, tree)
    except Exception as e:
        # self.create_links has already given the exception.
            # g.trace('BaseTest.make_data: Exception in create_links...')
            # print(e)
        assert e
        return '', None, None
    if 0:  # Sometimes useful.
        dump_tree(tokens, tree)
    if 0:  # Sometimes useful.
        dump_tokens(tokens)
    t2 = get_time()
    self.update_times('90: TOTAL', t2 - t1)
    return contents, tokens, tree
#@+node:ekr.20191113063144.26: *7* tog: Operands
#@+node:ekr.20191113063144.29: *8* tog.Attribute
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):

    yield from self.gen(node.value)
    yield from self.gen_op('.')
    yield from self.gen_name(node.attr)  # A string.
#@+node:ekr.20191113063144.30: *8* tog.Bytes
def do_Bytes(self, node):

    """
    It's invalid to mix bytes and non-bytes literals, so just
    advancing to the next 'string' token suffices.
    """
    token = self.find_next_significant_token()
    yield from self.gen_token('string', token.value)
#@+node:ekr.20191113063144.33: *8* tog.comprehension
# comprehension = (expr target, expr iter, expr* ifs, int is_async)

def do_comprehension(self, node):

    # No need to put parentheses.
    yield from self.gen(node.target)  # A name
    yield from self.gen_name('in')
    yield from self.gen(node.iter)
    for z in node.ifs or []:
        yield from self.gen_name('if')
        yield from self.gen(z)
#@+node:ekr.20191113063144.34: *8* tog.Constant
def do_Constant(self, node):  # pragma: no cover
    """
    
    https://greentreesnakes.readthedocs.io/en/latest/nodes.html
    
    A constant. The value attribute holds the Python object it represents.
    This can be simple types such as a number, string or None, but also
    immutable container types (tuples and frozensets) if all of their
    elements are constant.
    """
    
    # Support Python 3.8.
    if node.value is None or isinstance(node.value, bool):
        # Weird: return a name!
        yield from self.gen_token('name', repr(node.value))  
    elif node.value == Ellipsis:
        yield from self.gen_op('...')
    elif isinstance(node.value, str):
        yield from self.do_Str(node)
    elif isinstance(node.value, (int, float)):
        yield from self.gen_token('number', repr(node.value))
    elif isinstance(node.value, bytes):
        yield from self.do_Bytes(node)
    elif isinstance(node.value, tuple):
        yield from self.do_Tuple(node)
    elif isinstance(node.value, frozenset):
        yield from self.do_Set(node)
    else:
        # Unknown type.
        g.trace('----- Oops -----', repr(node.value), g.callers())
#@+node:ekr.20191113063144.35: *8* tog.Dict
# Dict(expr* keys, expr* values)

def do_Dict(self, node):

    assert len(node.keys) == len(node.values)
    yield from self.gen_op('{')
    # No need to put commas.
    for i, key in enumerate(node.keys):
        key, value = node.keys[i], node.values[i]
        yield from self.gen(key)  # a Str node.
        yield from self.gen_op(':')
        if value is not None:
            yield from self.gen(value)
    yield from self.gen_op('}')
#@+node:ekr.20191113063144.36: *8* tog.DictComp
# DictComp(expr key, expr value, comprehension* generators)

# d2 = {val: key for key, val in d.iteritems()}

def do_DictComp(self, node):

    yield from self.gen_token('op', '{')
    yield from self.gen(node.key)
    yield from self.gen_op(':')
    yield from self.gen(node.value)
    for z in node.generators or []:
        yield from self.gen_name('for')
        yield from self.gen(z)
        yield from self.gen_token('op', '}')
#@+node:ekr.20191113063144.37: *8* tog.Ellipsis
def do_Ellipsis(self, node):

    yield from self.gen_op('...')
#@+node:ekr.20191113063144.38: *8* tog.ExtSlice
# https://docs.python.org/3/reference/expressions.html#slicings

# ExtSlice(slice* dims)

def do_ExtSlice(self, node):

    # ','.join(node.dims)
    for i, z in enumerate(node.dims):
        yield from self.gen(z)
        if i < len(node.dims) - 1:
            yield from self.gen_op(',')
#@+node:ekr.20191113063144.40: *8* tog.Index
def do_Index(self, node):

    yield from self.gen(node.value)
#@+node:ekr.20191113063144.39: *8* tog.FormattedValue: not called!
# FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node):  # pragma: no cover
    """
    This node represents the *components* of a *single* f-string.
    
    Happily, JoinedStr nodes *also* represent *all* f-strings,
    so the TOG should *never visit this node!
    """
    filename = getattr(self, 'filename', '<no file>')
    raise AssignLinksError(
        f"file: {filename}\n"
        f"do_FormattedValue should never be called")

    # This code has no chance of being useful...

        # conv = node.conversion
        # spec = node.format_spec
        # yield from self.gen(node.value)
        # if conv is not None:
            # yield from self.gen_token('number', conv)
        # if spec is not None:
            # yield from self.gen(node.format_spec)
#@+node:ekr.20191113063144.41: *8* tog.JoinedStr & helpers
# JoinedStr(expr* values)

def do_JoinedStr(self, node):
    """
    JoinedStr nodes represent at least one f-string and all other strings
    concatentated to it.
    
    Analyzing JoinedStr.values would be extremely tricky, for reasons that
    need not be explained here.
    
    Instead, we get the tokens *from the token list itself*!
    """
    for z in self.get_concatenated_string_tokens():
        yield from self.gen_token(z.kind, z.value)
#@+node:ekr.20191113063144.42: *8* tog.List
def do_List(self, node):

    # No need to put commas.
    yield from self.gen_op('[')
    yield from self.gen(node.elts)
    yield from self.gen_op(']')
#@+node:ekr.20191113063144.43: *8* tog.ListComp
# ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node):

    yield from self.gen_op('[')
    yield from self.gen(node.elt)
    for z in node.generators:
        yield from self.gen_name('for')
        yield from self.gen(z)
    yield from self.gen_op(']')
#@+node:ekr.20191113063144.44: *8* tog.Name & NameConstant
def do_Name(self, node):

    yield from self.gen_name(node.id)

def do_NameConstant(self, node):

    yield from self.gen_name(repr(node.value))

#@+node:ekr.20191113063144.45: *8* tog.Num
def do_Num(self, node):

    yield from self.gen_token('number', node.n)
#@+node:ekr.20191113063144.47: *8* tog.Set
# Set(expr* elts)

def do_Set(self, node):

    yield from self.gen_op('{')
    yield from self.gen(node.elts)
    yield from self.gen_op('}')
#@+node:ekr.20191113063144.48: *8* tog.SetComp
# SetComp(expr elt, comprehension* generators)

def do_SetComp(self, node):

    yield from self.gen_op('{')
    yield from self.gen(node.elt)
    for z in node.generators or []:
        yield from self.gen_name('for')
        yield from self.gen(z)
    yield from self.gen_op('}')
#@+node:ekr.20191113063144.49: *8* tog.Slice
# slice = Slice(expr? lower, expr? upper, expr? step)

def do_Slice(self, node):

    lower = getattr(node, 'lower', None)
    upper = getattr(node, 'upper', None)
    step = getattr(node, 'step', None)
    if lower is not None:
        yield from self.gen(lower)
    # Always put the colon between upper and lower.
    yield from self.gen_op(':')
    if upper is not None:
        yield from self.gen(upper)
    # Put the second colon if it exists in the token list.
    if step is None:
        token = self.find_next_significant_token()
        if token and token.value == ':':
            yield from self.gen_op(':')
    else:
        yield from self.gen_op(':')
        yield from self.gen(step)
#@+node:ekr.20191113063144.50: *8* tog.Str & helper
def do_Str(self, node):
    """This node represents a string constant."""
    # This loop is necessary to handle string concatenation.
    for z in self.get_concatenated_string_tokens():
        yield from self.gen_token(z.kind, z.value)
#@+node:ekr.20200111083914.1: *9* tog.get_concatenated_tokens
def get_concatenated_string_tokens(self):
    """
    Return the next 'string' token and all 'string' tokens concatenated to
    it. *Never* update self.px here.
    """
    trace = False
    tag = 'tog.get_concatenated_string_tokens'
    i = self.px
    # First, find the next significant token.  It should be a string.
    i, token = i + 1, None
    while i < len(self.tokens):
        token = self.tokens[i]
        i += 1
        if token.kind == 'string':
            # Rescan the string.
            i -= 1
            break
        # An error.
        if is_significant_token(token):  # pragma: no cover
            break
    # Raise an error if we didn't find the expected 'string' token.
    if not token or token.kind != 'string':  # pragma: no cover
        if not token:
            token = self.tokens[-1]
        filename = getattr(self, 'filename', '<no filename>')
        raise AssignLinksError(
            f"\n"
            f"{tag}...\n"
            f"file: {filename}\n"
            f"line: {token.line_number}\n"
            f"   i: {i}\n"
            f"expected 'string' token, got {token!s}")
    # Accumulate string tokens.
    assert self.tokens[i].kind == 'string'
    results = []
    while i < len(self.tokens):
        token = self.tokens[i]
        i += 1
        if token.kind == 'string':
            results.append(token)
        elif token.kind == 'op' or is_significant_token(token):
            # Any significant token *or* any op will halt string concatenation.
            break
        # 'ws', 'nl', 'newline', 'comment', 'indent', 'dedent', etc.
    # The (significant) 'endmarker' token ensures we will have result.
    assert results
    if trace:
        g.printObj(results, tag=f"{tag}: Results")
    return results
#@+node:ekr.20191113063144.51: *8* tog.Subscript
# Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):

    yield from self.gen(node.value)
    yield from self.gen_op('[')
    yield from self.gen(node.slice)
    yield from self.gen_op(']')
#@+node:ekr.20191113063144.52: *8* tog.Tuple
# Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node):

    # Do not call gen_op for parens or commas here.
    # They do not necessarily exist in the token list!
    yield from self.gen(node.elts)
#@+node:ekr.20191113063144.34: *7* tog.Constant
def do_Constant(self, node):  # pragma: no cover
    """
    
    https://greentreesnakes.readthedocs.io/en/latest/nodes.html
    
    A constant. The value attribute holds the Python object it represents.
    This can be simple types such as a number, string or None, but also
    immutable container types (tuples and frozensets) if all of their
    elements are constant.
    """
    
    # Support Python 3.8.
    if node.value is None or isinstance(node.value, bool):
        # Weird: return a name!
        yield from self.gen_token('name', repr(node.value))  
    elif node.value == Ellipsis:
        yield from self.gen_op('...')
    elif isinstance(node.value, str):
        yield from self.do_Str(node)
    elif isinstance(node.value, (int, float)):
        yield from self.gen_token('number', repr(node.value))
    elif isinstance(node.value, bytes):
        yield from self.do_Bytes(node)
    elif isinstance(node.value, tuple):
        yield from self.do_Tuple(node)
    elif isinstance(node.value, frozenset):
        yield from self.do_Set(node)
    else:
        # Unknown type.
        g.trace('----- Oops -----', repr(node.value), g.callers())
#@+node:ekr.20191113063144.44: *7* tog.Name & NameConstant
def do_Name(self, node):

    yield from self.gen_name(node.id)

def do_NameConstant(self, node):

    yield from self.gen_name(repr(node.value))

#@+node:ekr.20200107174645.1: *7* class TestOrange (BaseTest)
class TestOrange(BaseTest):
    """
    Tests for the Orange class.
    
    **Important**: All unit tests assume that black_mode is False.
                   That is, unit tests assume that no blank lines
                   are ever inserted or deleted.
    """
    @others
#@+node:ekr.20200115201823.1: *8* TestOrange.blacken
def blacken(self, contents, line_length=None):
    """Return the results of running black on contents"""
    import warnings
    warnings.simplefilter("ignore")
    try:
        # Suppress a warning about imp being deprecated.
        with warnings.catch_warnings():
            import black
    except Exception:
        self.skipTest('Can not import black')
    # Suppress string normalization!
    try:
        mode = black.FileMode()
        mode.string_normalization = False
        if line_length is not None:
            mode.line_length = line_length
    except TypeError:
        self.skipTest('old version of black')
    return black.format_str(contents, mode=mode)
#@+node:ekr.20200228074455.1: *8* TestOrange.test_bug_1429
def test_bug_1429(self):
    
    contents = r'''\
def get_semver(tag):
    """bug 1429 docstring"""
    try:
        import semantic_version
        version = str(semantic_version.Version.coerce(tag, partial=True))
            # tuple of major, minor, build, pre-release, patch
            # 5.6b2 --> 5.6-b2
    except(ImportError, ValueError) as err:
        print('\n', err)
        print("""*** Failed to parse Semantic Version from git tag '{0}'.
        Expecting tag name like '5.7b2', 'leo-4.9.12', 'v4.3' for releases.
        This version can't be uploaded to PyPi.org.""".format(tag))
        version = tag
    return version
'''
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=0, max_split_line_length=0)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200219114415.1: *8* TestOrange.test_at_doc_part
def test_at_doc_part(self):

    line_length = 40  # For testing.
    contents = f"""\
@ Line 1
Line 2
@c

print('hi')
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200116102345.1: *8* TestOrange.test_backslash_newline
def test_backslash_newline(self):
    """
    This test is necessarily different from black, because orange doesn't
    delete semicolon tokens.
    """
    contents = r"""
print(a);\
print(b)
print(c); \
print(d)
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    # expected = self.blacken(contents).rstrip() + '\n'
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200219145639.1: *8* TestOrange.test_blank_lines_after_function
def test_blank_lines_after_function(self):

    contents = """\
# Comment line 1.
# Comment line 2.

def spam():
    pass
    # Properly indented comment.

# Comment line3.
# Comment line4.
a = 2
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200220050758.1: *8* TestOrange.test_blank_lines_after_function_2
def test_blank_lines_after_function_2(self):

    contents = """\
# Leading comment line 1.
# Leading comment lines 2.

def spam():
    pass

# Trailing comment line.
a = 2
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200220053212.1: *8* TestOrange.test_blank_lines_after_function_3
def test_blank_lines_after_function_3(self):

    # From leoAtFile.py.
    contents = r"""\
def writeAsisNode(self, p):
    print('1')

    def put(s):
        print('2')

    # Trailing comment 1.
    # Trailing comment 2.
    print('3')
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200210120455.1: *8* TestOrange.test_decorator
def test_decorator(self):

    table = (
    # Case 0.
    """\
@my_decorator(1)
def func():
    pass
""",
    # Case 1.
    """\
if 1:
    @my_decorator
    def func():
        pass
""",
    # Case 2.
    '''\
@g.commander_command('promote')
def promote(self, event=None, undoFlag=True, redrawFlag=True):
    """Make all children of the selected nodes siblings of the selected node."""
''',
    )
    for i, contents in enumerate(table):
        contents, tokens, tree = self.make_data(contents)
        expected = contents
        results = self.beautify(contents, tokens, tree)
        if results != expected:
            g.trace('Fail:', i)
        assert results == expected, expected_got(expected, results)
#@+node:ekr.20200211094614.1: *8* TestOrange.test_dont_delete_blank_lines
def test_dont_delete_blank_lines(self):

    line_length = 40  # For testing.
    contents = """\
class Test:

    def test_func():

        pass

    a = 2
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200116110652.1: *8* TestOrange.test_function_defs
def test_function_defs(self):

    table = (
    # Case 0.
    """\
def f1(a=2 + 5):
    pass
""",
    # Case 2
     """\
def f1(*args, **kwargs):
    pass
""",
    # Case 3.
    """\
def f1( *args, **kwargs ):
    pass
""",
    # Case 4.
    '''\
def should_kill_beautify(p):
    """Return True if p.b contains @killbeautify"""
    return 'killbeautify' in g.get_directives_dict(p)
''',
    )
    for i, contents in enumerate(table):
        contents, tokens, tree = self.make_data(contents)
        expected = self.blacken(contents).rstrip() + '\n'
        results = self.beautify(contents, tokens, tree)
        assert results == expected, (
            i, expected_got(expected, results))
#@+node:ekr.20200209152745.1: *8* TestOrange.test_indented_comment
def test_indented_comment(self):

    line_length = 40  # For testing.
    table = (
"""\
if 1:
    pass
        # An indented comment.
""",
"""\
table = (
    # Indented comment.
)
"""
    )

    fails = 0
    for contents in table:
        contents, tokens, tree = self.make_data(contents)
        expected = contents
        if 0:  # pragma: no cover
            dump_contents(contents)
            dump_tokens(tokens)
            # dump_tree(tokens, tree)
        results = self.beautify(contents, tokens, tree,
            max_join_line_length=line_length,
            max_split_line_length=line_length,
        )
        message = (
            f"\n"
            f"  contents: {contents!r}\n"
            f"  expected: {expected!r}\n"
            f"       got: {results!r}")
        if results != expected:  # pragma: no cover
            fails += 1
            print(f"Fail: {fails}\n{message}")
        elif 0:  # pragma: no cover
            print(f"Ok:\n{message}")
    assert not fails, fails
#@+node:ekr.20200116104031.1: *8* TestOrange.test_join_and_strip_condition
def test_join_and_strip_condition(self):

    contents = """\
if (
    a == b or
    c == d
):
    pass
"""
    expected = """\
if (a == b or c == d):
    pass
"""
    contents, tokens, tree = self.make_data(contents)
    expected = g.adjustTripleString(expected)
    # Black also removes parens, which is beyond our scope at present.
        # expected = self.blacken(contents, line_length=40)
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200208041446.1: *8* TestOrange.test_join_leading_whitespace
def test_join_leading_whitespace(self):

    line_length = 40  # For testing.
    table = (
                        #1234567890x1234567890x1234567890x1234567890x
"""\
if 1:
    print('4444',
        '5555')
""",
"""\
if 1:
    print('4444', '5555')\n""",
    )
    fails = 0
    for contents in table:
        contents, tokens, tree = self.make_data(contents)
        if 0:  # pragma: no cover
            dump_contents(contents)
            dump_tokens(tokens)
            # dump_tree(tokens, tree)
        expected = contents
        # expected = self.blacken(contents, line_length=line_length)
        results = self.beautify(contents, tokens, tree,
            max_join_line_length=line_length,
            max_split_line_length=line_length,
        )
        message = (
            f"\n"
            f"  contents: {contents!r}\n"
            f"  expected: {expected!r}\n"
            f"       got: {results!r}")
        if results != expected:  # pragma: no cover
            fails += 1
            print(f"Fail: {fails}\n{message}")
        elif 0:  # pragma: no cover
            print(f"Ok:\n{message}")
    assert not fails, fails
#@+node:ekr.20200121093134.1: *8* TestOrange.test_join_lines
def test_join_lines(self):

    # Except where noted, all entries are expected values....
    line_length = 40  # For testing.
    table = (
        #1234567890x1234567890x1234567890x1234567890x
        """print('4444',\n    '5555')""",
        """print('4444', '5555')\n""",
    )
    fails = 0
    for contents in table:
        contents, tokens, tree = self.make_data(contents)
        if 0:  # # pragma: no cover
            dump_contents(contents)
            dump_tokens(tokens)
            # dump_tree(tokens, tree)
        expected = contents
        results = self.beautify(contents, tokens, tree,
            max_join_line_length=line_length,
            max_split_line_length=line_length,
        )
        message = (
            f"\n"
            f"  contents: {contents!r}\n"
            f"  expected: {expected!r}\n"
            f"    orange: {results!r}")
        if results != expected:  # pragma: no cover
            fails += 1
            print(f"Fail: {fails}\n{message}")
        elif 0:  # pragma: no cover
            print(f"Ok:\n{message}")
    assert fails == 0, fails
#@+node:ekr.20200210051900.1: *8* TestOrange.test_join_suppression
def test_join_suppression(self):

    contents = """\
class T:
    a = 1
    print(
       a
    )
"""
    expected = """\
class T:
    a = 1
    print(a)
"""
    contents, tokens, tree = self.make_data(contents)
    expected = g.adjustTripleString(expected)
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200207093606.1: *8* TestOrange.test_join_too_long_lines
def test_join_too_long_lines(self):

    # Except where noted, all entries are expected values....
    line_length = 40  # For testing.
    table = (
                        #1234567890x1234567890x1234567890x1234567890x
        (
            """print('aaaaaaaaaaaa',\n    'bbbbbbbbbbbb', 'cccccccccccccccc')""",
            """print('aaaaaaaaaaaa',\n    'bbbbbbbbbbbb', 'cccccccccccccccc')\n""",
        ),
    )
    fails = 0
    for contents, expected in table:
        contents, tokens, tree = self.make_data(contents)
        if 0:  # verbose_fail:  # pragma: no cover
            dump_contents(contents)
            dump_tokens(tokens)
            # dump_tree(tokens, tree)
        results = self.beautify(contents, tokens, tree,
            max_join_line_length=line_length,
            max_split_line_length=line_length,
        )
        message = (
            f"\n"
            f"  contents: {contents!r}\n"
            f"  expected: {expected!r}\n"
            f"       got: {results!r}")
        if results != expected:  # pragma: no cover
            fails += 1
            print(f"Fail: {fails}\n{message}")
        elif 0:  # pragma: no cover
            print(f"Ok:\n{message}")
    assert not fails, fails
#@+node:ekr.20200108075541.1: *8* TestOrange.test_leo_sentinels
def test_leo_sentinels_1(self):

    # Careful: don't put a sentinel into the file directly.
    # That would corrupt leoAst.py.
    sentinel = '#@+node:ekr.20200105143308.54: ** test'
    contents = f"""\
{sentinel}
def spam():
    pass
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200209155457.1: *8* TestOrange.test_leo_sentinels_2
def test_leo_sentinels_2(self):

    # Careful: don't put a sentinel into the file directly.
    # That would corrupt leoAst.py.
    sentinel = '#@+node:ekr.20200105143308.54: ** test'
    contents = f"""\
{sentinel}
class TestClass:
    pass
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200108082833.1: *8* TestOrange.test_lines_before_class
def test_lines_before_class(self):

    contents = """\
a = 2
class aClass:
    pass
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200110014220.86: *8* TestOrange.test_multi_line_pet_peeves
def test_multi_line_pet_peeves(self):

    contents = """\
if x == 4: pass
if x == 4 : pass
print (x, y); x, y = y, x
print (x , y) ; x , y = y , x
if(1):
    pass
elif(2):
    pass
while(3):
    pass
"""
    # At present Orange doesn't split lines...
    expected = """\
if x == 4: pass
if x == 4: pass
print(x, y); x, y = y, x
print(x, y); x, y = y, x
if (1):
    pass
elif (2):
    pass
while (3):
    pass
"""
    contents, tokens, tree = self.make_data(contents)
    expected = self.adjust_expected(expected)
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200110014220.95: *8* TestOrange.test_one_line_pet_peeves
def test_one_line_pet_peeves(self):

    tag = 'test_one_line_pet_peeves'
    verbose_pass = False
    verbose_fail = True
    # Except where noted, all entries are expected values....
    if 0:
        # Test fails or recents...
        table = (
            # """a[: 1 if True else 2 :]""",
            """a[:-1]""",
        )
    else:
        table = (
            # Assignments...
            # Slices (colons)...
            """a[:-1]""",
            """a[: 1 if True else 2 :]""",
            """a[1 : 1 + 2]""",
            """a[lower:]""",
            """a[lower::]""",
            """a[:upper]""",
            """a[:upper:]""",
            """a[::step]""",
            """a[lower:upper:]""",
            """a[lower:upper:step]""",
            """a[lower + offset : upper + offset]""",
            """a[: upper_fn(x) :]""",
            """a[: upper_fn(x) : step_fn(x)]""",
            """a[:: step_fn(x)]""",
            """a[: upper_fn(x) :]""",
            """a[: upper_fn(x) : 2 + 1]""",
            """a[:]""",
            """a[::]""",
            """a[1:]""",
            """a[1::]""",
            """a[:2]""",
            """a[:2:]""",
            """a[::3]""",
            """a[1:2]""",
            """a[1:2:]""",
            """a[:2:3]""",
            """a[1:2:3]""",
            # * and **, inside and outside function calls.
            """a = b * c""",
            """a = b ** c""",
            """f(*args)""",
            """f(**kwargs)""",
            """f(*args, **kwargs)""",
            """f(a, *args)""",
            """f(a=2, *args)""",
            # Calls...
            """f(-1)""",
            """f(-1 < 2)""",
            """f(1)""",
            """f(2 * 3)""",
            """f(2 + name)""",
            """f(a)""",
            """f(a.b)""",
            """f(a=2 + 3, b=4 - 5, c= 6 * 7, d=8 / 9, e=10 // 11)""",
            """f(a[1 + 2])""",
            """f({key: 1})""",
            """t = (0,)""",
            """x, y = y, x""",
            # Dicts...
            """d = {key: 1}""",
            """d['key'] = a[i]""",
            # Trailing comments: expect two spaces.
            """whatever # comment""",
            """whatever  # comment""",
            """whatever   # comment""",
            # Word ops...
            """v1 = v2 and v3 if v3 not in v4 or v5 in v6 else v7""",
            """print(v7 for v8 in v9)""",
            # Unary ops...
            """v = -1 if a < b else -2""",
            # Returns...
            """return -1""",
        )
    fails = 0
    for i, contents in enumerate(table):
        description = f"{tag} part {i}"
        contents, tokens, tree = self.make_data(contents, description)
        expected = self.blacken(contents)
        results = self.beautify(contents, tokens, tree, filename=description)
        message = (
            f"\n"
            f"  contents: {contents.rstrip()}\n"
            f"     black: {expected.rstrip()}\n"
            f"    orange: {results.rstrip()}")
        if results != expected:  # pragma: no cover
            fails += 1
            if verbose_fail:
                print(f"Fail: {fails}\n{message}")
        elif verbose_pass:  # pragma: no cover
            print(f"Ok:\n{message}")
    assert fails == 0, fails
#@+node:ekr.20200210050646.1: *8* TestOrange.test_return
def test_return(self):

    contents = """return []"""
    expected = self.blacken(contents)
    contents, tokens, tree = self.make_data(contents)
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200107174742.1: *8* TestOrange.test_single_quoted_string
def test_single_quoted_string(self):

    contents = """print('hi')"""
    # blacken suppresses string normalization.
    expected = self.blacken(contents)
    contents, tokens, tree = self.make_data(contents)
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200117180956.1: *8* TestOrange.test_split_lines
def test_split_lines(self):

    line_length = 40  # For testing.
    table = (
    #1234567890x1234567890x1234567890x1234567890x
        """\
if 1:
    print('1111111111', '2222222222', '3333333333')
""",
"""print('aaaaaaaaaaaaa', 'bbbbbbbbbbbbbb', 'cccccc')""",
"""print('aaaaaaaaaaaaa', 'bbbbbbbbbbbbbb', 'cccccc', 'ddddddddddddddddd')""",
    )
    fails = 0
    for contents in table:
        contents, tokens, tree = self.make_data(contents)
        if 0:  # verbose_fail:  # pragma: no cover
            dump_tokens(tokens)
            # dump_tree(tokens, tree)
        expected = self.blacken(contents, line_length=line_length)
        results = self.beautify(contents, tokens, tree,
            max_join_line_length=line_length,
            max_split_line_length=line_length,
        )
        message = (
            f"\n"
            f"  contents: {contents!s}\n"
            f"     black: {expected!s}\n"
            f"    orange: {results!s}")
        if results != expected:  # pragma: no cover
            fails += 1
            print(f"Fail: {fails}\n{message}")
        elif 0:  # pragma: no cover
            print(f"Ok:\n{message}")
    assert fails == 0, fails
#@+node:ekr.20200210073227.1: *8* TestOrange.test_split_lines_2
def test_split_lines_2(self):

    line_length = 40  # For testing.
    # Different from how black handles things.
    contents = """\
if not any([z.kind == 'lt' for z in line_tokens]):
    return False
"""
    expected = """\
if not any(
    [z.kind == 'lt' for z in line_tokens]):
    return False
"""
    fails = 0
    contents, tokens, tree = self.make_data(contents)
    # expected = self.blacken(contents, line_length=line_length)
    expected = g.adjustTripleString(expected)
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    message = (
        f"\n"
        f"  contents: {contents!r}\n"
        f"  expected: {expected!r}\n"
        f"       got: {results!r}")
    if results != expected:  # pragma: no cover
        fails += 1
        print(f"Fail: {fails}\n{message}")
    elif 0:  # pragma: no cover
        print(f"Ok:\n{message}")
    assert fails == 0, fails
#@+node:ekr.20200219144837.1: *8* TestOrange.test_split_lines_3
def test_split_lines_3(self):

    line_length = 40  # For testing.
    # Different from how black handles things.
    contents = """print('eee', ('fffffff, ggggggg', 'hhhhhhhh', 'iiiiiii'), 'jjjjjjj', 'kkkkkk')"""
    # This is a bit different from black, but it's good enough for now.
    expected = """\
print(
    'eee',
    ('fffffff, ggggggg', 'hhhhhhhh', 'iiiiiii'),
    'jjjjjjj',
    'kkkkkk',
)
"""
    fails = 0
    contents, tokens, tree = self.make_data(contents)
    # expected = self.blacken(contents, line_length=line_length)
    expected = g.adjustTripleString(expected)
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    message = (
        f"\n"
        f"  contents: {contents!r}\n"
        f"  expected: {expected!r}\n"
        f"       got: {results!r}")
    if results != expected:  # pragma: no cover
        fails += 1
        print(f"Fail: {fails}\n{message}")
    elif 0:  # pragma: no cover
        print(f"Ok:\n{message}")
    assert fails == 0, fails
#@+node:ekr.20200119155207.1: *8* TestOrange.test_sync_tokens
def test_sync_tokens(self):

    contents = """if x == 4: pass"""
    # At present Orange doesn't split lines...
    expected = """if x == 4: pass"""
    contents, tokens, tree = self.make_data(contents)
    expected = self.adjust_expected(expected)
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200209161226.1: *8* TestOrange.test_ternary
def test_ternary(self):

    contents = """print(2 if name == 'class' else 1)"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200211093359.1: *8* TestOrange.test_verbatim
def test_verbatim(self):

    line_length = 40  # For testing.
    contents = """\
@nobeautify
    
def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    add_bool('--diff',          'use Leo as an external git diff')
    # add_bool('--dock',          'use a Qt dock')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--init-docks',    'put docks in default positions')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
        
# From leoAtFile.py
noDirective     =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective    =  3 # @doc.
        
@beautify
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    # g.printObj(g.splitLines(results))
    message = (
        f"\n"
        f"contents: {contents}\n"
        f"expected: {expected!r}\n"
        f"  orange: {results!r}")
    assert results == expected, message
#@+node:ekr.20200729083027.1: *8* TestOrange.verbatim2
def test_verbatim2(self):
    
    contents = """\
@beautify
@nobeautify
@ Starts doc part
More doc part.
The @c ends the doc part.
@c
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    message = (
        f"\n"
        f"contents: {contents}\n"
        f"expected: {expected!r}\n"
        f"  orange: {results!r}")
    assert results == expected, message
#@+node:ekr.20200211094209.1: *8* TestOrange.test_verbatim_with_pragma
def test_verbatim_with_pragma(self):

    line_length = 40  # For testing.
    contents = """\
#pragma: no beautify
    
def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    add_bool('--diff',          'use Leo as an external git diff')
    # add_bool('--dock',          'use a Qt dock')
    add_bool('--fullscreen',    'start fullscreen')
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
        
# pragma: beautify
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    message = (
        f"\n"
        f"contents: {contents}\n"
        f"expected: {expected!r}\n"
        f"  orange: {results!r}")
    assert results == expected, message
#@+node:ekr.20160521103254.1: *6* TT.test_visitors_exist
def test_visitors_exist(self):
    """Ensure that visitors for all ast nodes exist."""
    import _ast
    # Compute all fields to BaseTest.
    aList = sorted(dir(_ast))
    remove = [
        'Interactive', # Not necessary.
        'Suite',  # Not necessary.
        'PyCF_ONLY_AST',  # A constant,
        'AST',  # The base class,
        # Python 3.8: Not node types.
        'PyCF_ALLOW_TOP_LEVEL_AWAIT',
        'PyCF_TYPE_COMMENTS',
        # Python 3.8: Maybe not node types. Not properly documented...
        'FunctionType', 'NamedExpr', 'TypeIgnore',
    ]
    aList = [z for z in aList if not z[0].islower()]
        # Remove base classes.
    aList = [z for z in aList
        if not z.startswith('_') and not z in remove]
    # Now test them.
    table = (
        TokenOrderGenerator,
    )
    for class_ in table:
        traverser = class_()
        errors, nodes, ops = 0, 0, 0
        for z in aList:
            if hasattr(traverser, 'do_' + z):
                nodes += 1
            elif _op_names.get(z):
                ops += 1
            else:  # pragma: no cover
                errors += 1
                print(
                    f"Missing visitor: "
                    f"{traverser.__class__.__name__}.{z}")
    msg = f"{nodes} node types, {ops} op types, {errors} errors"
    assert not errors, msg
#@+node:ekr.20191113063144.34: *6* tog.Constant
def do_Constant(self, node):  # pragma: no cover
    """
    
    https://greentreesnakes.readthedocs.io/en/latest/nodes.html
    
    A constant. The value attribute holds the Python object it represents.
    This can be simple types such as a number, string or None, but also
    immutable container types (tuples and frozensets) if all of their
    elements are constant.
    """
    
    # Support Python 3.8.
    if node.value is None or isinstance(node.value, bool):
        # Weird: return a name!
        yield from self.gen_token('name', repr(node.value))  
    elif node.value == Ellipsis:
        yield from self.gen_op('...')
    elif isinstance(node.value, str):
        yield from self.do_Str(node)
    elif isinstance(node.value, (int, float)):
        yield from self.gen_token('number', repr(node.value))
    elif isinstance(node.value, bytes):
        yield from self.do_Bytes(node)
    elif isinstance(node.value, tuple):
        yield from self.do_Tuple(node)
    elif isinstance(node.value, frozenset):
        yield from self.do_Set(node)
    else:
        # Unknown type.
        g.trace('----- Oops -----', repr(node.value), g.callers())
#@+node:ekr.20200617103011.1: *5* #1602: ts coloring
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1602

@language python
#@+node:ekr.20190324050727.1: *6* bjc.init_style_ivars
def init_style_ivars(self):
    """Init Style data common to JEdit and Pygments colorizers."""
    # init() properly sets these for each language.
    self.actualColorDict = {}  # Used only by setTag.
    self.hyperCount = 0
    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Debugging...
    self.allow_mark_prev = True
    self.n_setTag = 0
    self.tagCount = 0
    self.trace_leo_matches = False
    self.trace_match_flag = False
    # Profiling...
    self.recolorCount = 0  # Total calls to recolor
    self.stateCount = 0  # Total calls to setCurrentState
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.initLanguage = None
    self.prev = None  # The previous token.
    self.fonts = {}  # Keys are config names.  Values are actual fonts.
    self.keywords = {}  # Keys are keywords, values are 0..5.
        # Keys are state ints, values are language names.
    self.modes = {}  # Keys are languages, values are modes.
    self.mode = None  # The mode object for the present language.
    self.modeBunch = None  # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {}  # Inited by init_keywords().
    self.tags = [
        # 8 Leo-specific tags.
        "blank",  # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab",  # show_invisibles_space_color
        "url",
        # jEdit tags.
        'comment1', 'comment2', 'comment3', 'comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1', 'keyword2', 'keyword3', 'keyword4',
        'label', 'literal1', 'literal2', 'literal3', 'literal4',
        'markup', 'operator',
        'trailing_whitespace',
    ]
#@+node:ekr.20110605121601.18622: *6* jedit.match_span & helper & restarter
def match_span(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False
):
    """Succeed if s[i:] starts with 'begin' and contains a following 'end'."""
    dots = False  # A flag that we are using dots as a continuation.
    if i >= len(s):
        return 0
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i > 0 and s[i - 1] in self.word_chars:
        j = i
    elif at_word_start and i + len(
        begin) + 1 < len(s) and s[i + len(begin)] in self.word_chars:
        j = i
    elif not g.match(s, i, begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s, i + len(begin), end,
            no_escape, no_line_break, no_word_break=no_word_break)
        if j == -1:
            j = i  # A real failure.
        else:
            # A hack to handle continued strings. Should work for most languages.
            # Prepend "dots" to the kind, as a flag to setTag.
            dots = j > len(
                s) and begin in "'\"" and end in "'\"" and kind.startswith('literal')
            dots = dots and self.language not in ('lisp', 'elisp', 'rust')
            if dots:
                kind = 'dots' + kind
            # A match
            i2 = i + len(begin); j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(
                    s, i, i2, kind, delegate=None, exclude_match=exclude_match)
                self.colorRangeWithTag(
                    s, i2, j, kind, delegate=delegate, exclude_match=exclude_match)
                self.colorRangeWithTag(
                    s, j, j2, kind, delegate=None, exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(
                    s, i, j2, kind, delegate=None, exclude_match=exclude_match)
            j = j2
            self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    # New in Leo 5.5: don't recolor everything after continued strings.
    if j > len(s) and not dots:
        j = len(s) + 1

        def span(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keyword args.
            delegate=delegate, end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    return j - i  # Correct, whatever j is.
#@+node:ekr.20110605121601.18623: *7* jedit.match_span_helper
def match_span_helper(self, s, i, pattern, no_escape, no_line_break, no_word_break):
    """
    Return n >= 0 if s[i] ends with a non-escaped 'end' string.
    """
    esc = self.escape
    # pylint: disable=inconsistent-return-statements
    while 1:
        j = s.find(pattern, i)
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            return len(s) + 1
        if no_word_break and j > 0 and s[j - 1] in self.word_chars:
            return -1  # New in Leo 4.5.
        if no_line_break and '\n' in s[i:j]:
            return -1
        if esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k >= 0 and s[j - k] == esc:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                assert s[j - 1] == esc
                i += 1  # 2013/08/26: just advance past the *one* escaped character.
            else:
                return j
        else:
            return j
    # For pylint.
    return -1
#@+node:ekr.20110605121601.18624: *7* jedit.restart_match_span
def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    """Remain in this state until 'end' is seen."""
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else:  # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j > len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j  # Return the new i, *not* the length of the match.
#@+node:ekr.20200618113036.1: *5* #1603: exit after refresh-from-disk
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1603

@language python
#@+node:ekr.20200618112042.1: *6* Serious crasher
# Refresh-from-disk with a directory


readFileIntoString not a file: C:/Users/edreamleo/RustProjects/hello_cargo/src

Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\leo\plugins\contextmenu.py", line 332, in refresh_rclick_cb
    c.refreshFromDisk()
  File "c:\leo.repo\leo-editor\leo\commands\commanderFileCommands.py", line 305, in refreshFromDisk
    p = at.readOneAtAutoNode(fn, p)
  File "c:\leo.repo\leo-editor\leo\core\leoAtFile.py", line 597, in readOneAtAutoNode
    c.persistenceController.update_after_read_foreign_file(p)
  File "c:\leo.repo\leo-editor\leo\core\leoPersistence.py", line 126, in update_after_read_foreign_file
    if not self.is_foreign_file(root):
  File "c:\leo.repo\leo-editor\leo\core\leoPersistence.py", line 461, in is_foreign_file
    self.is_at_auto_node(p) or
  File "c:\leo.repo\leo-editor\leo\core\leoPersistence.py", line 448, in is_at_auto_node
    return p.isAtAutoNode()
AttributeError: 'NoneType' object has no attribute 'isAtAutoNode'

c:\leo.repo\leo-editor>
#@+node:ekr.20200618112835.1: *6* Another error
can not open C:/Users/edreamleo/RustProjects/hello_cargo/src
g.toUnicode: unexpected argument of type NoneType
toUnicode readAll,readFileAtPosition,readOneAtCleanNode,read_at_clean_lines

#@+node:ekr.20140711111623.17807: *6* pd.update_after_read_foreign_file & helpers
def update_after_read_foreign_file(self, root):
    """Restore gnx's, uAs and clone links using @gnxs nodes and @uas trees."""
    self.at_persistence = self.find_at_persistence_node()
    if not self.at_persistence:
        return
    if not root:
        return
    if not self.is_foreign_file(root):
        return
    # Create clone links from @gnxs node
    at_gnxs = self.has_at_gnxs_node(root)
    if at_gnxs:
        self.restore_gnxs(at_gnxs, root)
    # Create uas from @uas tree.
    at_uas = self.has_at_uas_node(root)
    if at_uas:
        self.create_uas(at_uas, root)
#@+node:ekr.20140711111623.17810: *7* pd.restore_gnxs & helpers
def restore_gnxs(self, at_gnxs, root):
    """
    Recreate gnx's and clone links from an @gnxs node.
    @gnxs nodes contain pairs of lines:
        gnx:<gnx>
        unl:<unl>
    """
    lines = g.splitLines(at_gnxs.b)
    gnxs = [s[4:].strip() for s in lines if s.startswith('gnx:')]
    unls = [s[4:].strip() for s in lines if s.startswith('unl:')]
    if len(gnxs) == len(unls):
        d = self.create_outer_gnx_dict(root)
        for gnx, unl in zip(gnxs, unls):
            self.restore_gnx(d, gnx, root, unl)
    else:
        g.trace('bad @gnxs contents', gnxs, unls)
#@+node:ekr.20141021083702.18341: *8* pd.create_outer_gnx_dict
def create_outer_gnx_dict(self, root):
    """
    Return a dict whose keys are gnx's and whose values are positions
    **outside** of root's tree.
    """
    c, d = self.c, {}
    p = c.rootPosition()
    while p:
        if p.v == root.v:
            p.moveToNodeAfterTree()
        else:
            gnx = p.v.fileIndex
            d[gnx] = p.copy()
            p.moveToThreadNext()
    return d
#@+node:ekr.20140711111623.17809: *8* pd.restore_gnx
def restore_gnx(self, d, gnx, root, unl):
    """
    d is an *outer* gnx dict, associating nodes *outside* the tree with positions.
    Let p1 be the position of the node *within* root's tree corresponding to unl.
    Let p2 be the position of any node *outside* root's tree with the given gnx.
    - Set p1.v.fileIndex = gnx.
    - If p2 exists, relink p1 so it is a clone of p2.
    """
    p1 = self.find_position_for_relative_unl(root, unl)
    if not p1:
        return
    p2 = d.get(gnx)
    if p2:
        if p1.h == p2.h and p1.b == p2.b:
            p1._relinkAsCloneOf(p2)
            # Warning: p1 *no longer exists* here.
            # _relinkAsClone does *not* set p1.v = p2.v.
        else:
            g.es_print('mismatch in cloned node', p1.h)
    else:
        # Fix #526: A major bug: this was not set!
        p1.v.fileIndex = gnx
    g.app.nodeIndices.updateLastIndex(g.toUnicode(gnx))
#@+node:ekr.20140711111623.17892: *7* pd.create_uas
def create_uas(self, at_uas, root):
    """Recreate uA's from the @ua nodes in the @uas tree."""
    # Create an *inner* gnx dict.
    # Keys are gnx's, values are positions *within* root's tree.
    d = {}
    for p in root.self_and_subtree(copy=False):
        d[p.v.gnx] = p.copy()
    # Recreate the uA's for the gnx's given by each @ua node.
    for at_ua in at_uas.children():
        h, b = at_ua.h, at_ua.b
        gnx = h[4:].strip()
        if b and gnx and g.match_word(h, 0, '@ua'):
            p = d.get(gnx)
            if p:
                # Handle all recent variants of the node.
                lines = g.splitLines(b)
                if b.startswith('unl:') and len(lines) == 2:
                    # pylint: disable=unbalanced-tuple-unpacking
                    unl, ua = lines
                else:
                    unl, ua = None, b
                if ua.startswith('ua:'):
                    ua = ua[3:]
                if ua:
                    ua = self.unpickle(ua)
                    p.v.u = ua
                else:
                    g.trace('Can not unpickle uA in',
                        p.h, repr(unl), type(ua), ua[:40])
#@+node:ekr.20130911110233.11285: *6* at.openFileHelper
def openFileHelper(self, fileName):
    """Open a file, reporting all exceptions."""
    at = self
    s = ''
    try:
        with open(fileName, 'rb') as f:
            s = f.read()
    except IOError:
        at.error(f"can not open {fileName}")
    except Exception:
        at.error(f"Exception reading {fileName}")
        g.es_exception()
    return s
#@+node:ekr.20140717074441.17772: *6* c_file.refreshFromDisk
# refresh_pattern = re.compile(r'^(@[\w-]+)')

@g.commander_command('refresh-from-disk')
def refreshFromDisk(self, event=None):
    """Refresh an @<file> node from disk."""
    c, p, u = self, self.p, self.undoer
    c.nodeConflictList = []
    fn = p.anyAtFileNodeName()
    shouldDelete = c.sqlite_connection is None
    if not fn:
        g.warning(f"not an @<file> node: {p.h!r}")
        return
    # #1603.
    if os.path.isdir(fn):
        g.warning(f"not a file: {fn!r}")
        return
    b = u.beforeChangeTree(p)
    redraw_flag = True
    at = c.atFileCommands
    c.recreateGnxDict()
        # Fix bug 1090950 refresh from disk: cut node ressurection.
    i = g.skip_id(p.h, 0, chars='@')
    word = p.h[0:i]
    if word == '@auto':
        # This includes @auto-*
        if shouldDelete: p.v._deleteAllChildren()
        # Fix #451: refresh-from-disk selects wrong node.
        p = at.readOneAtAutoNode(fn, p)
    elif word in ('@thin', '@file'):
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True)
    elif word == '@clean':
        # Wishlist 148: use @auto parser if the node is empty.
        if p.b.strip() or p.hasChildren():
            at.readOneAtCleanNode(p)
        else:
            # Fix #451: refresh-from-disk selects wrong node.
            p = at.readOneAtAutoNode(fn, p)
    elif word == '@shadow':
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True, atShadow=True)
    elif word == '@edit':
        at.readOneAtEditNode(fn, p)
            # Always deletes children.
    elif word == '@asis':
        # Fix #1067.
        at.readOneAtAsisNode(fn, p)
            # Always deletes children.
    else:
        g.es_print(f"can not refresh from disk\n{p.h!r}")
        redraw_flag = False
    if redraw_flag:
        # Fix #451: refresh-from-disk selects wrong node.
        c.selectPosition(p)
        u.afterChangeTree(p, command='refresh-from-disk', bunch=b)
        # Create the 'Recovered Nodes' tree.
        c.fileCommands.handleNodeConflicts()
        c.redraw()
#@+node:ekr.20200619071053.1: *5* #1605: (x.rs) in headlines
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1605

- A kwargs to c.recursiveImport to override
  - @bool add-context-to-headline
  - @bool add-file context-to-headline

These two settings are used only in Importer.add_class_names.

@language python
#@+node:ekr.20130823083943.12596: *6* class RecursiveImportController
class RecursiveImportController:
    """Recursively import all python files in a directory and clean the result."""
    @others
#@+node:ekr.20130823083943.12615: *7* ric.ctor
def __init__(self, c, kind,
    # force_at_others = False, #tag:no-longer-used
    add_context=None,  # Override setting only if True/False
    add_file_context=None,  # Override setting only if True/False
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    ignore_pattern=None,
):
    """Ctor for RecursiveImportController class."""
    self.c = c
    self.add_path = add_path
    self.file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    self.kind = kind
        # in ('@auto', '@clean', '@edit', '@file', '@nosent')
    # self.force_at_others = force_at_others #tag:no-longer-used
    self.recursive = recursive
    self.root = None
    self.safe_at_file = safe_at_file
    self.theTypes = theTypes
    self.ignore_pattern = ignore_pattern or re.compile(r'\.git|node_modules')
    # #1605:

    def set_bool(setting, val):
        if val not in (True, False):
            return
        c.config.set(None, 'bool', setting, val, warn=True)
        
    set_bool('add-context-to-headlines', add_context)
    set_bool('add-file-context-to-headlines', add_file_context)
#@+node:ekr.20130823083943.12613: *7* ric.run & helpers
def run(self, dir_):
    """
    Import all files whose extension matches self.theTypes in dir_.
    In fact, dir_ can be a path to a single file.
    """
    if self.kind not in ('@auto', '@clean', '@edit', '@file', '@nosent'):
        g.es('bad kind param', self.kind, color='red')
    try:
        c = self.c
        p1 = self.root = c.p
        t1 = time.time()
        g.app.disable_redraw = True
        bunch = c.undoer.beforeChangeTree(p1)
        # Leo 5.6: Always create a new last top-level node.
        last = c.lastTopLevel()
        parent = last.insertAfter()
        parent.v.h = 'imported files'
        # Leo 5.6: Special case for a single file.
        self.n_files = 0
        if g.os_path_isfile(dir_):
            g.es_print('\nimporting file:', dir_)
            self.import_one_file(dir_, parent)
        else:
            self.import_dir(dir_, parent)
        self.post_process(parent, dir_)
            # Fix # 1033.
        c.undoer.afterChangeTree(p1, 'recursive-import', bunch)
    except Exception:
        g.es_print('Exception in recursive import')
        g.es_exception()
    finally:
        g.app.disable_redraw = False
        for p2 in parent.self_and_subtree(copy=False):
            p2.contract()
        c.redraw(parent)
    t2 = time.time()
    n = len(list(parent.self_and_subtree()))
    g.es_print(
        f"imported {n} node{g.plural(n)} "
        f"in {self.n_files} file{g.plural(self.n_files)} "
        f"in {t2 - t1:2.2f} seconds")
#@+node:ekr.20130823083943.12597: *8* ric.import_dir
def import_dir(self, dir_, parent):
    """Import selected files from dir_, a directory."""
    if g.os_path_isfile(dir_):
        files = [dir_]
    else:
        g.es_print('importing directory:', dir_)
        files = os.listdir(dir_)
    dirs, files2 = [], []
    for path in files:
        try:
            # Fix #408. Catch path exceptions.
            # The idea here is to keep going on small errors.
            path = g.os_path_join(dir_, path)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(path)
                if ext in self.theTypes:
                    files2.append(path)
            elif self.recursive:
                if not self.ignore_pattern.search(path):
                    dirs.append(path)
        except OSError:
            g.es_print('Exception computing', path)
            g.es_exception()
    if files or dirs:
        assert parent and parent.v != self.root.v, g.callers()
        parent = parent.insertAsLastChild()
        parent.v.h = dir_
        if files2:
            for f in files2:
                if not self.ignore_pattern.search(f):
                    self.import_one_file(f, parent=parent)
        if dirs:
            assert self.recursive
            for dir_ in sorted(dirs):
                self.import_dir(dir_, parent)
#@+node:ekr.20170404103953.1: *8* ric.import_one_file
def import_one_file(self, path, parent):
    """Import one file to the last top-level node."""
    c = self.c
    self.n_files += 1
    assert parent and parent.v != self.root.v, g.callers()
    if self.kind == '@edit':
        p = parent.insertAsLastChild()
        p.v.h = path.replace('\\', '/')
        s, e = g.readFileIntoString(path, kind=self.kind)
        p.v.b = s
        return
    # #1484: Use this for @auto as well.
    c.importCommands.importFilesCommand(
        files=[path],
        parent=parent,
        redrawFlag=False,
        shortFn=True,
        treeType='@file',  # '@auto','@clean','@nosent' cause problems.
    )
    p = parent.lastChild()
    p.h = self.kind + p.h[5:]
        # Bug fix 2017/10/27: honor the requested kind.
    if self.safe_at_file:
        p.v.h = '@' + p.v.h
#@+node:ekr.20130823083943.12607: *8* ric.post_process & helpers
def post_process(self, p, prefix):
    """
    Traverse p's tree, replacing all nodes that start with prefix
    by the smallest equivalent @path or @file node.
    """
    self.fix_back_slashes(p)
    prefix = prefix.replace('\\', '/')
    if self.kind not in ('@auto', '@edit'):
        self.remove_empty_nodes(p)
    if p.firstChild():
        self.minimize_headlines(p.firstChild(), prefix)
    self.clear_dirty_bits(p)
    self.add_class_names(p)
#@+node:ekr.20180524100258.1: *9* ric.add_class_names
def add_class_names(self, p):
    """Add class names to headlines for all descendant nodes."""
    # pylint: disable=no-else-continue
    after, class_name = None, None
    class_paren_pattern = re.compile(r'(.*)\(.*\)\.(.*)')
    paren_pattern = re.compile(r'(.*)\(.*\.py\)')
    for p in p.self_and_subtree(copy=False):
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            # prefix = m.group(1)
            # fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        elif p.h.startswith('@path '):
            after, class_name = None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if p.h.startswith(class_name):
                m = class_paren_pattern.match(p.h)
                if m:
                    p.h = f"{m.group(1)}.{m.group(2)}".rstrip()
            else:
                p.h = f"{class_name}.{p.h}"
        else:
            m = paren_pattern.match(p.h)
            if m:
                p.h = m.group(1).rstrip()
        # elif fn:
            # tag = ' (%s)' % fn
            # if not p.h.endswith(tag):
                # p.h += tag
#@+node:ekr.20130823083943.12608: *9* ric.clear_dirty_bits
def clear_dirty_bits(self, p):
    c = self.c
    c.clearChanged()  # Clears *all* dirty bits.
    for p in p.self_and_subtree(copy=False):
        p.clearDirty()
#@+node:ekr.20130823083943.12609: *9* ric.dump_headlines
def dump_headlines(self, p):
    # show all headlines.
    for p in p.self_and_subtree(copy=False):
        print(p.h)
#@+node:ekr.20130823083943.12610: *9* ric.fix_back_slashes
def fix_back_slashes(self, p):
    """Convert backslash to slash in all headlines."""
    for p in p.self_and_subtree(copy=False):
        s = p.h.replace('\\', '/')
        if s != p.h:
            p.v.h = s
#@+node:ekr.20130823083943.12611: *9* ric.minimize_headlines & helper
def minimize_headlines(self, p, prefix):
    """Create @path nodes to minimize the paths required in descendant nodes."""
    if prefix and not prefix.endswith('/'):
        prefix = prefix + '/'
    m = self.file_pattern.match(p.h)
    if m:
        # It's an @file node of some kind. Strip off the prefix.
        kind = m.group(0)
        path = p.h[len(kind) :].strip()
        stripped = self.strip_prefix(path, prefix)
        p.h = f"{kind} {stripped or path}"
        # Put the *full* @path directive in the body.
        if self.add_path and prefix:
            tail = g.os_path_dirname(stripped).rstrip('/')
            p.b = f"@path {prefix}{tail}\n{p.b}"
    else:
        # p.h is a path.
        path = p.h
        stripped = self.strip_prefix(path, prefix)
        p.h = f"@path {stripped or path}"
        for p in p.children():
            self.minimize_headlines(p, prefix + stripped)
#@+node:ekr.20170404134052.1: *10* ric.strip_prefix
def strip_prefix(self, path, prefix):
    """Strip the prefix from the path and return the result."""
    if path.startswith(prefix):
        return path[len(prefix) :]
    return ''  # A signal.
#@+node:ekr.20130823083943.12612: *9* ric.remove_empty_nodes
def remove_empty_nodes(self, p):
    """Remove empty nodes. Not called for @auto or @edit trees."""
    c = self.c
    aList = [
        p2 for p2 in p.self_and_subtree()
            if not p2.b and not p2.hasChildren()]
    if aList:
        c.deletePositionsInList(aList, redraw=False)
#@+node:ekr.20130823083943.12559: *6* c.recursiveImport
def recursiveImport(self, dir_, kind,
    add_context=None,  # Override setting only if True/False
    add_file_context=None,  # Override setting only if True/False
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    # force_at_others=False, # tag:no-longer-used
    ignore_pattern=None
):
    << docstring >>
    c = self
    if g.os_path_exists(dir_):
        # Import all files in dir_ after c.p.
        try:
            import leo.core.leoImport as leoImport
            cc = leoImport.RecursiveImportController(c, kind,
                add_context=add_context,
                add_file_context=add_file_context,
                add_path=add_path,
                recursive=recursive,
                safe_at_file=safe_at_file,
                theTypes=['.py'] if not theTypes else theTypes,
                # force_at_others = force_at_others,  # tag:no-longer-used
                ignore_pattern=ignore_pattern
            )
            cc.run(dir_)
        finally:
            c.redraw()
    else:
        g.es_print(f"Does not exist: {dir_}")
#@+node:ekr.20130823083943.12614: *7* << docstring >>
"""
Recursively import all python files in a directory and clean the results.

Parameters::
    dir_              The root directory or file to import.
    kind              One of ('@clean','@edit','@file','@nosent').
    add_path=True     True: add a full @path directive to @<file> nodes.
    recursive=True    True: recurse into subdirectories.
    safe_at_file=True True: produce @@file nodes instead of @file nodes.
    theTypes=None     A list of file extensions to import.
                      None is equivalent to ['.py']

This method cleans imported files as follows:

- Replace backslashes with forward slashes in headlines.
- Remove empty nodes.
- Add @path directives that reduce the needed path specifiers in descendant nodes.
- Add @file to nodes or replace @file with @@file.
"""
#@+node:ekr.20130823083943.12615: *6* ric.ctor
def __init__(self, c, kind,
    # force_at_others = False, #tag:no-longer-used
    add_context=None,  # Override setting only if True/False
    add_file_context=None,  # Override setting only if True/False
    add_path=True,
    recursive=True,
    safe_at_file=True,
    theTypes=None,
    ignore_pattern=None,
):
    """Ctor for RecursiveImportController class."""
    self.c = c
    self.add_path = add_path
    self.file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    self.kind = kind
        # in ('@auto', '@clean', '@edit', '@file', '@nosent')
    # self.force_at_others = force_at_others #tag:no-longer-used
    self.recursive = recursive
    self.root = None
    self.safe_at_file = safe_at_file
    self.theTypes = theTypes
    self.ignore_pattern = ignore_pattern or re.compile(r'\.git|node_modules')
    # #1605:

    def set_bool(setting, val):
        if val not in (True, False):
            return
        c.config.set(None, 'bool', setting, val, warn=True)
        
    set_bool('add-context-to-headlines', add_context)
    set_bool('add-file-context-to-headlines', add_file_context)
#@+node:ekr.20120215072959.12475: *6* c.config.set
def set(self, p, kind, name, val, warn=True):
    """
    Init the setting for name to val.
    
    The "p" arg is not used.
    """
    c = self.c
    # Note: when kind is 'shortcut', name is a command name.
    key = g.app.config.munge(name)
    d = self.settingsDict
    assert isinstance(d, g.TypedDict), repr(d)
    gs = d.get(key)
    if gs:
        assert isinstance(gs, g.GeneralSetting), repr(gs)
        path = gs.path
        if warn and g.os_path_finalize(
            c.mFileName) != g.os_path_finalize(path):  # #1341.
            g.es("over-riding setting:", name, "from", path)
    d[key] = g.GeneralSetting(kind, path=c.mFileName, val=val, tag='setting')
#@+node:ekr.20200619100706.1: *5* #1606: move-lines-to-next-node
#@+node:ekr.20200619082429.1: *6* ec.moveLinesToNextNode (new)
@cmd('move-lines-to-next-node')
def moveLineToNextNode(self, event):
    """Move one or *trailing* lines to the start of the next node."""
    c = self.c
    if not c.p.threadNext():
        return
    w = self.editWidget(event)
    if not w:
        return
    s = w.getAllText()
    sel_1, sel_2 = w.getSelectionRange()
    i, junk = g.getLine(s, sel_1)
    i2, j = g.getLine(s, sel_2)
    lines = s[i:j]
    if not lines.strip():
        return
    self.beginCommand(w, undoType='move-lines-to-next-node')
    try:
        next_i, next_j = g.getLine(s, j)
        w.delete(i, next_j)
        c.p.b = w.getAllText().rstrip() + '\n'
        c.selectPosition(c.p.threadNext())
        c.p.b = lines + '\n' + c.p.b
        c.recolor()
    finally:
        self.endCommand(changed=True, setLabel=True)
#@+node:ekr.20200623060055.1: *5* #1608: cython importer
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1608

@language python
#@+node:ekr.20200909170947.1: *5* #1610: Document sections and references
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1610

@language python
#@+node:ekr.20200707102415.1: *5* #1613: Review leoInteg issues
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1613

@language python
#@+node:ekr.20200724115128.1: *5* #1616 Show github branch in outline title
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1616

@language python
#@+node:ekr.20031218072017.3103: *6* g.computeWindowTitle
def computeWindowTitle(fileName):

    branch, commit = g.gitInfoForFile(fileName)  # #1616
    if not fileName:
        return branch + ": untitled" if branch else 'untitled'
    path, fn = g.os_path_split(fileName)
    if path:
        title = fn + " in " + path
    else:
        title = fn
    # Yet another fix for bug 1194209: regularize slashes.
    if os.sep in '/\\':
        title = title.replace('/', os.sep).replace('\\', os.sep)
    if branch:
        title = branch + ": " + title
    return title
#@+node:ekr.20200724133754.1: *6* g.gitInfoForOutline
def gitInfoForOutline(c):
    """
    Return the git (branch, commit) info associated for commander c.
    """
    return g.gitInfoForFile(c.fileName())
#@+node:ekr.20200724132432.1: *6* g.gitInfoForFile
def gitInfoForFile(filename):
    """
    return the git (branch, commit) info associated for the given file.
    
    Look for a .git directory in the file's directory, and parent directories.
    """
    from pathlib import Path
    branch, commit = '', ''
    if filename:
        parent = Path(filename)
        while parent:
            git_dir = os.path.join(parent, '.git')
            if os.path.exists(git_dir) and os.path.isdir(git_dir):
                head = os.path.join(git_dir, 'HEAD')
                if os.path.exists(head):
                    branch, commit = g.gitInfo(head)
                    break
            if parent == parent.parent:
                break
            parent = parent.parent
    return branch, commit
#@+node:ekr.20200427051334.1: *5* #1617: Fix ts importer problems
@language rest
@wrap


https://github.com/leo-editor/leo-editor/issues/1617
@language python
@nosearch
#@+node:ekr.20200726064630.1: *5* #1618: verbatim sentinenls
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1618

This work has been abandoned. This issue has been closed.

@language python
#@+node:ekr.20180602103135.3: *6* fast_at.get_patterns
@nobeautify

def get_patterns(self, delims):
    '''Create regex patterns for the given comment delims.'''
    # This must be a function, because of @comments & @delims.
    delim_start, delim_end = delims
    delims = re.escape(delim_start), re.escape(delim_end or '')
    delim1, delim2 = delims
    ref = g.angleBrackets(r'(.*)')
    patterns = (
        # The list of patterns, in alphabetical order.
        # These patterns must be mutually exclusive.
        fr'^\s*{delim1}@afterref{delim2}$',             # @afterref
        fr'^(\s*){delim1}@(\+|-)all\b(.*){delim2}$',    # @all
        fr'^\s*{delim1}@@c(ode)?{delim2}$',             # @c and @code
        fr'^\s*{delim1}@comment(.*){delim2}',           # @comment
        fr'^\s*{delim1}@delims(.*){delim2}',            # @delims
        fr'^\s*{delim1}@\+(at|doc)?(\s.*?)?{delim2}\n', # @doc or @
        fr'^\s*{delim1}@end_raw\s*{delim2}',            # @end_raw
        fr'^\s*{delim1}@@first{delim2}$',               # @first
        fr'^\s*{delim1}@@last{delim2}$',                # @last
        fr'^(\s*){delim1}@\+node:([^:]+): \*(\d+)?(\*?) (.*){delim2}$', # @node
        fr'^(\s*){delim1}@(\+|-)others\b(.*){delim2}$', # @others
        fr'^\s*{delim1}@raw(.*){delim2}',               # @raw
        fr'^(\s*){delim1}@(\+|-){ref}\s*{delim2}$'      # section ref
    )
    # Return the compiled patterns, in alphabetical order.
    return (re.compile(pattern) for pattern in patterns)
#@+node:ekr.20041005105605.174: *6* at.putCodeLine
def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) > 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
#@+node:ekr.20180602103135.8: *6* fast_at.scan_lines
def scan_lines(self, delims, first_lines, lines, path, start, test=False):
    '''Scan all lines of the file, creating vnodes.'''
    << init scan_lines >>
    << define dump_v >>

    i = 0  # To keep pylint happy.
    for i, line in enumerate(lines[start:]):
        # Order matters.
        << 1. common code for all lines >>
        << 2. short-circuit later tests >>
        << 3. handle @others >> # clears in_doc
        << 4. handle section refs >> # clears in_doc.
        # Order doesn't matter, but match more common sentinels first.
        << handle node_start >>
        << handle end of @doc & @code parts >>
        << handle @all >>
        << handle afterref >>
        << handle @first and @last >>
        << handle @comment >>
        << handle @delims >>
        << handle @raw >>
        << handle @-leo >>
        # These must be last, in this order.
        << Last 1. handle remaining @@ lines >>
        << Last 2. handle remaining @doc lines >>
        << Last 3. handle remaining @ lines >>
    else:
        # No @-leo sentinel
        return None, []
    # Handle @last lines.
    last_lines = lines[start + i :]
    if last_lines:
        last_lines = ['@last ' + z for z in last_lines]
        gnx2body[root_gnx] = gnx2body[root_gnx] + last_lines
    self.post_pass(gnx2body, gnx2vnode, root_v)
    return root_v, last_lines
#@+node:ekr.20180602103135.9: *7* << init scan_lines >>
#
# Simple vars...
afterref = False
    # A special verbatim line follows @afterref.
clone_v = None
    # The root of the clone tree.
    # When not None, we are scanning a clone and all it's descendants.
delim_start, delim_end = delims
    # The start/end delims.
doc_skip = (delim_start + '\n', delim_end + '\n')
    # To handle doc parts.
first_i = 0
    # Index into first array.
in_doc = False
    # True: in @doc parts.
in_raw = False
    # True: @raw seen.
is_cweb = delim_start == '@q@' and delim_end == '@>'
    # True: cweb hack in effect.
indent = 0
    # The current indentation.
level_stack = []
    # Entries are (vnode, in_clone_tree)
n_last_lines = 0
    # The number of @@last directives seen.
root_seen = False
    # False: The next +@node sentinel denotes the root, regardless of gnx.
    # Needed to handle #1065 so reads will not create spurious child nodes.
sentinel = delim_start + '@'
    # Faster than a regex!
stack = []
    # Entries are (gnx, indent, body)
    # Updated when at+others, at+<section>, or at+all is seen.
verbline = delim_start + '@verbatim' + delim_end + '\n'
    # The spelling of at-verbatim sentinel
verbatim = False
    # True: the next line must be added without change.
#
# Init the data for the root node.
#

#
# Init the parent vnode for testing.
#
if self.test:
    root_gnx = gnx = 'root-gnx'
        # The node that we are reading.
        # start with the gnx for the @file node.
    gnx_head = '<hidden top vnode>'
        # The headline of the root node.
    context = None
    parent_v = self.VNode(context=context, gnx=gnx)
    parent_v._headString = gnx_head
        # Corresponds to the @files node itself.
else:
    # Production.
    root_gnx = gnx = self.root.gnx
    context = self.c
    parent_v = self.root.v
root_v = parent_v
    # Does not change.
level_stack.append((root_v, False),)
#
# Init the gnx dict last.
#
gnx2vnode = self.gnx2vnode
    # Keys are gnx's, values are vnodes.
gnx2body = {}
    # Keys are gnxs, values are list of body lines.
gnx2vnode[gnx] = parent_v
    # Add gnx to the keys
gnx2body[gnx] = body = first_lines
    # Add gnx to the keys.
    # Body is the list of lines presently being accumulated.
#
# get the patterns.
data = self.get_patterns(delims)
after_pat, all_pat, code_pat, comment_pat, delims_pat, doc_pat, end_raw_pat, first_pat, last_pat, node_start_pat, others_pat, raw_pat, ref_pat = data

#@+node:ekr.20180613061743.1: *7* << define dump_v >>
def dump_v():
    """Dump the level stack and v."""
    print('----- LEVEL', level, v.h)
    print('       PARENT', parent_v.h)
    print('[')
    for i, data in enumerate(level_stack):
        v2, in_tree = data
        print(f"{i+1:2} {in_tree:5} {v2.h}")
    print(']')
    print('PARENT.CHILDREN...')
    g.printObj([v3.h for v3 in parent_v.children])
    print('PARENTS...')
    g.printObj([v4.h for v4 in v.parents])

#@+node:ekr.20180602103135.10: *7* << 1. common code for all lines >>
if verbatim:
    # We are in raw mode, or other special situation.
    # Previous line was verbatim sentinel. Append this line as it is.
    if afterref:
        afterref = False
        if body:  # a List of lines.
            body[-1] = body[-1].rstrip() + line
        else:
            body = [line]
        verbatim = False
    elif in_raw:
        m = end_raw_pat.match(line)
        if m:
            in_raw = False
            verbatim = False
        else:
             body.append(line)
             # Continue verbatim/raw mode.
    else:
        body.append(line)
        verbatim = False
    continue
if line == verbline:  # <delim>@verbatim.
    verbatim = True
    continue
#
# Strip the line only once.
strip_line = line.strip()
#
# Undo the cweb hack.
if is_cweb and line.startswith(sentinel):
    line = line[: len(sentinel)] + line[len(sentinel) :].replace('@@', '@')
# Adjust indentation.
if indent and line[:indent].isspace() and len(line) > indent:
    line = line[indent:]
#@+node:ekr.20180602103135.12: *7* << 2. short-circuit later tests >>
# This is valid because all following sections are either:
# 1. guarded by 'if in_doc' or
# 2. guarded by a pattern that matches the start of the sentinel.
#
if not in_doc and not strip_line.startswith(sentinel):
    # lstrip() is faster than using a regex!
    body.append(line)
    continue
#@+node:ekr.20180602103135.14: *7* << 3. handle @others >>
m = others_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':  # opening sentinel
        body.append(f"{m.group(1)}@others{m.group(3) or ''}\n")
        stack.append((gnx, indent, body))
        indent += m.end(1)  # adjust current identation
    else:  # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
#@+node:ekr.20180602103135.18: *7* << 4. handle section refs >>
m = ref_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':
        # open sentinel.
        body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
        stack.append((gnx, indent, body))
        indent += m.end(1)
        continue
    if stack:
        # #1232: Only if the stack exists.
        # close sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        continue
#@+node:ekr.20180602103135.19: *7* << handle node_start >>
m = node_start_pat.match(line)
if m:
    in_doc, in_raw = False, False
    gnx, head = m.group(2), m.group(5)
    level = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
        # m.group(3) is the level number, m.group(4) is the number of stars.
    v = gnx2vnode.get(gnx)
    #
    # Case 1: The root @file node. Don't change the headline.
    if not root_seen:
        # Fix #1064: The node represents the root, regardless of the gnx!
        root_seen = True
        clone_v = None
        gnx2body[gnx] = body = []
        if not v:
            # Fix #1064.
            v = root_v
            # This message is annoying when using git-diff.
                # if gnx != root_gnx:
                    # g.es_print("using gnx from external file: %s" % (v.h), color='blue')
            gnx2vnode[gnx] = v
            v.fileIndex = gnx
        v.children = []
        continue
    #
    # Case 2: We are scanning the descendants of a clone.
    parent_v, clone_v = level_stack[level - 2]
    if v and clone_v:
        # The last version of the body and headline wins..
        gnx2body[gnx] = body = []
        v._headString = head
        # Update the level_stack.
        level_stack = level_stack[: level - 1]
        level_stack.append((v, clone_v),)
        # Always clear the children!
        v.children = []
        parent_v.children.append(v)
        continue
    #
    # Case 3: we are not already scanning the descendants of a clone.
    if v:
        # The *start* of a clone tree. Reset the children.
        clone_v = v
        v.children = []
    else:
        # Make a new vnode.
        v = self.VNode(context=context, gnx=gnx)
    #
    # The last version of the body and headline wins.
    gnx2vnode[gnx] = v
    gnx2body[gnx] = body = []
    v._headString = head
    #
    # Update the stack.
    level_stack = level_stack[: level - 1]
    level_stack.append((v, clone_v),)
    #
    # Update the links.
    assert v != root_v
    parent_v.children.append(v)
    v.parents.append(parent_v)
    # dump_v()
    continue
#@+node:ekr.20180602103135.16: *7* << handle end of @doc & @code parts >>
if in_doc:
    # When delim_end exists the doc block:
    # - begins with the opening delim, alonw on its own line
    # - ends with the closing delim, alone on its own line.
    # Both of these lines should be skipped
    #
    # #1496: Retire the @doc convention.
    #        An empty line is no longer a sentinel.
    if delim_end and line in doc_skip:
        # doc_skip is (delim_start + '\n', delim_end + '\n')
        continue
    #
    # Check for @c or @code.
    m = code_pat.match(line)
    if m:
        in_doc = False
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
else:
    m = doc_pat.match(line)
    if m:
        # @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or ''  # Trailing text.
        if doc2:
            body.append(f"{doc}{doc2}\n")
        else:
            body.append(doc + '\n')
        # Enter @doc mode.
        in_doc = True
        continue
#@+node:ekr.20180602103135.13: *7* << handle @all >>
m = all_pat.match(line)
if m:
    # @all tells Leo's *write* code not to check for undefined sections.
    # Here, in the read code, we merely need to add it to the body.
    # Pushing and popping the stack may not be necessary, but it can't hurt.
    if m.group(2) == '+':  # opening sentinel
        body.append(f"{m.group(1)}@all{m.group(3) or ''}\n")
        stack.append((gnx, indent, body))
    else:  # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        gnx2body[gnx] = body
    continue
#@+node:ekr.20180603063102.1: *7* << handle afterref >>
m = after_pat.match(line)
if m:
    afterref = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
#@+node:ekr.20180606053919.1: *7* << handle @first and @last >>
m = first_pat.match(line)
if m:
    if 0 <= first_i < len(first_lines):
        body.append('@first ' + first_lines[first_i])
        first_i += 1
    else:
        g.trace(f"\ntoo many @first lines: {path}")
        print('@first is valid only at the start of @<file> nodes\n')
        g.printObj(first_lines, tag='first_lines')
        g.printObj(lines[start : i + 2], tag='lines[start:i+2]')
    continue
m = last_pat.match(line)
if m:
    n_last_lines += 1
    continue
#@+node:ekr.20180621050901.1: *7* << handle @comment >>
# http://leoeditor.com/directives.html#part-4-dangerous-directives
m = comment_pat.match(line)
if m:
    # <1, 2 or 3 comment delims>
    delims = m.group(1).strip()
    # Whatever happens, retain the @delims line.
    body.append(f"@comment {delims}\n")
    delim1, delim2, delim3 = g.set_delims_from_string(delims)
        # delim1 is always the single-line delimiter.
    if delim1:
        delim_start, delim_end = delim1, ''
    else:
        delim_start, delim_end = delim2, delim3
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__', '\n').replace('_', ' ')
    delim_end = delim_end.replace('__', '\n').replace('_', ' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@>'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns.
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
#@+node:ekr.20180608104836.1: *7* << handle @delims >>
m = delims_pat.match(line)
if m:
    # Get 1 or 2 comment delims
    # Whatever happens, retain the original @delims line.
    delims = m.group(1).strip()
    body.append(f"@delims {delims}\n")
    #
    # Parse the delims.
    delims_pat = re.compile(r'^([^ ]+)\s*([^ ]+)?')
    m2 = delims_pat.match(delims)
    if not m2:
        g.trace(f"Ignoring invalid @comment: {line!r}")
        continue
    delim_start = m2.group(1)
    delim_end = m2.group(2) or ''
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__', '\n').replace('_', ' ')
    delim_end = delim_end.replace('__', '\n').replace('_', ' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@>'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
#@+node:ekr.20180606080200.1: *7* << handle @raw >>
# http://leoeditor.com/directives.html#part-4-dangerous-directives
m = raw_pat.match(line)
if m:
    in_raw = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
#@+node:ekr.20180602103135.20: *7* << handle @-leo >>
if line.startswith(delim_start + '@-leo'):
    i += 1
    break
#@+node:ekr.20180603135602.1: *7* << Last 1. handle remaining @@ lines >>
# @first, @last, @delims and @comment generate @@ sentinels,
# So this must follow all of those.
if line.startswith(delim_start + '@@'):
    ii = len(delim_start) + 1  # on second '@'
    jj = line.rfind(delim_end) if delim_end else -1
    body.append(line[ii:jj] + '\n')
    continue
#@+node:ekr.20180606054325.1: *7* << Last 2. handle remaining @doc lines >>
if in_doc:
    if delim_end:
        # doc lines are unchanged.
        body.append(line)
        continue
    # Doc lines start with start_delim + one blank.
    # #1496: Retire the @doc convention:
    tail = line[len(delim_start) + 1 :]
    if tail.strip():
        body.append(tail)
    else:
        body.append('\n')
    continue
#@+node:ekr.20180602103135.17: *7* << Last 3. handle remaining @ lines >>
# Handle an apparent sentinel line.
# This *can* happen, as the result of the git-diff command.
#
# This assert verifies the short-circuit test.
assert strip_line.startswith(sentinel), (repr(sentinel), repr(line))
#
# This trace is less important, but interesting.
g.trace(
    f"{g.shortFileName(self.path)}: ignoring unexpected line: {line.strip()!r}")
# body.append(line)
#@+node:ekr.20200729080515.1: *6* ----- Used SENT hack
#@+node:ekr.20200219114415.1: *7* TestOrange.test_at_doc_part
def test_at_doc_part(self):

    line_length = 40  # For testing.
    contents = f"""\
@ Line 1
Line 2
@c

print('hi')
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents.rstrip() + '\n'
    results = self.beautify(contents, tokens, tree,
        max_join_line_length=line_length,
        max_split_line_length=line_length,
    )
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200220050758.1: *7* TestOrange.test_blank_lines_after_function_2
def test_blank_lines_after_function_2(self):

    contents = """\
# Leading comment line 1.
# Leading comment lines 2.

def spam():
    pass

# Trailing comment line.
a = 2
"""
    contents, tokens, tree = self.make_data(contents)
    expected = contents
    results = self.beautify(contents, tokens, tree)
    assert results == expected, expected_got(expected, results)
#@+node:ekr.20200727062416.1: *5* #1619: @language json
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1619

@language python
#@+node:ekr.20120522160137.9911: *6* app.define_extension_dict
@nobeautify

def define_extension_dict(self):

    # Keys are extensions, values are languages
    self.extension_dict = {
        # "ada":    "ada",
        "ada":      "ada95", # modes/ada95.py exists.
        "ahk":      "autohotkey",
        "aj":       "aspect_j",
        "apdl":     "apdl",
        "as":       "actionscript", # jason 2003-07-03
        "asp":      "asp",
        "awk":      "awk",
        "b":        "b",
        "bas":      "rapidq", # fil 2004-march-11
        "bash":     "shellscript",
        "bat":      "batch",
        "bbj":      "bbj",
        "bcel":     "bcel",
        "bib":      "bibtex",
        "c":        "c",
        "c++":      "cplusplus",
        "cbl":      "cobol", # Only one extension is valid: .cob
        "cfg":      "config",
        "cfm":      "coldfusion",
        "clj":      "clojure", # 2013/09/25: Fix bug 879338.
        "cljs":     "clojure",
        "cljc":     "clojure",
        "ch":       "chill", # Other extensions, .c186,.c286
        "coffee":   "coffeescript",
        "conf":     "apacheconf",
        "cpp":      "cplusplus", # 2020/08/12: was cpp.
        "css":      "css",
        "d":        "d",
        "dart":     "dart",
        "e":        "eiffel",
        "el":       "elisp",
        "eml":      "mail",
        "erl":      "erlang",
        "ex":       "elixir",
        "f":        "fortran",
        "f90":      "fortran90",
        "factor":   "factor",
        "forth":    "forth",
        "g":        "antlr",
        "groovy":   "groovy",
        "h":        "c", # 2012/05/23.
        "handlebars": "html", # McNab.
        "hbs":      "html", # McNab.
        "hs":       "haskell",
        "html":     "html",
        "hx":       "haxe",
        "i":        "swig",
        "i4gl":     "i4gl",
        "icn":      "icon",
        "idl":      "idl",
        "inf":      "inform",
        "info":     "texinfo",
        "ini":      "ini",
        "io":       "io",
        "ipynb":    "jupyter",
        "iss":      "inno_setup",
        "java":     "java",
        "jhtml":    "jhtml",
        "jmk":      "jmk",
        "js":       "javascript", # For javascript import test.
        "jsp":      "javaserverpage",
        "json":     "json", 
        # "jsp":      "jsp",
        "ksh":      "kshell",
        "kv":       "kivy", # PeckJ 2014/05/05
        "latex":    "latex",
        "less":     "css", # McNab
        "lua":      "lua", # ddm 13/02/06
        "ly":       "lilypond",
        "m":        "matlab",
        "mak":      "makefile",
        "md":       "md", # PeckJ 2013/02/07
        "ml":       "ml",
        "mm":       "objective_c", # Only one extension is valid: .m
        "mod":      "modula3",
        "mpl":      "maple",
        "mqsc":     "mqsc",
        "nqc":      "nqc",
        "nsi":      "nsi", # EKR: 2010/10/27
        # "nsi":      "nsis2",
        "nw":       "noweb",
        "occ":      "occam",
        "otl":      "vimoutline", # TL 8/25/08 Vim's outline plugin
        "p":        "pascal",
        # "p":      "pop11", # Conflicts with pascal.
        "php":      "php",
        "pike":     "pike",
        "pl":       "perl",
        "pl1":      "pl1",
        "po":       "gettext",
        "pod":      "perlpod",
        "pov":      "povray",
        "prg":      "foxpro",
        "pro":      "prolog",
        "ps":       "postscript",
        "psp":      "psp",
        "ptl":      "ptl",
        "py":       "python",
        "pyx":      "cython", # Other extensions, .pyd,.pyi
        # "pyx":    "pyrex",
        # "r":      "r", # modes/r.py does not exist.
        "r":        "rebol", # jason 2003-07-03
        "rb":       "ruby", # thyrsus 2008-11-05
        "rest":     "rst",
        "rex":      "objectrexx",
        "rhtml":    "rhtml",
        "rib":      "rib",
        "rs":       "rust", # EKR: 2019/08/11
        "sas":      "sas",
        "scala":    "scala",
        "scm":      "scheme",
        "scpt":     "applescript",
        "sgml":     "sgml",
        "sh":       "shell", # DS 4/1/04. modes/shell.py exists.
        "shtml":    "shtml",
        "sm":       "smalltalk",
        "splus":    "splus",
        "sql":      "plsql", # qt02537 2005-05-27
        "sqr":      "sqr",
        "ss":       "ssharp",
        "ssi":      "shtml",
        "sty":      "latex",
        "tcl":      "tcl", # modes/tcl.py exists.
        # "tcl":    "tcltk",
        "tex":      "latex",
        # "tex":      "tex",
        "tpl":      "tpl",
        "ts":       "typescript",
        "txt":      "plain",
        # "txt":      "text",
        # "txt":      "unknown", # Set when @comment is seen.
        "uc":       "uscript",
        "v":        "verilog",
        "vbs":      "vbscript",
        "vhd":      "vhdl",
        "vhdl":     "vhdl",
        "vim":      "vim",
        "vtl":      "velocity",
        "w":        "cweb",
        "wiki":     "moin",
        "xml":      "xml",
        "xom":      "omnimark",
        "xsl":      "xsl",
        "yaml":     "yaml",
        "vue":      "javascript",
        "zpt":      "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm

    # Extra language extensions, used to associate extensions with mode files.
    # Used by importCommands.languageForExtension.
    # Keys are extensions, values are corresponding mode file (without .py)
    # A value of 'none' is a signal to unit tests that no extension file exists.
    self.extra_extension_dict = {
        'pod'   : 'perl',
        'unknown_language': 'none',
        'w'     : 'none', # cweb
    }
#@+node:ekr.20120522160137.9909: *6* app.define_language_delims_dict
@nobeautify

def define_language_delims_dict(self):

    self.language_delims_dict = {
        # Internally, lower case is used for all language names.
        # Keys are languages, values are 1,2 or 3-tuples of delims.
        "actionscript"       : "// /* */", # jason 2003-07-03
        "ada"                : "--",
        "ada95"              : "--",
        "ahk"                : ";",
        "antlr"              : "// /* */",
        "apacheconf"         : "#",
        "apdl"               : "!",
        "applescript"        : "-- (* *)",
        "asp"                : "<!-- -->",
        "aspect_j"           : "// /* */",
        "assembly_macro32"   : ";",
        "assembly_mcs51"     : ";",
        "assembly_parrot"    : "#",
        "assembly_r2000"     : "#",
        "assembly_x86"       : ";",
        "autohotkey"         : "; /* */", # TL - AutoHotkey language
        "awk"                : "#",
        "b"                  : "// /* */",
        "batch"              : "REM_", # Use the REM hack.
        "bbj"                : "/* */",
        "bcel"               : "// /* */",
        "bibtex"             : "%",
        "c"                  : "// /* */", # C, C++ or objective C.
        "chill"              : "/* */",
        "clojure"            : ";", # 2013/09/25: Fix bug 879338.
        "cobol"              : "*",
        "coldfusion"         : "<!-- -->",
        "coffeescript"       : "#", # 2016/02/26.
        "config"             : "#", # Leo 4.5.1
        "cplusplus"          : "// /* */",
        "cpp"                : "// /* */",# C++.
        "csharp"             : "// /* */", # C#
        "css"                : "/* */", # 4/1/04
        "cweb"               : "@q@ @>", # Use the "cweb hack"
        "cython"             : "#",
        "d"                  : "// /* */",
        "dart"               : "// /* */", # Leo 5.0.
        "doxygen"            : "#",
        "eiffel"             : "--",
        "elisp"              : ";",
        "erlang"             : "%",
        "elixir"             : "#",
        "factor"             : "!_ ( )", # Use the rem hack.
        "forth"              : "\\_ _(_ _)", # Use the "REM hack"
        "fortran"            : "C",
        "fortran90"          : "!",
        "foxpro"             : "&&",
        "gettext"            : "# ",
        "groovy"             : "// /* */",
        "handlebars"         : "<!-- -->", # McNab: delegate to html.
        "haskell"            : "--_ {-_ _-}",
        "haxe"               : "// /* */",
        "hbs"                : "<!-- -->", # McNab: delegate to html.
        "html"               : "<!-- -->",
        "i4gl"               : "-- { }",
        "icon"               : "#",
        "idl"                : "// /* */",
        "inform"             : "!",
        "ini"                : ";",
        "inno_setup"         : ";",
        "interlis"           : "/* */",
        "io"                 : "// */",
        "java"               : "// /* */",
        "javascript"         : "// /* */", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage"     : "<%-- --%>", # EKR: 2011/11/25 (See also, jsp)
        "jhtml"              : "<!-- -->",
        "jmk"                : "#",
        "json"               : "#", # EKR: 2020/07/27: Json has no delims. This is a dummy entry.
        "jsp"                : "<%-- --%>",
        "jupyter"            : "<%-- --%>", # Default to markdown?
        "kivy"               : "#", # PeckJ 2014/05/05
        "kshell"             : "#", # Leo 4.5.1.
        "latex"              : "%",
        "less"               : "/* */", # NcNab: delegate to css.
        "lilypond"           : "% %{ %}",
        "lisp"               : ";", # EKR: 2010/09/29
        "lotos"              : "(* *)",
        "lua"                : "--", # ddm 13/02/06
        "mail"               : ">",
        "makefile"           : "#",
        "maple"              : "//",
        "markdown"           : "<!-- -->", # EKR, 2018/03/03: html comments.
        "matlab"             : "%", # EKR: 2011/10/21
        "md"                 : "<!-- -->", # PeckJ: 2013/02/08
        "ml"                 : "(* *)",
        "modula3"            : "(* *)",
        "moin"               : "##",
        "mqsc"               : "*",
        "netrexx"            : "-- /* */",
        "noweb"              : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
        "nqc"                : "// /* */",
        "nsi"                : ";", # EKR: 2010/10/27
        "nsis2"              : ";",
        "objective_c"        : "// /* */",
        "objectrexx"         : "-- /* */",
        "occam"              : "--",
        "omnimark"           : ";",
        "pandoc"             : "<!-- -->", 
        "pascal"             : "// { }",
        "perl"               : "#",
        "perlpod"            : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
        "php"                : "// /* */", # 6/23/07: was "//",
        "pike"               : "// /* */",
        "pl1"                : "/* */",
        "plain"              : "#", # We must pick something.
        "plsql"              : "-- /* */", # SQL scripts qt02537 2005-05-27
        "pop11"              : ";;; /* */",
        "postscript"         : "%",
        "povray"             : "// /* */",
        "powerdynamo"        : "// <!-- -->",
        "prolog"             : "% /* */",
        "psp"                : "<!-- -->",
        "ptl"                : "#",
        "pvwave"             : ";",
        "pyrex"              : "#",
        "python"             : "#",
        "r"                  : "#",
        "rapidq"             : "'", # fil 2004-march-11
        "rebol"              : ";", # jason 2003-07-03
        "redcode"            : ";",
        "rest"               : ".._",
        "rhtml"              : "<%# %>",
        "rib"                : "#",
        "rpmspec"            : "#",
        "rst"                : ".._",
        "rust"               : "// /* */",
        "ruby"               : "#", # thyrsus 2008-11-05
        "rview"              : "// /* */",
        "sas"                : "* /* */",
        "scala"              : "// /* */",
        "scheme"             : "; #| |#",
        "sdl_pr"             : "/* */",
        "sgml"               : "<!-- -->",
        "shell"              : "#",     # shell scripts
        "shellscript"        : "#",
        "shtml"              : "<!-- -->",
        "smalltalk"          : '" "', # Comments are enclosed in double quotes(!!)
        "smi_mib"            : "--",
        "splus"              : "#",
        "sqr"                : "!",
        "squidconf"          : "#",
        "ssharp"             : "#",
        "swig"               : "// /* */",
        "tcl"                : "#",
        "tcltk"              : "#",
        "tex"                : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
        "text"               : "#", # We must pick something.
        "texinfo"            : "@c",
        "tpl"                : "<!-- -->",
        "tsql"               : "-- /* */",
        "typescript"         : "// /* */", # For typescript import test.
        "unknown"            : "#", # Set when @comment is seen.
        "unknown_language"   : '#--unknown-language--', # For unknown extensions in @shadow files.
        "uscript"            : "// /* */",
        "vbscript"           : "'",
        "velocity"           : "## #* *#",
        "verilog"            : "// /* */",
        "vhdl"               : "--",
        "vim"                : "\"",
        "vimoutline"         : "#", # TL 8/25/08 Vim's outline plugin
        "xml"                : "<!-- -->",
        "xsl"                : "<!-- -->",
        "xslt"               : "<!-- -->",
        "yaml"               : "#",
        "zpt"                : "<!-- -->",

        # These aren't real languages, or have no delims...
        # "cvs_commit"         : "",
        # "dsssl"              : "; <!-- -->",
        # "embperl"            : "<!-- -->",  # Internal colorizing state.
        # "freemarker"         : "",
        # "hex"                : "",
        # "jcl"                : "",
        # "patch"              : "",
        # "phpsection"         : "<!-- -->",  # Internal colorizing state.
        # "props"              : "#",         # Unknown language.
        # "pseudoplain"        : "",
        # "relax_ng_compact"   : "#",         # An xml schema.
        # "rtf"                : "",
        # "svn_commit"         : "",
    }
#@+node:ekr.20120522160137.9910: *6* app.define_language_extension_dict
@nobeautify

def define_language_extension_dict(self):

    # Used only by g.app.externalFilesController.get_ext.

    # Keys are languages, values are extensions.
    self.language_extension_dict = {
        "actionscript"  : "as", # jason 2003-07-03
        "ada"           : "ada",
        "ada95"         : "ada",
        "ahk"           : "ahk",
        "antlr"         : "g",
        "apacheconf"    : "conf",
        "apdl"          : "apdl",
        "applescript"   : "scpt",
        "asp"           : "asp",
        "aspect_j"      : "aj",
        "autohotkey"    : "ahk", # TL - AutoHotkey language
        "awk"           : "awk",
        "b"             : "b",
        "batch"         : "bat", # Leo 4.5.1.
        "bbj"           : "bbj",
        "bcel"          : "bcel",
        "bibtex"        : "bib",
        "c"             : "c",
        "chill"         : "ch",  # Only one extension is valid: .c186, .c286
        "clojure"       : "clj", # 2013/09/25: Fix bug 879338.
        "cobol"         : "cbl", # Only one extension is valid: .cob
        "coldfusion"    : "cfm",
        "coffeescript"  : "coffee",
        "config"        : "cfg",
        "cplusplus"     : "c++",
        "cpp"           : "cpp",
        "css"           : "css", # 4/1/04
        "cweb"          : "w",
        "cython"        : "pyx", # Only one extension is valid at present: .pyi, .pyd.
        "d"             : "d",
        "dart"          : "dart",
        "eiffel"        : "e",
        "elisp"         : "el",
        "erlang"        : "erl",
        "elixir"        : "ex",
        "factor"        : "factor",
        "forth"         : "forth",
        "fortran"       : "f",
        "fortran90"     : "f90",
        "foxpro"        : "prg",
        "gettext"       : "po",
        "groovy"        : "groovy",
        "haskell"       : "hs",
        "haxe"          : "hx",
        "html"          : "html",
        "i4gl"          : "i4gl",
        "icon"          : "icn",
        "idl"           : "idl",
        "inform"        : "inf",
        "ini"           : "ini",
        "inno_setup"    : "iss",
        "io"            : "io",
        "java"          : "java",
        "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
        "javaserverpage": "jsp", # EKR: 2011/11/25
        "jhtml"         : "jhtml",
        "jmk"           : "jmk",
        "json"          : "json", 
        "jsp"           : "jsp",
        "jupyter"       : "ipynb",
        "kivy"          : "kv", # PeckJ 2014/05/05
        "kshell"        : "ksh", # Leo 4.5.1.
        "latex"         : "tex", # 1/8/04
        "lilypond"      : "ly",
        "lua"           : "lua", # ddm 13/02/06
        "mail"          : "eml",
        "makefile"      : "mak",
        "maple"         : "mpl",
        "matlab"        : "m",
        "md"            : "md", # PeckJ: 2013/02/07
        "ml"            : "ml",
        "modula3"       : "mod",
        "moin"          : "wiki",
        "mqsc"          : "mqsc",
        "noweb"         : "nw",
        "nqc"           : "nqc",
        "nsi"           : "nsi", # EKR: 2010/10/27
        "nsis2"         : "nsi",
        "objective_c"   : "mm", # Only one extension is valid: .m
        "objectrexx"    : "rex",
        "occam"         : "occ",
        "omnimark"      : "xom",
        "pascal"        : "p",
        "perl"          : "pl",
        "perlpod"       : "pod",
        "php"           : "php",
        "pike"          : "pike",
        "pl1"           : "pl1",
        "plain"         : "txt",
        "plsql"         : "sql", # qt02537 2005-05-27
        # "pop11"       : "p", # Conflicts with pascall.
        "postscript"    : "ps",
        "povray"        : "pov",
        "prolog"        : "pro",
        "psp"           : "psp",
        "ptl"           : "ptl",
        "pyrex"         : "pyx",
        "python"        : "py",
        "r"             : "r",
        "rapidq"        : "bas", # fil 2004-march-11
        "rebol"         : "r", # jason 2003-07-03
        "rhtml"         : "rhtml",
        "rib"           : "rib",
        "rst"           : "rest",
        "ruby"          : "rb", # thyrsus 2008-11-05
        "rust"          : "rs", # EKR: 2019/08/11
        "sas"           : "sas",
        "scala"         : "scala",
        "scheme"        : "scm",
        "sgml"          : "sgml",
        "shell"         : "sh", # DS 4/1/04
        "shellscript"   : "bash",
        "shtml"         : "ssi", # Only one extension is valid: .shtml
        "smalltalk"     : "sm",
        "splus"         : "splus",
        "sqr"           : "sqr",
        "ssharp"        : "ss",
        "swig"          : "i",
        "tcl"           : "tcl",
        "tcltk"         : "tcl",
        "tex"           : "tex",
        "texinfo"       : "info",
        "text"          : "txt",
        "tpl"           : "tpl",
        "tsql"          : "sql", # A guess.
        "typescript"    : "ts",
        "unknown"       : "txt", # Set when @comment is seen.
        "uscript"       : "uc",
        "vbscript"      : "vbs",
        "velocity"      : "vtl",
        "verilog"       : "v",
        "vhdl"          : "vhd", # Only one extension is valid: .vhdl
        "vim"           : "vim",
        "vimoutline"    : "otl", # TL 8/25/08 Vim's outline plugin
        "xml"           : "xml",
        "xsl"           : "xsl",
        "xslt"          : "xsl",
        "yaml"          : "yaml",
        "zpt"           : "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm
#@+node:ekr.20200503054140.1: *5* #1620: git-diff clones added nodes
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1620

@language python
#@+node:ekr.20170806191942.2: *6* gdc.create_compare_node
def create_compare_node(self, c1, c2, d, kind, rev1, rev2):
    """Create nodes describing the changes."""
    if not d:
        return
    parent = self.file_node.insertAsLastChild()
    parent.setHeadString(kind)
    for key in d:
        if kind.lower() == 'changed':
            v1, v2 = d.get(key)
            # Organizer node: contains diff
            organizer = parent.insertAsLastChild()
            organizer.h = v2.h
            body = list(difflib.unified_diff(
                g.splitLines(v1.b),
                g.splitLines(v2.b),
                rev1 or 'uncommitted',
                rev2 or 'uncommitted',
            ))
            if ''.join(body).strip():
                body.insert(0, '@ignore\n@nosearch\n@language patch\n')
                body.append(f"@language {c2.target_language}\n")
            else:
                body = ['Only headline has changed']
            organizer.b = ''.join(body)
            # Node 2: Old node
            p2 = organizer.insertAsLastChild()
            p2.h = 'Old:' + v1.h
            p2.b = v1.b
            # Node 3: New node
            assert v1.fileIndex == v2.fileIndex
            p_in_c = self.find_gnx(self.c, v1.fileIndex)
            if p_in_c:  # Make a clone, if possible.
                p3 = p_in_c.clone()
                p3.moveToLastChildOf(organizer)
            else:
                p3 = organizer.insertAsLastChild()
                p3.h = 'New:' + v2.h
                p3.b = v2.b
        elif kind.lower() == 'added':
            v = d.get(key)
            new_p = self.find_gnx(self.c, v.fileIndex)
            if new_p:  # Make a clone, if possible.
                p = new_p.clone()
                p.moveToLastChildOf(parent)
            else:
                p = parent.insertAsLastChild()
            p.h = v.h
            p.b = v.b
        else:
            v = d.get(key)
            p = parent.insertAsLastChild()
            p.h = v.h
            p.b = v.b
#@+node:ekr.20200808135023.1: *5* #1625: set language for cloned nodes
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1625

@language python
@nosearch
#@+node:ekr.20200810095719.1: *6* ----- changed
#@+node:ekr.20120522160137.9911: *7* app.define_extension_dict
@nobeautify

def define_extension_dict(self):

    # Keys are extensions, values are languages
    self.extension_dict = {
        # "ada":    "ada",
        "ada":      "ada95", # modes/ada95.py exists.
        "ahk":      "autohotkey",
        "aj":       "aspect_j",
        "apdl":     "apdl",
        "as":       "actionscript", # jason 2003-07-03
        "asp":      "asp",
        "awk":      "awk",
        "b":        "b",
        "bas":      "rapidq", # fil 2004-march-11
        "bash":     "shellscript",
        "bat":      "batch",
        "bbj":      "bbj",
        "bcel":     "bcel",
        "bib":      "bibtex",
        "c":        "c",
        "c++":      "cplusplus",
        "cbl":      "cobol", # Only one extension is valid: .cob
        "cfg":      "config",
        "cfm":      "coldfusion",
        "clj":      "clojure", # 2013/09/25: Fix bug 879338.
        "cljs":     "clojure",
        "cljc":     "clojure",
        "ch":       "chill", # Other extensions, .c186,.c286
        "coffee":   "coffeescript",
        "conf":     "apacheconf",
        "cpp":      "cplusplus", # 2020/08/12: was cpp.
        "css":      "css",
        "d":        "d",
        "dart":     "dart",
        "e":        "eiffel",
        "el":       "elisp",
        "eml":      "mail",
        "erl":      "erlang",
        "ex":       "elixir",
        "f":        "fortran",
        "f90":      "fortran90",
        "factor":   "factor",
        "forth":    "forth",
        "g":        "antlr",
        "groovy":   "groovy",
        "h":        "c", # 2012/05/23.
        "handlebars": "html", # McNab.
        "hbs":      "html", # McNab.
        "hs":       "haskell",
        "html":     "html",
        "hx":       "haxe",
        "i":        "swig",
        "i4gl":     "i4gl",
        "icn":      "icon",
        "idl":      "idl",
        "inf":      "inform",
        "info":     "texinfo",
        "ini":      "ini",
        "io":       "io",
        "ipynb":    "jupyter",
        "iss":      "inno_setup",
        "java":     "java",
        "jhtml":    "jhtml",
        "jmk":      "jmk",
        "js":       "javascript", # For javascript import test.
        "jsp":      "javaserverpage",
        "json":     "json", 
        # "jsp":      "jsp",
        "ksh":      "kshell",
        "kv":       "kivy", # PeckJ 2014/05/05
        "latex":    "latex",
        "less":     "css", # McNab
        "lua":      "lua", # ddm 13/02/06
        "ly":       "lilypond",
        "m":        "matlab",
        "mak":      "makefile",
        "md":       "md", # PeckJ 2013/02/07
        "ml":       "ml",
        "mm":       "objective_c", # Only one extension is valid: .m
        "mod":      "modula3",
        "mpl":      "maple",
        "mqsc":     "mqsc",
        "nqc":      "nqc",
        "nsi":      "nsi", # EKR: 2010/10/27
        # "nsi":      "nsis2",
        "nw":       "noweb",
        "occ":      "occam",
        "otl":      "vimoutline", # TL 8/25/08 Vim's outline plugin
        "p":        "pascal",
        # "p":      "pop11", # Conflicts with pascal.
        "php":      "php",
        "pike":     "pike",
        "pl":       "perl",
        "pl1":      "pl1",
        "po":       "gettext",
        "pod":      "perlpod",
        "pov":      "povray",
        "prg":      "foxpro",
        "pro":      "prolog",
        "ps":       "postscript",
        "psp":      "psp",
        "ptl":      "ptl",
        "py":       "python",
        "pyx":      "cython", # Other extensions, .pyd,.pyi
        # "pyx":    "pyrex",
        # "r":      "r", # modes/r.py does not exist.
        "r":        "rebol", # jason 2003-07-03
        "rb":       "ruby", # thyrsus 2008-11-05
        "rest":     "rst",
        "rex":      "objectrexx",
        "rhtml":    "rhtml",
        "rib":      "rib",
        "rs":       "rust", # EKR: 2019/08/11
        "sas":      "sas",
        "scala":    "scala",
        "scm":      "scheme",
        "scpt":     "applescript",
        "sgml":     "sgml",
        "sh":       "shell", # DS 4/1/04. modes/shell.py exists.
        "shtml":    "shtml",
        "sm":       "smalltalk",
        "splus":    "splus",
        "sql":      "plsql", # qt02537 2005-05-27
        "sqr":      "sqr",
        "ss":       "ssharp",
        "ssi":      "shtml",
        "sty":      "latex",
        "tcl":      "tcl", # modes/tcl.py exists.
        # "tcl":    "tcltk",
        "tex":      "latex",
        # "tex":      "tex",
        "tpl":      "tpl",
        "ts":       "typescript",
        "txt":      "plain",
        # "txt":      "text",
        # "txt":      "unknown", # Set when @comment is seen.
        "uc":       "uscript",
        "v":        "verilog",
        "vbs":      "vbscript",
        "vhd":      "vhdl",
        "vhdl":     "vhdl",
        "vim":      "vim",
        "vtl":      "velocity",
        "w":        "cweb",
        "wiki":     "moin",
        "xml":      "xml",
        "xom":      "omnimark",
        "xsl":      "xsl",
        "yaml":     "yaml",
        "vue":      "javascript",
        "zpt":      "zpt",
    }

    # These aren't real languages, or have no delims...
        # cvs_commit, dsssl, embperl, freemarker, hex, jcl,
        # patch, phpsection, progress, props, pseudoplain,
        # relax_ng_compact, rtf, svn_commit.

    # These have extensions which conflict with other languages.
        # assembly_macro32: .asm or .a
        # assembly_mcs51:   .asm or .a
        # assembly_parrot:  .asm or .a
        # assembly_r2000:   .asm or .a
        # assembly_x86:     .asm or .a
        # squidconf:        .conf
        # rpmspec:          .rpm

    # Extra language extensions, used to associate extensions with mode files.
    # Used by importCommands.languageForExtension.
    # Keys are extensions, values are corresponding mode file (without .py)
    # A value of 'none' is a signal to unit tests that no extension file exists.
    self.extra_extension_dict = {
        'pod'   : 'perl',
        'unknown_language': 'none',
        'w'     : 'none', # cweb
    }
#@+node:ekr.20090214075058.6: *7* g.findLanguageDirectives (must be fast)
def findLanguageDirectives(c, p):
    """Return the language in effect at position p."""
    if c is None or p is None:
        return None  # c may be None for testing.
        
    v0 = p.v
        
    def find_language(p_or_v):
        for s in p_or_v.h, p_or_v.b:
            for m in g_language_pat.finditer(s):
                language = m.group(1)
                if g.isValidLanguage(language):
                    return language
        return None

    # First, search up the tree.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    # #1625: Second, expand the search for cloned nodes.
    seen = [] # vnodes that have already been searched.
    parents = v0.parents[:] # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    # Finally, fall back to the defaults.
    return c.target_language.lower() if c.target_language else 'python'
#@+node:ekr.20111010082822.15545: *7* g.getLanguageFromAncestorAtFileNode
def getLanguageFromAncestorAtFileNode(p):
    """
    Return the language in effect as determined
    by the file extension of the nearest enclosing @<file> node.
    """
    
    v0 = p.v
        
    def find_language(p_or_v):
        if p_or_v.isAnyAtFileNode():
            name = p_or_v.anyAtFileNodeName()
            junk, ext = g.os_path_splitext(name)
            ext = ext[1:]  # strip the leading .
            language = g.app.extension_dict.get(ext)
            if g.isValidLanguage(language):
                return language
        return None

    # First, look at the direct parents.
    for p in p.self_and_parents(copy=False):
        language = find_language(p)
        if language:
            return language
    #
    # #1625: Expand the search for cloned nodes.
    seen = [] # vnodes that have already been searched.
    parents = v0.parents[:] # vnodes whose ancestors are to be searched.
    while parents:
        parent_v = parents.pop()
        if parent_v in seen:
            continue
        seen.append(parent_v)
        language = find_language(parent_v)
        if language:
            return language
        for grand_parent_v in parent_v.parents:
            if grand_parent_v not in seen:
                parents.append(grand_parent_v)
    return None
#@+node:ekr.20200810095117.1: *6* ----- new
#@+node:ekr.20200810074755.1: *7* g.isValidLanguage (new)
def isValidLanguage(language):
    """True if language exists in leo/modes."""
    # 2020/08/12: A hack for c++
    if language in ('c++', 'cpp'):
        language = 'cplusplus'
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', f"{language}.py")
    return g.os_path_exists(fn)
#@+node:ekr.20200810093517.1: *7* << define regex's >>
g_language_pat = re.compile(r'^@language\s+(\w+)+', re.MULTILINE)
    # Regex used by this module, and in leoColorizer.py.
#
# Patterns used only in this module...
g_is_directive_pattern = re.compile(r'^\s*@([\w-]+)\s*')
    # This pattern excludes @encoding.whatever and @encoding(whatever)
    # It must allow @language python, @nocolor-node, etc.
g_noweb_root = re.compile('<' + '<' + '*' + '>' + '>' + '=', re.MULTILINE)
g_pos_pattern = re.compile(r':(\d+),?(\d+)?,?([-\d]+)?,?(\d+)?$')
g_tabwidth_pat = re.compile(r'(^@tabwidth)', re.MULTILINE)
#@+node:ekr.20200809105223.1: *6* ----- unchanged
#@+node:ekr.20080416161551.190: *7*  p.__init__
def __init__(self, v, childIndex=0, stack=None):
    """Create a new position with the given childIndex and parent stack."""
    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable VNode object changes.
    self._childIndex = childIndex
    self.v = v
    # Stack entries are tuples (v, childIndex).
    if stack:
        self.stack = stack[:]  # Creating a copy here is safest and best.
    else:
        self.stack = []
    g.app.positions += 1
#@+node:ekr.20170127142001.2: *7* bjc.scanLanguageDirectives & helpers
def scanLanguageDirectives(self, p, use_default=True):
    """Return language based on the directives in p's ancestors."""
    c = self.c
    root = p.copy()
    # Look for the first @language directive only in p itself.
    language = self.findFirstValidAtLanguageDirective(p)
    if language:
        return language
    for p in root.parents():
        languages = self.findAllValidLanguageDirectives(p)
        if len(languages) == 1:  # An unambiguous language
            language = languages[0]
            return language
    #  Get the language from the nearest ancestor @<file> node.
    language = g.getLanguageFromAncestorAtFileNode(root)
    if not language and use_default:
        language = c.target_language
    return language
#@+node:ekr.20170201150505.1: *8* bjc.findAllValidLanguageDirectives
def findAllValidLanguageDirectives(self, p):
    """Return list of all valid @language directives in p.b"""
    languages = set()
    for m in g.g_language_pat.finditer(p.b):
        language = m.group(1)
        if g.isValidLanguage(language):
            languages.add(language)
    return list(sorted(languages))
#@+node:ekr.20170127142001.5: *8* bjc.findFirstAtLanguageDirective
def findFirstValidAtLanguageDirective(self, p):
    """Return the first *valid* @language directive in p.b."""
    for m in g.g_language_pat.finditer(p.b):
        language = m.group(1)
        if g.isValidLanguage(language):
            return language
    return None
#@+node:ekr.20170220103251.1: *7* g.findRootsWithPredicate
def findRootsWithPredicate(c, root, predicate=None):
    """
    Commands often want to find one or more **roots**, given a position p.
    A root is the position of any node matching a predicate.

    This function formalizes the search order used by the black,
    pylint, pyflakes and the rst3 commands, returning a list of zero
    or more found roots.
    """
    seen = []
    roots = []
    if predicate is None:

        # A useful default predicate for python.
        # pylint: disable=function-redefined

        def predicate(p):
            return p.isAnyAtFileNode() and p.h.strip().endswith('.py')

    # 1. Search p's tree.
    for p in root.self_and_subtree(copy=False):
        if predicate(p) and p.v not in seen:
            seen.append(p.v)
            roots.append(p.copy())
    if roots:
        return roots
    # 2. Look up the tree.
    for p in root.parents():
        if predicate(p):
            return [p.copy()]
    # 3. Expand the search if root is a clone.
    clones = []
    for p in root.self_and_parents(copy=False):
        if p.isCloned():
            clones.append(p.v)
    if clones:
        for p in c.all_positions(copy=False):
            if predicate(p):
                # Match if any node in p's tree matches any clone.
                for p2 in p.self_and_subtree():
                    if p2.v in clones:
                        return [p.copy()]
    return []
#@+node:ekr.20090214075058.9: *7* g.get_directives_dict (must be fast)
# The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

def get_directives_dict(p, root=None):
    """
    Scan p for Leo directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive
    """
    if root: root_node = root[0]
    # c = p and p.v and p.v.context
    d = {}
    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat, re.MULTILINE)
    # The headline has higher precedence because it is more visible.
    for kind, s in (('head', p.h), ('body', p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(1).strip()
            i = m.start(1)
            if word in d: continue
            j = i + len(word)
            if j < len(s) and s[j] not in ' \t\n':
                continue
                    # Not a valid directive: just ignore it.
                    # A unit test tests that @path:any is invalid.
            k = g.skip_line(s, j)
            val = s[j:k].strip()
            if word in ('root-doc', 'root-code'):
                d['root'] = val  # in addition to optioned version
            d[word] = val
            # New in Leo 5.7.1: @path is allowed in body text.
            # This is very useful when doing recursive imports.
    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"] = 0  # value not immportant
            else:
                g.es(f'{g.angleBrackets("*")} may only occur in a topmost node (i.e., without a parent)')
            break
    return d
#@+node:ekr.20090214075058.10: *8* g.compute_directives_re
def compute_directives_re():
    """
    Return an re pattern which word matches all Leo directives.
    Only g.get_directives_dict uses this pattern.
    """
    global globalDirectiveList
    # Use a pattern that guarantees word matches.
    aList = [
        fr"\b{z}\b" for z in globalDirectiveList if z != 'others'
    ]
    # Clearer w/o f-strings.
    return f"^@(%s)" % "|".join(aList)
#@+node:ekr.20040712084911.1: *7* g.scanForAtLanguage
def scanForAtLanguage(c, p):
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.
    if c and p:
        for p in p.self_and_parents(copy=False):
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language, delim1, delim2, delim3 = g.set_language(z, 0)
                return language
    return c.target_language
#@+node:ekr.20200810074909.1: *6* ----- no longer used
at_language_pattern = re.compile(r'^@language\s+([\w-]+)', re.MULTILINE)

g_language_pat = re.compile(r'^@language\s+(\w+)+', re.MULTILINE)
#@+node:ekr.20170127142001.6: *7* bjc.isValidLanguage
def isValidLanguage(self, language):
    """True if language exists in leo/modes."""
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', f"{language}.py")
    return g.os_path_exists(fn)
#@+node:ekr.20200816084339.1: *5* #1626: Fix c++ importer problems
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1626

@language python
@nosearch
#@+node:ekr.20200824093921.1: *5* #1631: adjust positions
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1631

This issue has been abandoned and closed.

@language python
@nosearch
#@+node:ekr.20200901081714.1: *6* ----- Ref
#@+node:ekr.20090706110836.6135: *7* v._addLink & _addParentLinks
def _addLink(self, childIndex, parent_v):
    """Adjust links after adding a link to v."""
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
        # For a plugin.
    # Update parent_v.children & v.parents.
    parent_v.children.insert(childIndex, v)
    v.parents.append(parent_v)
    # Set zodb changed flags.
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has only one parent, we adjust all
    # the parents links in the descendant tree.
    # This handles clones properly when undoing a delete.
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
#@+node:ekr.20090804184658.6129: *8* v._addParentLinks
def _addParentLinks(self, parent):

    v = self
    v.parents.append(parent)
    if len(v.parents) == 1:
        for child in v.children:
            child._addParentLinks(parent=v)
#@+node:ekr.20200825090749.1: *7* 2 calls to _adjustPositionBeforeUnlink
@nosearch

# These adjust *other* positions before unlinking p.
#@+node:ekr.20040303175026.10: *8* p.moveAfter
def moveAfter(self, a):
    """Move a position after position a."""
    p = self  # Do NOT copy the position!
    a._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAfter(a)
    return p
#@+node:ekr.20040303175026.11: *8* p.moveToNthChildOf
def moveToNthChildOf(self, parent, n):
    """Move a position to the nth child of parent."""
    p = self  # Do NOT copy the position!
    parent._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAsNthChild(parent, n)
    return p
#@+node:ekr.20080416161551.194: *7* p.isAncestorOf
def isAncestorOf(self, p2):
    """Return True if p is one of the direct ancestors of p2."""
    p = self
    c = p.v.context
    if not c.positionExists(p2):
        return False
    for z in p2.stack:
        # 2013/12/25: bug fix: test childIndices.
        # This is required for the new per-position expansion scheme.
        parent_v, parent_childIndex = z
        if parent_v == p.v and parent_childIndex == p._childIndex:
            return True
    return False
#@+node:ekr.20080427062528.4: *7* p._adjustPositionBeforeUnlink
def _adjustPositionBeforeUnlink(self, p2):
    """Adjust position p before unlinking p2."""
    # p will change if p2 is a previous sibling of p or
    # p2 is a previous sibling of any ancestor of p.
    p = self; sib = p.copy()
    # A special case for previous siblings.
    # Adjust p._childIndex, not the stack's childIndex.
    while sib.hasBack():
        sib.moveToBack()
        if sib == p2:
            p._childIndex -= 1
            return
    # Adjust p's stack.
    stack = []; changed = False; i = 0
    while i < len(p.stack):
        v, childIndex = p.stack[i]
        p3 = Position(v=v, childIndex=childIndex, stack=stack[:i])
        while p3:
            if p2 == p3:
                # 2011/02/25: compare full positions, not just vnodes.
                # A match with the to-be-moved node.
                stack.append((v, childIndex - 1),)
                changed = True
                break  # terminate only the inner loop.
            p3.moveToBack()
        else:
            stack.append((v, childIndex),)
        i += 1
    if changed:
        p.stack = stack
#@+node:ekr.20200831090505.1: *6* ----- No longer used
#@+node:ekr.20190506060937.1: *7* c.dumpExpanded
@cmd('dump-expanded')
def dump_expanded(self, event):
    c = event.get('c')
    if not c:
        return
    g.es_print('dump-expanded...')
    for p in c.all_positions():
        if p.v.expandedPositions:
            indent = ' ' * p.level()
            print(f"{indent}{p.h}")
            g.printObj(p.v.expandedPositions, indent=indent)
#@+node:ekr.20200825090825.1: *7* Found:expandedPositions
@nosearch

# flattened, word, ignore-case, head, body

# found 6 nodes
#@+node:ekr.20200825091022.1: *8* no need to change
#@+node:ekr.20060928062431: *9* c_oc.expandOnlyAncestorsOfNode
@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
#@+node:ekr.20180810052056.2: *9* qtree.yieldVisible (not used)
def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) > 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) <= 1 and (v.statusBits & v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 < len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 < len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
#@+node:ekr.20031218072017.3344: *9* v.__init
def __init__(self, context, gnx=None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString = 'newHeadline'
    self._bodyString = ''
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
#@+node:ekr.20131017174814.17480: *8* c.shouldBeExpanded
def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
#@+node:ekr.20131222112420.16371: *8* p.contract/expand/isExpanded
def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
#@+node:ekr.20200830142724.1: *6* ----- changed
#@+node:ekr.20131017174814.17480: *7* c.shouldBeExpanded
def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
#@+node:ekr.20051009045404: *7* frame.createFirstTreeNode
def createFirstTreeNode(self):
    c= self.c
    v = leoNodes.VNode(context=c)
    p = leoNodes.Position(v)
    v.initHeadString("NewHeadline")
    #
    # #1631: Initialize here, not in p._linkAsRoot.
    c.hiddenRootNode.children = []
    #
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot()
#@+node:ekr.20080416161551.216: *7* p._linkAsRoot (changed)
def _linkAsRoot(self):
    """Link self as the root node."""
    p = self
    assert(p.v)
    parent_v = p.v.context.hiddenRootNode
    assert parent_v, g.callers()
    #
    # Make p the root position.
    p.stack = []
    p._childIndex = 0
    #
    # Make p.v the first child of parent_v.
    p.v._addLink(0, parent_v)
    return p
#@+node:ekr.20131222112420.16371: *7* p.contract/expand/isExpanded
def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
#@+node:ekr.20040303175026.6: *7* p.moveToRoot (changed)
def moveToRoot(self):
    """Move self to the root position."""
    p = self  # Do NOT copy the position!
    #
    # #1631. The old root can not possibly be affected by unlinking p.
    p._unlink()
    p._linkAsRoot()
    return p
#@+node:ekr.20131017174814.17480: *6* c.shouldBeExpanded
def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
#@+node:ekr.20200901084548.1: *6* Found:shouldBeExpanded
@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
#@+node:ekr.20131222112420.16371: *7* p.contract/expand/isExpanded
def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
#@+node:ekr.20080416161551.196: *7* p.isVisible (slow)
def isVisible(self, c):
    """Return True if p is visible in c's outline."""
    p = self

    def visible(p, root=None):
        for parent in p.parents(copy=False):
            if parent and parent == root:
                # #12.
                return True
            if not c.shouldBeExpanded(parent):
                return False
        return True

    if c.hoistStack:
        root = c.hoistStack[-1].p
        if p == root:
            # #12.
            return True
        return root.isAncestorOf(p) and visible(p, root=root)
    for root in c.rootPosition().self_and_siblings(copy=False):
        if root == p or root.isAncestorOf(p):
            return visible(p)
    return False
#@+node:ekr.20180817043619.1: *7* qtree.update_expansion
def update_expansion(self, p):
    """Update expansion bits for p, including all clones."""
    c = self.c
    w = self.treeWidget
    expand = c.shouldBeExpanded(p)
    if 'drawing' in g.app.debug:
        g.trace('expand' if expand else 'contract')
    item = self.position2itemDict.get(p.key())
    if p:
        try:
            # These generate events, which would trigger a full redraw.
            self.busy = True
            if expand:
                w.expandItem(item)
            else:
                w.collapseItem(item)
        finally:
            self.busy = False
        w.repaint()
    else:
        g.trace('NO P')
        c.redraw()
#@+node:ekr.20180810052056.2: *7* qtree.yieldVisible (not used)
def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) > 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) <= 1 and (v.statusBits & v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 < len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 < len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
#@+node:ekr.20200901091332.1: *6* Found:expandedPositions
@nosearch

# flattened, word, ignore-case, head, body

# found 6 nodes
#@+node:ekr.20190506060937.1: *7* c.dumpExpanded
@cmd('dump-expanded')
def dump_expanded(self, event):
    c = event.get('c')
    if not c:
        return
    g.es_print('dump-expanded...')
    for p in c.all_positions():
        if p.v.expandedPositions:
            indent = ' ' * p.level()
            print(f"{indent}{p.h}")
            g.printObj(p.v.expandedPositions, indent=indent)
#@+node:ekr.20131017174814.17480: *7* c.shouldBeExpanded
def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
#@+node:ekr.20060928062431: *7* c_oc.expandOnlyAncestorsOfNode
@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
#@+node:ekr.20131222112420.16371: *7* p.contract/expand/isExpanded
def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
#@+node:ekr.20180810052056.2: *7* qtree.yieldVisible (not used)
def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) > 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) <= 1 and (v.statusBits & v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 < len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 < len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
#@+node:ekr.20031218072017.3344: *7* v.__init
def __init__(self, context, gnx=None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString = 'newHeadline'
    self._bodyString = ''
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
#@+node:ekr.20040930064232: *6* c_oc.contractNodeOrGoToParent
@g.commander_command('contract-or-go-left')
def contractNodeOrGoToParent(self, event=None):
    """Simulate the left Arrow Key in folder of Windows Explorer."""
    c, cc, p = self, self.chapterController, self.p
    parent = p.parent()
    redraw = False
    # Bug fix: 2016/04/19: test p.v.isExpanded().
    if p.hasChildren() and (p.v.isExpanded() or p.isExpanded()):
        c.contractNode()
    elif parent and parent.isVisible(c):
        # Contract all children first.
        if c.collapse_on_lt_arrow:
            for child in parent.children():
                if child.isExpanded():
                    child.contract()
                    if child.hasChildren():
                        redraw = True
        if cc and cc.inChapter and parent.h.startswith('@chapter '):
            pass
        else:
            c.goToParent()
    if redraw:
        # A *child* should be collapsed.  Do a *full* redraw.
        c.redraw()
#@+node:ekr.20031218072017.2901: *6* c_oc.contractNode
@g.commander_command('contract-node')
def contractNode(self, event=None):
    """Contract the presently selected node."""
    c = self
    p = c.p
    c.endEditing()
    p.contract()
    c.redraw_after_contract(p)
    c.selectPosition(p)
#@+node:ekr.20110605121601.17880: *6* qtree.redraw_after_contract
def redraw_after_contract(self, p):

    if self.busy:
        return
    self.update_expansion(p)
#@+node:ekr.20180817043619.1: *6* qtree.update_expansion
def update_expansion(self, p):
    """Update expansion bits for p, including all clones."""
    c = self.c
    w = self.treeWidget
    expand = c.shouldBeExpanded(p)
    if 'drawing' in g.app.debug:
        g.trace('expand' if expand else 'contract')
    item = self.position2itemDict.get(p.key())
    if p:
        try:
            # These generate events, which would trigger a full redraw.
            self.busy = True
            if expand:
                w.expandItem(item)
            else:
                w.collapseItem(item)
        finally:
            self.busy = False
        w.repaint()
    else:
        g.trace('NO P')
        c.redraw()
#@+node:ekr.20200824130719.1: *5* #1632: contract-all-subheads
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1632

@language python
#@+node:ekr.20031218072017.2911: *6* c.expandSubtree
def expandSubtree(self, v, redraw=True):
    c = self
    last = v.lastNode()
    while v and v != last:
        v.expand()
        v = v.threadNext()
    if redraw:
        c.redraw()
#@+node:ekr.20031218072017.2904: *6* c_oc.expandAllSubheads
@g.commander_command('expand-all-subheads')
def expandAllSubheads(self, event=None):
    """Expand all children of the presently selected node."""
    c = self; p = c.p
    if not p: return
    child = p.firstChild()
    c.expandSubtree(p)
    while child:
        c.expandSubtree(child)
        child = child.next()
    c.redraw(p)
#@+node:ekr.20200824130837.1: *6* c_oc.contractAllSubheads (new)
@g.commander_command('contract-all-subheads')
def contractAllSubheads(self, event=None):
    """Contract all children of the presently selected node."""
    c, p = self, self.p
    if not p:
        return
    child = p.firstChild()
    c.contractSubtree(p)
    while child:
        c.contractSubtree(child)
        child = child.next()
    c.redraw(p)
#@+node:ekr.20200902080911.1: *5* #1639: crash in v._cutParentLinks
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1639

Call stack: All lines are in leoNodes.py

moveOutlineRight, 1503
_unlink: 1089
_cutlink: 2537
_cutParentLinks: 2545
_cutParentLinks: 2545
_cutParentLinks: 2542  list.remove(x): x not in list

@language python
@nosearch

@common x-marked-nodes test code
#@+node:ekr.20031218072017.1771: *6* c_oc.moveOutlineRight
@g.commander_command('move-outline-right')
def moveOutlineRight(self, event=None):
    """Move the selected node right if possible."""
    c = self; u = c.undoer; p = c.p
    if not p: return
    if not c.canMoveOutlineRight():  # 11/4/03: Support for hoist.
        if c.hoistStack: cantMoveMessage(c)
        c.treeFocusHelper()
        return
    back = p.back()
    if not back:
        c.treeFocusHelper()
        return
    if not c.checkMoveWithParentWithWarning(p, back, True):
        c.treeFocusHelper()
        return
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    p.setDirty()
    n = back.numberOfChildren()
    p.moveToNthChildOf(back, n)
    p.setDirty()
    u.afterMoveNode(p, 'Move Right', undoData)
    c.redraw(p)
    c.recolor()
#@+node:ekr.20040303175026.11: *6* p.moveToNthChildOf
def moveToNthChildOf(self, parent, n):
    """Move a position to the nth child of parent."""
    p = self  # Do NOT copy the position!
    parent._adjustPositionBeforeUnlink(p)
    p._unlink()
    p._linkAsNthChild(parent, n)
    return p
#@+node:ekr.20080416161551.217: *6* p._unlink
def _unlink(self):
    """Unlink the receiver p from the tree."""
    p = self; n = p._childIndex
    parent_v = p._parentVnode()
        # returns None if p.v is None
    child = p.v
    assert(p.v)
    assert(parent_v)
    # Delete the child.
    if (0 <= n < len(parent_v.children) and
        parent_v.children[n] == child
    ):
        # This is the only call to v._cutlink.
        child._cutLink(n, parent_v)
    else:
        self.badUnlink(parent_v, n, child)
#@+node:ekr.20090706171333.6226: *7* p.badUnlink
def badUnlink(self, parent_v, n, child):

    if 0 <= n < len(parent_v.children):
        g.trace(f"**can not happen: children[{n}] != p.v")
        g.trace('parent_v.children...\n',
            g.listToString(parent_v.children))
        g.trace('parent_v', parent_v)
        g.trace('parent_v.children[n]', parent_v.children[n])
        g.trace('child', child)
        g.trace('** callers:', g.callers())
        if g.app.unitTesting: assert False, 'children[%s] != p.v'
    else:
        g.trace(
            f"**can not happen: bad child index: {n}, "
            f"len(children): {len(parent_v.children)}")
        g.trace('parent_v.children...\n',
            g.listToString(parent_v.children))
        g.trace('parent_v', parent_v, 'child', child)
        g.trace('** callers:', g.callers())
        if g.app.unitTesting:
            assert False, f"bad child index: {n}"
#@+node:ekr.20090804184658.6128: *6* v._cutLink & _cutParentLinks
def _cutLink(self, childIndex, parent_v):
    """Adjust links after cutting a link to v."""
    v = self
    v.context.frame.tree.generation += 1
    parent_v.childrenModified()
    assert parent_v.children[childIndex] == v
    del parent_v.children[childIndex]
    if parent_v in v.parents:
        try:
            v.parents.remove(parent_v)
        except ValueError:
            g.internalError(f"{parent_v} not in parents of {v}")
            g.trace('v.parents:')
            g.printObj(v.parents)
    v._p_changed = 1
    parent_v._p_changed = 1
    # If v has no more parents, we adjust all
    # the parent links in the descendant tree.
    # This handles clones properly when deleting a tree.
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
#@+node:ekr.20090804190529.6133: *7* v._cutParentLinks
def _cutParentLinks(self, parent):

    v = self
    v.parents.remove(parent)
    if not v.parents:
        for child in v.children:
            child._cutParentLinks(parent=v)
#@+node:ekr.20200903101030.1: *6* crash after saving the .db file
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\launchLeo.py", line 8, in <module>
    leo.core.runLeo.run()
  File "c:\leo.repo\leo-editor\leo\core\runLeo.py", line 75, in run
    g.app.loadManager.load(fileName, pymacs)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2615, in load
    lm.doPrePluginsInit(fileName, pymacs)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2799, in doPrePluginsInit
    lm.readGlobalSettingsFiles()
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2556, in readGlobalSettingsFiles
    lm.theme_path = lm.computeThemeFilePath()
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2191, in computeThemeFilePath
    theme_c = lm.openSettingsFile(path)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2518, in openSettingsFile
    readAtFileNodesFlag=False, silent=True)
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 708, in openLeoFile
    silent=silent,
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 567, in getLeoFile
    v = fc.retrieveVnodesFromDb(theFile) or fc.initNewDb(theFile)
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 1007, in retrieveVnodesFromDb
    p = fc.decodePosition(encp)
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 1727, in decodePosition
    stack = [(fc.gnxDict[x], int(y)) for x, y in stack]
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 1727, in <listcomp>
    stack = [(fc.gnxDict[x], int(y)) for x, y in stack]
KeyError: 'kgh.20200827123258.1'
#@+node:ekr.20200903105525.1: *6* @button print-parents
print(c.p.h)
print(c.p.v.parents)
#@+node:ekr.20200903105536.1: *6* -----
_cutParentLinks v <VNode kgh.20200830120602.1 node 5660>
parent <VNode kgh.20200830174443.1 node 5657> not in v.parents []

#@+node:ekr.20200903111927.1: *6* Found:.db
@nosearch

# flattened, word, ignore-case, head, body

# found 54 nodes
#@+node:ekr.20161028040028.1: *7* << LeoApp: global controller/manager objects >>
# Most of these are defined in initApp.
self.backgroundProcessManager = None
    # The singleton BackgroundProcessManager instance.
self.commander_cacher = None
    # The singleton leoCacher.CommanderCacher instance.
self.commander_db = None
    # The singleton db, managed by g.app.commander_cacher.
self.config = None
    # The singleton leoConfig instance.
self.db = None
    # The singleton global db, managed by g.app.global_cacher.
self.externalFilesController = None
    # The singleton ExternalFilesController instance.
self.global_cacher = None
    # The singleton leoCacher.GlobalCacher instance.
self.idleTimeManager = None
    # The singleton IdleTimeManager instance.
self.ipk = None
    # python kernel instance
self.loadManager = None
    # The singleton LoadManager instance.
# self.logManager = None
    # The singleton LogManager instance.
# self.openWithManager = None
    # The singleton OpenWithManager instance.
self.nodeIndices = None
    # The singleton nodeIndices instance.
self.pluginsController = None
    # The singleton PluginsManager instance.
self.sessionManager = None
    # The singleton SessionManager instance.
# The Commands class...
self.commandName = None
    # The name of the command being executed.
self.commandInterruptFlag = False
    # True: command within a command.
#@+node:tbrown.20131111194858.29876: *7* @g.command free-layout-load
@g.command('free-layout-load')
def free_layout_load(event):
    """Load layout from menu."""
    c = event.get('c')
    d = g.app.db.get('ns_layouts', {})
    menu = QtWidgets.QMenu(c.frame.top)
    for k in d:
        menu.addAction(k)
    pos = c.frame.top.window().frameGeometry().center()
    action = menu.exec_(pos)
    if action is None:
        return
    name = str(action.text())
    c.db['_ns_layout'] = name
    # layout = g.app.db['ns_layouts'][name]
    layouts = g.app.db.get('ns_layouts', {})
    layout = layouts.get(name)
    if layout:
        c.free_layout.get_top_splitter().load_layout(layout)
#@+node:ekr.20120427064024.10064: *7* app.checkForOpenFile
def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
#@+node:ekr.20120427064024.10066: *7* app.forgetOpenFile
def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
#@+node:ekr.20120427064024.10065: *7* app.rememberOpenFile
def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
#@+node:ville.20090620122043.6275: *7* app.setGlobalDb
def setGlobalDb(self):
    """ Create global pickleshare db

    Usable by::

        g.app.db['hello'] = [1,2,5]

    """
    # Fixes bug 670108.
    import leo.core.leoCache as leoCache
    g.app.global_cacher = leoCache.GlobalCacher()
    g.app.db = g.app.global_cacher.db
    g.app.commander_cacher = leoCache.CommanderCacher()
    g.app.commander_db = g.app.commander_cacher.db
#@+node:ekr.20070227093530: *7* bridge.initLeo & helpers
def initLeo(self):
    """
    Init the Leo app to which this class gives access.
    This code is based on leo.run().
    """
    if not self.isValidPython():
        return
    << initLeo imports >>
    g.app.recentFilesManager = leoApp.RecentFilesManager()
    g.app.loadManager = lm = leoApp.LoadManager()
    g.app.loadManager.computeStandardDirectories()
    if not g.app.setLeoID(useDialog=False, verbose=True):
        raise ValueError("unable to set LeoID.")
    g.app.inBridge = True  # Added 2007/10/21: support for g.getScript.
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.config = leoConfig.GlobalConfigManager()
    if self.useCaches:
        g.app.setGlobalDb()  # Fix #556.
    else:
        g.app.db = g.NullObject()
        g.app.commander_cacher = g.NullObject()
        g.app.global_cacher = g.NullObject()
    if self.readSettings:
        lm.readGlobalSettingsFiles()
            # reads only standard settings files, using a null gui.
            # uses lm.files[0] to compute the local directory
            # that might contain myLeoSettings.leo.
    else:
        # Bug fix: 2012/11/26: create default global settings dicts.
        settings_d, bindings_d = lm.createDefaultSettingsDicts()
        lm.globalSettingsDict = settings_d
        lm.globalBindingsDict = bindings_d
    self.createGui()  # Create the gui *before* loading plugins.
    if self.verbose: self.reportDirectories()
    self.adjustSysPath()
    # Kill all event handling if plugins not loaded.
    if not self.loadPlugins:

        def dummyDoHook(tag, *args, **keys):
            pass

        g.doHook = dummyDoHook
    g.doHook("start1")  # Load plugins.
    g.app.computeSignon()
    g.app.initing = False
    g.doHook("start2", c=None, p=None, v=None, fileName=None)
#@+node:ekr.20070227093629.1: *8* << initLeo imports >> initLeo (leoBridge)
try:
    # #1472: Simplify import of g
    import leo.core.leoGlobals as g
    self.g = g
except ImportError:
    print("Error importing leoGlobals.py")
#
# Create the application object.
try:
    g.in_bridge = True
        # Tell leoApp.createDefaultGui not to create a gui.
        # This module will create the gui later.
    import leo.core.leoApp as leoApp
    g.app = leoApp.LeoApp()
except ImportError:
    print("Error importing leoApp.py")
g.app.leoID = None
if self.tracePlugins:
    g.app.debug.append('plugins')
g.app.silentMode = self.silentMode
#
# Create the g.app.pluginsController here.
import leo.core.leoPlugins as leoPlugins
leoPlugins.init()  # Necessary. Sets g.app.pluginsController.
try:
    import leo.core.leoNodes as leoNodes
except ImportError:
    print("Error importing leoNodes.py")
    import traceback; traceback.print_exc()
try:
    import leo.core.leoConfig as leoConfig
except ImportError:
    print("Error importing leoConfig.py")
    import traceback; traceback.print_exc()
#@+node:ekr.20070302061713: *8* bridge.adjustSysPath
def adjustSysPath(self):
    """Adjust sys.path to enable imports as usual with Leo."""
    import sys
    g = self.g
    leoDirs = (
        'config', 'doc', 'extensions', 'modes', 'plugins', 'core', 'test')  # 2008/7/30
    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir, '..', theDir)
        if path not in sys.path:
            sys.path.append(path)
    # #258: leoBridge does not work with @auto-md subtrees.
    for theDir in ('importers', 'writers'):
        path = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins', theDir)
        if path not in sys.path:
            sys.path.append(path)
#@+node:ekr.20070227095743: *8* bridge.createGui
def createGui(self):
    g = self.g
    if self.guiName == 'nullGui':
        g.app.gui = g.app.nullGui
        g.app.log = g.app.gui.log = log = g.app.nullLog
        log.isNull = False
        log.enabled = True  # Allow prints from NullLog.
        log.logInited = True  # Bug fix: 2012/10/17.
    else:
        assert False, f"leoBridge.py: unsupported gui: {self.guiName}"
#@+node:ekr.20070227093629.4: *8* bridge.isValidPython
def isValidPython(self):
    import sys
    if sys.platform == 'cli':
        return True
    message = """\
Leo requires Python 3.6 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leo.core.leoGlobals as g
        # print('leoBridge:isValidPython:g',g)
        # Set leoGlobals.g here, rather than in leoGlobals.py.
        leoGlobals = g  # Don't set g.g, it would pollute the autocompleter.
        leoGlobals.g = g
    except ImportError:
        print("isValidPython: can not import leo.core.leoGlobals as leoGlobals")
        return 0
    except Exception:
        print(
            "isValidPytyhon: unexpected exception: import leo.core.leoGlobals as leoGlobals.py as g")
        import traceback; traceback.print_exc()
        return 0
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, '2.2.1')
        if not ok:
            print(message)
            g.app.gui.runAskOkDialog(
                None, "Python version error", message=message, text="Exit")
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        import traceback; traceback.print_exc()
        return 0
#@+node:ekr.20070227093629.9: *8* bridge.reportDirectories
def reportDirectories(self):
    if not self.silentMode:
        g = self.g
        for kind, theDir in (
            ("global config", g.app.globalConfigDir),
            ("home", g.app.homeDir),
        ):
            g.blue('', kind, 'directory', '', ':', theDir)
#@+node:ekr.20070227092442.5: *7* bridge.openLeoFile & helpers
def openLeoFile(self, fileName):
    """Open a .leo file, or create a new Leo frame if no fileName is given."""
    g = self.g
    g.app.silentMode = self.silentMode
    useLog = False
    if self.isOpen():
        if self.useCaches:
            self.reopen_cachers()
        else:
            g.app.db = g.NullObject()
                # g.TracingNullObject(tag='g.app.db')
        fileName = self.completeFileName(fileName)
        c = self.createFrame(fileName)
        # Leo 6.3: support leoInteg.
        g.app.windowList.append(c.frame)
        if not self.useCaches:
            c.db = g.NullObject()
                # g.TracingNullObject(tag='c.db')
        g.app.nodeIndices.compute_last_index(c)
            # New in Leo 5.1. An alternate fix for bug #130.
            # When using a bridge Leo might open a file, modify it,
            # close it, reopen it and change it all within one second.
            # In that case, this code must properly compute the next
            # available gnx by scanning the entire outline.
        if useLog:
            g.app.gui.log = log = c.frame.log
            log.isNull = False
            log.enabled = True
        return c
    return None
#@+node:ekr.20070227093629.5: *8* bridge.completeFileName
def completeFileName(self, fileName):
    g = self.g
    if not (fileName and fileName.strip()): return ''
    import os
    fileName = g.os_path_finalize_join(os.getcwd(), fileName)
    head, ext = g.os_path_splitext(fileName)
    if not ext: fileName = fileName + ".leo"
    return fileName
#@+node:ekr.20070227093629.6: *8* bridge.createFrame
def createFrame(self, fileName):
    """Create a commander and frame for the given file.
    Create a new frame if the fileName is empty or non-exisent."""
    g = self.g
    if fileName.strip():
        if g.os_path_exists(fileName):
            # This takes a long time due to imports in c.__init__
            c = g.openWithFileName(fileName)
            if c:
                return c
        elif not self.silentMode:
            print(f"file not found: {fileName}. creating new window")
    # Create a new frame. Unlike leo.run, this is not a startup window.
    c = g.app.newCommander(fileName)
    frame = c.frame
    frame.createFirstTreeNode()  # 2013/09/27: bug fix.
    assert c.rootPosition()
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
    # Call the 'new' hook for compatibility with plugins.
    # 2011/11/07: Do this only if plugins have been loaded.
    g.doHook("new", old_c=None, c=c, new_c=c)
    return c
#@+node:vitalije.20190923081235.1: *8* reopen_cachers
def reopen_cachers(self):
    import leo.core.leoCache as leoCache

    g = self.g
    try:
        g.app.db.get('dummy')
    except Exception:
        g.app.global_cacher = leoCache.GlobalCacher()
        g.app.db = g.app.global_cacher.db
        g.app.commander_cacher = leoCache.CommanderCacher()
        g.app.commander_db = g.app.commander_cacher.db
#@+node:ekr.20120217070122.10468: *7* c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.bufferCommands = None
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
#@+node:ekr.20120217070122.10470: *7* c.initObjects
@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '<hidden root vnode>'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.bufferCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
#@+node:ekr.20031218072017.2821: *7* c_file.open_outline & callback
@g.commander_command('open-outline')
def open_outline(self, event=None):
    """Open a Leo window containing the contents of a .leo file."""
    c = self
    @others
        # Defines open_completer function.

    #
    # Close the window if this command completes successfully?

    closeFlag = (
        c.frame.startupWindow and
            # The window was open on startup
        not c.changed and not c.frame.saved and
            # The window has never been changed
        g.app.numberOfUntitledWindows == 1
            # Only one untitled window has ever been opened
    )
    table = [
        ("Leo files", "*.leo *.db"),
        ("Python files", "*.py"),
        ("All files", "*"),
    ]
    fileName = ''.join(c.k.givenArgs)
    if fileName:
        c.open_completer(c, closeFlag, fileName)
        return
    if False:  # This seems not to be worth the trouble.
        g.app.gui.runOpenFileDialog(c,
            callback=open_completer,
            defaultextension=g.defaultLeoFileExtension(c),
            filetypes=table,
            title="Open",
        )
        return
    # Equivalent to legacy code.
    fileName = g.app.gui.runOpenFileDialog(c,
        defaultextension=g.defaultLeoFileExtension(c),
        filetypes=table,
        title="Open",
    )
    open_completer(c, closeFlag, fileName)
#@+node:ekr.20190518121302.1: *8* function: open_completer
def open_completer(c, closeFlag, fileName):

    c.bringToFront()
    c.init_error_dialogs()
    ok = False
    if fileName:
        if g.app.loadManager.isLeoFile(fileName):
            c2 = g.openWithFileName(fileName, old_c=c)
            if c2:
                c2.k.makeAllBindings()
                    # Fix #579: Key bindings don't take for commands defined in plugins.
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if c2 and closeFlag:
                g.app.destroyWindow(c.frame)
        elif c.looksLikeDerivedFile(fileName):
            # Create an @file node for files containing Leo sentinels.
            ok = c.importCommands.importDerivedFiles(parent=c.p,
                paths=[fileName], command='Open')
        else:
            # otherwise, create an @edit node.
            ok = c.createNodeFromExternalFile(fileName)
    c.raise_error_dialogs(kind='write')
    g.app.runAlreadyOpenDialog(c)
    # openWithFileName sets focus if ok.
    if not ok:
        c.initialFocusHelper()
#@+node:ekr.20180312043352.2: *7* c_file.open_theme_file
@g.commander_command('open-theme-file')
def open_theme_file(self, event):
    """Open a theme file in a new session and apply the theme."""
    c = event and event.get('c')
    if not c:
        return
    # Get the file name.
    themes_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'themes')
    fn = g.app.gui.runOpenFileDialog(c,
        title="Open Theme File",
        filetypes=[
            ("Leo files", "*.leo *.db"),
            ("All files", "*"),
        ],
        defaultextension=g.defaultLeoFileExtension(c),
        startpath=themes_dir,
    )
    if not fn:
        return
    leo_dir = g.os_path_finalize_join(g.app.loadDir, '..', '..')
    os.chdir(leo_dir)
    #
    # #1425: Open the theme file in a separate process.
    command = f'{g.sys.executable} {g.app.loadDir}/runLeo.py "{fn}"'
    g.execute_shell_commands(command) # #1564.
    os.chdir(leo_dir)
#@+node:ekr.20031218072017.2834: *7* c_file.save
@g.commander_command('save')
@g.commander_command('file-save')
@g.commander_command('save-file')
def save(self, event=None, fileName=None):
    """Save a Leo outline to a file."""
    if False and g.app.gui.guiName() == 'curses':
        g.trace('===== Save disabled in curses gui =====')
        return
    c = self
    p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody:
        p.saveCursorAndScroll()
    if g.unitTesting and g.app.unitTestDict.get('init_error_dialogs') is not None:
        # A kludge for unit testing:
        # indicated that c.init_error_dialogs and c.raise_error_dialogs
        # will be called below, *without* actually saving the .leo file.
        c.init_error_dialogs()
        c.raise_error_dialogs(kind='write')
        return
    if g.app.disableSave:
        g.es("save commands disabled", color="purple")
        return
    c.init_error_dialogs()
    # 2013/09/28: use the fileName keyword argument if given.
    # This supports the leoBridge.
    # Make sure we never pass None to the ctor.
    if fileName:
        c.frame.title = g.computeWindowTitle(fileName)
        c.mFileName = fileName
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""
    if c.mFileName:
        # Calls c.clearChanged() if no error.
        g.app.syntax_error_files = []
        c.fileCommands.save(c.mFileName)
        c.syntaxErrorDialog()
    else:
        root = c.rootPosition()
        if not root.next() and root.isAtEditNode():
            # There is only a single @edit node in the outline.
            # A hack to allow "quick edit" of non-Leo files.
            # See https://bugs.launchpad.net/leo-editor/+bug/381527
            fileName = None
            # Write the @edit node if needed.
            if root.isDirty():
                c.atFileCommands.writeOneAtEditNode(root)
            c.clearChanged()  # Clears all dirty bits.
        else:
            fileName = ''.join(c.k.givenArgs)
            if not fileName:
                fileName = g.app.gui.runSaveFileDialog(c,
                    initialfile=c.mFileName,
                    title="Save",
                    filetypes=[("Leo files", "*.leo *.db"),],
                    defaultextension=g.defaultLeoFileExtension(c))
        c.bringToFront()
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, g.defaultLeoFileExtension(c))
            c.frame.title = c.computeWindowTitle(c.mFileName)
            c.frame.setTitle(c.computeWindowTitle(c.mFileName))
                # 2013/08/04: use c.computeWindowTitle.
            c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
                # Bug fix in 4.4b2.
            if g.app.qt_use_tabs and hasattr(c.frame, 'top'):
                c.frame.top.leo_master.setTabName(c, c.mFileName)
            c.fileCommands.save(c.mFileName)
            g.app.recentFilesManager.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)
    # Done in FileCommands.save.
    # c.redraw_after_icons_changed()
    c.raise_error_dialogs(kind='write')
    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll()
    else:
        c.treeWantsFocus()
#@+node:ekr.20031218072017.2835: *7* c_file.saveAs
@g.commander_command('save-as')
@g.commander_command('file-save-as')
@g.commander_command('save-file-as')
def saveAs(self, event=None, fileName=None):
    """Save a Leo outline to a file with a new filename."""
    c = self; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody: p.saveCursorAndScroll()
    if g.app.disableSave:
        g.es("save commands disabled", color="purple")
        return
    c.init_error_dialogs()
    # 2013/09/28: add fileName keyword arg for leoBridge scripts.
    if fileName:
        c.frame.title = g.computeWindowTitle(fileName)
        c.mFileName = fileName
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
    if not fileName:
        fileName = ''.join(c.k.givenArgs)
    if not fileName:
        fileName = g.app.gui.runSaveFileDialog(c,
            initialfile=c.mFileName,
            title="Save As",
            filetypes=[("Leo files", "*.leo *.db"),],
            defaultextension=g.defaultLeoFileExtension(c))
    c.bringToFront()
    if fileName:
        # Fix bug 998090: save file as doesn't remove entry from open file list.
        if c.mFileName:
            g.app.forgetOpenFile(c.mFileName)
        # Don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, g.defaultLeoFileExtension(c))
        # Part of the fix for https://bugs.launchpad.net/leo-editor/+bug/1194209
        c.frame.title = title = c.computeWindowTitle(c.mFileName)
        c.frame.setTitle(title)
            # 2013/08/04: use c.computeWindowTitle.
        c.openDirectory = c.frame.openDirectory = g.os_path_dirname(c.mFileName)
            # Bug fix in 4.4b2.
        # Calls c.clearChanged() if no error.
        if g.app.qt_use_tabs and hasattr(c.frame, 'top'):
            c.frame.top.leo_master.setTabName(c, c.mFileName)
        c.fileCommands.saveAs(c.mFileName)
        g.app.recentFilesManager.updateRecentFiles(c.mFileName)
        g.chdir(c.mFileName)
    # Done in FileCommands.saveAs.
    # c.redraw_after_icons_changed()
    c.raise_error_dialogs(kind='write')
    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll()
    else:
        c.treeWantsFocus()
#@+node:ekr.20031218072017.2836: *7* c_file.saveTo
@g.commander_command('save-to')
@g.commander_command('file-save-to')
@g.commander_command('save-file-to')
def saveTo(self, event=None, fileName=None, silent=False):
    """Save a Leo outline to a file, leaving the file associated with the Leo outline unchanged."""
    c = self; p = c.p
    # Do this now: w may go away.
    w = g.app.gui.get_focus(c)
    inBody = g.app.gui.widget_name(w).startswith('body')
    if inBody:
        p.saveCursorAndScroll()
    if g.app.disableSave:
        g.es("save commands disabled", color="purple")
        return
    c.init_error_dialogs()
    # Add fileName keyword arg for leoBridge scripts.
    if not fileName:
        # set local fileName, _not_ c.mFileName
        fileName = ''.join(c.k.givenArgs)
    if not fileName:
        fileName = g.app.gui.runSaveFileDialog(c,
            initialfile=c.mFileName,
            title="Save To",
            filetypes=[("Leo files", "*.leo *.db"),],
            defaultextension=g.defaultLeoFileExtension(c))
    c.bringToFront()
    if fileName:
        fileName = g.ensure_extension(fileName, g.defaultLeoFileExtension(c))
        c.fileCommands.saveTo(fileName, silent=silent)
        g.app.recentFilesManager.updateRecentFiles(fileName)
        g.chdir(fileName)
    c.raise_error_dialogs(kind='write')
    # *Safely* restore focus, without using the old w directly.
    if inBody:
        c.bodyWantsFocus()
        p.restoreCursorAndScroll()
    else:
        c.treeWantsFocus()
    c.outerUpdate()
#@+node:vitalije.20170831154850.1: *7* c_file.setReferenceFile
@g.commander_command('set-reference-file')
def setReferenceFile(self, event=None):
    """
    Shows a file open dialog allowing you to select a **reference** Leo
    document to which this outline will be connected.
       
    This command creates a **special separator node**, a top-level node
    whose headline is `---begin-private-area---` and whose body is the path
    to reference Leo file.
    
    The separator node splits the outline into two parts. The **public
    part** consists of all nodes above the separator node. The **private
    part** consists of all nodes below the separator node.
       
    The update-ref-file and read-ref-file commands operate on the **public
    part** of the outline. The update-ref-file command saves *only* the
    public part of the outline to reference Leo file. The read-ref-file
    command *completely replaces* the public part of the outline with the
    contents of reference Leo file.
    """
    c = self
    fileName = g.app.gui.runOpenFileDialog(c,
            title="Select reference Leo file",
            filetypes=[("Leo files", "*.leo *.db"),],
            defaultextension=g.defaultLeoFileExtension(c))
    if not fileName: return
    c.fileCommands.setReferenceFile(fileName)
#@+node:ekr.20100209160132.5759: *7* cacher.clear
def clear(self):
    """Clear the cache for all commanders."""
    # Careful: self.db may be a Python dict.
    try:
        self.db.clear()
    except Exception:
        g.trace('unexpected exception')
        g.es_exception()
        self.db = {}
#@+node:ekr.20180627062431.1: *7* cacher.close
def close(self):
    # Careful: self.db may be a dict.
    if hasattr(self.db, 'conn'):
        # pylint: disable=no-member
        self.db.conn.commit()
        self.db.conn.close()
#@+node:ekr.20180627042809.1: *7* cacher.commit
def commit(self):
    # Careful: self.db may be a dict.
    if hasattr(self.db, 'conn'):
        # pylint: disable=no-member
        self.db.conn.commit()
#@+node:ekr.20100210163813.5747: *7* cacher.save
def save(self, c, fn, changeName):
    """
    Save the per-commander cache.
    
    Change the cache prefix if changeName is True.
    
    save and save-as set changeName to True, save-to does not.
    """
    self.commit()
    if fn and changeName:
        # 1484: Change only the key!
        if isinstance(c.db, CommanderWrapper):
            c.db.key = fn
            self.commit()
        else:
            g.trace('can not happen', c.db.__class__.__name__)
#@+node:ekr.20100208065621.5890: *7* cacher.test
def test(self):

    # pylint: disable=no-member
    if g.app.gui.guiName() == 'nullGui':
        # Null gui's don't normally set the g.app.gui.db.
        g.app.setGlobalDb()
    # Fixes bug 670108.
    assert g.app.db is not None
        # a PickleShareDB instance.
    # Make sure g.guessExternalEditor works.
    g.app.db.get("LEO_EDITOR")
    self.initFileDB('~/testpickleshare')
    db = self.db
    db.clear()
    assert not list(db.items())
    db['hello'] = 15
    db['aku ankka'] = [1, 2, 313]
    db['paths/nest/ok/keyname'] = [1, (5, 46)]
    db.uncache()  # frees memory, causes re-reads later
    if 0: print(db.keys())
    db.clear()
    return True
#@+node:ekr.20100208062523.5885: *7* class CommanderCacher
class CommanderCacher:
    """A class to manage per-commander caches."""

    def __init__(self):
        try:
            path = join(g.app.homeLeoDir, 'db', 'global_data')
            self.db = SqlitePickleShare(path)
        except Exception:
            self.db = {}
    @others
#@+node:ekr.20100209160132.5759: *8* cacher.clear
def clear(self):
    """Clear the cache for all commanders."""
    # Careful: self.db may be a Python dict.
    try:
        self.db.clear()
    except Exception:
        g.trace('unexpected exception')
        g.es_exception()
        self.db = {}
#@+node:ekr.20180627062431.1: *8* cacher.close
def close(self):
    # Careful: self.db may be a dict.
    if hasattr(self.db, 'conn'):
        # pylint: disable=no-member
        self.db.conn.commit()
        self.db.conn.close()
#@+node:ekr.20180627042809.1: *8* cacher.commit
def commit(self):
    # Careful: self.db may be a dict.
    if hasattr(self.db, 'conn'):
        # pylint: disable=no-member
        self.db.conn.commit()
#@+node:ekr.20180611054447.1: *8* cacher.dump
def dump(self):
    """Dump the indicated cache if --trace-cache is in effect."""
    dump_cache(g.app.commander_db, tag='Commander Cache')
#@+node:ekr.20180627053508.1: *8* cacher.get_wrapper
def get_wrapper(self, c, fn=None):
    """Return a new wrapper for c."""
    return CommanderWrapper(c, fn=fn)
#@+node:ekr.20100208065621.5890: *8* cacher.test
def test(self):

    # pylint: disable=no-member
    if g.app.gui.guiName() == 'nullGui':
        # Null gui's don't normally set the g.app.gui.db.
        g.app.setGlobalDb()
    # Fixes bug 670108.
    assert g.app.db is not None
        # a PickleShareDB instance.
    # Make sure g.guessExternalEditor works.
    g.app.db.get("LEO_EDITOR")
    self.initFileDB('~/testpickleshare')
    db = self.db
    db.clear()
    assert not list(db.items())
    db['hello'] = 15
    db['aku ankka'] = [1, 2, 313]
    db['paths/nest/ok/keyname'] = [1, (5, 46)]
    db.uncache()  # frees memory, causes re-reads later
    if 0: print(db.keys())
    db.clear()
    return True
#@+node:ekr.20100210163813.5747: *8* cacher.save
def save(self, c, fn, changeName):
    """
    Save the per-commander cache.
    
    Change the cache prefix if changeName is True.
    
    save and save-as set changeName to True, save-to does not.
    """
    self.commit()
    if fn and changeName:
        # 1484: Change only the key!
        if isinstance(c.db, CommanderWrapper):
            c.db.key = fn
            self.commit()
        else:
            g.trace('can not happen', c.db.__class__.__name__)
#@+node:ekr.20180627052459.1: *7* class CommanderWrapper
class CommanderWrapper:
    """A class to distinguish keys from separate commanders."""

    def __init__(self, c, fn=None):
        self.c = c
        self.db = g.app.db
        self.key = fn or c.mFileName
        self.user_keys = set()

    def get(self, key, default=None):
        value = self.db.get(f"{self.key}:::{key}")
        return default if value is None else value

    def keys(self):
        return sorted(list(self.user_keys))

    def __contains__(self, key):
        return f"{self.key}:::{key}" in self.db

    def __delitem__(self, key):
        if key in self.user_keys:
            self.user_keys.remove(key)
        del self.db[f"{self.key}:::{key}"]

    def __getitem__(self, key):
        return self.db[f"{self.key}:::{key}"]
            # May (properly) raise KeyError

    def __setitem__(self, key, value):
        self.user_keys.add(key)
        self.db[f"{self.key}:::{key}"] = value
#@+node:ekr.20180627041556.1: *7* class GlobalCacher
class GlobalCacher:
    """A singleton global cacher, g.app.db"""

    def __init__(self):
        """Ctor for the GlobalCacher class."""
        trace = 'cache' in g.app.debug
        try:
            path = join(g.app.homeLeoDir, 'db', 'g_app_db')
            if trace:
                print('path for g.app.db:', repr(path))
            self.db = SqlitePickleShare(path)
            if trace and self.db is not None:
                self.dump(tag='Startup')
        except Exception:
            if trace:
                g.es_exception()
            self.db = {}  # Use a plain dict as a dummy.
    @others
#@+node:ekr.20180627045750.1: *8* g_cacher.clear
def clear(self):
    """Clear the global cache."""
    # Careful: self.db may be a Python dict.
    if 'cache' in g.app.debug:
        g.trace('clear g.app.db')
    try:
        self.db.clear(verbose=True)
    except TypeError:
        self.db.clear()
    except Exception:
        g.trace('unexpected exception')
        g.es_exception()
        self.db = {}
#@+node:ekr.20180627042948.1: *8* g_cacher.commit_and_close()
def commit_and_close(self):
    # Careful: self.db may be a dict.
    if hasattr(self.db, 'conn'):
        # pylint: disable=no-member
        if 'cache' in g.app.debug:
            self.dump(tag='Shutdown')
        self.db.conn.commit()
        self.db.conn.close()
#@+node:ekr.20180627045953.1: *8* g_cacher.dump
def dump(self, tag=''):
    """Dump the indicated cache if --trace-cache is in effect."""
    tag0 = 'Global Cache'
    tag2 = f"{tag0}: {tag}" if tag else tag0
    dump_cache(self.db, tag2)
        # Careful: g.app.db may not be set yet.
#@+node:ekr.20200903101030.1: *7* crash after saving the .db file
Traceback (most recent call last):
  File "c:\leo.repo\leo-editor\launchLeo.py", line 8, in <module>
    leo.core.runLeo.run()
  File "c:\leo.repo\leo-editor\leo\core\runLeo.py", line 75, in run
    g.app.loadManager.load(fileName, pymacs)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2615, in load
    lm.doPrePluginsInit(fileName, pymacs)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2799, in doPrePluginsInit
    lm.readGlobalSettingsFiles()
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2556, in readGlobalSettingsFiles
    lm.theme_path = lm.computeThemeFilePath()
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2191, in computeThemeFilePath
    theme_c = lm.openSettingsFile(path)
  File "c:\leo.repo\leo-editor\leo\core\leoApp.py", line 2518, in openSettingsFile
    readAtFileNodesFlag=False, silent=True)
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 708, in openLeoFile
    silent=silent,
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 567, in getLeoFile
    v = fc.retrieveVnodesFromDb(theFile) or fc.initNewDb(theFile)
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 1007, in retrieveVnodesFromDb
    p = fc.decodePosition(encp)
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 1727, in decodePosition
    stack = [(fc.gnxDict[x], int(y)) for x, y in stack]
  File "c:\leo.repo\leo-editor\leo\core\leoFileCommands.py", line 1727, in <listcomp>
    stack = [(fc.gnxDict[x], int(y)) for x, y in stack]
KeyError: 'kgh.20200827123258.1'
#@+node:ekr.20150405200212.1: *7* efc.ask
def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @<file> tree.
    Return True if the user agrees.
    '''
    if g.unitTesting:
        return False
    if c not in g.app.commanders():
        return False
    if self.yesno_all_time + 3 >= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        return bool('yes' in self.yesno_all_answer.lower())
    if not p:
        for ef in self.files:
            if ef.path == path:
                where = ef.p.h
                break
        else:
            where = 'the outline node'
    else:
        where = p.h
    _is_leo = path.endswith(('.leo', '.db'))
    if _is_leo:
        s = '\n'.join([
            f"{g.splitLongFileName(path)} has changed outside Leo.",
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            f"{g.splitLongFileName(path)} has changed outside Leo.",
            f"Reload {where} in Leo?",
        ])
    result = g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
        yes_all=not _is_leo, no_all=not _is_leo)
    if result and "-all" in result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = result.lower()
    return bool(result and 'yes' in result.lower())
        # Careful: may be unit testing.
#@+node:ekr.20180708060437.1: *7* fast.getGlobalData
def getGlobalData(self):
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
#@+node:ekr.20180624125321.1: *7* fast.handleBits (reads c.db)
def handleBits(self):
    """Restore the expanded and marked bits from c.db."""
    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
#@+node:ekr.20031218072017.1553: *7* fc.getLeoFile & helpers (read main line)
def getLeoFile(self,
    theFile,
    fileName,
    readAtFileNodesFlag=True,
    silent=False,
    checkOpenFiles=True,
):
    """
        Read a .leo file.
        The caller should follow this with a call to c.redraw().
    """
    fc, c = self, self.c
    t1 = time.time()
    c.clearChanged()  # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()
    recoveryNode = None
    try:
        c.loading = True  # disable c.changed
        if not silent and checkOpenFiles:
            # Don't check for open file when reverting.
            g.app.checkForOpenFile(c, fileName)
        #
        # Read the .leo file and create the outline.
        if fileName.endswith('.db'):
            v = fc.retrieveVnodesFromDb(theFile) or fc.initNewDb(theFile)
        else:
            v = FastRead(c, self.gnxDict).readFile(fileName)
            if v:
                c.hiddenRootNode = v
        if v:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            if readAtFileNodesFlag:
                # c.redraw()
                    # Does not work.
                    # Redraw before reading the @file nodes so the screen isn't blank.
                    # This is important for big files like LeoPy.leo.
                recoveryNode = fc.readExternalFiles(fileName)
    finally:
        p = recoveryNode or c.p or c.lastTopLevel()
            # lastTopLevel is a better fallback, imo.
        c.selectPosition(p)
        c.redraw_later()
            # Delay the second redraw until idle time.
            # This causes a slight flash, but corrects a hangnail.
        c.checkOutline()
            # Must be called *after* ni.end_holding.
        c.loading = False
            # reenable c.changed
        if not isinstance(theFile, sqlite3.Connection):
            theFile.close()
            # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1208942
            # Leo holding directory/file handles after file close?
    if c.changed:
        fc.propegateDirtyNodes()
    fc.initReadIvars()
    t2 = time.time()
    g.es(f"read outline in {t2 - t1:2.2f} seconds")
    return v, c.frame.ratio
#@+node:ekr.20100205060712.8314: *8* fc.handleNodeConflicts
def handleNodeConflicts(self):
    """Create a 'Recovered Nodes' node for each entry in c.nodeConflictList."""
    c = self.c
    if not c.nodeConflictList:
        return None
    if not c.make_node_conflicts_node:
        s = f"suppressed {len(c.nodeConflictList)} node conflicts"
        g.es(s, color='red')
        g.pr('\n' + s + '\n')
        return None
    # Create the 'Recovered Nodes' node.
    last = c.lastTopLevel()
    root = last.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()
    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn = bunch.get('fileName') or ''
        b1, h1 = bunch.get('b_old'), bunch.get('h_old')
        b2, h2 = bunch.get('b_new'), bunch.get('h_new')
        root_v = bunch.get('root_v') or ''
        child = root.insertAsLastChild()
        h = f'Recovered node "{h1}" from {g.shortFileName(fn)}'
        child.setHeadString(h)
        if b1 == b2:
            lines = [
                'Headline changed...',
                f"{tag} gnx: {gnx} root: {(root_v and root.v)!r}",
                f"old headline: {h1}",
                f"new headline: {h2}",
            ]
            child.setBodyString('\n'.join(lines))
        else:
            line1 = f"{tag} gnx: {gnx} root: {root_v and root.v!r}\nDiff...\n"
            d = difflib.Differ().compare(g.splitLines(b1), g.splitLines(b2))
                # 2017/06/19: reverse comparison order.
            diffLines = [z for z in d]
            lines = [line1]
            lines.extend(diffLines)
            # There is less need to show trailing newlines because
            # we don't report changes involving only trailing newlines.
            child.setBodyString(''.join(lines))
            n1 = child.insertAsNthChild(0)
            n2 = child.insertAsNthChild(1)
            n1.setHeadString('old:' + h1)
            n1.setBodyString(b1)
            n2.setHeadString('new:' + h2)
            n2.setBodyString(b2)
    return root
#@+node:ekr.20100124110832.6212: *8* fc.propegateDirtyNodes
def propegateDirtyNodes(self):
    fc = self; c = fc.c
    aList = [z for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
#@+node:ekr.20120212220616.10537: *8* fc.readExternalFiles
def readExternalFiles(self, fileName):
    """Read all external files."""
    c, fc = self.c, self
    c.atFileCommands.readAll(c.rootPosition(), force=False)
    recoveryNode = fc.handleNodeConflicts()
    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read
    # the @thin nodes!
    fc.restoreDescendentAttributes()
    fc.setPositionsFromVnodes()
    return recoveryNode
#@+node:ekr.20031218072017.1554: *8* fc.warnOnReadOnlyFiles
def warnOnReadOnlyFiles(self, fileName):
    # os.access may not exist on all platforms.
    try:
        self.read_only = not os.access(fileName, os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False
    if self.read_only and not g.unitTesting:
        g.error("read only:", fileName)
#@+node:ekr.20031218072017.3037: *7* fc.putGlobals (sets window_position)
def putGlobals(self):
    """Put a vestigial <globals> element, and write global data to the cache."""
    trace = 'cache' in g.app.debug
    c = self.c
    self.put("<globals/>\n")
    if not c.mFileName:
        return
    c.db['body_outline_ratio'] = str(c.frame.ratio)
    c.db['body_secondary_ratio'] = str(c.frame.secondary_ratio)
    w, h, l, t = c.frame.get_window_info()
    c.db['window_position'] = str(t), str(l), str(h), str(w)
    if trace:
        g.trace(f"\nset c.db for {c.shortFileName()}")
        print('window_position:', c.db['window_position'])
#@+node:ekr.20190328160622.1: *7* fc.setCachedBits
def setCachedBits(self):
    """
    Set the cached expanded and marked bits for *all* nodes.
    Also cache the current position.
    """
    trace = 'cache' in g.app.debug
    c = self.c
    if not c.mFileName:
        return  # New.
    current = [str(z) for z in self.currentPosition.archivedPosition()]
    expanded = [v.gnx for v in c.all_unique_nodes() if v.isExpanded()]
    marked = [v.gnx for v in c.all_unique_nodes() if v.isMarked()]
    c.db['expanded'] = ','.join(expanded)
    c.db['marked'] = ','.join(marked)
    c.db['current_position'] = ','.join(current)
    if trace:
        g.trace(f"\nset c.db for {c.shortFileName()}")
        print('expanded:', expanded)
        print('marked:', marked)
        print('current_position:', current)
        print('')
#@+node:ekr.20060919110638.13: *7* fc.setPositionsFromVnodes
def setPositionsFromVnodes(self):

    c, root = self.c, self.c.rootPosition()
    if c.sqlite_connection:
        # position is already selected
        return
    current, str_pos = None, None
    if c.mFileName:
        str_pos = c.db.get('current_position')
    if str_pos is None:
        d = root.v.u
        if d: str_pos = d.get('str_leo_pos')
    if str_pos is not None:
        current = self.archivedPositionToPosition(str_pos)
    c.setCurrentPosition(current or c.rootPosition())
#@+node:ekr.20031218072017.3046: *7* fc.write_Leo_file & helpers
def write_Leo_file(self, fileName, outlineOnlyFlag, toString=False, toOPML=False):
    """Write the .leo file."""
    c, fc = self.c, self
    structure_errors = c.checkOutline()
    if structure_errors:
        g.error('Major structural errors! outline not written')
        return False

    if not outlineOnlyFlag or toOPML:
        g.app.recentFilesManager.writeRecentFilesFile(c)
        fc.writeAllAtFileNodesHelper()  # Ignore any errors.

    if fc.isReadOnly(fileName):
        return False

    if fileName and fileName.endswith('.db'):
        return fc.exportToSqlite(fileName)

    try:
        fc.putCount = 0
        fc.toString = toString
        if toString:
            ok = fc.writeToStringHelper(fileName)
        else:
            ok = fc.writeToFileHelper(fileName, toOPML)
    finally:
        fc.outputFile = None
        fc.toString = False
    return ok

write_LEO_file = write_Leo_file  # For compatibility with old plugins.
#@+node:ekr.20040324080359.1: *8* fc.isReadOnly
def isReadOnly(self, fileName):
    # self.read_only is not valid for Save As and Save To commands.
    if g.os_path_exists(fileName):
        try:
            if not os.access(fileName, os.W_OK):
                g.error("can not write: read only:", fileName)
                return True
        except Exception:
            pass  # os.access() may not exist on all platforms.
    return False
#@+node:ekr.20100119145629.6114: *8* fc.writeAllAtFileNodesHelper
def writeAllAtFileNodesHelper(self):
    """Write all @<file> nodes and set orphan bits."""
    c = self.c
    try:
        # 2010/01/19: Do *not* signal failure here.
        # This allows Leo to quit properly.
        c.atFileCommands.writeAll(all=False)
        return True
    except Exception:
        # Work around bug 1260415: https://bugs.launchpad.net/leo-editor/+bug/1260415
        g.es_error("exception writing external files")
        g.es_exception()
        g.es('Internal error writing one or more external files.', color='red')
        g.es('Please report this error to:', color='blue')
        g.es('https://groups.google.com/forum/#!forum/leo-editor', color='blue')
        g.es('All changes will be lost unless you', color='red')
        g.es('can save each changed file.', color='red')
        return False
#@+node:ekr.20100119145629.6111: *8* fc.writeToFileHelper & helpers
def writeToFileHelper(self, fileName, toOPML):
    c = self.c; toZip = c.isZipped
    ok, backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName, theActualFile = self.createActualFile(fileName, toOPML, toZip)
    if not theActualFile: return False
    self.mFileName = fileName
    self.outputFile = StringIO()  # Always write to a string.
    try:
        if toOPML:
            if hasattr(c, 'opmlController'):
                c.opmlController.putToOPML(owner=self)
            else:
                # This is not likely ever to be called.
                g.trace('leoOPML plugin not active.')
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s  # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            s = bytes(s, self.leo_file_encoding, 'replace')
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName, 'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(fileName, backupName, theActualFile)
        return False
#@+node:ekr.20100119145629.6106: *9* fc.createActualFile
def createActualFile(self, fileName, toOPML, toZip):
    if toZip:
        self.toString = True
        theActualFile = None
    else:
        try:
            # 2010/01/21: always write in binary mode.
            theActualFile = open(fileName, 'wb')
        except Exception:
            g.es(f"can not create {fileName}")
            g.es_exception()
            theActualFile = None
    return fileName, theActualFile
#@+node:ekr.20031218072017.3047: *9* fc.createBackupFile
def createBackupFile(self, fileName):
    """
        Create a closed backup file and copy the file to it,
        but only if the original file exists.
    """
    if g.os_path_exists(fileName):
        fd, backupName = tempfile.mkstemp(text=False)
        f = open(fileName, 'rb')  # rb is essential.
        s = f.read()
        f.close()
        try:
            try:
                os.write(fd, s)
            finally:
                os.close(fd)
            ok = True
        except Exception:
            g.error('exception creating backup file')
            g.es_exception()
            ok, backupName = False, None
        if not ok and self.read_only:
            g.error("read only")
    else:
        ok, backupName = True, None
    return ok, backupName
#@+node:ekr.20100119145629.6108: *9* fc.handleWriteLeoFileException
def handleWriteLeoFileException(self, fileName, backupName, theActualFile):
    c = self.c
    g.es("exception writing:", fileName)
    g.es_exception(full=True)
    if theActualFile:
        theActualFile.close()
    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName, '')
    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring", fileName, "from", backupName)
        # No need to create directories when restoring.
        g.utils_rename(c, backupName, fileName)
    else:
        g.error('backup file does not exist!', repr(backupName))
#@+node:ekr.20100119145629.6110: *8* fc.writeToStringHelper
def writeToStringHelper(self, fileName):
    try:
        self.mFileName = fileName
        self.outputFile = StringIO()
        self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s
        return True
    except Exception:
        g.es("exception writing:", fileName)
        g.es_exception(full=True)
        g.app.write_Leo_file_string = ''
        return False
#@+node:ekr.20070412095520: *8* fc.writeZipFile
def writeZipFile(self, s):
    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding, reportErrors=True)
    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding, reportErrors=True)
    # Write the archive.
    theFile = zipfile.ZipFile(fileName, 'w', zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName, s)
    theFile.close()
#@+node:vitalije.20170630172118.1: *8* fc.exportToSqlite
def exportToSqlite(self, fileName):
    """Dump all vnodes to sqlite database. Returns True on success."""
    # fc = self
    c = self.c; fc = self
    if c.sqlite_connection is None:
        c.sqlite_connection = sqlite3.connect(fileName,
                                    isolation_level='DEFERRED')
    conn = c.sqlite_connection

    def dump_u(v):
        try:
            s = pickle.dumps(v.u, protocol=1)
        except pickle.PicklingError:
            s = ''
            g.trace('unpickleable value', repr(v.u))
        return s

    dbrow = lambda v: (
            v.gnx,
            v.h,
            v.b,
            ' '.join(x.gnx for x in v.children),
            ' '.join(x.gnx for x in v.parents),
            v.iconVal,
            v.statusBits,
            dump_u(v)
        )
    ok = False
    try:
        fc.prepareDbTables(conn)
        fc.exportDbVersion(conn)
        fc.exportVnodesToSqlite(conn, (dbrow(v) for v in c.all_unique_nodes()))
        fc.exportGeomToSqlite(conn)
        fc.exportHashesToSqlite(conn)
        conn.commit()
        ok = True
    except sqlite3.Error as e:
        g.internalError(e)
    return ok
#@+node:vitalije.20170705075107.1: *9* fc.decodePosition
def decodePosition(self, s):
    """Creates position from its string representation encoded by fc.encodePosition."""
    fc = self
    if not s:
        return fc.c.rootPosition()
    sep = '<->'
    comma = ','
    stack = [x.split(comma) for x in s.split(sep)]
    stack = [(fc.gnxDict[x], int(y)) for x, y in stack]
    v, ci = stack[-1]
    p = leoNodes.Position(v, ci, stack[:-1])
    return p
#@+node:vitalije.20170705075117.1: *9* fc.encodePosition
def encodePosition(self, p):
    """New schema for encoding current position hopefully simplier one."""
    jn = '<->'
    mk = '%s,%s'
    res = [mk % (x.gnx, y) for x, y in p.stack]
    res.append(mk % (p.gnx, p._childIndex))
    return jn.join(res)
#@+node:vitalije.20170811130512.1: *9* fc.prepareDbTables
def prepareDbTables(self, conn):
    conn.execute('''drop table if exists vnodes;''')
    conn.execute(
        '''
        create table if not exists vnodes(
            gnx primary key,
            head,
            body,
            children,
            parents,
            iconVal,
            statusBits,
            ua);''',
    )
    conn.execute(
        '''create table if not exists extra_infos(name primary key, value)''')
#@+node:vitalije.20170701161851.1: *9* fc.exportVnodesToSqlite
def exportVnodesToSqlite(self, conn, rows):
    conn.executemany(
        '''insert into vnodes
        (gnx, head, body, children, parents,
            iconVal, statusBits, ua)
        values(?,?,?,?,?,?,?,?);''',
        rows,
    )
#@+node:vitalije.20170701162052.1: *9* fc.exportGeomToSqlite
def exportGeomToSqlite(self, conn):
    c = self.c
    data = zip(
        (
            'width', 'height', 'left', 'top',
            'ratio', 'secondary_ratio',
            'current_position'
        ),
        c.frame.get_window_info() +
        (
            c.frame.ratio, c.frame.secondary_ratio,
            self.encodePosition(c.p)
        )
    )
    conn.executemany('replace into extra_infos(name, value) values(?, ?)', data)
#@+node:vitalije.20170811130559.1: *9* fc.exportDbVersion
def exportDbVersion(self, conn):
    conn.execute(
        "replace into extra_infos(name, value) values('dbversion', ?)", ('1.0',))
#@+node:vitalije.20170701162204.1: *9* fc.exportHashesToSqlite
def exportHashesToSqlite(self, conn):
    c = self.c

    def md5(x):
        try:
            s = open(x, 'rb').read()
        except Exception:
            return ''
        s = s.replace(b'\r\n', b'\n')
        return hashlib.md5(s).hexdigest()

    files = set()

    p = c.rootPosition()
    while p:
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode() or p.isAtFileNode():
            fn = c.getNodeFileName(p)
            files.add((fn, 'md5_' + p.gnx))
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    conn.executemany(
        'replace into extra_infos(name, value) values(?,?)',
        map(lambda x: (x[1], md5(x[0])), files))
#@+node:ekr.20120419095424.9927: *7* flc.loadLayouts (sets wrap=True)
def loadLayouts(self, tag, keys, reloading=False):
    """loadLayouts - Load the outlines layout

    :Parameters:
    - `tag`: from hook event
    - `keys`: from hook event
    - `reloading`: True if this is not the initial load, see below

    When called from the `after-create-leo-frame2` hook this defaults
    to False.  When called from the `resotre-layout` command, this is set
    True, and the layout the outline had *when first loaded* is restored.
    Useful if you want to temporarily switch to a different layout and then
    back, without having to remember the original layouts name.
    """
    c = self.c
    if not (g.app and g.app.db):
        return  # Can happen when running from the Leo bridge.
    d = g.app.db.get('ns_layouts') or {}
    if c != keys.get('c'):
        return
    layout = c.config.getData("free-layout-layout")
    if layout:
        layout = json.loads('\n'.join(layout))
    name = c.db.get('_ns_layout')
    if name:
        if reloading:
            name = c.free_layout.original_layout
            c.db['_ns_layout'] = name
        else:
            c.free_layout.original_layout = name
        if layout:
            g.es("NOTE: embedded layout in @settings/@data free-layout-layout "
                 "overrides saved layout " + name)
        else:
            layout = d.get(name)
    # EKR: Create commands that will load each layout.
    if d:
        for name in sorted(d.keys()):

            def func(event, c=c, d=d, name=name):
                layout = d.get(name)
                if layout:
                    c.free_layout.get_top_splitter().load_layout(layout)
                else:
                    g.trace('no layout', name)

            name_s = name.strip().lower().replace(' ', '-')
            commandName = f"free-layout-load-{name_s}"
            c.k.registerCommand(commandName, func)
    # Careful: we could be unit testing or in the Leo bridge.
    if layout:
        splitter = c.free_layout.get_top_splitter()
        if splitter:
            splitter.load_layout(layout)
#@+node:tbrown.20110628083641.11730: *7* flc.ns_context
def ns_context(self):
    ans = [
        ('Embed layout', '_fl_embed_layout'),
        ('Save layout', '_fl_save_layout'),
    ]
    d = g.app.db.get('ns_layouts', {})
    if d:
        ans.append({'Load layout': [(k, '_fl_load_layout:' + k) for k in d]})
        ans.append({'Delete layout': [(k, '_fl_delete_layout:' + k) for k in d]})
        ans.append(('Forget layout', '_fl_forget_layout:'))
        ans.append(('Restore initial layout', '_fl_restore_layout:'))
    ans.append(('Restore default layout', '_fl_restore_default:'))
    ans.append(('Help for this menu', '_fl_help:'))
    return ans
#@+node:tbrown.20110628083641.11732: *7* flc.ns_do_context
def ns_do_context(self, id_, splitter, index):
    if id_.startswith('_fl_embed_layout'):
        self.embed()
        return True
    if id_.startswith('_fl_restore_default'):
        self.get_top_splitter().load_layout(
            {'content': [{'content': ['_leo_pane:outlineFrame',
             '_leo_pane:logFrame'], 'orientation': 1, 'sizes':
             [509, 275]}, '_leo_pane:bodyFrame'],
             'orientation': 2, 'sizes': [216, 216]})
    if id_.startswith('_fl_help'):
        self.c.putHelpFor(__doc__)
        # g.handleUrl("http://leoeditor.com/")
        return True
    if id_ == '_fl_save_layout':
        if self.c.config.getData("free-layout-layout"):
            g.es("WARNING: embedded layout in")
            g.es("@settings/@data free-layout-layout")
            g.es("will override saved layout")
        layout = self.get_top_splitter().get_saveable_layout()
        name = g.app.gui.runAskOkCancelStringDialog(self.c,
            title="Save layout",
            message="Name for layout?",
        )
        if name:
            self.c.db['_ns_layout'] = name
            d = g.app.db.get('ns_layouts', {})
            d[name] = layout
            # make sure g.app.db's __set_item__ is hit so it knows to save
            g.app.db['ns_layouts'] = d
        return True
    if id_.startswith('_fl_load_layout:'):
        if self.c.config.getData("free-layout-layout"):
            g.es("WARNING: embedded layout in")
            g.es("@settings/@data free-layout-layout")
            g.es("will override saved layout")
        name = id_.split(':', 1)[1]
        self.c.db['_ns_layout'] = name
        layout = g.app.db['ns_layouts'][name]
        self.get_top_splitter().load_layout(layout)
        return True
    if id_.startswith('_fl_delete_layout:'):
        name = id_.split(':', 1)[1]
        if ('yes' == g.app.gui.runAskYesNoCancelDialog(self.c,
            "Really delete Layout?",
            f"Really permanently delete the layout '{name}'?")
        ):
            d = g.app.db.get('ns_layouts', {})
            del d[name]
            # make sure g.app.db's __set_item__ is hit so it knows to save
            g.app.db['ns_layouts'] = d
            if '_ns_layout' in self.c.db:
                del self.c.db['_ns_layout']
        return True
    if id_.startswith('_fl_forget_layout:'):
        if '_ns_layout' in self.c.db:
            del self.c.db['_ns_layout']
        return True
    if id_.startswith('_fl_restore_layout:'):
        self.loadLayouts("reload", {'c': self.c}, reloading=True)
        return True
    return False
#@+node:ekr.20031218072017.3118: *7* g.ensure_extension
def ensure_extension(name, ext):

    theFile, old_ext = g.os_path_splitext(name)
    if not name:
        return name  # don't add to an empty name.
    if old_ext in ('.db', '.leo'):
        return name
    if old_ext and old_ext == ext:
        return name
    return name + ext
#@+node:ville.20090701144325.14942: *7* g.guessExternalEditor
def guessExternalEditor(c=None):
    """ Return a 'sensible' external editor """
    editor = (
        os.environ.get("LEO_EDITOR") or
        os.environ.get("EDITOR") or
        g.app.db and g.app.db.get("LEO_EDITOR") or
        c and c.config.getString('external-editor'))
    if editor: return editor
    # fallbacks
    platform = sys.platform.lower()
    if platform.startswith('win'):
        return "notepad"
    if platform.startswith('linux'):
        return 'gedit'
    g.es(
        '''No editor set.
Please set LEO_EDITOR or EDITOR environment variable,
or do g.app.db['LEO_EDITOR'] = "gvim"''',
    )
    return None
#@+node:ekr.20060913090832.1: *7* g.init_zodb
init_zodb_import_failed = False
init_zodb_failed = {}  # Keys are paths, values are True.
init_zodb_db = {}  # Keys are paths, values are ZODB.DB instances.

def init_zodb(pathToZodbStorage, verbose=True):
    """
    Return an ZODB.DB instance from the given path.
    return None on any error.
    """
    global init_zodb_db, init_zodb_failed, init_zodb_import_failed
    db = init_zodb_db.get(pathToZodbStorage)
    if db: return db
    if init_zodb_import_failed: return None
    failed = init_zodb_failed.get(pathToZodbStorage)
    if failed: return None
    try:
        import ZODB
    except ImportError:
        if verbose:
            g.es('g.init_zodb: can not import ZODB')
            g.es_exception()
        init_zodb_import_failed = True
        return None
    try:
        storage = ZODB.FileStorage.FileStorage(pathToZodbStorage)
        init_zodb_db[pathToZodbStorage] = db = ZODB.DB(storage)
        return db
    except Exception:
        if verbose:
            g.es('g.init_zodb: exception creating ZODB.DB instance')
            g.es_exception()
        init_zodb_failed[pathToZodbStorage] = True
        return None
#@+node:ekr.20180627045750.1: *7* g_cacher.clear
def clear(self):
    """Clear the global cache."""
    # Careful: self.db may be a Python dict.
    if 'cache' in g.app.debug:
        g.trace('clear g.app.db')
    try:
        self.db.clear(verbose=True)
    except TypeError:
        self.db.clear()
    except Exception:
        g.trace('unexpected exception')
        g.es_exception()
        self.db = {}
#@+node:ekr.20180627042948.1: *7* g_cacher.commit_and_close()
def commit_and_close(self):
    # Careful: self.db may be a dict.
    if hasattr(self.db, 'conn'):
        # pylint: disable=no-member
        if 'cache' in g.app.debug:
            self.dump(tag='Shutdown')
        self.db.conn.commit()
        self.db.conn.close()
#@+node:ekr.20180627045953.1: *7* g_cacher.dump
def dump(self, tag=''):
    """Dump the indicated cache if --trace-cache is in effect."""
    tag0 = 'Global Cache'
    tag2 = f"{tag0}: {tag}" if tag else tag0
    dump_cache(self.db, tag2)
        # Careful: g.app.db may not be set yet.
#@+node:ekr.20170806094320.9: *7* gdc.get_files
def get_files(self, rev1, rev2):
    """Return a list of changed files."""

    def readable(fn):
        for suffix in ('.db', '.leo', '.zip',):  # 'commit_timestamp.json',
            if fn.strip().endswith(suffix):
                return False
        return True

    command = f"git diff --name-only {(rev1 or '')} {(rev2 or '')}"
    files = [
        z.strip() for z in g.execGitCommand(command, self.repo_dir)
            if readable(z)
    ]
    return files
#@+node:ekr.20120223062418.10419: *7* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
#@+node:ekr.20120224161905.10030: *7* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
#@+node:vitalije.20190923081235.1: *7* reopen_cachers
def reopen_cachers(self):
    import leo.core.leoCache as leoCache

    g = self.g
    try:
        g.app.db.get('dummy')
    except Exception:
        g.app.global_cacher = leoCache.GlobalCacher()
        g.app.db = g.app.global_cacher.db
        g.app.commander_cacher = leoCache.CommanderCacher()
        g.app.commander_db = g.app.commander_cacher.db
#@+node:ekr.20180121041748.1: *7* tipm.get_next_tip
def get_next_tip(self):
    global tips
    db = g.app.db
    # Compute list of unseen tips.
    seen = db.get(self.key, [])
    unseen = [i for i in range(len(tips)) if i not in seen]
    if not unseen:
        db[self.key] = []
        unseen = list(range(len(tips)))
        seen = []
    # Choose a tip at random from the unseen tips.
    i = random.choice(unseen)
    assert i not in seen, (i, seen)
    seen.append(i)
    db[self.key] = seen
    return tips[i]
#@+node:ekr.20181102023828.1: *7* tm.do_tests_helper
def do_tests_helper(self, all, marked, verbosity):

    c = self.c
    suite = self.make_test_suite(all, marked)
    if not suite:
        g.error(
            f"no {'marked ' if marked else ''}"
            f"@test or @suite nodes in "
            f"{'entire' if all else 'selected'} outline")
        return
    #
    # New in Leo 5.8.1: re-init the dict.
    g.app.unitTestDict = {
        'fail': False, 'c': c, 'g': g, 'p': c.p.copy(),
    }
    #
    # 1. Set logger, handler, stream, runner
    gui_name = g.app.gui.guiName().lower()
    if gui_name == 'curses':
        logger, handler, stream = self.create_logging_stream()
        runner = unittest.TextTestRunner(
            failfast=g.app.failFast,
            stream=stream,
            verbosity=verbosity,
        )
    else:
        logger, handler, stream = None, None, None
        runner = unittest.TextTestRunner(
            failfast=g.app.failFast,
            verbosity=verbosity,
        )
    #
    # 2. Run the unit tests, with the NullGui.
    g.app.old_gui = old_gui = g.app.gui
    g.app.old_gui_name = g.app.gui.guiName()
    new_gui = self.instantiate_gui()
        # New in Leo 5.8.1.
    old_frame = c.frame
    old_k_w = c.k.w
    try:
        import leo.core.leoFrame as leoFrame
        g.app.gui = new_gui
        c.frame = leoFrame.NullFrame(c, title='<title>', gui=g.app.gui)
        c.frame.openDirectory = old_frame.openDirectory
            # A kluge, but quite useful.
        c.k.w = None
            # A huge switcheroo.
        result = runner.run(suite)
    finally:
        g.app.gui = old_gui
        c.frame = old_frame
        c.k.w = old_k_w
    #
    # 3. Clean up.
    if stream:
        if stream.aList:
            # pylint: disable=logging-not-lazy
                # This may be a pylint issue.
            logger.info('\n' + ''.join(stream.aList))
        logger.removeHandler(handler)
    #
    # 4. Support for the quicksearch plugin.
    if gui_name not in ('browser', 'curses'):
        key = 'unittest/cur/fail'
        archive = [(t.p.gnx, trace2) for (t, trace2) in result.errors]
        c.db[key] = archive
#@+node:vitalije.20170630152841.1: *6* fc.retrieveVnodesFromDb
def retrieveVnodesFromDb(self, conn):
    """
    Recreates tree from the data contained in table vnodes.
    
    This method follows behavior of readSaxFile.
    """

    c, fc = self.c, self
    sql = '''select gnx, head, 
         body,
         children,
         parents,
         iconVal,
         statusBits,
         ua from vnodes'''
    vnodes = []
    try:
        for row in conn.execute(sql):
            (gnx, h, b, children, parents, iconVal, statusBits, ua) = row
            try:
                ua = pickle.loads(g.toEncodedString(ua))
            except ValueError:
                ua = None
            v = leoNodes.VNode(context=c, gnx=gnx)
            v._headString = h
            v._bodyString = b
            v.children = children.split()
            v.parents = parents.split()
            v.iconVal = iconVal
            v.statusBits = statusBits
            v.u = ua
            vnodes.append(v)
    except sqlite3.Error as er:
        if er.args[0].find('no such table') < 0:
            # there was an error raised but it is not the one we expect
            g.internalError(er)
        # there is no vnodes table
        return None

    rootChildren = [x for x in vnodes if 'hidden-root-vnode-gnx' in x.parents]
    if not rootChildren:
        g.trace('there should be at least one top level node!')
        return None

    findNode = lambda x: fc.gnxDict.get(x, c.hiddenRootNode)

    # let us replace every gnx with the corresponding vnode
    for v in vnodes:
        v.children = [findNode(x) for x in v.children]
        v.parents = [findNode(x) for x in v.parents]
    c.hiddenRootNode.children = rootChildren
    (w, h, x, y, r1, r2, encp) = fc.getWindowGeometryFromDb(conn)
    c.frame.setTopGeometry(w, h, x, y)
    c.frame.resizePanesToRatio(r1, r2)
    p = fc.decodePosition(encp)
    c.setCurrentPosition(p)
    return rootChildren[0]
#@+node:vitalije.20170815162307.1: *7* fc.initNewDb
def initNewDb(self, conn):
    """ Initializes tables and returns None"""
    fc = self; c = self.c
    v = leoNodes.VNode(context=c)
    c.hiddenRootNode.children = [v]
    (w, h, x, y, r1, r2, encp) = fc.getWindowGeometryFromDb(conn)
    c.frame.setTopGeometry(w, h, x, y)
    c.frame.resizePanesToRatio(r1, r2)
    c.sqlite_connection = conn
    fc.exportToSqlite(c.mFileName)
    return v
#@+node:vitalije.20170630200802.1: *7* fc.getWindowGeometryFromDb
def getWindowGeometryFromDb(self, conn):
    geom = (600, 400, 50, 50, 0.5, 0.5, '')
    keys = ('width', 'height', 'left', 'top',
              'ratio', 'secondary_ratio',
              'current_position')
    try:
        d = dict(
            conn.execute(
            '''select * from extra_infos 
            where name in (?, ?, ?, ?, ?, ?, ?)''',
            keys,
        ).fetchall(),
        )
        geom = (d.get(*x) for x in zip(keys, geom))
    except sqlite3.OperationalError:
        pass
    return geom
#@+node:ekr.20200910093501.1: *5* ===== #1621: open-theme-file on arch linux
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1621

The fix to #1564 probably fixed this issue.

@language python
@nosearch
#@+node:ekr.20180312043352.2: *6* c_file.open_theme_file
@g.commander_command('open-theme-file')
def open_theme_file(self, event):
    """Open a theme file in a new session and apply the theme."""
    c = event and event.get('c')
    if not c:
        return
    # Get the file name.
    themes_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'themes')
    fn = g.app.gui.runOpenFileDialog(c,
        title="Open Theme File",
        filetypes=[
            ("Leo files", "*.leo *.db"),
            ("All files", "*"),
        ],
        defaultextension=g.defaultLeoFileExtension(c),
        startpath=themes_dir,
    )
    if not fn:
        return
    leo_dir = g.os_path_finalize_join(g.app.loadDir, '..', '..')
    os.chdir(leo_dir)
    #
    # #1425: Open the theme file in a separate process.
    command = f'{g.sys.executable} {g.app.loadDir}/runLeo.py "{fn}"'
    g.execute_shell_commands(command) # #1564.
    os.chdir(leo_dir)
#@+node:ekr.20200909102556.1: *5* Improve Sherlock
#@+node:ekr.20121128031949.12605: *6* class g.SherlockTracer
class SherlockTracer:
    """
    A stand-alone tracer class with many of Sherlock's features.

    This class should work in any environment containing the re, os and sys modules.

    The arguments in the pattern lists determine which functions get traced
    or which stats get printed. Each pattern starts with "+", "-", "+:" or
    "-:", followed by a regular expression::

    "+x"  Enables tracing (or stats) for all functions/methods whose name
          matches the regular expression x.
    "-x"  Disables tracing for functions/methods.
    "+:x" Enables tracing for all functions in the **file** whose name matches x.
    "-:x" Disables tracing for an entire file.

    Enabling and disabling depends on the order of arguments in the pattern
    list. Consider the arguments for the Rope trace::

    patterns=['+.*','+:.*',
        '-:.*\\lib\\.*','+:.*rope.*','-:.*leoGlobals.py',
        '-:.*worder.py','-:.*prefs.py','-:.*resources.py',])

    This enables tracing for everything, then disables tracing for all
    library modules, except for all rope modules. Finally, it disables the
    tracing for Rope's worder, prefs and resources modules. Btw, this is
    one of the best uses for regular expressions that I know of.

    Being able to zero in on the code of interest can be a big help in
    studying other people's code. This is a non-invasive method: no tracing
    code needs to be inserted anywhere.
    
    Usage:
        
    g.SherlockTracer(patterns).run()
    """
    @others
#@+node:ekr.20121128031949.12602: *7* __init__
def __init__(
    self,
    patterns,
    dots=True,
    show_args=True,
    show_return=True,
    verbose=True,
):
    """SherlockTracer ctor."""
    self.bad_patterns = []  # List of bad patterns.
    self.dots = dots  # True: print level dots.
    self.contents_d = {}  # Keys are file names, values are file lines.
    self.n = 0  # The frame level on entry to run.
    self.stats = {}  # Keys are full file names, values are dicts.
    self.patterns = None  # A list of regex patterns to match.
    self.pattern_stack = []
    self.show_args = show_args  # True: show args for each function call.
    self.show_return = show_return  # True: show returns from each function.
    self.trace_lines = True  # True: trace lines in enabled functions.
    self.verbose = verbose  # True: print filename:func
    self.set_patterns(patterns)
    from leo.core.leoQt import QtCore
    if QtCore:
        # pylint: disable=no-member
        QtCore.pyqtRemoveInputHook()
#@+node:ekr.20140326100337.16844: *7* __call__
def __call__(self, frame, event, arg):
    """Exists so that self.dispatch can return self."""
    return self.dispatch(frame, event, arg)
#@+node:ekr.20140326100337.16846: *7* sherlock.bad_pattern
def bad_pattern(self, pattern):
    """Report a bad Sherlock pattern."""
    if pattern not in self.bad_patterns:
        self.bad_patterns.append(pattern)
        print(f"\nignoring bad pattern: {pattern}\n")
#@+node:ekr.20140326100337.16847: *7* sherlock.check_pattern
def check_pattern(self, pattern):
    """Give an error and return False for an invalid pattern."""
    try:
        for prefix in ('+:', '-:', '+', '-'):
            if pattern.startswith(prefix):
                re.match(pattern[len(prefix) :], 'xyzzy')
                return True
        self.bad_pattern(pattern)
        return False
    except Exception:
        self.bad_pattern(pattern)
        return False
#@+node:ekr.20121128031949.12609: *7* sherlock.dispatch
def dispatch(self, frame, event, arg):
    """The dispatch method."""
    if event == 'call':
        self.do_call(frame, arg)
    elif event == 'return' and self.show_return:
        self.do_return(frame, arg)
    elif True and event == 'line' and self.trace_lines:
        self.do_line(frame, arg)
    # Queue the SherlockTracer instance again.
    return self
#@+node:ekr.20121128031949.12603: *7* sherlock.do_call & helper
def do_call(self, frame, unused_arg):
    """Trace through a function call."""
    frame1 = frame
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    function_name = code.co_name
    try:
        full_name = self.get_full_name(locals_, function_name)
    except Exception:
        full_name = function_name
    if not self.is_enabled(file_name, full_name, self.patterns):
        # 2020/09/09: Don't touch, for example, __ methods.
        return
    n = 0  # The number of callers of this def.
    while frame:
        frame = frame.f_back
        n += 1
    dots = '.' * max(0, n - self.n) if self.dots else ''
    path = f"{os.path.basename(file_name):>20}" if self.verbose else ''
    leadin = '+' if self.show_return else ''
    args = f"(%s)" % self.get_args(frame1) if self.show_args else ''
    print(f"{path}:{dots}{leadin}{full_name}{args}")
    # Always update stats.
    d = self.stats.get(file_name, {})
    d[full_name] = 1 + d.get(full_name, 0)
    self.stats[file_name] = d
#@+node:ekr.20130111185820.10194: *8* sherlock.get_args
def get_args(self, frame):
    """Return name=val for each arg in the function call."""
    code = frame.f_code
    locals_ = frame.f_locals
    name = code.co_name
    n = code.co_argcount
    if code.co_flags & 4: n = n + 1
    if code.co_flags & 8: n = n + 1
    result = []
    for i in range(n):
        name = code.co_varnames[i]
        if name != 'self':
            arg = locals_.get(name, '*undefined*')
            if arg:
                if isinstance(arg, (list, tuple)):
                    # Clearer w/o f-string
                    val = f"[%s]" % ','.join(
                        [self.show(z) for z in arg if self.show(z)])
                else:
                    val = self.show(arg)
                if val:
                    result.append(f"{name}={val}")
    return ','.join(result)
#@+node:ekr.20140402060647.16845: *7* sherlock.do_line (not used)
bad_fns = []

def do_line(self, frame, arg):
    """print each line of enabled functions."""
    if 1:
        return
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    full_name = self.get_full_name(locals_, name)
    if not self.is_enabled(file_name, full_name, self.patterns):
        return
    n = frame.f_lineno - 1  # Apparently, the first line is line 1.
    d = self.contents_d
    lines = d.get(file_name)
    if not lines:
        print(file_name)
        try:
            with open(file_name) as f:
                s = f.read()
        except Exception:
            if file_name not in self.bad_fns:
                self.bad_fns.append(file_name)
                print(f"open({file_name}) failed")
            return
        lines = g.splitLines(s)
        d[file_name] = lines
    line = lines[n].rstrip() if n < len(lines) else '<EOF>'
    if 0:
        print(f"{name:3} {line}")
    else:
        print(f"{g.shortFileName(file_name)} {n} {full_name} {line}")
#@+node:ekr.20130109154743.10172: *7* sherlock.do_return & helper
def do_return(self, frame, arg):  # Arg *is* used below.
    """Trace a return statement."""
    import os
    code = frame.f_code
    fn = code.co_filename
    locals_ = frame.f_locals
    name = code.co_name
    full_name = self.get_full_name(locals_, name)
    if self.is_enabled(fn, full_name, self.patterns):
        n = 0
        while frame:
            frame = frame.f_back
            n += 1
        dots = '.' * max(0, n - self.n) if self.dots else ''
        path = f"{os.path.basename(fn):>20}" if self.verbose else ''
        if name and name == '__init__':
            try:
                ret1 = locals_ and locals_.get('self', None)
                ret = self.format_ret(ret1)
            except NameError:
                ret = f"<{ret1.__class__.__name__}>"
        else:
            ret = self.format_ret(arg)
        print(f"{path}{dots}-{full_name}{ret}")
#@+node:ekr.20130111120935.10192: *8* sherlock.format_ret
def format_ret(self, arg):
    """Format arg, the value returned by a "return" statement."""
    try:
        if isinstance(arg, types.GeneratorType):
            ret = '<generator>'
        elif isinstance(arg, (tuple, list)):
            # Clearer w/o f-string.
            ret = f"[%s]" % ','.join([self.show(z) for z in arg])
            if len(ret) > 40:
                # Clearer w/o f-string.
                ret = f"[\n%s]" % ('\n,'.join([self.show(z) for z in arg]))
        elif arg:
            ret = self.show(arg)
            if len(ret) > 40:
                ret = f"\n    {ret}"
        else:
            ret = '' if arg is None else repr(arg)
    except Exception:
        exctype, value = sys.exc_info()[:2]
        s = f"<**exception: {exctype.__name__}, {value} arg: {arg !r}**>"
        # Clearer w/o f-string.
        ret = f" ->\n    %s" % s if len(s) > 40 else f" -> {s}"
    return f" -> {ret}"
#@+node:ekr.20121128111829.12185: *7* sherlock.fn_is_enabled (not used)
def fn_is_enabled(self, func, patterns):
    """Return True if tracing for the given function is enabled."""
    if func in self.ignored_functions:
        return False
        
    def ignore_function():
        if func not in self.ignored_functions:
            self.ignored_functions.append(func)
            print(f"Ignore function: {func}")
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b', 
        # String primitives.
        'append\b', 'split\b', 'join\b', 
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    g.trace('=====', func)
    for z in table:
        if re.match(z, func):
            ignore_function()
            return False
    #
    # Legacy code.  
    try:
        enabled, pattern = False, None
        for pattern in patterns:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], func):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], func):
                    enabled = False
        return enabled
    except Exception:
        self.bad_pattern(pattern)
        return False
#@+node:ekr.20130112093655.10195: *7* get_full_name
def get_full_name(self, locals_, name):
    """Return class_name::name if possible."""
    full_name = name
    try:
        user_self = locals_ and locals_.get('self', None)
        if user_self:
            full_name = user_self.__class__.__name__ + '::' + name
    except Exception:
        pass
    return full_name
#@+node:ekr.20121128111829.12183: *7* sherlock.is_enabled
ignored_files = []
ignored_functions = []

def is_enabled(self, file_name, function_name, patterns=None):
    """Return True if tracing for function_name in the given file is enabled."""
    #
    # New in Leo 6.3. Never trace through some files.
    if not os:
        return False  # Shutting down.
    base_name = os.path.basename(file_name)
    if base_name in self.ignored_files:
        return False

    def ignore_file():
        if not base_name in self.ignored_files:
            self.ignored_files.append(base_name)
            # print(f"Ignore file: {base_name}")
            
    def ignore_function():
        if function_name not in self.ignored_functions:
            self.ignored_functions.append(function_name)
            # print(f"Ignore function: {function_name}")
            
    if f"{os.sep}lib{os.sep}" in file_name:
        ignore_file()
        return False
    if base_name.startswith('<') and base_name.endswith('>'):
        ignore_file()
        return False
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b', 
        # String primitives.
        'append\b', 'split\b', 'join\b', 
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    for z in table:
        if re.match(z, function_name):
            ignore_function()
            return False
    #
    # Legacy code.
    enabled = False
    if patterns is None: patterns = self.patterns
    for pattern in patterns:
        try:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], file_name):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], file_name):
                    enabled = False
            elif pattern.startswith('+'):
                if re.match(pattern[1:], function_name):
                    enabled = True
            elif pattern.startswith('-'):
                if re.match(pattern[1:], function_name):
                    enabled = False
            else:
                self.bad_pattern(pattern)
        except Exception:
            self.bad_pattern(pattern)
    return enabled
#@+node:ekr.20121128111829.12182: *7* print_stats
def print_stats(self, patterns=None):
    """Print all accumulated statisitics."""
    print('\nSherlock statistics...')
    if not patterns: patterns = ['+.*', '+:.*',]
    for fn in sorted(self.stats.keys()):
        d = self.stats.get(fn)
        if self.fn_is_enabled(fn, patterns):
            result = sorted(d.keys())
        else:
            result = [key for key in sorted(d.keys())
                if self.is_enabled(fn, key, patterns)]
        if result:
            print('')
            fn = fn.replace('\\', '/')
            parts = fn.split('/')
            print('/'.join(parts[-2:]))
            for key in result:
                print(f"{d.get(key):4} {key}")
#@+node:ekr.20121128031949.12614: *7* run
# Modified from pdb.Pdb.set_trace.

def run(self, frame=None):
    """Trace from the given frame or the caller's frame."""
    import sys
    print(f"SherlockTracer.run:patterns:\n%s" % '\n'.join(self.patterns))
    if frame is None:
        frame = sys._getframe().f_back
    # Compute self.n, the number of frames to ignore.
    self.n = 0
    while frame:
        frame = frame.f_back
        self.n += 1
    # Pass self to sys.settrace to give easy access to all methods.
    sys.settrace(self)
#@+node:ekr.20140322090829.16834: *7* push & pop
def push(self, patterns):
    """Push the old patterns and set the new."""
    self.pattern_stack.append(self.patterns)
    self.set_patterns(patterns)
    print(f"SherlockTracer.push: {self.patterns}")

def pop(self):
    """Restore the pushed patterns."""
    if self.pattern_stack:
        self.patterns = self.pattern_stack.pop()
        print(f"SherlockTracer.pop: {self.patterns}")
    else:
        print('SherlockTracer.pop: pattern stack underflow')
#@+node:ekr.20140326100337.16845: *7* set_patterns
def set_patterns(self, patterns):
    """Set the patterns in effect."""
    self.patterns = [z for z in patterns if self.check_pattern(z)]
#@+node:ekr.20140322090829.16831: *7* show
def show(self, item):
    """return the best representation of item."""
    if not item:
        return repr(item)
    if isinstance(item, dict):
        return 'dict'
    if isinstance(item, str):
        s = repr(item)
        if len(s) <= 20:
            return s
        return s[:17] + '...'
    return repr(item)
#@+node:ekr.20121128093229.12616: *7* stop
def stop(self):
    """Stop all tracing."""
    import sys
    sys.settrace(None)
#@+node:ekr.20200909102346.1: *6* Sherlock traces in make_main_window
    if 1:
        tracer = g.SherlockTracer([
            '+.*',
            '-:.*leo.*.py',
            '+:.*leoAtFile.py',
            '-AtFile::.*',
            # '-Tokenizer::.*',
            # '-Position::.*',
            '+__init__',
            '-:.*leoNodes.py',
            ],
            dots=True, show_args=False, show_return=False, verbose=True)
        tracer.run()
#@+node:ekr.20121128111829.12183: *6* sherlock.is_enabled
ignored_files = []
ignored_functions = []

def is_enabled(self, file_name, function_name, patterns=None):
    """Return True if tracing for function_name in the given file is enabled."""
    #
    # New in Leo 6.3. Never trace through some files.
    if not os:
        return False  # Shutting down.
    base_name = os.path.basename(file_name)
    if base_name in self.ignored_files:
        return False

    def ignore_file():
        if not base_name in self.ignored_files:
            self.ignored_files.append(base_name)
            # print(f"Ignore file: {base_name}")
            
    def ignore_function():
        if function_name not in self.ignored_functions:
            self.ignored_functions.append(function_name)
            # print(f"Ignore function: {function_name}")
            
    if f"{os.sep}lib{os.sep}" in file_name:
        ignore_file()
        return False
    if base_name.startswith('<') and base_name.endswith('>'):
        ignore_file()
        return False
    #
    # New in Leo 6.3. Never trace dangerous functions.
    table = (
        '_deepcopy.*',
        # Unicode primitives.
        'encode\b', 'decode\b',
        # System functions
        '.*__next\b',
        '<frozen>', '<genexpr>', '<listcomp>',
        # '<decorator-gen-.*>',
        'get\b', 
        # String primitives.
        'append\b', 'split\b', 'join\b', 
        # File primitives...
        'access_check\b', 'expanduser\b', 'exists\b', 'find_spec\b',
        'abspath\b', 'normcase\b', 'normpath\b', 'splitdrive\b',
    )
    for z in table:
        if re.match(z, function_name):
            ignore_function()
            return False
    #
    # Legacy code.
    enabled = False
    if patterns is None: patterns = self.patterns
    for pattern in patterns:
        try:
            if pattern.startswith('+:'):
                if re.match(pattern[2:], file_name):
                    enabled = True
            elif pattern.startswith('-:'):
                if re.match(pattern[2:], file_name):
                    enabled = False
            elif pattern.startswith('+'):
                if re.match(pattern[1:], function_name):
                    enabled = True
            elif pattern.startswith('-'):
                if re.match(pattern[1:], function_name):
                    enabled = False
            else:
                self.bad_pattern(pattern)
        except Exception:
            self.bad_pattern(pattern)
    return enabled
#@+node:ekr.20121128031949.12603: *6* sherlock.do_call & helper
def do_call(self, frame, unused_arg):
    """Trace through a function call."""
    frame1 = frame
    code = frame.f_code
    file_name = code.co_filename
    locals_ = frame.f_locals
    function_name = code.co_name
    try:
        full_name = self.get_full_name(locals_, function_name)
    except Exception:
        full_name = function_name
    if not self.is_enabled(file_name, full_name, self.patterns):
        # 2020/09/09: Don't touch, for example, __ methods.
        return
    n = 0  # The number of callers of this def.
    while frame:
        frame = frame.f_back
        n += 1
    dots = '.' * max(0, n - self.n) if self.dots else ''
    path = f"{os.path.basename(file_name):>20}" if self.verbose else ''
    leadin = '+' if self.show_return else ''
    args = f"(%s)" % self.get_args(frame1) if self.show_args else ''
    print(f"{path}:{dots}{leadin}{full_name}{args}")
    # Always update stats.
    d = self.stats.get(file_name, {})
    d[full_name] = 1 + d.get(full_name, 0)
    self.stats[file_name] = d
#@+node:ekr.20130111185820.10194: *7* sherlock.get_args
def get_args(self, frame):
    """Return name=val for each arg in the function call."""
    code = frame.f_code
    locals_ = frame.f_locals
    name = code.co_name
    n = code.co_argcount
    if code.co_flags & 4: n = n + 1
    if code.co_flags & 8: n = n + 1
    result = []
    for i in range(n):
        name = code.co_varnames[i]
        if name != 'self':
            arg = locals_.get(name, '*undefined*')
            if arg:
                if isinstance(arg, (list, tuple)):
                    # Clearer w/o f-string
                    val = f"[%s]" % ','.join(
                        [self.show(z) for z in arg if self.show(z)])
                else:
                    val = self.show(arg)
                if val:
                    result.append(f"{name}={val}")
    return ','.join(result)
#@+node:ekr.20200914071151.1: *5* ----- Hook up qt styles
# The work is complete, and merged into devel.
#@+node:ekr.20190412044556.1: *6* qtFrame.setQtStyle
def setQtStyle(self):
    """
    Set the default Qt style.  Based on pyzo code.
    
    Copyright (C) 2013-2018, the Pyzo development team

    Pyzo is distributed under the terms of the (new) BSD License.
    The full license can be found in 'license.txt'.
    """
    c = self.c
    trace = 'themes' in g.app.debug
    #
    # Get the requested style name.
    stylename = c.config.getString('qt-style-name') or ''
    if trace: g.trace(repr(stylename))
    if not stylename:
        return
    #
    # Return if the style does not exist.
    styles = [z.lower() for z in QtWidgets.QStyleFactory.keys()]
    if stylename.lower() not in styles:
        g.es_print(f"ignoring unknown Qt style name: {stylename!r}")
        g.printObj(styles)
        return
    #
    # Change the style and palette.
    QtWidgets.qApp.nativePalette = QtWidgets.qApp.palette()
    qstyle = QtWidgets.qApp.setStyle(stylename)
    if not qstyle:
        g.es_print(f"failed to set Qt style name: {stylename!r}")
        return
    g.app.gui.qtApp.setPalette(QtWidgets.qApp.nativePalette)
    # g.es_print('set qt style: %r' % stylename)
#@+node:ekr.20200415060222.1: *4* ===== #1128: Add restart command
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1128

@language python
#@+node:ekr.20200415060421.1: *5* pyzo: MainWindow.restart
def restart(self):
    """ Restart Pyzo. """

    self._closeflag = time.time()

    # Close
    self.close()

    if self._closeflag:
        # Get args
        args = [arg for arg in sys.argv]

        if not paths.is_frozen():
            # Prepend the executable name (required on Linux)
            lastBit = os.path.basename(sys.executable)
            args.insert(0, lastBit)

        # Replace the process!
        os.execv(sys.executable, args)
#@+node:ekr.20200415060313.1: *5* pyzo: MainWindow.closeEvent
def closeEvent(self, event):
    """ Override close event handler. """
    
    if g: g.pr('ORIGINAL MainWindow.closeEvent')

    # Are we restaring?
    restarting = time.time() - self._closeflag < 1.0

    # Save settings
    pyzo.saveConfig()
    pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    result = pyzo.editors.closeAll()
    if not result:
        self._closeflag = False
        event.ignore()
        return
    else:
        self._closeflag = True
        #event.accept()  # Had to comment on Windows+py3.3 to prevent error

    # Proceed with closing shells
    pyzo.localKernelManager.terminateAll()
    for shell in pyzo.shells:
        shell._context.close()

    # Close tools
    for toolname in pyzo.toolManager.getLoadedTools():
        tool = pyzo.toolManager.getTool(toolname)
        tool.close()

    # Stop all threads (this should really only be daemon threads)
    import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass

#         # Wait for threads to die ...
#         # This should not be necessary, but I used it in the hope that it
#         # would prevent the segfault on Python3.3. It didn't.
#         timeout = time.time() + 0.5
#         while threading.activeCount() > 1 and time.time() < timeout:
#             time.sleep(0.1)
#         print('Number of threads alive:', threading.activeCount())

    # Proceed as normal
    QtWidgets.QMainWindow.closeEvent(self, event)

    # Harder exit to prevent segfault. Not really a solution,
    # but it does the job until Pyside gets fixed.
    if sys.version_info >= (3,3,0) and not restarting:
        if hasattr(os, '_exit'):
            os._exit(0)
#@+node:ekr.20170221033738.1: *5* c_file.reloadSettings & helper
@g.commander_command('reload-settings')
def reloadSettings(self, event=None):
    """Reload settings for the selected outline, saving it if necessary."""
    c = self
    reloadSettingsHelper(c, all=False)

@g.commander_command('reload-all-settings')
def reloadAllSettings(self, event=None):
    """Reload settings for all open outlines, saving them if necessary."""
    c = self
    reloadSettingsHelper(c, all=True)
#@+node:ekr.20170221034501.1: *6* function: reloadSettingsHelper
def reloadSettingsHelper(c, all):
    """
    Reload settings in all commanders, or just c.
    
    A helper function for reload-settings and reload-all-settings.
    """
    lm = g.app.loadManager
    commanders = g.app.commanders() if all else [c]
    # Save any changes so they can be seen.
    for c2 in commanders:
        if c2.isChanged():
            c2.save()
    lm.readGlobalSettingsFiles()
        # Read leoSettings.leo and myLeoSettings.leo, using a null gui.
    for c in commanders:
        previousSettings = lm.getPreviousSettings(fn=c.mFileName)
            # Read the local file, using a null gui.
        c.initSettings(previousSettings)
            # Init the config classes.
        c.initConfigSettings()
            # Init the commander config ivars.
        c.reloadConfigurableSettings()
            # Reload settings in all configurable classes
        # c.redraw()
            # Redraw so a pasted temp node isn't visible
#@+node:ekr.20171127111053.1: *5* app.Closing
#@+node:ekr.20031218072017.2609: *6* app.closeLeoWindow
def closeLeoWindow(self, frame, new_c=None, finish_quit=True):
    """
    Attempt to close a Leo window.

    Return False if the user veto's the close.

    finish_quit - usually True, close Leo when last file closes, but
                  False when closing an already-open-elsewhere file
                  during initial load, so UI remains for files
                  further along the command line.
    """
    c = frame.c
    if 'shutdown' in g.app.debug:
        g.trace(f"changed: {c.changed} {c.shortFileName()}")
    c.endEditing()  # Commit any open edits.
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
    g.app.recentFilesManager.writeRecentFilesFile(c)
        # Make sure .leoRecentFiles.txt is written.
    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False
    g.app.setLog(None)  # no log until we reactive a window.
    g.doHook("close-frame", c=c)
    #
    # Save the window state for *all* open files.
    g.app.commander_cacher.commit()
        # store cache, but don't close it.
    # This may remove frame from the window list.
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
        g.app.windowList.remove(frame)
    else:
        # #69.
        g.app.forgetOpenFile(fn=c.fileName(), force=True)
    if g.app.windowList:
        c2 = new_c or g.app.windowList[0].c
        g.app.selectLeoWindow(c2)
    elif finish_quit and not g.app.unitTesting:
        g.app.finishQuit()
    return True  # The window has been closed.
#@+node:ekr.20031218072017.2612: *6* app.destroyAllOpenWithFiles
def destroyAllOpenWithFiles(self):
    """Remove temp files created with the Open With command."""
    if 'shutdown' in g.app.debug:
        g.pr('destroyAllOpenWithFiles')
    if g.app.externalFilesController:
        g.app.externalFilesController.shut_down()
        g.app.externalFilesController = None
#@+node:ekr.20031218072017.2615: *6* app.destroyWindow
def destroyWindow(self, frame):
    """Destroy all ivars in a Leo frame."""
    if 'shutdown' in g.app.debug:
        g.pr(f"destroyWindow:  {frame.c.shortFileName()}")
    if g.app.externalFilesController:
        g.app.externalFilesController.destroy_frame(frame)
    if frame in g.app.windowList:
        # g.pr('destroyWindow', (g.app.windowList)
        g.app.forgetOpenFile(frame.c.fileName())
    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()
#@+node:ekr.20031218072017.1732: *6* app.finishQuit
def finishQuit(self):
    # forceShutdown may already have fired the "end1" hook.
    assert self == g.app, repr(g.app)
    if 'shutdown' in g.app.debug:
        g.pr('finishQuit: killed:', g.app.killed)
    if not g.app.killed:
        g.doHook("end1")
        g.app.global_cacher.commit_and_close()
        g.app.commander_cacher.commit()
        g.app.commander_cacher.close()
    if g.app.ipk:
        g.app.ipk.cleanup_consoles()
    g.app.destroyAllOpenWithFiles()
    if hasattr(g.app, 'pyzo_close_handler'):
        # pylint: disable=no-member
        g.app.pyzo_close_handler()
    g.app.killed = True
        # Disable all further hooks and events.
        # Alas, "idle" events can still be called
        # even after the following code.
    if g.app.gui:
        g.app.gui.destroySelf()
            # Calls qtApp.quit()
#@+node:ekr.20031218072017.2616: *6* app.forceShutdown
def forceShutdown(self):
    """
    Forces an immediate shutdown of Leo at any time.

    In particular, may be called from plugins during startup.
    """
    trace = 'shutdown' in g.app.debug
    app = self
    if trace:
        g.pr('forceShutdown')
    for c in app.commanders():
        app.forgetOpenFile(c.fileName(), force=True)
    # Wait until everything is quiet before really quitting.
    if trace: g.pr('forceShutdown: before end1')
    g.doHook("end1")
    if trace: g.pr('forceShutdown: after end1')
    self.log = None  # Disable writeWaitingLog
    self.killed = True  # Disable all further hooks.
    for w in self.windowList[:]:
        if trace: g.pr(f"forceShutdown: {w}")
        self.destroyWindow(w)
    if trace: g.pr('before finishQuit')
    self.finishQuit()
#@+node:ekr.20031218072017.2617: *6* app.onQuit
@cmd('exit-leo')
@cmd('quit-leo')
def onQuit(self, event=None):
    """Exit Leo, prompting to save unsaved outlines first."""
    if 'shutdown' in g.app.debug:
        g.trace()
    g.app.quitting = True
    if g.app.loaded_session and g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    while g.app.windowList:
        w = g.app.windowList[0]
        if not g.app.closeLeoWindow(w):
            break
    if g.app.windowList:
        g.app.quitting = False  # If we get here the quit has been disabled.
#@+node:ekr.20120420054855.14349: *5* class SessionManager
# These were top-level nodes of leotools.py


class SessionManager:
    @others
#@+node:ekr.20120420054855.14351: *6* SessionManager.ctor
def __init__(self):
    self.path = self.get_session_path()
#@+node:ekr.20120420054855.14246: *6* SessionManager.clear_session
def clear_session(self, c):
    """Close all tabs except the presently selected tab."""
    for frame in g.app.windowList:
        if frame.c != c:
            frame.c.close()
#@+node:ekr.20120420054855.14417: *6* SessionManager.error
# def error (self,s):
    # # Do not use g.trace or g.es here.
    # print(s)
#@+node:ekr.20120420054855.14245: *6* SessionManager.get_session
def get_session(self):
    """Return a list of UNLs for open tabs."""
    result = []
    # Fix #1118, part 2.
    if not getattr(g.app.gui, 'frameFactory', None):
        return result
    mf = getattr(g.app.gui.frameFactory, 'masterFrame', None)
    if mf:
        outlines = [mf.widget(i).leo_c for i in range(mf.count())]
    else:
        outlines = [i.c for i in g.app.windowList]
    for c in outlines:
        result.append(c.p.get_UNL(with_file=True, with_proto=False, with_index=True))
    return result
#@+node:ekr.20120420054855.14416: *6* SessionManager.get_session_path
def get_session_path(self):
    """Return the path to the session file."""
    for path in (g.app.homeLeoDir, g.app.homeDir):
        if g.os_path_exists(path):
            return g.os_path_finalize_join(path, 'leo.session')
    return None
#@+node:ekr.20120420054855.14247: *6* SessionManager.load_session
def load_session(self, c=None, unls=None):
    """Open a tab for each item in UNLs & select the indicated node in each."""
    if not unls:
        return
    unls = [z.strip() for z in unls or [] if z.strip()]
    for unl in unls:
        i = unl.find("#")
        if i > -1:
            fn, unl = unl[:i], unl[i:]
        else:
            fn, unl = unl, ''
        fn = fn.strip()
        exists = fn and g.os_path_exists(fn)
        if not exists:
            if 'startup' in g.app.debug:
                g.trace('file not found:', fn)
            continue
        if 'startup' in g.app.debug:
            g.trace('loading:', fn)
        g.app.loadManager.loadLocalFile(fn, gui=g.app.gui, old_c=c)
            # This selects the proper position.
#@+node:ekr.20120420054855.14248: *6* SessionManager.load_snapshot
def load_snapshot(self):
    """
    Load a snapshot of a session from the leo.session file.

    Called when --restore-session is in effect.
    """
    fn = self.path
    if fn and g.os_path_exists(fn):
        try:
            with open(fn) as f:
                session = json.loads(f.read())
            return session
        except Exception:
            pass
    #
    # #1107: No need for this message.
        # print('can not load session: no leo.session file')
    return None
#@+node:ekr.20120420054855.14249: *6* SessionManager.save_snapshot
def save_snapshot(self, c=None):
    """
    Save a snapshot of the present session to the leo.session file.

    Called automatically during shutdown when no files were given on the command line.
    """
    if self.path:
        session = self.get_session()
        # print('save_snaphot: %s' % (len(session)))
        with open(self.path, 'w') as f:
            json.dump(session, f)
            f.close()
        # Do not use g.trace or g.es here.
        print(f"wrote {self.path}")
    else:
        print('can not save session: no leo.session file')
#@+node:ekr.20120219154958.10452: *5* LM.load & helpers
def load(self, fileName=None, pymacs=None):
    """Load the indicated file"""
    lm = self
    t1 = time.process_time()
    # Phase 1: before loading plugins.
    # Scan options, set directories and read settings.
    print('')  # Give some separation for the coming traces.
    if not lm.isValidPython():
        return
    lm.doPrePluginsInit(fileName, pymacs)
        # sets lm.options and lm.files
    g.app.computeSignon()
    g.app.printSignon()
    if lm.options.get('version'):
        return
    if not g.app.gui:
        return
    g.app.disable_redraw = True
        # Disable redraw until all files are loaded.
    #
    # Phase 2: load plugins: the gui has already been set.
    g.doHook("start1")
    if g.app.killed:
        return
    g.app.idleTimeManager.start()
    #
    # Phase 3: after loading plugins. Create one or more frames.
    if lm.options.get('script') and not self.files:
        ok = True
    else:
        ok = lm.doPostPluginsInit()
        # Fix #579: Key bindings don't take for commands defined in plugins
        g.app.makeAllBindings()
        if ok and g.app.diff:
            lm.doDiff()
    if not ok:
        return
    g.es('')  # Clears horizontal scrolling in the log pane.
    if g.app.listen_to_log_flag:
        g.app.listenToLog()
    if 'startup' in g.app.debug:
        t2 = time.process_time()
        g.es_print(f"startup time: {t2 - t1:5.2f} sec")
    g.app.gui.runMainLoop()
    # For scripts, the gui is a nullGui.
    # and the gui.setScript has already been called.
#@+node:ekr.20150225133846.7: *6* LM.doDiff
def doDiff(self):
    """Support --diff option after loading Leo."""
    if len(self.old_argv[2:]) == 2:
        pass  # c.editFileCommands.compareAnyTwoFiles gives a message.
    else:
        # This is an unusual situation.
        g.es('--diff mode. sys.argv[2:]...', color='red')
        for z in self.old_argv[2:]:
            g.es(g.shortFileName(z) if z else repr(z), color='blue')
    commanders = g.app.commanders()
    if len(commanders) == 2:
        c = commanders[0]
        c.editFileCommands.compareAnyTwoFiles(event=None)
#@+node:ekr.20120219154958.10487: *6* LM.doPostPluginsInit & helpers
def doPostPluginsInit(self):
    """Create a Leo window for each file in the lm.files list."""
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False  # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.Show it and all queued messages.
    c = c1 = fn = None
    if lm.files:
        try:  # #1403.
            for n, fn in enumerate(lm.files):
                lm.more_cmdline_files = n < len(lm.files) - 1
                c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                    # Returns None if the file is open in another instance of Leo.
                if c and not c1:  # #1416:
                    c1 = c
        except Exception:
            g.es_print(f"Unexpected exception reading {fn!r}")
            g.es_exception()
            c = None
    # Load (and save later) a session *only* if the command line contains no files.
    g.app.loaded_session = not lm.files
    if g.app.sessionManager and g.app.loaded_session:
        try:  # #1403.
            aList = g.app.sessionManager.load_snapshot()
            if aList:
                g.app.sessionManager.load_session(c1, aList)
                # #659.
                if g.app.windowList:
                    c = c1 = g.app.windowList[0].c
                else:
                    c = c1 = None
        except Exception:
            g.es_print('Can not load session')
            g.es_exception()
    # Enable redraws.
    g.app.disable_redraw = False
    if not c1:
        try:  # #1403.
            c1 = lm.openEmptyWorkBook()
                # Calls LM.loadLocalFile.
        except Exception:
            g.es_print('Can not create empty workbook')
            g.es_exception()
    c = c1
    if not c:
        # Leo is out of options: Force an immediate exit.
        return False
    # #199.
    g.app.runAlreadyOpenDialog(c1)
    #
    # Final inits...
    # For qt gui, select the first-loaded tab.
    if hasattr(g.app.gui, 'frameFactory'):
        factory = g.app.gui.frameFactory
        if factory and hasattr(factory, 'setTabForCommander'):
            factory.setTabForCommander(c)
    g.app.logInited = True
    g.app.initComplete = True
    c.setLog()
    c.redraw()
    g.doHook("start2", c=c, p=c.p, fileName=c.fileName())
    c.initialFocusHelper()
    screenshot_fn = lm.options.get('screenshot_fn')
    if screenshot_fn:
        lm.make_screen_shot(screenshot_fn)
        return False  # Force an immediate exit.
    return True
#@+node:ekr.20120219154958.10489: *7* LM.make_screen_shot
def make_screen_shot(self, fn):
    """Create a screenshot of the present Leo outline and save it to path."""
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
#@+node:ekr.20131028155339.17098: *7* LM.openEmptyWorkBook
def openEmptyWorkBook(self):
    """Open an empty frame and paste the contents of CheatSheet.leo into it."""
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    if not fn:
        return None  # #1415
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    if not c:
        return None  # #1201: AttributeError below.
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # #933: Save clipboard.
        old_clipboard = g.app.gui.getTextFromClipboard()
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.setCurrentPosition(p2)  # 1380
                c2.copyOutline()
                p = c.pasteOutline()
                # #1380 & #1381: Add guard & use vnode methods to prevent redraw.
                if p:
                    c.setCurrentPosition(p)  # 1380
                    p.v.contract()
                    p.v.clearDirty()
            c2.close(new_c=c)
            # Delete the dummy first node.
            root = c.rootPosition()
            root.doDelete(newNode=root.next())
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.clearChanged()
            c.redraw(c.rootPosition())  # # 1380: Select the root.
        # #933: Restore clipboard
        g.app.gui.replaceClipboardWith(old_clipboard)
    return c
#@+node:ekr.20120219154958.10477: *6* LM.doPrePluginsInit & helpers
def doPrePluginsInit(self, fileName, pymacs):
    """ Scan options, set directories and read settings."""
    lm = self
    lm.computeStandardDirectories()
    lm.adjustSysPath()
        # A do-nothing.
    # Scan the options as early as possible.
    lm.options = options = lm.scanOptions(fileName, pymacs)
        # also sets lm.files.
    if options.get('version'):
        return
    script = options.get('script')
    verbose = script is None
    # Init the app.
    lm.initApp(verbose)
    g.app.setGlobalDb()
    lm.reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    lm.readGlobalSettingsFiles()
        # reads only standard settings files, using a null gui.
        # uses lm.files[0] to compute the local directory
        # that might contain myLeoSettings.leo.
    # Read the recent files file.
    localConfigFile = lm.files[0] if lm.files else None
    g.app.recentFilesManager.readRecentFiles(localConfigFile)
    # Create the gui after reading options and settings.
    lm.createGui(pymacs)
    # We can't print the signon until we know the gui.
    g.app.computeSignon()  # Set app.signon/signon1 for commanders.
#@+node:ekr.20170302093006.1: *7* LM.createAllImporterData & helpers
def createAllImporterData(self):
    """
    New in Leo 5.5:

    Create global data structures describing importers and writers.
    """
    assert g.app.loadDir
        # This is the only data required.
    self.createWritersData()
        # Was an AtFile method.
    self.createImporterData()
        # Was a LeoImportCommands method.
#@+node:ekr.20140724064952.18037: *8* LM.createImporterData & helper
def createImporterData(self):
    """Create the data structures describing importer plugins."""
    # Allow plugins to be defined in ~/.leo/plugins.
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(
            g.app.loadDir, '..', 'plugins', 'importers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    module_name = sfn[:-3]
                    # Important: use importlib to give imported modules
                    # their fully qualified names.
                    m = importlib.import_module(
                        f"leo.plugins.importers.{module_name}")
                    self.parse_importer_dict(sfn, m)
                    # print('createImporterData', m.__name__)
                except Exception:
                    g.warning(f"can not import leo.plugins.importers.{module_name}")
#@+node:ekr.20140723140445.18076: *9* LM.parse_importer_dict
def parse_importer_dict(self, sfn, m):
    """
    Set entries in g.app.classDispatchDict, g.app.atAutoDict and
    g.app.atAutoNames using entries in m.importer_dict.
    """
    importer_d = getattr(m, 'importer_dict', None)
    if importer_d:
        at_auto = importer_d.get('@auto', [])
        scanner_class = importer_d.get('class', None)
        # scanner_name = scanner_class.__name__
        extensions = importer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoDict
            for s in at_auto:
                d[s] = scanner_class
                g.app.atAutoDict[s] = scanner_class
                g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.classDispatchDict
            for ext in extensions:
                d[ext] = scanner_class
    elif sfn not in (
        # These are base classes, not real plugins.
        'basescanner.py',
        'linescanner.py',
    ):
        g.warning(f"leo/plugins/importers/{sfn} has no importer_dict")
#@+node:ekr.20140728040812.17990: *8* LM.createWritersData & helper
def createWritersData(self):
    """Create the data structures describing writer plugins."""
    trace = False and 'createWritersData' not in g.app.debug_dict
        # Do *not* remove this trace.
    if trace:
        # Suppress multiple traces.
        g.app.debug_dict['createWritersData'] = True
    g.app.writersDispatchDict = {}
    g.app.atAutoWritersDict = {}
    plugins1 = g.os_path_finalize_join(g.app.homeDir, '.leo', 'plugins')
    plugins2 = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
    for kind, plugins in (('home', plugins1), ('leo', plugins2)):
        pattern = g.os_path_finalize_join(g.app.loadDir,
            '..', 'plugins', 'writers', '*.py')
        for fn in g.glob_glob(pattern):
            sfn = g.shortFileName(fn)
            if sfn != '__init__.py':
                try:
                    # Important: use importlib to give imported modules their fully qualified names.
                    m = importlib.import_module(f"leo.plugins.writers.{sfn[:-3]}")
                    self.parse_writer_dict(sfn, m)
                except Exception:
                    g.es_exception()
                    g.warning(f"can not import leo.plugins.writers.{sfn}")
    if trace:
        g.trace('LM.writersDispatchDict')
        g.printDict(g.app.writersDispatchDict)
        g.trace('LM.atAutoWritersDict')
        g.printDict(g.app.atAutoWritersDict)
    # Creates problems: See #40.
#@+node:ekr.20140728040812.17991: *9* LM.parse_writer_dict
def parse_writer_dict(self, sfn, m):
    """
    Set entries in g.app.writersDispatchDict and g.app.atAutoWritersDict
    using entries in m.writers_dict.
    """
    writer_d = getattr(m, 'writer_dict', None)
    if writer_d:
        at_auto = writer_d.get('@auto', [])
        scanner_class = writer_d.get('class', None)
        extensions = writer_d.get('extensions', [])
        if at_auto:
            # Make entries for each @auto type.
            d = g.app.atAutoWritersDict
            for s in at_auto:
                aClass = d.get(s)
                if aClass and aClass != scanner_class:
                    g.trace(
                        f"{sfn}: duplicate {s} class {aClass.__name__} "
                        f"in {m.__file__}:")
                else:
                    d[s] = scanner_class
                    g.app.atAutoNames.add(s)
        if extensions:
            # Make entries for each extension.
            d = g.app.writersDispatchDict
            for ext in extensions:
                aClass = d.get(ext)
                if aClass and aClass != scanner_class:
                    g.trace(f"{sfn}: duplicate {ext} class", aClass, scanner_class)
                else:
                    d[ext] = scanner_class
    elif sfn not in ('basewriter.py',):
        g.warning(f"leo/plugins/writers/{sfn} has no writer_dict")
#@+node:ekr.20120219154958.10478: *7* LM.createGui
def createGui(self, pymacs):
    lm = self
    gui_option = lm.options.get('gui')
    windowFlag = lm.options.get('windowFlag')
    script = lm.options.get('script')
    if g.app.gui:
        if g.app.gui == g.app.nullGui:
            g.app.gui = None  # Enable g.app.createDefaultGui
            g.app.createDefaultGui(__file__)
        else:
            pass
            # This can happen when launching Leo from IPython.
            # This can also happen when leoID does not exist.
    elif gui_option is None:
        if script and not windowFlag:
            # Always use null gui for scripts.
            g.app.createNullGuiWithScript(script)
        else:
            g.app.createDefaultGui(__file__)
    else:
        lm.createSpecialGui(gui_option, pymacs, script, windowFlag)
#@+node:ekr.20120219154958.10479: *7* LM.createSpecialGui
def createSpecialGui(self, gui, pymacs, script, windowFlag):
    # lm = self
    if pymacs:
        g.app.createNullGuiWithScript(script=None)
    elif script:
        if windowFlag:
            g.app.createDefaultGui()
            g.app.gui.setScript(script=script)
            sys.args = []
        else:
            g.app.createNullGuiWithScript(script=script)
    else:
        g.app.createDefaultGui()
#@+node:ekr.20120219154958.10480: *7* LM.adjustSysPath
def adjustSysPath(self):
    """
    Adjust sys.path to enable imports as usual with Leo.

    This method is no longer needed:
    """
    pass
#@+node:ekr.20120219154958.10482: *7* LM.getDefaultFile
def getDefaultFile(self):
    # Get the name of the workbook.
    fn = g.app.config.getString('default-leo-file')
    fn = g.os_path_finalize(fn)
    if not fn:
        return None
    if g.os_path_exists(fn):
        return fn
    if g.os_path_isabs(fn):
        # Create the file.
        g.error(f"Using default leo file name:\n{fn}")
        return fn
    # It's too risky to open a default file if it is relative.
    return None
#@+node:ekr.20120219154958.10484: *7* LM.initApp
def initApp(self, verbose):

    self.createAllImporterData()
        # Can be done early. Uses only g.app.loadDir
    assert g.app.loadManager
    import leo.core.leoBackground as leoBackground
    import leo.core.leoConfig as leoConfig
    import leo.core.leoNodes as leoNodes
    import leo.core.leoPlugins as leoPlugins
    import leo.core.leoSessions as leoSessions
    # Import leoIPython only if requested.  The import is quite slow.
    self.setStdStreams()
    if g.app.useIpython:
        import leo.core.leoIPython as leoIPython
            # This launches the IPython Qt Console.  It *is* required.
        assert leoIPython  # suppress pyflakes/flake8 warning.
    # Make sure we call the new leoPlugins.init top-level function.
    leoPlugins.init()
    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    # Create early classes *after* doing plugins.init()
    g.app.idleTimeManager = IdleTimeManager()
    g.app.backgroundProcessManager = leoBackground.BackgroundProcessManager()
    g.app.externalFilesController = leoExternalFiles.ExternalFilesController()
    g.app.recentFilesManager = RecentFilesManager()
    g.app.config = leoConfig.GlobalConfigManager()
    g.app.nodeIndices = leoNodes.NodeIndices(g.app.leoID)
    g.app.sessionManager = leoSessions.SessionManager()
    # Complete the plugins class last.
    g.app.pluginsController.finishCreate()
#@+node:ekr.20120219154958.10486: *7* LM.scanOptions & helpers
def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''beauty,cache,coloring,dock,drawing,events,focus,git,gnx,
      ipython,keys,plugins,save,select,shutdown,size,startup,themes'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
#@+node:ekr.20180312150559.1: *8* LM.addOptionsToParser
@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@<file> type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
#@+node:ekr.20120219154958.10483: *8* LM.computeFilesList
def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
#@+node:ekr.20180312150805.1: *8* LM.doGuiOption
def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
#@+node:ekr.20180312152329.1: *8* LM.doLoadTypeOption
def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
#@+node:ekr.20180312152609.1: *8* LM.doScreenShotOption
def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
#@+node:ekr.20180312153008.1: *8* LM.doScriptOption
def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
#@+node:ekr.20180312151544.1: *8* LM.doSimpleOptions
def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
#@+node:ekr.20190923170528.1: *8* LM.doWindowSpotOption
def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
#@+node:ekr.20180312154839.1: *8* LM.doWindowSizeOption
def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
#@+node:ekr.20160718072648.1: *7* LM.setStdStreams
def setStdStreams(self):
    """
    Make sure that stdout and stderr exist.
    This is an issue when running Leo with pythonw.exe.
    """
    # pdb requires sys.stdin, which doesn't exist when using pythonw.exe.
    # import pdb ; pdb.set_trace()
    import sys
    import leo.core.leoGlobals as g

    # Define class LeoStdOut
    @others
    if not sys.stdout:
        sys.stdout = sys.__stdout__ = LeoStdOut('stdout')
    if not sys.stderr:
        sys.stderr = sys.__stderr__ = LeoStdOut('stderr')
#@+node:ekr.20160718091844.1: *8* class LeoStdOut
class LeoStdOut:
    """A class to put stderr & stdout to Leo's log pane."""

    def __init__(self, kind):
        self.kind = kind
        g.es_print = self.write
        g.pr = self.write

    def flush(self, *args, **keys):
        pass
    @others
#@+node:ekr.20160718102306.1: *9* LeoStdOut.write
def write(self, *args, **keys):
    """Put all non-keyword args to the log pane, as in g.es."""
    #
    # Tracing will lead to unbounded recursion unless
    # sys.stderr has been redirected on the command line.
    app = g.app
    if not app or app.killed: return
    if app.gui and app.gui.consoleOnly: return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
    }
    # Handle keywords for g.pr and g.es_print.
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return
    if log and color is None:
        color = g.actualColor('black')
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if log:
            log.put(s)
    elif log and app.logInited:
        # from_redirect is the big difference between this and g.es.
        log.put(s, color=color, tabName=tabName, from_redirect=True)
    else:
        app.logWaiting.append((s, color, newline),)
#@+node:ekr.20120219154958.10491: *6* LM.isValidPython
def isValidPython(self):
    if sys.platform == 'cli':
        return True
    message = (
        f"Leo requires Python {g.minimum_python_version} or higher"
        f"You may download Python from http://python.org/download/")
    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0, 1, 2)])
        ok = g.CheckVersion(version, g.minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                d = g.EmergencyDialog(
                    title='Python Version Error',
                    message=message)
                d.run()
            except Exception:
                g.es_exception()
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
#@+node:ekr.20120223062418.10393: *6* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
#@+node:ekr.20120223062418.10394: *7* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    """Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui, previousSettings=previousSettings)
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # this commander is associated with sqlite db
        c.sqlite_connection = theFile
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
#@+node:ekr.20120223062418.10405: *8* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
#@+node:ekr.20120223062418.10406: *8* LM.findOpenFile
def findOpenFile(self, fn):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20120223062418.10407: *8* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # #181: Honor focus requests.
#@+node:ekr.20120223062418.10408: *8* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20120223062418.10419: *8* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
#@+node:ekr.20120224161905.10030: *8* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
#@+node:ekr.20120223062418.10416: *8* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10410: *8* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        s = g.toUnicode(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10412: *8* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = g.os_path_finalize(g.os_path_dirname(fn))  # 1341
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=False)
            # #970: Never close Leo here.
    return ok
#@+node:ekr.20031218072017.1732: *5* app.finishQuit
def finishQuit(self):
    # forceShutdown may already have fired the "end1" hook.
    assert self == g.app, repr(g.app)
    if 'shutdown' in g.app.debug:
        g.pr('finishQuit: killed:', g.app.killed)
    if not g.app.killed:
        g.doHook("end1")
        g.app.global_cacher.commit_and_close()
        g.app.commander_cacher.commit()
        g.app.commander_cacher.close()
    if g.app.ipk:
        g.app.ipk.cleanup_consoles()
    g.app.destroyAllOpenWithFiles()
    if hasattr(g.app, 'pyzo_close_handler'):
        # pylint: disable=no-member
        g.app.pyzo_close_handler()
    g.app.killed = True
        # Disable all further hooks and events.
        # Alas, "idle" events can still be called
        # even after the following code.
    if g.app.gui:
        g.app.gui.destroySelf()
            # Calls qtApp.quit()
#@+node:ekr.20200422075655.1: *5* c_file.restartLeo
@g.commander_command('restart-leo')
def restartLeo(self, event=None):
    """Restart Leo, reloading all presently open outlines."""
    c = self
    # 0. Remember the args to be used.
    if g.app.sessionManager:
        # Don't specify files, thereby using session data.
        args = ['-c'] + [sys.argv[0]]
    else:
        # Load only those files originally on the command line.
        args = ['-c'] + [z for z in sys.argv]
    # 1. Write .leoRecentFiles.txt.
    g.app.recentFilesManager.writeRecentFilesFile(c)
    # 2. Abort the restart if the user veto's any close.
    for c in g.app.commanders():
        if c.changed:
            veto = False
            try:
                c.promptingForClose = True
                veto = c.frame.promptForSave()
            finally:
                c.promptingForClose = False
            if veto:
                g.es_print('Cancelling restart-leo command')
                return
    # 3. Save session data.
    if g.app.sessionManager:
        g.app.sessionManager.save_snapshot()
    # 4. Close all unsaved outlines.
    g.app.setLog(None)  # Kill the log.
    for c in g.app.commanders():
        frame = c.frame
        # This is similar to g.app.closeLeoWindow.
        g.doHook("close-frame", c=c)
        # Save the window state
        g.app.saveWindowState(c)
        g.app.saveEditorDockState(c)
        g.app.commander_cacher.commit() # store cache, but don't close it.
        # This may remove frame from the window list.
        if frame in g.app.windowList:
            g.app.destroyWindow(frame)
            g.app.windowList.remove(frame)
        else:
            # #69.
            g.app.forgetOpenFile(fn=c.fileName(), force=True)
    # 5. Complete the shutdown.
    g.app.finishQuit()
    # 6. Restart.
    os.execv(sys.executable, args)
#@+node:ekr.20200503075952.1: *4* ----- restore buffer commands
#@+node:ekr.20031218072017.2811: *5*  c.Birth & death
#@+node:ekr.20031218072017.2812: *6* c.__init__ & helpers
def __init__(self, fileName,
    gui=None,
    parentFrame=None,
    previousSettings=None,
    relativeFileName=None,
):

    # tag = 'Commands.__init__ %s' % (g.shortFileName(fileName))
    c = self
    # Official ivars.
    self._currentPosition = None
    self._topPosition = None
    self.frame = None
    self.parentFrame = parentFrame  # New in Leo 6.0.
    self.gui = gui or g.app.gui
    self.ipythonController = None
        # Set only by the ipython plugin.
    # The order of these calls does not matter.
    c.initCommandIvars()
    c.initDebugIvars()
    c.initDocumentIvars()
    c.initEventIvars()
    c.initFileIvars(fileName, relativeFileName)
    c.initOptionsIvars()
    c.initObjectIvars()
    c.initSettings(previousSettings)
        # Init the settings *before* initing the objects.
    # Initialize all subsidiary objects, including subcommanders.
    c.initObjects(self.gui)
    assert c.frame
    assert c.frame.c
    # Complete the init!
    c.finishCreate()
#@+node:ekr.20120217070122.10475: *7* c.computeWindowTitle
def computeWindowTitle(self, fileName):
    """Set the window title and fileName."""
    if fileName:
        title = g.computeWindowTitle(fileName)
    else:
        s = "untitled"
        n = g.app.numberOfUntitledWindows
        if n > 0:
            s += str(n)
        title = g.computeWindowTitle(s)
        g.app.numberOfUntitledWindows = n + 1
    return title
#@+node:ekr.20120217070122.10473: *7* c.initCommandIvars
def initCommandIvars(self):
    """Init ivars used while executing a command."""
    self.commandsDict = {}
        # Keys are command names, values are functions.
    self.disableCommandsMessage = ''
        # The presence of this message disables all commands.
    self.hookFunction = None
        # One of three places that g.doHook looks for hook functions.
    self.ignoreChangedPaths = False
        # True: disable path changed message in at.WriteAllHelper.
    self.inCommand = False
        # Interlocks to prevent premature closing of a window.
    self.isZipped = False
        # Set by g.openWithFileName.
    self.outlineToNowebDefaultFileName = "noweb.nw"
        # For Outline To Noweb dialog.
    # For tangle/untangle
    self.tangle_errors = 0
    # Default Tangle options
    self.use_header_flag = False
    self.output_doc_flag = False
    # For hoist/dehoist commands.
    self.hoistStack = []
        # Stack of nodes to be root of drawn tree.
        # Affects drawing routines and find commands.
    # For outline navigation.
    self.navPrefix = ''  # Must always be a string.
    self.navTime = None

    self.sqlite_connection = None
#@+node:ekr.20120217070122.10466: *7* c.initDebugIvars
def initDebugIvars(self):
    """Init Commander debugging ivars."""
    self.command_count = 0
    self.scanAtPathDirectivesCount = 0
    self.trace_focus_count = 0
#@+node:ekr.20120217070122.10471: *7* c.initDocumentIvars
def initDocumentIvars(self):
    """Init per-document ivars."""
    self.expansionLevel = 0
        # The expansion level of this outline.
    self.expansionNode = None
        # The last node we expanded or contracted.
    self.nodeConflictList = []
        # List of nodes with conflicting read-time data.
    self.nodeConflictFileName = None
        # The fileName for c.nodeConflictList.
    self.user_dict = {}
        # Non-persistent dictionary for free use by scripts and plugins.
#@+node:ekr.20120217070122.10467: *7* c.initEventIvars
def initEventIvars(self):
    """Init ivars relating to gui events."""
    self.configInited = False
    self.doubleClickFlag = False
    self.exists = True
        # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    self.in_qt_dialog = False
        # True: in a qt dialog.
    self.loading = False
        # True: we are loading a file: disables c.setChanged()
    self.promptingForClose = False
        # True: lock out additional closing dialogs.
    self.suppressHeadChanged = False
        # True: prevent setting c.changed when switching chapters.
    # Flags for c.outerUpdate...
    self.enableRedrawFlag = True
    self.requestCloseWindow = False
    self.requestedFocusWidget = None
    self.requestLaterRedraw = False
#@+node:ekr.20120217070122.10472: *7* c.initFileIvars
def initFileIvars(self, fileName, relativeFileName):
    """Init file-related ivars of the commander."""
    self.changed = False
        # True: the ouline has changed since the last save.
    self.ignored_at_file_nodes = []
        # List of nodes for c.raise_error_dialogs.
    self.import_error_nodes = []
        # List of nodes for c.raise_error_dialogs.
    self.last_dir = None
        # The last used directory.
    self.mFileName = fileName or ''
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName or ''
        #
    self.openDirectory = None
        #
    self.orphan_at_file_nodes = []
        # List of orphaned nodes for c.raise_error_dialogs.
    self.wrappedFileName = None
        # The name of the wrapped file, for wrapper commanders.
        # Set by LM.initWrapperLeoFile
#@+node:ekr.20120217070122.10469: *7* c.initOptionsIvars
def initOptionsIvars(self):
    """Init Commander ivars corresponding to user options."""
    self.fixed = False
    self.fixedWindowPosition = []
    self.forceExecuteEntireBody = False
    self.focus_border_color = 'white'
    self.focus_border_width = 1  # pixels
    self.outlineHasInitialFocus = False
    self.page_width = 132
    self.sparse_find = True
    self.sparse_move = True
    self.sparse_spell = True
    self.stayInTreeAfterSelect = False
    self.tab_width = -4
    self.tangle_batch_flag = False
    self.target_language = "python"
    self.untangle_batch_flag = False
    # self.use_body_focus_border = True
    # self.use_focus_border = False
        # Replaced by style-sheet entries.
    self.vim_mode = False
#@+node:ekr.20120217070122.10468: *7* c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.bufferCommands = None
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
#@+node:ekr.20120217070122.10470: *7* c.initObjects
@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '<hidden root vnode>'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.bufferCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
#@+node:ekr.20140815160132.18837: *7* c.initSettings
def initSettings(self, previousSettings):
    """Init the settings *before* initing the objects."""
    c = self
    import leo.core.leoConfig as leoConfig
    c.config = leoConfig.LocalConfigManager(c, previousSettings)
    g.app.config.setIvarsFromSettings(c)
#@+node:ekr.20031218072017.2814: *6* c.__repr__ & __str__
def __repr__(self):
    return f"Commander {id(self)}: {repr(self.mFileName)}"

__str__ = __repr__
#@+node:ekr.20050920093543: *6* c.finishCreate & helpers
def finishCreate(self):
    """
    Finish creating the commander and all sub-objects.
    This is the last step in the startup process.
    """
    c, k = self, self.k
    assert c.gui
    assert k
    c.frame.finishCreate()
    c.miniBufferWidget = c.frame.miniBufferWidget
        # Will be None for nullGui.
    # Only c.abbrevCommands needs a finishCreate method.
    c.abbrevCommands.finishCreate()
    # Finish other objects...
    c.createCommandNames()
    k.finishCreate()
    c.findCommands.finishCreate()
    if not c.gui.isNullGui:
        g.registerHandler('idle', c.idle_focus_helper)
    if getattr(c.frame, 'menu', None):
        c.frame.menu.finishCreate()
    if getattr(c.frame, 'log', None):
        c.frame.log.finishCreate()
    c.undoer.clearUndoState()
    if c.vimCommands and c.vim_mode:
        c.vimCommands.finishCreate()
        # Menus must exist at this point.
    # Do not call chapterController.finishCreate here:
    # It must be called after the first real redraw.
    g.check_cmd_instance_dict(c, g)
    c.bodyWantsFocus()
#@+node:ekr.20140815160132.18835: *7* c.createCommandNames
def createCommandNames(self):
    """
    Create all entries in c.commandsDict.
    Do *not* clear c.commandsDict here.
    """
    for commandName, func in g.global_commands_dict.items():
        self.k.registerCommand(commandName, func)
#@+node:ekr.20051007143620: *7* c.printCommandsDict
def printCommandsDict(self):
    c = self
    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print(f"{key:30} = {command.__name__ if command else '<None>'}")
    print('')
#@+node:ekr.20041130173135: *6* c.hash
# This is a bad idea.

def hash(self):
    c = self
    if c.mFileName:
        return g.os_path_finalize(c.mFileName).lower()  # #1341.
    return 0
#@+node:ekr.20110509064011.14563: *6* c.idle_focus_helper & helpers
idle_focus_count = 0

def idle_focus_helper(self, tag, keys):
    """An idle-tme handler that ensures that focus is *somewhere*."""
    trace = 'focus' in g.app.debug
    trace_inactive_focus = False  # Too disruptive for --trace-focus
    trace_in_dialog = False  # Not useful enough for --trace-focus
    c = self
    assert tag == 'idle'
    if g.app.unitTesting:
        return
    if keys.get('c') != c:
        if trace: g.trace('no c')
        return
    self.idle_focus_count += 1
    if c.in_qt_dialog:
        if trace and trace_in_dialog: g.trace('in_qt_dialog')
        return
    w = g.app.gui.get_focus(at_idle=True)
    if g.app.gui.active:
        # Always call trace_idle_focus.
        self.trace_idle_focus(w)
        if w and self.is_unusual_focus(w):
            if trace:
                w_class = w and w.__class__.__name__
                g.trace('***** unusual focus', w_class)
            # Fix bug 270: Leo's keyboard events doesn't work after "Insert"
            # on headline and Alt+Tab, Alt+Tab
            # Presumably, intricate details of Qt event handling are involved.
            # The focus was in the tree, so put the focus back in the tree.
            c.treeWantsFocusNow()
        # elif not w and active:
            # c.bodyWantsFocusNow()
    elif trace and trace_inactive_focus:
        w_class = w and w.__class__.__name__
        count = c.idle_focus_count
        g.trace(f"{count} inactive focus: {w_class}")
#@+node:ekr.20160427062131.1: *7* c.is_unusual_focus
def is_unusual_focus(self, w):
    """Return True if w is not in an expected place."""
    #
    # #270: Leo's keyboard events doesn't work after "Insert"
    #       on headline and Alt+Tab, Alt+Tab
    #
    # #276: Focus lost...in Nav text input
    import leo.plugins.qt_frame as qt_frame
    return isinstance(w, qt_frame.QtTabBarWrapper)
#@+node:ekr.20150403063658.1: *7* c.trace_idle_focus
last_unusual_focus = None
# last_no_focus = False

def trace_idle_focus(self, w):
    """Trace the focus for w, minimizing chatter."""
    from leo.core.leoQt import QtWidgets
    import leo.plugins.qt_frame as qt_frame
    trace = 'focus' in g.app.debug
    trace_known = False
    c = self
    table = (QtWidgets.QWidget, qt_frame.LeoQTreeWidget,)
    count = c.idle_focus_count
    if w:
        w_class = w and w.__class__.__name__
        c.last_no_focus = False
        if self.is_unusual_focus(w):
            if trace:
                g.trace(f"{count} unusual focus: {w_class}")
        else:
            c.last_unusual_focus = None
            if isinstance(w, table):
                if trace and trace_known:
                    g.trace(f"{count} known focus: {w_class}")
            elif trace:
                g.trace(f"{count} unknown focus: {w_class}")
    else:
        if trace:
            g.trace(f"{count:3} no focus")
#@+node:ekr.20081005065934.1: *6* c.initAfterLoad
def initAfterLoad(self):
    """Provide an offical hook for late inits of the commander."""
    pass
#@+node:ekr.20090213065933.6: *6* c.initConfigSettings
def initConfigSettings(self):
    """Init all cached commander config settings."""
    c = self
    getBool = c.config.getBool
    getColor = c.config.getColor
    getData = c.config.getData
    getInt = c.config.getInt
    c.autoindent_in_nocolor = getBool('autoindent-in-nocolor-mode')
    c.collapse_nodes_after_move = getBool('collapse-nodes-after-move')
    c.collapse_on_lt_arrow = getBool('collapse-on-lt-arrow', default=True)
    c.contractVisitedNodes = getBool('contractVisitedNodes')
    c.fixedWindowPositionData = getData('fixedWindowPosition')
    c.focus_border_color = getColor('focus-border-color') or 'red'
    c.focus_border_command_state_color = getColor(
        'focus-border-command-state-color') or 'blue'
    c.focus_border_overwrite_state_color = getColor(
        'focus-border-overwrite-state-color') or 'green'
    c.focus_border_width = getInt('focus-border-width') or 1  # pixels
    c.forceExecuteEntireBody = getBool('force-execute-entire-body', default=False)
    c.make_node_conflicts_node = getBool('make-node-conflicts-node', default=True)
    c.outlineHasInitialFocus = getBool('outline-pane-has-initial-focus')
    c.page_width = getInt('page-width') or 132
    # c.putBitsFlag = getBool('put-expansion-bits-in-leo-files', default=True)
    c.sparse_move = getBool('sparse-move-outline-left')
    c.sparse_find = getBool('collapse-nodes-during-finds')
    c.sparce_spell = getBool('collapse-nodes-while-spelling')
    c.stayInTreeAfterSelect = getBool('stayInTreeAfterSelect')
    c.smart_tab = getBool('smart-tab')
    c.tab_width = getInt('tab-width') or -4
    c.verbose_check_outline = getBool('verbose-check-outline', default=False)
    c.vim_mode = getBool('vim-mode', default=False)
    c.write_script_file = getBool('write-script-file')
#@+node:ekr.20090213065933.7: *6* c.setWindowPosition
def setWindowPosition(self):
    c = self
    if c.fixedWindowPositionData:
        try:
            aList = [z.strip() for z in c.fixedWindowPositionData if z.strip()]
            w, h, l, t = aList
            c.fixedWindowPosition = int(w), int(h), int(l), int(t)
        except Exception:
            g.error('bad @data fixedWindowPosition',
                repr(self.fixedWindowPosition))
    else:
        c.windowPosition = 500, 700, 50, 50  # width,height,left,top.
#@+node:ekr.20120217070122.10468: *5* c.initObjectIvars
def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.bufferCommands = None
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
#@+node:ekr.20120217070122.10470: *5* c.initObjects
@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '<hidden root vnode>'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.bufferCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
#@+node:ekr.20200727095246.1: *4* ----- can not happen: not found (jedi)
#@+node:ekr.20180519111302.1: *5* ac.get_jedi_completions & helper
def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 >= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0 - 1 : n0 + 30])
        print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1 + n0 + jedi_line,
                column=column,
                path=g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            )
            completions = script.completions()
            t3 = time.process_time()
        except ValueError:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 >= t2 >= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
#@+node:ekr.20180526211127.1: *6* ac.add_prefix
def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') > -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
#@+node:ekr.20200910094121.1: *4* ===== #1569: zoom
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1569

The fonts size in body panel changes to original size with clicking the body panel after run zoom-in or zoom-out command.

May be a MacOS bug.

@language python
@nosearch
#@+node:ekr.20190326034006.1: *5* bjc.find_font
zoom_dict = {}  # Keys are key::settings_names, values are cumulative font size.

def find_font(self, key, setting_name):
    """
    Return the font for the given setting name.
    """
    c, get = self.c, self.c.config.get
    default_size = c.config.defaultBodyFontSize
    trace = False and not g.unitTesting  # and setting_name.startswith('php')
    for name in (setting_name, setting_name.rstrip('_font')):
        size_error = False
        family = get(name + '_family', 'family')
        size = get(name + '_size', 'size')
        slant = get(name + '_slant', 'slant')
        weight = get(name + '_weight', 'weight')
        if family or slant or weight or size:
            family = family or g.app.config.defaultFontFamily
            key = f"{key}::{setting_name}"
            if key in self.zoom_dict:
                old_size = self.zoom_dict.get(key)
            else:
                # It's a good idea to set size explicitly.
                old_size = size or default_size
                if trace: g.trace(
                    "STARTING SIZE", old_size, repr(size), default_size)
            if isinstance(old_size, str):
                # All settings should be in units of points.
                try:
                    if old_size.endswith(('pt', 'px'),):
                        old_size = int(old_size[:-2])
                    else:
                        old_size = int(old_size)
                except ValueError:
                    size_error = True
            elif not isinstance(old_size, int):
                size_error = True
            if size_error:
                g.trace('bad old_size:', old_size.__class__, old_size)
                size = old_size
            else:
                # #490: Use c.zoom_size if it exists.
                zoom_delta = getattr(c, 'zoom_delta', 0)
                if zoom_delta:
                    size = old_size + zoom_delta
                    self.zoom_dict[key] = size
            slant = slant or 'roman'
            weight = weight or 'normal'
            size = str(size)
            font = g.app.gui.getFontFromParams(family, size, slant, weight)
            # A good trace: the key shows what is happening.
            if font:
                if trace: g.trace(
                    f"key: {key:30} family: {family or 'None'} "
                    f"size: {size or 'None'} {slant} {weight}")
                return font
    return None
#@+node:tbrown.20130411145310.18855: *5* lqtb.wheelEvent
def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier & event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta < 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
#@+node:ekr.20110605121601.18106: *5* qsciw.set_config
def set_config(self):
    """Set QScintillaWrapper configuration options."""
    c, w = self.c, self.widget
    n = c.config.getInt('qt-scintilla-zoom-in')
    if n not in (None, 1, 0):
        w.zoomIn(n)
    w.setUtf8(True)  # Important.
    if 1:
        w.setBraceMatching(2)  # Sloppy
    else:
        w.setBraceMatching(0)  # wrapper.flashCharacter creates big problems.
    if 0:
        w.setMarginWidth(1, 40)
        w.setMarginLineNumbers(1, True)
    w.setIndentationWidth(4)
    w.setIndentationsUseTabs(False)
    w.setAutoIndent(True)
#@+node:ekr.20200910122336.1: *5* free layout stuff
#@+node:tbrown.20140522153032.32658: *6* @g.command free-layout-zoom
@g.command('free-layout-zoom')
def free_layout_zoom(event):
    """(un)zoom the current pane."""
    c = event.get('c')
    c.free_layout.get_top_splitter().zoom_toggle()
#@+node:tbnorth.20160510122413.1: *6* flc.splitter_clicked
def splitter_clicked(self, splitter, handle, event, release, double):
    """
    splitter_clicked - middle click release will zoom adjacent
    body / tree panes

    :param NestedSplitter splitter: splitter containing clicked handle
    :param NestedSplitterHandle handle: clicked handle
    :param QMouseEvent event: mouse event for click
    :param bool release: was it a Press or Release event
    :param bool double: was it a double click event
    """
    if not release or event.button() != QtCore.Qt.MidButton:
        return
    if splitter.root.zoomed:  # unzoom if *any* handle clicked
        splitter.zoom_toggle()
        return
    before = splitter.widget(splitter.indexOf(handle) - 1)
    after = splitter.widget(splitter.indexOf(handle))
    for pane in before, after:
        if pane.objectName() == 'bodyFrame':
            pane.setFocus()
            splitter.zoom_toggle()
            return
        if pane.objectName() == 'outlineFrame':
            pane.setFocus()
            splitter.zoom_toggle(local=True)
            return
#@+node:ekr.20110605121601.17967: *6* ns.__init__
def __init__(self, parent=None, orientation=QtCore.Qt.Horizontal, root=None):
    """Ctor for NestedSplitter class."""
    super().__init__(orientation, parent)
        # This creates a NestedSplitterHandle.
    if root is None:
        root = self.top(local=True)
        if root == self:
            root.marked = None  # Tuple: self,index,side-1,widget
            root.providers = []
            root.holders = {}
            root.windows = []
            root._main = self.parent()  # holder of the main splitter
            # list of top level NestedSplitter windows opened from 'Open Window'
            # splitter handle context menu
            root.zoomed = False
        #
        # NestedSplitter is a kind of meta-widget, in that it manages
        # panes across multiple actual splitters, even windows.
        # So to create a signal for a click on splitter handle, we
        # need to propagate the .connect() call across all the
        # actual splitters, current and future
        root._splitterClickedArgs = []  # save for future added splitters
    for args in root._splitterClickedArgs:
        # apply any .connect() calls that occured earlier
        self._splitterClickedSignal.connect(*args)

    self.root = root
#@+node:tbrown.20140522153032.32656: *6* ns.zoom_toggle
def zoom_toggle(self, local=False):
    """zoom_toggle - (Un)zoom current pane to be only expanded pane

    :param bool local: just zoom pane within its own splitter
    """
    if self.root.zoomed:
        for ns in self.top().self_and_descendants():
            if hasattr(ns, '_unzoom'):
                # this splitter could have been added since
                ns.setSizes(ns._unzoom)
    else:
        focused = Qt.QApplication.focusWidget()
        parents = []
        parent = focused
        while parent:
            parents.append(parent)
            parent = parent.parent()
        if not focused:
            g.es("Not zoomed, and no focus")
        for ns in (self if local else self.top()).self_and_descendants():
            # FIXME - shouldn't be doing this across windows
            ns._unzoom = ns.sizes()
            for i in range(ns.count()):
                w = ns.widget(i)
                if w in parents:
                    sizes = [0] * len(ns._unzoom)
                    sizes[i] = sum(ns._unzoom)
                    ns.setSizes(sizes)
                    break
    self.root.zoomed = not self.root.zoomed
#@+node:ekr.20110605121601.17965: *6* nsh.splitter_menu
def splitter_menu(self, pos):
    """build the context menu for NestedSplitter"""
    splitter = self.splitter()
    if not splitter.enabled:
        g.trace('splitter not enabled')
        return
    index = splitter.indexOf(self)
    # get three pairs
    widget, neighbour, count = splitter.handle_context(index)
    lr = 'Left', 'Right'
    ab = 'Above', 'Below'
    split_dir = 'Vertically'
    if self.orientation() == QtCore.Qt.Vertical:
        lr, ab = ab, lr
        split_dir = 'Horizontally'
    # blue/orange - color-blind friendly
    color = '#729fcf', '#f57900'
    sheet = []
    for i in 0, 1:
        sheet.append(widget[i].styleSheet())
        widget[i].setStyleSheet(sheet[-1] + f"\nborder: 2px solid {color[i]};")
    menu = QtWidgets.QMenu()
    menu.hovered.connect(self.show_tip)

    def pl(n):
        return 's' if n > 1 else ''

    def di(s):
        return {
            'Above': 'above',
            'Below': 'below',
            'Left': 'left of',
            'Right': 'right of',
        }[s]

    # Insert.

    def insert_callback(index=index):
        splitter.insert(index)

    self.add_item(insert_callback, menu, 'Insert',
        "Insert an empty pane here")
    # Remove, +0/-1 reversed, we need to test the one that remains
    # First see if a parent has more than two splits
    # (we could be a sole surviving child).
    max_parent_splits = 0
    up = splitter.parent()
    while isinstance(up, NestedSplitter):
        max_parent_splits = max(max_parent_splits, up.count())
        up = up.parent()
        if max_parent_splits >= 2:
            break  # two is enough
    for i in 0, 1:
        # keep = splitter.widget(index)
        # cull = splitter.widget(index - 1)
        if (max_parent_splits >= 2 or  # more splits upstream
            splitter.count() > 2 or  # 3+ splits here, or 2+ downstream
            neighbour[not i] and neighbour[not i].max_count() >= 2
        ):

            def remove_callback(i=i, index=index):
                splitter.remove(index, i)

            self.add_item(remove_callback, menu,
                f"Remove {count[i]:d} {lr[i]}",
                f"Remove the {count[i]} pane{pl(count[i])} {di(lr[i])} here")
    # Swap.

    def swap_callback(index=index):
        splitter.swap(index)

    self.add_item(swap_callback, menu,
        f"Swap {count[0]:d} {lr[0]} {count[1]:d} {lr[1]}",
        f"Swap the {count[0]:d} pane{pl(count[0])} {di(lr[0])} here "
        f"with the {count[1]:d} pane{pl(count[1])} {di(lr[1])} here"
        )
    # Split: only if not already split.
    for i in 0, 1:
        if not neighbour[i] or neighbour[i].count() == 1:

            def split_callback(i=i, index=index, splitter=splitter):
                splitter.split(index, i)

            self.add_item(
                split_callback, menu, f"Split {lr[i]} {split_dir}")
    for i in 0, 1:

        def mark_callback(i=i, index=index):
            splitter.mark(index, i)

        self.add_item(mark_callback, menu, f"Mark {count[i]:d} {lr[i]}")
    # Swap With Marked.
    if splitter.root.marked:
        for i in 0, 1:
            if not splitter.invalid_swap(widget[i], splitter.root.marked[2]):

                def swap_mark_callback(i=i, index=index, splitter=splitter):
                    splitter.swap_with_marked(index, i)

                self.add_item(swap_mark_callback, menu,
                    f"Swap {count[i]:d} {lr[i]} With Marked")
    # Add.
    for i in 0, 1:
        if (
            not isinstance(splitter.parent(), NestedSplitter) or
            splitter.parent().indexOf(splitter) ==
                [0, splitter.parent().count() - 1][i]
        ):

            def add_callback(i=i, splitter=splitter):
                splitter.add(i)

            self.add_item(add_callback, menu, f"Add {ab[i]}")
    # Rotate All.
    self.add_item(splitter.rotate, menu, 'Toggle split direction')

    def rotate_only_this(index=index):
        splitter.rotateOne(index)

    self.add_item(rotate_only_this, menu, 'Toggle split/dir. just this')
    # equalize panes

    def eq(splitter=splitter.top()):
        splitter.equalize_sizes(recurse=True)

    self.add_item(eq, menu, 'Equalize all')
    # (un)zoom pane

    def zoom(splitter=splitter.top()):
        splitter.zoom_toggle()

    self.add_item(
        zoom,
        menu,
        ('Un' if splitter.root.zoomed else '') + 'Zoom pane'
    )
    # open window
    if splitter.top().parent().__class__ != NestedSplitterTopLevel:
        # don't open windows from windows, only from main splitter
        # so owner is not a window which might close.  Could instead
        # set owner to main splitter explicitly.  Not sure how right now.
        submenu = menu.addMenu('Open window')
        if 1:
            # pylint: disable=unnecessary-lambda
            self.add_item(lambda: splitter.open_window(), submenu, "Empty")
        # adapted from choice_menu()
        if (splitter.root.marked and
            splitter.top().max_count() > 1
        ):
            self.add_item(
                lambda: splitter.open_window(action="_move_marked_there"),
                submenu, "Move marked there")
        for provider in splitter.root.providers:
            if hasattr(provider, 'ns_provides'):
                for title, id_ in provider.ns_provides():

                    def cb(id_=id_):
                        splitter.open_window(action=id_)

                    self.add_item(cb, submenu, title)
    submenu = menu.addMenu('Debug')
    act = QtWidgets.QAction("Print splitter layout", self)

    def cb(checked, splitter=splitter):  # pylint: disable=function-redefined
        print(f"\n{splitter.layout_to_text(splitter.top().get_layout())}\n")

    act.triggered.connect(cb)
    submenu.addAction(act)

    def load_items(menu, items):
        for i in items:
            if isinstance(i, dict):
                for k in i:
                    load_items(menu.addMenu(k), i[k])
            else:
                title, id_ = i

                def cb(checked, id_=id_):
                    splitter.context_cb(id_, index)

                act = QtWidgets.QAction(title, self)
                act.triggered.connect(cb)
                menu.addAction(act)

    for provider in splitter.root.providers:
        if hasattr(provider, 'ns_context'):
            load_items(menu, provider.ns_context())
    menu.exec_(self.mapToGlobal(pos))
    for i in 0, 1:
        widget[i].setStyleSheet(sheet[i])
#@+node:ekr.20191001084541.1: *5*  zoom commands
#@+node:tbrown.20130411145310.18857: *6* @g.command("zoom-in")
@g.command("zoom-in")
def zoom_in(event=None, delta=1):
    """increase body font size by one

    @font-size-body must be present in the stylesheet
    """
    zoom_helper(event, delta=1)
#@+node:ekr.20191001084646.1: *6* @g.command("zoom-out")
@g.command("zoom-out")
def zoom_out(event=None):
    """decrease body font size by one

    @font-size-body must be present in the stylesheet
    """
    # zoom_in(event=event, delta=-1)
    zoom_helper(event=event, delta=-1)
#@+node:ekr.20191001084612.1: *6* zoom_helper
def zoom_helper(event, delta):
    """
    Common helper for zoom commands.
    """
    c = event.get('c')
    if not c:
        return
    wrapper = c.frame.body.wrapper
    #
    # For performance, don't c.styleSheetManager.reload_style_sheets().
    # Apply to body widget directly
    c._style_deltas['font-size-body'] += delta
    ssm = c.styleSheetManager
    sheet = ssm.expand_css_constants(c.active_stylesheet)
    wrapper.widget.setStyleSheet(sheet)
    #
    # #490: Honor language-specific settings.
    colorizer = getattr(c.frame.body, 'colorizer', None)
    if not colorizer:
        return
    c.zoom_delta = delta
    colorizer.configure_fonts()
    wrapper.setAllText(wrapper.getAllText())
        # Recolor everything.
#@+node:ekr.20110605121601.18175: *5* ssm.set_style_sheets
def set_style_sheets(self, all=True, top=None, w=None):
    """Set the master style sheet for all widgets using config settings."""
    if g.app.loadedThemes:
        return
    c = self.c
    if top is None: top = c.frame.top
    selectors = ['qt-gui-plugin-style-sheet']
    if all:
        selectors.append('qt-gui-user-style-sheet')
    sheets = []
    for name in selectors:
        sheet = c.config.getData(name, strip_comments=False)
            # don't strip `#selector_name { ...` type syntax
        if sheet:
            if '\n' in sheet[0]:
                sheet = ''.join(sheet)
            else:
                sheet = '\n'.join(sheet)
        if sheet and sheet.strip():
            line0 = f"\n/* ===== From {name} ===== */\n\n"
            sheet = line0 + sheet
            sheets.append(sheet)
    if sheets:
        sheet = "\n".join(sheets)
        # store *before* expanding, so later expansions get new zoom
        c.active_stylesheet = sheet
        sheet = self.expand_css_constants(sheet)
        if not sheet: sheet = self.default_style_sheet()
        if w is None:
            w = self.get_master_widget(top)
        w.setStyleSheet(sheet)
#@+node:ekr.20200913074639.1: *4* ===== #1599: indentation guides
@language rest
@wrap

In "repaint" branch.

https://github.com/leo-editor/leo-editor/issues/1599

@language python
@nosearch
#@+node:ekr.20200913082124.1: *5* COPY CodeEditorBase.doForVisibleBlocks
def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y > self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
#@+node:ekr.20200913074701.1: *5* COPY IndentationGuides.paintEvent
# in appearance.py
# In effect, this is a subclass of QPlainTextEditor!

def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w > 0: # if scrolled horizontally it can become < 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
#@+node:ekr.20200913075121.1: *5* COPY CodeEditorBase.__init__
def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:patch: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
#@+node:ekr.20200914071303.1: *5* COPY lqtb.paintEvent (experimenatal)
def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width > 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w > 0: # if scrolled horizontally it can become < 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
#@+node:ekr.20110605121601.18005: *5* class LeoQTextBrowser (QtWidgets.QTextBrowser)
if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
#@+node:ekr.20110605121601.18006: *6*  lqtb.ctor
def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
#@+node:ekr.20110605121601.18007: *6* lqtb. __repr__ & __str__
def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
#@+node:ekr.20110605121601.18008: *6* lqtb.Auto completion
#@+node:ekr.20110605121601.18009: *7* class LeoQListWidget(QListWidget)
class LeoQListWidget(QtWidgets.QListWidget):
    @others
#@+node:ekr.20110605121601.18010: *8* lqlw.ctor
def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
#@+node:ekr.20110605121601.18011: *8* lqlw.closeEvent
def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
#@+node:ekr.20110605121601.18012: *8* lqlw.end_completer
def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
#@+node:ekr.20141024170936.7: *8* lqlw.get_selection
def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
#@+node:ekr.20110605121601.18013: *8* lqlw.keyPressEvent
def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
#@+node:ekr.20110605121601.18014: *8* lqlw.select_callback
def select_callback(self):
    """Called when user selects an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) > 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.frame.body.onBodyChanged('Typing')
    self.end_completer()
#@+node:tbrown.20111011094944.27031: *8* lqlw.tab_callback
def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) < 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 <= i < len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j > i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
#@+node:ekr.20110605121601.18015: *8* lqlw.set_position
def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
#@+node:ekr.20110605121601.18016: *8* lqlw.show_completions
def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
#@+node:ekr.20110605121601.18017: *7* lqtb.lqtb.init_completer
def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
#@+node:ekr.20110605121601.18018: *7* lqtb.redirections to LeoQListWidget
def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
#@+node:ekr.20141103061944.31: *6* lqtb.get/setXScrollPosition
def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
#@+node:ekr.20111002125540.7021: *6* lqtb.get/setYScrollPosition
def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
#@+node:ekr.20110605121601.18019: *6* lqtb.leo_dumpButton
def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
#@+node:ekr.20200304130514.1: *6* lqtb.onContextMenu
def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
#@+node:ekr.20120925061642.13506: *6* lqtb.onSliderChanged
def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
#@+node:tbrown.20130411145310.18855: *6* lqtb.wheelEvent
def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier & event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta < 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
#@+node:ekr.20110605121601.18006: *5*  lqtb.ctor
def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
#@+node:ekr.20200913082155.1: *5* lqtb.doForVisibleBlocks
def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y > self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
#@+node:ekr.20200913075250.1: *5* lqtb.paintEvent (experimental)
def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width > 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w > 0: # if scrolled horizontally it can become < 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
#@+node:ekr.20200906070319.1: *3* ===== #1643, 1654, & 1665: simpler docks
@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1643
https://github.com/leo-editor/leo-editor/issues/1654

@language python
@nosearch
#@+node:ekr.20200908052950.1: *4* 2 calls to restoreWindowState
@nosearch

# flattened, ignore-case, head, body
#@+node:ekr.20031218072017.1623: *5* c_file.new
@g.commander_command('file-new')
@g.commander_command('new')
def new(self, event=None, gui=None):
    """Create a new Leo window."""
    import leo.core.leoApp as leoApp
    lm = g.app.loadManager
    old_c = self
    # Clean out the update queue so it won't interfere with the new window.
    self.outerUpdate()
    # Supress redraws until later.
    g.app.disable_redraw = True
    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    # Retain all previous settings. Very important for theme code.
    c = g.app.newCommander(
        fileName=None,
        gui=gui,
        previousSettings=leoApp.PreviousSettings(
            settingsDict=lm.globalSettingsDict,
            shortcutsDict=lm.globalBindingsDict,
        ))
    frame = c.frame
    g.app.unlockLog()
    if not old_c:
        frame.setInitialWindowGeometry()
    # #1643: This doesn't work.
        # g.app.restoreWindowState(c)
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    lm.createMenu(c)
    lm.finishOpen(c)
    g.app.writeWaitingLog(c)
    g.doHook("new", old_c=old_c, c=c, new_c=c)
    c.setLog()
    c.clearChanged()  # Fix #387: Clear all dirty bits.
    g.app.disable_redraw = False
    c.redraw()
    return c  # For unit tests and scripts.
#@+node:ekr.20120223062418.10393: *5* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
#@+node:ekr.20120223062418.10394: *6* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    """Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui, previousSettings=previousSettings)
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # this commander is associated with sqlite db
        c.sqlite_connection = theFile
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
#@+node:ekr.20120223062418.10405: *7* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
#@+node:ekr.20120223062418.10406: *7* LM.findOpenFile
def findOpenFile(self, fn):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20120223062418.10407: *7* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # #181: Honor focus requests.
#@+node:ekr.20120223062418.10408: *7* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20120223062418.10419: *7* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
#@+node:ekr.20120224161905.10030: *7* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
#@+node:ekr.20120223062418.10416: *7* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10410: *7* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        s = g.toUnicode(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10412: *7* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = g.os_path_finalize(g.os_path_dirname(fn))  # 1341
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=False)
            # #970: Never close Leo here.
    return ok
#@+node:ekr.20200906142157.1: *4* ----- changed
#@+node:ekr.20110605121601.18477: *5*  qt_gui.__init__ (sets qtApp)
def __init__(self):
    """Ctor for LeoQtGui class."""
    super().__init__('qt')
         # Initialize the base class.
    self.active = True
    self.consoleOnly = False  # Console is separate from the log.
    self.iconimages = {}
    self.globalFindDialog = None
    self.idleTimeClass = qt_idle_time.IdleTime
    self.insert_char_flag = False  # A flag for eventFilter.
    self.mGuiName = 'qt'
    self.main_window = None
        # The *singleton* QMainWindow.
    self.plainTextWidget = qt_text.PlainTextWrapper
    self.styleSheetManagerClass = StyleSheetManager
        # For c.idle_focus_helper and activate/deactivate events.
    #
    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)
    # Create objects...
    self.qtApp = QtWidgets.QApplication(sys.argv)
    self.reloadSettings()
    self.appIcon = self.getIconImage('leoapp32.png')
    #
    # Define various classes key stokes.
    << define FKeys >>
    << define ignoreChars >>
    << define specialChars >>
    # Put up the splash screen()
    if (g.app.use_splash_screen and
        not g.app.batchMode and
        not g.app.silentMode and
        not g.unitTesting
    ):
        self.splashScreen = self.createSplashScreen()
    self.frameFactory = qt_frame.TabbedFrameFactory()
        # qtFrame.finishCreate does all the other work.

def reloadSettings(self):
    pass
#@+node:ekr.20180419110303.1: *6* << define FKeys >>
self.FKeys = [
    'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']
    # These do not generate keystrokes on MacOs.
#@+node:ekr.20180419105250.1: *6* << define ignoreChars >>
# Always ignore these characters
self.ignoreChars = [
    # These are in ks.special characters.
    # They should *not* be ignored.
        # 'Left', 'Right', 'Up', 'Down',
        # 'Next', 'Prior',
        # 'Home', 'End',
        # 'Delete', 'Escape',
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    # F-Keys are also ok.
        # 'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_0', 'KP_1', 'KP_2', 'KP_3', 'KP_4', 'KP_5', 'KP_6', 'KP_7', 'KP_8', 'KP_9',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1', 'KP_F2', 'KP_F3', 'KP_F4',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        # Keypad chars should be have been converted to other keys.
        # Users should just bind to the corresponding normal keys.
    'CapsLock', 'Caps_Lock',
    'NumLock', 'Num_Lock',
    'ScrollLock',
    'Alt_L', 'Alt_R',
    'Control_L', 'Control_R',
    'Meta_L', 'Meta_R',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
        # Clearly, these should never be generated.
    'Break', 'Pause', 'Sys_Req',
        # These are real keys, but they don't mean anything.
    'Begin', 'Clear',
        # Don't know what these are.
]
#@+node:ekr.20180419081404.1: *6* << define specialChars >>
# Keys whose names must never be inserted into text.
self.specialChars = [
    # These are *not* special keys.
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    'Left', 'Right', 'Up', 'Down',
        # Arrow keys
    'Next', 'Prior',
        # Page up/down keys.
    'Home', 'End',
        # Home end keys.
    'Delete', 'Escape',
        # Others.
    'Enter', 'Insert', 'Ins',
        # These should only work if bound.
    'Menu',
        # #901.
    'PgUp', 'PgDn',
        # #868.
]
#@+node:ekr.20180312151544.1: *5* LM.doSimpleOptions
def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
#@+node:ekr.20120219154958.10486: *5* LM.scanOptions & helpers
def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''beauty,cache,coloring,dock,drawing,events,focus,git,gnx,
      ipython,keys,plugins,save,select,shutdown,size,startup,themes'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
#@+node:ekr.20180312150559.1: *6* LM.addOptionsToParser
@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@<file> type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
#@+node:ekr.20120219154958.10483: *6* LM.computeFilesList
def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
#@+node:ekr.20180312150805.1: *6* LM.doGuiOption
def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
#@+node:ekr.20180312152329.1: *6* LM.doLoadTypeOption
def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
#@+node:ekr.20180312152609.1: *6* LM.doScreenShotOption
def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
#@+node:ekr.20180312153008.1: *6* LM.doScriptOption
def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
#@+node:ekr.20180312151544.1: *6* LM.doSimpleOptions
def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
#@+node:ekr.20190923170528.1: *6* LM.doWindowSpotOption
def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
#@+node:ekr.20180312154839.1: *6* LM.doWindowSizeOption
def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
#@+node:ekr.20190819072045.1: *5* qt_gui.make_main_window
def make_main_window(self):
    """Make the *singleton* QMainWindow."""
    window = QtWidgets.QMainWindow()
    window.setObjectName('LeoGlobalMainWindow')
    # Calling window.show() here causes flash.
    self.attachLeoIcon(window)
    # Monkey-patch
    window.closeEvent = self.close_event
        # Use self: g.app.gui does not exist yet.
    self.runAtIdle(self.set_main_window_style_sheet)
        # No StyleSheetManager exists yet.
    return window

def set_main_window_style_sheet(self):
    """Style the main window, using the first .leo file."""
    commanders = g.app.commanders()
    if commanders:
        c = commanders[0]
        ssm = c.styleSheetManager
        ssm.set_style_sheets(w=self.main_window)
        self.main_window.setWindowTitle(c.frame.title)  # #1506.
    else:
        g.trace("No open commanders!")
#@+node:ekr.20200908052413.1: *4* ----- The 'new' command
#@+node:ekr.20031218072017.1623: *5* c_file.new
@g.commander_command('file-new')
@g.commander_command('new')
def new(self, event=None, gui=None):
    """Create a new Leo window."""
    import leo.core.leoApp as leoApp
    lm = g.app.loadManager
    old_c = self
    # Clean out the update queue so it won't interfere with the new window.
    self.outerUpdate()
    # Supress redraws until later.
    g.app.disable_redraw = True
    # Send all log messages to the new frame.
    g.app.setLog(None)
    g.app.lockLog()
    # Retain all previous settings. Very important for theme code.
    c = g.app.newCommander(
        fileName=None,
        gui=gui,
        previousSettings=leoApp.PreviousSettings(
            settingsDict=lm.globalSettingsDict,
            shortcutsDict=lm.globalBindingsDict,
        ))
    frame = c.frame
    g.app.unlockLog()
    if not old_c:
        frame.setInitialWindowGeometry()
    # #1643: This doesn't work.
        # g.app.restoreWindowState(c)
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio, frame.secondary_ratio)
        # Resize the _new_ frame.
    c.frame.createFirstTreeNode()
    lm.createMenu(c)
    lm.finishOpen(c)
    g.app.writeWaitingLog(c)
    g.doHook("new", old_c=old_c, c=c, new_c=c)
    c.setLog()
    c.clearChanged()  # Fix #387: Clear all dirty bits.
    g.app.disable_redraw = False
    c.redraw()
    return c  # For unit tests and scripts.
#@+node:ekr.20031218072017.2821: *5* c_file.open_outline & callback
@g.commander_command('open-outline')
def open_outline(self, event=None):
    """Open a Leo window containing the contents of a .leo file."""
    c = self
    @others
        # Defines open_completer function.

    #
    # Close the window if this command completes successfully?

    closeFlag = (
        c.frame.startupWindow and
            # The window was open on startup
        not c.changed and not c.frame.saved and
            # The window has never been changed
        g.app.numberOfUntitledWindows == 1
            # Only one untitled window has ever been opened
    )
    table = [
        ("Leo files", "*.leo *.db"),
        ("Python files", "*.py"),
        ("All files", "*"),
    ]
    fileName = ''.join(c.k.givenArgs)
    if fileName:
        c.open_completer(c, closeFlag, fileName)
        return
    if False:  # This seems not to be worth the trouble.
        g.app.gui.runOpenFileDialog(c,
            callback=open_completer,
            defaultextension=g.defaultLeoFileExtension(c),
            filetypes=table,
            title="Open",
        )
        return
    # Equivalent to legacy code.
    fileName = g.app.gui.runOpenFileDialog(c,
        defaultextension=g.defaultLeoFileExtension(c),
        filetypes=table,
        title="Open",
    )
    open_completer(c, closeFlag, fileName)
#@+node:ekr.20190518121302.1: *6* function: open_completer
def open_completer(c, closeFlag, fileName):

    c.bringToFront()
    c.init_error_dialogs()
    ok = False
    if fileName:
        if g.app.loadManager.isLeoFile(fileName):
            c2 = g.openWithFileName(fileName, old_c=c)
            if c2:
                c2.k.makeAllBindings()
                    # Fix #579: Key bindings don't take for commands defined in plugins.
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if c2 and closeFlag:
                g.app.destroyWindow(c.frame)
        elif c.looksLikeDerivedFile(fileName):
            # Create an @file node for files containing Leo sentinels.
            ok = c.importCommands.importDerivedFiles(parent=c.p,
                paths=[fileName], command='Open')
        else:
            # otherwise, create an @edit node.
            ok = c.createNodeFromExternalFile(fileName)
    c.raise_error_dialogs(kind='write')
    g.app.runAlreadyOpenDialog(c)
    # openWithFileName sets focus if ok.
    if not ok:
        c.initialFocusHelper()
#@+node:ekr.20120223062418.10393: *5* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
#@+node:ekr.20120223062418.10394: *6* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    """Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui, previousSettings=previousSettings)
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # this commander is associated with sqlite db
        c.sqlite_connection = theFile
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
#@+node:ekr.20120223062418.10405: *7* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
#@+node:ekr.20120223062418.10406: *7* LM.findOpenFile
def findOpenFile(self, fn):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20120223062418.10407: *7* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # #181: Honor focus requests.
#@+node:ekr.20120223062418.10408: *7* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20120223062418.10419: *7* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
#@+node:ekr.20120224161905.10030: *7* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
#@+node:ekr.20120223062418.10416: *7* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10410: *7* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        s = g.toUnicode(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10412: *7* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = g.os_path_finalize(g.os_path_dirname(fn))  # 1341
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=False)
            # #970: Never close Leo here.
    return ok
#@+node:ekr.20200909161045.1: *4* ----- no longer needed
#@+node:ekr.20200909161120.1: *4* ----- startup order
#@+node:ekr.20110605121601.18134: *5* init (qt_gui.py)
def init():

    if g.app.unitTesting:  # Not Ok for unit testing!
        return False
    if not QtCore:
        return False
    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    g.app.gui = LeoQtGui()
    g.app.gui.finishCreate()
    g.plugin_signon(__name__)
    return True
#@+node:ekr.20110605121601.18477: *5*  qt_gui.__init__ (sets qtApp)
def __init__(self):
    """Ctor for LeoQtGui class."""
    super().__init__('qt')
         # Initialize the base class.
    self.active = True
    self.consoleOnly = False  # Console is separate from the log.
    self.iconimages = {}
    self.globalFindDialog = None
    self.idleTimeClass = qt_idle_time.IdleTime
    self.insert_char_flag = False  # A flag for eventFilter.
    self.mGuiName = 'qt'
    self.main_window = None
        # The *singleton* QMainWindow.
    self.plainTextWidget = qt_text.PlainTextWrapper
    self.styleSheetManagerClass = StyleSheetManager
        # For c.idle_focus_helper and activate/deactivate events.
    #
    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)
    # Create objects...
    self.qtApp = QtWidgets.QApplication(sys.argv)
    self.reloadSettings()
    self.appIcon = self.getIconImage('leoapp32.png')
    #
    # Define various classes key stokes.
    << define FKeys >>
    << define ignoreChars >>
    << define specialChars >>
    # Put up the splash screen()
    if (g.app.use_splash_screen and
        not g.app.batchMode and
        not g.app.silentMode and
        not g.unitTesting
    ):
        self.splashScreen = self.createSplashScreen()
    self.frameFactory = qt_frame.TabbedFrameFactory()
        # qtFrame.finishCreate does all the other work.

def reloadSettings(self):
    pass
#@+node:ekr.20180419110303.1: *6* << define FKeys >>
self.FKeys = [
    'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']
    # These do not generate keystrokes on MacOs.
#@+node:ekr.20180419105250.1: *6* << define ignoreChars >>
# Always ignore these characters
self.ignoreChars = [
    # These are in ks.special characters.
    # They should *not* be ignored.
        # 'Left', 'Right', 'Up', 'Down',
        # 'Next', 'Prior',
        # 'Home', 'End',
        # 'Delete', 'Escape',
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    # F-Keys are also ok.
        # 'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_0', 'KP_1', 'KP_2', 'KP_3', 'KP_4', 'KP_5', 'KP_6', 'KP_7', 'KP_8', 'KP_9',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1', 'KP_F2', 'KP_F3', 'KP_F4',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        # Keypad chars should be have been converted to other keys.
        # Users should just bind to the corresponding normal keys.
    'CapsLock', 'Caps_Lock',
    'NumLock', 'Num_Lock',
    'ScrollLock',
    'Alt_L', 'Alt_R',
    'Control_L', 'Control_R',
    'Meta_L', 'Meta_R',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
        # Clearly, these should never be generated.
    'Break', 'Pause', 'Sys_Req',
        # These are real keys, but they don't mean anything.
    'Begin', 'Clear',
        # Don't know what these are.
]
#@+node:ekr.20180419081404.1: *6* << define specialChars >>
# Keys whose names must never be inserted into text.
self.specialChars = [
    # These are *not* special keys.
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    'Left', 'Right', 'Up', 'Down',
        # Arrow keys
    'Next', 'Prior',
        # Page up/down keys.
    'Home', 'End',
        # Home end keys.
    'Delete', 'Escape',
        # Others.
    'Enter', 'Insert', 'Ins',
        # These should only work if bound.
    'Menu',
        # #901.
    'PgUp', 'PgDn',
        # #868.
]
#@+node:ekr.20190819072045.1: *5* qt_gui.make_main_window
def make_main_window(self):
    """Make the *singleton* QMainWindow."""
    window = QtWidgets.QMainWindow()
    window.setObjectName('LeoGlobalMainWindow')
    # Calling window.show() here causes flash.
    self.attachLeoIcon(window)
    # Monkey-patch
    window.closeEvent = self.close_event
        # Use self: g.app.gui does not exist yet.
    self.runAtIdle(self.set_main_window_style_sheet)
        # No StyleSheetManager exists yet.
    return window

def set_main_window_style_sheet(self):
    """Style the main window, using the first .leo file."""
    commanders = g.app.commanders()
    if commanders:
        c = commanders[0]
        ssm = c.styleSheetManager
        ssm.set_style_sheets(w=self.main_window)
        self.main_window.setWindowTitle(c.frame.title)  # #1506.
    else:
        g.trace("No open commanders!")
#@+node:ekr.20200914110857.1: *4* Found:dynamicwindow
@nosearch

# flattened, word, ignore-case, head, body

# found 16 nodes
#@+node:ekr.20110605121601.18138: *5*  dw.ctor & reloadSettings
def __init__(self, c, parent=None):
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    if 'startup' in g.app.debug:
        print('DynamicWindow.__init__', c.shortFileName())
    super().__init__(parent)
    self.leo_c = c
    self.leo_master = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
#@+node:ekr.20110228162720.13980: *5* c_file.saveAll
@g.commander_command('save-all')
def saveAll(self, event=None):
    """Save all open tabs windows/tabs."""
    c = self
    c.save()  # Force a write of the present window.
    for f in g.app.windowList:
        c2 = f.c
        if c2 != c and c2.isChanged():
            c2.save()
    # Restore the present tab.
    dw = c.frame.top  # A DynamicWindow
    dw.select(c)
#@+node:ekr.20110605121601.18137: *5* class  DynamicWindow (QMainWindow)
class DynamicWindow(QtWidgets.QMainWindow):
    """
    A class representing all parts of the main Qt window.
    
    c.frame.top is a DynamicWindow.
    c.frame.top.leo_master is a LeoTabbedTopLevel.
    c.frame.top.parent() is a QStackedWidget()

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    """
    @others
#@+node:ekr.20110605121601.18138: *6*  dw.ctor & reloadSettings
def __init__(self, c, parent=None):
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    if 'startup' in g.app.debug:
        print('DynamicWindow.__init__', c.shortFileName())
    super().__init__(parent)
    self.leo_c = c
    self.leo_master = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
#@+node:ekr.20110605121601.18172: *6* dw.do_leo_spell_btn_*
def doSpellBtn(self, btn):
    """Execute btn, a button handler."""
    # Make *sure* this never crashes.
    try:
        tab = self.leo_c.spellCommands.handler.tab
        button = getattr(tab, btn)
        button()
    except Exception:
        g.es_exception()

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
#@+node:ekr.20110605121601.18140: *6* dw.closeEvent
def closeEvent(self, event):
    """Handle a close event in the Leo window."""
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        event.accept()
        return
    if c.inCommand:
        c.requestCloseWindow = True
        return
    ok = g.app.closeLeoWindow(c.frame)
    if ok:
        event.accept()
    else:
        event.ignore()
#@+node:ekr.20110605121601.18139: *6* dw.construct & helpers
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')
        # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
#@+node:ekr.20140915062551.19519: *7* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
#@+node:ekr.20110605121601.18141: *6* dw.createMainWindow & helpers
def createMainWindow(self):
    """
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    """
    self.setMainWindowOptions()
    #
    # Legacy code: will not go away.
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        # Top pane contains only outline.  Bottom pane contains body and log panes.
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        # Top pane contains outline and log panes.
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(self)
    # Signals...
    QtCore.QMetaObject.connectSlotsByName(self)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18142: *7* dw.top-level
#@+node:ekr.20190118150859.10: *8* dw.addNewEditor
def addNewEditor(self, name):
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    #
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame
        # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    
#@+node:ekr.20110605121601.18143: *8* dw.createBodyPane
def createBodyPane(self, parent):
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=QtWidgets.QSizePolicy.Expanding,
         vPolicy=QtWidgets.QSizePolicy.Expanding,
    )
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
 
#@+node:ekr.20110605121601.18144: *8* dw.createCentralWidget
def createCentralWidget(self):
    """Create the central widget."""
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
    return w
#@+node:ekr.20110605121601.18145: *8* dw.createLogPane & helpers (legacy)
def createLogPane(self, parent):
    """Create all parts of Leo's log pane."""
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    #
    # #516 and #1507: Create a Find tab unless we are using a dialog.
    #
    # Careful: @bool minibuffer-ding-mode overrides @bool use-find-dialog.
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if use_minibuffer or not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Complete the Find tab in LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
#@+node:ekr.20131118172620.16858: *9* dw.finishCreateLogPane
def finishCreateLogPane(self):
    """It's useful to create this late, because c.config is now valid."""
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
#@+node:ekr.20110605121601.18146: *8* dw.createMainLayout
def createMainLayout(self, parent):
    """Create the layout for Leo's main window."""
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setObjectName('main_splitter')
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setObjectName('secondary_splitter')
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18147: *8* dw.createMenuBar
def createMenuBar(self):
    """Create Leo's menu bar."""
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
#@+node:ekr.20110605121601.18148: *8* dw.createMiniBuffer (class VisLineEdit)
def createMiniBuffer(self, parent):
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            super().focusInEvent(event)
                # Call the base class method.

        def focusOutEvent(self, event):
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
        # Transfers focus request from label to lineEdit.
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
#@+node:ekr.20110605121601.18149: *8* dw.createOutlinePane
def createOutlinePane(self, parent):
    """Create the widgets and ivars for Leo's outline."""
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
#@+node:ekr.20110605121601.18150: *8* dw.createStatusBar
def createStatusBar(self, parent):
    """Create the widgets and ivars for Leo's status area."""
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
#@+node:ekr.20110605121601.18212: *8* dw.packLabel
def packLabel(self, w, n=None):
    """
    Pack w into the body frame's QVGridLayout.
    
    The type of w does not affect the following code. In fact, w is a
    QTextBrowser possibly packed inside a LeoLineTextWidget.
    """
    c = self.leo_c
    #
    # Reuse the grid layout in the body frame.
    grid = self.leo_body_frame.layout()
    # Pack the label and the text widget.
    label = QtWidgets.QLineEdit(None)
    label.setObjectName('editorLabel')
    label.setText(c.p.h)
    if n is None:
        n = c.frame.body.numberOfEditors
    n = max(0, n - 1)
    grid.addWidget(label, 0, n)
    grid.addWidget(w, 1, n)
    grid.setRowStretch(0, 0)  # Don't grow the label vertically.
    grid.setRowStretch(1, 1)  # Give row 1 as much as vertical room as possible.
    # Inject the ivar.
    w.leo_label = label
#@+node:ekr.20110605121601.18151: *8* dw.setMainWindowOptions
def setMainWindowOptions(self):
    """Set default options for Leo's main window."""
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
#@+node:ekr.20110605121601.18152: *7* dw.widgets
#@+node:ekr.20110605121601.18153: *8* dw.createButton
def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18154: *8* dw.createCheckBox
def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18155: *8* dw.createFrame
def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    """Create a Qt Frame."""
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18156: *8* dw.createGrid
def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18157: *8* dw.createHLayout & createVLayout
def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
#@+node:ekr.20110605121601.18158: *8* dw.createLabel
def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18159: *8* dw.createLineEdit
def createLineEdit(self, parent, name, disabled=True):

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled  # Inject the ivar.
    return w
#@+node:ekr.20110605121601.18160: *8* dw.createRadioButton
def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18161: *8* dw.createStackedWidget
def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18162: *8* dw.createTabWidget
def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18163: *8* dw.createText (creates QTextBrowser)
def createText(self, parent, name,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18164: *8* dw.createTreeWidget
def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18165: *7* dw.log tabs
#@+node:ekr.20110605121601.18167: *8* dw.createSpellTab
def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for (ivar, label, row, col) in table:
        name = f"spell_{label}_button"
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, f"do_leo_spell_btn_{ivar}")
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, f"leo_spell_btn_{ivar}", button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent  # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox  # Must exist
    self.leo_spell_label = lab  # Must exist (!!)
#@+node:ekr.20110605121601.18166: *8* dw.createFindTab & helpers
def createFindTab(self, parent, tab_widget):
    """Create a Find Tab in the given parent."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0  # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget  # A scrollArea.
    ftm.init_widgets()
#@+node:ekr.20131118152731.16847: *9* dw.create_find_grid
def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
#@+node:ekr.20131118152731.16849: *9* dw.create_find_header
def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
#@+node:ekr.20131118152731.16848: *9* dw.create_find_findbox
def create_find_findbox(self, grid, parent, row):
    """Create the Find: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(
        parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16850: *9* dw.create_find_replacebox
def create_find_replacebox(self, grid, parent, row):
    """Create the Replace: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(
        parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:')  # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16851: *9* dw.create_find_checkboxes
def create_find_checkboxes(self, grid, parent, max_row2, row):
    """Create check boxes and radio buttons."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&', '').lower()
        return f"{kind}{name}"

    # Rows for check boxes, radio buttons & execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &Word', 0, 0),
        ('rb', '&Entire outline', 0, 1),
        # Second row.
        ('box', '&Ignore case', 1, 0),
        ('rb', '&Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &Around', 2, 0),
        ('rb', '&Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&Xp', 3, 0),
        ('box', 'search &Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &Finds', 4, 0),
        ('box', 'search &Body', 4, 1),
        # Sixth row.
        ('box', 'mark &Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
#@+node:ekr.20131118152731.16852: *9* dw.create_find_buttons
def create_find_buttons(self, grid, parent, max_row2, row):
    """
    Per #1342, this method now creates labels, not real buttons.
    """
    dw, k = self, self.leo_c.k

    # Create Buttons in column 2 (Leo 4.11.1.)
    table = (
        (0, 2, 'findButton', 'find-next'),
        (1, 2, 'findPreviousButton', 'find-prev'),
        (2, 2, 'findAllButton', 'find-all'),
        (3, 2, 'changeButton', 'replace'),
        (4, 2, 'changeThenFindButton', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'replace-all'),
    )
    for row2, col, func_name, cmd_name in table:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = f"{cmd_name}:  {k.prettyPrintKey(stroke)}"
        else:
            label = cmd_name
        # #1342: Create a label, not a button.
        w = dw.createLabel(parent, cmd_name, label)
        w.setObjectName('find-label')
        grid.addWidget(w, row + row2, col)
    row += max_row2
    row += 2
    return row
#@+node:ekr.20131118152731.16853: *9* dw.create_help_row
def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: <alt-x>help-for-find-commands<return>')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
#@+node:ekr.20150618072619.1: *9* dw.create_find_status
if 0:

    def create_find_status(self, grid, parent, row):
        """Create the status line."""
        dw = self
        status_label = dw.createLabel(parent, 'status-label', 'Status')
        status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
        grid.addWidget(status_label, row, 0)
        grid.addWidget(status_line, row, 1, 1, 2)
        # Official ivars.
        dw.find_status_label = status_label
        dw.find_status_edit = status_line
#@+node:ekr.20131118172620.16891: *9* dw.override_events
def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(
        c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(
        c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)

    if 0:  # #1342: These are no longer needed, because there are no buttons.
        table = (
            ('findNextCommand', 'find-next'),
            ('findPrevCommand', 'find-prev'),
            ('findAll', 'find-all'),
            ('changeCommand', 'replace'),
            ('changeThenFind', 'replace-then-find'),
            ('changeAll', 'replace-all'),
        )
        for func_name, cmd_name in table:
            ivar = f"{cmd_name}-{'button'}"
            ivar = ivar.replace('-', '_')
            w = getattr(ftm, ivar, None)
            func = getattr(fc, func_name, None)
            if w and func:
                next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
                EventWrapper(c, w=w, next_w=next_w, func=func)
            else:
                g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
#@+node:ekr.20131118172620.16892: *10* class EventWrapper
class EventWrapper:

    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper
    @others
#@+node:ekr.20131120054058.16281: *11* create_d
def create_d(self):
    """Create self.d dictionary."""
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
#@+node:ekr.20131118172620.16893: *11* wrapper
def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    if type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16894: *11* keyPress (EventWrapper)
def keyPress(self, event):

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16895: *11* keyRelease
def keyRelease(self, event):
    return self.oldEvent(event)
#@+node:ekr.20110605121601.18168: *7* dw.utils
#@+node:ekr.20110605121601.18169: *8* dw.setName
def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
#@+node:ekr.20110605121601.18170: *8* dw.setSizePolicy
def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
#@+node:ekr.20110605121601.18171: *8* dw.tr
def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    return QtWidgets.QApplication.translate(
        'MainWindow',
        s,
        None,
        QtWidgets.QApplication.UnicodeUTF8)
#@+node:ekr.20110605121601.18173: *6* dw.select
def select(self, c):
    """Select the window or tab for c."""
    # Called from the save commands.
    self.leo_master.select(c)
#@+node:ekr.20110605121601.18178: *6* dw.setGeometry (legacy)
def setGeometry(self, rect):
    """Set the window geometry, but only once when using the qt gui."""
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
        # Only set the geometry once, even for new files.
        if not hasattr(m, 'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            super().setGeometry(rect)
    else:
        super().setGeometry(rect)
#@+node:ekr.20110605121601.18177: *6* dw.setLeoWindowIcon
def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
    g.app.gui.attachLeoIcon(self)
#@+node:ekr.20110605121601.18174: *6* dw.setSplitDirection
def setSplitDirection(self, main_splitter, secondary_splitter, orientation):
    """Set the orientations of the splitters in the Leo main window."""
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    h, v = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
#@+node:ekr.20130804061744.12425: *6* dw.setWindowTitle
if 0:  # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
#@+node:ekr.20110605121601.18139: *5* dw.construct & helpers
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')
        # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
#@+node:ekr.20140915062551.19519: *6* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
#@+node:ekr.20130804061744.12425: *5* dw.setWindowTitle
if 0:  # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
#@+node:ekr.20110605121601.18465: *5* frameFactory.__init__	 & __repr__
def __init__(self):
    # will be created when first frame appears
    # DynamicWindow => Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {}
        # Keys are DynamicWindows, values are frames.
    self.masterFrame = None
    self.createTabCommands()
#@+node:ekr.20131115120119.17398: *5* qt_base_tab.select (leoTabbedTopLevel)
def select(self, c):
    """Select the tab for c."""
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    self.setCurrentIndex(i)
    # Fix bug 844953: tell Unity which menu to use.
        # c.enableMenuBar()
#@+node:ekr.20131115120119.17395: *5* qt_base_tab.setChanged
def setChanged(self, c, changed):
    """Set the changed indicator in c's tab."""
    # Find the tab corresponding to c.
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    if i < 0: return
    s = self.tabText(i)
    if len(s) > 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i, title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i, title)
#@+node:ekr.20131115120119.17396: *5* qt_base_tab.setTabName
def setTabName(self, c, fileName):
    """Set the tab name for c's tab to fileName."""
    # Find the tab corresponding to c.
    dw = c.frame.top  # A DynamicWindow
    i = self.indexOf(dw)
    if i > -1:
        self.setTabText(i, g.shortFileName(fileName))
#@+node:ekr.20150619053138.1: *5* qt_gui.createFindDialog
def createFindDialog(self, c):
    """Create and init a non-modal Find dialog."""
    g.app.globalFindTabManager = c.findCommands.ftm
    top = c.frame.top  # top is the DynamicWindow class.
    w = top.findTab
    d = QtWidgets.QDialog()
    # Fix #516: Hide the dialog. Never delete it.

    def closeEvent(event, d=d):
        event.ignore()
        d.hide()

    d.closeEvent = closeEvent
    layout = QtWidgets.QVBoxLayout(d)
    layout.addWidget(w)
    self.attachLeoIcon(d)
    d.setLayout(layout)
    c.styleSheetManager.set_style_sheets(w=d)
    g.app.gui.setFilter(c, d, d, 'find-dialog')
        # This makes most standard bindings available.
    d.setModal(False)
    return d
#@+node:ekr.20190601054958.1: *5* qt_gui.get_focus
def get_focus(self, c=None, raw=False, at_idle=False):
    """Returns the widget that has focus."""
    # pylint: disable=arguments-differ
    trace = 'focus' in g.app.debug
    trace_idle = False
    trace = trace and (trace_idle or not at_idle)
    app = QtWidgets.QApplication
    w = app.focusWidget()
    if w and not raw and isinstance(w, qt_text.LeoQTextBrowser):
        has_w = getattr(w, 'leo_wrapper', None)
        if has_w:
            if trace: g.trace(w)
        elif c:
            # Kludge: DynamicWindow creates the body pane
            # with wrapper = None, so return the LeoQtBody.
            w = c.frame.body
    if trace:
        name = w.objectName() if hasattr(w, 'objectName') else w.__class__.__name__
        g.trace('(LeoQtGui)', name)
    return w
#@+node:ekr.20130921043420.21175: *5* qt_gui.setFilter
# w's type is in (DynamicWindow,QMinibufferWrapper,LeoQtLog,LeoQtTree,
# QTextEditWrapper,LeoQTextBrowser,LeoQuickSearchWidget,cleoQtUI)

def setFilter(self, c, obj, w, tag):
    """
    Create an event filter in obj.
    w is a wrapper object, not necessarily a QWidget.
    """
    # gui = self
    assert isinstance(obj, QtWidgets.QWidget), obj
    theFilter = qt_events.LeoQtEventFilter(c, w=w, tag=tag)
    obj.installEventFilter(theFilter)
    w.ev_filter = theFilter
        # Set the official ivar in w.
#@+node:ekr.20110605121601.18308: *5* qtFrame.resizeToScreen
@cmd('resize-to-screen')
def resizeToScreen(self, event=None):
    """Resize the Leo window so it fill the entire screen."""
    frame = self
    # This unit test will fail when run externally.
    if frame and frame.top:
        # frame.top.leo_master is a LeoTabbedTopLevel.
        # frame.top is a DynamicWindow.
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['resize-to-screen'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMaximized)
#@+node:ekr.20190611053431.9: *5* qtFrame.setTopGeometry
def setTopGeometry(self, w, h, x, y):
    # self.top is a DynamicWindow.
    if 'size' in g.app.debug:
        g.trace(bool(self.top), w, h, x, y)
    if self.top:
        self.top.setGeometry(QtCore.QRect(x, y, w, h))
#@+node:ekr.20140913054442.19390: *5* ssm.get_master_widget
def get_master_widget(self, top=None):
    """
    Carefully return the master widget.
    c.frame.top is a DynamicWindow.
    """
    if top is None:
        top = self.c.frame.top
    master = top.leo_master or top
    return master
#@+node:ekr.20200914110949.1: *4* ----- The only call to DynamicWindow ctor
#@+node:ekr.20110605121601.18466: *5* frameFactory.createFrame (changed, makes dw)
def createFrame(self, leoFrame):

    c = leoFrame.c
    tabw = self.masterFrame
    dw = DynamicWindow(c, tabw)
    self.leoFrames[dw] = leoFrame
    # Shorten the title.
    title = os.path.basename(c.mFileName) if c.mFileName else leoFrame.title
    tip = leoFrame.title
    dw.setWindowTitle(tip)
    idx = tabw.addTab(dw, title)
    if tip:
        tabw.setTabToolTip(idx, tip)
    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    g.app.gui.setFilter(c, dw, dw, tag='tabbed-frame')
    #
    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() > 1)
    tabw.setTabsClosable(c.config.getBool('outline-tabs-show-close', True))
    if True:  # #1327: Must always do this.
        dw.show()
        tabw.show()
    return dw
#@+node:ekr.20200915113937.1: *3* ===== Retire docks
@nosearch
#@+node:ekr.20200915115424.1: *4* ----- Done: remove use_global_docks
@nosearch

# flattened, word, ignore-case, head, body

# found 7 nodes

# ===== These have all been changed.
#@+node:ekr.20110605121601.18477: *5*  qt_gui.__init__ (sets qtApp)
def __init__(self):
    """Ctor for LeoQtGui class."""
    super().__init__('qt')
         # Initialize the base class.
    self.active = True
    self.consoleOnly = False  # Console is separate from the log.
    self.iconimages = {}
    self.globalFindDialog = None
    self.idleTimeClass = qt_idle_time.IdleTime
    self.insert_char_flag = False  # A flag for eventFilter.
    self.mGuiName = 'qt'
    self.main_window = None
        # The *singleton* QMainWindow.
    self.plainTextWidget = qt_text.PlainTextWrapper
    self.styleSheetManagerClass = StyleSheetManager
        # For c.idle_focus_helper and activate/deactivate events.
    #
    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)
    # Create objects...
    self.qtApp = QtWidgets.QApplication(sys.argv)
    self.reloadSettings()
    self.appIcon = self.getIconImage('leoapp32.png')
    #
    # Define various classes key stokes.
    << define FKeys >>
    << define ignoreChars >>
    << define specialChars >>
    # Put up the splash screen()
    if (g.app.use_splash_screen and
        not g.app.batchMode and
        not g.app.silentMode and
        not g.unitTesting
    ):
        self.splashScreen = self.createSplashScreen()
    self.frameFactory = qt_frame.TabbedFrameFactory()
        # qtFrame.finishCreate does all the other work.

def reloadSettings(self):
    pass
#@+node:ekr.20180419110303.1: *6* << define FKeys >>
self.FKeys = [
    'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12']
    # These do not generate keystrokes on MacOs.
#@+node:ekr.20180419105250.1: *6* << define ignoreChars >>
# Always ignore these characters
self.ignoreChars = [
    # These are in ks.special characters.
    # They should *not* be ignored.
        # 'Left', 'Right', 'Up', 'Down',
        # 'Next', 'Prior',
        # 'Home', 'End',
        # 'Delete', 'Escape',
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    # F-Keys are also ok.
        # 'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_0', 'KP_1', 'KP_2', 'KP_3', 'KP_4', 'KP_5', 'KP_6', 'KP_7', 'KP_8', 'KP_9',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1', 'KP_F2', 'KP_F3', 'KP_F4',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
        # Keypad chars should be have been converted to other keys.
        # Users should just bind to the corresponding normal keys.
    'CapsLock', 'Caps_Lock',
    'NumLock', 'Num_Lock',
    'ScrollLock',
    'Alt_L', 'Alt_R',
    'Control_L', 'Control_R',
    'Meta_L', 'Meta_R',
    'Shift_L', 'Shift_R',
    'Win_L', 'Win_R',
        # Clearly, these should never be generated.
    'Break', 'Pause', 'Sys_Req',
        # These are real keys, but they don't mean anything.
    'Begin', 'Clear',
        # Don't know what these are.
]
#@+node:ekr.20180419081404.1: *6* << define specialChars >>
# Keys whose names must never be inserted into text.
self.specialChars = [
    # These are *not* special keys.
        # 'BackSpace', 'Linefeed', 'Return', 'Tab',
    'Left', 'Right', 'Up', 'Down',
        # Arrow keys
    'Next', 'Prior',
        # Page up/down keys.
    'Home', 'End',
        # Home end keys.
    'Delete', 'Escape',
        # Others.
    'Enter', 'Insert', 'Ins',
        # These should only work if bound.
    'Menu',
        # #901.
    'PgUp', 'PgDn',
        # #868.
]
#@+node:ekr.20161028035755.1: *5* << LeoApp: command-line arguments >>
self.batchMode = False
    # True: run in batch mode.
self.debug = []
    # A list of switches to be enabled.
self.diff = False
    # True: run Leo in diff mode.
self.enablePlugins = True
    # True: run start1 hook to load plugins. --no-plugins
self.failFast = False
    # True: Use the failfast option in unit tests.
self.gui = None
    # The gui class.
self.guiArgName = None
    # The gui name given in --gui option.
self.ipython_inited = False
    # True if leoIpython.py imports succeeded.
self.isTheme = False
    # True: load files as theme files (ignore myLeoSettings.leo).
self.listen_to_log_flag = False
    # True: execute listen-to-log command.
self.qt_use_tabs = False
    # True: using qt gui: allow tabbed main window.
self.loaded_session = False
    # Set by startup logic to True if no files specified on the command line.
self.silentMode = False
    # True: no signon.
self.start_fullscreen = False
    # For qt_frame plugin.
self.start_maximized = False
    # For qt_frame plugin.
self.start_minimized = False
    # For qt_frame plugin.
self.trace_binding = None
    # The name of a binding to trace, or None.
self.trace_setting = None
    # The name of a setting to trace, or None.
self.translateToUpperCase = False
    # Never set to True.
self.useIpython = False
    # True: add support for IPython.
self.use_psyco = False
    # True: use psyco optimization.
self.use_splash_screen = True
    # True: put up a splash screen.
#@+node:ekr.20180605062300.1: *5* fast.scanGlobals & helper
def scanGlobals(self, g_element):
    """Get global data from the cache, with reasonable defaults."""
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    windowSpot = g.app.loadManager.options.get('windowSpot')
    if windowSize is not None:
        h, w = windowSize  # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    if windowSpot is None:
        x, y = d.get('left'), d.get('top')
    else:
        y, x = windowSpot  # #1263: (top, left)
    if 'size' in g.app.debug:
        g.trace(w, h, x, y, c.shortFileName())
    # c.frame may be a NullFrame.
    c.frame.setTopGeometry(w, h, x, y)
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.resizePanesToRatio(r1, r2)
    frameFactory = getattr(g.app.gui, 'frameFactory', None)
    if not frameFactory:
        return
    assert frameFactory is not None
    mf = frameFactory.masterFrame
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        # #1189: fast.scanGlobals calls showMaximized later.
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
#@+node:ekr.20180708060437.1: *6* fast.getGlobalData
def getGlobalData(self):
    """Return a dict containing all global data."""
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
#@+node:ekr.20110605121601.18468: *5* frameFactory.createMaster
def createMaster(self):

    window = self.masterFrame = LeoTabbedTopLevel(factory=self)
    tabbar = window.tabBar()
    g.app.gui.attachLeoIcon(window)
    try:
        tabbar.setTabsClosable(True)
        tabbar.tabCloseRequested.connect(self.slotCloseRequest)
    except AttributeError:
        pass  # Qt 4.4 does not support setTabsClosable
    window.currentChanged.connect(self.slotCurrentChanged)
    if 'size' in g.app.debug:
        g.trace(
            f"minimized: {g.app.start_minimized}, "
            f"maximized: {g.app.start_maximized}, "
            f"fullscreen: {g.app.start_fullscreen}")
    #
    # #1189: We *can* (and should) minimize here, to eliminate flash.
    if g.app.start_minimized:
        window.showMinimized()
#@+node:ekr.20180312151544.1: *5* LM.doSimpleOptions
def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
#@+node:ekr.20110605121601.18250: *5* qtFrame.finishCreate & helpers
def finishCreate(self):
    """Finish creating the outline's frame."""
    # Called from app.newCommander, Commands.__init__
    c = self.c
    assert c
    frameFactory = g.app.gui.frameFactory
    if not frameFactory.masterFrame:
        frameFactory.createMaster()
    self.top = frameFactory.createFrame(leoFrame=self)
    self.createIconBar()  # A base class method.
    self.createSplitterComponents()
    self.createStatusLine()  # A base class method.
    self.createFirstTreeNode()  # Call the base-class method.
    self.menu = LeoQtMenu(c, self, label='top-level-menu')
    g.app.windowList.append(self)
    self.setQtStyle()
    self.miniBufferWidget = qt_text.QMinibufferWrapper(c)
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18251: *6* qtFrame.createSplitterComponents
def createSplitterComponents(self):

    c = self.c
    self.tree = qt_tree.LeoQtTree(c, self)
    self.log = LeoQtLog(self, None)
    self.body = LeoQtBody(self, None)
    self.splitVerticalFlag, ratio, secondary_ratio = self.initialRatios()
    self.resizePanesToRatio(ratio, secondary_ratio)
#@+node:ekr.20190412044556.1: *6* qtFrame.setQtStyle
def setQtStyle(self):
    """
    Set the default Qt style.  Based on pyzo code.
    
    Copyright (C) 2013-2018, the Pyzo development team

    Pyzo is distributed under the terms of the (new) BSD License.
    The full license can be found in 'license.txt'.
    """
    c = self.c
    trace = 'themes' in g.app.debug
    #
    # Get the requested style name.
    stylename = c.config.getString('qt-style-name') or ''
    if trace: g.trace(repr(stylename))
    if not stylename:
        return
    #
    # Return if the style does not exist.
    styles = [z.lower() for z in QtWidgets.QStyleFactory.keys()]
    if stylename.lower() not in styles:
        g.es_print(f"ignoring unknown Qt style name: {stylename!r}")
        g.printObj(styles)
        return
    #
    # Change the style and palette.
    QtWidgets.qApp.nativePalette = QtWidgets.qApp.palette()
    qstyle = QtWidgets.qApp.setStyle(stylename)
    if not qstyle:
        g.es_print(f"failed to set Qt style name: {stylename!r}")
        return
    g.app.gui.qtApp.setPalette(QtWidgets.qApp.nativePalette)
    # g.es_print('set qt style: %r' % stylename)
#@+node:ekr.20190611053431.4: *5* qtFrame.get_window_info
def get_window_info(self):
    """Return the geometry of the top window."""
    if getattr(self.top, 'leo_master', None):
        f = self.top.leo_master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x, y = topLeft.x(), topLeft.y()
    w, h = rect.width(), rect.height()
    if 'size' in g.app.debug:
        g.trace('\n', w, h, x, y)
    return w, h, x, y
#@+node:ekr.20200915121239.1: *4* ----- changed
#@+node:ekr.20200915114215.1: *5* do-nothing when g.app.dock is true
#@+node:ekr.20200303082511.6: *6* 'contract-body-pane' & 'expand-outline-pane'
@g.command('contract-body-pane')
@g.command('expand-outline-pane')
def contractBodyPane(event):
    '''Contract the body pane. Expand the outline/log splitter.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = min(1.0, f.ratio + 0.1)
    f.divideLeoSplitter1(r)
    
expandOutlinePane = contractBodyPane
#@+node:ekr.20200303084048.1: *6* 'contract-log-pane'
@g.command('contract-log-pane')
def contractLogPane(event):
    '''Contract the log pane. Expand the outline pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = min(1.0, f.secondary_ratio + 0.1)
    f.divideLeoSplitter2(r)
#@+node:ekr.20200303084225.1: *6* 'contract-outline-pane' & 'expand-body-pane'
@g.command('contract-outline-pane')
@g.command('expand-body-pane')
def contractOutlinePane(event):
    '''Contract the outline pane. Expand the body pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = max(0.0, f.ratio - 0.1)
    f.divideLeoSplitter1(r)

expandBodyPane = contractOutlinePane
#@+node:ekr.20200303084226.1: *6* 'expand-log-pane'
@g.command('expand-log-pane')
def expandLogPane(event):
    '''Expand the log pane. Contract the outline pane.'''
    c = event.get('c')
    if not c:
        return
    f = c.frame
    r = max(0.0, f.secondary_ratio - 0.1)
    f.divideLeoSplitter2(r)
#@+node:ekr.20200303104851.1: *6* 'hide-body-dock'
@g.command('hide-body-dock')
def hideBodyDock(event):
    '''Hide the Body dock'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.body.widget
    dock = dock_widget(w)
    if dock:
        dock.hide()
#@+node:ekr.20200303084610.1: *6* 'hide-body-pane'
@g.command('hide-body-pane')
def hideBodyPane(event):
    '''Hide the body pane. Fully expand the outline/log splitter.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter1(1.0)
#@+node:ekr.20200303084625.1: *6* 'hide-log-pane'
@g.command('hide-log-pane')
def hideLogPane(event):
    '''Hide the log pane. Fully expand the outline pane.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter2(1.0)
#@+node:ekr.20200303105224.1: *6* 'hide-outline-dock'
@g.command('hide-outline-dock')
def hideOutlineDock(event):
    '''Hide the Outline dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.tree.treeWidget
    dock = dock_widget(w)
    if dock:
        dock.hide()
#@+node:ekr.20200303082511.7: *6* 'hide-outline-pane'
@g.command('hide-outline-pane')
def hideOutlinePane(event):
    '''Hide the outline/log splitter. Fully expand the body pane.'''
    c = event.get('c')
    if not c:
        return
    c.frame.divideLeoSplitter1(0.0)

#@+node:ekr.20200303105106.1: *6* 'hide-tabs-dock'
@g.command('hide-tabs-dock')
def hideTabsDock(event):
    '''Hide the Tabs dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.log.logWidget
    dock = dock_widget(w)
    if dock:
        dock.hide()
#@+node:ekr.20200303105513.1: *6* 'show-body-dock'
@g.command('show-body-dock')
def showBodyDock(event):
    '''Show the Body dock'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.body.widget
    dock = dock_widget(w)
    if dock:
        dock.show()
#@+node:ekr.20200303105712.1: *6* 'show-outline-dock'
@g.command('show-outline-dock')
def showOutlineDock(event):
    '''Show the Outline dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.tree.treeWidget
    dock = dock_widget(w)
    if dock:
        dock.show()
#@+node:ekr.20200303105622.1: *6* 'show-tabs-dock'
@g.command('show-tabs-dock')
def showTabsDock(event):
    '''Show the Tabs dock.'''
    c = event.get('c')
    if not c:
        return
    w = c.frame.log.logWidget
    dock = dock_widget(w)
    if dock:
        dock.show()
#@+node:tbrown.20140524112944.32658: *6* @g.command free-layout-context-menu
@g.command('free-layout-context-menu')
def free_layout_context_menu(event):
    """
    Open free layout's context menu, using the first divider of the top
    splitter for context.
    """
    c = event.get('c')
    splitter = c.free_layout.get_top_splitter()
    handle = splitter.handle(1)
    handle.splitter_menu(handle.rect().topLeft())
#@+node:tbrown.20131111194858.29876: *6* @g.command free-layout-load
@g.command('free-layout-load')
def free_layout_load(event):
    """Load layout from menu."""
    c = event.get('c')
    d = g.app.db.get('ns_layouts', {})
    menu = QtWidgets.QMenu(c.frame.top)
    for k in d:
        menu.addAction(k)
    pos = c.frame.top.window().frameGeometry().center()
    action = menu.exec_(pos)
    if action is None:
        return
    name = str(action.text())
    c.db['_ns_layout'] = name
    # layout = g.app.db['ns_layouts'][name]
    layouts = g.app.db.get('ns_layouts', {})
    layout = layouts.get(name)
    if layout:
        c.free_layout.get_top_splitter().load_layout(layout)
#@+node:tbrown.20130403081644.25265: *6* @g.command free-layout-restore
@g.command('free-layout-restore')
def free_layout_restore(event):
    """
    Restore layout outline had when it was loaded.
    """
    c = event.get('c')
    c.free_layout.loadLayouts('reload', {'c': c}, reloading=True)
#@+node:tbrown.20140522153032.32658: *6* @g.command free-layout-zoom
@g.command('free-layout-zoom')
def free_layout_zoom(event):
    """(un)zoom the current pane."""
    c = event.get('c')
    c.free_layout.get_top_splitter().zoom_toggle()
#@+node:ekr.20110605121601.18340: *6* class LeoQtMenu (LeoMenu)
class LeoQtMenu(leoMenu.LeoMenu):

    @others
#@+node:ekr.20110605121601.18341: *7* LeoQtMenu.__init__
def __init__(self, c, frame, label):
    """ctor for LeoQtMenu class."""
    assert frame
    assert frame.c
    super().__init__(frame)
    self.leo_menu_label = label.replace('&', '').lower()
    self.frame = frame
    self.c = c
    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar is not None
    # Inject this dict into the commander.
    if not hasattr(c, 'menuAccels'):
        setattr(c, 'menuAccels', {})
    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant', 'menu_text_font_weight',
            c.config.defaultMenuFontSize)
#@+node:ekr.20120306130648.9848: *7* LeoQtMenu.__repr__
def __repr__(self):
    return f"<LeoQtMenu: {self.leo_menu_label}>"

__str__ = __repr__
#@+node:ekr.20110605121601.18342: *7* LeoQtMenu.Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20110605121601.18343: *8* LeoQtMenu.Methods with Tk spellings
#@+node:ekr.20110605121601.18344: *9* LeoQtMenu.add_cascade
def add_cascade(self, parent, label, menu, underline):
    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""
    # menu and parent are a QtMenuWrappers, subclasses of  QMenu.
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    menu.setTitle(label)
    if parent:
        parent.addMenu(menu)  # QMenu.addMenu.
    else:
        self.menuBar.addMenu(menu)
    label = label.replace('&', '').lower()
    menu.leo_menu_label = label
    return menu
#@+node:ekr.20110605121601.18345: *9* LeoQtMenu.add_command (Called by createMenuEntries)
def add_command(self, **keys):
    """Wrapper for the Tkinter add_command menu method."""
    # pylint: disable=arguments-differ
    accel = keys.get('accelerator') or ''
    command = keys.get('command') or ''
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    if n is None: n = -1
    menu = keys.get('menu') or self
    if not label:
        return
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = f"{label}\t{accel}"
    action = menu.addAction(label)
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName
    if command:

        def qt_add_command_callback(checked, label=label, command=command):
            return command()

        action.triggered.connect(qt_add_command_callback)
#@+node:ekr.20110605121601.18346: *9* LeoQtMenu.add_separator
def add_separator(self, menu):
    """Wrapper for the Tkinter add_separator menu method."""
    if menu:
        action = menu.addSeparator()
        action.leo_menu_label = '*seperator*'
#@+node:ekr.20110605121601.18347: *9* LeoQtMenu.delete
def delete(self, menu, realItemName='<no name>'):
    """Wrapper for the Tkinter delete menu method."""
    # if menu:
        # return menu.delete(realItemName)
#@+node:ekr.20110605121601.18348: *9* LeoQtMenu.delete_range
def delete_range(self, menu, n1, n2):
    """Wrapper for the Tkinter delete menu method."""
    # Menu is a subclass of QMenu and LeoQtMenu.
    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
#@+node:ekr.20110605121601.18349: *9* LeoQtMenu.destroy
def destroy(self, menu):
    """Wrapper for the Tkinter destroy menu method."""
    # Fixed bug https://bugs.launchpad.net/leo-editor/+bug/1193870
    if menu:
        menu.menuBar.removeAction(menu.menuAction())
#@+node:ekr.20110605121601.18350: *9* LeoQtMenu.index
def index(self, label):
    """Return the index of the menu with the given label."""
    return 0
#@+node:ekr.20110605121601.18351: *9* LeoQtMenu.insert
def insert(self, menuName, position, label, command, underline=None):

    menu = self.getMenu(menuName)
    if menu and label:
        n = underline or 0
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:

            def insert_callback(checked, label=label, command=command):
                command()

            action.triggered.connect(insert_callback)
#@+node:ekr.20110605121601.18352: *9* LeoQtMenu.insert_cascade
def insert_cascade(self, parent, index, label, menu, underline):
    """Wrapper for the Tkinter insert_cascade menu method."""
    menu.setTitle(label)
    label.replace('&', '').lower()
    menu.leo_menu_label = label  # was leo_label
    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)
    action = menu.menuAction()
    if action:
        action.leo_menu_label = label
    else:
        g.trace('no action for menu', label)
    return menu
#@+node:ekr.20110605121601.18353: *9* LeoQtMenu.new_menu
def new_menu(self, parent, tearoff=False, label=''):  # label is for debugging.
    """Wrapper for the Tkinter new_menu menu method."""
    c, leoFrame = self.c, self.frame
    # Parent can be None, in which case it will be added to the menuBar.
    menu = QtMenuWrapper(c, leoFrame, parent, label)
    return menu
#@+node:ekr.20110605121601.18354: *8* LeoQtMenu.Methods with other spellings
#@+node:ekr.20110605121601.18355: *9* LeoQtMenu.clearAccel
def clearAccel(self, menu, name):
    pass
    # if not menu:
        # return
    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")
    # menu.entryconfig(realName,accelerator='')
#@+node:ekr.20110605121601.18356: *9* LeoQtMenu.createMenuBar
def createMenuBar(self, frame):
    """
    (LeoQtMenu) Create all top-level menus.
    The menuBar itself has already been created.
    """
    self.createMenusFromTables()
        # This is LeoMenu.createMenusFromTables.
#@+node:ekr.20110605121601.18357: *9* LeoQtMenu.createOpenWithMenu
def createOpenWithMenu(self, parent, label, index, amp_index):
    """
    Create the File:Open With submenu.

    This is called from LeoMenu.createOpenWithMenuFromTable.
    """
    # Use the existing Open With menu if possible.
    menu = self.getMenu('openwith')
    if not menu:
        menu = self.new_menu(parent, tearoff=False, label=label)
        menu.insert_cascade(parent, index, label, menu, underline=amp_index)
    return menu
#@+node:ekr.20110605121601.18358: *9* LeoQtMenu.disable/enableMenu (not used)
def disableMenu(self, menu, name):
    self.enableMenu(menu, name, False)

def enableMenu(self, menu, name, val):
    """Enable or disable the item in the menu with the given name."""
    if menu and name:
        val = bool(val)
        for action in menu.actions():
            s = g.checkUnicode(action.text()).replace('&', '')
            if s.startswith(name):
                action.setEnabled(val)
                break
#@+node:ekr.20110605121601.18359: *9* LeoQtMenu.getMenuLabel
def getMenuLabel(self, menu, name):
    """Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item."""
    # At present, it is valid to always return None.
#@+node:ekr.20110605121601.18360: *9* LeoQtMenu.setMenuLabel
def setMenuLabel(self, menu, name, label, underline=-1):

    def munge(s):
        return (s or '').replace('&', '')

    # menu is a QtMenuWrapper.

    if not menu: return
    realName = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
#@+node:ekr.20110605121601.18361: *7* LeoQtMenu.activateMenu & helper
def activateMenu(self, menuName):
    """Activate the menu with the given name"""
    menu = self.getMenu(menuName)
        # Menu is a QtMenuWrapper, a subclass of both QMenu and LeoQtMenu.
    if menu:
        self.activateAllParentMenus(menu)
    else:
        g.trace(f"No such menu: {menuName}")
#@+node:ekr.20120922041923.10607: *8* LeoQtMenu.activateAllParentMenus
def activateAllParentMenus(self, menu):
    """menu is a QtMenuWrapper.  Activate it and all parent menus."""
    parent = menu.parent()
    action = menu.menuAction()
    if action:
        if parent and isinstance(parent, QtWidgets.QMenuBar):
            parent.setActiveAction(action)
        elif parent:
            self.activateAllParentMenus(parent)
            parent.setActiveAction(action)
        else:
            g.trace(f"can not happen: no parent for {menu}")
    else:
        g.trace(f"can not happen: no action for {menu}")
#@+node:ekr.20120922041923.10613: *7* LeoQtMenu.deactivateMenuBar
# def deactivateMenuBar (self):
    # """Activate the menu with the given name"""
    # menubar = self.c.frame.top.leo_menubar
    # menubar.setActiveAction(None)
    # menubar.repaint()
#@+node:ekr.20110605121601.18362: *7* LeoQtMenu.getMacHelpMenu
def getMacHelpMenu(self, table):
    return None
#@+node:ekr.20110605121601.18345: *6* LeoQtMenu.add_command (Called by createMenuEntries)
def add_command(self, **keys):
    """Wrapper for the Tkinter add_command menu method."""
    # pylint: disable=arguments-differ
    accel = keys.get('accelerator') or ''
    command = keys.get('command') or ''
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    if n is None: n = -1
    menu = keys.get('menu') or self
    if not label:
        return
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = f"{label}\t{accel}"
    action = menu.addAction(label)
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName
    if command:

        def qt_add_command_callback(checked, label=label, command=command):
            return command()

        action.triggered.connect(qt_add_command_callback)
#@+node:ekr.20110605121601.18251: *6* qtFrame.createSplitterComponents
def createSplitterComponents(self):

    c = self.c
    self.tree = qt_tree.LeoQtTree(c, self)
    self.log = LeoQtLog(self, None)
    self.body = LeoQtBody(self, None)
    self.splitVerticalFlag, ratio, secondary_ratio = self.initialRatios()
    self.resizePanesToRatio(ratio, secondary_ratio)
#@+node:ekr.20110605121601.18307: *6* qtFrame.toggleSplitDirection
@cmd('toggle-split-direction')
def toggleSplitDirection(self, event=None):
    """Toggle the split direction in the present Leo window."""
    if hasattr(self.c, 'free_layout'):
        self.c.free_layout.get_top_splitter().rotate()
#@+node:ekr.20190118150859.10: *5* dw.addNewEditor
def addNewEditor(self, name):
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    #
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame
        # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    
#@+node:ekr.20110605121601.18139: *5* dw.construct & helpers
def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.iconBar.setObjectName('icon-bar')
        # Required for QMainWindow.saveState().
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
#@+node:ekr.20140915062551.19519: *6* dw.set_icon_bar_orientation
def set_icon_bar_orientation(self, c):
    """Set the orientation of the icon bar based on settings."""
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
#@+node:ekr.20110605121601.18143: *5* dw.createBodyPane
def createBodyPane(self, parent):
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=QtWidgets.QSizePolicy.Expanding,
         vPolicy=QtWidgets.QSizePolicy.Expanding,
    )
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
 
#@+node:ekr.20110605121601.18141: *5* dw.createMainWindow & helpers
def createMainWindow(self):
    """
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    """
    self.setMainWindowOptions()
    #
    # Legacy code: will not go away.
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        # Top pane contains only outline.  Bottom pane contains body and log panes.
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        # Top pane contains outline and log panes.
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(self)
    # Signals...
    QtCore.QMetaObject.connectSlotsByName(self)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18142: *6* dw.top-level
#@+node:ekr.20190118150859.10: *7* dw.addNewEditor
def addNewEditor(self, name):
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    #
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame
        # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    
#@+node:ekr.20110605121601.18143: *7* dw.createBodyPane
def createBodyPane(self, parent):
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=QtWidgets.QSizePolicy.Expanding,
         vPolicy=QtWidgets.QSizePolicy.Expanding,
    )
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
 
#@+node:ekr.20110605121601.18144: *7* dw.createCentralWidget
def createCentralWidget(self):
    """Create the central widget."""
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
    return w
#@+node:ekr.20110605121601.18145: *7* dw.createLogPane & helpers (legacy)
def createLogPane(self, parent):
    """Create all parts of Leo's log pane."""
    c = self.leo_c
    #
    # Create the log frame.
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    #
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    #
    # Create the Find tab, embedded in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    #
    # #516 and #1507: Create a Find tab unless we are using a dialog.
    #
    # Careful: @bool minibuffer-ding-mode overrides @bool use-find-dialog.
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if use_minibuffer or not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Complete the Find tab in LeoFind.finishCreate.
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    #
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    #
    # Official ivars
    self.tabWidget = tabWidget  # Used by LeoQtLog.
#@+node:ekr.20131118172620.16858: *8* dw.finishCreateLogPane
def finishCreateLogPane(self):
    """It's useful to create this late, because c.config is now valid."""
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
#@+node:ekr.20110605121601.18146: *7* dw.createMainLayout
def createMainLayout(self, parent):
    """Create the layout for Leo's main window."""
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setObjectName('main_splitter')
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setObjectName('secondary_splitter')
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
#@+node:ekr.20110605121601.18147: *7* dw.createMenuBar
def createMenuBar(self):
    """Create Leo's menu bar."""
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
#@+node:ekr.20110605121601.18148: *7* dw.createMiniBuffer (class VisLineEdit)
def createMiniBuffer(self, parent):
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            super().focusInEvent(event)
                # Call the base class method.

        def focusOutEvent(self, event):
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
        # Transfers focus request from label to lineEdit.
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
#@+node:ekr.20110605121601.18149: *7* dw.createOutlinePane
def createOutlinePane(self, parent):
    """Create the widgets and ivars for Leo's outline."""
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
#@+node:ekr.20110605121601.18150: *7* dw.createStatusBar
def createStatusBar(self, parent):
    """Create the widgets and ivars for Leo's status area."""
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
#@+node:ekr.20110605121601.18212: *7* dw.packLabel
def packLabel(self, w, n=None):
    """
    Pack w into the body frame's QVGridLayout.
    
    The type of w does not affect the following code. In fact, w is a
    QTextBrowser possibly packed inside a LeoLineTextWidget.
    """
    c = self.leo_c
    #
    # Reuse the grid layout in the body frame.
    grid = self.leo_body_frame.layout()
    # Pack the label and the text widget.
    label = QtWidgets.QLineEdit(None)
    label.setObjectName('editorLabel')
    label.setText(c.p.h)
    if n is None:
        n = c.frame.body.numberOfEditors
    n = max(0, n - 1)
    grid.addWidget(label, 0, n)
    grid.addWidget(w, 1, n)
    grid.setRowStretch(0, 0)  # Don't grow the label vertically.
    grid.setRowStretch(1, 1)  # Give row 1 as much as vertical room as possible.
    # Inject the ivar.
    w.leo_label = label
#@+node:ekr.20110605121601.18151: *7* dw.setMainWindowOptions
def setMainWindowOptions(self):
    """Set default options for Leo's main window."""
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
#@+node:ekr.20110605121601.18152: *6* dw.widgets
#@+node:ekr.20110605121601.18153: *7* dw.createButton
def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18154: *7* dw.createCheckBox
def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18155: *7* dw.createFrame
def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    """Create a Qt Frame."""
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18156: *7* dw.createGrid
def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18157: *7* dw.createHLayout & createVLayout
def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
#@+node:ekr.20110605121601.18158: *7* dw.createLabel
def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18159: *7* dw.createLineEdit
def createLineEdit(self, parent, name, disabled=True):

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled  # Inject the ivar.
    return w
#@+node:ekr.20110605121601.18160: *7* dw.createRadioButton
def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
#@+node:ekr.20110605121601.18161: *7* dw.createStackedWidget
def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18162: *7* dw.createTabWidget
def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18163: *7* dw.createText (creates QTextBrowser)
def createText(self, parent, name,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18164: *7* dw.createTreeWidget
def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
#@+node:ekr.20110605121601.18165: *6* dw.log tabs
#@+node:ekr.20110605121601.18167: *7* dw.createSpellTab
def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for (ivar, label, row, col) in table:
        name = f"spell_{label}_button"
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, f"do_leo_spell_btn_{ivar}")
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, f"leo_spell_btn_{ivar}", button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent  # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox  # Must exist
    self.leo_spell_label = lab  # Must exist (!!)
#@+node:ekr.20110605121601.18166: *7* dw.createFindTab & helpers
def createFindTab(self, parent, tab_widget):
    """Create a Find Tab in the given parent."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0  # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget  # A scrollArea.
    ftm.init_widgets()
#@+node:ekr.20131118152731.16847: *8* dw.create_find_grid
def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
#@+node:ekr.20131118152731.16849: *8* dw.create_find_header
def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
#@+node:ekr.20131118152731.16848: *8* dw.create_find_findbox
def create_find_findbox(self, grid, parent, row):
    """Create the Find: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(
        parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16850: *8* dw.create_find_replacebox
def create_find_replacebox(self, grid, parent, row):
    """Create the Replace: label and text area."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(
        parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:')  # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
#@+node:ekr.20131118152731.16851: *8* dw.create_find_checkboxes
def create_find_checkboxes(self, grid, parent, max_row2, row):
    """Create check boxes and radio buttons."""
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&', '').lower()
        return f"{kind}{name}"

    # Rows for check boxes, radio buttons & execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &Word', 0, 0),
        ('rb', '&Entire outline', 0, 1),
        # Second row.
        ('box', '&Ignore case', 1, 0),
        ('rb', '&Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &Around', 2, 0),
        ('rb', '&Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&Xp', 3, 0),
        ('box', 'search &Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &Finds', 4, 0),
        ('box', 'search &Body', 4, 1),
        # Sixth row.
        ('box', 'mark &Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
#@+node:ekr.20131118152731.16852: *8* dw.create_find_buttons
def create_find_buttons(self, grid, parent, max_row2, row):
    """
    Per #1342, this method now creates labels, not real buttons.
    """
    dw, k = self, self.leo_c.k

    # Create Buttons in column 2 (Leo 4.11.1.)
    table = (
        (0, 2, 'findButton', 'find-next'),
        (1, 2, 'findPreviousButton', 'find-prev'),
        (2, 2, 'findAllButton', 'find-all'),
        (3, 2, 'changeButton', 'replace'),
        (4, 2, 'changeThenFindButton', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'replace-all'),
    )
    for row2, col, func_name, cmd_name in table:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = f"{cmd_name}:  {k.prettyPrintKey(stroke)}"
        else:
            label = cmd_name
        # #1342: Create a label, not a button.
        w = dw.createLabel(parent, cmd_name, label)
        w.setObjectName('find-label')
        grid.addWidget(w, row + row2, col)
    row += max_row2
    row += 2
    return row
#@+node:ekr.20131118152731.16853: *8* dw.create_help_row
def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: <alt-x>help-for-find-commands<return>')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
#@+node:ekr.20150618072619.1: *8* dw.create_find_status
if 0:

    def create_find_status(self, grid, parent, row):
        """Create the status line."""
        dw = self
        status_label = dw.createLabel(parent, 'status-label', 'Status')
        status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
        grid.addWidget(status_label, row, 0)
        grid.addWidget(status_line, row, 1, 1, 2)
        # Official ivars.
        dw.find_status_label = status_label
        dw.find_status_edit = status_line
#@+node:ekr.20131118172620.16891: *8* dw.override_events
def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(
        c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(
        c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)

    if 0:  # #1342: These are no longer needed, because there are no buttons.
        table = (
            ('findNextCommand', 'find-next'),
            ('findPrevCommand', 'find-prev'),
            ('findAll', 'find-all'),
            ('changeCommand', 'replace'),
            ('changeThenFind', 'replace-then-find'),
            ('changeAll', 'replace-all'),
        )
        for func_name, cmd_name in table:
            ivar = f"{cmd_name}-{'button'}"
            ivar = ivar.replace('-', '_')
            w = getattr(ftm, ivar, None)
            func = getattr(fc, func_name, None)
            if w and func:
                next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
                EventWrapper(c, w=w, next_w=next_w, func=func)
            else:
                g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
#@+node:ekr.20131118172620.16892: *9* class EventWrapper
class EventWrapper:

    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper
    @others
#@+node:ekr.20131120054058.16281: *10* create_d
def create_d(self):
    """Create self.d dictionary."""
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
#@+node:ekr.20131118172620.16893: *10* wrapper
def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    if type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16894: *10* keyPress (EventWrapper)
def keyPress(self, event):

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
#@+node:ekr.20131118172620.16895: *10* keyRelease
def keyRelease(self, event):
    return self.oldEvent(event)
#@+node:ekr.20110605121601.18168: *6* dw.utils
#@+node:ekr.20110605121601.18169: *7* dw.setName
def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
#@+node:ekr.20110605121601.18170: *7* dw.setSizePolicy
def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
#@+node:ekr.20110605121601.18171: *7* dw.tr
def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    return QtWidgets.QApplication.translate(
        'MainWindow',
        s,
        None,
        QtWidgets.QApplication.UnicodeUTF8)
#@+node:ekr.20110605121601.18148: *5* dw.createMiniBuffer (class VisLineEdit)
def createMiniBuffer(self, parent):
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            super().focusInEvent(event)
                # Call the base class method.

        def focusOutEvent(self, event):
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
        # Transfers focus request from label to lineEdit.
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
#@+node:ekr.20110605121601.18212: *5* dw.packLabel
def packLabel(self, w, n=None):
    """
    Pack w into the body frame's QVGridLayout.
    
    The type of w does not affect the following code. In fact, w is a
    QTextBrowser possibly packed inside a LeoLineTextWidget.
    """
    c = self.leo_c
    #
    # Reuse the grid layout in the body frame.
    grid = self.leo_body_frame.layout()
    # Pack the label and the text widget.
    label = QtWidgets.QLineEdit(None)
    label.setObjectName('editorLabel')
    label.setText(c.p.h)
    if n is None:
        n = c.frame.body.numberOfEditors
    n = max(0, n - 1)
    grid.addWidget(label, 0, n)
    grid.addWidget(w, 1, n)
    grid.setRowStretch(0, 0)  # Don't grow the label vertically.
    grid.setRowStretch(1, 1)  # Give row 1 as much as vertical room as possible.
    # Inject the ivar.
    w.leo_label = label
#@+node:ekr.20110605121601.18199: *5* LeoQtBody.delete_editor_command
@cmd('delete-editor')
@cmd('editor-delete')
def delete_editor_command(self, event=None):
    """Delete the presently selected body text editor."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    # Fix bug 228: make *sure* the old text is saved.
    c.p.b = wrapper.getAllText()
    name = getattr(w, 'leo_name', None)
    if len(list(d.keys())) <= 1 or name == '1':
        g.warning('can not delete main editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        label = getattr(w, 'leo_label', None)
        if label:
            self.unpackWidget(layout, label)
    w.leo_label = None
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18326: *5* LeoQtLog.createTab
def createTab(self, tabName, createText=True, widget=None, wrap='none'):
    """
    Create a new tab in tab widget
    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c
    if widget is None:
        widget = qt_text.LeoQTextBrowser(parent=None, c=c, wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = qt_text.QTextEditWrapper(widget=widget, name='log', c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
        option = QtGui.QTextOption
        widget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
        widget.setReadOnly(False)  # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
        # Set binding on all log pane widgets.
        g.app.gui.setFilter(c, widget, self, tag='log')
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget, tabName)
    else:
        # #1161: Don't set the wrapper unless it has the correct type.
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        if isinstance(contents, qt_text.QTextEditWrapper):
            widget.leo_log_wrapper = widget
                # The leo_log_wrapper is the widget itself.
        else:
            widget.leo_log_wrapper = None
                # Tell the truth.
        g.app.gui.setFilter(c, widget, contents, 'tabWidget')
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents, tabName)
    return contents
#@+node:ekr.20190603064815.1: *5* LeoQtLog.finishCreateTab
def finishCreateTab(self, tabName):
    """Finish creating the given tab. Do not set focus!"""
    c = self.c
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('Can not happen', tabName)
        self.tabName = None
        return
    # # #1161.
    if tabName == 'Log':
        wrapper = None
        widget = self.contentsDict.get('Log')
            # a qt_text.QTextEditWrapper
        if widget:
            wrapper = getattr(widget, 'leo_log_wrapper', None)
            if wrapper and isinstance(wrapper, qt_text.QTextEditWrapper):
                self.logCtrl = wrapper
        if not wrapper: g.trace('NO LOG WRAPPER')
    if tabName == 'Find':
        # Do *not* set focus here!
        # #1254861: Ctrl-f doesn't ensure find input field visible.
        if c.config.getBool('auto-scroll-find-tab', default=True):
            # This is the cause of unwanted scrolling.
            findbox = c.findCommands.ftm.find_findbox
            if hasattr(widget, 'ensureWidgetVisible'):
                widget.ensureWidgetVisible(findbox)
            else:
                findbox.setFocus()
    if tabName == 'Spell':
        # Set a flag for the spell system.
        widget = self.tabWidget.widget(i)
        self.frameDict['Spell'] = widget
#@+node:ekr.20190603064816.1: *5* LeoQtLog.finishSelectTab
def finishSelectTab(self, tabName):
    """Select the proper tab."""
    w = self.tabWidget
    # Special case for Spell tab.
    if tabName == 'Spell':
        return
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('can not happen', tabName)
        self.tabName = None
        return
    w.setCurrentIndex(i)
    self.tabName = tabName
#@+node:ekr.20110605121601.18345: *5* LeoQtMenu.add_command (Called by createMenuEntries)
def add_command(self, **keys):
    """Wrapper for the Tkinter add_command menu method."""
    # pylint: disable=arguments-differ
    accel = keys.get('accelerator') or ''
    command = keys.get('command') or ''
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    if n is None: n = -1
    menu = keys.get('menu') or self
    if not label:
        return
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = f"{label}\t{accel}"
    action = menu.addAction(label)
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName
    if command:

        def qt_add_command_callback(checked, label=label, command=command):
            return command()

        action.triggered.connect(qt_add_command_callback)
#@+node:ekr.20180312151544.1: *5* LM.doSimpleOptions
def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
#@+node:ekr.20120223062418.10393: *5* LM.loadLocalFile & helper
def loadLocalFile(self, fn, gui, old_c):
    """Completely read a file, creating the corresonding outline.

    1. If fn is an existing .leo file (possibly zipped), read it twice:
    the first time with a NullGui to discover settings,
    the second time with the requested gui to create the outline.

    2. If fn is an external file:
    get settings from the leoSettings.leo and myLeoSetting.leo, then
    create a "wrapper" outline continain an @file node for the external file.

    3. If fn is empty:
    get settings from the leoSettings.leo and myLeoSetting.leo or default settings,
    or open an empty outline.
    """
    lm = self
    # Step 0: Return if the file is already open.
    fn = g.os_path_finalize(fn)
    if fn:
        c = lm.findOpenFile(fn)
        if c:
            return c
    # Step 1: get the previous settings.
    # For .leo files (and zipped .leo files) this pre-reads the file in a null gui.
    # Otherwise, get settings from leoSettings.leo, myLeoSettings.leo, or default settings.
    previousSettings = lm.getPreviousSettings(fn)
    # Step 2: open the outline in the requested gui.
    # For .leo files (and zipped .leo file) this opens the file a second time.
    c = lm.openFileByName(fn, gui, old_c, previousSettings)
    return c
#@+node:ekr.20120223062418.10394: *6* LM.openFileByName & helpers
def openFileByName(self, fn, gui, old_c, previousSettings):
    """Read the local file whose full path is fn using the given gui.
    fn may be a Leo file (including .leo or zipped file) or an external file.

    This is not a pre-read: the previousSettings always exist and
    the commander created here persists until the user closes the outline.

    Reads the entire outline if fn exists and is a .leo file or zipped file.
    Creates an empty outline if fn is a non-existent Leo file.
    Creates an wrapper outline if fn is an external file, existing or not.
    """
    lm = self
    # Disable the log.
    g.app.setLog(None)
    g.app.lockLog()
    # Create the a commander for the .leo file.
    # Important.  The settings don't matter for pre-reads!
    # For second read, the settings for the file are *exactly* previousSettings.
    c = g.app.newCommander(fileName=fn, gui=gui, previousSettings=previousSettings)
    # Open the file, if possible.
    g.doHook('open0')
    theFile = lm.openLeoOrZipFile(fn)
    if isinstance(theFile, sqlite3.Connection):
        # this commander is associated with sqlite db
        c.sqlite_connection = theFile
    # Enable the log.
    g.app.unlockLog()
    c.frame.log.enable(True)
    # Phase 2: Create the outline.
    g.doHook("open1", old_c=None, c=c, new_c=c, fileName=fn)
    if theFile:
        readAtFileNodesFlag = bool(previousSettings)
        # The log is not set properly here.
        ok = lm.readOpenedLeoFile(c, fn, readAtFileNodesFlag, theFile)
            # Call c.fileCommands.openLeoFile to read the .leo file.
        if not ok: return None
    else:
        # Create a wrapper .leo file if:
        # a) fn is a .leo file that does not exist or
        # b) fn is an external file, existing or not.
        lm.initWrapperLeoFile(c, fn)
    g.doHook("open2", old_c=None, c=c, new_c=c, fileName=fn)
    # Phase 3: Complete the initialization.
    g.app.writeWaitingLog(c)
    c.setLog()
    lm.createMenu(c, fn)
    lm.finishOpen(c)
    return c
#@+node:ekr.20120223062418.10405: *7* LM.createMenu
def createMenu(self, c, fn=None):
    # lm = self
    # Create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1", c=c, p=c.p, v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        g.app.recentFilesManager.updateRecentFiles(fn)
        g.doHook("menu2", c=c, p=c.p, v=c.p)
        g.doHook("after-create-leo-frame", c=c)
        g.doHook("after-create-leo-frame2", c=c)
        # Fix bug 844953: tell Unity which menu to use.
            # c.enableMenuBar()
#@+node:ekr.20120223062418.10406: *7* LM.findOpenFile
def findOpenFile(self, fn):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if g.os_path_realpath(munge(fn)) == g.os_path_realpath(munge(c.mFileName)):
            # Don't call frame.bringToFront(), it breaks --minimize
            c.setLog()
            # Selecting the new tab ensures focus is set.
            master = getattr(frame.top, 'leo_master', None)
            if master:  # master is a TabbedTopLevel.
                master.select(frame.c)
            c.outerUpdate()
            return c
    return None
#@+node:ekr.20120223062418.10407: *7* LM.finishOpen
def finishOpen(self, c):
    # lm = self
    k = c.k
    assert k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController: c.chapterController.finishCreate()
    if k: k.setDefaultInputState()
    c.initialFocusHelper()
    if k: k.showStateAndMode()
    c.frame.initCompleteHint()
    c.outerUpdate()
        # #181: Honor focus requests.
#@+node:ekr.20120223062418.10408: *7* LM.initWrapperLeoFile
def initWrapperLeoFile(self, c, fn):
    """
    Create an empty file if the external fn is empty.

    Otherwise, create an @edit or @file node for the external file.
    """
    # lm = self
    # Use the config params to set the size and location of the window.
    frame = c.frame
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    # #1570: Resize the _new_ frame.
    frame.splitVerticalFlag, r1, r2 = frame.initialRatios()
    frame.resizePanesToRatio(r1, r2)
    if not g.os_path_exists(fn):
        p = c.rootPosition()
        # Create an empty @edit node unless fn is an .leo file.
        # Fix #1070: Use "newHeadline", not fn.
        p.h = "newHeadline" if fn.endswith('.leo') else f"@edit {fn}"
        c.selectPosition(p)
    elif c.looksLikeDerivedFile(fn):
        # 2011/10/10: Create an @file node.
        p = c.importCommands.importDerivedFiles(parent=c.rootPosition(),
            paths=[fn], command=None)  # Not undoable.
        if p and p.hasBack():
            p.back().doDelete()
            p = c.rootPosition()
        if not p: return None
    else:
        # Create an @<file> node.
        p = c.rootPosition()
        if p:
            load_type = self.options['load_type']
            p.setHeadString(f"{load_type} {fn}")
            c.refreshFromDisk()
            c.selectPosition(p)

    # Fix critical bug 1184855: data loss with command line 'leo somefile.ext'
    # Fix smallish bug 1226816 Command line "leo xxx.leo" creates file xxx.leo.leo.
    c.mFileName = fn if fn.endswith('.leo') else f"{fn}.leo"
    c.wrappedFileName = fn
    c.frame.title = c.computeWindowTitle(c.mFileName)
    c.frame.setTitle(c.frame.title)
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use-chapters') and c.chapterController:
        c.chapterController.finishCreate()
    frame.c.clearChanged()
        # Mark the outline clean.
        # This makes it easy to open non-Leo files for quick study.
    return c
#@+node:ekr.20120223062418.10419: *7* LM.isLeoFile & LM.isZippedFile
def isLeoFile(self, fn):
    return fn and (
        zipfile.is_zipfile(fn) or fn.endswith('.leo') or fn.endswith('.db'))

def isZippedFile(self, fn):
    return fn and zipfile.is_zipfile(fn)
#@+node:ekr.20120224161905.10030: *7* LM.openLeoOrZipFile
def openLeoOrZipFile(self, fn):
    lm = self
    if fn.endswith('.db'):
        return sqlite3.connect(fn)
    zipped = lm.isZippedFile(fn)
    if lm.isLeoFile(fn) and g.os_path_exists(fn):
        if zipped:
            theFile = lm.openZipFile(fn)
        else:
            theFile = lm.openLeoFile(fn)
    else:
        theFile = None
    return theFile
#@+node:ekr.20120223062418.10416: *7* LM.openLeoFile
def openLeoFile(self, fn):
    # lm = self
    try:
        theFile = open(fn, 'rb')
        return theFile
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10410: *7* LM.openZipFile
def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        s = g.toUnicode(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
#@+node:ekr.20120223062418.10412: *7* LM.readOpenedLeoFile
def readOpenedLeoFile(self, c, fn, readAtFileNodesFlag, theFile):
    # New in Leo 4.10: The open1 event does not allow an override of the init logic.
    assert theFile
    # lm = self
    ok = c.fileCommands.openLeoFile(theFile, fn,
        readAtFileNodesFlag=readAtFileNodesFlag)
            # closes file.
    if ok:
        if not c.openDirectory:
            theDir = g.os_path_finalize(g.os_path_dirname(fn))  # 1341
            c.openDirectory = c.frame.openDirectory = theDir
    else:
        g.app.closeLeoWindow(c.frame, finish_quit=False)
            # #970: Never close Leo here.
    return ok
#@+node:ekr.20200915143757.1: *3* new deleted nodes
#@+node:ekr.20190616092159.1: *4* app.get_central_widget
def get_central_widget(self, c):

    assert self.dock, g.callers()
    s = c.config.getString('central-dock-widget')
    if s:
        s = s.lower()
        if s in ('body', 'outline', 'tabs'):
            return s
    return 'outline'
#@+node:ekr.20190613062749.1: *4* debug.print-window-state
@cmd('print-window-state')
def printWindowState(self, event=None):
    """
    For Leo's core developers: print QMainWindow.saveState().
    
    This is the value to be assigned to g.app.defaultWindowState.
    
    Warning: this window state should *only* be used for new users! #1190.
    
    Recommended procedure:

    - Set @bool user-vr-dock = False.  Close Leo.
    - Clear .leo/db caches. Reopen Leo.
    - Make sure Render dock is visible to left of Body dock.
    - Set @bool user-vr-dock = True. Close Leo & reopen.
      The vr dock will be moveable.  Don't move it!
    - Do print-window-state.
    - Change g.app.defaultWindowState.
    """
    c = event.get('c')
    if c:
        print(c.frame.top.saveState())
        if c.config.getBool('dockable-log-tabs', default=False):
            print('Warning: @bool dockable-log-tabs is True')
        central_widget = g.app.get_central_widget(c)
        if central_widget != 'outline':
            print(f"Warning: @string central-dock-widget is {central_widget!r}")
    else:
        print('no c')
#@+node:ekr.20190601054955.1: *4* qt_gui.raise_dock
def raise_dock(self, widget):
    """Raise the nearest parent QDockWidget, if any."""
    while widget:
        if isinstance(widget, QtWidgets.QDockWidget):
            widget.raise_()
            return
        if not hasattr(widget, 'parent'):
            return
        widget = widget.parent()
#@+node:ekr.20200915143036.1: *3* new changes
#@+node:ekr.20110605121601.18138: *4*  dw.ctor & reloadSettings
def __init__(self, c, parent=None):
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    if 'startup' in g.app.debug:
        print('DynamicWindow.__init__', c.shortFileName())
    super().__init__(parent)
    self.leo_c = c
    self.leo_master = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
#@+node:ekr.20200915143230.1: *3* Found:dock
@nosearch

# flattened, ignore-case, head, body

# found 22 nodes
#@+node:ekr.20200915143627.1: *4* changed
#@+node:ekr.20110605121601.18138: *5*  dw.ctor & reloadSettings
def __init__(self, c, parent=None):
    """Ctor for the DynamicWindow class.  The main window is c.frame.top"""
        # Called from LeoQtFrame.finishCreate.
        # parent is a LeoTabbedTopLevel.
    if 'startup' in g.app.debug:
        print('DynamicWindow.__init__', c.shortFileName())
    super().__init__(parent)
    self.leo_c = c
    self.leo_master = None  # Set in construct.
    self.leo_menubar = None  # Set in createMenuBar.
    c._style_deltas = defaultdict(lambda: 0)  # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
#@+node:ekr.20161028035755.1: *5* << LeoApp: command-line arguments >>
self.batchMode = False
    # True: run in batch mode.
self.debug = []
    # A list of switches to be enabled.
self.diff = False
    # True: run Leo in diff mode.
self.enablePlugins = True
    # True: run start1 hook to load plugins. --no-plugins
self.failFast = False
    # True: Use the failfast option in unit tests.
self.gui = None
    # The gui class.
self.guiArgName = None
    # The gui name given in --gui option.
self.ipython_inited = False
    # True if leoIpython.py imports succeeded.
self.isTheme = False
    # True: load files as theme files (ignore myLeoSettings.leo).
self.listen_to_log_flag = False
    # True: execute listen-to-log command.
self.qt_use_tabs = False
    # True: using qt gui: allow tabbed main window.
self.loaded_session = False
    # Set by startup logic to True if no files specified on the command line.
self.silentMode = False
    # True: no signon.
self.start_fullscreen = False
    # For qt_frame plugin.
self.start_maximized = False
    # For qt_frame plugin.
self.start_minimized = False
    # For qt_frame plugin.
self.trace_binding = None
    # The name of a binding to trace, or None.
self.trace_setting = None
    # The name of a setting to trace, or None.
self.translateToUpperCase = False
    # Never set to True.
self.useIpython = False
    # True: add support for IPython.
self.use_psyco = False
    # True: use psyco optimization.
self.use_splash_screen = True
    # True: put up a splash screen.
#@+node:ekr.20161028035956.1: *5* << LeoApp: global data >>
self.atAutoNames = set()
    # The set of all @auto spellings.
self.atFileNames = set()
    # The set of all built-in @<file> spellings.

self.globalKillBuffer = []
    # The global kill buffer.
self.globalRegisters = {}
    # The global register list.
self.leoID = None
    # The id part of gnx's.
self.loadedThemes = []
    # List of loaded theme.leo files.
    # This is used by the 'new' command.
self.lossage = []
    # List of last 100 keystrokes.
self.paste_c = None
    # The commander that pasted the last outline.
self.spellDict = None
    # The singleton PyEnchant spell dict.
self.numberOfUntitledWindows = 0
    # Number of opened untitled windows.
self.windowList = []
    # Global list of all frames.
self.realMenuNameDict = {}
    # Translations of menu names.
#@+node:ekr.20190905091614.5: *5* aso.new_commander
def new_commander(self):
    """Create the new commander, and load all settings files."""
    # import leo.core.leoApp as leoApp
    lm = g.app.loadManager
    old_c = self.c
    # Save any changes so they can be seen.
    if old_c.isChanged():
        old_c.save()
    old_c.outerUpdate()
    # From file-new...
    g.app.disable_redraw = True
    g.app.setLog(None)
    g.app.lockLog()
    # Switch to the new commander. Do *not* use previous settings.
    fileName = f"{old_c.fileName()}-active-settings"
    g.es(fileName, color='red')
    c = g.app.newCommander(fileName=fileName)
    # Restore the layout, if we have ever saved this file.
    if not old_c:
        c.frame.setInitialWindowGeometry()
    # #1340: Don't do this. It is no longer needed.
        # g.app.restoreWindowState(c)
    c.frame.resizePanesToRatio(c.frame.ratio, c.frame.secondary_ratio)
    # From file-new...
    g.app.unlockLog()
    lm.createMenu(c)
    lm.finishOpen(c)
    g.app.writeWaitingLog(c)
    c.setLog()
    c.clearChanged()  # Clears all dirty bits.
    g.app.disable_redraw = False
    return c
#@+node:ekr.20190118150859.10: *5* dw.addNewEditor
def addNewEditor(self, name):
    """Create a new body editor."""
    c, p = self.leo_c, self.leo_c.p
    body = c.frame.body
    assert isinstance(body, LeoQtBody), repr(body)
    #
    # Step 1: create the editor.
    parent_frame = c.frame.top.leo_body_inner_frame
    widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    widget.setObjectName('richTextEdit')  # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(widget, name='body', c=c)
    self.packLabel(widget)
    #
    # Step 2: inject ivars, set bindings, etc.
    inner_frame = c.frame.top.leo_body_inner_frame
        # Inject ivars *here*.
    body.injectIvars(inner_frame, name, p, wrapper)
    body.updateInjectedIvars(widget, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(widget, QtWidgets.QTextEdit):
        colorizer = leoColorizer.make_colorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        body.recolorWidget(p, wrapper)
    
#@+node:ekr.20110605121601.18143: *5* dw.createBodyPane
def createBodyPane(self, parent):
    """
    Create the *pane* for the body, not the actual QTextBrowser.
    """
    c = self.leo_c
    #
    # Create widgets.
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame')
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget',
         hPolicy=QtWidgets.QSizePolicy.Expanding,
         vPolicy=QtWidgets.QSizePolicy.Expanding,
    )
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit')  # A LeoQTextBrowser
    #
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=0)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    #
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw  # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
    return bodyFrame
 
#@+node:ekr.20110605121601.18148: *5* dw.createMiniBuffer (class VisLineEdit)
def createMiniBuffer(self, parent):
    """Create the widgets for Leo's minibuffer area."""
    # Create widgets.
    frame = self.createFrame(parent, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')


    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            super().focusInEvent(event)
                # Call the base class method.

        def focusOutEvent(self, event):
            self.store_selection()
            super().focusOutEvent(event)

        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins < j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit')  # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
        # Transfers focus request from label to lineEdit.
    #
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
    return frame
#@+node:ekr.20110605121601.18151: *5* dw.setMainWindowOptions
def setMainWindowOptions(self):
    """Set default options for Leo's main window."""
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
#@+node:ekr.20110605121601.18195: *5* LeoQtBody.add_editor_command
# An override of leoFrame.addEditor.

@cmd('editor-add')
@cmd('add-editor')
def add_editor_command(self, event=None):
    """Add another editor to the body pane."""
    c, p = self.c, self.c.p
    d = self.editorWrappers
    dw = c.frame.top
    wrapper = c.frame.body.wrapper  # A QTextEditWrapper
    widget = wrapper.widget
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.totalNumberOfEditors == 2:
        d ['1'] = wrapper
        # Pack the original body editor.
        # Fix #1021: Pack differently depending on whether the gutter exists.
        if self.use_gutter:
            dw.packLabel(widget.parent(), n=1)
            widget.leo_label = widget.parent().leo_label
        else:
            dw.packLabel(widget, n=1)
    name = f"{self.totalNumberOfEditors}"
    f, wrapper = dw.addNewEditor(name)
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(widget), widget
    assert isinstance(f, QtWidgets.QFrame), f
    d[name] = wrapper
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        keys = list(d.keys())
        old_name = keys[0]
        old_wrapper = d.get(old_name)
        old_w = old_wrapper.widget
        self.injectIvars(f, old_name, p, old_wrapper)
        self.updateInjectedIvars(old_w, p)
        self.selectLabel(old_wrapper)
             # Immediately create the label in the old editor.
    # Switch editors.
    c.frame.body.wrapper = wrapper
    self.selectLabel(wrapper)
    self.selectEditor(wrapper)
    self.updateEditors()
    c.bodyWantsFocus()
#@+node:ekr.20110605121601.18199: *5* LeoQtBody.delete_editor_command
@cmd('delete-editor')
@cmd('editor-delete')
def delete_editor_command(self, event=None):
    """Delete the presently selected body text editor."""
    c, d = self.c, self.editorWrappers
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    # Fix bug 228: make *sure* the old text is saved.
    c.p.b = wrapper.getAllText()
    name = getattr(w, 'leo_name', None)
    if len(list(d.keys())) <= 1 or name == '1':
        g.warning('can not delete main editor')
        return
    #
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_body_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    #
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        label = getattr(w, 'leo_label', None)
        if label:
            self.unpackWidget(layout, label)
    w.leo_label = None
    self.selectEditor(new_wrapper)
#@+node:ekr.20110605121601.18211: *5* LeoQtBody.injectIvars
def injectIvars(self, parentFrame, name, p, wrapper):

    trace = g.app.debug == 'select' and not g.app.unitTesting
    tag = 'qt_body.injectIvars'
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if trace:
        print(f"{tag:>30}: {wrapper!r} {g.callers(1)}")
    # Inject ivars
    if name == '1':
        w.leo_p = None  # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in JEditColorizer ctor.
    w.leo_frame = parentFrame
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    w.leo_wrapper = wrapper
#@+node:ekr.20110605121601.18201: *5* LeoQtBody.select/unselectLabel
def unselectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    pass
    # self.createChapterIvar(wrapper)

def selectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    c = self.c
    w = wrapper.widget
    label = getattr(w, 'leo_label', None)
    if label:
        label.setEnabled(True)
        label.setText(c.p.h)
        label.setEnabled(False)
#@+node:ekr.20110605121601.18326: *5* LeoQtLog.createTab
def createTab(self, tabName, createText=True, widget=None, wrap='none'):
    """
    Create a new tab in tab widget
    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c
    if widget is None:
        widget = qt_text.LeoQTextBrowser(parent=None, c=c, wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = qt_text.QTextEditWrapper(widget=widget, name='log', c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
        option = QtGui.QTextOption
        widget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
        widget.setReadOnly(False)  # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
        # Set binding on all log pane widgets.
        g.app.gui.setFilter(c, widget, self, tag='log')
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget, tabName)
    else:
        # #1161: Don't set the wrapper unless it has the correct type.
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        if isinstance(contents, qt_text.QTextEditWrapper):
            widget.leo_log_wrapper = widget
                # The leo_log_wrapper is the widget itself.
        else:
            widget.leo_log_wrapper = None
                # Tell the truth.
        g.app.gui.setFilter(c, widget, contents, 'tabWidget')
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents, tabName)
    return contents
#@+node:ekr.20190603064816.1: *5* LeoQtLog.finishSelectTab
def finishSelectTab(self, tabName):
    """Select the proper tab."""
    w = self.tabWidget
    # Special case for Spell tab.
    if tabName == 'Spell':
        return
    i = self.findTabIndex(tabName)
    if i is None:
        g.trace('can not happen', tabName)
        self.tabName = None
        return
    w.setCurrentIndex(i)
    self.tabName = tabName
#@+node:ekr.20190601054959.1: *5* qt_gui.set_focus
def set_focus(self, c, w):
    """Put the focus on the widget."""
    # pylint: disable=arguments-differ
    if not w:
        return
    if getattr(w, 'widget', None):
        if not isinstance(w, QtWidgets.QWidget):
            # w should be a wrapper.
            w = w.widget
    if 'focus' in g.app.debug:
        name = w.objectName() if hasattr(w, 'objectName') else w.__class__.__name__
        g.trace('(LeoQtGui)', name)
    w.setFocus()
#@-all
#@@nosearch
#@-leo
