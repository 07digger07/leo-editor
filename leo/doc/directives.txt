.. @+leo-ver=5-thin
.. @+node:ekr.20100805001344.7253: * @thin directives.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:ekr.20050828061213: ** @rst html/directives.html
#####################################
Chapter 4: Leo's Reference
#####################################

This chapter is a reference for all of Leo's directives.

This chapter does *not* teach how to use Leo. It assumes you are *thoroughly*
familiar with `Leo's tutorial`_.

.. contents::
.. @+node:ekr.20050828160132: *3* @rst-no-head links
.. External links...
.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. Links to other chapters
.. _front:                  front.html
.. _`Leo's tutorial`:       intro.html
.. _`Leo and reStructuredText`: rstplugin3.html
.. _`History of Leo`:       history.html
.. _`Using Chapters`:       outlines.html#using-chapters

.. Relative links...
..  .. _`@auto reference`:      `auto reference`_
..  .. _`@delims`:              `delims reference`_
..  .. _`@file reference`:      `file reference`_
..  .. _`@root Directive Family`:   `root reference`_


.. For reasons unknown, images must appear in the _images folder on the web site.
.. |leoAtFileMainNode| image:: screen-shots/leo-qt-at-file-main-node.JPG
.. |leoAtFileFirstChild| image:: screen-shots/leo-qt-at-file-first-child.JPG
.. |leoAtFileNamedChild| image:: screen-shots/leo-qt-at-file-named-child.JPG
.. @+node:ekr.20100804133903.7260: *3* @rst-ignore-tree
.. @+node:sps.20100712151944.7192: *4* Commands related to @auto
Three commands allow you to manually read and write \@auto nodes from the
presently selected outline. As always, an \@ignore directive in the \@auto
node or its ancestors will suppress any of these commands. Invoke the following
in the minibuffer with Alt-x:

- The read-at-auto-nodes command reads all \@auto nodes in the presently
  selected outline. An \@ignore directive will suppress this import.

- The write-at-auto-nodes command writes all \@auto nodes. An \@ignore
  directive will suppress this write.

- The write-dirty-at-auto-nodes is the same as the write-at-auto-nodes
  command, except that only changed \@auto trees are written.

Most users will rarely use these explicit commands, because reading and writing
.leo files handles \@auto nodes well enough. However, you can use the
read-at-auto-nodes command to update \@auto nodes changed outside of Leo
(e.g., by a text editor or version control system) without having to reload the
.leo file.
.. @+node:ekr.20100806170836.4409: *4* Unused @comment stuff
..  ========================  =======================================================================
..  \@comment                 no args\: Restores the delims to the defaults given by \@language
..  ------------------------  -----------------------------------------------------------------------
..  \@comment //              \1 arg\: Sets the single-line comment delims. 
                                   ..  Clears the block comment delims.
..  ------------------------  -----------------------------------------------------------------------
..  \@comment /\* \*/         \2 args\: Sets the block comment delims.
                                    ..  Clears the single-line delim.
..  ------------------------  -----------------------------------------------------------------------
..  \@comment // /\* \*/      \3 args\: Sets all three delimiters.
..  ========================  =======================================================================

..  If only one delimiter is given, Leo uses it to begin each line of a recognized
..  documentation part (that is, one ungoverned by something like \@all).

..  If two delimiters are given, Leo uses block-style comments instead of
..  single-line comments. For example, \@comment { } could be used with Pascal
..  files.
.. @+node:ekr.20100806170836.4412: *4* Unused @language stuff
..  actionscript            ada95                   ahk                     antlr
..  apacheconf              apdl                    applescript             aspect_j
..  asp                     assembly_macro32        assembly_mcs51          assembly_parrot
..  assembly_r2000          assembly_x86            awk                     batch
..  bbj                     bcel                    bibtex                  b
..  chill                   cobol                   coldfusion              cplusplus
..  c                       csharp                  css                     cvs_commit
..  doxygen                 d                       dsssl                   eiffel
..  embperl                 erlang                  factor                  forth
..  fortran90               fortran                 foxpro                  freemarker
..  gettext                 groovy                  haskell                 haxe
..  hex                     html                    i4gl                    icon
..  idl                     inform                  ini                     inno_setup
..  interlis                io                      java                    javascript
..  jcl                     jhtml                   jmk                     jsp
..  latex                   lilypond                lisp                    lotos
..  lua                     mail                    makefile                maple
..  matlab                  ml                      modula3                 moin
..  mqsc                    netrexx                 nqc                     nsis2
..  objective_c             objectrexx              occam                   omnimark
..  pascal                  patch                   perl                    php
..  phpsection              pike                    pl1                     plain
..  plsql                   pop11                   postscript              povray
..  powerdynamo             progress                prolog                  props
..  pseudoplain             psp                     ptl                     pvwave
..  pyrex                   python                  rebol                   redcode
..  relax_ng_compact        rest                    rhtml                   rib
..  rpmspec                 r                       rtf                     ruby
..  rview                   sas                     scheme                  sdl_pr
..  sgml                    shell                   shellscript             shtml
..  smalltalk               smi_mib                 splus                   sqr
..  squidconf               ssharp                  svn_commit              swig
..  tcl                     texinfo                 tex                     text
..  tpl                     tsql                    uscript                 vbscript
..  velocity                verilog                 vhdl                    xml
..  xsl                     zpt

..  # run this node with Control-b to discover Leo's current list of languages
..  for lang in sorted(g.app.language_delims_dict.keys()):
..    g.es("    @language %s" % lang)
.. @+node:ekr.20100806170836.4400: *4* Unused @root directives
.. index::
    pair: @root; Reference
    pair: @root-code; Reference
    pair: @root-doc; Reference
    pair: @verbose; Reference
    pair: @terse; Reference
    pair: @quiet; Reference
    pair: @silent; Reference

\@root
    Creates an external file using traditional literate programming techniques.

    This directive is the most flexible, the most difficult to use, and behaves
    differently from all other \@<file> directives.

    Using \@root trees is too complex to describe here. See `Using @root trees`_
    for full details.

    This directive must appear in the node's headline.

    **Note**: The following directives are valid only within \@root trees:
    \@quiet, \@root-code, \@root-doc, \@silent, \@terse, \@unit and \@verbose.

.. index::
    pair: @quiet; Reference

\@quiet
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index::
    pair: @silent; Reference

\@silent
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index::
    pair: @terse; Reference

\@terse
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index::
    pair: @unit; Reference

\@unit
    Expands the scope of definitions in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @verbose

\@verbose
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. @+node:sps.20100712151944.7259: *4* Using @root trees
This section discusses \@root trees. \@<file> trees are typically easier to use
than \@root trees:

- \@<file> trees use less markup than \@root trees, since every code section
  must be explicitly named explicitly placed by name. In particular, the
  \@others directive is valid only within \@<file> trees.

- You must explicitly tangle and untangle \@root trees using tangle and untangle
  commands.

However, \@root trees are more flexible than \@<file> trees:

- Sections may be defined anywhere within \@root trees.

- The \@unit directive can expand the scope of section definitions to all
  descendant \@root trees so that a section may be referenced in several \@root
  trees.

- Sections definitions may be extended by multiple nodes within the governing
  scope; in the external file, the corresponding parts appear in the outline
  order of the appearance of the multiple section definitions.

- Multiple sections may be defined within a single node, so if a concept
  requires implementation in multiple files or multiple locations within a file,
  it can still be presented in a coherent unit.

- The meaning of section definitions in \@root trees are independent of their
  position within the tree, except for the influence of ancestor \@language and
  \@comment directives.
.. @+node:sps.20100712151944.7220: *5* \@root
.. index::
    pair: @root; Reference

The \@root directive specifies the name of a file to create.

The body text of the @\root node specifies the contents of the file after all
section references in the \@root node have been expanded in the process
described below.

The \@root directive has three forms. All three forms mean exactly the same
thing::

    @root filename
    @root "filename"
    @root <filename>

If *filename* is an absolute filename the location of the external file is
specified only by the filename. Otherwise, when \@root is given a relative
filename, the location of the external file is relative to:

1. the directory specified by \@path directives in parent nodes, or
2. the \@directory default_tangle_directory if no \@path directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.
.. @+node:sps.20100712151944.7222: *5* \@root-code and @root-doc
.. index::
    pair: @root-code; Reference
    pair: @root-doc; Reference

By default, body text in \@root root trees start in doc mode (see below) if the
\@bool at_root_bodies_start_in_doc_mode setting is True. You may override this
setting explicitly by using \@root-code or \@root-doc instead of \@root. It is
good style to use \@root-code or \@root-doc directive, because the meaning of
\@root trees depends on value of this setting.
.. @+node:ekr.20100806072146.4421: *5* Code and doc parts
.. index::
    pair: Code part; Reference
    pair: Doc part; Reference

Within \@root trees, body text is split into zero or more code and doc parts.
**Code parts** start with \@c or section definition lines (see below). **Doc parts**
start with \@. Parts continue until the start of another part or until the end
of the body text.

.. index::
    pair: Named code section; Reference

The \@c directive starts a **named code section**.  The \@c directive is
invalid unless the node's headline looks a section reference.  That is
the nodes' headline should look like::

    << a section >>
.. @+node:sps.20100712151944.7260: *5* Sections and section references
.. index::
    pair: Section definition line; Reference

**Section definition lines** are lines in body text of the form::

	<< section name>>=

(note the equal sign). At least one non-blank line must follow this line; empty
sections generate an error and prevent any update to the external file.

Section definition lines start named code parts. Within an \@root tree, named
code parts may be defined in more than one place. The definition of a named code
part is the concatenation of all code parts with the same name.

Section references in \@root trees have the same form and meaning as in all other \@<file> trees.

Here is a typical example of the body text within an \@root tree::

    @ This method puts an open node sentinel for node v.
    <<atFile methods>>=
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The example creates or adds to the <<atFile methods>> code section.

If the node's headline starts with <<atFile methods>>, the following
is equivalent to the example above::

    @ This method puts an open node sentinel for node v.
    @c
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

If we convert the doc part to a comment we have::

    @c
    # This method puts an open node sentinel for node v.
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The following escape convention applies only in @root trees. Within a code part.
\@@@ in the first column (and only in the first column) stands for a single
\@ sign.

It is natural to place the definition of a section S in a child of the node
containing the reference to S. However, if a section is referenced in more than
one node, you may place its definition in an ancestor of all the nodes that
refer to it. Here is a typical way of specifying a header file xx.h::

    @root xx.h
    #ifndef xx_defined
    #define xx_defined
    << declarations of public constants of the xx class >>
    << declarations of public types of the xx class >>
    << declarations of public variables of the xx class >>
    << public prototypes of the xx class >>
    #endif

The Tangle commands will create the file xx.h from this body text by expanding
all the section references. Any text preceding the \@root directive is
treated just like the doc part of a section definition and does not appear in
the external file.

Here is the typical way of specifying the corresponding xx.c file::

    @root xx.c
    << public variables of the xx class >>
    << private types of the xx class >>
    << private variables of the xx class >>
    << private function prototypes of the xx class >>
    << methods of the xx class >>

.. index::
    pair: Scope; Reference

The **scope** of a definition is the tree in which the definition is known. By
default, tangle commands look for section definitions only in the the \@root
tree being tangled. That is, all sections are assumed to be defined either in
the body text of a node, or in the body text of a descendants of the node.

.. index:: @unit

The \@unit directive expands the scope of section definitions in \@root nodes.
Within the \@unit tree, sections defined in any \@root node are available to
within all other \@root trees.

For example, suppose we have a tree organized as follows with nodes indicated by
their body contents::

	+ @unit
		+ @root A
		    sections in A
		+ @root B
		    sections in B

All sections defined in A are available in B, and vice versa.
.. @+node:sps.20100712151944.7261: *5* Tangling
.. index:: Tangling

**Tangling** is the process of creating external files from \@root trees. This
process is called "tangling" because tangling rearranges the text of the \@root
tree to form the external file. You must tangle \@root trees explicitly using
one of Leo's Tangle commands.

Tangling starts at the top-level \@root node. Tangling create the contents of
the external file after tangling by expanding all section references in the
top-level \@root node.

Tangling expands a section reference by substituting the code section itself for
the section reference. Tangling is a recursive process. That is, the substituted
code section may contain other code references which are themselves expanded,
and so on.

Three commands tangle an outline: tangle, tangle-all, and tangle-marked; they
appear in the File->Tangle submenu. The tangle command tangles only \@root nodes
the selected tree. The tangle-all command tangles all \@root nodes in the entire
outline. The tangle-marked command tangles all marked \@root nodes in the entire
outline.

The tangle commands ignore any tree whose top-level node contains an \@ignore
directive.  This allows \@root trees to contain data that will not appear
in the tangled external files.
.. @+node:sps.20100712151944.7262: *5* Untangling
.. index:: Untangling(Reference)
.. index:: untangle (command)(Reference)
.. index:: untangle-all(Reference),untangle-marked(Reference)

Untangling is the reverse of tangling.  Tangling updates \@root nodes
based on changes made outside of Leo to the corresponding external files.

The untangle, untangle-all, and untangle-marked commands untangle external
files. These commands are found in the File->Untangle submenu. They update one
or more \@root nodes based on changes made to the corresponding external files.

For example, suppose you create a new part of the outline and tangle it for the
first time. When you compile the external files you may get syntax errors. You
could fix those errors in the outline and tangle the outline again, but you may
also fix the errors in the external files using the compiler's editor, then run
the untangle command on the part of the outline that created the external files.
The untangle command uses the sentinels in the external files to update the
outline to match the changes in the external files. The untangle command marks
all the nodes in the outline that it updates, so by doing unmark-all before
the untangle you can review all such nodes with the goto-next-marked command
(menu Outline->Go To...->Go To Next Marked).

You cannot use Untangle to update doc parts, since those are not present in the
external file.

Untangle does not change the structure of an outline; it never inserts, deletes
or moves nodes. Don't attempt to change the structure of an outline by modifying
external files; it won't work. Also, never delete, move or alter the sentinel
lines in external files written by the tangle command. Such lines start with the
comment delimiter followed by a section name, and are easily recognizable.

If you change the section name in a sentinel line, untangle will not update the
code in the outline (with the old name) that generated the renamed section.
Untangle warns about sections that appear in an external file but not in the
outline. Untangle has no trouble with changed section references in external
files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for
untangle. Untangle will update all cloned nodes each time it is encounters the
code section referenced, so only the code in the last encountered referenced
section will take effect. Therefore, the safe way to update text in cloned nodes
is to make the change in the .leo file rather than the external files.
.. @+node:sps.20100712151944.7250: *5* @verbose, @terse, @quiet and @silent
When the \@verbose, \@terse, \@quiet and \@silent directives determine how the
tangle process puts comments in \@root derived files. These directives control
only: a) the comments containing doc sections and b) sentinel comments that
delimit the beginning and end of code sections. Program comments in code section
are output as they are.

When \@verbose is in effect, the tangle process emits the sentinels necessary
for the untangle process. If \@bool print_doc_flag = True, the tangle process
also puts doc parts in the derived file as comments.

When \@quiet is in effect, the tangle process emits comments indicating section
names, but *not* the section end comments necessary for the untangle process. If
\@bool print_doc_flag = True, the tangle process also puts the doc parts in the
derived file as comments.

When \@terse is in effect, tangle outputs only those comments necessary for
untangle to work; it emits doc parts, regardless of the value of \@bool
print_doc_flag.

When \@silent is in effect tangle adds no additional comments, does not emit
doc parts (regardless of \@bool print_doc_flag), and suppresses generation of
whitespace not explicitly present in section definitions.

\@verbose is the default. If more than one of these directives appear in the
same body text the "most verbose" of these options will be in effect.
.. @+node:ekr.20050828061501.43: *5* CWEB mode
CWEB mode gives support for the `CWEB`_ language in \@root trees. CWEB mode is
in effect only in \@root trees where @language cweb is in effect.

In CWEB mode, Leo treats *all* CWEB code as unevaluated text. That is, Leo
treats cweb control codes, including \@<...@>, \@<..@>=, \@c, \@, \@* and \@**
as "raw" text.

In CWEB mode, Leo does *not* expand *CWEB* section references when writing
external files. However, Leo *does* expand *noweb* section references, so you
may use noweb sections to organize cweb files! You can create *noweb* code and
doc sections using the @code and @doc directives in place of \@c and \@
directives.

In CWEB mode, Leo colors \@, \@* and \@** sections using the same syntax
coloring as for LaTeX. In addition, Leo colors C comments using LaTeX coloring.
You may change these defaults using the color_cweb_doc_parts_with_latex and
color_cweb_comments_with_latex settings.
.. @+node:ekr.20100804133903.7275: *4* @rst-no-head All other directives
.. index:: @(Reference), @doc(Reference),Doc part(Reference)

\@ and \@doc
    These directives start a doc part. \@doc is a synonym for \@. Doc parts
    continue until an \@c directive or the end of the body text. For example::

        @ This is a comment in a doc part.
        Doc parts can span multiple lines.
        The next line ends the doc part
        @c

    When writing external files, Leo writes doc parts as comments.

    Leo does not recognize \@ or \@doc in \@asis trees or when the \@all or
    \@delims directives are in effect.

.. index:: @c(Reference), @code(Reference)

\@c and \@code
    Ends any doc part and starts a code part.

    \@code is a deprecated synonym for \@.

    Leo does not recognize this directive in \@asis trees or when the
    \@all or \@raw directives are in effect.

.. index:: @chapter(Reference), @chapters(Reference)

\@chapter and \@chapters
    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

    These directives are too complex to describe here. For full details, see
    `Using Chapters`_.

    These directives must appear in the node's headline.

\@encoding <encoding>
    Specifies the Unicode encoding for an external file. For example::

        @encoding iso-8859-1

    When reading external files, the encoding given must match the encoding
    actually used in the external file or "byte hash" will result.

.. index:: @first(Reference)

\@first <text>
    Places lines at the very start of an external file, before any Leo
    sentinels. \@first lines must be the very first lines in an \@<file> node.
    More then one \@first lines may appear.

    This creates two first lines, a shebang line and a Python encoding line::

	    @first #! /usr/bin/env python
        @first # -*- coding: utf-8 -*-

    Here is a perl example::

        @first #!/bin/sh -- # perl, to stop looping
        @first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
        @first     if 0;

\@ignore
    Tells Leo to ignore the subtree in which it appears.

    In the body text of most top-level @<file> nodes, the \@ignore directive
    causes Leo not to write the tree. However, Leo ignores \@ignore directives
    in \@asis trees.

    Plugins and other parts of Leo sometimes @ignore for their own purposes. For
    example, Leo's unit testing commands will ignore trees containing @ignore.
    In such cases, the \@ignore directive may appear in the headline or body
    text.

.. index:: @language(Reference)

\@language <language name>
    Specifies the language in effect, including comment delimiters.
    If no \@language directive is in effect, Leo uses the defaults specified
    by the \@string target-language setting.

    A node may contain at most one \@language directive.

    The valid language names are: actionscript,ada,autohotkey, batch, c, config,
    cpp, csharp, css, cweb, elisp, forth, fortran, fortran90, haskell, haxe,
    html, ini, java, javascript, kshell, latex, lua, noweb, pascal, perl,
    perlpod, php, plain, plsql, python, rapidq, rebol, rest, rst, ruby, shell,
    tcltk, tex, unknown, unknown_language, vim, vimoutline, xml, xslt.

    **Note**: Shell files have comments that start with #.

    Case is ignored in the language names. For example, the following are
    equivalent::

        @language html
        @language HTML

    The \@language directive also specifies how the colorizer operates.
    For language x, the file leo/modes/x.py describes how to colorize the language.
    To see the languages presently supported, look in the leo/modes directory.
    There are over 100 such languages.

.. index:: @last(Reference)

\@last <text>
    Places lines at the very end of external files.

    This directive must occur at the very end of top-level \@<file> nodes. More
    than one \@last directive may exist. For example::

        @first <?php
        ...
        @last ?>

    Leo does not recognize \@last directive in \@asis trees.

.. index:: @lineending(Reference)

\@lineending cr/lf/nl/crlf
    Sets the line endings for external files.
    This directive overrides the \@string output_newline setting.

    The valid forms of the @lineending directive are:

    ========================   ======================================================
    \@lineending nl            The default, Linux.
    ------------------------   ------------------------------------------------------
    \@lineending cr            Mac
    ------------------------   ------------------------------------------------------
    \@lineending crlf          Windows
    ------------------------   ------------------------------------------------------
    \@lineending lf            Same as 'nl', not recommended
    ------------------------   ------------------------------------------------------
    \@lineending platform      Same as platform value for output_newline setting.
    ========================   ======================================================

.. index:: @nowrap(Reference)

\@nowrap
    Disables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@nowrap may appear in either headlines or body text.

..  If \@others occurs multiple times in the same node, all non-section nodes
..  appear at the location of the first instance of the \@others directive; the
..  remainder are remembered as sentinels but have no other content.

.. index:: @pagewidth(Reference)

\@pagewidth <n>
   Sets the page width used to break doc parts into lines.
   <n> should be a positive integer.  For example::

      @pagewidth 100

  The \@pagewidth directive overrides the \@int page_width setting.

.. index:: @path(Reference),Absolute path(Reference),Path prefix(Reference)

\@path <path>
   Sets the **path prefix** for relative filenames for all \@<file> tree.

   This directive may appear in headlines or body text, and may
   appear in top-level \@<file> nodes.

   The path is an **absolute path** if it begins with c:\\ or /,
   otherwise the path is a **relative** paths.

   Multiple \@path directives may contribute to the path prefix.
   Absolute paths overrides any ancestor \@path directives.
   Relative paths add to the path prefix.

   If no \@path directives are in effect, the default path prefix is
   the directory containing the .leo file.

   Within \@root trees, the default_tangle_directory setting is used
   as the default if it exists, otherwise the directory containing
   the .leo file is used as the default.

.. index:: @tabwidth(Reference), Negative tab width(Reference)

\@tabwidth <n>
  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

.. index:: @wrap(Reference)

\@wrap
    Enables line wrapping in Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@wrap may appear in either headlines or body text.
.. @+node:ekr.20100806170836.4392: *3* Part 1: \@<file> directives
.. index::
    pair: @<file>, Reference

This section discusses the \@<file> directives. These directives create or
import external files.

**Important**: Newcomers to Leo should create external files with \@auto or
\@thin. Use \@auto if your external files must not contain sentinel lines. Use
\@thin otherwise. In particular, \@thin is **highly recommended** when sharing
external files in a collaborative environment.

**Note**: All these directive must appear in headlines.

The following table summarizes the various ways of creating external files.

+---------+------------+------------------+-----------------+
|         | Sentinels  | Sections and     | File data stored|
| Kind    | in external| @others expanded | in .leo file?   |
|         | file?      | on write?        |                 |
+---------+------------+------------------+-----------------+
| @asis   | no         | no               | yes             |
+---------+------------+------------------+-----------------+
| @auto   | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @edit   | no         | yes: note 3      | no              |
+---------+------------+------------------+-----------------+
| @nosent | no         | yes              | yes             |
+---------+------------+------------------+-----------------+
| @shadow | Note 1     | yes              | no              |
+---------+------------+------------------+-----------------+
| @file   | yes        | yes              |                 |
| @thin   |            |                  | no              |
| Note 2  |            |                  |                 |
+---------+------------+------------------+-----------------+

**Note 1**: \@shadow nodes create two files, a **public** file without sentinels
and a **private** file with sentinels.

**Note 2**: \@file and \@thin nodes are synonyms.

**Note 3**: Outline structure created in \@edit nodes is not saved in the
external file.

.. @+node:ekr.20100806170836.4393: *4* \@asis <path>
.. index::
    pair: @asis; Reference

The \@asis directive creates an external file without sentinels and without any
expansions.

Use this directive only when you must have complete control over every character
of the external file. When writing \@asis nodes, writes the body text of all
nodes in outline order. Leo writes the body text *as is*, without recognizing
section definitions, without expanding section references, and without treating
directives specially in any way. In particular, Leo copies all directives,
including \@ or \@c directives, to the external file as text.

.. index::
    pair: @@ convention in @asis trees; Reference

**The @@ convention**: Within \@asis trees only, if a headline starts with \@@,
Leo writes everything in the headline following the \@@ just before the
corresponding body text.

Files created from \@asis trees contain *nothing* not contained in body text (or
\@@ headlines). In particular, if body text does not end in a newline, the first
line from the next node will concatenated to the last line of the preceding
node.

Within \@asis trees, Leo writes no sentinels to the external file, so Leo can not update the outline
using changes to the external file. When reading .leo files, Leo does *not* read
external files created from \@asis nodes. Instead, all data in an \@asis tree is
stored in the .leo file.

Within \@asis trees, Leo recognizes the \@ignore directive only in the
*ancestors* of \@asis nodes. This allows you to use the \@ignore directive to
prevent Leo from writing \@asis trees.

**Note**: \@file-asis and \@silent are deprecated synonyms for \@asis.
.. @+node:ekr.20100806170836.4396: *4* \@auto <path>
.. index::
    pair: @auto; Reference
    pair: Importer; Reference
    pair: Organizer tag; Reference
    pair: Strict language; Reference
    pair: Underindented line; Reference

The \@auto directive imports an external file into a tree of nodes. Using \@auto
is *highly recommended* when using external files that must not contain Leo
sentinels.

\@auto trees allow people to use Leo in collaborative environments without using
sentinels in external files. Even without sentinels, \@auto trees can change
when the corresponding external file changes outside of Leo.

When reading \@auto nodes, Leo creates the \@auto tree using **importers**,
parsers that create an outline with nodes for each class, method and function in
the external file. Some importers create other kinds of nodes as well.

Importers presently exist for C, elisp, HTML, Java, Javascript, Pascal, PHP,
Python and xml. Leo determines the language using the file's extension. If no
parser exists for a language, Leo copies the entire body of the external file
into the \@auto node.

**Note**: the \@data import_xml_tags setting specifies the **organizer tags**
that cause the HTML and XML importers to create outline nodes. By default, the
**organizer tags** are html, body, head, and div.

When writing \@auto nodes, Leo writes the external file without sentinels. This
allows you to use Leo in collaborative environments without disturbing
colleagues. Leo does not expand section references when writing \@auto nodes:
Leo generates \@verbatim sentinels for lines that look like section references.

When importing files into \@auto trees, Leo performs several checks to ensure
that writing the imported file will produce exactly the same file. These checks
can produces **errors** or **warnings**. Errors indicate a potentially serious
problem. Leo inserts an \@ignore directive in the \@auto tree if any error is
found. This prevents the \@auto tree from modifying the external file.

Before importing a file, Leo **regularizes** the leading whitespace of all
lines of the original source file. That is, Leo converts blanks to tabs or
tabs to blanks depending on the value of the \@tabwidth directive in effect
for the \@auto node. Leo also checks that the indentation of any non-blank
line is a multiple of the indentation specified by the \@tabwidth directive.
**Strict languages** are languages such as Python for which leading
whitespace must be preserved exactly as it appears in the original source
file. Problems during regularizing whitespace generate errors for strict
languages and warnings for non-strict languages.

After importing a file, Leo verifies that writing the \@auto node would create
the same file as the original file. Such file comparison mismatches
generate errors unless the problem involves only leading whitespace for
non-strict languages. Whenever a mismatch occurs the first non-matching line is
printed.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any such bugs immediately.

2. Underindented lines in classes, methods or function.

An **underindented line** is a line that is indented less then the starting
line of the class, method or function in which it appears. Leo outlines can
not represent such lines exactly: every line of node will have, in the
external file, at least the indentation of any unindented line of the node.
Leo will issue a warning (not an error) for underindented Python comment
lines. Such lines can not change the meaning of Python programs.
.. @+node:ekr.20100806170836.4395: *4* \@edit <path>
.. index::
    pair: @edit; Reference

The \@edit directive imports an external file into a single node.

When reading \@edit nodes, Leo reads the entire file into the \@edit node. Lines
that look like sentinels will be read just as they are.

When writing \@edit nodes, Leo writes expands section references, \@all and
\@others just as with \@thin trees. However, Leo writes no sentinels, so the
structure created by sections references, \@all and \@others is not preserved.
.. @+node:ekr.20100806170836.4403: *4* \@file <path>
.. index::
    pair: @file; Reference
    pair: @thin; Reference

The \@file directive is a synonym for \@thin.

Prior to Leo 4.7, \@file worked differently from \@thin. This should not be
a problem: Leo 4.7 can read all external files written by Leo 4.6.
.. @+node:ekr.20100806170836.4399: *4* \@nosent <path>
.. index::
    pair: @nosent; Reference

The \@nosent <filename> creates an external file without sentinel lines.

When writing an \@nosent tree, Leo expands section references, \@all and
\@others directives, but Leo writes no sentinels to the external file. Thus, Leo
can not update \@nosent trees from changes made to the external file.

When reading an \@nosent node, Leo does *not* read the external file. Instead, all the
data in the \@nosent tree is stored in the .leo file.

**Note**: \@auto or \@shadow are usually better choices than \@nosent for
creating external files without sentinels.

**Note**: The \@bool force_newlines_in_at_nosent_bodies setting controls whether
Leo writes a trailing newline if non-empty body text does not end in a newline.
The default is True.
.. @+node:ekr.20100806170836.4402: *4* \@shadow <path>
.. index::
    pair: @shadow; Reference
    pair: Private file; Reference
    pair: Public file; Reference

The \@shadow directive creates *two* external files, a **public** file without
sentinels, and a **private** file containing sentinels.

When reading an \@shadow node, Leo uses a brilliant algorithm devised by
Bernhard Mulder that compares the public and private files, and then updates the
outline based on changes to the *public* file. In this way, \@shadow provides
many of the benefits of \@thin trees without writing sentinels in the (public)
external file.

Leo can do an initial import of \@shadow trees by parsing the corresponding
public file, exactly as is done for \@auto nodes.
.. @+node:ekr.20100806170836.4401: *4* \@thin <path>
.. index::
    pair: @thin; Reference

The \@thin directive creates an external file containing sentinels. When writing
\@thin trees, Leo expands section references and \@all and \@others directives.

When reading external files created by \@thin, the sentinels allow Leo to
recreate all aspects of the outline. In particular, Leo can update the
outline based on changes made to the file by another editor. 

**Important**: \@thin is the recommended way to create and edit most files. In
particular, using \@thin nodes is **highly recommended** when sharing external
files in a collaborative environment.
.. @+node:ekr.20100806170836.4411: *3* Part 2: \@all and \@others
These control how Leo places text when writing external files.
They are two of the most important directives in Leo.

.. glossary::
    :sorted:

.. index::
    pair: @all; Reference

\@all

    Copies *all* descendant nodes to the external file. Use \@all to place
    unrelated data in an external file.

    The \@all directive is valid only in the body of \@thin trees.

    Within the range of an \@all directive, Leo ignores the \@others directive
    and section references, so Leo will not complain about orphan nodes.

.. index::
    pair: @others; Reference

\@others

    Writes the body text of all unnamed descendant into the external file, in
    outline order.

    Whitespace appearing before \@others directive adds to the indentation of
    all nodes added by the \@others directive.

    A single node may contain only one \@others directive, but descendant nodes
    may have other \@others directives.
.. @+node:ekr.20100806170836.4398: *3* Part 3: Syntax coloring directives
The \@color, \@killcolor, \@nocolor and \@nocolor-node directives control how
Leo colors text in the body pane.

.. index::
    pair: Ambiguous node; Reference

These directives typically affect the node in which they appear and all
descendant nodes. Exception: an **ambiguous node**, a node containing both
\@color and \@nocolor directives, has no effect on how Leo colors text in
descendant nodes.

.. glossary::
    :sorted:

.. index::
    pair: @color; Reference

\@color

    Enables syntax coloring until the next \@nocolor directive.

.. index::
    pair: @killcolor; Reference

\@killcolor

    Disables syntax coloring in a node, overriding all \@color, \@nocolor or
    \@nocolor-node directives in the same node.

.. index::
    pair:  @nocolor; Reference

\@nocolor

    Disables syntax coloring until the next \@nocolor directive.

.. index::
    pair:  @nocolor-node; Reference

\@nocolor-node

    Disables coloring for only the node containing it. The \@nocolor-node
    directive overrides the \@color and \@nocolor directives within the same
    node.
.. @+node:ekr.20100806170836.4408: *3* Part 4: Dangerous directives
These directives alter how Leo represents data in external files. They are
**dangerous**--mistakes in using these sentinels can make it impossible for Leo
to read the resulting external file. Use them with care!

Nevertheless, these sentinels can be useful in special situations.

.. glossary::
    :sorted:

.. index::
    pair:  @comment; Reference

\@comment <1, 2 or three comment delims>

    Sets the comment delimiters in \@thin, \@file and \@shadow files.
    **Important**: Use \@comment for unusual situations only. In most cases, you
    should use the \@language directive to set comment delimiters.

    The \@comment directive may be followed by one, two or three delimiters,
    separated by whitespace. If one delimiter is given, it sets the delimiter
    used by single-line comments. If two delimiters are given, they set the
    block comment delimiter. If three delimiters are given, the first sets the
    single-line-comment delimiter, and the others set the block-comment
    delimiters.

    Within these delimiters, underscores represent a significant space, and
    double underscores represent a newline. Examples::

        @comment REM_
        @comment __=pod__ __=cut__

    The second line sets PerlPod comment delimiters.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: \@language and \@comment may appear in the same node, provided
    that \@comment appears *after* the \@language directive: \@comment overrides
    \@language.

    The \@comment directive must precede the first section name or \@c
    directive.

.. index::
    pair:  @delims; Reference

\@delims <1 or 2 comment delims>

    Sets comment delimiters in external files containing sentinel lines.

    The \@delims directive requires one or two delimiters, separated by
    whitespace. If one delimiter is present it sets the single-line-comment
    delimiter. If two delimiters are present they set block comment delimiters.

    This directive is often used to place Javascript text inside XML or HTML
    files. Like this::

        @delims /* */
        Javascript stuff
        @delims <-- -->
        HTML stuff

    **Warning**: you **must** change back to previous delimiters using another
    \@delims directive. Failure to change back to the previous delimiters will
    thoroughly corrupt the external file as far as compilers, HTML renderers,
    etc. are concerned. Leo does not do this automatically at the end of a node.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: The \@delims directive can not be used to change the comment
    strings at the start of the external file, that is, the comment strings for
    the \@+leo sentinel and the initial \@+body and \@+node sentinels.

.. index::
    pair:  @raw; Reference
    pair:  @end_raw; Reference

\@raw and \@end_raw

    \@raw starts a section of "raw" text that ends *only* with the \@end_raw directive
    or the end of the body text containing the \@raw directive. Within this
    range, Leo ignores all section references and directives, and Leo generates
    no additional leading whitespace.
.. @+node:ekr.20100804133903.7262: *3* Part 5: All other directives
This section is a reference guide for all other Leo directives, organized
alphabetically.

Unless otherwise noted, all directives listed are valid only in body text,
and they must start at the leftmost column of the node.

.. glossary::
     :sorted:

.. index::
    pair:  @; Reference
.. index::
    pair:  @doc; Reference
.. index::
    pair:  Doc part; Reference

\@ and \@doc

    These directives start a doc part. \@doc is a synonym for \@. Doc parts
    continue until an \@c directive or the end of the body text. For example::

        @ This is a comment in a doc part.
        Doc parts can span multiple lines.
        The next line ends the doc part
        @c

    When writing external files, Leo writes doc parts as comments.

    Leo does not recognize \@ or \@doc in \@asis trees or when the \@all or
    \@delims directives are in effect.

.. index::
    pair:  @c; Reference
.. index::
    pair:  @code; Reference

\@c and \@code

    Ends any doc part and starts a code part.

    \@code is a deprecated synonym for \@.

    Leo does not recognize this directive in \@asis trees or when the
    \@all or \@raw directives are in effect.

.. index::
    pair:  @chapter; Reference
.. index::
    pair:  @chapters; Reference

\@chapter and \@chapters

    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

    These directives are too complex to describe here. For full details, see
    `Using Chapters`_.

    These directives must appear in the node's headline.

.. index::
    pair:  @encoding; Reference

\@encoding <encoding>

    Specifies the Unicode encoding for an external file. For example::

        @encoding iso-8859-1

    When reading external files, the encoding given must match the encoding
    actually used in the external file or "byte hash" will result.

.. index::
    pair:  @first; Reference

\@first <text>

    Places lines at the very start of an external file, before any Leo
    sentinels. \@first lines must be the very first lines in an \@<file> node.
    More then one \@first lines may appear.

    This creates two first lines, a shebang line and a Python encoding line::

        @first #! /usr/bin/env python
        @first # -*- coding: utf-8 -*-

    Here is a perl example::

        @first #!/bin/sh -- # perl, to stop looping
        @first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
        @first     if 0;

\@ignore

    Tells Leo to ignore the subtree in which it appears.

    In the body text of most top-level @<file> nodes, the \@ignore directive
    causes Leo not to write the tree. However, Leo ignores \@ignore directives
    in \@asis trees.

    Plugins and other parts of Leo sometimes @ignore for their own purposes. For
    example, Leo's unit testing commands will ignore trees containing @ignore.
    In such cases, the \@ignore directive may appear in the headline or body
    text.

.. index::
    pair:  @language; Reference

\@language <language name>

    Specifies the language in effect, including comment delimiters.
    If no \@language directive is in effect, Leo uses the defaults specified
    by the \@string target-language setting.

    A node may contain at most one \@language directive.

    The valid language names are: actionscript, ada, autohotkey, batch, c, config,
    cpp, csharp, css, cweb, elisp, forth, fortran, fortran90, haskell, haxe,
    html, ini, java, javascript, kshell, latex, lua, noweb, pascal, perl,
    perlpod, php, plain, plsql, python, rapidq, rebol, rest, rst, ruby, shell,
    tcltk, tex, unknown, unknown_language, vim, vimoutline, xml, xslt.

    **Note**: Shell files have comments that start with #.

    Case is ignored in the language names. For example, the following are
    equivalent::

        @language html
        @language HTML

    The \@language directive also controls syntax coloring. For language x, the
    file leo/modes/x.py describes how to colorize the language. To see the
    languages presently supported, look in the leo/modes directory. There are
    over 100 such languages.

.. index::
    pair:  @last; Reference

\@last <text>

    Places lines at the very end of external files.

    This directive must occur at the very end of top-level \@<file> nodes. More
    than one \@last directive may exist. For example::

        @first <?php
        ...
        @last ?>

    Leo does not recognize \@last directive in \@asis trees.

.. index::
    pair:  @lineending; Reference

\@lineending cr/lf/nl/crlf

    Sets the line endings for external files.
    This directive overrides the \@string output_newline setting.

    The valid forms of the @lineending directive are:

    ========================   ======================================================
    \@lineending nl            The default, Linux.
    ------------------------   ------------------------------------------------------
    \@lineending cr            Mac
    ------------------------   ------------------------------------------------------
    \@lineending crlf          Windows
    ------------------------   ------------------------------------------------------
    \@lineending lf            Same as 'nl', not recommended
    ------------------------   ------------------------------------------------------
    \@lineending platform      Same as platform value for output_newline setting.
    ========================   ======================================================

.. index::
    pair:  @nowrap; Reference

\@nowrap

    Disables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@nowrap may appear in either headlines or body text.

..  If \@others occurs multiple times in the same node, all non-section nodes
..  appear at the location of the first instance of the \@others directive; the
..  remainder are remembered as sentinels but have no other content.

.. index::
    pair:  @pagewidth; Reference

\@pagewidth <n>

   Sets the page width used to break doc parts into lines.
   <n> should be a positive integer.  For example::

      @pagewidth 100

  The \@pagewidth directive overrides the \@int page_width setting.

.. index::
    pair:  @path; Reference
.. index::
    pair:  Absolute path; Reference
.. index::
    pair:  Path prefix; Reference

\@path <path>

   Sets the **path prefix** for relative filenames for all \@<file> tree.

   This directive may appear in headlines or body text, and may
   appear in top-level \@<file> nodes.

   The path is an **absolute path** if it begins with c:\\ or /,
   otherwise the path is a **relative** paths.

   Multiple \@path directives may contribute to the path prefix.
   Absolute paths overrides any ancestor \@path directives.
   Relative paths add to the path prefix.

   If no \@path directives are in effect, the default path prefix is
   the directory containing the .leo file.

   Within \@root trees, the default_tangle_directory setting is used
   as the default if it exists, otherwise the directory containing
   the .leo file is used as the default.

.. index::
    pair:  @tabwidth; Reference
.. index::
    pair:  Negative tab width; Reference

\@tabwidth <n>

  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

.. index::
    pair:  @wrap; Reference

\@wrap

    Enables line wrapping in Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@wrap may appear in either headlines or body text.
.. @-all
.. @-leo
