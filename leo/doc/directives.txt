.. @+leo-ver=5-thin
.. @+node:ekr.20100805001344.7253: * @thin directives.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:ekr.20050828061213: ** @rst html/directives.html
#####################################
Chapter 4: Writing Programs in Leo
#####################################
.. @+node:ekr.20050828160132: *3* @rst-no-head links
.. External links...
.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. Links to other chapters
.. _front:                  front.html
.. _`Leo's tutorial`:       intro.html
.. _`Leo and reStructuredText`: rstplugin3.html
.. _`History of Leo`:       history.html
.. _`Using Chapters`:       outlines.html#using-chapters

.. Relative links...
..  .. _`@auto reference`:      `auto reference`_
..  .. _`@delims`:              `delims reference`_
..  .. _`@file reference`:      `file reference`_
..  .. _`@root Directive Family`:   `root reference`_


.. For reasons unknown, images must appear in the _images folder on the web site.
.. |leoAtFileMainNode| image:: screen-shots/leo-qt-at-file-main-node.JPG
.. |leoAtFileFirstChild| image:: screen-shots/leo-qt-at-file-first-child.JPG
.. |leoAtFileNamedChild| image:: screen-shots/leo-qt-at-file-named-child.JPG
.. @+node:ekr.20050828061501.1: *3* @rst-no-head Intro
This chapter is a reference for all of Leo's directives, organized by topic, and
further organized alphabetically with each top. This chapter also covers several
special topics.

This chapter does *not* teach how to use Leo.  It assumes you are thoroughly
familiar with `Leo's tutorial`_.

..  This chapter is a guide to computer programming with Leo, specifically, to
..  interacting with external files intended for use with other programs, such as C
..  or python source code, the CVS data for a spreadsheet, or a markup language such
..  as nroff, TeX or XML. For reStructuredText, there are special facilities
..  detailed in the chapter `Leo and reStructuredText`_. This chapter does *not*
..  teach you how to use Leo: for that you should read `Leo's tutorial`_. You should
..  be thoroughly familiar with the terminology introduced in that tutorial.
.. @+node:ekr.20100804133903.7267: *3* Summary of ways to create external files
The following table summarizes the various ways of creating external files.

+---------+------------+------------------+-----------------+
|         | Sentinels  | Sections and     | Sections and    |
| Kind    | in external| @others expanded | @others created |
|         | files?     | on write?        | on read?        |
+---------+------------+------------------+-----------------+
| @asis   | no         | no               | no              |
+---------+------------+------------------+-----------------+
| @auto   | no         | yes              | yes             |
+---------+------------+------------------+-----------------+
| @edit   | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @nosent | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @shadow | Note 1     | yes              | yes             |
+---------+------------+------------------+-----------------+
| @file   | yes        | yes              | .leo file       |
| @thin   |            |                  | updated by      |
| Note 2  |            |                  | external file   |
+---------+------------+------------------+-----------------+

.. index:: Public @shadow file(r), Private @shadow file.(r)

**Note 1**: \@shadow nodes create two files, a **public** file without sentinels
and a **private** file with sentinels.

**Note 2**: \@file and \@thin nodes are synonyms.

.. @+node:sps.20100712151944.7214: *3* Section references
In the \@auto, \@edit, \@file, \@nosent, \@shadow and \@thin trees, << *section*
>> in the headline specifies that this node and its descendants define a named
section. In the body of a node, it specifies the location at which the text of a
named section (defined in a child node) is to be interpolated. It is the only
directive recognized in the body when preceded by something other than
whitespace.

As with nearly all other directives, sections are ignored in \@asis trees or
when governed by \@all.
.. @+node:sps.20100712151944.7260: *3* Sections and section definitions
Just as with \@file trees, \@root trees may contain code parts and doc
parts, but their delineation is different. Code parts start with section
definition lines (see below) or the \@c directive. Doc parts start with \@
directive. Parts continue until the end of body text or until the next section
definition, \@c or \@ directive.

Body text in \@root trees contain zero or more code and doc parts in any
order. The \@c directive starts a named code section if the node's headline
starts with << *section name* >>. Otherwise, the \@c directive is
invalid.

**Section definition lines** are lines of the form::

	<< section name>>=

(note the equal sign). Such lines also start named code parts. Named code parts
in \@root trees may be defined in several places. The definition of a named
code part is the concatenation of all code parts with the same name. Body text
that defines no code part is considered the doc part; it is associated with the
following code section, but unless the output mode directive \@verbose
governs the external file generation, the doc part is ignored. At least one
non-blank line must follow at least one section definition line for the named
section; empty sections generate an error and prevent any update to the external
file.

Paired << and >> characters on the same line always denote a section name, even
within comments and strings. Thus, << and >> characters that do not delimit a
section name must be placed on separate lines. Specifically, the \@raw and
\@end_raw directives are not available. If << and >> are not paired on a
line, they are treated as ordinary << and >> characters.

Here is a typical example of the body text within an \@root tree::

    @ This method puts an open node sentinel for node v.
    <<atFile methods>>=
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The example adds a part consisting of a documentation line and six lines of code
to the <<atFile methods>> code section. Elsewhere within the \@root tree,
other parts may be added to the <<atFile methods>> definition.

If we have a node with a headline starting with <<atFile methods>>, an
equivalent to the example above is::

    @ This method puts an open node sentinel for node v.
    @c
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

If we convert the doc part to a comment we have::

    @c
    # This method puts an open node sentinel for node v.
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The following escape convention applies only in @root trees. Within a code part
\@@@ in the first column (and only in the first column) stands for a single
\@ sign.
.. @+node:sps.20100712151944.7259: *3* Using @root trees
This section discusses \@root trees. Every code sction in an \@root tree must be
part of t \@root directives must appear in body text, not headlines (though this
may change in the future).

You should carefully consider whether the extra flexibility afforded by \@root
trees is worth the extra bother; \@<file> trees are typically easier to use than
\@root trees, for the following reasons:

- \@<file> trees use less markup than \@root trees, since every code section
  must be explicitly named explicitly placed by name. In particular, the
  \@others directive is valid only within \@<file> trees.

- You must explicitly tangle and untangle \@root trees using tangle and untangle
  commands.

However, \@root trees are more flexible than \@<file> trees:

- Sections may be defined anywhere within \@root trees.

- The \@unit directive can expand the scope of section definitions to all
  descendant \@root trees so that a section may be referenced in several \@root
  trees.

- Sections definitions may be extended by multiple nodes within the governing
  scope; in the external file, the corresponding parts appear in the outline
  order of the appearance of the multiple section definitions.

- Multiple sections may be defined within a single node, so if a concept
  requires implementation in multiple files or multiple locations within a file,
  it can still be presented in a coherent unit.

- The meaning of section definitions in \@root trees are independent of their
  position within the tree, except for the influence of ancestor \@language and
  \@comment directives.
.. @+node:sps.20100712151944.7220: *4* \@root
The \@root directive specifies the name of a file to create. The remaining
lines of the node body, until the next section definition or \@ doc part
specify the contents of the file. Normally, there is a combination of literal
text and section references. The sections referenced must be defined either
within the node body (not recommended), within a descendant node body, or within
the descendants of an (optional) ancesetor \@unit directive.
.. @+node:sps.20100712151944.7222: *4* \@root-code and @root-doc
Leo allows you to choose whether body text in \@root trees will start in code
mode or doc mode by default. The \@root-doc *filename* and \@root-code
*filename* directives specify that body text is assumed to start in doc mode or
code mode respectively. The options (-doc and -code) must follow @root
immediately with no intervening whitespace. In effect, @root-code and @root-doc
are two new directives.

These \@root options override the \@bool at_root_bodies_start_in_doc_mode
setting, which affects only \@root trees without options. It is better style
to use the explicit \@root-code or \@root-doc directive, since the meaning
of plain \@root trees will depend on the \@bool
at_root_bodies_start_in_doc_mode setting. By default, \@bool
at_root_bodies_start_in_doc_mode = True for compatibility with earlier Leo
\@root trees. The distinction in whether to expect doc or code at the
beginning of a node applies only to descendants of the \@root node; the node
containing the \@root directive always effectively begins in doc mode.
.. @+node:sps.20100712151944.7226: *4* \<< named section >>, @c and @code
If the headline is of the form << *section* >>, the \@c directive
ends a doc part and begins a code part. Multiple parts may occur in the node;
each of the \@c will add another code part to the code section named in the
headline. If the headline does not contain a double angle bracketed section
name, attempts to tangle or untangle the \@root tree will generate an error.
\@code is a synonym for \@c, but \@c is preferred.
.. @+node:sps.20100712151944.7248: *4* @unit
The \@unit directive is placed as an ancestor to\@root trees so that a
section defined anywhere in its descendants may be referenced in any of its
descendant \@root trees. There is no equivalent for \@<file> trees.
.. @+node:sps.20100712151944.7250: *4* @verbose, @terse, @quiet and @silent
Whem the \@verbose, \@terse, \@quiet and \@silent directives appear
in body text, they determine how the tangle process puts comments in \@root
derived files. Comments written by the user in code sections (which must of
course use the native comment syntax) are always output. These directives
control only: a) the comments containing doc sections and b) sentinel comments
that delimit the beginning and end of code sections.

When \@verbose is in effect, the tangle process emits the sentinels necessary
for the untangle process. If \@bool print_doc_flag = True, the tangle process
also puts doc parts in the derived file as comments.

When \@quiet is in effect, the tangle process emits comments indicating
section names, **BUT** does not emit the section end comments necessary for the
untangle process. If \@bool print_doc_flag = True, the tangle process also
puts the doc parts in the derived file as comments.

When \@terse is in effect, tangle outputs only those comments necessary for
untangle to work; it *does not* emit doc parts, regardless of the value of
\@bool print_doc_flag.

When \@silent is in effect tangle adds no additional comments, does not emit
doc parts (regardless of \@bool print_doc_flag), and suppresses generation of
whitespace not explicitly present in section definitions.

\@verbose is the default. If more than one of these directives appear in the
same body text the "most verbose" of these options will be in effect.
.. @+node:sps.20100712151944.7261: *4* Tangling @root trees with the Tangle commands
Each \@root directive corresponds to an external file. **Tangling** is a
process of creating external files from \@<file> or \@root trees. Leo
tangles \@<file> trees automatically whenever an outline is saved. The user
must tangle \@root trees explicitly using one of the Tangle commands.

The tangle process for \@root directives is quite different from that for
\@<file> directives, reflecting the differing semantics of \@root
directives. Leo creates external files by expanding all section references in an
\@root node. Leo expands a section reference by substituting the code section
itself for the section reference. This is a recursive process: the substituted
code section may contain other code references which are themselves expanded,
and so on.

The outline provides a natural way of organizing by placing the definition of a
section S in a child of the node containing the reference to S. However, if a
section is referenced in more than one node, it may be placed in an ancestor of
all the nodes that refer to it. Usually these rules of thumb creates an outline
whose structure mirrors the intrinsic organization of a program. If not, use a
separate tree not containing \@root directives but containing clones of the
source code nodes along with organizing and documentation nodes to explain the
program files.

The Tangle command creates external files from an \@root node. The \@root
directive indicates which sections constitute an output file. The text following
an \@root directive forms the entire content of the file, that is, after
section references are expanded. An outline can contain arbitrarily many
\@root directives: Leo's tangle-all command will create one output file
for each. The process of creating external files is called "tangling" because
the code from the outline is rearranged to create the external files.

For example, the following @root section shows a typical way of specifying a
header file xx.h::

    @root xx.h
    #ifndef xx_defined
    #define xx_defined
    << declarations of public constants of the xx class >>
    << declarations of public types of the xx class >>
    << declarations of public variables of the xx class >>
    << public prototypes of the xx class >>
    #endif

The Tangle commands will create the file xx.h from this body text by expanding
all the section references. Any text preceding the \@root directive is
treated just like the doc part of a section definition and does not appear in
the external file.

As another example, the following shows a typical way of specifying the
corresponding xx.c file::

    @root xx.c
    << public variables of the xx class >>
    << private types of the xx class >>
    << private variables of the xx class >>
    << private function prototypes of the xx class >>
    << methods of the xx class >>

Three commands tangle an outline: tangle, tangle-all, and
tangle-marked; they appear in the File->Tangle submenu. These commands are
identical except for how much of the outline is tangled. tangle processes
only the selected portion of the outline; tangle-all processes the entire
outline, and tangle-marked processes only marked headlines.

The \@root directive has three forms. All three forms mean exactly the same
thing::

    @root filename
    @root "filename"
    @root <filename>

If *filename* is an absolute filename the location of the external file is
specified only by the filename. Otherwise, when \@root is given a relative
filename, the location of the external file is relative to:

1. the directory specified by \@path directives in parent nodes, or
2. the \@directory default_tangle_directory if no \@path directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.

The scope of a definition is the tree in which the definition is known. By
default, tangle commands look for section definitions only in the suboutline of
the \@root directive being tangled. That is, all sections are assumed to be
defined either in the body text of the node, say with headline *h*, containing
the \@root directive, or in the body texts of the descendants of *h*. The
\@unit directive explicitly indicates the scope of section definitions. When
a tangle command encounters the \@unit directive it treats the suboutline
containing the \@unit command as the scope for all enclosed roots. This
ensures that the group of roots in the subtree use the same section definitions.

For example, suppose we have a tree organized as follows with nodes indicated by
their body contents::

	+ @unit
		+ @root A
		    sections in A
		+ @root B
		    sections in B

The @unit directive ensures that only sections defined in the unit can affect
files A and B and that all sections definitions in A and B are compatible with
each other.

The tangle commands ignore any node (and its descendants) with a body containing an \@ignore
directive.  Use of the \@ignore directive allows trees to contain cloned nodes
or other subsidiary information without causing the tangle commands to issue spurious
error messages.  It also ensures that part of the outline does not contribute a section
definition to another part of the outline by mistake.
.. @+node:sps.20100712151944.7262: *4* Untangling @root trees with the Untangle commands
The untangle, untangle-all, and untangle-marked commands are the
reverse of the corresponding tangle commands. They are found in the
File->Untangle submenu. They update one or more \@root nodes based on changes
made to the corresponding external files.

For example, suppose you create a new part of the outline and tangle it for the
first time. When you compile the external files you may get syntax errors. You
could fix those errors in the outline and tangle the outline again, but you may
also fix the errors in the external files using the compiler's editor, then run
the untangle command on the part of the outline that created the external files.
The untangle command uses the sentinels in the external files to update the
outline to match the changes in the external files. The untangle command marks
all the nodes in the outline that it updates, so by doing unmark-all before
the untangle you can review all such nodes with the goto-next-marked command
(menu Outline->Go To...->Go To Next Marked).

You cannot use Untangle to update doc parts, since those are not present in the
external file.

Untangle does not change the structure of an outline; it never inserts, deletes
or moves nodes. Don't attempt to change the structure of an outline by modifying
external files; it won't work. Also, never delete, move or alter the sentinel
lines in external files written by the tangle command. Such lines start with the
comment delimiter followed by a section name, and are easily recognizable.

If you change the section name in a sentinel line untangle will not update the
code in the outline (with the old name) that generated the renamed section.
Untangle warns about sections that appear in an external file but not in the
outline. Untangle has no trouble with changed section references in external
files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for
untangle. Untangle will update all cloned nodes each time it is encounters the
code section referenced, so only the code in the last encountered referenced
section will take effect. Therefore, the safe way to update text in cloned nodes
is to make the change in the .leo file rather than the external files.
.. @+node:ekr.20100804133903.7261: *3* Special topics
.. @+node:sps.20100712151944.7185: *4* Controlling syntax coloring
.. index:: @color(r), @nocolor(r), @killcolor(r)

Syntax coloring is on by default in all body text. Leo formats comments and
documentation parts in red, directives and C keywords in blue, strings and
character constants in green and all other text in code parts in black. The
color directives are recognized only in the first column of the body text. The
\@nocolor directive disables syntax coloring for the lines of body text after
which it appears. No syntax coloring is done until an \@color directive
re-enables syntax coloring.

.. index:: Ambiguous node(r)

If a node contains neither the \@color nor the \@nocolor directive it may
inherit the syntax coloring attribute from an ancestor. The nearest ancestor
that contains exactly one of the \@color or \@nocolor directives will control
the syntax coloring. **Ambiguous nodes**, nodes containing both the \@color and
\@nocolor directives, never affect the coloring of their children.

.. index:: @nocolor-node(r)

The \@nocolor-node directive completely disables coloring for that node only,
taking precedence over other color directives that may be present. Descedant
nodes are not affected.

.. index:: @killcolor(r)

The \@killcolor directive completely disables the colorizer for that node and
its descendants, although \@killcolor may itself be overridden in descendant
nodes. The differences between \@killcolor and \@nocolor:

- \@nocolor suppresses coloring only until the next \@color directive.

- \@killcolor overrides \@nocolor and \@color directives. Any node
  containing \@killcolor is unambiguously an \@killcolor node regardless
  of whether that node also contains \@color or \@nocolor directives.

\@killcolor and \@nocolor-node differ in that the influence of
\@nocolor-node does not extend to descendant nodes, whereas \@killcolor
does influence descendant nodes.

Leo recognizes the color directives only in the first column of body text, not
in headlines. They have no effect on the tangle process.
.. @+node:sps.20100712151944.7191: *4* Perfect import checks
Leo performs several checks to ensure that the result of importing an external
file will be equivalent to the file that writing the \@auto tree would produce.

These checks can produces **errors** or **warnings**. Errors indicate a
potentially serious problem. Leo inserts an \@ignore directive in the \@auto
tree if any error is found. This \@ignore directive prevents the \@auto tree
from modifying the external file. If you remove or displace the \@ignore
directive, a later write of the \@auto tree will attempt to fix the problems
that gave rise to the errors. There are no guarantees however.

Before importing a file, Leo **regularizes** the leading whitespace of all lines
of the original source file. That is, Leo converts blanks to tabs or tabs to
blanks depending on the value of the \@tabwidth directive in effect for the
\@auto node. Leo also checks that the indentation of any non-blank line is not a
multiple of the indentation specified by the \@tabwidth directive in effect for
the \@auto node.

Leo cannot guarantee to reproduce the original source file exactly if problems
are discovered while regularizing leading whitespace. **Strict languages** are
languages such as Python for which leading whitespace must be preserved exactly
as it appears in the original source file. Problems during regularizing
whitespace generate errors for strict languages and warnings for non-strict
languages.

After importing a file, Leo verifies that writing the \@auto node would create
*exactly* the same file as the original file. Such file comparison mismatches
generate errors unless the problem involves only leading whitespace for
non-strict languages. Whenever a mismatch occurs the first non-matching line is
printed.

File comparison mismatches can arise for several reasons:

1. Bugs in the import parsers. Please report any suspected bugs immediately.

2. Underindented lines in classes, methods or function. An **underindented
   line** is a line that is indented less then the starting line of the class,
   method or function in which it appears. Leo outlines can not represent such
   lines exactly: every line of node implicitly has at least the indentation of
   any unindented line of the node.

Leo will issue a warning (not an error) for underindented Python comment lines.
Such lines can not change the meaning of Python programs.
.. @+node:ekr.20050828061501.43: *4* CWEB mode
See `CWEB`_ for a discussion of the CWEB language. CWEB mode refers to how Leo
tangles an outline when @language cweb is in effect or the cweb setting is in
effect. Leo treats *all* CWEB code in cweb mode as unevaluated text. That is,
Leo treats cweb control codes, including \@<...@>, \@<..@>=, \@c, \@, \@* and
\@** as "raw" text within cweb mode. Leo does *not* expand *cweb* section
references when writing external files in cweb mode. However, Leo *does* expand
*noweb* section references, so you may use noweb sections to organize cweb
files! You can create *noweb* code and doc sections using the @code and @doc
directives in place of @c and @ directives.

By default, cweb colors \@, \@* and \@** sections using the same syntax coloring
as for LaTeX. In addition, cweb colors C // and /*..*/ comments using LaTeX
coloring by default. You may change these defaults using the
color_cweb_doc_parts_with_latex and color_cweb_comments_with_latex settings.
.. @+node:sps.20100716120121.18083: *4* sentinels
Leo puts special comments into the derived files called *sentinels*. Their
purpose is to guide the untangle process as it incorporates changes made to the
external file into the Leo outline. If a node contains section definitions
destined for different files with different languages, you may need to change
comment conventions in the midst of a node. This is now possible by preceding a
section definition with an \@language or \@comment directive appropriate
to that section's syntax; the new syntax will remain in effect for the remainder
of the node and for all descendants until the next \@language or \@comment
directive. For example, one might have a node containing::

    @language java
    << invoke stored procedure normalize_time_period_limit >>=
    String sql = new StringBuilder()
                 .append("SELECT * FROM ")
                 .append("    normalize_time_period_limit(")
                 .append("        NULL::timestamp with time zone,")
                 .append("        NULL::timestamp with time zone)")
                 .tostring();
    statement.execute(sql);

    @ here's the definition of the stored procedure
    Taken from an example at
    http://www.postgresql.org/docs/8.1/interactive/sql-createfunction.html
    @language plsql
    @comment --_
    << normalize_time_period_limit >>=
    CREATE OR REPLACE FUNCTION normalize_time_period_limit(
        P_StartTime INOUT timestamp with time zone,
        P_EndTime INOUT timestamp with time zone)
    AS $$
    BEGIN
        P_StartTime = COALESCE(P_StartTime, (timestamp with time zone '1980-01-01 00:00:00.0+00'));
        P_EndTime = COALESCE(P_EndTime, current_timestamp);
    END;
    $$ LANGUAGE PLPGSQL;

In that example, the different section definitions are destined for different
files, and each begins and ends with the same comment convention. Sometimes one
needs to mix languages within a single file; for example, here is javascript
embedded in html::

    @language html
    <<head>>=
    <head>
        <title>Your Royal Magnificence</title>
        <script type="text/javascript"><!--
        <<initialize javascript>>
    </head>
    @
    End the head definition before starting the
    javascript section with the new comment convention
    @comment //
    <<initialize javascript>>=
        var img = "http://example.com/heraldry.jpg";
    --></script>
    @comment <!-- -->

Note that \@comment and \@language take effect in both doc and code parts,
and they apply from that point forward to the sentinels of the *defined*
section; they **DO NOT** apply to *referenced* sections: referenced sections
must be defined under the influence of \@comment or \@language directives
appropriate to the context in which they will be referenced. Note how the
javascript section in the example ends with an \@comment that prepares for
the transition back to html.

The \@comment and \@language directives do not appear in external files;
if untangle is applied to such files, the \@comment and \@language are
recovered into potentially modified code sections (doc sections do not change)
by placing them as the last line of the code section. The effect on sentinels is
the same regardless of where in the code section the \@comment or
\@language directive appear. An attempt to retain the former position within
the code would be ambiguous if the context around the directive changed. Putting
\@comment and \@language directives at the end of the code section will
lead to the fewest surprises. In doc sections, their position may be anything
that communicates clearly to the reader.
.. @+node:ekr.20100805001344.7250: *4* Using @comment
.. index:: @comment(r)

The \@comment directive sets comment delimiters in \@thin, \@file and \@shadow
files. **Important**: Use \@comment for unusual situations only. In most cases,
you should use the \@language directive to set comment delimiters.

\@language and \@comment may appear in the same node, provided that \@comment
appears *after* the \@language directive.

**Warning**: the \@comment and \@delims directives **must not** appear in the same node.
Doing so may create a file that Leo can not read.

However,
sometimes using both \@language and \@comment is useful. For this to be
effective the \@comment directive should appear after the \@language directive
(in outline order). In such cases \@comment overrides the comment delimiters
normally used by \@language. Even in this case, you will generally do better
combining \@language and \@delims.

\@comment controls the text used to designate comment strings in the external
file. By default, saving an \@thin style tree produces C-language comments.
Single-line comments generated during generation start with //, while
documentation parts are surrounded by /\* and \*/. The \@comment directive allows
you to work with source code for almost any programming languages.

The \@comment directive may be followed by zero to three delimiters, separated
by whitespace. This directive sets the single-line comment delimiter and the
opening and closing block comment delimiters as follows:

========================  =====================================================================
\@comment                 no args\: restores the defaults to //, /\* and \*/
------------------------  ---------------------------------------------------------------------
\@comment //              \1 arg\: sets the single-line comment and clears the other delims.
------------------------  ---------------------------------------------------------------------
\@comment /\* \*/         \2 args\: sets the block comment delims; clears the single-line delim.
------------------------  ---------------------------------------------------------------------
\@comment // /\* \*/      \3 args\: sets all three delimiters.
========================  =====================================================================

If only one delimiter is given, Leo uses it to begin each line of a recognized
documentation part (that is, one ungoverned by something like \@all).

If two delimiters are given, Leo uses block-style comments instead of
single-line comments. For example, \@comment { } could be used with Pascal
files.

The \@comment directive must precede the first section name or \@c directive.

Leo will convert underscores in the \@comment directives to significant spaces.
For example::

    @comment REM_

causes the comment delimiter to be "REM " (Note the trailing space). Leo
interprets a double underscore as a newline so that \@comment __=pod__
__=cut__ could support perl's POD facility.
.. @+node:ekr.20100805001344.7251: *4* Using @delims
The \@delims directive changes the comment strings used to mark sentinel lines
from that point forward in the body text. This directive is often used to place
Javascript text inside XML or HTML files.

**Warning**: the \@comment and \@delims directives **must not** appear in
the same node. Doing so may create a file that Leo can not read.

The \@delims directive contains one or two delimiters, separated by whitespace.
If only one delim is present it delimits single-line comments. If two delims are
present they delimit block comments. The \@delims directive can not be used to
change the comment strings at the start of the external file, that is, the
comment strings for the \@+leo sentinel and the initial \@+body and \@+node
sentinels.

The \@delims directive inserts \@@delims sentinels into the external file. The
new delimiter strings continue in effect until the next \@@delims sentinel in
the external file or the end of the external file.

**Note**: Leo can not revert to previous delimiters automatically; you must
change back to previous delimiters using another \@delims directive. For
example::

    @delims /* */
    Javascript stuff
    @delims <-- -->
    HTML stuff

Adding, deleting or changing \@delims sentinels will destroy Leo's ability to
read the external file. \@delims affects only external files, having no effect
on Leo's colorizer or internal data representation. Incorrect use will
thoroughly corrupt the external file as far as compilers, HTML renderers, etc.
are concerned. Do not mix \@delims with \@comment.
.. @+node:ekr.20100804133903.7260: *3* @rst-ignore-tree
.. @+node:ekr.20100804133903.7278: *4* Not used
.. @+node:sps.20100712151944.7128: *5* A Brief and Inaccurate History of Leo for Programming
Leo has an initially bewildering array of ways to turn outlines into external
files. This history, simplified to the point of inaccuracy, may help you decide
which of the varieties are appropriate to your project. For a better and more
detailed history, see the chapter `History of Leo`_.

The earliest variety of file generation was the @root directive, designed to
work with either `CWEB`_ or `noweb`_ markup. The model for CWEB and noweb were
for a person to edit a text ("web") file containing code and markup, and then
"tangle" the file into a source code file appropriate for the compiler or
interpreter, and to "weave" the text file into a beautifully typeset narrative
which explained all the inner workings of the code. Leo's innovation was to
realize that a lot of what the markup was doing was to expose the often hidden
conceptual structure of the code, and that this could be done better with an
outline. Thus in Leo, "tangling" creates the source files from the outline,
"weaving" is dropped, and "untangling" turns source files into outlines. That
last trick nearly always requires some assistance from the source file, in the
form of special comments called "sentinels" which help Leo discover the names of
outline headlines and the boundaries in the chunks of text (bodies)
corresponding to those headlines - and which chunks are subheads to other
subheads. As with CWEB and noweb, the specifications for how to assemble the
nodes into the program source code are explicit: << *section* >>
specifies the location where Leo emits the section, and << *section* >>=
*code* adds snippets of code to the end of the section definition.

Patterns in how @root trees were used suggested a different and easier way
of deriving code from the outline: @file. This directive occurs in the
headline. Instead of explicitly naming each section, one puts an @others
directive where Leo interpolates the otherwise unplaced child sections; if you
want a section put in a more specific place, specifying << *section* >>
will put it at that location in the body, and consequently require that
<< *section* >> appear as a child headline defining that section. The other
innovation with @file is what happens when Leo starts: there is an immediate
"untangle" of each \@file, thus incorporating changes from outside Leo into
Leo's model of the file. Correspondingly, when Leo exits, you're prompted to
"save" (tangle) any altered \@file (including alterations to child nodes).

The next innovation was \@thin. \@file created source code with sentinels
containing almost, but not all, of what was needed to recreate the outline for
the \@file. That same information was in the .leo file. Situations could
arise where that information was inconsistent, and created headaches. \@thin
was like \@file, except that *everything* needed to create the \@thin
outline goes into the sentinels, and *does not* go into the .leo file, thus
severely reducing opportunities for inconsistency. This has been so successful
that the old \@file directive now forcibly converts \@file derived source
code to \@thin style sentinels, and otherwise acts as a synonym for
\@thin. (Beware, however, if you use both pre-4.7 and 4.7 *et post* versions
of Leo with \@file: change each \@file headline to \@thin immediately,
otherwise the incompatible sentinels for \@file between the versions will be
most painful.)

If you look at source code managed with \@thin, the sentinels will stand
silently in their commented multitudes - which may be reassuring to the Leo
user, but appear to the non-Leo reader as a massive invasion. The sentinels are
almost necessary for pulling in changes from external files, but if those
sentinels are banished, any number of compromise approaches can be imagined -
and most of them seem to have been implemented. All these directives can appear
in a headline and create files without sentinels:


\@nosent
  writes files honoring the directives in the manner of \@thin, keeps copies
  of everything in the .leo file, and ignores changes introduced into the
  external file

\@shadow
  reads and writes two versions of each file, one without sentinels, and a
  hidden one with sentinels as if it were \@thin, then uses the sentinels in
  the hidden file to make sense of externally introduced changes to the
  unsentineled file

There are subtleties and crucial details to each of these external file
generation directives: read the descriptive sections carefully.
.. @+node:EKR.20040524104904.282: *5* Converting @root trees to @file trees
To convert an \@root tree to an \@file tree, choose the root of the tree to be
converted, then do the following in the Python window::

	import c2py
	c2py.leo1to2()

This script makes numerous changes throughout the tree. It does not, however,
change @root to @file, or insert the needed @others directives. You must do that
by hand.

To convert @root trees to @file trees by hand:

1. Change the @root node to an @file node. That is, delete the @root <filename>
    from the body text and insert @file <filename> in the headline. Typically,
    the root node contains a reference like <<methods of class x>> as the last
    body text. Replace this reference with the @others directive. The expansion
    of @others is all text that is not part of a section definition.

2. Add @ to the start of all doc parts. Leo starts syntax coloring in code mode
   rather than doc mode, so if a doc part starts body text it should start with
   an '@' sign.

3. Replace all section definition lines (like <<name>>=) by @c. This results in
   the node being added to the expansion of @others.

4. Remove all unused code from the @file tree. Leo does not write external files
   whose @file trees contain orphan or @ignore nodes.

5. Make sure that all nodes defining a section have a headline that starts with
   <<section>>. This will typically be true when converting @root trees that use
   the @code directive.

6. If a section is referenced in more than one node (a rare occurrence in my
    code), clone the defining node and move one clone under each referencing
    node.

7. If a node contains the definitions of several sections, place each different
   definition in a different node.
.. @+node:sps.20100712151944.7192: *5* Commands related to @auto
Three commands allow you to manually read and write \@auto nodes from the
presently selected outline. As always, an \@ignore directive in the \@auto
node or its ancestors will suppress any of these commands. Invokw the following
in the minibuffer with Alt-x:

- The read-at-auto-nodes command reads all \@auto nodes in the presently
  selected outline. An \@ignore directive will suppress this import.

- The write-at-auto-nodes command writes all \@auto nodes. An \@ignore
  directive will suppress this write.

- The write-dirty-at-auto-nodes is the same as the write-at-auto-nodes
  command, except that only changed \@auto trees are written.

Most users will rarely use these explicit commands, because reading and writing
.leo files handles \@auto nodes well enough. However, you can use the
read-at-auto-nodes command to update \@auto nodes changed outside of Leo
(e.g., by a text editor or version control system) without having to reload the
.leo file.
.. @+node:sps.20100712151944.7146: *4* Tree Walk Modifiers
With the exception of << *section* >>, these directives must appear in body text.

.. index:: Section reference(r)

- **<<** *section* **>>**
  In a node body, interpolates a named section; in a node headline, the body defines a named section.

.. index:: @ignore(r)

- **\@ignore**
  Causes Leo to skip conversion to and from all or part of an external file.

.. @+node:sps.20100712151944.7187: *4* \@<file> Directive Family
Here's an simple example using \@thin to create a file. The bodies of the
three nodes can be seen in the three screenshots:

|leoAtFileMainNode|
|leoAtFileFirstChild|
|leoAtFileNamedChild|

Saving the .leo file creates not only the .leo file but also creates the file
``/var/tmp/example.py`` containing the following text::

    #@+leo-ver=5-thin
    #@+node:sps.20100713093238.7252: * @thin /var/tmp/example.py
    #@@language python 
    #@+<<includes>>
    #@+node:sps.20100713093238.7253: ** <<includes>>
    import os
    #@-<<includes>>
    #@+others
    #@+node:sps.20100713093238.7254: ** first action
    print "Hello, world!"
    #@-others
    #@-leo
.. @+node:ekr.20100804133903.7262: *3* Directives reference
This section is a reference guide for all of Leo's directives, organized
alphabetically. Unless otherwise noted, directives must appear in the first
column of body text.

.. glossary::
    :sorted:
.. @+node:ekr.20100804133903.7275: *4* @rst-no-head All directives
.. index:: @(r), @doc(r)

\@ and \@doc
    The \@ directive starts a doc part. Doc parts continue until an \@c
    directive or the end of the body text. For example::

        @ This is a comment in a doc part.
        Doc parts can span multiple lines.
        The next line ends the doc part
        @c

    \@doc is a synonym for \@, but \@ is preferred.

    When writing external files, Leo writes doc parts as comments.

    Leo does not recognize \@ or \@doc in \@asis trees or when the \@all or
    \@delims directives are in effect. In those cases Leo simply writes what
    looks like the doc part to the file as is.

.. index:: @all(r)

\@all
    Copies *all* descendant nodes to the external file. Use \@all
    to place unrelated data in an external file.

    The \@all directive is valid only in the body of \@thin trees.

    Within the range of an \@all directive, Leo ignores the \@others directive
    and section references, so Leo will not complain about orphan nodes.

.. index:: @asis(r), @file-asis(r), @silent(r)
.. index:: @@ convention for headlines(r)

\@asis <filename>
    Use this directive only when you must have complete control over every
    character of the external file.  It is inconvenient to use.

    When writing \@asis nodes, writes the body text of all nodes in outline
    order. Leo writes the body text *as is*, without recognizing section
    definitions, without expanding section references, and without treating
    directives specially in any way. In particular, Leo copies all directives,
    including \@ or \@c directives, to the external file as text.

    **Important**: within \@asis trees only, if a headline starts with \@@, Leo
    writes everything in the headline following the \@@ just before the
    corresponding body text.

    Files created from \@asis trees contain *nothing* not contained in body text
    (or \@@ headlines). In particular, if body text does not end in a newline,
    the first line from the next node will concatenated to the last line of the
    preceding node.

    Leo writes no sentinels to the external file, so Leo can not update the
    outline using changes to the external file. When reading .leo files, Leo
    does *not* read external files created from \@asis nodes. Instead, all data
    in an \@asis tree is stored in the .leo file.

    Leo recognizes the \@ignore directive only in the *ancestors* of \@asis
    nodes. This allows you to use the \@ignore directive to prevent Leo from
    writing \@asis trees.

    This directive must appear in the node's headline.

    \@file-asis and \@silent are deprecated synonyms for \@asis.

.. index:: @auto(r), importer(r), organizer tag(r)

\@auto <filename>
    \@auto trees allow people to use Leo in collaborative environments without
    using sentinels in external files. Even without sentinels, \@auto trees can
    change when the corresponding external file changes outside of Leo.

    When reading \@auto nodes, Leo creates the \@auto tree using **importers**,
    parsers that create an outline with nodes for each class, method and
    function in the external file. Some importers create other kinds of nodes as
    well.

    Importers presently exist for C, elisp, HTML, Java, Javascript, Pascal, PHP,
    Python and xml. Leo determines the language using the file's extension. If
    no parser exists for a language, Leo copies the entire body of the external
    file into the \@auto node.

    **Note**: the \@data import_xml_tags setting specifies the **organizer
    tags** that cause the HTML and XML importers to create outline nodes. By
    default, the **organizer tags** are html, body, head, and div.

    When writing \@auto nodes, Leo writes the external file without sentinels.
    This allows you to use Leo in collaborative environments without disturbing
    colleagues. Leo does not expand section references when writing \@auto
    nodes: Leo genereates \@verbatim sentinels for lines that look like section
    references.

    This directive must appear in the node's headline.

.. index:: @c(r), @code(r)

\@c and \@code
    Ends any doc part and starts a code part.

    \@code is a deprecated synonym for \@.

    Leo does not recognize this directive in \@asis trees or when the
    \@all or \@raw directives are in effect.


.. index:: @chapter(r), @chapters(r)

\@chapter and \@chapter
    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

    These directives are too complex to describe here. For full details, see
    `Using Chapters`_.

    These directives must appear in the node's headline.

.. index:: @color(r)

\@color
    Enables syntax coloring until the next \@killcolor, \@nocolor or
    \@nocolor-node directive takes effect. **Note**: the \@killcolor directive
    disables all further syntax coloring in a node: \@killcolor overrides
    \@color within the node containing \@killcolor.

.. index:: @comment(r)

\@comment
    The \@comment directive sets comment delimiters in \@thin, \@file and
    \@shadow files. **Important**: Use \@comment for unusual situations only. In
    most cases, you should use the \@language directive to set comment
    delimiters.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    The \@comment directive is too complex to describe here.
    See `Using \@comment`_ below for full details.

.. index:: @delims(r)

\@delims
  Sets comment delimiters in \@thin, \@file and \@shadow trees.

  **Warning**: the \@comment and \@delims directives **must not** appear in
  the same node. Doing so may create a file that Leo can not read.

  The \@delims directive is too complex to describe here.
  See `Using \@delims`_ below for full details.

.. index:: @encoding(r)

\@encoding <encoding>
    The \@encoding directive specifies the Unicode encoding for an external file.
    For example::

        @encoding iso-8859-1

    When reading external files, the encoding given must match the encoding
    acutally used in the external file or "byte hash" will result.

.. index:: @edit(r)

\@edit <filename>
    When reading \@edit nodes, Leo reads the entire file into the \@edit node.
    Lines that look like sentinels will be read just as they are. When writing
    \@edit nodes, Leo writes expands section references, \@all and \@others just
    as with \@thin trees.  However, Leo writes no sentinels, so the structure
    created by sections references, \@all and \@others is not preserved.

    This directive must appear in the node's headline.

.. index:: @encoding(r)

\@encoding
    Sets the Unicode encoding used in external files.

.. index:: @endraw(r)

\@end_raw
    Ends a section of 'raw' text.

.. index:: @file(r), @thin(r)

\@file <filename>
    A synonym for \@thin.

    Prior to Leo 4.7, \@file worked differently from \@thin. However, this
    should not be a problem: Leo 4.7 can read external files written by Leo 4.6
    from \@file nodes.

    This directive must appear in the node's headline.

.. index:: @first(r)

\@first <text>
    The \@first directive allows you to place lines at the very start of an
    external file. Here is a typical example::

	    @first #! /usr/bin/env python

    If present, \@first lines must be the first lines in an \@<file> node.

    More than one \@first directive may exist, like this::

        @first #!/bin/sh -- # perl, to stop looping
        @first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
        @first     if 0;

\@ignore
    The \@ignore directive tells Leo to ignore the subtree in which it appears.

    In the body text of most top-level @<file> nodes, the \@ignore directive
    causes Leo now to write the tree. However, Leo ignores \@ignore directives
    in \@asis trees.

    Plugins and other parts of Leo sometimes @ignore for their own purposes. For
    example, Leo's unit testing commands will ignore trees containing @ignore.
    In such cases, the \@ignore directive may appear in the headline or body
    text.

.. index:: @last(r)

\@last <text>
    Forces lines to appear after the last sentinel of an external file.

.. index:: @language(r)

\@language <language name>
    The \@language directive specifies the comment delimiters.
    If no \@langue directive is in effect, Leo uses the defaults specified
    by the \@string target-language setting.

    A node may contain at most one \@language directive.

    The valid language names are:
    actionscript,ada,autohotkey, batch, c, config, cpp, csharp, 
    css, cweb, elisp, forth, fortran, fortran90, haskell, haxe, html,
    ini, java, javascript, kshell, latex, lua, noweb, pascal, perl,
    perlpod, php, plain, plsql, python, rapidq, rebol, rest, rst, ruby,
    shell, tcltk, tex, unknown, unknown_language, vim, vimoutline, xml, xslt.

    Shell files have comments that start with #.

    Case is ignored in the language names. For example, the following are
    equivalent::

        @language html
        @language HTML

    The \@language directive also specifies how the colorizer operates.
    For language x, the file leo/modes/x.py describes how to colorize the language.
    To see the languages presently supported, look in the leo/modes directory.
    There are over 100 such languges.

..  actionscript            ada95                   ahk                     antlr
..  apacheconf              apdl                    applescript             aspect_j
..  asp                     assembly_macro32        assembly_mcs51          assembly_parrot
..  assembly_r2000          assembly_x86            awk                     batch
..  bbj                     bcel                    bibtex                  b
..  chill                   cobol                   coldfusion              cplusplus
..  c                       csharp                  css                     cvs_commit
..  doxygen                 d                       dsssl                   eiffel
..  embperl                 erlang                  factor                  forth
..  fortran90               fortran                 foxpro                  freemarker
..  gettext                 groovy                  haskell                 haxe
..  hex                     html                    i4gl                    icon
..  idl                     inform                  ini                     inno_setup
..  interlis                io                      java                    javascript
..  jcl                     jhtml                   jmk                     jsp
..  latex                   lilypond                lisp                    lotos
..  lua                     mail                    makefile                maple
..  matlab                  ml                      modula3                 moin
..  mqsc                    netrexx                 nqc                     nsis2
..  objective_c             objectrexx              occam                   omnimark
..  pascal                  patch                   perl                    php
..  phpsection              pike                    pl1                     plain
..  plsql                   pop11                   postscript              povray
..  powerdynamo             progress                prolog                  props
..  pseudoplain             psp                     ptl                     pvwave
..  pyrex                   python                  rebol                   redcode
..  relax_ng_compact        rest                    rhtml                   rib
..  rpmspec                 r                       rtf                     ruby
..  rview                   sas                     scheme                  sdl_pr
..  sgml                    shell                   shellscript             shtml
..  smalltalk               smi_mib                 splus                   sqr
..  squidconf               ssharp                  svn_commit              swig
..  tcl                     texinfo                 tex                     text
..  tpl                     tsql                    uscript                 vbscript
..  velocity                verilog                 vhdl                    xml
..  xsl                     zpt

..  # run this node with Control-b to discover Leo's current list of languages
..  for lang in sorted(g.app.language_delims_dict.keys()):
..    g.es("    @language %s" % lang)

.. index:: @last(r)

\@last
    The \@last directive allows you to place lines at the very end of external
    files.  This directive must occur at the very end of top-level \@<file> nodes.
    More than one \@last directive may exist. For example::

        @first <?php
        ...
        @last ?>

    Leo does not recognize \@last directive in \@asis trees.

.. index:: @lineending(r)

\@lineending
    The \@lineending directive sets the line endings for individual external files.
    This directive overrides the \@string output_newline setting.

    The valid forms of the @lineending directive are:

    ========================   ======================================================
    \@lineending nl            The default, Linux.
    ------------------------   ------------------------------------------------------
    \@lineending cr            Mac
    ------------------------   ------------------------------------------------------
    \@lineending crlf          Windows
    ------------------------   ------------------------------------------------------
    \@lineending lf            Same as 'nl', not recommended
    ------------------------   ------------------------------------------------------
    \@lineending platform      Same as platform value for output_newline setting.
    ========================   ======================================================

.. index:: @nosent(r)

\@nosent <filename>
    When writing an \@nosent tree, Leo expands section references, \@all and
    \@others directives, but Leo writes no sentinels to the external file. Thus,
    Leo can not update \@nosent trees from changes made to the external file.

    When reading an outline, Leo does *not* read the external file. Instead, all
    the data in the \@nosent tree is stored in the .leo file.

    For these reasons, you should use \@nosent only as a last resort: \@auto or
    \@shadow are usually better choices if you can not tolerate sentinels in
    your external files.

    **Note**: The \@bool force_newlines_in_at_nosent_bodies setting controls
    whether Leo writes a trailing newline if non-empty body text does not end in
    a newline. The default is True.

    This directive must appear in the node's headline.

.. index:: @nowrap(r)

\@nowrap
    Disables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@nowrap may appear in either headlines or body text.

.. index:: @others(r)

\@others
    The \@others directive writes the body text of all descendant non-section definition
    nodes into the external file.  Nodes are written in outline order.

    Whitespace appearing before \@others directive itself adds to the indentation
    of all nodes added by the \@others directive.

    A single node may contain only one \@others directive, but descendant nodes
    may have other \@others directives.

    ..  If \@others occurs multiple times in the same node, all non-section nodes
    ..  appear at the location of the first instance of the \@others directive; the
    ..  remainder are remembered as sentinels but have no other content.

.. index:: @path(r)

\@path <path>
  Sets the path prefix for relative filenames for all descendant \@<file> directives.
  May appear either in body text or in headlines.

.. index:: @pagewidth(r)

\@pagewidth <n>
   Sets the page width used to break doc parts into lines.
   <n> should be a positive integer.  For example::

      @pagewidth 100

  The \@pagewidth directive overrides the \@int page_width setting.

.. index:: @quiet(r)

\@quiet
    This directive is valid only in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @raw(r)

\@raw
    The \@raw directive starts a section of "raw" text that ends *only* with the
    \@end_raw directive or the end of the body text containing the \@raw
    directive. Within this range, Leo ignores all section references and
    directives, and Leo generates no additional leading whitespace.

.. index:: @root(r), @root-code(r), @root-doc(r)
.. index:: @verbose(r), @terse(r), @quiet(r), @silent(r)

\@root
  Use this directive when you need to create different pieces of multiple files
  within a single node. This directive is the most flexible, the most difficult
  to use, and behaves differently from all other \@<file> directives. It comes
  closest in spirit to traditional literate programming tools.

  Using \@root trees is too complex to describe here. See `Using @root trees`_
  for full details.

  **Note**: The following directives have effect only within \@root trees:
  \@root-code, \@root-doc, \@unit, \@verbose, \@terse, \@quiet and \@silent.
  See `Using @root trees`_ for full details.

  This directive must appear in the node's headline.

.. index:: @shadow(r), private file(r), public file(r)

\@shadow <filename>
    When writing an \@shadow node, Leo writes *two* external files, a **public**
    file without sentinels, and a **private** file containing sentinels.

    When reading an \@shadow node, Leo uses a brilliant algorithm devised by
    Bernhard Mulder that compares the public and private files, and then updates
    the outline based on changes to the *public* file. In this way, \@shadow
    provides many of the benefits of \@thin trees without writing sentinels in
    the (public) external file.

    This directive must appear in the node's headline.

.. index:: @silent(r)

\@silent
    This directive is valid only in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @tabwidth(r), Negative tab width(r)

\@tabwidth
  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

.. index:: @terse(r)

\@terse
    This directive is valid only in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @thin(r)

\@thin <filename>
    \@thin creates an external file containing sentinels. When writing \@thin
    trees, Leo expands section references and \@all and \@others directives.

    When reading external files created by \@thin, the sentinels allow Leo to
    recreate all aspects of the outline. In particular, Leo can update the
    outline based on changes made to the file by another editor. 

    **Important**: \@thin is the recommended way to create and edit most files.
    Use \@thin unless you have a very good reason not to do so. In particular,
    using \@thin nodes is **highly recommended** when sharing external in a
    collaborative environment.

    This directive must appear in the node's headline.

.. index:: @unit(r)

\@unit
    This directive is valid only in \@root trees.
    See `Using @root trees`_ for full details.

\@verbose
    This directive is valid only in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @wrap(r)

\@wrap
    Enables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@wrap may appear in either headlines or body text.
.. @+node:ekr.20100805001344.7252: *4* @rst-ignore
.. @+node:sps.20100712151944.7196: *5* @path
\@path directives override the deprecated \@directory default_tangle_directory
setting.

The form is::

    @path <directory>

where directory is taken to be the first non-whitespace following \@path to
the end of the line.

When an external file directive such as \@thin specifies an absolute path,
no \@path or setting affects the external file name.
When an external file directive specifies a relative name,
Leo derives the directory to which that name is relative as follows:

1. the directory specified by \@path directives in parent nodes, or
2. the \@directory default_tangle_directory if no \@path directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

As parent nodes are examined beginning with the closest, Leo prepends relative
path components, and finishes when prepending an absolute path. In other words,
\@path directives specifying relative directory names are relative to their
parent nodes. If no \@path directive gives an absolute directory name, then the
topmost \@path is relative to either (2) or (3) in the list above.

An error occurs if no absolute path can be computed according to these rules,
or if the derived directory name does not exist.
.. @+node:sps.20100712151944.7242: *5* @path
\@path directives override the \@directory default_tangle_directory
setting.

\@path only influences \@root directives which specify a relative path for
their filename.

The form of the \@path directive is \@path *direcotryname*, where
*directoryname* is taken to be everything following \@path to the end of the
line. \@path may occur in both body text and headlines; only the first
occurrence in a node is effective effective, with the headline taking precedence
over the body. The \@path directive may occur in the same node with the
\@root directive.

If *directoryname* is an absolute path (e.g., beginning with C:\\ or /)
the location of the external file is specified only by that directory name and
any relative \@path directives intervening between the absolute name node and
the \@root directive. If *directoryname* is relative, the location of the
external file is relative to:

1. the directory specified by all applicable ancestor \@path directives, or
2. the \@directory default_tangle_directory, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules, or
if *filename* does not exist.

It is usually advisable to have the Leo outline parallel the file system
structure - which one hopes was chosen to be meaningful. Put the .leo file in
the topmost directory where it will be generating a file, and for all
subdirectories where it will be generating files, have an \@path directive in
a node for that subdirectory. For example (designating nodes by their
function)::

    + @root README
    + @root Makefile
    + @path include
        + @root azaza.h
    + @path a2z
        + @root a2z.c
        + @root a2z.h
    + @path z2a
        + @root z2a.c
        + @root z2a.h
    + @path lib
        + @root azaza.c
        + @path sublib
            + @root zazaz.c
            + @root zazaz.h

would correspond to the files::

    azaza.leo
    README
    Makefile
    include/azaza.h
    a2z/a2z.c
    a2z/a2z.h
    z2a/z2a.c
    z2a/z2a.h
    lib/azaza.c
    lib/sublib/zazaz.c
    lib/sublib/zazaz.h

If the conceptual structure does not follow the file system structure, use an
\@unit directive as a parent to all the \@root directives, then define the
named sections of the files in a structure beneath the \@unit directive that
*is* faithful to the concepts. Alternatively, one may use clones to pull out
nodes into sibling non-\@root trees that expose concepts, e.g., call-into or
call-out diagrams.
.. @+node:sps.20100712151944.7197: *5* @shadow
When writing an \@shadow tree, Leo writes *two* files, a **public** file without
sentinels, and a **private** file (by default in the .leo_shadow subfolder)
containing sentinels. The primary sources for \@shadow trees are the private
files, updated by changes to the public file.

When reading an \@shadow tree, Leo will import the tree from the public file
if the private file does not exist. Leo will not read (import) or write an
\@shadow tree if the \@shadow node or its parents contain an \@ignore
directive. \@ignore in the descendants of a node only affect the node
containing the \@ignore directive and the descendants of that node.

Leo can do an initial import of \@shadow trees by parsing the corresponding
public file, exactly as is done for \@auto node. See the discussion of `@auto reference`_ for details.
.. @+node:sps.20100712151944.7246: *5* @tabwidth
The \@tabwidth directive overrides the \@int tab_width setting. The form
of the \@tabwidth directive is \@tabwidth *n*, where the absolute value of
*n* is the width of tabs in spaces. For example::

    @tabwidth -4

Negative values cause Leo to convert tabs to spaces.
.. @+node:sps.20100712151944.7211: *5* @tabwidth
The \@tabwidth directive overrides the \@int tab_width setting.
The form of the \@tabwidth directive is \@tabwidth *n*,
where the absolute value of *n* is the width of tabs in spaces.
For example::

    @tabwidth -4

Negative values cause Leo to convert tabs to spaces.
.. @-all
.. @-leo
