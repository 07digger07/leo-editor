.. @+leo-ver=5-thin
.. @+node:ekr.20100805001344.7253: * @thin directives.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:ekr.20050828061213: ** @rst html/directives.html
#####################################
Chapter 4: Leo's Reference
#####################################
.. @+node:ekr.20050828160132: *3* @rst-no-head links
.. External links...
.. _`CWEB`:     http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`noweb`:    http://www.eecs.harvard.edu/~nr/noweb/

.. Links to other chapters
.. _front:                  front.html
.. _`Leo's tutorial`:       intro.html
.. _`Leo and reStructuredText`: rstplugin3.html
.. _`History of Leo`:       history.html
.. _`Using Chapters`:       outlines.html#using-chapters

.. Relative links...
..  .. _`@auto reference`:      `auto reference`_
..  .. _`@delims`:              `delims reference`_
..  .. _`@file reference`:      `file reference`_
..  .. _`@root Directive Family`:   `root reference`_


.. For reasons unknown, images must appear in the _images folder on the web site.
.. |leoAtFileMainNode| image:: screen-shots/leo-qt-at-file-main-node.JPG
.. |leoAtFileFirstChild| image:: screen-shots/leo-qt-at-file-first-child.JPG
.. |leoAtFileNamedChild| image:: screen-shots/leo-qt-at-file-named-child.JPG
.. @+node:ekr.20100804133903.7260: *3* @rst-ignore-tree
.. @+node:sps.20100712151944.7128: *4* A Brief and Inaccurate History of Leo for Programming
Leo has an initially bewildering array of ways to turn outlines into external
files. This history, simplified to the point of inaccuracy, may help you decide
which of the varieties are appropriate to your project. For a better and more
detailed history, see the chapter `History of Leo`_.

The earliest variety of file generation was the @root directive, designed to
work with either `CWEB`_ or `noweb`_ markup. The model for CWEB and noweb were
for a person to edit a text ("web") file containing code and markup, and then
"tangle" the file into a source code file appropriate for the compiler or
interpreter, and to "weave" the text file into a beautifully typeset narrative
which explained all the inner workings of the code. Leo's innovation was to
realize that a lot of what the markup was doing was to expose the often hidden
conceptual structure of the code, and that this could be done better with an
outline. Thus in Leo, "tangling" creates the source files from the outline,
"weaving" is dropped, and "untangling" turns source files into outlines. That
last trick nearly always requires some assistance from the source file, in the
form of special comments called "sentinels" which help Leo discover the names of
outline headlines and the boundaries in the chunks of text (bodies)
corresponding to those headlines - and which chunks are subheads to other
subheads. As with CWEB and noweb, the specifications for how to assemble the
nodes into the program source code are explicit: << *section* >>
specifies the location where Leo emits the section, and << *section* >>=
*code* adds snippets of code to the end of the section definition.

Patterns in how @root trees were used suggested a different and easier way
of deriving code from the outline: @file. This directive occurs in the
headline. Instead of explicitly naming each section, one puts an @others
directive where Leo interpolates the otherwise unplaced child sections; if you
want a section put in a more specific place, specifying << *section* >>
will put it at that location in the body, and consequently require that
<< *section* >> appear as a child headline defining that section. The other
innovation with @file is what happens when Leo starts: there is an immediate
"untangle" of each \@file, thus incorporating changes from outside Leo into
Leo's model of the file. Correspondingly, when Leo exits, you're prompted to
"save" (tangle) any altered \@file (including alterations to child nodes).

The next innovation was \@thin. \@file created source code with sentinels
containing almost, but not all, of what was needed to recreate the outline for
the \@file. That same information was in the .leo file. Situations could
arise where that information was inconsistent, and created headaches. \@thin
was like \@file, except that *everything* needed to create the \@thin
outline goes into the sentinels, and *does not* go into the .leo file, thus
severely reducing opportunities for inconsistency. This has been so successful
that the old \@file directive now forcibly converts \@file derived source
code to \@thin style sentinels, and otherwise acts as a synonym for
\@thin. (Beware, however, if you use both pre-4.7 and 4.7 *et post* versions
of Leo with \@file: change each \@file headline to \@thin immediately,
otherwise the incompatible sentinels for \@file between the versions will be
most painful.)

If you look at source code managed with \@thin, the sentinels will stand
silently in their commented multitudes - which may be reassuring to the Leo
user, but appear to the non-Leo reader as a massive invasion. The sentinels are
almost necessary for pulling in changes from external files, but if those
sentinels are banished, any number of compromise approaches can be imagined -
and most of them seem to have been implemented. All these directives can appear
in a headline and create files without sentinels:


\@nosent
  writes files honoring the directives in the manner of \@thin, keeps copies
  of everything in the .leo file, and ignores changes introduced into the
  external file

\@shadow
  reads and writes two versions of each file, a private without sentinels, and a
  hidden one with sentinels as if it were \@thin, then uses the sentinels in
  the hidden file to make sense of externally introduced changes to the
  private file

There are subtleties and crucial details to each of these external file
generation directives: read the descriptive sections carefully.
.. @+node:EKR.20040524104904.282: *4* Converting @root trees to @file trees
To convert an \@root tree to an \@file tree, choose the root of the tree to be
converted, then do the following in the Python window::

	import c2py
	c2py.leo1to2()

This script makes numerous changes throughout the tree. It does not, however,
change @root to @file, or insert the needed @others directives. You must do that
by hand.

To convert @root trees to @file trees by hand:

1. Change the @root node to an @file node. That is, delete the @root <filename>
    from the body text and insert @file <filename> in the headline. Typically,
    the root node contains a reference like <<methods of class x>> as the last
    body text. Replace this reference with the @others directive. The expansion
    of @others is all text that is not part of a section definition.

2. Add @ to the start of all doc parts. Leo starts syntax coloring in code mode
   rather than doc mode, so if a doc part starts body text it should start with
   an '@' sign.

3. Replace all section definition lines (like <<name>>=) by @c. This results in
   the node being added to the expansion of @others.

4. Remove all unused code from the @file tree. Leo does not write external files
   whose @file trees contain orphan or @ignore nodes.

5. Make sure that all nodes defining a section have a headline that starts with
   <<section>>. This will typically be true when converting @root trees that use
   the @code directive.

6. If a section is referenced in more than one node (a rare occurrence in my
    code), clone the defining node and move one clone under each referencing
    node.

7. If a node contains the definitions of several sections, place each different
   definition in a different node.
.. @+node:sps.20100712151944.7192: *4* Commands related to @auto
Three commands allow you to manually read and write \@auto nodes from the
presently selected outline. As always, an \@ignore directive in the \@auto
node or its ancestors will suppress any of these commands. Invoke the following
in the minibuffer with Alt-x:

- The read-at-auto-nodes command reads all \@auto nodes in the presently
  selected outline. An \@ignore directive will suppress this import.

- The write-at-auto-nodes command writes all \@auto nodes. An \@ignore
  directive will suppress this write.

- The write-dirty-at-auto-nodes is the same as the write-at-auto-nodes
  command, except that only changed \@auto trees are written.

Most users will rarely use these explicit commands, because reading and writing
.leo files handles \@auto nodes well enough. However, you can use the
read-at-auto-nodes command to update \@auto nodes changed outside of Leo
(e.g., by a text editor or version control system) without having to reload the
.leo file.
.. @+node:sps.20100712151944.7187: *4* \@<file> Directive Family
Here's an simple example using \@thin to create a file. The bodies of the
three nodes can be seen in the three screenshots:

|leoAtFileMainNode|
|leoAtFileFirstChild|
|leoAtFileNamedChild|

Saving the .leo file creates not only the .leo file but also creates the file
``/var/tmp/example.py`` containing the following text::

    #@+leo-ver=5-thin
    #@+node:sps.20100713093238.7252: * @thin /var/tmp/example.py
    #@@language python 
    #@+<<includes>>
    #@+node:sps.20100713093238.7253: ** <<includes>>
    import os
    #@-<<includes>>
    #@+others
    #@+node:sps.20100713093238.7254: ** first action
    print "Hello, world!"
    #@-others
    #@-leo
.. @+node:ekr.20100806072146.6929: *4* \@path
It is usually advisable to have the Leo outline parallel the file system
structure - which one hopes was chosen to be meaningful. Put the .leo file in
the topmost directory where it will be generating a file, and for all
subdirectories where it will be generating files, have an \@path directive in
a node for that subdirectory. For example (designating nodes by their
function)::

    + @root README
    + @root Makefile
    + @path include
        + @root azaza.h
    + @path a2z
        + @root a2z.c
        + @root a2z.h
    + @path z2a
        + @root z2a.c
        + @root z2a.h
    + @path lib
        + @root azaza.c
        + @path sublib
            + @root zazaz.c
            + @root zazaz.h

would correspond to the files::

    azaza.leo
    README
    Makefile
    include/azaza.h
    a2z/a2z.c
    a2z/a2z.h
    z2a/z2a.c
    z2a/z2a.h
    lib/azaza.c
    lib/sublib/zazaz.c
    lib/sublib/zazaz.h

If the conceptual structure does not follow the file system structure, use an
\@unit directive as a parent to all the \@root directives, then define the
named sections of the files in a structure beneath the \@unit directive that
*is* faithful to the concepts. Alternatively, one may use clones to pull out
nodes into sibling non-\@root trees that expose concepts, e.g., call-into or
call-out diagrams.
.. @+node:sps.20100716120121.18083: *4* sentinels
Leo puts special comments into the derived files called *sentinels*. Their
purpose is to guide the untangle process as it incorporates changes made to the
external file into the Leo outline. If a node contains section definitions
destined for different files with different languages, you may need to change
comment conventions in the midst of a node. This is now possible by preceding a
section definition with an \@language or \@comment directive appropriate
to that section's syntax; the new syntax will remain in effect for the remainder
of the node and for all descendants until the next \@language or \@comment
directive. For example, one might have a node containing::

    @language java
    << invoke stored procedure normalize_time_period_limit >>=
    String sql = new StringBuilder()
                 .append("SELECT * FROM ")
                 .append("    normalize_time_period_limit(")
                 .append("        NULL::timestamp with time zone,")
                 .append("        NULL::timestamp with time zone)")
                 .tostring();
    statement.execute(sql);

    @ here's the definition of the stored procedure
    Taken from an example at
    http://www.postgresql.org/docs/8.1/interactive/sql-createfunction.html
    @language plsql
    @comment --_
    << normalize_time_period_limit >>=
    CREATE OR REPLACE FUNCTION normalize_time_period_limit(
        P_StartTime INOUT timestamp with time zone,
        P_EndTime INOUT timestamp with time zone)
    AS $$
    BEGIN
        P_StartTime = COALESCE(P_StartTime, (timestamp with time zone '1980-01-01 00:00:00.0+00'));
        P_EndTime = COALESCE(P_EndTime, current_timestamp);
    END;
    $$ LANGUAGE PLPGSQL;

In that example, the different section definitions are destined for different
files, and each begins and ends with the same comment convention. Sometimes one
needs to mix languages within a single file; for example, here is javascript
embedded in html::

    @language html
    <<head>>=
    <head>
        <title>Your Royal Magnificence</title>
        <script type="text/javascript"><!--
        <<initialize javascript>>
    </head>
    @
    End the head definition before starting the
    javascript section with the new comment convention
    @comment //
    <<initialize javascript>>=
        var img = "http://example.com/heraldry.jpg";
    --></script>
    @comment <!-- -->

Note that \@comment and \@language take effect in both doc and code parts,
and they apply from that point forward to the sentinels of the *defined*
section; they **DO NOT** apply to *referenced* sections: referenced sections
must be defined under the influence of \@comment or \@language directives
appropriate to the context in which they will be referenced. Note how the
javascript section in the example ends with an \@comment that prepares for
the transition back to html.

The \@comment and \@language directives do not appear in external files;
if untangle is applied to such files, the \@comment and \@language are
recovered into potentially modified code sections (doc sections do not change)
by placing them as the last line of the code section. The effect on sentinels is
the same regardless of where in the code section the \@comment or
\@language directive appear. An attempt to retain the former position within
the code would be ambiguous if the context around the directive changed. Putting
\@comment and \@language directives at the end of the code section will
lead to the fewest surprises. In doc sections, their position may be anything
that communicates clearly to the reader.
.. @+node:ekr.20050828061501.1: *3* @rst-no-head Intro
This chapter is a reference for all of Leo's directives, organized by topic, and
further organized alphabetically with each top. This chapter also covers several
other topics.

This chapter does *not* teach how to use Leo.  It assumes you are *thoroughly*
familiar with `Leo's tutorial`_.
.. @+node:ekr.20100804133903.7262: *3* Directives
This section is a reference guide for all of Leo's directives, organized
alphabetically. Most directives must appear in body text, but directives
that create external files must appear in headlines.

.. glossary::
    :sorted:
.. @+node:ekr.20100804133903.7275: *4* @rst-no-head All directives
.. index:: @(Reference), @doc(Reference),Doc part(Reference)

\@ and \@doc
    These directives start a doc part. \@doc is a synonym for \@. Doc parts
    continue until an \@c directive or the end of the body text. For example::

        @ This is a comment in a doc part.
        Doc parts can span multiple lines.
        The next line ends the doc part
        @c

    When writing external files, Leo writes doc parts as comments.

    Leo does not recognize \@ or \@doc in \@asis trees or when the \@all or
    \@delims directives are in effect.

.. index:: @all(Reference)

\@all
    Copies *all* descendant nodes to the external file. Use \@all
    to place unrelated data in an external file.

    The \@all directive is valid only in the body of \@thin trees.

    Within the range of an \@all directive, Leo ignores the \@others directive
    and section references, so Leo will not complain about orphan nodes.

.. index:: @asis(Reference)
.. index:: @@ convention for headlines(Reference)

\@asis <filename>
    Creates an external file without sentinels and without any expansions.

    Use this directive only when you must have complete control over every
    character of the external file. When writing \@asis nodes, writes the body
    text of all nodes in outline order. Leo writes the body text *as is*,
    without recognizing section definitions, without expanding section
    references, and without treating directives specially in any way. In
    particular, Leo copies all directives, including \@ or \@c directives, to
    the external file as text.

    **The @@ convention in headlines**: Within \@asis trees only, if a headline
    starts with \@@, Leo writes everything in the headline following the \@@
    just before the corresponding body text.

    Files created from \@asis trees contain *nothing* not contained in body text
    (or \@@ headlines). In particular, if body text does not end in a newline,
    the first line from the next node will concatenated to the last line of the
    preceding node.

    Leo writes no sentinels to the external file, so Leo can not update the
    outline using changes to the external file. When reading .leo files, Leo
    does *not* read external files created from \@asis nodes. Instead, all data
    in an \@asis tree is stored in the .leo file.

    Leo recognizes the \@ignore directive only in the *ancestors* of \@asis
    nodes. This allows you to use the \@ignore directive to prevent Leo from
    writing \@asis trees.

    This directive must appear in the node's headline.

    \@file-asis and \@silent are deprecated synonyms for \@asis.

.. index:: @auto(Reference), importer(Reference), organizer tag(Reference)
.. index:: Strict language(Reference),Underindented line(Reference)

\@auto <filename>
    Imports an external file into a tree of nodes.

    \@auto trees allow people to use Leo in collaborative environments without
    using sentinels in external files. Even without sentinels, \@auto trees can
    change when the corresponding external file changes outside of Leo.

    When reading \@auto nodes, Leo creates the \@auto tree using **importers**,
    parsers that create an outline with nodes for each class, method and
    function in the external file. Some importers create other kinds of nodes as
    well.

    Importers presently exist for C, elisp, HTML, Java, Javascript, Pascal, PHP,
    Python and xml. Leo determines the language using the file's extension. If
    no parser exists for a language, Leo copies the entire body of the external
    file into the \@auto node.

    **Note**: the \@data import_xml_tags setting specifies the **organizer
    tags** that cause the HTML and XML importers to create outline nodes. By
    default, the **organizer tags** are html, body, head, and div.

    When writing \@auto nodes, Leo writes the external file without sentinels.
    This allows you to use Leo in collaborative environments without disturbing
    colleagues. Leo does not expand section references when writing \@auto
    nodes: Leo generates \@verbatim sentinels for lines that look like section
    references.

    This directive must appear in the node's headline.

    When importing files into \@auto trees, Leo performs several checks to
    ensure that writing the imported file will produce exactly the same file.
    These checks can produces **errors** or **warnings**. Errors indicate a
    potentially serious problem. Leo inserts an \@ignore directive in the \@auto
    tree if any error is found. This prevents the \@auto tree from modifying the
    external file.

    Before importing a file, Leo **regularizes** the leading whitespace of all
    lines of the original source file. That is, Leo converts blanks to tabs or
    tabs to blanks depending on the value of the \@tabwidth directive in effect
    for the \@auto node. Leo also checks that the indentation of any non-blank
    line is a multiple of the indentation specified by the \@tabwidth directive.
    **Strict languages** are languages such as Python for which leading
    whitespace must be preserved exactly as it appears in the original source
    file. Problems during regularizing whitespace generate errors for strict
    languages and warnings for non-strict languages.

    After importing a file, Leo verifies that writing the \@auto node would create
    the same file as the original file. Such file comparison mismatches
    generate errors unless the problem involves only leading whitespace for
    non-strict languages. Whenever a mismatch occurs the first non-matching line is
    printed.

    File comparison mismatches can arise for several reasons:

    1. Bugs in the import parsers. Please report any such bugs immediately.

    2. Underindented lines in classes, methods or function.

    An **underindented line** is a line that is indented less then the starting
    line of the class, method or function in which it appears. Leo outlines can
    not represent such lines exactly: every line of node will have, in the
    external file, at least the indentation of any unindented line of the node.
    Leo will issue a warning (not an error) for underindented Python comment
    lines. Such lines can not change the meaning of Python programs.

.. index:: @c(Reference), @code(Reference)

\@c and \@code
    Ends any doc part and starts a code part.

    \@code is a deprecated synonym for \@.

    Leo does not recognize this directive in \@asis trees or when the
    \@all or \@raw directives are in effect.

.. index:: @chapter(Reference), @chapters(Reference)

\@chapter and \@chapters
    An \@chapter tree represents a chapter. All @chapter nodes should be
    contained in an \@chapters node.

    These directives are too complex to describe here. For full details, see
    `Using Chapters`_.

    These directives must appear in the node's headline.

.. index:: @color(Reference)
.. index:: Ambiguous node(Reference),

\@color
    Enables syntax coloring until the next \@nocolor directive.

    The \@killcolor and \@nocolor-node directives override the \@color
    directive.

    An **ambiguous node** is a node containing both \@color and \@nocolor
    directives. Such a node has no effect on the syntax coloring of descendant
    nodes.

.. index:: @comment(Reference)

\@comment <1, 2 or three delimiters>
    Sets the comment delimiters in \@thin, \@file and \@shadow files.
    **Important**: Use \@comment for unusual situations only. In most cases, you
    should use the \@language directive to set comment delimiters.

    The \@comment directive may be followed by one, two or three delimiters,
    separated by whitespace. If one delimiter is given, it sets the delimiter
    used by single-line comments. If two delimiters are given, they set the
    block comment delimiter. If three delimiters are given, the first sets the
    single-line-comment delimiter, and the others set the block-comment
    delimiters.

    Within these delimiters, underscores represent a significant space, and
    double underscores represent a newline.  Examples::

        @comment REM_
        @comment __=pod__ __=cut__

    The second line sets PerlPod comment delimiters.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: \@language and \@comment may appear in the same node, provided that
    \@comment appears *after* the \@language directive: \@comment overrides
    \@language.

    The \@comment directive must precede the first section name or \@c directive.

..  ========================  =======================================================================
..  \@comment                 no args\: Restores the delims to the defaults given by \@language
..  ------------------------  -----------------------------------------------------------------------
..  \@comment //              \1 arg\: Sets the single-line comment delims. 
                                   ..  Clears the block comment delims.
..  ------------------------  -----------------------------------------------------------------------
..  \@comment /\* \*/         \2 args\: Sets the block comment delims.
                                    ..  Clears the single-line delim.
..  ------------------------  -----------------------------------------------------------------------
..  \@comment // /\* \*/      \3 args\: Sets all three delimiters.
..  ========================  =======================================================================

..  If only one delimiter is given, Leo uses it to begin each line of a recognized
..  documentation part (that is, one ungoverned by something like \@all).

..  If two delimiters are given, Leo uses block-style comments instead of
..  single-line comments. For example, \@comment { } could be used with Pascal
..  files.

.. index:: @delims(Reference)

\@delims <1 or 2 comment delimiters>
    Sets comment delimiters in external files containing sentinel lines.

    The \@delims directive requires one or two delimiters, separated by
    whitespace. If one delimiter is present it sets the single-line-comment
    delimiter. If two delimiters are present they set block comment delimiters.

    This directive is often used to place Javascript text inside XML or HTML
    files. Like this::

        @delims /* */
        Javascript stuff
        @delims <-- -->
        HTML stuff

    **Warning**: you **must** change back to previous delimiters using another
    \@delims directive. Failure to change back to the previous delimiters will
    thoroughly corrupt the external file as far as compilers, HTML renderers,
    etc. are concerned.  Leo does not do this automatically at the end of a node.

    **Warning**: the \@comment and \@delims directives **must not** appear in
    the same node. Doing so may create a file that Leo can not read.

    **Note**: The \@delims directive can not be used to change the comment
    strings at the start of the external file, that is, the comment strings for
    the \@+leo sentinel and the initial \@+body and \@+node sentinels.

.. index:: @edit(Reference)

\@edit <filename>
    Imports an external file into a single node.

    When reading \@edit nodes, Leo reads the entire file into the \@edit node.
    Lines that look like sentinels will be read just as they are. When writing
    \@edit nodes, Leo writes expands section references, \@all and \@others just
    as with \@thin trees. However, Leo writes no sentinels, so the structure
    created by sections references, \@all and \@others is not preserved.

    This directive must appear in the node's headline.

.. index:: @encoding(Reference)

\@encoding <encoding>
    Specifies the Unicode encoding for an external file. For example::

        @encoding iso-8859-1

    When reading external files, the encoding given must match the encoding
    actually used in the external file or "byte hash" will result.

.. index:: @end_raw(Reference)

\@end_raw
    Ends a section of 'raw' text that started with an \@raw directive.

.. index:: @file(Reference), @thin(Reference)

\@file <filename>
    A synonym for \@thin.

    Prior to Leo 4.7, \@file worked differently from \@thin. This should not be
    a problem: Leo 4.7 can read external all files written by Leo 4.6.

    This directive must appear in the node's headline.

.. index:: @first(Reference)

\@first <text>
    Places lines at the very start of an external file, before any Leo
    sentinels. \@first lines must be the very first lines in an \@<file> node.
    More then one \@first lines may appear.

    This creates two first lines, a shebang line and a Python encoding line::

	    @first #! /usr/bin/env python
        @first # -*- coding: utf-8 -*-

    Here is a perl example::

        @first #!/bin/sh -- # perl, to stop looping
        @first eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
        @first     if 0;

\@ignore
    Tells Leo to ignore the subtree in which it appears.

    In the body text of most top-level @<file> nodes, the \@ignore directive
    causes Leo not to write the tree. However, Leo ignores \@ignore directives
    in \@asis trees.

    Plugins and other parts of Leo sometimes @ignore for their own purposes. For
    example, Leo's unit testing commands will ignore trees containing @ignore.
    In such cases, the \@ignore directive may appear in the headline or body
    text.

.. index:: @killcolor

\@killcolor
    Disables syntax coloring in a node, regardless of other \@color,
    \@nocolor or \@nocolor-node directives in that node.

.. index:: @language(Reference)

\@language <language name>
    Specifies the language in effect, including comment delimiters.
    If no \@language directive is in effect, Leo uses the defaults specified
    by the \@string target-language setting.

    A node may contain at most one \@language directive.

    The valid language names are: actionscript,ada,autohotkey, batch, c, config,
    cpp, csharp, css, cweb, elisp, forth, fortran, fortran90, haskell, haxe,
    html, ini, java, javascript, kshell, latex, lua, noweb, pascal, perl,
    perlpod, php, plain, plsql, python, rapidq, rebol, rest, rst, ruby, shell,
    tcltk, tex, unknown, unknown_language, vim, vimoutline, xml, xslt.

    **Note**: Shell files have comments that start with #.

    Case is ignored in the language names. For example, the following are
    equivalent::

        @language html
        @language HTML

    The \@language directive also specifies how the colorizer operates.
    For language x, the file leo/modes/x.py describes how to colorize the language.
    To see the languages presently supported, look in the leo/modes directory.
    There are over 100 such languages.

..  actionscript            ada95                   ahk                     antlr
..  apacheconf              apdl                    applescript             aspect_j
..  asp                     assembly_macro32        assembly_mcs51          assembly_parrot
..  assembly_r2000          assembly_x86            awk                     batch
..  bbj                     bcel                    bibtex                  b
..  chill                   cobol                   coldfusion              cplusplus
..  c                       csharp                  css                     cvs_commit
..  doxygen                 d                       dsssl                   eiffel
..  embperl                 erlang                  factor                  forth
..  fortran90               fortran                 foxpro                  freemarker
..  gettext                 groovy                  haskell                 haxe
..  hex                     html                    i4gl                    icon
..  idl                     inform                  ini                     inno_setup
..  interlis                io                      java                    javascript
..  jcl                     jhtml                   jmk                     jsp
..  latex                   lilypond                lisp                    lotos
..  lua                     mail                    makefile                maple
..  matlab                  ml                      modula3                 moin
..  mqsc                    netrexx                 nqc                     nsis2
..  objective_c             objectrexx              occam                   omnimark
..  pascal                  patch                   perl                    php
..  phpsection              pike                    pl1                     plain
..  plsql                   pop11                   postscript              povray
..  powerdynamo             progress                prolog                  props
..  pseudoplain             psp                     ptl                     pvwave
..  pyrex                   python                  rebol                   redcode
..  relax_ng_compact        rest                    rhtml                   rib
..  rpmspec                 r                       rtf                     ruby
..  rview                   sas                     scheme                  sdl_pr
..  sgml                    shell                   shellscript             shtml
..  smalltalk               smi_mib                 splus                   sqr
..  squidconf               ssharp                  svn_commit              swig
..  tcl                     texinfo                 tex                     text
..  tpl                     tsql                    uscript                 vbscript
..  velocity                verilog                 vhdl                    xml
..  xsl                     zpt

..  # run this node with Control-b to discover Leo's current list of languages
..  for lang in sorted(g.app.language_delims_dict.keys()):
..    g.es("    @language %s" % lang)

.. index:: @last(Reference)

\@last <text>
    Places lines at the very end of external files.

    This directive must occur at the very end of top-level \@<file> nodes. More
    than one \@last directive may exist. For example::

        @first <?php
        ...
        @last ?>

    Leo does not recognize \@last directive in \@asis trees.

.. index:: @lineending(Reference)

\@lineending cr/lf/nl/crlf
    Sets the line endings for external files.
    This directive overrides the \@string output_newline setting.

    The valid forms of the @lineending directive are:

    ========================   ======================================================
    \@lineending nl            The default, Linux.
    ------------------------   ------------------------------------------------------
    \@lineending cr            Mac
    ------------------------   ------------------------------------------------------
    \@lineending crlf          Windows
    ------------------------   ------------------------------------------------------
    \@lineending lf            Same as 'nl', not recommended
    ------------------------   ------------------------------------------------------
    \@lineending platform      Same as platform value for output_newline setting.
    ========================   ======================================================

.. index:: @nocolor(Reference)

\@nocolor
    Disables syntax coloring until the next \@killcolor, \@nocolor or
    \@nocolor-node directive.

    The \@killcolor and \@nocolor-node override \@nocolor.

    Ambiguous nodes (nodes containing both \@color and \@nocolor directives)
    have no effect on the syntax coloring of descendant nodes.

.. index:: @nocolor-node(Reference)

\@nocolor-node
    The \@nocolor-node directive disables coloring for only the node containing it.

    The \@killcolor directive overrides the \@nocolor-node directive.

    The @nocolor-node directive overrides the \@color directive.

.. index:: @nosent(Reference)

\@nosent <filename>
    Creates an external file without sentinel lines.

    When writing an \@nosent tree, Leo expands section references, \@all and
    \@others directives, but Leo writes no sentinels to the external file. Thus,
    Leo can not update \@nosent trees from changes made to the external file.

    When reading an outline, Leo does *not* read the external file. Instead, all
    the data in the \@nosent tree is stored in the .leo file.

    This directive must appear in the node's headline.

    **Note**: \@auto or \@shadow are usually better choices than \@nosent for
    creating external files without sentinels.

    **Note**: The \@bool force_newlines_in_at_nosent_bodies setting controls
    whether Leo writes a trailing newline if non-empty body text does not end in
    a newline. The default is True.

.. index:: @nowrap(Reference)

\@nowrap
    Disables line wrapping the Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@nowrap may appear in either headlines or body text.

.. index:: @others(Reference)

\@others
    Writes the body text of all unnamed descendant into the external file, in
    outline order.

    Whitespace appearing before \@others directive adds to the indentation
    of all nodes added by the \@others directive.

    A single node may contain only one \@others directive, but descendant nodes
    may have other \@others directives.

..  If \@others occurs multiple times in the same node, all non-section nodes
..  appear at the location of the first instance of the \@others directive; the
..  remainder are remembered as sentinels but have no other content.

.. index:: @pagewidth(Reference)

\@pagewidth <n>
   Sets the page width used to break doc parts into lines.
   <n> should be a positive integer.  For example::

      @pagewidth 100

  The \@pagewidth directive overrides the \@int page_width setting.

.. index:: @path(Reference),Absolute path(Reference),Path prefix(Reference)

\@path <path>
   Sets the **path prefix** for relative filenames for all \@<file> tree.

   This directive may appear in headlines or body text, and may
   appear in top-level \@<file> nodes.

   The path is an **absolute path** if it begins with c:\\ or /,
   otherwise the path is a **relative** paths.

   Multiple \@path directives may contribute to the path prefix.
   Absolute paths overrides any ancestor \@path directives.
   Relative paths add to the path prefix.

   If no \@path directives are in effect, the default path prefix is
   the directory containing the .leo file.

   Within \@root trees, the default_tangle_directory setting is used
   as the default if it exists, otherwise the directory containing
   the .leo file is used as the default.

.. index:: @quiet(Reference)

\@quiet
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @raw(Reference)

\@raw
    Starts a section of "raw" text that ends *only* with the \@end_raw directive
    or the end of the body text containing the \@raw directive. Within this
    range, Leo ignores all section references and directives, and Leo generates
    no additional leading whitespace.

.. index:: @root(Reference), @root-code(Reference), @root-doc(Reference)
.. index:: @verbose(Reference), @terse(Reference), @quiet(Reference), @silent(Reference)

\@root
    Creates an external file using traditional literate programming techniques.

    This directive is the most flexible, the most difficult to use, and behaves
    differently from all other \@<file> directives.

    Using \@root trees is too complex to describe here. See `Using @root trees`_
    for full details.

    This directive must appear in the node's headline.

    **Note**: The following directives are valid only within \@root trees:
    \@quiet, \@root-code, \@root-doc, \@silent, \@terse, \@unit and \@verbose.

.. index:: @shadow(Reference), Private file(Reference), Public file(Reference)

\@shadow <filename>
    Creates *two* external files, a **public** file without sentinels, and a
    **private** file containing sentinels.

    When reading an \@shadow node, Leo uses a brilliant algorithm devised by
    Bernhard Mulder that compares the public and private files, and then updates
    the outline based on changes to the *public* file. In this way, \@shadow
    provides many of the benefits of \@thin trees without writing sentinels in
    the (public) external file.

    This directive must appear in the node's headline.

    Leo can do an initial import of \@shadow trees by parsing the corresponding
    public file, exactly as is done for \@auto nodes.

.. index:: @silent(Reference)

\@silent
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @tabwidth(Reference), Negative tab width(Reference)

\@tabwidth <n>
  Sets the width of tabs.
  Negative tab widths cause Leo to convert tabs to spaces.

.. index:: @terse(Reference)

\@terse
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @thin(Reference)

\@thin <filename>
    Creates an external file containing sentinels. When writing \@thin
    trees, Leo expands section references and \@all and \@others directives.

    When reading external files created by \@thin, the sentinels allow Leo to
    recreate all aspects of the outline. In particular, Leo can update the
    outline based on changes made to the file by another editor. 

    **Important**: \@thin is the recommended way to create and edit most files.
    Use \@thin unless you have a very good reason not to do so. In particular,
    using \@thin nodes is **highly recommended** when sharing external files in
    a collaborative environment.

    This directive must appear in the node's headline.

.. index:: @unit(Reference)

\@unit
    Expands the scope of definitions in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @verbose

\@verbose
    Sets the verbosity of sentinels in \@root trees.
    See `Using @root trees`_ for full details.

.. index:: @wrap(Reference)

\@wrap
    Enables line wrapping in Leo's body pane.

    Only the first \@wrap or \@nowrap directive in a node has any effect.

    \@wrap may appear in either headlines or body text.
.. @+node:ekr.20100804133903.7267: *3* Summary: creating external files
The following table summarizes the various ways of creating external files.

+---------+------------+------------------+-----------------+
|         | Sentinels  | Sections and     | Sections and    |
| Kind    | in external| @others expanded | @others created |
|         | files?     | on write?        | on read?        |
+---------+------------+------------------+-----------------+
| @asis   | no         | no               | no              |
+---------+------------+------------------+-----------------+
| @auto   | no         | yes              | yes             |
+---------+------------+------------------+-----------------+
| @edit   | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @nosent | no         | yes              | no              |
+---------+------------+------------------+-----------------+
| @shadow | Note 1     | yes              | yes             |
+---------+------------+------------------+-----------------+
| @file   | yes        | yes              | .leo file       |
| @thin   |            |                  | updated by      |
| Note 2  |            |                  | external file   |
+---------+------------+------------------+-----------------+

**Note 1**: \@shadow nodes create two files, a **public** file without sentinels
and a **private** file with sentinels.

**Note 2**: \@file and \@thin nodes are synonyms.
.. @+node:sps.20100712151944.7259: *3* Using @root trees
This section discusses \@root trees. \@<file> trees are typically easier to use
than \@root trees:

- \@<file> trees use less markup than \@root trees, since every code section
  must be explicitly named explicitly placed by name. In particular, the
  \@others directive is valid only within \@<file> trees.

- You must explicitly tangle and untangle \@root trees using tangle and untangle
  commands.

However, \@root trees are more flexible than \@<file> trees:

- Sections may be defined anywhere within \@root trees.

- The \@unit directive can expand the scope of section definitions to all
  descendant \@root trees so that a section may be referenced in several \@root
  trees.

- Sections definitions may be extended by multiple nodes within the governing
  scope; in the external file, the corresponding parts appear in the outline
  order of the appearance of the multiple section definitions.

- Multiple sections may be defined within a single node, so if a concept
  requires implementation in multiple files or multiple locations within a file,
  it can still be presented in a coherent unit.

- The meaning of section definitions in \@root trees are independent of their
  position within the tree, except for the influence of ancestor \@language and
  \@comment directives.
.. @+node:sps.20100712151944.7220: *4* \@root
.. index:: @root(Reference)

The \@root directive specifies the name of a file to create.

The body text of the @\root node specifies the contents of the file after all
section references in the \@root node have been expanded in the process
described below.

The \@root directive has three forms. All three forms mean exactly the same
thing::

    @root filename
    @root "filename"
    @root <filename>

If *filename* is an absolute filename the location of the external file is
specified only by the filename. Otherwise, when \@root is given a relative
filename, the location of the external file is relative to:

1. the directory specified by \@path directives in parent nodes, or
2. the \@directory default_tangle_directory if no \@path directive is in effect, or
3. the directory in which the .leo file resides if the .leo file has ever been saved.

An error occurs if no absolute path can be computed according to these rules,
or if the filename or directory does not exist.
.. @+node:sps.20100712151944.7222: *4* \@root-code and @root-doc
.. index:: @root-code(Reference), @root-doc(Reference)

By default, body text in \@root root trees start in doc mode (see below) if the
\@bool at_root_bodies_start_in_doc_mode setting is True. You may override this
setting explicitly by using \@root-code or \@root-doc instead of \@root. It is
good style to use \@root-code or \@root-doc directive, because the meaning of
\@root trees depends on value of this setting.
.. @+node:ekr.20100806072146.4421: *4* Code and doc parts
.. index:: Code part(Reference), Doc part(Reference)

Within \@root trees, body text is split into zero or more code and doc parts.
**Code parts** start with \@c or section definition lines (see below). **Doc parts**
start with \@. Parts continue until the start of another part or until the end
of the body text.

.. index:: Named code section(Reference)

The \@c directive starts a **named code section**.  The \@c directive is
invalid unless the node's headline looks a section reference.  That is
the nodes' headline should look like::

    << a section >>
.. @+node:sps.20100712151944.7260: *4* Sections and section references
.. index:: Section definition line(Reference)

**Section definition lines** are lines in body text of the form::

	<< section name>>=

(note the equal sign). At least one non-blank line must follow this line; empty
sections generate an error and prevent any update to the external file.

Section definition lines start named code parts. Within an \@root tree, named
code parts may be defined in more than one place. The definition of a named code
part is the concatenation of all code parts with the same name.

Section references in \@root trees have the same form and meaning as in all other \@<file> trees.

Here is a typical example of the body text within an \@root tree::

    @ This method puts an open node sentinel for node v.
    <<atFile methods>>=
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The example creates or adds to the <<atFile methods>> code section.

If the node's headline starts with <<atFile methods>>, the following
is equivalent to the example above::

    @ This method puts an open node sentinel for node v.
    @c
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

If we convert the doc part to a comment we have::

    @c
    # This method puts an open node sentinel for node v.
    def putOpenNodeSentinel(self,v):
        if v.isAtFileNode() and v != self.root:
            << issue an error message >>
        else:
            s = self.nodeSentinelText(v)
            self.putSentinel("@+node:" + s)

The following escape convention applies only in @root trees. Within a code part.
\@@@ in the first column (and only in the first column) stands for a single
\@ sign.

It is natural to place the definition of a section S in a child of the node
containing the reference to S. However, if a section is referenced in more than
one node, you may place its definition in an ancestor of all the nodes that
refer to it. Here is a typical way of specifying a header file xx.h::

    @root xx.h
    #ifndef xx_defined
    #define xx_defined
    << declarations of public constants of the xx class >>
    << declarations of public types of the xx class >>
    << declarations of public variables of the xx class >>
    << public prototypes of the xx class >>
    #endif

The Tangle commands will create the file xx.h from this body text by expanding
all the section references. Any text preceding the \@root directive is
treated just like the doc part of a section definition and does not appear in
the external file.

Here is the typical way of specifying the corresponding xx.c file::

    @root xx.c
    << public variables of the xx class >>
    << private types of the xx class >>
    << private variables of the xx class >>
    << private function prototypes of the xx class >>
    << methods of the xx class >>

.. index:: Scope(Reference)

The **scope** of a definition is the tree in which the definition is known. By
default, tangle commands look for section definitions only in the the \@root
tree being tangled. That is, all sections are assumed to be defined either in
the body text of a node, or in the body text of a descendants of the node.

.. index:: @unit

The \@unit directive expands the scope of section definitions in \@root nodes.
Within the \@unit tree, sections defined in any \@root node are available to
within all other \@root trees.

For example, suppose we have a tree organized as follows with nodes indicated by
their body contents::

	+ @unit
		+ @root A
		    sections in A
		+ @root B
		    sections in B

All sections defined in A are available in B, and vice versa.
.. @+node:sps.20100712151944.7261: *4* Tangling
.. index:: Tangling

**Tangling** is the process of creating external files from \@root trees. This
process is called "tangling" because tangling rearranges the text of the \@root
tree to form the external file. You must tangle \@root trees explicitly using
one of Leo's Tangle commands.

Tangling starts at the top-level \@root node. Tangling create the contents of
the external file after tangling by expanding all section references in the
top-level \@root node.

Tangling expands a section reference by substituting the code section itself for
the section reference. Tangling is a recursive process. That is, the substituted
code section may contain other code references which are themselves expanded,
and so on.

Three commands tangle an outline: tangle, tangle-all, and tangle-marked; they
appear in the File->Tangle submenu. The tangle command tangles only \@root nodes
the selected tree. The tangle-all command tangles all \@root nodes in the entire
outline. The tangle-marked command tangles all marked \@root nodes in the entire
outline.

The tangle commands ignore any tree whose top-level node contains an \@ignore
directive.  This allows \@root trees to contain data that will not appear
in the tangled external files.
.. @+node:sps.20100712151944.7262: *4* Untangling
.. index:: Untangling(Reference)
.. index:: untangle (command)(Reference)
.. index:: untangle-all(Reference),untangle-marked(Reference)

Untangling is the reverse of tangling.  Tangling updates \@root nodes
based on changes made outside of Leo to the corresponding external files.

The untangle, untangle-all, and untangle-marked commands untangle external
files. These commands are found in the File->Untangle submenu. They update one
or more \@root nodes based on changes made to the corresponding external files.

For example, suppose you create a new part of the outline and tangle it for the
first time. When you compile the external files you may get syntax errors. You
could fix those errors in the outline and tangle the outline again, but you may
also fix the errors in the external files using the compiler's editor, then run
the untangle command on the part of the outline that created the external files.
The untangle command uses the sentinels in the external files to update the
outline to match the changes in the external files. The untangle command marks
all the nodes in the outline that it updates, so by doing unmark-all before
the untangle you can review all such nodes with the goto-next-marked command
(menu Outline->Go To...->Go To Next Marked).

You cannot use Untangle to update doc parts, since those are not present in the
external file.

Untangle does not change the structure of an outline; it never inserts, deletes
or moves nodes. Don't attempt to change the structure of an outline by modifying
external files; it won't work. Also, never delete, move or alter the sentinel
lines in external files written by the tangle command. Such lines start with the
comment delimiter followed by a section name, and are easily recognizable.

If you change the section name in a sentinel line, untangle will not update the
code in the outline (with the old name) that generated the renamed section.
Untangle warns about sections that appear in an external file but not in the
outline. Untangle has no trouble with changed section references in external
files; it is only changed sentinel lines that cause problems.

Cloned nodes that generate code in several files may cause problems for
untangle. Untangle will update all cloned nodes each time it is encounters the
code section referenced, so only the code in the last encountered referenced
section will take effect. Therefore, the safe way to update text in cloned nodes
is to make the change in the .leo file rather than the external files.
.. @+node:sps.20100712151944.7250: *4* @verbose, @terse, @quiet and @silent
When the \@verbose, \@terse, \@quiet and \@silent directives determine how the
tangle process puts comments in \@root derived files. These directives control
only: a) the comments containing doc sections and b) sentinel comments that
delimit the beginning and end of code sections. Program comments in code section
are output as they are.

When \@verbose is in effect, the tangle process emits the sentinels necessary
for the untangle process. If \@bool print_doc_flag = True, the tangle process
also puts doc parts in the derived file as comments.

When \@quiet is in effect, the tangle process emits comments indicating section
names, but *not* the section end comments necessary for the untangle process. If
\@bool print_doc_flag = True, the tangle process also puts the doc parts in the
derived file as comments.

When \@terse is in effect, tangle outputs only those comments necessary for
untangle to work; it emits doc parts, regardless of the value of \@bool
print_doc_flag.

When \@silent is in effect tangle adds no additional comments, does not emit
doc parts (regardless of \@bool print_doc_flag), and suppresses generation of
whitespace not explicitly present in section definitions.

\@verbose is the default. If more than one of these directives appear in the
same body text the "most verbose" of these options will be in effect.
.. @+node:ekr.20050828061501.43: *4* CWEB mode
CWEB mode gives support for the `CWEB`_ language in \@root trees. CWEB mode is
in effect only in \@root trees where @language cweb is in effect.

In CWEB mode, Leo treats *all* CWEB code as unevaluated text. That is, Leo
treats cweb control codes, including \@<...@>, \@<..@>=, \@c, \@, \@* and \@**
as "raw" text.

In CWEB mode, Leo does *not* expand *CWEB* section references when writing
external files. However, Leo *does* expand *noweb* section references, so you
may use noweb sections to organize cweb files! You can create *noweb* code and
doc sections using the @code and @doc directives in place of \@c and \@
directives.

In CWEB mode, Leo colors \@, \@* and \@** sections using the same syntax
coloring as for LaTeX. In addition, Leo colors C comments using LaTeX coloring.
You may change these defaults using the color_cweb_doc_parts_with_latex and
color_cweb_comments_with_latex settings.
.. @-all
.. @-leo
