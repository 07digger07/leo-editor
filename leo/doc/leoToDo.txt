#@+leo-ver=5-thin
#@+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
#@+all
#@+node:ekr.20110520051220.18187: ** To do: 4.9 a1/b1
#@+node:ekr.20110517093705.14575: *3* Before a1
# As many as possible before the first release(a1).
# All must be fixed before the second release(b1)


#@+node:ekr.20110522203356.18250: *4* * Bug 760531:Spurious "x has been modified outside of Leo. Overwrite this file?"
@nocolor-node

High-priority bug

https://bugs.launchpad.net/leo-editor/+bug/760531

Ville:
    
I get this error way too often compared to the amount of cases when
it's actually useful (I think Leo uses wrong logic here, but didn't
check): 

=====

Matt Wilkie

I don't know if it's related, but I get warning about overwriting an
existing file when I create a new @file node and the file does not
already exist (leo is creating the file):

1. insert node, edit headline to "@file deleteme.py"
2. [ctrl]-[s]
3. add some text to "@file deleteme.py" body pane
4. [ctrl]-[s], message pops up:

---------------------------
Overwrite existing file?
#@+node:ekr.20110522203356.18251: *4* * Bug 735938:file assosiasion crash
@nocolor-node

High priority

https://bugs.launchpad.net/leo-editor/+bug/735938

Yesterday I installed the new version of leo. I changed the path to leo and
wanted to associate .leo file with leo. I ran the commands:

> ftype LeoFile=C:\Python26\python.exe "C:\Python26\Lib\site-packages\leo\launchLeo.py" "%*"
> assoc .leo=LeoFile

But when I tried to start .leo file from console it gave me an error:

-------------------------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 3497, in
 os_path_dirname
    path = g.toUnicodeFileEncoding(path)
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 3727, in
 toUnicodeFileEncoding
    if path: path = path.replace('\\', os.sep)
AttributeError: 'tuple' object has no attribute 'replace'

--------------------------------------------------------------------------------------
I added pprint.pprint(path) before the erroneous code. It printed many strings, but at the end
gave this:

u'C:\\Python26\\Lib\\site-packages\\leo\\leo\\config\\.leoRecentFiles.txt'
u'C:\\Python26\\Lib\\site-packages\\leo\\leo\\config\\.leoRecentFiles.txt'
(None, None)

Seems to be that nasty tuple at the end.

After I tried adding the code:

if isinstance(path, str):
 if path: path = path.replace('\\', os.sep)

It gave a new error:
-------------------------------------------------------------------------------------
  File "C:\Python26\Lib\site-packages\leo\leo\core\leoGlobals.py", line 4730, in
 toUnicode
    s = f(s,encoding,'replace')
TypeError: coercing to Unicode: need string or buffer, tuple found
-------------------------------------------------------------------------------------

How did this tuple emerge?
#@+node:ekr.20110522203356.18252: *4* * Bug 568452:file local @settings ignored if file opened from command line with absolute path
@nocolor-node

High-priority bug

https://bugs.launchpad.net/leo-editor/+bug/568452

Given

  LEOPATH=/home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk
  HOME=/tmp python $LEOPATH/launchLeo.py foo/bar.leo

@settings in bar.leo are honored., but with

  HOME=/tmp python $LEOPATH/launchLeo.py /home/tbrown/Desktop/leotest/foo/bar.leo

(i.e. absolute path to same file), they're ignored.

(LEOPATH has nothing to do with anything here, just trying to make the example more clear)

==========================

Still seeing this, don't know why I thought it was fixed.

with the attached del.leo in $HOME/.leo

cd $HOME/.leo
python /home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk/launchLeo.py /home/tbrown/.leo/del.leo

-> icon bar is at top and running g.es(c.config.getString('qt-toolbar-location')) in 'test' node reports top

vs.

cd $HOME/.leo
python /home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk/launchLeo.py del.leo

-> icon bar is at left and running g.es(c.config.getString('qt-toolbar-location')) in 'test' node reports left

only difference is on the command line, '/home/tbrown/.leo/del.leo' vs. 'del.leo'

cd $HOME and '.leo/del.leo' also works, so it seems to be the absoluteness of the path which is making it not read the config.


====================

In case you don't know '2>&1', it means 'redirect stderr to the same
place as stdout'.

  python launchLeo.py del.leo >relative.log 2>&1

test script correctly reports 'left', tool bar correctly positioned

  python launchLeo.py $PWD/del.leo >absolute.log 2>&1

test script incorrectly reports 'top', tool bar incorrectly (although
consistently) positioned

md5sum *log

218398d7c0594365ba0589541a302ad0 absolute.log
218398d7c0594365ba0589541a302ad0 relative.log

So, absolute vs. relative makes no difference in the console output,
which is:

trunk> cat relative.log
*** isPython3: False
Leo 4.8 final, build 3752, November 26, 2010
Python 2.6.5, qt version 4.6.2
linux2
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/config/leoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/myLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/mothLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/del.leo
Warning: shortcut conflict for <Ctrl+O>
            leoscreen-run-text in all from register-command
                  open-outline in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+M>
               leoscreen-other in all from register-command
                          mark in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+P>
            leoscreen-get-line in all from register-command
        repeat-complex-command in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+B>
             quickmove_jump_to in all from register-command
                execute-script in all from leosettings.leo
createMenuEntries No inverse for makeallbuttonsherepermanent
createMenuEntries No inverse for clearallpermanentbuttonshere
wrote recent file: /home/tbrown/.leo/.leoRecentFiles.txt

The log pane is similar:

Leo Log Window
Leo 4.8 final, build 3752, November 26, 2010
Python 2.6.5, qt version 4.6.2
linux2
setting leoID from os.getenv('USER'): 'tbrown'
load dir: /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/core
global config dir: /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/config
home dir: /home/tbrown
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/leo/config/leoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/myLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.leo/mothLeoSettings.leo
reading settings in /mnt/usr1/usr1/home/tbrown/.gnome-desktop/Package/leo/bzr/leo.repo/trunk/del.leo
reading: /home/tbrown/Desktop/Package/leo/bzr/leo.repo/trunk/del.leo
local @command press-me
Warning: shortcut conflict for <Ctrl+O>
            leoscreen-run-text in all from register-command
                  open-outline in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+M>
               leoscreen-other in all from register-command
                          mark in all from leosettings.leo
Warning: shortcut conflict for <Ctrl+P>
            leoscreen-get-line in all from register-com...
#@+node:ekr.20110522203356.18253: *4* Do as many medium severity bugs as possible
@nocolor-node

Most should take an hour or less.

It may be good to fix *all* of these for the first release.  If so, it can be called b1.
#@+node:ekr.20110522203356.18256: *4* Do as many (before b1) bugs as possible
#@+node:ekr.20110522121957.18232: *4* Key binding problems
@nocolor-node

Shortcuts don't work in most Log frame tabs
https://bugs.launchpad.net/leo-editor/+bug/701261

    ** Make sure *all* widgets have bindings.
    *  Do we need c.idle_focus_helper?

PgUp/PgDown should scroll the body, not the tree
https://bugs.launchpad.net/leo-editor/+bug/394309 
#@+node:ekr.20110522121957.18233: *4* Auto-collapse option for viewrendered pane
@nocolor-node

viewrendered.py behaviour
https://bugs.launchpad.net/leo-editor/+bug/755206

*Option to have viewrendered plugins auto-collapse the pane
#@+node:ekr.20110520051220.18203: *4* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
#@+node:ekr.20110520051220.18199: *3* Before b1
# These must be fixed before the second release(b1).
#@+node:ekr.20110522203356.18255: *4* Bugs
#@+node:ekr.20090907080624.6081: *5* Fix bug: spell checker should check headlines
#@+node:ekr.20101021101942.6011: *5* Window size not honored when opened from menu
#@+node:ekr.20100223133351.5998: *5* show-invisibles doesn't work for blank lines
#@+node:ekr.20081208102356.1: *5* Threading colorizer doesn't handle multiple body editors
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5be7a099b299327e

> Tk only colorizes one body editor, and if you delete that editor it
> colorizes no editor.

Thanks for this report.  This is a problem, never noticed until now,
with the threading colorizer.  A workaround is to disable the
threading colorizer plugin. 
#@+node:ekr.20100522090453.5912: *5* Fix bugs with @verbatim, @raw and @end_raw
@nocolor-node

> In the @file family of derived files (@thin, @nosent, etc.)  (i.e.,
> not @root), you can prevent any interpretation of the immediately
> following line with the "@verbatim" directive

This is not true, although it might appear to be true.

There is an @verbatim *sentinel*, but no @verbatim *directive*.

For example, I have just verified that the following does not work:

@verbatim
<< undefined ref >>

@raw and @end_raw do work as described.

There appear to be several bugs in this area:

1. Leo probably should warn that @verbatim does not exist as a
directive, although technically Leo is supposed to write anything that
looks like a sentinel but isn't "verbatim".

2. Leo does appear to read @raw and @end_raw properly in @thin files,
but Leo improperly issues the (red) log message,
converting @file format in @thin test_verbatim_sentinel.py
#@+node:ekr.20110111100539.12257: *5* Fix end-of-line problem (MacOS)
# Apparently, ctrl-e is not passed to Leo at all.
#@+node:ekr.20110111100539.12258: *6* Report
@nocolor-node

http://mail.google.com/mail/#inbox/12c5646c646a90d2

I expect C-e to go to end-of-line, but C-e works as the next line.
Alt-x and check end-of-line and I get the following result.

I use Mac OS X 10.6.5, newest Leo, and Python/Qt.

Leo 4.8 rc1, build 3715, November 15, 2010
Python 2.6.1, qt version 4.7.0
darwin

I remember I could use C-e, but it doesn't work anymore even after I
reinstall the Leo.

As I explained in this post - http://groups.google.com/group/leo-editor/browse_thread/thread/1ee0b35b4f76c999
After having @bool swap_mac_keys = True, I can use C-e.

C-a move the cursor to the start of line, but C-e seems to move the
cursor the first of the next line, which is the end of last line + 1.
If the line is the final one, C-e moves the cursor to the end of line
as there's no next line.

#@+node:ekr.20100109094541.6232: *6* within lines
def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'start-line',extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    self.moveWithinLineHelper(event,'start-line',extend=True)

def endOfLine (self,event):
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    self.moveWithinLineHelper(event,'end-line',extend=False)

def endOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the end of the line.'''
    self.moveWithinLineHelper(event,'end-line',extend=True)
#@+node:ekr.20100109094541.6231: *6* moveWithinLineHelper
def moveWithinLineHelper (self,event,spot,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    # g.trace(hasattr(w,'leoMoveCursorHelper'))

    if hasattr(w,'leoMoveCursorHelper'):
        extend = extend or self.extendMode
        w.leoMoveCursorHelper(kind=spot,extend=extend)
        w.seeInsertPoint()
        c.frame.updateStatusLine()
    else:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i,j = g.getLine(s,ins)
        if spot == 'start-line':
            self.moveToHelper(event,i,extend=extend)
        elif spot == 'end-line':
            # if g.match(s,i-1,'\n'): i -= 1
            self.moveToHelper(event,j,extend=extend)
        else:
            g.trace('can not happen: bad spot: %s' % spot)
#@+node:ekr.20110522203356.18254: *4* New features
#@+node:ekr.20110522121957.18234: *5* fill-para doesn't respect setting from set-fill-column
@nocolor-node

fill-para doesn't respect setting from set-fill-column
https://bugs.launchpad.net/leo-editor/+bug/766747

#@+node:ekr.20101116100300.5827: *5* Write script file to temp file if @bool write_script_file is False
@nocolor-node

It's important that g.pdb get the sources for *all* Leo scripts.

Postings:

When @bool write_script_file is True the execute-script file uses
execfile (or its Python 3k equivalent) to execute scripts.

This allows g.pdb (or pudb) to know the text of Leo scripts!

I want to emphasize here how important this change is.  After 4.8 final I'll add code to use a temp file to hold sources if 
@bool write_script_file is False.

In the meantime, I strongly urge all script writers to set @bool write_script_file = True.

Depending on your installation, especially on *nix, the default location for the file may be a problem.  In that case, set
@string script_file_path to some convenient place, say in your home directory.
#@+node:ekr.20080806054207.3: *5* Auto scroll outline pane if headline would become invisible
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/76789df8aac08c70

When using leo as outliner, I often use only node headlines to write
down some data. If the headline string is too long, the cursor goes
beyond the visible area. When modifying a node headline, is it
possible to make leo to auto-scroll, so the cursor is always visible? 
#@+node:ekr.20110520051220.18189: ** 4.9 Maybe
#@+node:ekr.20110427135155.14306: *3* Add <attr> elements to .leo files
@language rest

- <attr> solves pickle problem.
#@+node:ekr.20110414065052.6100: *4* ** Treat gnx's as strings: don't parse them
http://mail.google.com/mail/#inbox/12f3d4950fbabeea
#@+node:ekr.20110421132230.6107: *4* File format
@language rest
@pagewidth 65

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
#@+node:ekr.20110419083918.6104: *4* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
#@+node:ekr.20110415173840.6098: *4* new uA's
#@+node:ekr.20040701065235.2: *5* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
#@+node:ekr.20080805071954.2: *5* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
#@+node:EKR.20040526202501: *5* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
#@+node:ekr.20090130114732.6: *5* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
#@+node:ekr.20110414164347.6082: *4* Reference for json stuff
#@+node:ekr.20031218072017.1997: *5* scanGnx
def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
#@+node:ekr.20060919104530: *5* Sax (reading)
#@+node:ekr.20090525144314.6526: *6* cleanSaxInputString
def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
#@+node:ekr.20060919110638.5: *6* fc.createSaxChildren & helpers
def createSaxChildren (self, sax_node, parent_v):

    c = self.c
    trace = False and not g.unitTesting # and c.shortFileName().find('small') > -1
    children = []

    for sax_child in sax_node.children:
        tnx = sax_child.tnx
        v = self.gnxDict.get(tnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.createSaxVnode(sax_child,parent_v,v=v)   
        else:
            v = self.createSaxVnode(sax_child,parent_v)
            self.createSaxChildren(sax_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace: g.trace(
            '*** added parent',parent_v,'to',child,
            'len(child.parents)',len(child.parents))

    return children
#@+node:ekr.20060919110638.7: *7* fc.createSaxVnode & helpers
def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') > -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
#@+node:ekr.20060919110638.8: *8* handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
#@+node:ekr.20061004053644: *8* handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
#@+node:ekr.20060919110638.2: *6* dumpSaxTree
def dumpSaxTree (self,root,dummy):

    if not root:
        g.pr('dumpSaxTree: empty tree')
        return
    if not dummy:
        root.dump()
    for child in root.children:
        self.dumpSaxTree(child,dummy=False)
#@+node:ekr.20061003093021: *6* getSaxUa
def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None


    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return val

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
#@+node:ekr.20060919110638.14: *6* parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
#@+node:ekr.20060919110638.3: *6* readSaxFile
def readSaxFile (self,theFile,fileName,silent,inClipboard,reassignIndices,s=None):

    dump = False and not g.unitTesting
    fc = self ; c = fc.c

    # Pass one: create the intermediate nodes.
    saxRoot = fc.parse_leo_file(theFile,fileName,
        silent=silent,inClipboard=inClipboard,s=s)

    if dump: fc.dumpSaxTree(saxRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    if saxRoot:
        parent_v = c.hiddenRootNode
        children = fc.createSaxChildren(saxRoot,parent_v)
        assert c.hiddenRootNode.children == children
        v = children and children[0] or None
        return v
    else:
        return None
#@+node:ekr.20060919110638.11: *6* resolveTnodeLists
def resolveTnodeLists (self):

    trace = False and not g.unitTesting
    c = self.c

    for p in c.all_unique_positions():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                v = self.gnxDict.get(index)
                if v:
                    if trace: g.trace(tnx,v)
                    result.append(v)
                else:
                    g.trace('*** No vnode for %s' % tnx)
            if result:
                p.v.tnodeList = result
                # g.trace('*** tnodeList for',p.h,result)
            delattr(p.v,'tempTnodeList')
#@+node:ekr.20080805132422.3: *6* resolveArchivedPosition  (New in Leo 4.5)
def resolveArchivedPosition(self,archivedPosition,root_v):

    '''Return a vnode corresponding to the archived position relative to root node root_v.'''

    def oops (message):
        if not g.app.unitTesting:
            g.es_print('bad archived position: %s' % (message),color='red')

    try:
        aList = [int(z) for z in archivedPosition.split('.')]
        aList.reverse()
    except Exception:
        return oops('"%s"' % archivedPosition)

    if not aList:
        return oops('empty')

    last_v = root_v
    n = aList.pop()
    if n != 0:
        return oops('root index="%s"' % n )

    while aList:
        n = aList.pop()
        children = last_v.children
        if n < len(children):
            last_v = children[n]
        else:
            return oops('bad index="%s", len(children)="%s"' % (n,len(children)))

    return last_v
#@+node:ekr.20060919110638.13: *6* setPositionsFromVnodes & helper (sax read)
def setPositionsFromVnodes (self):

    trace = False and not g.unitTesting
    c = self.c ; p = c.rootPosition()
    current,str_pos = None,None

    use_db = g.enableDB and c.mFileName
    if use_db:
        str_pos = c.cacher.getCachedStringPosition()

    if not str_pos:
        d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
        if d: str_pos = d.get('str_leo_pos')
        if trace: g.trace('from p.v.u',str_pos)

    if str_pos:
        current = self.archivedPositionToPosition(str_pos)

    c.setCurrentPosition(current or c.rootPosition())
#@+node:ekr.20061006104837.1: *7* archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    s = g.toUnicode(s) # 2011/02/25
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
#@+node:ekr.20090218115025.3: *4* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
#@+node:ekr.20071001052501: *3* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
#@+node:ekr.20110518103946.18179: *3* Add external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
#@+node:ekr.20080421140032.1: *3* Fix multiple controllers problem in all plugins
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/663e1f9d8e2d1c24
#@+node:ekr.20110514231951.14492: ** 4.9 Docs
#@+node:ekr.20110518082415.14439: *3* Document highlights of my workflow
@language rest

This thread will discuss the workflow I use to develop Leo. The intention is to
help present and potential developers use Leo effectively. This thread will be
pre-writing for a section of the users guide.

This is a continuation of the thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/4494324d21bd0bde/adf6d565c90e175c

Overview
=======

Here is the big picture:

* Develop in an outline containing all of Leo's source files. Close this outline
 rarely: this keeps the code I am using stable while I'm hacking the code.

* Test in a *separate* .leo file, say test.leo. In fact, I often test in a
  private file, ekr.leo, so that test.leo doesn't get continually updated on bzr
  with trivial changes.

These two points are covered in a bit more detail in the FAQ:

http://webpages.charter.net/edreamleo/FAQ.html#how-can-i-use-leo-to-develop-leo-itself

Additional tips:

A. Avoid using the mouse whenever possible.  For example, use alt-tab to switch between windows.

B. Always develop Leo in a console.  This allows me to see the output of g.trace.

Speaking of g.trace, I hardly ever use 'print' because g.trace prints the name
of the function or method in which it appears. The typical pattern for enabling
traces is:

    trace = True and not g.unitTesting
    if trace: g.trace(whatever)

This pattern is especially useful when a method contains multiple calls to g.trace.

C. I use scripts to open particular Leo files. These are batch files on Windows,
   and aliases on Linux, but invoking them is the same on either platform:

all: opens all my main development files using the qt-tabs gui: leoPy.leo,
     leoGuiPlugins.leo, leoPlugins.leo, leoSettings.leo, myLeoSettings.leo and
     LeoDocs.leo.

t: opens test.leo.

e: opens ekr.leo.  I use this file for private testing.

d: opens LeoDocs.leo.

s: opens LeoPy.leo.

plugins: opens leoPlugins.leo.

gui: opens leoGui.leo.

u: opens unitTest.leo.

These run Leo with Python 3.x. There are similar scripts, ending in 2, that run
Leo with Python 2.x. For example, u2 opens unitTest.leo with Python 2.x.

Similarly, the tk prefix uses the Tk gui: utk opens unitTest.leo with --gui=tk
(and Python 2.x since the tk gui only works with Python 2.x)

Thus, to run a test, I alt-tab to an available console window, then type 'e' or
't' or 'e2' or 't2'.

D. Use clones to focus attention on the task at hand.  For more details, see:

E.  For thousand of example of my programming style, see leoPy.leo and leoGuiPlugins.leo.

http://webpages.charter.net/edreamleo/intro.html#clones-views

The projects section in leoPy.leo contains many examples of using clones to
create view nodes. I typically delete the clones in the views shortly before a
release.

That's about all for code-level tips.  Here are some administrative tips:

A.  Use postings as pre-writing for documentation.

I don't mind blabbing on and on about Leo because all my posts become
pre-writing for Leo's documentation. I simply copy posts to nodes in the
"documentation to-do" section. At release time, I edit these nodes and put them
in Leo's main documentation or the release notes. This posting is an example.

B. Never rely on memory.

A project like this contains thousands and thousands of details. Everything
eventually goes into a Leo node somewhere. If it doesn't it surely *will* be
forgotten.

C. Do easy items first. This keeps to-do lists short, which in turn helps keep
energy high.


============================

> Do you also have any bzr specific gotchas that you plan to add to this
> section?

I use the following batch files related to bzr:

b: short for bzr
bs: short for bzr status
tr: short for cd <path to trunk>
main: short for cd <path to copy of trunk>

The "main" (copy) of the trunk is purely for handling bzr conflicts.
If one happens I do this:

main
b pull
b merge ../trunk
b c -m "my commit message"
b push

If the merge goes well (it usually does), I do:

tr
b pull

This suffices to resolve the conflict.
#@+node:ekr.20110514134640.14520: *3* Doc: summary of autocompleter (do not delete)
@language rest

There has been a lot of work on autocompletion recently. Here, I'll summarize
the present status and indicate future directions.

Terminology: the *legacy* (aka tabbed) autocompleter shows completions in Leo's
tabbed pane. The *new* (aka qcompleter) autocompleter shows completions in or
near the body pane.

Appearance
==========

There is little change to the legacy completer, except that no text is
highlighted in the body pane during completion. This is calmer than before.
Furthermore, there is no longer any need for highlighting, because when the user
types a backspace the legacy completer now simply deletes a single character
instead of the highlighted text.

One more minor change: the legacy completer now *does* insert characters that do
not match the start of any possible completion. This is an experimental feature,
but it might play well with using codewise completions as a fallback to
leo-related completions.

The appearance of the qcompleter is in flux. Previously, the QCompleter ctor
created a wretched-looking window in or near the body pane. The present code
creates a new temporary splitter above the body pane. It looks good, but has the
unpleasant effect of shifting the body pane done.

The consensus seems to be that the completion window should float near the
to-be-completed text, without obscuring it. I'll do this immediately.

Function and design
===================

Both the legacy and new completer now work *exactly* the same way, because they
both use the AutoCompleterClass to compute the list of completions.

In other words, the qcompleter code in qtGui.py deals *only* with gui- related
matters. All policy matters are delegated to AutoCompleterClass.

All completion-related code is stateless, or as stateless as possible. In
practice, this means that ac.compute_completion_list must be called on every
keystroke. That's not a problem: it is extremely fast.

Yesterday I realized that the strict "stateless" requirement means that the
"intermediate" completions must be entered into the body pane while completion
is active. This might be a debatable user-interface choice. It works well as a
visual cue when using the tabbed completer: indeed, the tabbed completer would
be difficult to use without this cue.

The situation is slightly different with the qcompleter. Adding code before the
user accepts the completion might be considered an "advanced" feature. However,
it does have two important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it limits what must appear
in the qcompleter window.

It would be possible *not* to add the intermediate text into the body pane when
using the qcompleter, but that would have the following disadvantages:

- It would require internal state somewhere, probably in AutoCompleterClass.

- It would require that the complete prefix be visible in the qcompleter window.

For these reasons, I would prefer to have the code remains stateless for both
the legacy and new completers.

Codewise completions
====================

I agree with Ville that the @bool use_codewise setting should be eliminated, or
at the very least made the default. The problem with eliminating the setting
completely is that it might give incorrect results if c, g and p do not mean
what they mean in Leo. Perhaps this is not worth worrying about. In any case,
the codewise completions should be used whenever the eval-oriented approach
fails.

The present codewise-oriented completions appear to work well. In large part,
this is due to adding the global "self." completions to all class-related
completions (kind == 'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the ContextSniffer class.

Performance
===========

Performance of leo-related completions is *much* better than before. The old
code used Python's inspect module and was horribly complex. The new code uses
eval and is perfectly straightforward.

The present codewise-related code caches completions for all previously-seen
prefixes. This dramatically speeds up backspacing. Global caching is possible
because completions depend *only* one the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions would depend on the
selected node and caching would likely be impractical.

Despite these improvements, the performance of codewise-oriented completions is
now noticeably slower than leo-related completions.

The present qcompleter code avoids the QCompleter class entirely. This
dramatically speeds up completions and simplifies the code in qtGui.py.

Future directions
=============

Appearance-related issues will soon be completely resolved. When that happens I
shall consider autocompletion to be "complete enough".

I am completely happy with the leo-oriented completions. I'm not looking for
anything better :-)

Falling back to codewise-completions when leo-related completions fail may have
some promise. In fact, the slowness of computing the codewise-oriented
completions in that case might be a subtle clue that something is amiss :-) We
shall see. In any case, it's a small point with no global implications.

The "final frontier" is, as it has always been, improving codewise completions.
As always, this is an open-ended project. The question are, how much AI is
reasonable, and how can performance be improved? Having said that, I am pleased
with ac.get_codewise_completions. It, and its helpers, guess_class and clean,
are relatively straightforward.

I have always considered the codewise completions (or whatever replaces them) to
be the "hard part". There is still a sense in which this is true, but perhaps as
a practical matter Ville was correct in calling this week's work the hard part
:-)

In any case, the codewise completions work surprisingly well. For example, it
suggests all parts of the chain c.frame.body.bodyCtrl.widget except the bodyCtrl
part, and after I type the bodyCtrl part by hand the codewise completer does
suggest widget.

This is all a bit of a hack. The codewise completer suggests far more
completions than are actually valid. Happily, these extra suggestions cause no
pain: typing just a few letters of the next part of the chain quickly removes
most extraneous completions.

The performance and flexibility of the codewise completer are greater concerns.
Now that leo-related completions are so fast, the slower speed of the codewise
completer is just a bit annoying. Caching helps somewhat, but not enough.

By "flexibility" I mean that the user must run ctags periodically to update
completions. One could imagine Leo doing this automatically from time to time,
but such a project would not be trivial.

Summary
=======

User interface issues are nearly resolved: I'll make the qcompleter float today.

Performance of Leo completions are excellent; codewise completions not bad.

Improving codewise completions would be an interesting project, but not urgent.
#@+node:ekr.20110514134640.14521: *3* Doc: the new completion caching scheme (do not delete)
@language rest

QQQ
The completer should calculate all possible completions at that time. now, as
you enter letters b a r, (to get foo.bar), completions should not be calculated
- rather, the original completion list calculated earlier should be pruned
according to the letters typed.
QQQ

The change was elegant: see ac.get_cached_options. This method cuts back the
prefix until it finds a cached prefix. ac.compute_completion_list then uses this
(perhaps-way-too-long-list) as a starting point, and computes the final
completion list by calling g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much simpler and more
robust than attempting to do "prefix AI" based on comparing old and new
prefixes. Furthermore, this scheme is completely independent of the how
completions are actually computed. The autocompleter now caches options lists,
regardless of whether using eval or codewise.

And in most cases the scheme is extremely fast: calls to get_completions replace
calls to g.itemsMatchingPrefixInList. However, for short prefixes, the list that
g.g.itemsMatchingPrefixInList scans can have thousands of items. Scanning large
lists can't be helped in any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the completionDict does
*not* define state (it is valid everywhere) and no state variables had to be
added.

In short, the new caching scheme is much better than before, and it probably is
close to optimal in most situations.
#@+node:ekr.20101129095441.5963: *3* Improve screenshots page
#@+node:ekr.20110518103946.18157: ** Maybe
#@+node:ekr.20101104191857.5820: *3* Idea: presentation tool
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

#@+node:ekr.20090724081340.5987: *3* Improve recursive import script and @auto
@nocolor-node

Instead of adding an @ignore directive, it might be better
to change @auto to @@auto.

Should @auto be more lenient with C files?

Improve the recursive import script.
    - Minimize the path names
    - Option to include/exclude the @auto itself

#@+node:ekr.20090601083544.6067: *3* Make all commands available to all commanders
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/a83082cec5ad3df8

QQQ (Ville)
So to create command you would do

import leoPlugins

def mycmd(c,p, event):
  print c,p

leoPlugins.expose_command('my-command', mycmd)
leoPlugins.expose_button('press-this',mycmd)

[EKR: I would rather use g.app.exposeCommand, g.app.exposeButton].

These would be available on *all* new commanders, and the current
commander as well (for easy testing). Plugins would not have to
contain more code than what is presented above.

The idea is to have a global command dict, [EKR: g.app.commandsDict]
and global button dict.
There is one after-create-frame handler that introduces all the
entries in this dict to the commander command dict.
QQQ

============


QQQ
g.app.global_commands_dict, which gets copied to c on commander
creation. it's rev 1889, you'll note that it's a simple
implementation. I didn't add g.button yet. An example:

@g.command('bookmark')
def bookmark(event):
    c = event.get('c')
    p = c.currentPosition()
    bookmarks.append(p.gnx)
    g.es('bookmarked') 
QQQ
#@+node:ekr.20090714085914.5994: *3* New commands
#@+node:ekr.20071004120359.2: *4* Do expand-region-abbrevs from
See: regionalExpandAbbrev.
#@+node:ekr.20090402072059.2: *4* clone-find-all-once
@

First do a normal clone-find-all for the word "clone". Then click the script
button and do it again. Notice that children of previously found nodes don't get
added again in the modified version.
#@+node:ekr.20090402072059.4: *5* @@@button my clone find all
import leo.core.leoFind as leoFind 

def new_find_all(self):
    << do some initial stuff >>


    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break

        if count % 10 == 0 and count > 0:
            g.es("still searching, matches found: ", count)

        << Skip node if it's a child of a previously found node >>

        count += 1

        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                << create the found node >>
            clones.append(self.p.v.t)
            positions.append(self.p)
            << create a clone of p under the find node >>

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")


leoFind.leoFind.findAll = new_find_all

c.executeMinibufferCommand("clone-find-all") 
#@+node:ekr.20090402072059.5: *6* << do some initial stuff >>
g.es("findAll..., self: ", self)

c = self.c ; w = self.s_ctrl ; u = c.undoer
undoType = 'Clone Find All'
if not self.checkArgs():
    return
self.initInHeadline()
if self.clone_find_all:
    self.p = None # Restore will select the root position.
data = self.save()
self.initBatchCommands()
count = 0 ; clones = []; positions = []
#@+node:ekr.20090402072059.6: *6* << create the found node >>
oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition() # New in Leo 4.5.
#@+node:ekr.20090402072059.7: *6* << create a clone of p under the find node >>
q = self.p.clone()
q.moveToLastChildOf(found)
#@+node:ekr.20090402072059.8: *6* << Skip node if it's a child of a previously found node >>
<< def: is a child of b >>

is_child_of_previous = False
for previously_found in positions:
    if is_a_child_of_b(self.p, previously_found):
        is_child_of_previous = True
        break

if is_child_of_previous:
    continue
#@+node:ekr.20090402072059.9: *7* << def: is a child of b >>

def is_a_child_of_b(a, b):
    for child in b.children_iter():
        if a.t == child.t:
            return True
        if is_a_child_of_b(a, child):
            return True
    return False
#@+node:ekr.20100108101415.6196: *4* insert-tab commands
insert-tab-or-indent-region, insert-hard-tab, insert-soft-tab.
#@+node:ekr.20101024062147.5996: *3* Wishlist
#@+node:ekr.20080922115725.1: *4* Finish @shadow
# Allow block comments in private shadow files.
# Compute delims using the private shadow file, not the file extension!
# Can @shadow mark externally changed nodes?
#@+node:ekr.20081004102201.2: *5* Log file for @shadow
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5e7bd3af2d1fbf51

How about a shadow.log file which Leo told what it thought of the relationship
between the node, file and shadow? It might provide useful clues.
#@+node:ekr.20081001062423.1: *5* Can @shadow mark externally changed nodes?
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/c46eabe8a9fe6e8

@color
#@+node:ekr.20080708094444.38: *6* x.propagate_changed_lines
def propagate_changed_lines(self,new_public_lines,old_private_lines,marker,p=None):

    '''Propagate changes from 'new_public_lines' to 'old_private_lines.

    We compare the old and new public lines, create diffs and
    propagate the diffs to the new private lines, copying sentinels as well.

    We have two invariants:
    1. We *never* delete any sentinels.
       New at 2010/01/07: Replacements preserve sentinel locations.
    2. Insertions that happen at the boundary between nodes will be put at
       the end of a node.  However, insertions must always be done within sentinels.
    '''

    trace = False and g.unitTesting
    verbose = True
    x = self
    # mapping tells which line of old_private_lines each line of old_public_lines comes from.
    old_public_lines, mapping = self.strip_sentinels_with_map(old_private_lines,marker)

    << init vars >>
    << define print_tags >>

    delim1,delim2 = marker.getDelims()
    sm = difflib.SequenceMatcher(None,old_public_lines,new_public_lines)
    prev_old_j = 0 ; prev_new_j = 0

    for tag,old_i,old_j,new_i,new_j in sm.get_opcodes():

        << About this loop >>

        # Verify that SequenceMatcher never leaves gaps.
        if old_i != prev_old_j: # assert old_i == prev_old_j
            x.error('can not happen: gap in old: %s %s' % (old_i,prev_old_j))
        if new_i != prev_new_j: # assert new_i == prev_new_j
            x.error('can not happen: gap in new: %s %s' % (new_i,prev_new_j))

        << Handle the opcode >>

        # Remember the ends of the previous tag ranges.
        prev_old_j = old_j
        prev_new_j = new_j

    # Copy all unwritten sentinels.
    self.copy_sentinels(
        old_private_lines_rdr,
        new_private_lines_wtr,
        marker,
        limit = old_private_lines_rdr.size())

    # Get the result.
    result = new_private_lines_wtr.getlines()
    if 1:
        << do final correctness check>>
    return result
#@+node:ekr.20080708094444.40: *7* << init vars >>
new_private_lines_wtr = self.sourcewriter(self)
# collects the contents of the new file.

new_public_lines_rdr = self.sourcereader(self,new_public_lines)
    # Contains the changed source code.

old_public_lines_rdr = self.sourcereader(self,old_public_lines)
    # this is compared to new_public_lines_rdr to find out the changes.

old_private_lines_rdr = self.sourcereader(self,old_private_lines) # lines_with_sentinels)
    # This is the file which is currently produced by Leo, with sentinels.

# Check that all ranges returned by get_opcodes() are contiguous
old_old_j, old_i2_modified_lines = -1,-1

tag = old_i = old_j = new_i = new_j = None
#@+node:ekr.20080708094444.39: *7* << define print_tags >>
def print_tags(tag, old_i, old_j, new_i, new_j, message):

    sep1 = '=' * 10 ; sep2 = '-' * 20

    g.pr('\n',sep1,message,sep1,p and p.h)

    g.pr('\n%s: old[%s:%s] new[%s:%s]' % (tag,old_i,old_j,new_i,new_j))

    g.pr('\n',sep2)

    table = (
        (old_private_lines_rdr,'old private lines'),
        (old_public_lines_rdr,'old public lines'),
        (new_public_lines_rdr,'new public lines'),
        (new_private_lines_wtr,'new private lines'),
    )

    for f,tag in table:
        f.dump(tag)
        g.pr(sep2)


#@+node:ekr.20080708192807.2: *7* << about this loop >>
@ This loop writes all output lines using a single writer:
new_private_lines_wtr.

The output lines come from two, and *only* two readers:

1. old_private_lines_rdr delivers the complete original sources. All
   sentinels and unchanged regular lines come from this reader.

2. new_public_lines_rdr delivers the new, changed sources. All inserted or
   replacement text comes from this reader.

Each time through the loop, the following are true:

- old_i is the index into old_public_lines of the start of the present
  SequenceMatcher opcode.

- mapping[old_i] is the index into old_private_lines of the start of
  the same opcode.

At the start of the loop, the call to copy_sentinels effectively skips
(deletes) all previously unwritten non-sentinel lines in
old_private_lines_rdr whose index is less than mapping[old_i].

As a result, the opcode handlers do not need to delete elements from
the old_private_lines_rdr explicitly. This explains why opcode
handlers for the 'insert' and 'delete' opcodes are identical.
#@+node:ekr.20080708192807.5: *7* << Handle the opcode >>
# Do not copy sentinels if a) we are inserting and b) limit is at the end of the old_private_lines.
# In this special case, we must do the insert before the sentinels.
limit=mapping[old_i]

if trace: g.trace('tag',tag,'old_i',old_i,'limit',limit)

if tag == 'equal':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)

    # Copy all lines (including sentinels) from the old private file to the new private file.
    start = old_private_lines_rdr.index() # Only used for tag.
    while old_private_lines_rdr.index() <= mapping[old_j-1]:
        line = old_private_lines_rdr.get()
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (
            tag,start,mapping[old_j-1]))

    # Ignore all new lines up to new_j: the same lines (with sentinels) have just been written.
    new_public_lines_rdr.sync(new_j)

elif tag == 'insert':
    if limit < old_private_lines_rdr.size():
        self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # All unwritten lines from old_private_lines_rdr up to mapping[old_i] have already been ignored.
    # Copy lines from new_public_lines_rdr up to new_j.
    start = new_public_lines_rdr.index() # Only used for tag.
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag == 'replace':
    # This case is new: it was the same as the 'insert' case.
    start = old_private_lines_rdr.index() # Only used for tag.
    while (
        old_private_lines_rdr.index() <= mapping[old_j-1]
        and new_public_lines_rdr.index() <  new_j
            # 2010/10/22: the replacement lines can be shorter.
    ):
        old_line = old_private_lines_rdr.get()
        if marker.isSentinel(old_line):
            # Important: this should work for @verbatim sentinels
            # because the next line will also be replaced.
            new_private_lines_wtr.put(old_line,tag='%s %s:%s' % (
                'replace: copy sentinel',start,new_j))
        else:
            new_line = new_public_lines_rdr.get()
            new_private_lines_wtr.put(new_line,tag='%s %s:%s' % (
                'replace: new line',start,new_j))

    # 2010/10/22: The replacement lines can be longer: same as 'insert' code above.
    while new_public_lines_rdr.index() < new_j:
        line = new_public_lines_rdr.get()
        if marker.isSentinel(line):
            new_private_lines_wtr.put(
                '%s@verbatim%s\n' % (delim1,delim2),
                tag='%s %s:%s' % ('new sent',start,new_j))
        new_private_lines_wtr.put(line,tag='%s %s:%s' % (tag,start,new_j))

elif tag=='delete':
    # Copy sentinels up to the limit = mapping[old_i]
    self.copy_sentinels(old_private_lines_rdr,new_private_lines_wtr,marker,limit=limit)
    # Leave new_public_lines_rdr unchanged.

else: g.trace('can not happen: unknown difflib.SequenceMather tag: %s' % repr(tag))

if trace and verbose:
    print_tags(tag, old_i, old_j, new_i, new_j, "After tag")
#@+node:ekr.20080708094444.45: *7* << do final correctness check >>
t_sourcelines, t_sentinel_lines = self.separate_sentinels(
    new_private_lines_wtr.lines, marker)

self.check_the_final_output(
    new_private_lines   = result,
    new_public_lines    = new_public_lines,
    sentinel_lines      = t_sentinel_lines,
    marker              = marker)
#@+node:ekr.20090402072059.13: *5* Create a general mechanism for aux (shadow, _db) files
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/4ec30df3f1db8db3

On Sat, Mar 28, 2009 at 3:24 AM, VR <viktor.ransmayr@gmail.com> wrote:


    When I tried to de-install Leo-4.6b1 I succeeded, but the program
    reported that 5 directories
    were not removed.

    Three of the directories where

    1) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\config
    2) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\doc
    3) C:\Python26\Lib\site-packages\Leo-4-6-b1\leo\plugins

    [containing]


    a) .leoSettings.leo_db
    b) .leoDocs.leo_db
    c) .leo_shadow
    d) .leoPluginsRef.leo_db


Thanks for this report. I think it is important, and needs a good solution.

I dislike all these files being sprayed around the file system. I'd like to see
these files placed somewhere the ~/.leo directory. Is there a reason why this
would be a bad idea?

Similarly, we might also prefer to have shadow files place in, say,
~/.leo/shadow_files.

In both cases, I think we want to create files that indicate their location.
Either that, or mirror their location in (subdirectories) ~/.leo. In other
words, this is a general problem, and it would be good to have a robust, general
solution.
#@+node:ekr.20100131161507.6303: *4* Unit tests that all commands have docstrings
# Just make the test.  It doesn't have to pass.
#@+node:ekr.20100826110728.5839: *4* Relocating .leo_shadow directories
@nocolor-node

2008

http://groups.google.com/group/leo-editor/browse_thread/thread/b738e3f8d164f9fc

May 10, 2010

Kent

I think there could be quite a bit of interest in moving
the shadow files to their own tree, avoiding what might
be considered 'pollution' of a tree of files in @shadow nodes.

Edward has said that this would add a lot of complexity to Leo.

It seems that a VCS back end for Leo might simplify the
task of arbitrary shadow file location, as well as adding
versioning capability.


Those of us old enough to remember the Groucho Marx show will know what I am ...

bogomil
 to me

In order to relocate .leo_shadow directories in home dir, I have made
the following changes leoShadow.py:
1. Introduce new setting 'shadow_in_home_dir':
   x.ctor:
     ...
     self.shadow_prefix = c.config.getString('shadow_prefix') or ''

=>  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir')
or False
    ...

2. Make the following line:
   x.shadowDirName and shadowPathName:
      ...
      fileDir = g.os_path_dirname(filename)

=>   if self.shadow_in_home_dir:
        fileDir = "//".join([baseDir, fileDir.replace(':','%')])

In this way I keep .leo_shadow dirs in a tree and it is ok if the user
reorgs the original tree.

=====================
Edward K. Ream
 to bogomil

Thanks for these suggestions.  I'll try them soon.

A few minor comments about the code.

>  self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir') or False

This works (because c.config.getBool returns None if the setting does
not exist). Thus, the "or False" part merely replaces None by False.
I prefer the following:

self.shadow_in_home_dir = c.config.getBool('shadow_in_home_dir',default=False)

>   if self.shadow_in_home_dir:
>         fileDir = "//".join([baseDir, fileDir.replace(':','%')])

This looks like a Windows-only solution because of ':'.  It might fail
in strange ways on other platforms.
#@+node:ekr.20100830120622.5829: *4* Fix python import problems
@nocolor-node

> > Hmm, I guess that would be more clear, although I think I'd like an option
to include it in the following def to avoid

> > Decoration
> > index
> > Decoration
> > add_user
>
> Sure.  Decorations must always be part of a definition.

Well, personally I'd like to have them included in the definition, but I think
Kent's preference for a separate node is reasonable to. If your function and
hence definition node is called "pluralize", and it's decorated with something
like "@authenticate_user", you may never check the innocent looking pluralize
definition to find out what on earth's triggering the mysterious network
database call. And this isn't a completely specious example, authentication may
have been added to stop pluralize being used in a user existence detection
exploit or something. OTOH in well behaved code like CherryPy apps you don't
want a separate node for every @cherrypy.expose.

Bottom line is I think we're asking for a set of @settings to fine tune python
import behavior:

@python_import_interdef = previous | next | own_node | ai
@python_import_decoration = next | own_node

I'm not sure I believe the AI option is possible / practical, and am not asking
for it, just listing it :-)

I'd also like

@python_import_init_in_class_node = true | false

as often there's more docs on a class in the __init__ than the class docstring.

I think that's really all we're talking about, some @settings to test during import.
#@+node:ekr.20110518103946.18156: ** Leo 4.10: deprecate Tk
#@+node:ekr.20100521090440.5890: *3* Cleanups
#@+node:ekr.20100223123910.5930: *4* recentFilesController
@
The present operation of recent files is surprising.

Recent files should be a global list, managed by a single controller.
#@+node:ekr.20100219083854.5615: *4* Improve caching
#@+node:ekr.20100209160132.5770: *5* cache notes
@nocolor-node

Top-level folder are direct subfolders of .leo/db.
Top-level folders represent file *locations* not file contents.
Exception: the top-level "globals" folder represents minor data.

Only two files are ever needed in a top-level folder:

contents_<key>: the contents of the file.
data_<key>: a dict representing the "minor data" of the file:
    <globals> element stuff, expansion bits, etc.

We write contents_<key> only once.
By definition, its contents never changes, since the contents generates the key.
We can write data_<key> as many times as we like.

To do:
- Simplify or even eliminate the path-manipulation code in PickleShareDB.
- Use g.makeAllNonExistentDirectories to make top-level directories.
- Clear cache should clear all top-level directories.
#@+node:ekr.20100209114432.5751: *6* Cache expansion bits
# Simplify the structure of the cache: put more into the "minor" files.
#@+node:ekr.20100211095442.6201: *5* cache notes 2
@nocolor-node

1. Memory does leak, and that's not ok with me.  And I want just two
files per top-level directory.

2. Strange things can happen with caching, as just happened to me when
I restored qtui_generate.py mistakenly deleted from leo/test.  There
is an @auto node for this file in qtGui.py, and I got improper 'can
not open' messages for this file.

3. It is troubling that the present caching scheme does not use the
full path to a file, only the basename.  This means that two identical
files in two different places will use the same cache entries.  I've
been wondering for the last several days about whether this could
cause problems.  I don't know for sure, but I am uncomfortable.

4. I want the clear-cache and clear-all-caches commands to do what
they say: get rid of everything.  Among other things, this is good for
debugging and recovering from cache problems.

#@+node:ekr.20100223075705.5635: *5* Don't write expansion bits
#@+node:ekr.20100210163813.5748: *5* Caching buglets?
@nocolor-node

This is a recent bug, but imo it has uncovered some other caching buglets. These
buglets are not big enough to delay Leo 4.7, but the new caching scheme would
ensure they never bite.

1. The code that computes what I have been calling the top-level directory is dubious::

    dbdirname = join(g.app.homeLeoDir,'db',
            '%s_%s' % (bname,hashlib.md5(fn).hexdigest()))

The problem is that bname is only the base name of the cached file, not a name
(or key) that depends on the full path. Thus, two copies of the same file in the
same place will be cached in the same directory. Is this ominous?

2. It's not clear what caching to do with the save-to command.
#@+node:ekr.20100225102636.5627: *5* Use the string returned by cacher
# It should be possible to avoid duplicate reads.
#@+node:ekr.20080628095358.1: *4* Make each Leo command a class
http://groups.google.com/group/leo-editor/browse_thread/thread/5688ed9aaa39be2e#

@nocolor

The main difficulty I see in the migration is creating the tables in the getPublicCommands methods in the various classes in leoEditCommands.py.  At present, these tables associate command names (strings) with corresponding methods.  The form of getPublicCommands is always:

def getPublicCommands (self):
  return {
    'command-name1': self.methodName1,
    'command-name2': self.methodName2,
    ...
  }

Thinking out loud, let's see whether the migration can be done easily.  We would change the entry:

    'command-name1': self.methodNameN,

to:

    'command-name1': self.classNameN(self),

That is, the table creates an instance of the class by calling the class's ctor, with self (the container object) as the ctor's only argument.  To make this work, all we need to do is give the class a __call__ method whose signature matches the signature of methodNameN, that is, the signature used to call methods previously.

Well, isn't this nice.  We can transition gradually, as needed.  No need *ever* to do a mass migration.  It should be easy to verify this scheme with one or two examples.  Please report your experiences if you decide to play around with this.

Edward

P.S.  I think it would be good style to append "Class" to the name of each command class. This makes it clear that self.myCommandClass(self) is a ctor.
#@+node:ekr.20101119030344.5838: *5* script to turn all commands into @g.command nodes
'''Add @g.command(command_name) before all commands.'''

@others

import os ; os.system('cls')

d = c.commandsDict
f_dict = find_all_defs(c)

result1, result2 = [],[]
for f_name in sorted(f_dict): # These are function names, not command name.
    c_name = c.k.inverseCommandsDict.get(f_name) # Get the emacs command name.
    if c_name:
        f = d.get(c_name) # f is the function name that defines a command.
        if f:
            d_name = f.__name__
            s = repr(f)
            tag = '<bound method '
            if s.startswith(tag): s = s[len(tag):]
            i = s.find(' of ')
            if i > -1: s = s[:i]
            aList = [p.h for i,p in f_dict.get(d_name,[])]
            if len(aList) == 1:
                result1.append((d_name,s,aList),)
            else:
                result2.append((d_name,s,aList),)

print('----- duplicate commands -----\n')
for d_name,s,aList in result2:
    print('%s: %s\n%s %s\n' % (d_name,s,len(aList),aList))

print('----- unambiguous commands -----\n')
for d_name,s,aList in result1:
    print('%40s %s' % (d_name,aList[0]))

if 0:
    for name in sorted(d):
        f = d.get(name)
        f_name = f.__name__
        # name is the minibuffer command name, f_name is the function name.
        i,p = find(c,command,f_name)
        adjust(c,f_name,i,p)
#@+node:ekr.20061031131434.3: *6* << about key dicts >>
@nocolor
@
ivars:

c.commandsDict:
    Keys are emacs command names; values are functions f.

k.inverseCommandsDict:
    Keys are f.__name__; values are emacs command names.

k.bindingsDict:
    Keys are shortcuts; values are *lists* of g.bunch(func,name,warningGiven)

k.masterBindingsDict:
    Keys are scope names: 'all','text',etc. or mode names.
    Values are dicts:  keys are strokes, values are g.Bunch(commandName,func,pane,stroke)

k.masterGuiBindingsDict:
    Keys are strokes; value is a list of widgets for which stroke is bound.

k.settingsNameDict:
    Keys are lowercase settings; values are 'real' Tk key specifiers.
    Important: this table has no inverse.

not an ivar (computed by k.computeInverseBindingDict):

inverseBindingDict
    Keys are emacs command names; values are *lists* of shortcuts.
#@+node:ekr.20101119030344.5841: *6* find_all_defs
def find_all_defs (c):

    '''Return a dict containing all function defs.

    Keys are function names, values are lists of (i,p) pairs.'''

    # To do: consider only files that actually generate commands?
    d = {}
    suppress = ('__init__',)
    for p in c.all_unique_positions():
        done,i,s = False,0,p.b
        while not done and i < len(s):
            progress = i
            i = i1 = s.find('def',i)
            if i == -1:
                done = True ; break
            i += 3 # Assures progress.
            if not g.match_word(s,i-3,'def'): continue
            j = g.skip_ws(s,i)
            if j == i: continue
            i = j
            j = g.skip_id(s,i,chars='_')
            if j == i: continue
            name = s[i:j]
            if name not in suppress:
                aList = d.get(name,[])
                aList.append((i1,p.copy()),)
                d[name] = aList
            # g.trace('%30s %s' % (name,p.h))
            i = j
            assert progress < i
    return d
#@+node:ekr.20101119030344.5839: *6* find
def find (c,command,f_name):

    g.trace('%30s %s' % (command,f_name))

    for p in c.all_unique_nodes():
        s = p.b
        i = s.find('def %s' % f_name)
#@+node:ekr.20101119030344.5840: *6* adjust
def adjust(f,i,p):
    pass
#@+node:ekr.20080923200153.1: *4* Support scan-directives hook again?
# This affects the add_directives plugin.
# Also, the color_markup plugin doesn't work with the threading colorizer.
#@+node:ekr.20100206074650.5844: *3* Features
#@+node:ekr.20090811141250.5955: *4*  Most important features
@ Important: There is another features list for 4.9.
#@+node:ekr.20090801103907.6018: *5* Add entries to global dicts for more languages
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.
#@+node:ekr.20090816125009.5993: *6* @url http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780
#@+node:ekr.20090814190307.5983: *6* print all modes/*.py files
import glob

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')

aList = glob.glob(theDir)

for z in aList:
    print g.os_path_basename(z)

@
Exist:

    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
"w"     : "cweb",
"xml"   : "xml",
"xsl"   : "xslt",

Add first:


ada95.py
antlr.py
apacheconf.py
apdl.py
applescript.py
asp.py
aspect_j.py
assembly_macro32.py
assembly_mcs51.py
assembly_parrot.py
assembly_r2000.py
assembly_x86.py
awk.py
b.py
batch.py
bbj.py
bcel.py
bibtex.py
c.py
chill.py
cobol.py
coldfusion.py
cplusplus.py
csharp.py
css.py
cvs_commit.py
d.py
doxygen.py
dsssl.py
eiffel.py
embperl.py
erlang.py
factor.py
forth.py
fortran.py
fortran90.py
foxpro.py
freemarker.py
gettext.py
groovy.py
haskell.py
hex.py
html.py
i4gl.py
icon.py
idl.py
inform.py
ini.py
inno_setup.py
interlis.py
io.py
java.py
javascript.py
jcl.py
jhtml.py
jmk.py
jsp.py
latex.py
lilypond.py
lisp.py
lotos.py
lua.py
mail.py
makefile.py
maple.py
matlab.py
ml.py
modula3.py
moin.py
mqsc.py
netrexx.py
nqc.py
nsis2.py
objective_c.py
objectrexx.py
occam.py
omnimark.py
pascal.py
patch.py
perl.py
php.py
phpsection.py
pike.py
pl1.py
plain.py
plsql.py
pop11.py
postscript.py
povray.py
powerdynamo.py
progress.py
prolog.py
props.py
psp.py
ptl.py
pvwave.py
pyrex.py
python.py
r.py
rebol.py
redcode.py
relax_ng_compact.py
rest.py
rhtml.py
rib.py
rpmspec.py
rtf.py
ruby.py
rview.py
sas.py
scheme.py
sdl_pr.py
sgml.py
shell.py
shellscript.py
shtml.py
smalltalk.py
smi_mib.py
splus.py
sqr.py
squidconf.py
ssharp.py
svn_commit.py
swig.py
tcl.py
tex.py
texinfo.py
text.py
tpl.py
tsql.py
uscript.py
vbscript.py
velocity.py
verilog.py
vhdl.py
xml.py
xsl.py
zpt.py
__init__.py
#@+node:ekr.20090601083544.6051: *5* Add expand_noweb_references for rst3 plugin
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
#@+node:ekr.20090601083544.6052: *6* post
@nocolor-node

I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  <<code fragment>>

Unfortunately, <<code fragment>> will not be expanded. Furthermore, in order to
get to this work, I should have <<code fragment>> under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
#@+node:ekr.20080918164844.12: *5* Improve headline navigation
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/bce1065d9a332fcd

Now that the leo is more "modeless" (I'm speaking of switching between
outline navigation and body editing modes), which btw is a clear improvement
to how leo used to behave, here are some things that still feel a bit
un-intuitive:

- ctrl+H (edit-headline) "locks" the user into the mode way too much.

   * The headline editing mode should be cancelled when the user does:
      - cursor up/down
      - ESC

   * Even better alternative: I find myself constantly thinking that "ok,
now I need to edit a headline (typically not the current headline), so now
I'll press ctrl+H". I think perhaps pressing up/down should cancel the
current headline editing, and select the next/previous headline for editing.
That is, I wouldn't need to navigate to the headline I want to edit before I
start editing it.

  - cut-node (ctrl+shift+x) selects the wrong node after the cut. The
intuitive assumption is that cut will select the node that "took the place
of the
    current node", instead of starting to travel upwards the set of nodes.

   * Typical use case is the way you usually start deleting a set of items.
You move to the first item and start cutting repeatedly. This wont work with
the current behaviour. 
#@+node:ekr.20101004092958.5914: *5* Write treepad scanner
@ treepad.py is from the treepad website
#@+node:ekr.20101004092958.5939: *6* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

#@+node:ekr.20101004092958.5940: *7* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
#@+node:ekr.20101004092958.5941: *7* class Node
class Node:
    @others
#@+node:ekr.20101004092958.5942: *8* __init__
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
#@+node:ekr.20101004092958.5943: *8* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
#@+node:ekr.20101004092958.5944: *8* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
#@+node:ekr.20101004092958.5945: *8* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
#@+node:ekr.20101004092958.5946: *8* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
#@+node:ekr.20101004092958.5947: *8* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

#@+node:ekr.20101004092958.5948: *7* class NodeReader
class NodeReader:
    @others
#@+node:ekr.20101004092958.5949: *8* __init__
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
#@+node:ekr.20101004092958.5950: *8* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
#@+node:ekr.20101004092958.5951: *8* readstart
def readstart(self):
    self.expect(VERSION)
#@+node:ekr.20101004092958.5952: *8* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

#@+node:ekr.20101004092958.5953: *7* class TreeReader
class TreeReader:
    @others
#@+node:ekr.20101004092958.5954: *8* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
#@+node:ekr.20101004092958.5955: *8* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
#@+node:ekr.20101004092958.5956: *8* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

#@+node:ekr.20101004092958.5957: *7* class TreeWriter
class TreeWriter:
    @others
#@+node:ekr.20101004092958.5958: *8* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
#@+node:ekr.20101004092958.5959: *8* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

#@+node:ekr.20101004092958.5960: *7* class Main
class Main:
    @others
#@+node:ekr.20101004092958.5961: *8* __init__
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
#@+node:ekr.20101004092958.5962: *8* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

#@+node:ekr.20101125041212.5845: *4* Small improvements
@nocolor-node

To be done early in the release cycle.
#@+node:ekr.20101124145006.5842: *5* Unify extract commands
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/679614fdd6a76a81#

I think this should be combined with extract-section (ctrl-shift-x), so that

- if the first line of selection is << foo >>, it created a node with
headline << foo >>

- If the  first line is def foo, create a node with headline foo

- Extend as appropriate.
#@+node:ekr.20101123131018.5842: *5* Don't save expansion bits in uA if not saving expansion bits
@nocolor-node

@bool put_expansion_bits_in_leo_files = False

It's illogical to save bits in uA's if they aren't save in in the <v> elements.
#@+node:ekr.20101116104701.5828: *5* Make promote-child-body an official command
#@+node:ekr.20081119132758.2: *5* Support @ifgui in settings trees
#@+node:ekr.20080813064908.8: *5* Find a way to limit length of lines in indented nodes
#@+node:ekr.20080802070659.11: *5* Make node attributes visible, and supported by Leo's core
#@+node:ekr.20070521105645: *5* Improve api docs with epydoc?
@nocolor
http://sourceforge.net/forum/message.php?msg_id=4319363
By: ktenney

I think there is room for improvement in documenting Leo's
API, making it easier to write these kind of scripts.
I'm not sure of the best way to do that.

Epydoc seems to be the most active project in this realm.
http://epydoc.sourceforge.net/epydoc.html
#@+node:ekr.20090131200406.15: *4* Optional file features
#@+node:ekr.20080311135649.2: *5* Allow different .leo formats
@nocolor

On Tue, Mar 11, 2008 at 7:03 AM, Kent Tenney <kten...@gmail.com> wrote:

> On 3/11/08, derwisch <johannes.hues...@med.uni-heidelberg.de> wrote:

> >  On 11 Mrz., 08:03, "Ville M. Vainio" <vivai...@gmail.com> wrote:
> >  > It could also be argued that

> >  > - Referring to previous cloned vnodes explicitly in XML does not
> >  > necessarily obscure DAG - it follows the "do not repeat yourself"
> rule
> >  > - It will speed up reading
> >  > - Wouldn't it be better for preserving the integrity of the XML file?

> > I would lean towards this line of argumentation. A couple of days I
> >  had my Leo extension destroy the Leo ODM file (which was still valid
> >  according to Leo, but unreadable wrt the extension and broken uAs). I
> >  resorted to editing the Leo file with Emacs, and was quite surprised
> >  to see that the headStrings were attributes of vnodes.

> I'll chime in with my pet peeve re: .leo file structure::

> I think that putting the headstrings on vnodes and body strings on tnodes
> obscures the informational content of the .leo file, and makes the .leo
> file
> format less attractive as a generalized solution to the problem of how to
> manage head/body pairs which live in a hierarchal structure.

> Thanks,
> Kent

> >  I think that
> >  editing the file might have been a bit easier if there had been no
> >  such redundancy. But this is more a feeling rather than a qualified
> >  opinion.

Thanks for all these comments.  I'll respond to them all here.

Clearly, we should be using a standard xml parser to read .leo files.

My present thoughts:

- I personally like human-readable headlines in <v> elements.

- I am open to putting headlines in <t> elements, as an indication that
tnodes do indeed contain headlines and body text.

- I am willing to consider only writing shared subtrees once.

Oh! (An Aha)  All these are preferences.  We can allow any combination of
these provided that headlines appear somewhere.

So that's clean.  This will happen in Leo 4.5. 
#@+node:ekr.20061002093442: *5* Add opml support to new,open, save commands
#@+node:ekr.20071003104917: *5* Make http://edreamleo.org/namespaces/leo-python-editor/1.1 Leo's official namespace
xmlns:leo="http://edreamleo.org/namespaces/leo-python-editor/1.1"
#@+node:ekr.20080626081829.2: *5* Allow headline comments for @nosent files
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/eb718b4c6d478ac0

I'm just getting started learning how to use Leo. Now, I'd like to use
it for some of my projects, but there's no chance that I can convert
everyone at work to using it, so putting sentinel-filled files in our
repository is out of the question. At the same time, my code looks
awfully bare without sentinels because the documentation ends up in
the section names, not the comments!

So, I was wondering if there's a convenient way to pull the section
names into a comment at the start of each section?

===============

Interesting question.  Am I correct in assuming you are using @nosent trees
to generate your files?  If so, it would be easy to add support for the
following options:

@bool write_section_comments_in_at_nosent_trees
@bool write_node_name_comments_in_at_nosent_trees

The first would write a sentinel consisting of only the section name;
the second would write a sentinel consisting only of the node's headline
(for nodes whose headline is not a section name).

These seem like they would be useful additions.  One can even imagine
corresponding Leo directives so that the comments could be turned on or off
within an @nosent tree.

What do you think?

=====================

> Interesting question.  Am I correct in assuming you are using @nosent trees
> to generate your files?  If so, it would be easy to add support for the
> following options:

> @bool write_section_comments_in_at_nosent_trees
> @bool write_node_name_comments_in_at_nosent_trees

> The first would write a sentinel consisting of only the section name;
> the second would write a sentinel consisting only of the node's headline
> (for nodes whose headline is not a section name).

> These seem like they would be useful additions.  One can even imagine
> corresponding Leo directives so that the comments could be turned on or off
> within an @nosent tree.

That sounds like an excellent solution. Particularly the last bit --
if you could turn section-comments on and off as required, it would
become very convenient to use Leo to produce source that is intended
to also be read by non Leo users. 
#@+node:ekr.20080919085541.3: *5* Use sqlite data base as an alternative representation for .leo files
http://groups.google.com/group/leo-editor/browse_thread/thread/dff0c165e2211691
#@+node:ekr.20100828074347.5827: *4* Vim bindings: abandoned
@nocolor-node

This is probably as far as we can go without supporting vim's underlying data model.

http://groups.google.com/group/leo-editor/browse_thread/thread/141690c553bfde55
#@+node:ekr.20110202111105.15438: *5* Handling vim modes
#@+node:ekr.20061031131434.123: *6* set-xxx-State
def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite')
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
#@+node:ekr.20061031131434.133: *6* setInputState
def setInputState (self,state):

    k = self
    k.unboundKeyAction = state



#@+node:ekr.20110202111105.15433: *5* Vim settings
#@+node:ekr.20110202111105.15434: *6* @strings [command,insert, overwrite] top_level_unbound_key_action = command
@nocolor

This setting determines the initial binding for otherwise-unbound keystrokes
when no mode is in effect.  Note: the keyboard-quit command exits all modes.

The valid values are::

command:  Leo ignores the key (like Vim).
insert:  Leo inserts the key at the cursor (like Emacs)
overwrite: Leo replaces the character at the cursor.
#@+node:ekr.20110202111105.15435: *6* @bool stayInTreeAfterEditHeadline = True
This allows the newline character to switch from the outline pane to the body pane.
#@+node:ekr.20110202111105.15436: *6* @bool outline_pane_has_initial_focus = True
True:  Outline gets focus when a new window is opened.
False: Body pane gets focus when a new window is opened.
#@+node:ekr.20110202111105.15437: *6* @bool stayInTreeAfterSelect = True
True: (Recommended) Selecting an outline node leaves the focus in the outline pane.

If this is False it will be harder to use the arrow keys in the headline.
    
False: (Legacy) Selecting an outline node transfers focus to the body pane.
#@+node:ekr.20110202094848.12569: *5* Notes
#@+node:ekr.20100521090440.5887: *6* Generalize minibuffer code
@language python
@color

#Just playing with part of a template system, the (partial) mock up for "range()" is:

def tabStopNaming (event=None):

  stateName = 'naming'
  k = c.k
  state = k.getState(stateName)

  help = ('start-value -- optional, -> fill-in or tab eliminate.  ',
           'end-value -- required, -> fill-in.  ',
           'step -- optional, ->fill-in or tab to eliminate.  ')
  tabStop = ('start-value', 'end-value', 'step')

  if state == 0:
      k.setLabelBlue(help[0],protect=True)
      k.getArg(event,stateName,1,tabStopNaming)
      # g.es('does this ever executed?') # yes, imediately!
  else:
      k.clearState()
      g.es_print('%s : %s' % (tabStop[0], k.arg))
      k.setLabelBlue('')

tabStopNaming()

@nocolor

=====================================================
This is hardwired for the first parameter.  Things I need to expand
this:

1. put in a variable that cycles through the tabStops

2. In this mock up, you are entering the parameters in the minibuffer,
a more advanced version would collect each keypress and put it in the
body at the current tabStop, a tab would finalize the entry and
advance to the next stop, no text other than the 'help', ends up in
the minibuffer.

Sinc I'm only modifying existing code without real understanding of
what Leo is doing, andy guidance would be appreciated.

Tom

=======================

Generalizing the minibuffer code would be a good thing to do.  I
suppose we could define some kind of language that would create, or
rather simulate, hand-written code.  In a sense, @mode nodes are
intended to do this also.

As I look at leoKeys.py again I'll keep this example in the back of my
mind as something that it would be good to support more easily.

Edward
#@+node:ekr.20100210102224.5744: *6* Design
@nocolor-node

Requirements:
    - Existing bindings must still be valid.
    - But @mode does not have to remain.

Think data:
    - Drive binding by tables.
    *** Design these tables first.
    - Table design should be flixible.
      It can change without affecting user.

keySequence class?
    - Represents a sequence of keystrokes.

bufferMode class?
    - Might encapsulate directives, etc.

bindHelper class?
    - Would mediate various aspects of binding.
    - c.bindHelper or k.bindHelper?
#@+node:ekr.20100113075303.6270: *5* Vim problems
#@+node:ekr.20100112051224.6229: *6* Binding Arrow keys (fixed?)
@nocolor-node

Binding arrow keys, with or without Shift, Ctrl, Alt, and their combinations, to
commands or @mode nodes have no effect.
#@+node:ekr.20100112051224.6239: *6* Displaying mode help
@nocolor-node

The "--> mode-help" command has the following issues related to the
display of the "Help" tab:

1. Key label always capitalized.

Vim commands are mapped to both lower-case and upper-case keys but always appear
mapped to upper-case keys within the "Help" tab.

2. Layout of tab's contents.

To improve readability and better support narrow tab cards, display the mode's
label without the "enter-" and "-mode" text and place the key label before the
mode label.

For example, the following entries would change from::
    enter-vi-delete-line-mode d
    enter-vi-delete-to-begin-of-word-mode b
to::
    d : vi-delete-line
    b : vi-delete-to-begin-of-word
#@+node:ekr.20100112051224.6225: *6* Repeat last cursor movement command
@nocolor-node

Support the ';' key: repeat the last "To character" or "Find character" command.
#@+node:ekr.20100113075303.6271: *6* Need mode-oriented bindings
@nocolor-node

Mapping a number to a command or an @mode node works but can not be used as it
prevents the number from being entered as text while in Vi's insert state.

Binding 'bksp' key to back-char to move back a character in command mode
prevents 'bksp' from deleting characters in text edit mode.
#@+node:ekr.20080616110054.2: *6* Support vim dot command
@nocolor-node

The ability to repeat the last editing related command by pressing the period
key is not supported and there is no workaround in place.

Binding keys within nodes:

Some commands can be "easily" repeated by having the command's mode
bind itself to the period key.  This is not currently working.  

Support commands requesting input:

Add companion commands that reuse input.  For example, a zap-to-
character-again command could exist which will reuse the key entered
in the last zap-to-character command.  With this support, the mode
that performs the initial command would assign the period key to a
companion mode that is identical to the initial mode but with the zap-
to-character command replaced by the zap-to-character-again command.

Commands requiring companion commands are:
  zap-to-character
  find-character
  backward-find-character
  (Any others?)

Notes:

- The copy of the character should be saved somewhere that does NOT affect the
  contents of the clipboard.

- The same or a separate storage location can be used for all commands to retain
  a copy of the character entered by the user. It doesn't matter since only the
  last command is assigned to the period key to be re-executed.
#@+node:ekr.20100112051224.6238: *6* Some commands do not work in headline
@nocolor-node

Leo functions exist which unconditionally set focus to the body pane
regardless of the active pane.

For example, bracket matching commands ("%" key) do not work within
a node's headline text.  Instead, the command is performed on the
node's body text.

Using the "undo" command (key 'u') to undo a change to a node's headline text
only works correctly after another node has been selected. It appears that
changes made to a node's headline text are not recorded in Leo's change history
until the edited node has lost focus.
#@+node:ekr.20100113075303.6272: *6* Argument handling
#@+node:ekr.20100112051224.6222: *7* Commands requesting user input
@nocolor-node

Commands requesting user input must be the last command executed within an @mode
node. This prevents the implementation of commands such as "yank to <character>"
that requires a "copy to clipboard" operation after the "find-character"
command.

======

Maybe we just need more commands...
#@+node:ekr.20100112051224.6226: *7* Range prefix to commands/objects (k.getArgs)
@nocolor-node

The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
#@+node:ekr.20100112051224.6223: *6* Editing node headlines using @mode nodes
@nocolor-node

Commands modifying or selecting headline text do not work correctly within a
@mode node.

This eliminates accurate implementation of vi's delete/change/substitute/yank
object commands. As a workaround, the commands are currently written to only
select the text. The user must perform the subsequent delete, change,
substitute, and yank.
#@+node:ekr.20100112051224.6237: *6* Fix forward and backward by sentences
@nocolor-node

Leo's sentence related functions:

- do not stop at empty lines.
- do not skip periods within words.
- do not stop at sentences ending in non-periods.
- do not stop at the end or beginning of the buffer.

Note: see forwardSentenceHelper and backSentenceHelper functions.
#@+node:ekr.20100112051224.6246: *6* Missing commands/features
#@+node:ekr.20100112051224.6232: *7* Toggle case command (easy)
@nocolor-node

Leo provides support for switching to upper or lower case but no method exists
to toggle between cases (used by Vi's "~" command).

#@+node:ekr.20100112051224.6233: *7* Replace current character command
@nocolor-node

Vi's "r" command allows user to replace the current character with the next
entered character.
#@+node:ekr.20100112051224.6234: *7* Move current line (to screen position)
@nocolor-node

Vi has a collection of "z<movement>" commands that will move the
current line to the top, middle, and bottom of the screen.  They are
not supported in Leo.
#@+node:ekr.20100112051224.6235: *7* Move body text up/down
@nocolor-node

Vi maps keys to scroll the text up/down one line and by half the
number of visible lines.  Leo does not support this.

#@+node:ekr.20110202094848.12568: *7* Named marks
@nocolor-node

Having worked with Tk text canvases more that Qt, there still seem to
be things that it had that have to be worked around as the Qt people
just haven't seen the need for.

One is the block cursor, I giving Leo Vim like functionality, it would
be nice if one where supported, theses new kids just don't understand
something so primitive I guess.

Another is named marks, in Vim you can store a number of cursor
locations, and recall them to jump around in your code.  This was also
useful in filling out templates as each stop could be given a name
mark.  This helped make filling out a template easier as you weren't
stuck in a linear filling in the blanks in a set order, template stops
where linked in rings, you could jump from the last stop back to the
first and make and changes you wanted on a second go round.  Gravity
of marks made things easier to inspect to determine what stops where
used and which ones were being bypassed.

As these things had an actual presence in the text buffer, it going to
be a little harder to come up with a reasonable work around.

Tom
#@+node:ekr.20110115062009.6025: *6* Commands that work differently in Vim
#@+node:ekr.20100112051224.6236: *7* Two kinds of words
Vi supports two types of words in its commands:

1. Words that consist of only a subset of the character set and
2. words that consist of all characters except the space and tab characters.

Leo's always considers a word to consist of a subset of characters
although some word related commands include different characters
than others.
#@+node:ekr.20090629183608.8446: *7* Copy/paste/yank/delete
Yank vs. Yank:
Vi's "yank" commands copy the selected text TO the clipboard.
Leo's "yank" commands insert text FROM the clipboard.

copy-text in modes:
Leo's copy-text command does not work within a mode.  As a result,
all "copy to clipboard" capability is being implemented using the
kill-<object> command followed by Leo's "yank" command to put the
text back.

paste-text in modes:
The paste-text command does not work within an @mode node.  Leo's
"yank" command is used instead.

delete-node does not copy node to clipboard:
A copy-node command is issued to copy the node to the clipboard
followed by the delete-node command.
#@+node:ekr.20110516132611.14438: *3* Deprecate Tk
#@+node:ekr.20090131200406.11: *4* Remove remaining tk-isms from Leo's core
@nocolor-node

Eliminate all tk-indices from leoEditCommands.py

These are marked with ###

(found) wordend, wordstart
(found) lineend, linestart
(found) sel.first, sel.last
(found) w.insert, w.delete
#@+node:ekr.20110125142807.17269: *4* Rewrite all tk plugins
#@-all
#@-leo
