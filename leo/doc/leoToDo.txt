.. @+leo-ver=5-thin
.. @+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
.. @@language rest # override the default .txt coloring.

.. @+all
.. @+node:ekr.20110609102702.16471: ** To do: 4.9.1
I am willing to fix bugs, but I would like to declare a moratorium on feature additions until 2012.
.. @+node:ekr.20110921132705.6960: *3* To do first
.. @+node:ekr.20111010122531.15570: *4* Lighter Leo
.. @+node:ekr.20111010122531.15568: *5* Lighter rendering
@language rest

The free_layout and viewrendered plugins are a huge step forward.  But
the lighter/heavier distinction suggests a new way to use them.

Suppose Leo supports @render-rest or @render-html.

This means that all nodes in the tree will have the body pane become a
rendering pane for rST or html.

Imagine LeoDocs completely rendered at all times.

Of course, for specific purposes, say in Leo's scripting chapter, we
might want to override these rendering directives (which should be
allowed in headlines too) with @no-render.

The point is that having *both* the original text *and* the rendered
text be visible is often too heavy: the user usually does not want to
know about the sources: the rendering is good enough.

I suppose for sophisticated users, something like show/hide-body pane
would be good commands to have, but that doesn't matter: those
commands to not increase the burden on the user while she is reading
the (rendered) docs.
.. @+node:ekr.20111010122531.15569: *5* Lighter commands
@language rest

A reminder, the opposite of "light" is "heavy", not "dark" :-)

Leo's print-settings, print-commands and print-bindings commands
create too much text.

Suppose they created outline nodes instead, replacing existing nodes
if they exist.  Something like this:

- Reference (Anywhere you like)
 - @print-settings
    etc.
 - @print-bindings
   etc
 - @print commands
   etc

Doh!  This uses Leo's power.  The subnodes can be as voluminous as
desired, and there can be organizer nodes in each case.  The actual
tree could be specified as in @menus.

Etc., etc.  This could moot the need for separate apropos commands.
Conversely, apropos commands could create their own trees, or
subtrees.

This could be the tip of an iceberg.

The more I think about the light/heavy distinction, the more I think
it is getting close to what makes Leo special.  For example, clones
(and nodes, for that matter) drastically lighten the apparent
complexity of programs or data.
.. @+node:ekr.20111009230326.7036: *4* Important
.. @+node:ekr.20110930174206.15470: *5* * Bring screen shots up to date
> While doing so I noted that on the sourceforge project
> page some screenshots are bit old, such as touting Tk.
>
> shows tk - http://webpages.charter.net/edreamleo/screen-shots.html
    Fixed
    
> uses @thin - http://webpages.charter.net/edreamleo/PCWindow.gif

> screenshots shows deprecated plugin manager -
> http://sourceforge.net/projects/leo/
    All souce-forge screenshots need to be replaced.


.. @+node:ekr.20110918204916.6811: *5* revise autocompletion docs based on recent posts
.. @+node:ekr.20110929074744.15474: *6* Autocompleter post
@language rest
@pagewidth 65

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass unless otherwise noted.

- The autoComplete method is the entry point. It will be called
  when autocompletion is enabled and the user types either a period
  or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       
.. @+node:ekr.20110929074744.15475: *7* Creating ctags data
On Sep 10, 8:36 am, "Edward K. Ream" <edream...@gmail.com> wrote:

> Later posts will discuss the following:
> 
> - Setting up to use ctags/codewise completion.

This section describes how to use Ville's codewise.py
module in leo\external folder.

**Note**: I've recently made a few changes to codewise.py. The
following discussion reflects the following changes:

- Changed docstring.

- The setup command does not crash if the ~/.ctags file already
  exist.
  
- The setup command does not call the init command, and thus does
  not delete ~/.codewise.db.
  
- Revised various print statements so they look better with Python 3.x.

**Important**: Leo's core contains all necessary autocompletion
code. In particular, enable *neither* the ctagscompleter.py
plugin *nor* the codewisecompleter.py plugin. I plan to remove
these plugins immediately, unless someone gives a good reason not
to do so.

**Important**: I've taken care to with the following
instructions, but there could be oversights or misunderstandings.
I would appreciate any corrections or additions.

Creating codewise/ctags data
============================

1. Make sure you have exuberant ctags (not just regular ctags)
   installed. It's an Ubuntu package, so its easy to install if
   you're using Ubuntu.
   
2. Execute the following commands from Leo's external/codewise.py
   module. **Note**: On Windows, you can use codewise.bat to
   execute these commands. For example::

        python <path to leo>\external\codewise.py %*
    
A. [Optional] Create a custom ~/.ctags file containing default
   configuration settings for ctags::
    
        codewise setup
        
    This command will leave the ~/.ctags file unchanged if it
    exists.  Othewise, the ``codewise setup`` command will
    create a ~/.ctags file containing the following defaults::
    
        --exclude=*.html
        --exclude=*.css
    
    See: http://ctags.sourceforge.net/ctags.html#FILES for more
    details about the .ctags file.
    
B. [Optional] Delete the existing ctags database in ~/.codewise.db::
   
        codewise init
        
C. Add ctags data to the existing ctags database::

        codewise parse <path to directory>
        
   You can add data from multiple sources by running
   the ``codewise parse`` command on multiple directories.
   
.. @+node:ekr.20110929074744.15476: *7* Using Leo's autocompleter (outline form)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
.. @+node:ekr.20110929074744.15477: *8* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15478: *8* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15479: *8* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15480: *8* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15481: *8* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15482: *7* Using Leo's autocompleter (COPY)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
Starting autocompletions
========================

There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autcompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.

Displaying autocompletions
==========================

How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.

Using the QCompleter
====================

When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.

Using the Log pane completer
============================

When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.

Showing docstrings
==================

Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15483: *8* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15484: *8* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15485: *8* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15486: *8* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15487: *8* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15488: *7* Code notes
Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.



.. @+node:ekr.20110929074744.15489: *7* Minor settings
Minor Autocompletion settings
=============================

These are found in leoSettings.leo: @settings-->Autocompleter

- @bool use_codewise = False

True: use codewise completions.
False: use Leo-specific completions.

- @bool use_qcompleter = True

True:  show completions in a QCompleter popup.
False: show completions in Leo's Completions tab.
This option has effect only when using the qt or qttabs gui's.

The following options specify minor user preferences: they have little or no effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15490: *7* Appearance
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

.. @+node:ekr.20110929074744.15491: *7* Codewise notes
Why the codewise module
=======================

- This module supports modern code completion for the Leo editor.

- Exuberant ctags is an excellent code scanner, but TAGS file
  lookup sucks for "find methods of this class".
  
- This module puts all data in a single file, ~/.codewise.db by
  default. In contrast, TAGS files can exist all over the file
  system.

- The code in codewise.py is usable as a python module, or a
  command line tool.


Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.
.. @+node:ekr.20110929074744.15492: *7* Performance
Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

.. @+node:ekr.20110929074744.15493: *7* Completions
os.path.splitdrive.d_rule
os.path.join
.. @+node:ekr.20110929074744.15494: *8* Docs
@language rest


Creating codewise/ctags data
============================

This is adapted from the thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/ca01e7a803d2b546
"HOWTO: make Ville's autocompleter work.

1. Make sure you have exuberant ctags (not just regular ctags) installed.  It's an Ubuntu package, so it's easy to install if you're using Ubuntu.

2. All recent versions of Leo contain Ville's codewise module: leo/external/codewise.py

@pagewidth 60

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass
unless otherwise noted.

- The autoComplete method is the entry point.  It will be called when autocompletion is enabled and the user types either a period or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       


Here are the contents of the discussion of autocompletion from the 4.9 release notes in LeoDocs.leo.  These should be folded into Leo's Users Guide: I'll do that today.

QQQQQ
 
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

QQQQQ

Part 2: New documentation

As I reread the release notes, I see that they are too code-oriented for the general reader.  What is needed are the following:

1. A discussion of Autocompletion settings in 
.. @+node:ekr.20110929074744.15495: *9* Additional options
The following options specify minor user preferences: they have little or no
effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15496: *8* Existing docs
@language rest
@pagewidth 65

Typing a period when @language python is in effect starts
autocompletion. Typing Return or Control-g (keyboard-quit) exits
autocompletion.

Autocompletion shows what may follow a period in code. (Actually
you can specify any character using the auto-complete shortcut
setting.) For example, after typing g. Leo will show a list of
all the global functions in leoGlobals.py. Autocompletion works
much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in
the body pane.

A leading period brings up ‘Autocomplete Modules’. (The period
goes away.) You can also get any module by typing its name. If
more than 25 items would appear in the Autocompleter tab, Leo
shows only the valid starting characters. At this point, typing
an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated
modes.

If x is a list ‘x.!’ shows all its elements, and if x is a Python
dictionary, ‘x.!’ shows x.keys(). For example, ‘sys.modules.!’
Again, further exclamation marks toggles between full and
abbreviated modes.

During autocompletion, typing a question mark shows the docstring
for the object. For example: ‘g.app?’ shows the docstring for
g.app. This doesn’t work (yet) directly for Python globals, but
‘__builtin__.f?’ does. Example: ‘__builtin__.pow?’ shows the
docstring for pow.

Autocompletion works in the Find tab; you can use <Tab> to cycle
through the choices. The ‘Completion’ tab appears while you are
doing this; the Find tab reappears once the completion is
finished. Calltips

Calltips appear after you type an open parenthesis in code.
Calltips shows the expected arguments to a function or method.
Calltips work for any Python function or method, including
Python’s global functions. Typing Return or Control-g
(keyboard-quit) exits calltips.

Examples:

    ‘g.toUnicode(‘ gives ‘g.toUnicode(s, encoding, reportErrors=False’
    ‘c.widgetWantsFocusNow’ gives ‘c.widgetWantsFocusNow(w’
    ‘reduce(‘ gives ‘reduce(function, sequence[, initial]) -> value’

The calltips appear directly in the text and the argument list is highlighted so you can just type to replace it. The calltips appear also in the status line for reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the enable_autocompleter and enable_calltips settings in leoSettings.leo. You may enable or disable these features at any time with these commands: enable-auto-completer-command, enable-calltips-command, disable-auto-completer-command and disable-calltips-command.
The minibuffer

The mini-buffer is a text area at the bottom of the body pane. You use it like the Emacs mini-buffer to invoke commands by their so-called long name. The following commands affect the minibuffer:

    full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit <Return> to execute the command. Tab completion works, but not yet for file names.

    universal-argument: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 a’s.
    keyboard-quit: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands <Return>.

The following sections list the various commands that you can invoke from the minibuffer. Important: you may bind keystrokes to any of these commands. See Customizing Leo for full details.
.. @+node:ekr.20111009162434.7204: *5* Port ipy_leo.py to latest version of IPython
.. @+node:ekr.20111003161039.15481: *5* Support solarized colors
http://ethanschoonover.com/solarized
.. @+node:ekr.20111003232155.6988: *5* Use c.db for marks & expansion bits
This would allow us to eliminate @bool put_expansion_bits_in_leo_files.
.. @+node:ekr.20111009230326.7037: *5* Leo-to-json script for IPython?
.. @+node:ekr.20110527084258.18378: *6* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *7* Notes
.. @+node:ekr.20110609042343.16548: *8* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *8* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *8* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *8* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *7* Code related to uA's
.. @+node:ekr.20040701065235.2: *8* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *8* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *8* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *8* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20111010093113.15548: *5* Lighten Leo's code base
@nocolor-node


Almost from day one, Leo has defined gui base classes in the core, and
subclasses in gui plugins.

I plan to continue that organization, but I would like to remove some of the
wrapping layers if possible. The present scheme has one or two too many
redirection layers, and they are more of a nuisance than a help.

One idea would be to define **interface classes** that define the desired api's.
Unit tests could test that subclass implements the interface class, without
having to resort to quite as much error-prone machinery as at present.
.. @+node:ekr.20111010062725.15541: *4* Bugs
.. @+node:ekr.20111010062725.15543: *5* ctrl-k twice (second time on blank line) doesn't work
.. @+node:ekr.20111010062725.15537: *5* Finish cleaning @color settings
.. @+node:ekr.20111008073427.15595: *5* Macro bug: really must have a shortcut for call-last-macro
.. @+node:ekr.20110930213637.15473: *4* Next
.. @+node:ekr.20111009162434.7203: *5* Investigate pygments
.. @+node:ekr.20111009080647.15614: *6* pygments test
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
import time

fn = g.os_path_finalize_join(g.app.loadDir,'leoCommands.py')
s = open(fn).read()

# s = 'print "Hello World"'

t1 = time.time()

s2 = highlight(s,PythonLexer(),HtmlFormatter())

t2 = time.time()

print(len(s),len(s2),'%2.2f sec' % (t2-t1))
.. @+node:ekr.20111009080647.15615: *6* pygments install error on pthon26 (python3.2 no problem)
@nocolor-node

c:\apps\pygments>python26 setup.py install

c:\apps\pygments>c:\python26\python.exe setup.py install
running install
running bdist_egg
running egg_info
creating Pygments.egg-info
writing Pygments.egg-info\PKG-INFO
writing top-level names to Pygments.egg-info\top_level.txt
writing dependency_links to Pygments.egg-info\dependency_links.txt
writing entry points to Pygments.egg-info\entry_points.txt
writing manifest file 'Pygments.egg-info\SOURCES.txt'
reading manifest file 'Pygments.egg-info\SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'Pygments.egg-info\SOURCES.txt'
installing library code to build\bdist.win32\egg
running install_lib
running build_py
creating build\bdist.win32
creating build\bdist.win32\egg
creating build\bdist.win32\egg\pygments
copying build\lib\pygments\cmdline.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\console.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\filter.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\filters
copying build\lib\pygments\filters\__init__.py -> build\bdist.win32\egg\pygments\filters
copying build\lib\pygments\formatter.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\bbcode.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\html.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\img.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\latex.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\other.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\rtf.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\svg.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\terminal.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\terminal256.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\_mapping.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\__init__.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\lexer.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\agile.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\asm.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\compiled.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\dotnet.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\functional.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\hdl.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\math.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\other.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\parsers.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\postgres.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\pypylog.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\special.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\templates.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\text.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\web.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_asybuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_clbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_luabuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_mapping.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_phpbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_postgres_builtins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_vimbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\__init__.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\plugin.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\scanner.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\style.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\autumn.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\borland.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\bw.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\colorful.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\default.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\emacs.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\friendly.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\fruity.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\manni.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\monokai.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\murphy.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\native.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\pastie.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\perldoc.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\tango.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\trac.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\vim.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\vs.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\__init__.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\token.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\unistring.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\util.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\__init__.py -> build\bdist.win32\egg\pygments
byte-compiling build\bdist.win32\egg\pygments\cmdline.py to cmdline.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\cmdline.py', 133, 43,
'print("%s not found!" % what, file=sys.stderr)\n'))

byte-compiling build\bdist.win32\egg\pygments\console.py to console.pyc
byte-compiling build\bdist.win32\egg\pygments\filter.py to filter.pyc
byte-compiling build\bdist.win32\egg\pygments\filters\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\formatter.py to formatter.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\bbcode.py to bbcode.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\html.py to html.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\formatters\\html.py', 472, 88, "
       'using current directory as base for the CSS file name', file=sys.stderr)\n"))

byte-compiling build\bdist.win32\egg\pygments\formatters\img.py to img.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\latex.py to latex.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\other.py to other.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\rtf.py to rtf.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\svg.py to svg.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\terminal.py to terminal.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\terminal256.py to terminal256.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\_mapping.py to _mapping.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\lexer.py to lexer.pyc
SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\lexer.py', 40, 30, 'class Lexer(object, metaclass=L
exerMeta):\n'))

byte-compiling build\bdist.win32\egg\pygments\lexers\agile.py to agile.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\asm.py to asm.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\compiled.py to compiled.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\dotnet.py to dotnet.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\functional.py to functional.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\hdl.py to hdl.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\math.py to math.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\other.py to other.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\parsers.py to parsers.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\postgres.py to postgres.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\pypylog.py to pypylog.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\special.py to special.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\templates.py to templates.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\text.py to text.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\web.py to web.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_asybuiltins.py to _asybuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_clbuiltins.py to _clbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_luabuiltins.py to _luabuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_mapping.py to _mapping.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_phpbuiltins.py to _phpbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_postgres_builtins.py to _postgres_builtins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_vimbuiltins.py to _vimbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\plugin.py to plugin.pyc
byte-compiling build\bdist.win32\egg\pygments\scanner.py to scanner.pyc
byte-compiling build\bdist.win32\egg\pygments\style.py to style.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\style.py', 107, 30,

'class Style(object, metaclass=StyleMeta):\n'))

byte-compiling build\bdist.win32\egg\pygments\styles\autumn.py to autumn.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\borland.py to borland.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\bw.py to bw.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\colorful.py to colorful.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\default.py to default.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\emacs.py to emacs.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\friendly.py to friendly.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\fruity.py to fruity.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\manni.py to manni.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\monokai.py to monokai.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\murphy.py to murphy.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\native.py to native.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\pastie.py to pastie.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\perldoc.py to perldoc.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\tango.py to tango.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\trac.py to trac.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\vim.py to vim.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\vs.py to vs.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\token.py to token.pyc
byte-compiling build\bdist.win32\egg\pygments\unistring.py to unistring.pyc
byte-compiling build\bdist.win32\egg\pygments\util.py to util.pyc
byte-compiling build\bdist.win32\egg\pygments\__init__.py to __init__.pyc
creating build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\PKG-INFO -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\SOURCES.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\dependency_links.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\entry_points.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\not-zip-safe -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\top_level.txt -> build\bdist.win32\egg\EGG-INFO
creating dist
creating 'dist\Pygments-1.4dev_20111009-py2.6.egg' and adding 'build\bdist.win32\egg' to it
removing 'build\bdist.win32\egg' (and everything under it)
Processing Pygments-1.4dev_20111009-py2.6.egg
creating c:\python26\lib\site-packages\Pygments-1.4dev_20111009-py2.6.egg
Extracting Pygments-1.4dev_20111009-py2.6.egg to c:\python26\lib\site-packages

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\cmdlin
e.py', 133, 43, '        print("%s not found!" % what, file=sys.stderr)\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\lexer.
py', 40, 30, 'class Lexer(object, metaclass=LexerMeta):\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\style.
py', 107, 30, 'class Style(object, metaclass=StyleMeta):\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\format
ters\\html.py', 472, 88, "                          'using current directory as base for the CSS file name', file=sys.st
derr)\n"))

Removing pygments 1.1.1 from easy-install.pth file
Adding Pygments 1.4dev-20111009 to easy-install.pth file
Installing pygmentize-script.py script to c:\python26\Scripts
Installing pygmentize.exe script to c:\python26\Scripts
Installing pygmentize.exe.manifest script to c:\python26\Scripts

Installed c:\python26\lib\site-packages\pygments-1.4dev_20111009-py2.6.egg
Processing dependencies for Pygments==1.4dev-20111009
Finished processing dependencies for Pygments==1.4dev-20111009

c:\apps\pygments>
.. @+node:ekr.20110605121601.18550: *6* Syntax coloring
.. @+node:ekr.20110605121601.18551: *7* leoQtColorizer
# This is c.frame.body.colorizer

class leoQtColorizer:

    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the jEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''

    @others

.. @+node:ekr.20110605121601.18552: *8*  ctor (leoQtColorizer)
def __init__ (self,c,w):

    # g.trace('(leoQtColorizer)',w)

    self.c = c
    self.w = w

    # Step 1: create the ivars.
    self.changingText = False
    self.count = 0 # For unit testing.
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.killColorFlag = False
    self.language = 'python' # set by scanColorDirectives.
    self.languageList = [] # List of color directives in the node the determines it.
    self.max_chars_to_colorize = c.config.getInt('qt_max_colorized_chars') or 0
    self.oldLanguageList = []
    self.oldV = None
    self.showInvisibles = False # 2010/1/2

    # Step 2: create the highlighter.
    self.highlighter = leoQtSyntaxHighlighter(c,w,colorizer=self)
    self.colorer = self.highlighter.colorer
    w.leo_colorizer = self

    # Step 3: finish enabling.
    if self.enabled:
        self.enabled = hasattr(self.highlighter,'currentBlock')
.. @+node:ekr.20110605121601.18553: *8* colorize (leoQtColorizer)
def colorize(self,p,incremental=False,interruptable=True):

    '''The main colorizer entry point.'''

    trace = False and not g.unitTesting ; verbose = False

    self.count += 1 # For unit testing.

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    elif self.enabled:
        oldFlag = self.flag
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace and verbose:
            g.trace('old: %s, new: %s, %s' % (
                self.oldLanguageList,self.languageList,repr(p.h)))
        if (oldFlag != self.flag or
            self.oldV != p.v or
            self.oldLanguageList != self.languageList or
            not incremental
        ):
            if trace: g.trace('** calling rehighlight **')
            self.oldLanguageList = self.languageList[:]
            self.oldV = p.v
            self.highlighter.rehighlight(p)

    return "ok" # For unit testing.
.. @+node:ekr.20110605121601.18554: *8* enable/disable
def disable (self,p):

    g.trace(g.callers(4))

    if self.enabled:
        self.flag = False
        self.enabled = False
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

def enable (self,p):

    g.trace(g.callers(4))

    if not self.enabled:
        self.enabled = True
        self.flag = True
        # Do a full recolor, but only if we aren't changing nodes.
        if self.c.currentPosition() == p:
            self.highlighter.rehighlight(p)
.. @+node:ekr.20110605121601.18555: *8* minor entry points
def interrupt(self):
    pass

def isSameColorState (self):
    return True # Disable some logic in leoTree.select.

def kill (self):
    pass
.. @+node:ekr.20110605121601.18556: *8* scanColorDirectives (leoQtColorizer) & helper
def scanColorDirectives(self,p):
    
    '''Set self.language based on the directives in p's tree.'''

    trace = False and not g.unitTesting
    c = self.c
    if c == None: return None # self.c may be None for testing.
    
    root = p.copy()
    self.language = None
    self.rootMode = None # None, "code" or "doc"

    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        << Test for @language >>
        << Test for @root, @root-doc or @root-code >>
        
    # 2011/05/28: If no language, get the language from any @<file> node.
    if self.language:
        if trace: g.trace('found @language %s' % (self.language))
        return self.language
        
    #  Attempt to get the language from the nearest enclosing @<file> node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)

    if not self.language:
        if trace: g.trace('using default',c.target_language)
        self.language = c.target_language

    return self.language # For use by external routines.
.. @+node:ekr.20110605121601.18557: *9* << Test for @language >>
if 'language' in theDict:
    s = theDict["language"]
    i = g.skip_ws(s,0)
    j = g.skip_c_id(s,i)
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = aList
        self.language = aList and aList[0] or []
        break
.. @+node:ekr.20110605121601.18558: *9* << Test for @root, @root-doc or @root-code >>
if 'root' in theDict and not self.rootMode:

    s = theDict["root"]
    if g.match_word(s,0,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,0,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
.. @+node:ekr.20110605121601.18559: *9* findLanguageDirectives
def findLanguageDirectives (self,p):

    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s,0,'@language'):
            i = len('@language')
            i = g.skip_ws(s,i)
            j = g.skip_id(s,i)
            if j > i:
                word = s[i:j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace:g.trace('invalid',word)

    if trace: g.trace(aList)
    return aList
.. @+node:ekr.20110605121601.18560: *9* isValidLanguage
def isValidLanguage (self,language):
    
    fn = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
    return g.os_path_exists(fn)
.. @+node:ekr.20110605121601.18561: *8* setHighlighter
# Called *only* from leoTree.setBodyTextAfterSelect

def setHighlighter (self,p):

    trace = False and not g.unitTesting
    c = self.c

    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        if self.flag:
            # Do a full recolor, but only if we aren't changing nodes.
            if self.c.currentPosition() == p:
                self.highlighter.rehighlight(p)
        else:
            self.highlighter.rehighlight(p) # Do a full recolor (to black)
    else:
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

    if trace: g.trace('enabled: %s flag: %s %s' % (
        self.enabled,self.flag,p.h),g.callers())
.. @+node:ekr.20110605121601.18562: *8* updateSyntaxColorer
def updateSyntaxColorer (self,p):

    trace = False and not g.unitTesting
    p = p.copy()

    if len(p.b) > self.max_chars_to_colorize > 0:
        self.flag = False
    else:
        # self.flag is True unless an unambiguous @nocolor is seen.
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p) # Sets self.language

    if trace: g.trace(self.flag,len(p.b),self.language,p.h,g.callers(5))
    return self.flag
.. @+node:ekr.20110605121601.18563: *8* useSyntaxColoring & helper
def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p',repr(p))
        return False

    p = p.copy()
    first = True ; kind = None ; val = True
    self.killColorFlag = False
    for p in p.self_and_parents():
        d = self.findColorDirectives(p)
        color,no_color = 'color' in d,'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False ; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False ; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True ; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False ; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True ; break
        first = False

    if trace: g.trace(val,kind)
    return val
.. @+node:ekr.20110605121601.18564: *9* findColorDirectives
color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    ,re.MULTILINE)

def findColorDirectives (self,p):

    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''

    trace = False and not g.unitTesting

    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word

    if trace: g.trace(d)
    return d
.. @+node:ekr.20110605121601.18565: *7* leoQtSyntaxHighlighter
# This is c.frame.body.colorizer.highlighter

class leoQtSyntaxHighlighter(QtGui.QSyntaxHighlighter):

    '''A subclass of QSyntaxHighlighter that overrides
    the highlightBlock and rehighlight methods.

    All actual syntax coloring is done in the jeditColorer class.'''

    @others
.. @+node:ekr.20110605121601.18566: *8* ctor (leoQtSyntaxHighlighter)
def __init__ (self,c,w,colorizer):

    self.c = c
    self.w = w

    # print('leoQtSyntaxHighlighter.__init__',w)

    # Not all versions of Qt have the crucial currentBlock method.
    self.hasCurrentBlock = hasattr(self,'currentBlock')

    # Init the base class.
    QtGui.QSyntaxHighlighter.__init__(self,w)

    self.colorizer = colorizer

    self.colorer = jEditColorizer(c,
        colorizer=colorizer,
        highlighter=self,
        w=c.frame.body.bodyCtrl)
.. @+node:ekr.20110605121601.18567: *8* highlightBlock
def highlightBlock (self,s):
    """ Called by QSyntaxHiglighter """

    if self.hasCurrentBlock and not self.colorizer.killColorFlag:
        if g.isPython3:
            s = str(s)
        else:
            s = unicode(s)
        self.colorer.recolor(s)

.. @+node:ekr.20110605121601.18568: *8* rehighlight
def rehighlight (self,p):

    '''Override base rehighlight method'''

    trace = False and not g.unitTesting
    verbose = False
    c = self.c ; tree = c.frame.tree
    self.w = c.frame.body.bodyCtrl.widget
    s = p.b
    self.colorer.init(p,s)
    n = self.colorer.recolorCount
    
    if trace: g.trace(p.h)

    # Call the base class method, but *only*
    # if the crucial 'currentBlock' method exists.
    if self.colorizer.enabled and self.hasCurrentBlock:
        # Lock out onTextChanged.
        old_selecting = c.frame.tree.selecting
        try:
            c.frame.tree.selecting = True
            QtGui.QSyntaxHighlighter.rehighlight(self)
        finally:
            c.frame.tree.selecting = old_selecting

    if trace and verbose:
        g.trace('%s %s calls to recolor' % (
            p.h,self.colorer.recolorCount-n))
.. @+node:ekr.20110605121601.18569: *7* class jeditColorizer
# This is c.frame.body.colorizer.highlighter.colorer

class jEditColorizer:

    '''This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.'''

    << about the line-oriented jEdit colorizer >>

    @others
.. @+node:ekr.20110605121601.18570: *8* << about the line-oriented jEdit colorizer >>
@nocolor-node
@

The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
.. @+node:ekr.20110605121601.18571: *8*  Birth & init
.. @+node:ekr.20110605121601.18572: *9* __init__ (jeditColorizer)
def __init__(self,c,colorizer,highlighter,w):

    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.w = w
    assert(w == self.c.frame.body.bodyCtrl)

    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    self.defaultState = 'default-state:' # The name of the default state.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.

    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        "blank","comment","cwebName","docPart","keyword","leoKeyword",
        "latexModeBackground","latexModeKeyword",
        "latexBackground","latexKeyword",
        "link","name","nameBrackets","pp","string",
        "elide","bold","bolditalic","italic", # new for wiki styling.
        "tab",
        # Leo jEdit tags...
        '@color', '@nocolor', 'doc_part', 'section_ref',
        # jEdit tags.
        'bracketRange',
        'comment1','comment2','comment3','comment4',
        'function',
        'keyword1','keyword2','keyword3','keyword4',
        'label','literal1','literal2','literal3','literal4',
        'markup','operator',
    ]

    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
.. @+node:ekr.20110605121601.18573: *10* defineLeoKeywordsDict
def defineLeoKeywordsDict(self):

    self.leoKeywordsDict = {}

    for key in g.globalDirectiveList:
        self.leoKeywordsDict [key] = 'leoKeyword'
.. @+node:ekr.20110605121601.18574: *10* defineDefaultColorsDict
def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        # tag name       :(     option name,           default color),
        'blank'          :('blank_color',                 'black'), # 2010/1/2
        'tab'            :('tab_color',                   'black'), # 2010/1/2
        'comment'        :('comment_color',               'red'),
        'cwebName'       :('cweb_section_name_color',     'red'),
        'pp'             :('directive_color',             'blue'),
        'docPart'        :('doc_part_color',              'red'),
        'keyword'        :('keyword_color',               'blue'),
        'leoKeyword'     :('leo_keyword_color',           'blue'),
        'link'           :('section_name_color',          'red'),
        'nameBrackets'   :('section_name_brackets_color', 'blue'),
        'string'         :('string_color',                '#00aa00'), # Used by IDLE.
        'name'           :('undefined_section_name_color','red'),
        'latexBackground':('latex_background_color',      'white'),
        'url'            :('url_color',                   'purple'),

        # Tags used by forth.
        'bracketRange'   :('bracket_range_color','orange'),

        # jEdit tags.
        'comment1'       :('comment1_color', 'red'),
        'comment2'       :('comment2_color', 'red'),
        'comment3'       :('comment3_color', 'red'),
        'comment4'       :('comment4_color', 'red'),
        'function'       :('function_color', 'black'),
        'keyword1'       :('keyword1_color', 'blue'),
        'keyword2'       :('keyword2_color', 'blue'),
        'keyword3'       :('keyword3_color', 'blue'),
        'keyword4'       :('keyword4_color', 'blue'),
        'keyword5'       :('keyword5_color', 'blue'),
        'label'          :('label_color',    'black'),
        'literal1'       :('literal1_color', '#00aa00'),
        'literal2'       :('literal2_color', '#00aa00'),
        'literal3'       :('literal3_color', '#00aa00'),
        'literal4'       :('literal4_color', '#00aa00'),
        'markup'         :('markup_color',   'red'),
        'null'           :('null_color',     'black'),
        'operator'       :('operator_color', 'black'),
    }
.. @+node:ekr.20110605121601.18575: *10* defineDefaultFontDict
def defineDefaultFontDict (self):

    self.default_font_dict = {
        # tag name      : option name
        'comment'       :'comment_font',
        'cwebName'      :'cweb_section_name_font',
        'pp'            :'directive_font',
        'docPart'       :'doc_part_font',
        'keyword'       :'keyword_font',
        'leoKeyword'    :'leo_keyword_font',
        'link'          :'section_name_font',
        'nameBrackets'  :'section_name_brackets_font',
        'string'        :'string_font',
        'name'          :'undefined_section_name_font',
        'latexBackground':'latex_background_font',
        'tab'           : 'tab_font',
        'url'           : 'url_font',

        # Tags used by forth.
        'bracketRange'   :'bracketRange_font',
        
        ## Default font.
        #'default'       :'default_font',

         # jEdit tags.
        'comment1'      :'comment1_font',
        'comment2'      :'comment2_font',
        'comment3'      :'comment3_font',
        'comment4'      :'comment4_font',
        'function'      :'function_font',
        'keyword1'      :'keyword1_font',
        'keyword2'      :'keyword2_font',
        'keyword3'      :'keyword3_font',
        'keyword4'      :'keyword4_font',
        'keyword5'      :'keyword5_font',
        'label'         :'label_font',
        'literal1'      :'literal1_font',
        'literal2'      :'literal2_font',
        'literal3'      :'literal3_font',
        'literal4'      :'literal4_font',
        'markup'        :'markup_font',
        # 'nocolor' This tag is used, but never generates code.
        'null'          :'null_font',
        'operator'      :'operator_font',
    }
.. @+node:ekr.20110605121601.18576: *9* addImportedRules
def addImportedRules (self,mode,rulesDict,rulesetName):

    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''

    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets [rulesetName] = True

    names = hasattr(mode,'importDict') and mode.importDict.get(rulesetName,[]) or []

    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key,[])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict [key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
.. @+node:ekr.20110605121601.18577: *9* addLeoRules
def addLeoRules (self,theDict):

    '''Put Leo-specific rules to theList.'''

    table = (
        # Rules added at front are added in **reverse** order.
        ('@',  self.match_leo_keywords,True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@',  self.match_at_color,    True),
        ('@',  self.match_at_killcolor,True),
        ('@',  self.match_at_language, True), # 2011/01/17
        ('@',  self.match_at_nocolor,  True),
        ('@',  self.match_at_nocolor_node,True),
        ('@',  self.match_doc_part,    True),
        ('f',  self.match_url_f,        True),
        ('h',  self.match_url_h,       True),
        ('<',  self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ',  self.match_blanks,      False),
        ('\t', self.match_tabs,        False),
    )

    for ch, rule, atFront, in table:

        # Replace the bound method by an unbound method.

        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)

        theList = theDict.get(ch,[])
        if rule not in theList:
            if atFront:
                theList.insert(0,rule)
            else:
                theList.append(rule)
            theDict [ch] = theList

    # g.trace(g.listToString(theDict.get('@')))
.. @+node:ekr.20110605121601.18578: *9* configure_tags
def configure_tags (self):

    trace = False and not g.unitTesting
    verbose = False
    traceColor = False
    traceFonts = True
    c = self.c ; w = self.w
    isQt = g.app.gui.guiName().startswith('qt')

    if trace: g.trace(self.colorizer.language) # ,g.callers(5))

    # The stated default is 40, but apparently it must be set explicitly.
    tabWidth = c.config.getInt('qt-tab-width') or 40
    w.widget.setTabStopWidth(tabWidth)

    if w and hasattr(w,'start_tag_configure'):
        w.start_tag_configure()

    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant",  "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont

    # Configure fonts.
    keys = list(self.default_font_dict.keys()) ; keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language,option_name),(option_name)):
            if trace: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found',name,id(font))
                w.tag_config(key,font=font)
                break
            else:
                family = c.config.get(name + '_family','family')
                size   = c.config.get(name + '_size',  'size')   
                slant  = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight','weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size   = size or c.config.defaultBodyFontSize
                    slant  = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family,size,slant,weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found',key,name,family,size,slant,weight,id(font))
                    w.tag_config(key,font=font)
                    break

        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default',key,font)
                self.fonts[key] = font # 2010/02/19: Essential
                w.tag_config(key,font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
                    
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04

    keys = list(self.default_colors_dict.keys()) ; keys.sort()
    for name in keys:
        option_name,default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language,option_name)) or
            c.config.getColor(option_name) or
            default_color
        )
        if trace and traceColor: g.trace(option_name,color)

        # Must use foreground, not fg.
        try:
            w.tag_configure(name, foreground=color)
        except: # Recover after a user error.
            g.es_exception()
            w.tag_configure(name, foreground=default_color)

    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        w.tag_configure("link",underline=1) # defined
        w.tag_configure("name",underline=0) # undefined
    else:
        w.tag_configure("link",underline=0)
        if self.underline_undefined:
            w.tag_configure("name",underline=1)
        else:
            w.tag_configure("name",underline=0)

    self.configure_variable_tags()

    # Colors for latex characters.  Should be user options...

    if 1: # Alas, the selection doesn't show if a background color is specified.
        w.tag_configure("latexModeBackground",foreground="black")
        w.tag_configure("latexModeKeyword",foreground="blue")
        w.tag_configure("latexBackground",foreground="black")
        w.tag_configure("latexKeyword",foreground="blue")
    else: # Looks cool, and good for debugging.
        w.tag_configure("latexModeBackground",foreground="black",background="seashell1")
        w.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
        w.tag_configure("latexBackground",foreground="black",background="white")
        w.tag_configure("latexKeyword",foreground="blue",background="white")

    # Tags for wiki coloring.
    w.tag_configure("bold",font=self.bold_font)
    w.tag_configure("italic",font=self.italic_font)
    w.tag_configure("bolditalic",font=self.bolditalic_font)
    for name in self.color_tags_list:
        w.tag_configure(name,foreground=name)

    try:
        w.end_tag_configure()
    except AttributeError:
        pass
.. @+node:ekr.20110605121601.18579: *9* configure_variable_tags
def configure_variable_tags (self):

    c = self.c ; w = self.w

    # g.trace()

    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80"),
        ("elide", None,                                   "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name,default_color = self.default_colors_dict.get(name,(None,None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            w.tag_configure(name,background=color)
        except: # A user error.
            w.tag_configure(name,background=default_color)

    # Special case:
    if not self.showInvisibles:
        w.tag_configure("elide",elide="1")
.. @+node:ekr.20110605121601.18580: *9* init (jeditColorizer)
def init (self,p,s):

    trace = False and not g.unitTesting

    if p: self.p = p.copy()
    self.all_s = s or ''

    if trace: g.trace('='*20,self.colorizer.language) #,g.callers(4))

    # State info.
    self.all_s = s
    self.global_i,self.global_j = 0,0
    self.global_offset = 0

    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.

    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
.. @+node:ekr.20110605121601.18581: *9* init_mode & helpers
def init_mode (self,name):

    '''Name may be a language name or a delegate name.'''

    trace = False and not g.unitTesting
    if not name: return False
    h = self.highlighter
    language,rulesetName = self.nameToRulesetName(name)
    # if trace: g.trace(name,list(self.modes.keys()))
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found',language,rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language,rulesetName)
        path = g.os_path_join(g.app.loadDir,'..','modes')
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        fileName = g.os_path_join(path,'%s.py' % (language))
        if g.os_path_exists(fileName):
            mode = g.importFromPath (language,path)
        else: mode = None

        if mode:
            # A hack to give modes/forth.py access to c.
            if hasattr(mode,'pre_init_mode'):
                mode.pre_init_mode(self.c)
        else:
            # Create a dummy bunch to limit recursion.
            self.modes [rulesetName] = self.modeBunch = g.Bunch(
                attributesDict  = {},
                defaultColor    = None,
                keywordsDict    = {},
                language        = 'unknown-language',
                mode            = mode,
                properties      = {},
                rulesDict       = {},
                rulesetName     = rulesetName,
                word_chars      = self.word_chars, # 2011/05/21
            )
            if trace: g.trace('***** No colorizer file: %s.py' % language)
            self.rulesetName = rulesetName
            self.language_name = 'unknown-language'
            return False
        self.colorizer.language = language
        self.rulesetName = rulesetName
        self.properties = hasattr(mode,'properties') and mode.properties or {}
        self.keywordsDict = hasattr(mode,'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName,{}) or {}
        self.setKeywords()
        self.attributesDict = hasattr(mode,'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
        # g.trace('*******',rulesetName,self.attributesDict)
        self.setModeAttributes()
        self.rulesDict = hasattr(mode,'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
        self.addLeoRules(self.rulesDict)

        self.defaultColor = 'null'
        self.mode = mode
        self.modes [rulesetName] = self.modeBunch = g.Bunch(
            attributesDict  = self.attributesDict,
            defaultColor    = self.defaultColor,
            keywordsDict    = self.keywordsDict,
            language        = self.colorizer.language,
            mode            = self.mode,
            properties      = self.properties,
            rulesDict       = self.rulesDict,
            rulesetName     = self.rulesetName,
            word_chars      = self.word_chars, # 2011/05/21
        )
        # Do this after 'officially' initing the mode, to limit recursion.
        self.addImportedRules(mode,self.rulesDict,rulesetName)
        self.updateDelimsTables()
        initialDelegate = self.properties.get('initialModeDelegate')
        if initialDelegate:
            if trace: g.trace('initialDelegate',initialDelegate)
            # Replace the original mode by the delegate mode.
            self.init_mode(initialDelegate)
            language2,rulesetName2 = self.nameToRulesetName(initialDelegate)
            self.modes[rulesetName] = self.modes.get(rulesetName2)
            self.language_name = language2  # 2011/05/30
        else:
            self.language_name = language  # 2011/05/30
        return True
.. @+node:ekr.20110605121601.18582: *10* nameToRulesetName
def nameToRulesetName (self,name):

    '''Compute language and rulesetName from name, which is either a language or a delegate name.'''

    if not name: return ''

    i = name.find('::')
    if i == -1:
        language = name
        rulesetName = '%s_main' % (language)
    else:
        language = name[:i]
        delegate = name[i+2:]
        rulesetName = self.munge('%s_%s' % (language,delegate))

    # if rulesetName == 'php_main': rulesetName = 'php_php'

    # g.trace(name,language,rulesetName)
    return language,rulesetName
.. @+node:ekr.20110605121601.18583: *10* setKeywords
def setKeywords (self):

    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.'''

    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d [key] = 'leoKeyword'

    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]

    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))

    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)

    # g.trace(self.colorizer.language,[str(z) for z in chars])

    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
.. @+node:ekr.20110605121601.18584: *10* setModeAttributes
def setModeAttributes (self):

    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''

    d = self.attributesDict
    aList = (
        ('default',         'null'),
	    ('digit_re',        ''),
        ('escape',          ''), # New in Leo 4.4.2.
	    ('highlight_digits',True),
	    ('ignore_case',     True),
	    ('no_word_sep',     ''),
    )

    # g.trace(d)

    for key, default in aList:
        val = d.get(key,default)
        if val in ('true','True'): val = True
        if val in ('false','False'): val = False
        setattr(self,key,val)
        # g.trace(key,val)
.. @+node:ekr.20110605121601.18585: *10* initModeFromBunch
def initModeFromBunch (self,bunch):

    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor   = bunch.defaultColor
    self.keywordsDict   = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode           = bunch.mode
    self.properties     = bunch.properties
    self.rulesDict      = bunch.rulesDict
    self.rulesetName    = bunch.rulesetName
    self.word_chars     = bunch.word_chars # 2011/05/21
.. @+node:ekr.20110605121601.18586: *10* updateDelimsTables
def updateDelimsTables (self):

    '''Update g.app.language_delims_dict if no entry for the language exists.'''

    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')

    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment,startComment,endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment,endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None

    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d [self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
.. @+node:ekr.20110605121601.18587: *9* munge
def munge(self,s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'

    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
.. @+node:ekr.20110605121601.18588: *9* setFontFromConfig
def setFontFromConfig (self):

    c = self.c
    # isQt = g.app.gui.guiName() == 'qt'

    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold")

    # if self.bold_font and not isQt:
        # self.bold_font.configure(weight="bold")

    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer italic")

    # if self.italic_font and not isQt:
        # self.italic_font.configure(slant="italic",weight="normal")

    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize) # , tag = "colorer bold italic")

    # if self.bolditalic_font and not isQt:
        # self.bolditalic_font.configure(weight="bold",slant="italic")

    self.color_tags_list = []
    # self.image_references = []
.. @+node:ekr.20110605121601.18589: *8*  Pattern matchers
.. @+node:ekr.20110605121601.18590: *9*  About the pattern matchers
@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
.. @+node:ekr.20110605121601.18591: *9* dump
def dump (self,s):

    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
.. @+node:ekr.20110605121601.18592: *9* Leo rule functions
.. @+node:ekr.20110605121601.18593: *10* match_at_color
def match_at_color (self,s,i):

    if self.trace_leo_matches: g.trace()

    seq = '@color'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,'leoKeyword')
        self.clearState()
        return j - i
    else:
        return 0
.. @+node:ekr.20110605121601.18594: *10* match_at_language
def match_at_language (self,s,i):

    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i,repr(s))

    seq = '@language'

    # Only matches at start of line.
    if i != 0: return 0

    if g.match_word(s,i,seq):
        j = i + len(seq)
        j = g.skip_ws(s,j)
        k = g.skip_c_id(s,j)
        name = s[j:k]
        ok = self.init_mode(name)
        if trace: g.trace(ok,name)
        if ok:
            self.colorRangeWithTag(s,i,k,'leoKeyword')
        self.clearState()
        return k - i
    else:
        return 0
.. @+node:ekr.20110605121601.18595: *10* match_at_nocolor & restarter
def match_at_nocolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i == 0 and not g.match(s,i,'@nocolor-') and g.match_word(s,i,'@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
.. @+node:ekr.20110605121601.18596: *11* restartNoColor
def restartNoColor (self,s):

    if self.trace_leo_matches: g.trace(repr(s))

    if g.match_word(s,0,'@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)

    return len(s) # Always match everything.
.. @+node:ekr.20110605121601.18597: *10* match_at_killcolor & restarter
def match_at_killcolor (self,s,i):

    if self.trace_leo_matches: g.trace(i,repr(s))

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@killcolor'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0

.. @+node:ekr.20110605121601.18598: *11* restartKillColor
def restartKillColor(self,s):

    self.setRestart(self.restartKillColor)
    return len(s)+1
.. @+node:ekr.20110605121601.18599: *10* match_at_nocolor_node & restarter
def match_at_nocolor_node (self,s,i):

    if self.trace_leo_matches: g.trace()

    # Only matches at start of line.
    if i != 0 and s[i-1] != '\n':
        return 0

    tag = '@nocolor-node'

    if g.match_word(s,i,tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
.. @+node:ekr.20110605121601.18600: *11* restartNoColorNode
def restartNoColorNode(self,s):

    self.setRestart(self.restartNoColorNode)
    return len(s)+1
.. @+node:ekr.20110605121601.18601: *10* match_blanks
def match_blanks (self,s,i):

    if not self.showInvisibles:
        return 0

    j = i ; n = len(s)

    while j < n and s[j] == ' ':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'blank')
        return j - i
    else:
        return 0
.. @+node:ekr.20110605121601.18602: *10* match_doc_part & restarter
def match_doc_part (self,s,i):

    # New in Leo 4.5: only matches at start of line.
    if i != 0:
        return 0
    elif g.match_word(s,i,'@doc'):
        j = i + 4
    elif g.match(s,i,'@') and (i+1 >= len(s) or s[i+1] in (' ','\t','\n')):
        j = i + 1
    else:
        return 0

    self.colorRangeWithTag(s,i,j,'leoKeyword')
    self.colorRangeWithTag(s,j,len(s),'docPart')
    self.setRestart(self.restartDocPart)

    return len(s)
.. @+node:ekr.20110605121601.18603: *11* restartDocPart
def restartDocPart (self,s):

    for tag in ('@c','@code'):
        if g.match_word(s,0,tag):
            j = len(tag)
            self.colorRangeWithTag(s,0,j,'leoKeyword') # 'docPart')
            self.clearState()
            return j
    else:
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s,0,len(s),'docPart')

        return len(s)
.. @+node:ekr.20110605121601.18604: *10* match_leo_keywords
def match_leo_keywords(self,s,i):

    '''Succeed if s[i:] is a Leo keyword.'''

    # g.trace(i,g.get_line(s,i))

    self.totalLeoKeywordsCalls += 1

    if s[i] != '@':
        return 0

    # fail if something besides whitespace precedes the word on the line.
    i2 = i-1
    while i2 >= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ','\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0

    # Get the word as quickly as possible.
    j = i+1
    while j < len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i+1:j] # entries in leoKeywordsDict do not start with '@'.

    if j < len(s) and s[j] not in (' ','\t','\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.

    if self.leoKeywordsDict.get(word):
        kind = 'leoKeyword'
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j-i+1 # Bug fix: skip the last character.
        self.trace_match(kind,s,i,j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s,i,j,kind)
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            # g.trace('found',word)
            return j-i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j-i+1) # An important optimization.
.. @+node:ekr.20110605121601.18605: *10* match_section_ref
def match_section_ref (self,s,i):

    if self.trace_leo_matches: g.trace()
    c = self.c ; p = c.currentPosition()
    w = self.w

    if not g.match(s,i,'<<'):
        return 0
    k = g.find_on_line(s,i+2,'>>')
    if k is not None:
        j = k + 2
        self.colorRangeWithTag(s,i,i+2,'nameBrackets')
        ref = g.findReference(c,s[i:j],p)
        if ref:
            if self.use_hyperlinks:
                << set the hyperlink >>
            else:
                self.colorRangeWithTag(s,i+2,k,'link')
        else:
            self.colorRangeWithTag(s,i+2,k,'name')
        self.colorRangeWithTag(s,k,j,'nameBrackets')
        return j - i
    else:
        return 0
.. @+node:ekr.20110605121601.18606: *11* << set the hyperlink >>
# Set the bindings to vnode callbacks.
# Create the tag.
# Create the tag name.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
w.tag_delete(tagName)
w.tag_add(tagName,i+2,j)

ref.tagName = tagName
c.tag_bind(w,tagName,"<Control-1>",ref.OnHyperLinkControlClick)
c.tag_bind(w,tagName,"<Any-Enter>",ref.OnHyperLinkEnter)
c.tag_bind(w,tagName,"<Any-Leave>",ref.OnHyperLinkLeave)
.. @+node:ekr.20110605121601.18607: *10* match_tabs
def match_tabs (self,s,i):

    if not self.showInvisibles:
        return 0

    if self.trace_leo_matches: g.trace()

    j = i ; n = len(s)

    while j < n and s[j] == '\t':
        j += 1

    if j > i:
        self.colorRangeWithTag(s,i,j,'tab')
        return j - i
    else:
        return 0
.. @+node:ekr.20110605121601.18608: *10* match_url_any/f/h  (new)
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")

def match_any_url(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):

def match_url_f(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_f)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
    
def match_url_h(self,s,i):
    
    return self.match_compiled_regexp(s,i,kind='url',regexp=self.url_regex_h)
        # at_line_start=False,at_whitespace_end=False,at_word_start=False,delegate=''):
.. @+node:ekr.20110605121601.18609: *9* match_compiled_regexp (new)
def match_compiled_regexp (self,s,i,kind,regexp,delegate=''):

    '''Succeed if the compiled regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_compiled_regexp_helper(s,i,regexp)
    if n > 0:
        j = i + n
        assert (j-i == n)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
.. @+node:ekr.20110605121601.18610: *10* match_compiled_regexp_helper
def match_compiled_regexp_helper (self,s,i,regex):
    
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
.. @+node:ekr.20110605121601.18611: *9* match_eol_span
def match_eol_span (self,s,i,
    kind=None,seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if seq matches s[i:]'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        return 0

    if g.match(s,i,seq):
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
.. @+node:ekr.20110605121601.18612: *9* match_eol_span_regexp
def match_eol_span_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False):

    '''Succeed if the regular expression regex matches s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,regexp)
    if n > 0:
        j = len(s)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
        return j - i
    else:
        return 0
.. @+node:ekr.20110605121601.18613: *9* match_everything
# def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):

    # '''Match the entire rest of the string.'''

    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    # return j
.. @+node:ekr.20110605121601.18614: *9* match_keywords
# This is a time-critical method.
def match_keywords (self,s,i):

    '''Succeed if s[i:] is a keyword.'''

    # trace = False
    self.totalKeywordsCalls += 1

    # Important.  Return -len(word) for failure greatly reduces
    # the number of times this method is called.

    # We must be at the start of a word.
    if i > 0 and s[i-1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0

    # Get the word as quickly as possible.
    j = i ; n = len(s) ; chars = self.word_chars
    while j < n and s[j] in chars:
        j += 1

    word = s[i:j]
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s,i,j,kind)
        self.prev = (i,j,kind)
        result = j - i
        # if trace: g.trace('success',word,kind,j-i)
        self.trace_match(kind,s,i,j)
        return result
    else:
        # if trace: g.trace('fail',word,kind)
        return -len(word) # An important new optimization.
.. @+node:ekr.20110605121601.18615: *9* match_line
def match_line (self,s,i,kind=None,delegate='',exclude_match=False):

    '''Match the rest of the line.'''

    j = g.skip_to_end_of_line(s,i)

    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)

    return j-i
.. @+node:ekr.20110605121601.18616: *9* match_mark_following & getNextToken
def match_mark_following (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    trace = (True or self.verbose) and not g.unitTesting
    if not self.allow_mark_prev: return 0

    # if trace: g.trace(g.callers(1),i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 < len(s) and s[i+len(pattern)] in self.word_chars:
        return 0 # 7/5/2008

    if g.match(s,i,pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s,j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k > j:
            self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,k,kind,exclude_match=False)
            j = k
            self.prev = (i,j,kind)
            self.trace_match(kind,s,i,j)
            return j - i
        else:
            return 0
    else:
        return 0
.. @+node:ekr.20110605121601.18617: *10* getNextToken
def getNextToken (self,s,i):

    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?

    while i < len(s) and s[i] in self.word_chars:
        i += 1

    # 2011/05/31: was i+1
    return min(len(s),i)
.. @+node:ekr.20110605121601.18618: *9* match_mark_previous
def match_mark_previous (self,s,i,
    kind='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''

    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
.. @+node:ekr.20110605121601.18619: *9* match_regexp_helper
def match_regexp_helper (self,s,i,pattern):

    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''

    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language,pattern,s)) # g.callers(1)

    try:
        flags = re.MULTILINE
        if self.ignore_case: flags|= re.IGNORECASE
        re_obj = re.compile(pattern,flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0

    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s,i) # re_obj.search(s,i) 

    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern',pattern)
            g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
            g.trace('groups',mo.groups())
        return end - start
.. @+node:ekr.20110605121601.18620: *9* match_seq
def match_seq (self,s,i,
    kind='',seq='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if s[:] mathces seq.'''

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:  # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 < len(s) and s[i+len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s,i,seq):
        j = i + len(seq)
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j)
    else:
        j = i
    return j - i
.. @+node:ekr.20110605121601.18621: *9* match_seq_regexp
def match_seq_regexp (self,s,i,
    kind='',regexp='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate=''):

    '''Succeed if the regular expression regexp matches at s[i:].'''

    if self.verbose: g.trace(g.callers(1),i,repr(s[i:i+20]),'regexp',regexp)

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0

    n = self.match_regexp_helper(s,i,regexp)
    j = i + n
    assert (j-i == n)
    self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    self.prev = (i,j,kind)
    self.trace_match(kind,s,i,j)
    return j - i
.. @+node:ekr.20110605121601.18622: *9* match_span & helper & restarter
def match_span (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False,no_word_break=False):

    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''

    trace = False and not g.unitTesting
    if i >= len(s): return 0

    # g.trace(begin,end,no_escape,no_line_break,no_word_break)

    if at_line_start and i != 0 and s[i-1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s,0):
        j = i
    elif at_word_start and i > 0 and s[i-1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        j = i
    elif not g.match(s,i,begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s,i+len(begin),end,
            no_escape,no_line_break,no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin) ; j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s,i,i2,kind,delegate=None,    exclude_match=exclude_match)
                self.colorRangeWithTag(s,i2,j,kind,delegate=delegate,exclude_match=exclude_match)
                self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
            j = j2
            self.prev = (i,j,kind)

    self.trace_match(kind,s,i,j)

    if j > len(s):
        j = len(s) + 1
        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Continuing',kind,i,j,len(s))
    elif j != i:
        if trace: g.trace('***Ending',kind,i,j,s[i:j])
        self.clearState()

    return j - i # Correct, whatever j is.
.. @+node:ekr.20110605121601.18623: *10* match_span_helper
def match_span_helper (self,s,i,pattern,no_escape,no_line_break,no_word_break):

    '''Return n >= 0 if s[i] ends with a non-escaped 'end' string.'''

    esc = self.escape

    while 1:
        j = s.find(pattern,i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s)+1
        elif no_word_break and j > 0 and s[j-1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i:j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == esc:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # Continue searching past the escaped pattern string.
                i = j + len(pattern) # Bug fix: 7/25/07.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
.. @+node:ekr.20110605121601.18624: *10* restart_match_span
def restart_match_span (self,s,
    delegate,end,exclude_match,kind,
    no_escape,no_line_break,no_word_break):

    '''Remain in this state until 'end' is seen.'''

    trace = False and not g.unitTesting

    i = 0
    j = self.match_span_helper(s,i,end,no_escape,no_line_break,no_word_break)
    if j == -1:
        j2 = len(s)+1
    elif j > len(s):
        j2 = j
    else:
        j2 = j + len(end)

    if delegate:
        self.colorRangeWithTag(s,i,j,kind,delegate=delegate,exclude_match=exclude_match)
        self.colorRangeWithTag(s,j,j2,kind,delegate=None,    exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
    j = j2

    self.trace_match(kind,s,i,j)

    if j > len(s):
        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate,end,exclude_match,kind,
                no_escape,no_line_break,no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate,end=end,kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)

        if trace: g.trace('***Re-continuing',i,j,len(s),s,g.callers(5))
    else:
        if trace: g.trace('***ending',i,j,len(s),s)
        self.clearState()

    return j # Return the new i, *not* the length of the match.
.. @+node:ekr.20110605121601.18625: *9* match_span_regexp
def match_span_regexp (self,s,i,
    kind='',begin='',end='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    delegate='',exclude_match=False,
    no_escape=False,no_line_break=False, no_word_break=False,
):

    '''Succeed if s[i:] starts with 'begin' (a regular expression) and contains a following 'end'.'''

    if self.verbose: g.trace('begin',repr(begin),'end',repr(end),self.dump(s[i:]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 < len(s) and s[i+len(begin)] in self.word_chars:
        return 0 # 7/5/2008

    n = self.match_regexp_helper(s,i,begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n > 0:
        j = i + n
        j2 = s.find(end,j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0 ; k = 1
            while j-k >=0 and s[j-k] == self.escape:
                escapes += 1 ; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s,i,j,kind, delegate=None,     exclude_match=exclude_match)
            self.colorRangeWithTag(s,j,i2,kind, delegate=delegate,exclude_match=False)
            self.colorRangeWithTag(s,i2,j2,kind,delegate=None,    exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s,i,j2,kind,delegate=None,exclude_match=exclude_match)
        self.prev = (i,j,kind)
        self.trace_match(kind,s,i,j2)
        return j2 - i
    else: return 0
.. @+node:ekr.20110605121601.18626: *9* match_word_and_regexp
def match_word_and_regexp (self,s,i,
    kind1='',word='',
    kind2='',pattern='',
    at_line_start=False,at_whitespace_end=False,at_word_start=False,
    exclude_match=False):

    '''Succeed if s[i:] matches pattern.'''

    if not self.allow_mark_prev: return 0

    if (False or self.verbose): g.trace(i,repr(s[i:i+20]))

    if at_line_start and i != 0 and s[i-1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s,0): return 0
    if at_word_start and i > 0 and s[i-1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 < len(s) and s[i+len(word)] in self.word_chars:
        j = i

    if not g.match(s,i,word):
        return 0

    j = i + len(word)
    n = self.match_regexp_helper(s,j,pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s,i,j,kind1,exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s,j,k,kind2,exclude_match=False)    
    self.prev = (j,k,kind2)
    self.trace_match(kind1,s,i,j)
    self.trace_match(kind2,s,j,k)
    return k - i
.. @+node:ekr.20110605121601.18627: *9* skip_line
def skip_line (self,s,i):

    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i < len(s):
            j = g.skip_line(s,i)
            if not g.match(s,j-n,escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s,i)
            # Include the newline so we don't get a flash at the end of the line.
.. @+node:ekr.20110605121601.18628: *9* trace_match
def trace_match(self,kind,s,i,j):

    if j != i and self.trace_match_flag:
        g.trace(kind,i,j,g.callers(2),self.dump(s[i:j]))
.. @+node:ekr.20110605121601.18629: *8*  State methods
.. @+node:ekr.20110605121601.18630: *9* clearState
def clearState (self):

    self.setState(-1)
.. @+node:ekr.20110605121601.18631: *9* computeState
def computeState (self,f,keys):

    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''

    # Abbreviate arg names.
    d = {
        'delegate':'del:',
        'end':'end',
        'at_line_start':'line-start',
        'at_whitespace_end':'ws-end',
        'exclude_match':'exc-match',
        'no_escape':'no-esc',
        'no_line_break':'no-brk',
        'no_word_break':'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key,val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None,''):
            result.append('%s=%s' % (key,keyVal))
    state = ';'.join(result)

    n = self.stateNameToStateNumber(f,state)
    return n
.. @+node:ekr.20110605121601.18632: *9* currentState and prevState
def currentState(self):

    return self.highlighter.currentBlockState()

def prevState(self):

    return self.highlighter.previousBlockState()
.. @+node:ekr.20110605121601.18633: *9* setRestart
def setRestart (self,f,**keys):

    n = self.computeState(f,keys)
    self.setState(n)
.. @+node:ekr.20110605121601.18634: *9* setState
def setState (self,n):

    trace = False and not g.unitTesting

    self.highlighter.setCurrentBlockState(n)

    if trace:
        stateName = self.showState(n)
        g.trace(stateName,g.callers(4))
.. @+node:ekr.20110605121601.18635: *9* showState & showCurrentState
def showState (self,n):

    if n == -1: 
        return 'default-state'
    else:
        return self.stateDict.get(n,'<no state>')

def showCurrentState(self):

    n = self.currentState()
    return self.showState(n)

def showPrevState(self):

    n = self.prevState()
    return self.showState(n)
.. @+node:ekr.20110605121601.18636: *9* stateNameToStateNumber
def stateNameToStateNumber (self,f,stateName):

    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions

    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)

    return n
.. @+node:ekr.20110605121601.18637: *8* colorRangeWithTag
def colorRangeWithTag (self,s,i,j,tag,delegate='',exclude_match=False):

    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''

    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.

    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return

    if delegate:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate,tag)),i,j,s2,g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 <= i < j and i < len(s):
            progress = i
            assert j >= 0,j
            for f in self.rulesDict.get(s[i],[]):
                n = f(self,s,i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n > 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n ; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag,s,i,i+1)
                i += 1
            assert i > progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = g.choose(len(repr(s[i:j])) <= 20,repr(s[i:j]),repr(s[i:i+17-2]+'...'))
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name,tag)),i,j,s2,g.callers(2)))
        self.setTag(tag,s,i,j)
        
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j,len(s))
        while i < j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s,i)
                i += max(1,n)
            else:
                i += 1
.. @+node:ekr.20110605121601.18638: *8* mainLoop & restart
def mainLoop(self,n,s):

    '''Colorize a *single* line s, starting in state n.'''

    trace = False and not g.unitTesting
    traceMatch = False
    traceState = False
    verbose = False
    
    if trace:
        if traceState:
            g.trace('** start',self.showState(n),repr(s))
        else:
            g.trace(self.language_name,repr(s)) # ,g.callers(6))
                # Called from recolor.

    i = 0
    if n > -1:
        i = self.restart(n,s,trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
        
    ### last_i = i

    while i < len(s):
        progress = i
        functions = self.rulesDict.get(s[i],[])
        for f in functions:
            n = f(self,s,i)
            if n is None:
                g.trace('Can not happen: n is None',repr(f))
                break
            elif n > 0: # Success.
                if trace and traceMatch and f.__name__!='match_blanks':
                    g.trace('match: %20s %s' % (
                        f.__name__,s[i:i+n]))
                # The match has already been colored.
                ### if last_i < i:
                    ### self.colorRangeWithTag(s,last_i,i,'default')
                i += n
                ### last_i = i
                break # Stop searching the functions.
            elif n < 0: # Fail and skip n chars.
                if trace and traceMatch and verbose:
                    g.trace('fail: %20s %s' % (
                        f.__name__,s[i:i+n]))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i > progress

    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceState:
        g.trace('** end',self.showCurrentState(),s)
.. @+node:ekr.20110605121601.18639: *9* restart
def restart (self,n,s,traceMatch):

    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i > 0:
                g.trace('** restart match',fname,s[:i])
            else:
                g.trace('** restart fail',fname,s)
    else:
        g.trace('**** no restart f')
        i = 0

    return i
.. @+node:ekr.20110605121601.18640: *8* recolor
def recolor (self,s):

    '''Recolor a *single* line, s.'''

    trace = False and not g.unitTesting
    callers = False ; line = True ; state = True

    # Update the counts.
    self.recolorCount += 1
    self.totalChars += len(s)

    if self.colorizer.changingText:
        return
    if not self.colorizer.flag:
        return

    # Get the previous state.
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if line and state:
            g.trace('%2s %s %s' % (n,self.showState(n),repr(s)))
        elif line:
            g.trace('%2s %s' % (n,repr(s)))
        if callers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())

    if s.strip() or self.showInvisibles:
        self.mainLoop(n,s)
    else:
        self.setState(n) # Required
.. @+node:ekr.20110605121601.18641: *8* setTag
def setTag (self,tag,s,i,j):

    trace = False and not g.unitTesting

    if i == j:
        if trace: g.trace('empty range')
        return

    w = self.w
    colorName = w.configDict.get(tag)

    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return

    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[:-1]

    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name',colorName)

    underline = w.configUnderlineDict.get(tag)

    format = QtGui.QTextCharFormat()

    font = self.fonts.get(tag)
    if font:
        format.setFont(font)

    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i,j,len(s),font and id(font) or '<no font>',colorName),
            '%-10s %-25s' % (tag,s[i:j]),g.callers(2))

    if tag in ('blank','tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)

    self.highlighter.setFormat (i,j-i,format)

.. @+node:ekr.20110930075237.15472: *5* Improving Leo: think inside the box
@nocolor-node

There is plenty of room for improving Leo, and my recent energy spike
promises to carry over to Leo itself.  Here are the major areas that I
see that can be improved:

1. Windows.

Terry's work is an enabler.  Just as Blender supports many kinds of
windows, so too should Leo.  Up until now, the outline, body and log
panes have been the only "official" panes.  The rendering pane soon
will be fully official.

Terry's plugins have also created nifty new windows.

Here are some other ideas:

A.  Hosting the PyQt demo inside Leo.

B.  Making an OpenGL window an official Leo window.  This might be the
start of a prototype for "Blender in a Leo Window"

2. Keystrokes

Restarting the vim-keys project is conceivable.  I stopped work on the
project when I realized that vim bindings only make sense when
*commands* can be composed as in vim.

3. Bridges

This could be an important "new" direction.  True, there are already
bridges for vim, emacs, ipython and docutils, but I think more can be
done.

The first thought is to improve Leo's inter-process communication
capabilities.  I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in
order to resize vim, say, to it automatically tracks Leo's body pane
(or any other pane).

4. Code tools

Analysis, checking, refactoring and other code-level tools are a
natural for Leo.  When the new-lint project is mature, it could be
folded into Leo.

5. Documentation

Perhaps Leo's documentation could be built primarily from docstrings.
In any event, documentation tools are always needed.
.. @+node:ekr.20110930075237.15473: *6* Kent's suggestions
@nocolor-node

Buttons:
Enhance the button machinery to allow mixed case, spaces, colors.
Provide cascading rclick capability: rclick on an rclick list ...

Templating:
Solid, simple implementation of one of the standard template engines
providing intuitive template nodes, variable definitions, and rendering options.

Wizards:
Leverage the template capability to offer form-based content creation:
- create a plugin
- generate a test node
- generate a wizard :-]

LeoFS:
- create a Leo implementation of pyfilesystem
http://packages.python.org/fs/implementersguide.html

Enhanced node attributes:
ctime, atime, mtime


Remove expansion data from .leo file:
    
    @bool put_expansion_bits_in_leo_files = False
    
    It would be possible to put expansion bits in c.db. The key would be the
    gnx, so it would be straightforward. We could even eliminate the option
    entirely...

- provide persistence of tab status
 (resume editing with same tabs open when using tabbed gui)
.. @+node:ekr.20110930075237.15474: *6* Matt Wilkie
@nocolor-node

As for user interface, I'd love to see myLeoSettings with a checkbox
interface and filter bar at the top, and a feature to "merge or reset
from LeoSettings".
... or maybe something like Firefox's "about:config" would be better
suited (and probably faster to build).
.. @+node:ekr.20110929074744.15449: *5* generalize show/hide/select gui elements commands
@nocolor-node

tab-cycle-next makes the following not so important

There is a relationship here with mouseless
programming.  It would seem that all visual elements, especially those
that may exist in multiple versions, must have a name or other
description suitable for generalized commands.

The user might want multiple rendering panes, especially if
one or more are locked.  Without a description, there is no way to
specify exactly what show/hide-rendering pane does.

I haven't forgotten the autocompleter docs.  I'll get to them next.
It looks like autocompletion would be the way to generalize the not-
very-effect commands that switch focus from one ui element to
another.  A related benefit is one generalized command might be more
convenient to use than the present flavors of (buggy) cycle-focus
commands.

In short, contemplating generalized windows leads us to generalized
select/delete/show/hide commands, based on autocompletion, that work
on various ui elements.  This looks like the next project. 
.. @+node:ekr.20110929165422.15449: *5* Add expand_noweb_references for rst3 plugin
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
.. @+node:ekr.20110929165422.15450: *6* post
@nocolor-node

I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  <<code fragment>>

Unfortunately, <<code fragment>> will not be expanded. Furthermore, in order to
get to this work, I should have <<code fragment>> under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
.. @+node:ekr.20110929165422.15451: *6* writeBody & helpers
def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n') 

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
.. @+node:ekr.20110929165422.15452: *7* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
.. @+node:ekr.20110929165422.15453: *8* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
.. @+node:ekr.20110929165422.15454: *8* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
.. @+node:ekr.20110929165422.15455: *8* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
.. @+node:ekr.20110929165422.15456: *7* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
.. @+node:ekr.20110929165422.15457: *7* isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
.. @+node:ekr.20110929165422.15458: *7* isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
.. @+node:ekr.20110929165422.15459: *7* isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
.. @+node:ekr.20110929165422.15460: *7* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20110929165422.15461: *7* handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
.. @+node:ekr.20110929165422.15462: *7* replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
.. @+node:ekr.20111004090723.15491: *5* Fix broken link in docs
> In this node of LeoDocs.leo:
> Users Guide-->Basics-->FAQ-->@file FAQ.txt-->@rst html\FAQ.html-->Tips and
> techniques-->How can I display graphics in Leo?
>
> It introduce a link of sourceforge forum, but the page seems not exist or
> disabled.
> http://sourceforge.net/forum/forum.php?thread_id=1201579&forum_id=10226
.. @+node:ekr.20111006183053.7091: *5* Why doesn't embedded Leo draw icons?
.. @+node:ekr.20110605121601.18412: *6* getCompositeIconImage
def getCompositeIconImage(self,p,val):

    trace = False and not g.unitTesting
    userIcons = self.c.editCommands.getIconList(p)
    if not userIcons:
        # if trace: g.trace('no userIcons')
        return self.getStatusIconImage(p)

    hash = [i['file'] for i in userIcons if i['where'] == 'beforeIcon']
    hash.append(str(val))
    hash.extend([i['file'] for i in userIcons if i['where'] == 'beforeHeadline'])
    hash = ':'.join(hash)

    if hash in g.app.gui.iconimages:
        icon = g.app.gui.iconimages[hash]
        if trace: g.trace('cached %s' % (icon))
        return icon

    images = [g.app.gui.getImageImage(i['file']) for i in userIcons
             if i['where'] == 'beforeIcon']
    images.append(g.app.gui.getImageImage("box%02d.GIF" % val))
    images.extend([g.app.gui.getImageImage(i['file']) for i in userIcons
                  if i['where'] == 'beforeHeadline'])
    width = sum([i.width() for i in images])
    height = max([i.height() for i in images])

    pix = QtGui.QPixmap(width,height)
    pix.fill()
    pix.setAlphaChannel(pix)
    painter = QtGui.QPainter(pix)
    x = 0
    for i in images:
        painter.drawPixmap(x,(height-i.height())//2,i)
        x += i.width()
    painter.end()

    icon = QtGui.QIcon(pix)
    g.app.gui.iconimages[hash] = icon
    if trace: g.trace('new %s' % (icon))
    return icon
.. @+node:ekr.20110605121601.18516: *6* getIconImage (qtGui)
def getIconImage (self,name):

    '''Load the icon and return it.'''

    trace = False and not g.unitTesting

    # Return the image from the cache if possible.
    if name in self.iconimages:
        image = self.iconimages.get(name)
        if trace: ### and not name.startswith('box'):
            g.trace('cached',id(image),name,image)
        return image
    try:
        iconsDir = g.os_path_join(g.app.loadDir,"..","Icons")
        homeIconsDir = g.os_path_join(g.app.homeLeoDir,"Icons")
        for theDir in (homeIconsDir,iconsDir):
            fullname = g.os_path_finalize_join(theDir,name)
            if g.os_path_exists(fullname):
                if 0: # Not needed: use QTreeWidget.setIconsize.
                    pixmap = QtGui.QPixmap()
                    pixmap.load(fullname)
                    image = QtGui.QIcon(pixmap)
                else:
                    image = QtGui.QIcon(fullname)
                    if trace: g.trace('name',fullname,'image',image)
        
                self.iconimages[name] = image
                if trace: g.trace('new',id(image),theDir,name)
                return image
            elif trace: g.trace('Directory not found',theDir)
        else:
            if trace: g.trace('Not found',name)
            return None

    except Exception:
        g.es_print("exception loading:",fullname)
        g.es_exception()
        return None
.. @+node:ekr.20110605121601.17948: *6* getStatusIconImage
def getStatusIconImage (self,p):

    val = p.v.computeIcon()

    r = g.app.gui.getIconImage(
        "box%02d.GIF" % val)
        
    # g.trace(r)
    
    return r
.. @+node:ekr.20110929165422.15431: *4* Fun scripts
.. @+node:ekr.20110919113533.6818: *5* split-defs-into-node
.. @+node:ekr.20110919113533.6820: *6* methods
# Normalize a type. Replaces type with fully qualified version
def normalize_type(ty):
    SwigType *qty
    if CPlusPlus:
        Replaceall(ty,"struct ","")
        Replaceall(ty,"union ","")
        Replaceall(ty,"class ","")
    qty = SwigType_typedef_qualified(ty)
    #    Printf(stdout,"%s -. %s\n",ty,qty);
    Clear(ty)
    Append(ty,qty)
    Delete(qty)
# Normaldef normalize_parms(p):
#     while(p)
#         SwigType *ty = Getattr(p,"type");
#         normalize_type(ty);
#         /* This is a check for a function type
            SwigType *qty = SwigType_typedef_resolve_all(ty)
            if SwigType_isfunction(qty):
                SwigType_add_pointer(ty)
            Delete(qty)
        String *value = Getattr(p,"value")
        if value:
            Node *n = Swig_symbol_clookup(value,0)
            if n:
                String *q = Swig_symbol_qualified(n)
                if q and Len(q):
                    String *vb = Swig_scopename_last(value)
                    Clear(value)
                    Printf(value,"%s::%s",SwigType_namestr(q),vb)
                    Delete(q)
        if value and SwigType_istemplate(value):
            String *nv = SwigType_namestr(value)
            Setattr(p,"value",nv)
        p = nextSibling(p)
void normalize_later(ParmList *p)
    while p:
        SwigType *ty = Getattr(p,"type")
        Append(normalize,ty)
        p = nextSibling(p)
# Walk through entries in normalize list and patch them up
def normalize_list():
    Hash *currentsym = Swig_symbol_current()
    normal_node *nn = patch_list
    normal_node *np
    while nn:
        Swig_symbol_setscope(nn.symtab)
        SwigType_set_scope(nn.typescope)
        Iterator t
        for t = First(nn.normallist); t.item; t = Next(t):
            normalize_type(t.item)
        Delete(nn.normallist)
        np = nn.next
        delete(nn)
        nn = np
    Swig_symbol_setscope(currentsym)
# generate C++ inheritance type-relationships
def cplus_inherit_types_impl(first,cls,clsname,bases,baselist,ispublic,cast):
    if first == cls:
        return
    			# The Marcelo check
    if !cls:
        cls = first
    List *alist = 0
    List *ilist = Getattr(cls,bases)
    if !ilist:
        List *nlist = Getattr(cls,baselist)
        if nlist:
             len = Len(nlist)
             i
            for i = 0; i < len; i++:
                Node *bcls = 0
                 clsforward = 0
                String *bname = Getitem(nlist,i)
                String *sname = bname
                String *tname = 0
                # Try to locate the base class.   We look in the symbol table and we chase
#      typedef declarations to get to the base class if necessary
                Symtab *st = Getattr(cls,"sym:symtab")
                if SwigType_istemplate(bname):
                    tname = SwigType_typedef_resolve_all(bname)
                    sname = tname
                while 1:
                    String *qsname = SwigType_typedef_qualified(sname)
                    bcls = Swig_symbol_clookup(qsname,st)
                    Delete(qsname)
                    if bcls:
                        if Strcmp(nodeType(bcls),"class")!= 0:
                            # Not a class.   The symbol could be a typedef.
                            if checkAttribute(bcls,"storage","typedef"):
                                SwigType *decl = Getattr(bcls,"decl")
                                if !decl or !(Len(decl)):
                                    sname = Getattr(bcls,"type")
                                    st = Getattr(bcls,"sym:symtab")
                                    if SwigType_istemplate(sname):
                                        if tname:
                                            Delete(tname)
                                        tname = SwigType_typedef_resolve_all(sname)
                                        sname = tname
                                    continue
                            if Strcmp(nodeType(bcls),"classforward")!= 0:
                                Swig_error(Getfile(bname),Getline(bname),"'%s' is not a valid base class.\n",SwigType_namestr(bname))
                                Swig_error(Getfile(bcls),Getline(bcls),"See definition of '%s'.\n",SwigType_namestr(bname))
                             else:
                                Swig_warning(WARN_TYPE_INCOMPLETE,Getfile(bname),Getline(bname),"Base class '%s' is incomplete.\n",SwigType_namestr(bname))
                                Swig_warning(WARN_TYPE_INCOMPLETE,Getfile(bcls),Getline(bcls),"Only forward declaration '%s' was found.\n",SwigType_namestr(bname))
                                clsforward = 1
                            bcls = 0
                         else:
                            if Getattr(bcls,"typepass:visit"):
                                if !ilist:
                                    ilist = alist = NewList()
                                Append(ilist,bcls)
                             else:
                                Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bname),Getline(bname),"Base class '%s' undefined.\n",SwigType_namestr(bname))
                                Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bcls),Getline(bcls),"'%s' must be defined before it is used as a base class.\n",SwigType_namestr(bname))
                    break
                if tname:
                    Delete(tname)
                if !bcls:
                    if !clsforward:
                        if ispublic and !Getmeta(bname,"already_warned"):
                            Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bname),Getline(bname),"Nothing known about base class '%s'. Ignored.\n",SwigType_namestr(bname))
                            if Strchr(bname,'<'):
                                Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bname),Getline(bname),"Maybe you forgot to instantiate '%s' using %%template.\n",SwigType_namestr(bname))
                            Setmeta(bname,"already_warned","1")
                    SwigType_inherit(clsname,bname,cast,0)
        if ilist:
            Setattr(cls,bases,ilist)
    if alist:
        Delete(alist)
    if !ilist:
        return
     len = Len(ilist)
     i
    for i = 0; i < len; i++:
        Node *n = Getitem(ilist,i)
        String *bname = Getattr(n,"name")
        Node *bclass = n; # Getattr(n,"class");
        Hash *scopes = Getattr(bclass,"typescope")
        SwigType_inherit(clsname,bname,cast,0)
        String *smartptr = Getattr(first,"feature:smartptr")
        if smartptr:
            SwigType *smart = 0
            SwigType *spt = Swig_cparse_type(smartptr)
            if spt:
                smart = SwigType_typedef_resolve_all(spt)
                Delete(spt)
                # Record a(fake)inheritance relationship between smart pointer
#      and smart pointer to base class,so that smart pointer upcasts
#      are automatically generated.
                SwigType *bsmart = Copy(smart)
                SwigType *rclsname = SwigType_typedef_resolve_all(clsname)
                SwigType *rbname = SwigType_typedef_resolve_all(bname)
                Replaceall(bsmart,rclsname,rbname)
                Delete(rclsname)
                Delete(rbname)
                String *smartnamestr = SwigType_namestr(smart)
                String *bsmartnamestr = SwigType_namestr(bsmart)
                # construct casting code
                String *convcode = NewStringf("\n    *newmemory = SWIG_CAST_NEW_MEMORY;\n    return(void *)new %s(*(%s *)$from);\n",bsmartnamestr,smartnamestr)
                Delete(bsmartnamestr)
                Delete(smartnamestr)
                # setup inheritance relationship between smart pointer templates
                SwigType_inherit(smart,bsmart,0,convcode)
                if !GetFlag(bclass,"feature:smartptr"):
                    Swig_warning(WARN_LANG_SMARTPTR_MISSING,Getfile(first),Getline(first),"Base class '%s' of '%s' is not similarly marked as a smart pointer.\n",SwigType_namestr(Getattr(bclass,"name")),SwigType_namestr(Getattr(first,"name")))
                Delete(convcode)
                Delete(bsmart)
                Delete(smart)
             else:
                Swig_error(Getfile(first),Getline(first),"Invalid type(%s)in 'smartptr' feature for class %s.\n",SwigType_namestr(smartptr),SwigType_namestr(clsname))
         else:
            if GetFlag(bclass,"feature:smartptr"):
                Swig_warning(WARN_LANG_SMARTPTR_MISSING,Getfile(first),Getline(first),"Derived class '%s' of '%s' is not similarly marked as a smart pointer.\n",SwigType_namestr(Getattr(first,"name")),SwigType_namestr(Getattr(bclass,"name")))
        if !importmode:
            String *btype = Copy(bname)
            SwigType_add_pointer(btype)
            SwigType_remember(btype)
            Delete(btype)
        if scopes:
            SwigType_inherit_scope(scopes)
        # Set up inheritance in the symbol table
        Symtab *st = Getattr(cls,"symtab")
        Symtab *bst = Getattr(bclass,"symtab")
        if st == bst:
            Swig_warning(WARN_PARSE_REC_INHERITANCE,Getfile(cls),Getline(cls),"Recursive scope inheritance of '%s'.\n",SwigType_namestr(Getattr(cls,"name")))
            continue
        Symtab *s = Swig_symbol_current()
        Swig_symbol_setscope(st)
        Swig_symbol_inherit(bst)
        Swig_symbol_setscope(s)
        # Recursively hit base classes
        String *namestr = SwigType_namestr(Getattr(bclass,"name"))
        String *newcast = NewStringf("(%s *)%s",namestr,cast)
        Delete(namestr)
        cplus_inherit_types_impl(first,bclass,clsname,bases,baselist,ispublic,newcast)
        Delete(newcast)
void append_list(List *lb,List *la)
    if la and lb:
        for Iterator bi = First(la); bi.item; bi = Next(bi):
            Append(lb,bi.item)
void cplus_inherit_types(Node *first,Node *cls,String *clsname,String *cast = 0)
    cplus_inherit_types_impl(first,cls,clsname,"bases","baselist",1,cast)
    cplus_inherit_types_impl(first,cls,clsname,"protectedbases","protectedbaselist",0,cast)
    cplus_inherit_types_impl(first,cls,clsname,"privatebases","privatebaselist",0,cast)
    if !cls:
        cls = first
    List *allbases = NewList()
    append_list(allbases,Getattr(cls,"bases"))
    append_list(allbases,Getattr(cls,"protectedbases"))
    append_list(allbases,Getattr(cls,"privatebases"))
    if Len(allbases):
        Setattr(cls,"allbases",allbases)
    Delete(allbases)
# ------------------------------------------------------------
# * top()
# * ------------------------------------------------------------
def top(n):
    importmode = 0
    module = Getattr(n,"module")
    inclass = 0
    normalize = 0
    nsname = 0
    nssymname = 0
    classhash = Getattr(n,"classes")
    emit_children(n)
    normalize_list()
    SwigType_set_scope(0)
    return SWIG_OK
# ------------------------------------------------------------
# * moduleDirective()
# * ------------------------------------------------------------
virtual int moduleDirective(Node *n)
    if !module:
        module = n
    return SWIG_OK
# ------------------------------------------------------------
# * importDirective()
# * ------------------------------------------------------------
def importDirective(n):
    String *oldmodule = module
     oldimport = importmode
    importmode = 1
    module = 0
    emit_children(n)
    importmode = oldimport
    module = oldmodule
    return SWIG_OK
# ------------------------------------------------------------
# * includeDirective()
# * externDirective()
# * extendDirective()
# * ------------------------------------------------------------
virtual int includeDirective(Node *n)
    return emit_children(n)
def externDeclaration(n):
    return emit_children(n)
virtual int edef xtendDirective(n):
    return emit_children(n)
# ------------------------------------------------------------
# * classDeclaration()
# * ------------------------------------------------------------
def classDeclaration(n):
    String *name = Getattr(n,"name")
    String *tdname = Getattr(n,"tdname")
    String *unnamed = Getattr(n,"unnamed")
    String *storage = Getattr(n,"storage")
    String *kind = Getattr(n,"kind")
    Node *oldinclass = inclass
    List *olist = normalize
    Symtab *symtab
    String *nname = 0
    String *fname = 0
    String *scopename = 0
    normalize = NewList()
    if name:
        if SwigType_istemplate(name):
            # We need to fully resolve the name to make templates work correctly */
Node *cn
            fname = SwigType_typedef_resolve_all(name)
            if Strcmp(fname,name)!= 0 and(cn = Swig_symbol_clookup_local(fname,0)):
                if(n == cn)
      or(Strcmp(nodeType(cn),"template")== 0)
      or(Getattr(cn,"feature:onlychildren")!= 0)
      or(Getattr(n,"feature:onlychildren")!= 0):
                    Swig_symbol_cadd(fname,n)
                    SwigType_typedef_class(fname)
                    scopename = Copy(fname)
                 else:
                    Swig_warning(WARN_TYPE_REDEFINED,Getfile(n),Getline(n),"Template '%s' was already wrapped,\n",SwigType_namestr(name))
                    Swig_warning(WARN_TYPE_REDEFINED,Getfile(cn),Getline(cn),"previous wrap of '%s'.\n",SwigType_namestr(Getattr(cn,"name")))
                    scopename = 0
             else:
                Swig_symbol_cadd(fname,n)
                SwigType_typedef_class(fname)
                scopename = Copy(fname)
         else:
            if(CPlusPlus)or(unnamed):
                SwigType_typedef_class(name)
             else:
                SwigType_typedef_class(NewStringf("%s %s",kind,name))
            scopename = Copy(name)
     else:
        scopename = 0
    Setattr(n,"typepass:visit","1")
    # Need to set up a typedef if unnamed
    if unnamed and tdname and(Cmp(storage,"typedef")== 0):
        SwigType_typedef(unnamed,tdname)
    if nsname:
        nname = NewStringf("%s::%s",nsname,name)
        String *tdname = Getattr(n,"tdname")
        if tdname:
            tdname = NewStringf("%s::%s",nsname,tdname)
            Setattr(n,"tdname",tdname)
    if nssymname:
        if GetFlag(n,"feature:nspace"):
            Setattr(n,"sym:nspace",nssymname)
    SwigType_new_scope(scopename)
    SwigType_attach_symtab(Getattr(n,"symtab"))
    # Inherit type definitions into the class
    if name:
        cplus_inherit_types(n,0,nname ? nname:(fname ? fname: name))
    inclass = n
    symtab = Swig_symbol_setscope(Getattr(n,"symtab"))
    emit_children(n)
    Swig_symbol_setscope(symtab)
    Hash *ts = SwigType_pop_scope()
    Setattr(n,"typescope",ts)
    Delete(ts)
    Setattr(n,"module",module)
    # Normalize deferred types
        normal_node *nn = new normal_node()
        nn.normallist = normalize
        nn.symtab = Getattr(n,"symtab")
        nn.next = patch_list
        nn.typescope = Getattr(n,"typescope")
        patch_list = nn
    normalize = olist
    inclass = oldinclass
    # If in a namespace,patch the class name
    if nname:
        Setattr(n,"name",nname)
        Delete(nname)
    return SWIG_OK
# ------------------------------------------------------------
# * namespaceDeclaration()
# * ------------------------------------------------------------
virtual int templateDeclaration(Node *n)
    String *name = Getattr(n,"name")
    String *ttype = Getattr(n,"templatetype")
    if Strcmp(ttype,"class")== 0:
        String *rname = SwigType_typedef_resolve_all(name)
        SwigType_typedef_class(rname)
        Delete(rname)
     elif Strcmp(ttype,"classforward")== 0:
        String *rname = SwigType_typedef_resolve_all(name)
        SwigType_typedef_class(rname)
        Delete(rname)
        #      SwigType_typedef_class(name);
    return SWIG_OK
# ------------------------------------------------------------
# * classforwardDeclaration()
# * ------------------------------------------------------------
def classforwardDeclaration(n):
    # Temporary hack. Can't do inside a class because it breaks
#    C nested structure wrapping
    if(!inclass)or(CPlusPlus):
        String *name = Getattr(n,"name")
        String *nname
        SwigType_typedef_class(name)
        if nsname:
            nname = NewStringf("%s::%s",nsname,name)
            Setattr(n,"name",nname)
    return SWIG_OK
# ------------------------------------------------------------
# * namespaceDeclaration()
# * ------------------------------------------------------------
virtual int namespaceDeclaration(Node *n)
    Symtab *symtab
    String *name = Getattr(n,"name")
    String *alias = Getattr(n,"alias")
    List *olist = normalize
    normalize = NewList()
    if alias:
        Typetab *ts = Getattr(n,"typescope")
        if !ts:
            Node *ns
            # Create a empty scope for the alias
            ns = Getattr(n,"namespace")
            if ns:
                SwigType_scope_alias(name,Getattr(ns,"typescope"))
            ts = Getattr(ns,"typescope")
            Setattr(n,"typescope",ts)
        # Namespace alias
        return SWIG_OK
     else:
        if name:
            Node *nn = Swig_symbol_clookup(name,n)
            Hash *ts = 0
            if nn:
                ts = Getattr(nn,"typescope")
            if !ts:
                SwigType_new_scope(name)
                SwigType_attach_symtab(Getattr(n,"symtab"))
             else:
                SwigType_set_scope(ts)
        String *oldnsname = nsname
        String *oldnssymname = nssymname
        nsname = Swig_symbol_qualified(Getattr(n,"symtab"))
        nssymname = Swig_symbol_qualified_language_scopename(Getattr(n,"symtab"))
        symtab = Swig_symbol_setscope(Getattr(n,"symtab"))
        emit_children(n)
        Swig_symbol_setscope(symtab)
        if name:
            Hash *ts = SwigType_pop_scope()
            Setattr(n,"typescope",ts)
            Delete(ts)
        # Normalize deferred types
            normal_node *nn = new normal_node()
            nn.normallist = normalize
            nn.symtab = Getattr(n,"symtab")
            nn.next = patch_list
            nn.typescope = Getattr(n,"typescope")
            patch_list = nn
        normalize = olist
        Delete(nssymname)
        nssymname = oldnssymname
        Delete(nsname)
        nsname = oldnsname
        return SWIG_OK
# ------------------------------------------------------------
# * cDeclaration()
# * ------------------------------------------------------------
def cDeclaration(n):
    if NoExcept:
        Delattr(n,"throws")
    # Normalize types.
    SwigType *ty = Getattr(n,"type")
    normalize_type(ty)
    SwigType *decl = Getattr(n,"decl")
    if decl:
        normalize_type(decl)
    normalize_parms(Getattr(n,"parms"))
    normalize_parms(Getattr(n,"throws"))
    if GetFlag(n,"conversion_operator"):
        # The call to the operator in the generated wrapper must be fully qualified in order to compile
        SwigType *name = Getattr(n,"name")
        SwigType *qualifiedname = Swig_symbol_string_qualify(name,0)
        Clear(name)
        Append(name,qualifiedname)
        Delete(qualifiedname)
    if checkAttribute(n,"storage","typedef"):
        String *name = Getattr(n,"name")
        ty = Getattr(n,"type")
        decl = Getattr(n,"decl")
        SwigType *t = Copy(ty)
            # If the typename is qualified,make sure the scopename is fully qualified when making a typedef
            if Swig_scopename_check(t)and strncmp(Char(t),"::",2):
                String *base,*prefix,*qprefix
                base = Swig_scopename_last(t)
                prefix = Swig_scopename_prefix(t)
                qprefix = SwigType_typedef_qualified(prefix)
                Delete(t)
                t = NewStringf("%s::%s",qprefix,base)
                Delete(base)
                Delete(prefix)
                Delete(qprefix)
        SwigType_push(t,decl)
        if CPlusPlus:
            Replaceall(t,"struct ","")
            Replaceall(t,"union ","")
            Replaceall(t,"class ","")
        SwigType_typedef(t,name)
    # If namespaces are active.  We need to patch the name with a namespace prefix
    if nsname and !inclass:
        String *name = Getattr(n,"name")
        if name:
            String *nname = NewStringf("%s::%s",nsname,name)
            Setattr(n,"name",nname)
            Delete(nname)
    clean_overloaded(n)
    return SWIG_OK
# ------------------------------------------------------------
# * constructorDeclaration()
# * ------------------------------------------------------------
virtual int constructorDeclaration(Node *n)
    if NoExcept:
        Delattr(n,"throws")
    normalize_parms(Getattr(n,"parms"))
    normalize_parms(Getattr(n,"throws"))
    # If in a namespace,patch the class name
    if nsname:
        String *nname = NewStringf("%s::%s",nsname,Getattr(n,"name"))
        Setattr(n,"name",nname)
    clean_overloaded(n)
    return SWIG_OK
# ------------------------------------------------------------
# * destructorDeclaration()
# * ------------------------------------------------------------
def destructorDeclaration(n):
    # If in a namespace,patch the class name
    if nsname:
        String *nname = NewStringf("%s::%s",nsname,Getattr(n,"name"))
        Setattr(n,"name",nname)
    return SWIG_OK
# ------------------------------------------------------------
# * constantDirective()
# * ------------------------------------------------------------
virtual int constantDirective(Node *n)
    SwigType *ty = Getattr(n,"type")
    if ty:
        Setattr(n,"type",SwigType_typedef_qualified(ty))
    return SWIG_OK
# ------------------------------------------------------------
# * enumDeclaration()
# * ------------------------------------------------------------
def enumDeclaration(n):
    String *name = Getattr(n,"name")
    if name:
        String *scope = 0
        # Add a typedef to the type table so that we can use 'enum Name' as well as just 'Name'
  if nsname or inclass:
            # But first correct the name and tdname to contain the fully qualified scopename
if nsname and inclass:
                scope = NewStringf("%s::%s",nsname,Getattr(inclass,"name"))
             elif nsname:
                scope = NewStringf("%s",nsname)
             elif inclass:
                scope = NewStringf("%s",Getattr(inclass,"name"))
            String *nname = NewStringf("%s::%s",scope,name)
            Setattr(n,"name",nname)
            String *tdname = Getattr(n,"tdname")
            if tdname:
                tdname = NewStringf("%s::%s",scope,tdname)
                Setattr(n,"tdname",tdname)
            SwigType *t = NewStringf("enum %s",nname)
            SwigType_typedef(t,name)
         else:
            SwigType *t = NewStringf("enum %s",name)
            SwigType_typedef(t,name)
        Delete(scope)
    String *tdname = Getattr(n,"tdname")
    String *unnamed = Getattr(n,"unnamed")
    String *storage = Getattr(n,"storage")
    # Construct enumtype - for declaring an enum of this type with SwigType_ltype()etc
String *enumtype = 0
    if unnamed and tdname and(Cmp(storage,"typedef")== 0):
        enumtype = Copy(Getattr(n,"tdname"))
     elif name:
        enumtype = NewStringf("%s%s",CPlusPlus ? "": "enum ",Getattr(n,"name"))
     else:
        # anonymous enums
  enumtype = Copy(Getattr(n,"type"))
    Setattr(n,"enumtype",enumtype)
    if nssymname:
        if GetFlag(n,"feature:nspace"):
            Setattr(n,"sym:nspace",nssymname)
    # This block of code is for dealing with %ignore on an enum item where the target language
# attempts to use the C enum value in the target language itself and expects the previous enum value
# to be one more than the previous value... the previous enum item might not exist if it is ignored!
# - It sets the first non-ignored enum item with the "firstenumitem" attribute.
# - It adds an enumvalue attribute if the previous enum item is ignored
        Node *c
         count = 0
        String *previous = 0
        bool previous_ignored = false
        bool firstenumitem = false
        for c = firstChild(n); c; c = nextSibling(c):
            assert(strcmp(Char(nodeType(c)),"enumitem")== 0)
            bool reset
            String *enumvalue = Getattr(c,"enumvalue")
            if GetFlag(c,"feature:ignore")or !Getattr(c,"sym:name"):
                reset = enumvalue ? true: false
                previous_ignored = true
             else:
                if !enumvalue and previous_ignored:
                    if previous:
                        Setattr(c,"enumvalue",NewStringf("(%s)+ %d",previous,count+1))
                    else:
                    Setattr(c,"enumvalue",NewStringf("%d",count))
                    SetFlag(c,"virtenumvalue")# identify enumvalue as virtual,ie not from the parsed source
                if !firstenumitem:
                    SetFlag(c,"firstenumitem")
                    firstenumitem = true
                reset = true
                previous_ignored = false
            if reset:
                previous = enumvalue ? enumvalue: Getattr(c,"name")
                count = 0
             else:
                count++
    emit_children(n)
    return SWIG_OK
# ------------------------------------------------------------
# * enumvalueDeclaration()
# * ------------------------------------------------------------
virtual int enumvalueDeclaration(Node *n)
    String *name = Getattr(n,"name")
    String *value = Getattr(n,"value")
    if !value:
        value = name
    if Strcmp(value,name)== 0:
        String *new_value
        if(nsname or inclass)and cparse_cplusplus:
            new_value = NewStringf("%s::%s",SwigType_namestr(Swig_symbol_qualified(n)),value)
         else:
            new_value = NewString(value)
        if(nsname or inclass)and !cparse_cplusplus:
            String *cppvalue = NewStringf("%s::%s",SwigType_namestr(Swig_symbol_qualified(n)),value)
            Setattr(n,"cppvalue",cppvalue); # for target languages that always generate C++ code even when wrapping C code
        Setattr(n,"value",new_value)
        Delete(new_value)
    Node *next = nextSibling(n)
    # Make up an enumvalue if one was not specified in the parsed code(not designed to be used on enum items and %ignore - enumvalue will be set instead)
if !GetFlag(n,"feature:ignore"):
        if Getattr(n,"_last")and !Getattr(n,"enumvalue"):  	# Only the first enum item has _last set(Note: first non-ignored enum item has firstenumitem set)
Setattr(n,"enumvalueex","0")
        if next and !Getattr(next,"enumvalue"):
            Setattr(next,"enumvalueex",NewStringf("%s + 1",Getattr(n,"sym:name")))
    return SWIG_OK
# ------------------------------------------------------------
# * enumforwardDeclaration()
# * ------------------------------------------------------------
def enumforwardDeclaration(n):
    # Use enumDeclaration()to do all the hard work.
# Note that no children can be emitted in a forward declaration as there aren't any.
return enumDeclaration(n)
ifdef DEBUG_OVERLOADED
static void show_overloaded(Node *n)
    Node *c = Getattr(n,"sym:overloaded")
    Node *checkoverloaded = c
    Printf(stdout,"-------------------- overloaded start %s sym:overloaded():%p -------------------------------\n",Getattr(n,"name"),c)
    while c:
        if Getattr(c,"error"):
            c = Getattr(c,"sym:nextSibling")
            continue
        if Getattr(c,"sym:overloaded")!= checkoverloaded:
            Printf(stdout,"sym:overloaded error c:%p checkoverloaded:%p\n",c,checkoverloaded)
            Swig_print_node(c)
            exit(1)
        String *decl = Strcmp(nodeType(c),"using")== 0 ? NewString("------"): Getattr(c,"decl")
        Printf(stdout,"  show_overloaded %s::%s(%s)         [%s] nodeType:%s\n",parentNode(c)? Getattr(parentNode(c),"name"): "NOPARENT",Getattr(c,"name"),decl,Getattr(c,"sym:overname"),nodeType(c))
        if !Getattr(c,"sym:overloaded"):
            Printf(stdout,"sym:overloaded error.....%p\n",c)
            Swig_print_node(c)
            exit(1)
        c = Getattr(c,"sym:nextSibling")
    Printf(stdout,"-------------------- overloaded end   %s -------------------------------\n",Getattr(n,"name"))
# ------------------------------------------------------------
# * usingDeclaration()
# * ------------------------------------------------------------
def usingDeclaration(n):
    if Getattr(n,"namespace"):
        # using namespace id
        # For a namespace import.   We set up inheritance in the type system
        Node *ns = Getattr(n,"node")
        if ns:
            Typetab *ts = Getattr(ns,"typescope")
            if ts:
                SwigType_using_scope(ts)
        return SWIG_OK
     else:
        Node *ns
        # using id
        Symtab *stab = Getattr(n,"sym:symtab")
        if stab:
            String *uname = Getattr(n,"uname")
            ns = Swig_symbol_clookup(uname,stab)
            if !ns and SwigType_istemplate(uname):
                String *tmp = Swig_symbol_template_deftype(uname,0)
                if !Equal(tmp,uname):
                    ns = Swig_symbol_clookup(tmp,stab)
                Delete(tmp)
         else:
            ns = 0
        if !ns:
            if is_public(n):
                Swig_warning(WARN_PARSE_USING_UNDEF,Getfile(n),Getline(n),"Nothing known about '%s'.\n",SwigType_namestr(Getattr(n,"uname")))
         else:
            # Only a single symbol is being used.  There are only a few symbols that
#    we actually care about.  These are typedef,class declarations,and enum
            String *ntype = nodeType(ns)
            if Strcmp(ntype,"cdecl")== 0:
                if checkAttribute(ns,"storage","typedef"):
                    # A typedef declaration
                    String *uname = Getattr(n,"uname")
                    SwigType_typedef_using(uname)
                 else:
                    # A normal C declaration.
                    if(inclass)and(!GetFlag(n,"feature:ignore"))and(Getattr(n,"sym:name")):
                        Node *c = ns
                        Node *unodes = 0,*last_unodes = 0
                         ccount = 0
                        String *symname = Getattr(n,"sym:name")
                        while c:
                            if Strcmp(nodeType(c),"cdecl")== 0:
                                if !(checkAttribute(c,"storage","static")
        or checkAttribute(c,"storage","typedef")
        or checkAttribute(c,"storage","friend")
        or(Getattr(c,"feature:extend")and !Getattr(c,"code"))
        or GetFlag(c,"feature:ignore")):
                                    # Don't generate a method if the method is overridden in this class,
#          * for example don't generate another m(bool)should there be a Base::m(bool):
#          * struct Derived: Base
#          *   void m(bool);
#          *   using Base::m;
#          * ;
#
                                    String *csymname = Getattr(c,"sym:name")
                                    if !csymname or(Strcmp(csymname,symname)== 0):
                                            String *decl = Getattr(c,"decl")
                                            Node *over = Getattr(n,"sym:overloaded")
                                             match = 0
                                            while over:
                                                String *odecl = Getattr(over,"decl")
                                                if Cmp(decl,odecl)== 0:
                                                    match = 1
                                                    break
                                                over = Getattr(over,"sym:nextSibling")
                                            if match:
                                                c = Getattr(c,"csym:nextSibling")
                                                continue
                                        Node *nn = copyNode(c)
                                        Delattr(nn,"access")	# access might be different from the method in the base class
          Setattr(nn,"access",Getattr(n,"access"))
                                        if !Getattr(nn,"sym:name"):
                                            Setattr(nn,"sym:name",symname)
                                        if !GetFlag(nn,"feature:ignore"):
                                            ParmList *parms = CopyParmList(Getattr(c,"parms"))
                                             is_pointer = SwigType_ispointer_return(Getattr(nn,"decl"))
                                             is_void = checkAttribute(nn,"type","void")and !is_pointer
                                            Setattr(nn,"parms",parms)
                                            Delete(parms)
                                            if Getattr(n,"feature:extend"):
                                                String *ucode = is_void ? NewStringf(" self.%s(",Getattr(n,"uname")): NewStringf(" return self.%s(",Getattr(n,"uname"))
                                                for ParmList *p = parms; p;:
                                                    Append(ucode,Getattr(p,"name"))
                                                    p = nextSibling(p)
                                                    if p:
                                                        Append(ucode,",")
                                                Append(ucode,"); ")
                                                Setattr(nn,"code",ucode)
                                                Delete(ucode)
                                            ParmList *throw_parm_list = Getattr(c,"throws")
                                            if throw_parm_list:
                                                Setattr(nn,"throws",CopyParmList(throw_parm_list))
                                            ccount++
                                            if !last_unodes:
                                                last_unodes = nn
                                                unodes = nn
                                             else:
                                                Setattr(nn,"previousSibling",last_unodes)
                                                Setattr(last_unodes,"nextSibling",nn)
                                                Setattr(nn,"sym:previousSibling",last_unodes)
                                                Setattr(last_unodes,"sym:nextSibling",nn)
                                                Setattr(nn,"sym:overloaded",unodes)
                                                Setattr(unodes,"sym:overloaded",unodes)
                                                last_unodes = nn
                                         else:
                                            Delete(nn)
                            c = Getattr(c,"csym:nextSibling")
                        if unodes:
                            set_firstChild(n,unodes)
                            if ccount > 1:
                                if !Getattr(n,"sym:overloaded"):
                                    Setattr(n,"sym:overloaded",n)
                                    Setattr(n,"sym:overname","_SWIG_0")
                        # Hack the parse tree symbol table for overloaded methods. Replace the "using" node with the
#        * list of overloaded methods we have just added in as child nodes to the "using" node.
#        * The node will still exist,it is just the symbol table linked list of overloaded methods
#        * which is hacked.
                        if Getattr(n,"sym:overloaded"):
                             cnt = 0
                            ifdef DEBUG_OVERLOADED
    Node *debugnode = n
                            show_overloaded(n)
    if !firstChild(n):
                                # Remove from overloaded list('using' node does not actually end up adding in any methods)
      Node *ps = Getattr(n,"sym:previousSibling")
                                Node *ns = Getattr(n,"sym:nextSibling")
                                if ps:
                                    Setattr(ps,"sym:nextSibling",ns)
                                if ns:
                                    Setattr(ns,"sym:previousSibling",ps)
                             else:
                                # The 'using' node results in methods being added in - slot in the these methods here
      Node *ps = Getattr(n,"sym:previousSibling")
                                Node *ns = Getattr(n,"sym:nextSibling")
                                Node *fc = firstChild(n)
                                Node *pp = fc
                                Node *firstoverloaded = Getattr(n,"sym:overloaded")
                                if firstoverloaded == n:
                                    # This 'using' node we are cutting out was the first node in the overloaded list.
        # Change the first node in the list to its first sibling
        Delattr(firstoverloaded,"sym:overloaded")
                                    Node *nnn = Getattr(firstoverloaded,"sym:nextSibling")
                                    firstoverloaded = fc
                                    while nnn:
                                        Setattr(nnn,"sym:overloaded",firstoverloaded)
                                        nnn = Getattr(nnn,"sym:nextSibling")
                                while pp:
                                    Node *ppn = Getattr(pp,"sym:nextSibling")
                                    Setattr(pp,"sym:overloaded",firstoverloaded)
                                    Setattr(pp,"sym:overname",NewStringf("%s_%d",Getattr(n,"sym:overname"),cnt++))
                                    if ppn:
                                        pp = ppn
                                    else:
                                    break
                                if ps:
                                    Setattr(ps,"sym:nextSibling",fc)
                                    Setattr(fc,"sym:previousSibling",ps)
                                if ns:
                                    Setattr(ns,"sym:previousSibling",pp)
                                    Setattr(pp,"sym:nextSibling",ns)
                                ifdef DEBUG_OVERLOADED
      debugnode = firstoverloaded
                            Delattr(n,"sym:previousSibling")
                            Delattr(n,"sym:nextSibling")
                            Delattr(n,"sym:overloaded")
                            Delattr(n,"sym:overname")
                            ifdef DEBUG_OVERLOADED
    show_overloaded(debugnode)
    clean_overloaded(n)# Needed?
             elif(Strcmp(ntype,"class")== 0)or((Strcmp(ntype,"classforward")== 0)):
                # We install the using class name as kind of a typedef back to the original class
                String *uname = Getattr(n,"uname")
                # Import into current type scope
                SwigType_typedef_using(uname)
             elif Strcmp(ntype,"enum")== 0:
                SwigType_typedef_using(Getattr(n,"uname"))
    return SWIG_OK
# ------------------------------------------------------------
# * typemapDirective()
# * ------------------------------------------------------------
virtual int typemapDirective(Node *n)
    if inclass or nsname:
        Node *items = firstChild(n)
        while items:
            Parm *pattern = Getattr(items,"pattern")
            Parm *parms = Getattr(items,"parms")
            normalize_later(pattern)
            normalize_later(parms)
            items = nextSibling(items)
    return SWIG_OK
# ------------------------------------------------------------
# * typemapcopyDirective()
# * ------------------------------------------------------------
def typemapcopyDirective(n):
    if inclass or nsname:
        Node *items = firstChild(n)
        ParmList *pattern = Getattr(n,"pattern")
        normalize_later(pattern)
        while items:
            ParmList *npattern = Getattr(items,"pattern")
            normalize_later(npattern)
            items = nextSibling(items)
    return SWIG_OK
# ------------------------------------------------------------
# * applyDirective()
# * ------------------------------------------------------------
virtual int applyDirective(Node *n)
    if inclass or nsname:
        ParmList *pattern = Getattr(n,"pattern")
        normalize_later(pattern)
        Node *items = firstChild(n)
        while items:
            Parm *apattern = Getattr(items,"pattern")
            normalize_later(apattern)
            items = nextSibling(items)
    return SWIG_OK
# ------------------------------------------------------------
# * clearDirective()
# * ------------------------------------------------------------
def clearDirective(n):
    if inclass or nsname:
        Node *p
        for p = firstChild(n); p; p = nextSibling(p):
            ParmList *pattern = Getattr(p,"pattern")
            normalize_later(pattern)
    return SWIG_OK
public:
statdef pass(n):
    TypePass t
    t.top(n)
.. @+node:ekr.20110917104720.9418: *5* convert-names-to-pep8
.. @+node:ekr.20110918204546.6809: *5* convert-to-class
.. @+node:ekr.20111004182631.15509: *4* Later
.. @+node:ekr.20111004090723.15495: *5* Finish leoOPML plugin
.. @+node:ekr.20110929074744.15499: *5* Allow more panes to be part of the free_layout "action" buttons
.. @+node:ekr.20110620065017.14900: *3* Bugs
.. @+node:ekr.20110621085435.6531: *4* Improve the find panel and find menu
@nocolor-node

Recently, perhaps it was today, there was a remark made about Leo's
Find panel being confusing for newbies.  I have some sympathy for the
remarks.

1.  Looking at Leo's Edit:Find menu, there is no obvious way of doing
a search/replace operation.  I'll fix this soon after 4.9 final.

2.  The Find tab should make it clearer that it is a summary/status
tab only--not a way of actually initiating or continuing searches.
Perhaps using QLabel widgets instead of (disabled) QTextEdit widgets
for the find/change patterns would help a bit.
.. @+node:ekr.20110620083705.14901: *4* Fix or disable curses and none gui's
See scanOptions.
.. @+node:ekr.20110619173515.14895: *4* Fix bug: realpath in g.openWithFileName
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/cd5e2125c9e13d8f

g.openWithFileName needs

   fileName = g.os_path_realpath(fileName)

at the start of it, otherwise

g.openWithFileName("/home/tbrown/.leo/.todo.leo", c) will open another
instance of an already open "/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo"
because it doesn't recognize them as being the same.

It would be nice if the original attempt to open
"/home/tbrown/.leo/.todo.leo" was not converted to
"/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo", but I think the POSIX
spec. insists on giving CPython the real path form, so this is hard to
avoid.  You see this when selecting a file using a file dialog, in the
dialog you choose /home/me/myfile.txt, but the return
is /mnt/usr1/usr1/home/me/myfile.txt.

Anyway, let me know if and when I can push that to trunk, impacts seem
to be limited to (a) not failing to detect an already opened file in
g.openWithFileName, which is a bug, and (b) sometimes less attractive
apparent paths, which is annoying, but I think better than the bug.

(this of course trips up UNLs
if /mnt/usr1/usr1/home/tbrown/.leo/.todo.leo is already loaded and the
UNL is /home/tbrown/.leo/.todo.leo#Home-->Paint roof)
.. @+node:ekr.20110619173515.14896: *4* Fix bug: wrong modality level on autocompleter
Just noticed the autocompleter pop-up is modal globally, not just for
the Leo windows.  Probably should only block the Leo windows.
.. @+node:ekr.20110621085435.6532: *4* Request: have equal-sized-panes resize vr pane
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/583bc0a31a6c7979

I noticed that when the renderpane is active it is not affected by the
Window>Equal Sized Panes command. Only the Outline and Body Panes are affected -
just as described in
http://webpages.charter.net/edreamleo/outlines.html#resizing-panes. However from
the user perspective the current behaviour appears as though the command is only
partially successful. Since there are specific commands to contract/expand the
log pane, shouldn't the log and render panes also be affected by the
Window>Equal Sized Panes command?


I suppose so.  I would prefer to wait for Terry to finish his
pane-generalization code before dealing with this.
.. @+node:ekr.20110921094450.6956: ** To do: 4.10
3. Bridges


.. @+node:ekr.20110921094450.6954: *3* Important
.. @+node:ekr.20110921094450.6955: *4* Windows
Leo should support more new windows.


Terry's plugins have also created nifty new windows.

Here are some other ideas:

A.  Hosting the PyQt demo inside Leo.

B. Making an OpenGl window an official Leo window. This might be the start of a
   prototype for "Blender in a Leo Window".
.. @+node:ekr.20110528034751.18272: *5* Support for tabifying Leo's core panes
Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
.. @+node:ekr.20110525112110.18402: *5* Ideas:
.. @+node:ekr.20101104191857.5820: *6* QWebView makes Leo a presentation tool
http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

.. @+node:ekr.20060227123536: *6* Tiddlywiki and related comments about rendering body text (Mulder)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
.. @+node:ekr.20110921094450.6957: *4* Keys: restart vim project
This requires commands that can be composed.
.. @+node:ekr.20110921094450.6958: *4* Bridges
There are already bridges for vim, emacs, ipython and docutils, but I think more
can be done.

The first thought is to improve Leo's inter-process communication capabilities.
I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in order to
resize vim, say, to it automatically tracks Leo's body pane (or any other pane).
.. @+node:ekr.20110921094450.6959: *4* Code tools
Analysis, checking, refactoring and other code-level tools are a natural for
Leo. When the new-lint project is mature, it could be folded into Leo.

* Rewrite the beautify-python command using a much simpler tokenizer.

.. @+node:ekr.20110921094450.6960: *4* Documentation tools
Perhaps Leo's documentation could be built primarily from docstrings. In any
event, documentation tools are always needed.
.. @+node:ekr.20110531190516.19365: *3* Maybe
@language rest

.. @+node:ekr.20110611043506.16494: *4*  Ashland sprint items: 3
.. @+node:ekr.20110527084258.18378: *5* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *6* Notes
.. @+node:ekr.20110609042343.16548: *7* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *7* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *7* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *7* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *6* Code related to uA's
.. @+node:ekr.20040701065235.2: *7* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *7* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *7* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *7* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20110528034751.18273: *5* Global search in Nav plugin?
.. @+node:ekr.20110613110911.16421: *5* Read/write files in json format
.. @+node:ekr.20051110155735.1: *4* Improve Spell tab & spell checker
@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
.. @+node:ekr.20090907080624.6081: *5* Spell checker should check headlines
.. @+node:ekr.20101004092958.5914: *4* Write treepad scanner
@ treepad.py is from the treepad website
.. @+node:ekr.20101004092958.5939: *5* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

.. @+node:ekr.20101004092958.5940: *6* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
.. @+node:ekr.20101004092958.5941: *6* class Node
class Node:
    @others
.. @+node:ekr.20101004092958.5942: *7* __init__
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
.. @+node:ekr.20101004092958.5943: *7* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
.. @+node:ekr.20101004092958.5944: *7* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
.. @+node:ekr.20101004092958.5945: *7* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
.. @+node:ekr.20101004092958.5946: *7* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
.. @+node:ekr.20101004092958.5947: *7* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

.. @+node:ekr.20101004092958.5948: *6* class NodeReader
class NodeReader:
    @others
.. @+node:ekr.20101004092958.5949: *7* __init__
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
.. @+node:ekr.20101004092958.5950: *7* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
.. @+node:ekr.20101004092958.5951: *7* readstart
def readstart(self):
    self.expect(VERSION)
.. @+node:ekr.20101004092958.5952: *7* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

.. @+node:ekr.20101004092958.5953: *6* class TreeReader
class TreeReader:
    @others
.. @+node:ekr.20101004092958.5954: *7* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
.. @+node:ekr.20101004092958.5955: *7* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
.. @+node:ekr.20101004092958.5956: *7* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

.. @+node:ekr.20101004092958.5957: *6* class TreeWriter
class TreeWriter:
    @others
.. @+node:ekr.20101004092958.5958: *7* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
.. @+node:ekr.20101004092958.5959: *7* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

.. @+node:ekr.20101004092958.5960: *6* class Main
class Main:
    @others
.. @+node:ekr.20101004092958.5961: *7* __init__
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
.. @+node:ekr.20101004092958.5962: *7* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

.. @+node:ekr.20110520051220.18203: *4* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
.. @+node:ekr.20071001052501: *4* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
.. @+node:ekr.20080802070659.11: *4* Make node attributes visible, and supported by Leo's core
.. @+node:ekr.20110614123640.6587: *4* Add headline/color functions to Leo's core
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/7e279fe3dedf42be/f00fde4df5b39ded

What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&lt;something&gt;"
namespace?

-------------------

Terry Brown

Sounds like something I may have brought up, long ago.

I was thinking that setting the fore/background color of nodes in the
tree should be a "gui core" function, and that the info should be
stored in uA, and so wanted to know what key should be used in uA for
that.  I think the docs say top level keys starting with "leo_" are
reserved, and probably wanted a ruling on

v.u['leo_fg'] = 'red'

vs

v.u['leo_tree_style']['fg'] = 'red'

etc.

I think the question may be more complicated than just what to call the
key, so you can probably retire the todo item.
.. @+node:ekr.20100112051224.6226: *4* Vim-related: Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20110601105631.19373: *5* Simple vim bindings
.. @+node:ekr.20110601105631.19374: *6* Cursors
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
.. @+node:ekr.20110601105631.19375: *6* Enter insert mode after ctrl-h
.. @+node:ekr.20110601105631.19376: *6* Colorize headline text depending on state
.. @+node:ekr.20110601105631.19377: *6* colon destroys alt-x binding
This project reorganizes makeBindingFromCommandsDict
.. @+node:ekr.20110530063322.18333: *4* scala not colored properly
.. @+node:ekr.20110518103946.18179: *4* Add external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
.. @+node:ekr.20090801103907.6018: *4* Add entries to global dicts for more languages (waiting for requests)
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.

** Only c.getOpenWithExt uses app.language_extension_dict.

I'll wait until I get requests for particular language.
.. @+node:ekr.20110528103005.18323: *5* Found: extension_dict
.. @+node:ekr.20080819075811.13: *6* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
.. @+node:ekr.20090212054250.9: *6* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20031218072017.2824: *6* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
.. @+node:EKR.20040504150046.4: *6* g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', '', '')

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    ('', '<!--', '-->')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
.. @+node:ekr.20080811174246.1: *6* languageForExtension
def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
.. @+node:ekr.20031218072017.368: *5* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20110528103005.18319: *5* Script to global data structures from in modes/*.py files
import glob
import imp

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)
theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

print('-'*40,len(aList))
known_keys = list(g.app.language_delims_dict.keys())
known_keys.sort()
known = []
computed = {}
for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2.startswith('__'): continue
    # if name2 in known_keys:
        # known.append(name)
        # continue
    try:
        theFile, pathname, description = imp.find_module(name2,[theDir])
        m = imp.load_module(name2, theFile, pathname, description)
    except Exception:
        g.es_exception()
        m = None
    if m:
        aList2 = [m.properties.get(z)
            for z in ('lineComment','commentStart','commentEnd')
                if m.properties.get(z)]
        print('%-20s : "%s",' % (
            '"%s"' % (name2),
            ' '.join(aList2)))
        computed[name2] = ' '.join(aList2)
mismatches = 0
for z in known_keys:
    val = g.app.language_delims_dict.get(z)
    val2 = computed.get(z)
    if not val:
        print('oops: no val',z)
    elif not val2:
        print('oops: no val2',z)
    elif val != val2:
        mismatches += 1
        print('mismatch for %s' % z)
        print(repr(val))
        print(repr(val2))
print('%s total languages' % len(aList))
print('%s new languages' % (len(list(computed.keys())) - len(known_keys)))
print('%s mismatches' % mismatches)
print('%s known language: %s' % (len(known_keys),known_keys))
.. @+node:ekr.20110527225107.18351: *4* Vague
@language rest

**Important**: These items are not scheduled for any release. They will be done
only if there are specific requests for them.

Eventually, all these items will move to the dreaded to-do-later list.
.. @+node:ekr.20110529115328.18238: *5* Emacs related: 5
I'll do these if and and only if somebody asks for them.
.. @+node:ekr.20110529104352.18248: *6* Complete k.universalDispatcher
.. @+node:ekr.20110529104352.18249: *6* Complete number-to-register command
.. @+node:ekr.20031218072017.753: *6* Emacs comint-mode
@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
.. @+node:ekr.20071004120359.2: *6* expand-region-abbrev
See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
.. @+node:ekr.20060628103226.3: *6* Make sure repeat counts work on basic editing commands
.. @-all
.. @-leo
