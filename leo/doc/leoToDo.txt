.. @+leo-ver=5-thin
.. @+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
.. @@language rest # override the default .txt coloring.

.. @+all
.. @+node:ekr.20110609102702.16471: ** To do: 4.10
Top 10:

* Fix all significant bugs.
    - Fix key bindings after redefining keys.
    - Fix serious clone bug
    - Eliminate (somehow!) spellpyx.txt from bzr repo
* Rendering to tex,pdf, etc.
* Use c.db for marks and expansion bits.
* Restart vim project
.. @+node:ekr.20120212095313.10377: *3* To do first
.. @+node:ekr.20120225032124.18056: *4* Clear out the pre-writing folder
@pagewidth 60
.. @+node:ekr.20120225072226.10199: *5* Add to scripting chapter
@language rest

I want to learn about PyQt and leo's qtGui. As a first step,
I'm trying to execute a script from within a leo body::

    from PyQt4 import QtGui
    w = QtGui.QWidget()
    w.resize(250, 150)
    w.move(300, 300)
    w.setWindowTitle('Simple test')
    w.show()

Q. When I try the above, I see a window appear and then
immediately disappear. How can I keep the window visible?

A. When the script exits the sole reference to the window,
w, ceases to exist, so the window is destroyed (garbage
collected). To keep the window open, add the following code
as the last line to keep the reference alive::

    g.app.scriptsDict['my-script_w'] = w

Note that this reference will persist until the next time
the execute-script command is run.  If you want something even
more permanent, you can do something like::

    g.app.my_script_w = w
.. @+node:ekr.20120225072226.10200: *5* Code for displaying a function call hierarchy in Leo
@language rest

@pagewidth 80

From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
.. @+node:ekr.20120225072226.10203: *6* call tree
import trace

@language python
@others

# see http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
.. @+node:ekr.20120225072226.10204: *7* displayCalltree
def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) > 0:
       while len(levels[-1]) > 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
.. @+node:ekr.20120225072226.10205: *7* trace session
.. @+node:ekr.20120225072226.10282: *5* The leoInspect module
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/f13fadac68eec41b/9124ba6d733ecbad
leoInspect: a hobby with a future?

http://groups.google.com/group/leo-editor/browse_thread/thread/62f0e7b84a25e0d0/39f848ad8a96bcbc
leoInspect: remarkable collapse in complexity and attempted assessment

.. @+node:ekr.20120226095657.10213: *5* Issue: @path @auto - strange behaviour
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b49d23010703aa61/32e1271d25ba2cfb

> In short, I am now willing, on an experimental basis, to have Leo put
> up a dialog when inserting an @ignore, and also when writing an
> @<file> node containing @ignore.

> In the past, I have always found read/write dialogs to be a) intrusive
> and b) panic-inducing, but this may be a tolerable exception.  We
> shall see.
.. @+node:ekr.20120226095657.10214: *5* How to upgrade properly
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/61019e45d75a6f18/71ee770ee4421222


Once you have the 4.9 "official release" working, then further updates are simply:

(ongoing practice - keep your folder containing your leo
code - separate from your .mySettings.leo and any data
files, .leo and otherwise.)

1. archive and remove that app folder
2. download the nightly snapshot zip file
3. unzip it into the same place
4. enjoy your up-to-date Leo code. . .
.. @+node:ekr.20120226095657.10215: *5* version.py now uses bzr_version.py
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5fdadfba113e12d9/fa329534654ecfec

As of rev 4847, Leo now reports bzr version numbers and dates more
accurately.

A new script, called v.bat, runs bzr version-info to create leo/core/
bzr_version.py.
leo/core/version.py uses the data in bzr_version.py to create Leo's
signon message. A copy of v.bat is in the latest copy of LeoPyRef.leo.

Thus, I can update the signon simply by running the script.  This
gives complete control over when the signon message will change.

I plan to run the "v" script at least once a day. This will ensure
that the daily snapshots will be distinguishable.

Edward

P.S.  v.bat must run 2to3 on bzr_version.py to ensure that it will
work on Python 3k, as well as with Python 2.x. 

It might be possible to run v from a bzr push hook, but I haven't done
that.  For now, we'll just have to accept that the info might be
slightly out of date. 
.. @+node:ekr.20120226131923.10221: *4* Allow abbreviations in minibuffer: 
@nocolor-node

cfa=clone-find-all-flattened
.. @+node:ekr.20120203053243.10111: *4* Fix OpenWith menu
@nocolor-node

This affects bindings.
.. @+node:ekr.20041118104831.1: *5* class LocalConfigManager
class LocalConfigManager:

    """A class to hold config settings for commanders."""

    @others
.. @+node:ekr.20120215072959.12472: *6* c.config.Birth
.. @+node:ekr.20041118104831.2: *7* c.config.ctor
def __init__ (self,c,previousSettings=None):
 
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('c.config.__init__ %s' % (c and c.shortFileName()))
    self.c = c
    
    # The shortcuts and settings dicts, set in c.__init__
    # for local files.
    if previousSettings:
        self.settingsDict = previousSettings.settingsDict
        self.shortcutsDict = previousSettings.shortcutsDict
        assert g.isTypedDict(self.settingsDict)
        assert g.isTypedDictOfLists(self.shortcutsDict)
    else:
        lm = g.app.loadManager
        self.settingsDict  = d1 = lm.globalSettingsDict
        self.shortcutsDict = d2 = lm.globalShortcutsDict
        assert d1 is None or g.isTypedDict(d1),d1
        assert d2 is None or g.isTypedDictOfLists(d2),d2

    # Define these explicitly to eliminate a pylint warning.
    self.default_derived_file_encoding =\
        g.app.config.default_derived_file_encoding
    self.redirect_execute_script_output_to_log_pane =\
        g.app.config.redirect_execute_script_output_to_log_pane
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultMenuFontSize = g.app.config.defaultMenuFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize

    for key in g.app.config.encodingIvarsDict.keys():
        self.initEncoding(key)

    for key in g.app.config.ivarsDict.keys():
        self.initIvar(key)
.. @+node:ekr.20041118104414: *7* c.config.initEncoding
def initEncoding (self,key):

    c = self.c

    # Important: the key is munged.
    gs = g.app.config.encodingIvarsDict.get(key)
    encodingName = gs.ivar
    
    encoding = self.get(encodingName,kind='string')
    

    # Use the global setting as a last resort.
    if encoding:
        # g.trace('c.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)
    else:
        encoding = getattr(g.app.config,encodingName)
        # g.trace('g.app.config',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad", "%s: %s" % (encodingName,encoding))
.. @+node:ekr.20041118104240: *7* c.config.initIvar
def initIvar(self,key):

    trace = False and not g.unitTesting
    c = self.c

    # Important: the key is munged.
    gs = g.app.config.ivarsDict.get(key)
    ivarName = gs.ivar
    val = self.get(ivarName,kind=None)

    if val or not hasattr(self,ivarName):
        if trace: g.trace('c.config',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
.. @+node:ekr.20120215072959.12471: *6* c.config.Getters
.. @+node:ekr.20120215072959.12543: *7* c.config.Getters: redirect to g.app.config
def getButtons (self):
    '''Return a list of tuples (x,y) for common @button nodes.'''
    return g.app.config.atCommonButtonsList # unusual.

def getCommands (self):
    '''Return the list of tuples (headline,script) for common @command nodes.'''
    return g.app.config.atCommonCommandsList # unusual.
    
def getEnabledPlugins (self):
    '''Return the body text of the @enabled-plugins node.'''
    return g.app.config.enabledPluginsString # unusual.
    
def getRecentFiles (self):
    '''Return the list of recently opened files.'''
    return g.app.config.getRecentFiles() # unusual
.. @+node:ekr.20120215072959.12515: *7* c.config.Getters
@nocolor-node

@ Only the following need to be defined.

    get (self,setting,theType)
    getAbbrevDict (self)
    getBool (self,setting,default=None)
    getButtons (self)
    getColor (self,setting)
    getData (self,setting)
    getDirectory (self,setting)
    getFloat (self,setting)
    getFontFromParams (self,family,size,slant,weight,defaultSize=12)
    getInt (self,setting)
    getLanguage (self,setting)
    getMenusList (self)
    getOpenWith (self):
    getRatio (self,setting)
    getShortcut (self,commandName)
    getString (self,setting)
.. @+node:ekr.20120215072959.12519: *8* c.config.get & allies
def get (self,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    # trace = (False or g.trace_startup) and not g.unitTesting
    trace = False and not g.unitTesting
    verbose = True
    c = self.c
    d = self.settingsDict
    lm = g.app.loadManager

    if d:
        assert g.isTypedDict(d),d
        val,junk = self.getValFromDict(d,setting,kind)
        if trace and verbose and val is not None:
            # g.trace('%35s %20s %s' % (setting,val,g.callers(3)))
            g.trace('%40s %s' % (setting,val))
            
        return val
    else:
        if trace and lm.globalSettingsDict:
            g.trace('ignore: %40s %s' % (
                setting,g.callers(2)))
        return None
.. @+node:ekr.20120215072959.12520: *9* getValFromDict
def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    c = self.c
    gs = d.get(g.app.config.munge(setting))
    if not gs: return None,False

    assert g.isGeneralSetting(gs),gs
    
    # g.trace(setting,requestedType,gs.toString())
    val = gs.val

    # 2011/10/24: test for an explicit None.
    if g.isPython3:
        isNone = val in ('None','none','') # ,None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','') #,None)

    if not self.typesMatch(gs.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',gs.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    # elif val in (u'None',u'none','None','none','',None):
    elif isNone:
        return '', True
            # 2011/10/24: Exists, a *user-defined* empty value.
    else:
        # g.trace(setting,val)
        return val, True
.. @+node:ekr.20120215072959.12521: *9* typesMatch
def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    # The shortcuts logic no longer uses the get/set code.
    shortcuts = ('shortcut','shortcuts',)
    if type1 in shortcuts or type2 in shortcuts:
        g.trace('oops: type in shortcuts')

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
.. @+node:ekr.20120215072959.12522: *8* c.config.getAbbrevDict
def getAbbrevDict (self):

    """Search all dictionaries for the setting & check it's type"""

    d = self.get('abbrev','abbrev')
    return d or {}
.. @+node:ekr.20120215072959.12523: *8* c.config.getBool
def getBool (self,setting,default=None):

    '''Return the value of @bool setting, or the default if the setting is not found.'''

    val = self.get(setting,"bool")

    if val in (True,False):
        return val
    else:
        return default
.. @+node:ekr.20120215072959.12525: *8* c.config.getColor
def getColor (self,setting):

    '''Return the value of @color setting.'''

    return self.get(setting,"color")
.. @+node:ekr.20120215072959.12527: *8* c.config.getData
def getData (self,setting):

    '''Return a list of non-comment strings in the body text of @data setting.'''

    return self.get(setting,"data")
.. @+node:ekr.20120215072959.12528: *8* c.config.getDirectory
def getDirectory (self,setting):

    '''Return the value of @directory setting, or None if the directory does not exist.'''

    theDir = self.getString(setting)

    if g.os_path_exists(theDir) and g.os_path_isdir(theDir):
        return theDir
    else:
        return None
.. @+node:ekr.20120215072959.12530: *8* c.config.getFloat
def getFloat (self,setting):

    '''Return the value of @float setting.'''

    val = self.get(setting,"float")
    try:
        val = float(val)
        return val
    except TypeError:
        return None
.. @+node:ekr.20120215072959.12531: *8* c.config.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    Default to size=12, slant="roman", weight="normal".

    Return None if there is no family setting so we can use system default fonts."""

    family = self.get(family,"family")
    if family in (None,""): family = g.app.config.defaultFontFamily

    size = self.get(size,"size")
    if size in (None,0): size = defaultSize

    slant = self.get(slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(weight,"weight")
    if weight in (None,""): weight = "normal"

    # g.trace(family,size,slant,weight,g.shortFileName(self.c.mFileName))
    return g.app.gui.getFontFromParams(family,size,slant,weight)
.. @+node:ekr.20120215072959.12532: *8* c.config.getInt
def getInt (self,setting):

    '''Return the value of @int setting.'''

    val = self.get(setting,"int")
    try:
        val = int(val)
        return val
    except TypeError:
        return None
.. @+node:ekr.20120215072959.12533: *8* c.config.getLanguage
def getLanguage (self,setting):

    '''Return the setting whose value should be a language known to Leo.'''

    language = self.getString(setting)
    # g.trace(setting,language)

    return language
.. @+node:ekr.20120215072959.12534: *8* c.config.getMenusList
def getMenusList (self):

    '''Return the list of entries for the @menus tree.'''

    aList = self.get('menus','menus')
    # g.trace(aList and len(aList) or 0)

    return aList or g.app.config.menusList
.. @+node:ekr.20120215072959.12535: *8* c.config.getOpenWith
def getOpenWith (self):

    '''Return a list of dictionaries corresponding to @openwith nodes.'''

    val = self.get('openwithtable','openwithtable')

    return val
.. @+node:ekr.20120215072959.12536: *8* c.config.getRatio
def getRatio (self,setting):

    '''Return the value of @float setting.

    Warn if the value is less than 0.0 or greater than 1.0.'''

    val = self.get(setting,"ratio")
    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            return val
        else:
            return None
    except TypeError:
        return None
.. @+node:ekr.20120215072959.12538: *8* c.config.getSettingSource
def getSettingSource (self,setting):

    '''return the name of the file responsible for setting.'''
    
    trace = False and not g.unitTesting
    c = self.c
    d = self.settingsDict
    lm = g.app.loadManager
    
    if d:
        assert g.isTypedDict(d),d
        si = d.get(setting)
        if si is None:
            return 'unknown setting',None
        else:
            assert g.isShortcutInfo(si)
            return si.path,si.val
    else:
        # lm.readGlobalSettingsFiles is opening a settings file.
        # lm.readGlobalSettingsFiles has not yet set lm.globalSettingsDict.
        assert d is None
        return None
.. @+node:ekr.20120215072959.12539: *8* c.config.getShortcut
def getShortcut (self,commandName):

    '''Return rawKey,accel for shortcutName'''
    
    trace = False and not g.unitTesting
    c = self.c
    d = self.shortcutsDict
    lm = g.app.loadManager
    
    if not c.frame.menu:
        g.trace('no menu: %s' % (commandName))
        return None,[]

    if d:
        assert g.isTypedDictOfLists(d),d
        key = c.frame.menu.canonicalizeMenuName(commandName)
        key = key.replace('&','') # Allow '&' in names.
        aList = d.get(commandName,[])
        if aList:
            for si in aList: assert g.isShortcutInfo(si),si 
            # It's very important to filter empty strokes here.
            aList = [si for si in aList
                if si.stroke and si.stroke.lower() != 'none']
        if trace: g.trace(d,'\n',aList)
        return key,aList
    else:
        # lm.readGlobalSettingsFiles is opening a settings file.
        # lm.readGlobalSettingsFiles has not yet set lm.globalSettingsDict.
        return None,[]
.. @+node:ekr.20120215072959.12540: *8* c.config.getString
def getString (self,setting):

    '''Return the value of @string setting.'''

    return self.get(setting,"string")
.. @+node:ekr.20120224140548.10528: *7* c.exists (new)
def exists (self,c,setting,kind):

    '''Return true if a setting of the given kind exists, even if it is None.'''
    
    d = self.settingsDict
    if d:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True
    return False
.. @+node:ekr.20041123092357: *7* c.config.findSettingsPosition & helper
# This was not used prior to Leo 4.5.

def findSettingsPosition (self,setting):

    """Return the position for the setting in the @settings tree for c."""

    munge = g.app.config.munge
    c = self.c

    root = self.settingsRoot()
    if not root:
        return c.nullPosition()

    setting = munge(setting)

    for p in root.subtree():
        #BJ munge will return None if a headstring is empty
        h = munge(p.h) or ''
        if h.startswith(setting):
            return p.copy()

    return c.nullPosition()
.. @+node:ekr.20041120074536: *8* c.config.settingsRoot
def settingsRoot (self):

    '''Return the position of the @settings tree.'''

    # g.trace(c,c.rootPosition())
    
    c = self.c

    for p in c.all_unique_positions():
        if p.h.rstrip() == "@settings":
            return p.copy()
    else:
        return c.nullPosition()
.. @+node:ekr.20070418073400: *6* c.config.printSettings
def printSettings (self):

    '''Prints the value of every setting, except key bindings and commands and open-with tables.
    The following shows where the active setting came from:

    -     leoSettings.leo,
    - [D] default settings.
    - [F] indicates the file being loaded,
    - [M] myLeoSettings.leo,

    '''

    legend = '''\
legend:
    leoSettings.leo
[D] default settings
[F] loaded .leo File
[M] myLeoSettings.leo
'''
    c = self.c
    legend = g.adjustTripleString(legend,c.tab_width)
    result = []
    for name,val,c,letter in g.app.config.config_iter(c):
        kind = g.choose(letter==' ','   ','[%s]' % (letter))
        result.append('%s %s = %s\n' % (kind,name,val))

    # Use a single g.es statement.
    result.append('\n'+legend)
    if g.unitTesting:
        pass # print(''.join(result))
    else:
        g.es('',''.join(result),tabName='Settings')
.. @+node:ekr.20120215072959.12475: *6* c.config.set
def set (self,p,kind,name,val):

    """Init the setting for name to val."""

    trace = False and not g.unitTesting
    if trace: g.trace(kind,name,val)
    
    c = self.c

    # Note: when kind is 'shortcut', name is a command name.
    key = g.app.config.munge(name)

    # if kind and kind.startswith('setting'): g.trace("c.config %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    assert g.isTypedDict(d),d

    gs = d.get(key)
    if gs:
        assert g.isGeneralSetting(gs),gs
        path = gs.path
        if c.os_path_finalize(c.mFileName) != c.os_path_finalize(path):
            g.es("over-riding setting:",name,"from",path)

    gs = g.GeneralSetting(kind,path=c.mFileName,val=val,tag='setting')
    d.replace(key,gs)
.. @+node:ekr.20031218072017.3750: *5* class leoMenu
class leoMenu:

    """The base class for all Leo menus."""

    @others
.. @+node:ekr.20120124042346.12938: *6* leoMenu.Birth
def __init__ (self,frame):

    self.c = c = frame.c
    self.enable_dict = {}       # Created by finishCreate.
    self.frame = frame
    self.menus = {}             # Menu dictionary.
    self.menuShortcuts = {}
        
def finishCreate (self):

    self.define_enable_dict()
.. @+node:ekr.20120124042346.12937: *7* define_enable_table
def define_enable_dict (self):
    
    c = self.c
    
    if not c.commandsDict:
        return # This is not an error: it happens during init.

    self.enable_dict = d = {
    
        # File menu...
            # 'revert':         True, # Revert is always enabled.               
        'open-with':            g.app.hasOpenWithMenu,
        
        # Edit menu...
        'undo':                 c.undoer.canUndo,
        'redo':                 c.undoer.canRedo,
        'extract-names':        c.canExtractSectionNames,
        'extract':              c.canExtract,
        'match-brackets':       c.canFindMatchingBracket,
        
        # Top-level Outline menu...
        'cut-node':             c.canCutOutline,
        'delete-node':          c.canDeleteHeadline,
        'paste-node':           c.canPasteOutline,
        'paste-retaining-clones':   c.canPasteOutline,
        'clone-node':           c.canClone,
        'sort-siblings':        c.canSortSiblings,
        'hoist':                c.canHoist,
        'de-hoist':             c.canDehoist,
        
        # Outline:Expand/Contract menu...
        'contract-parent':      c.canContractParent,
        'contract-node':        lambda: c.p.hasChildren() and c.p.isExpanded(),
        'contract-or-go-left':  lambda: c.p.hasChildren() and c.p.isExpanded() or c.p.hasParent(),
        'expand-node':          lambda: c.p.hasChildren() and not c.p.isExpanded(),
        'expand-prev-level':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-next-level':    lambda: c.p.hasChildren(),
        'expand-to-level-1':    lambda: c.p.hasChildren() and c.p.isExpanded(),
        'expand-or-go-right':   lambda: c.p.hasChildren(),
        
        # Outline:Move menu...
        'move-outline-down':    lambda: c.canMoveOutlineDown(),
        'move-outline-left':    lambda: c.canMoveOutlineLeft(),
        'move-outline-right':   lambda: c.canMoveOutlineRight(),
        'move-outline-up':      lambda: c.canMoveOutlineUp(),
        'promote':              lambda: c.canPromote(),
        'demote':               lambda: c.canDemote(),
        
        # Outline:Go To menu...
        'goto-prev-history-node':   lambda: c.nodeHistory.canGoToPrevVisited(),
        'goto-next-history-node':   lambda: c.nodeHistory.canGoToNextVisited(),
        'goto-prev-visible':        lambda: c.canSelectVisBack(),
        'goto-next-visible':        lambda: c.canSelectVisNext(),
        # These are too slow...
            # 'go-to-next-marked':  c.canGoToNextMarkedHeadline,
            # 'go-to-next-changed': c.canGoToNextDirtyHeadline,
        'goto-next-clone':          lambda: c.p.isCloned(),
        'goto-prev-node':           lambda: c.canSelectThreadBack(),
        'goto-next-node':           lambda: c.canSelectThreadNext(),
        'goto-parent':              lambda: c.p.hasParent(),
        'goto-prev-sibling':        lambda: c.p.hasBack(),
        'goto-next-sibling':        lambda: c.p.hasNext(),
        
        # Outline:Mark menu...
        'mark-subheads':            lambda: c.p.hasChildren(),
        # too slow...
            # 'mark-changed-items':   c.canMarkChangedHeadlines,
    }
    
    for i in range(1,9):
        d ['expand-to-level-%s' % (i)] = lambda: c.p.hasChildren()

    if 0: # Initial testing.
        commandKeys = list(c.commandsDict.keys())
        for key in sorted(d.keys()):
            if key not in commandKeys:
                g.trace('*** bad entry for %s' % (key))
.. @+node:ekr.20031218072017.3775: *6* error and oops
def oops (self):

    g.pr("leoMenu oops:", g.callers(4), "should be overridden in subclass")

def error (self,s):

    g.es_print('',s,color='red')
.. @+node:ekr.20031218072017.3781: *6* Gui-independent menu routines
.. @+node:ekr.20060926213642: *7* capitalizeMinibufferMenuName
def capitalizeMinibufferMenuName (self,s,removeHyphens):

    result = []
    for i in range(len(s)):
        ch = s[i]
        prev = i > 0 and s[i-1] or ''
        prevprev = i > 1 and s[i-2] or ''
        if (
            i == 0 or
            i == 1 and prev == '&' or
            prev == '-' or
            prev == '&' and prevprev == '-'
        ):
            result.append(ch.capitalize())
        elif removeHyphens and ch == '-':
            result.append(' ')
        else:
            result.append(ch)
    return ''.join(result)
.. @+node:ekr.20031218072017.3785: *7* createMenusFromTables & helpers
def createMenusFromTables (self):

    c = self.c

    aList = c.config.getMenusList()
    if aList:
        self.createMenusFromConfigList(aList)
    else:
        self.defineMenuTables()

        self.createFileMenuFromTable()
        self.createEditMenuFromTable()
        self.createOutlineMenuFromTable()

        g.doHook("create-optional-menus",c=c)

        self.createCmndsMenuFromTable()
        self.createWindowMenuFromTable()
        self.createHelpMenuFromTable()
.. @+node:ekr.20031218072017.3790: *8* createFileMenuFromTable
def createFileMenuFromTable (self):

    c = self.c
    fileMenu = self.createNewMenu("&File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    << create the recent files submenu >>
    self.add_separator(fileMenu)
    << create the read/write submenu >>
    << create the tangle submenu >>
    << create the untangle submenu >>
    << create the import submenu >>
    << create the export submenu >>
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)
.. @+node:ekr.20031218072017.3791: *9* << create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")

if 0: # Not needed, and causes problems in wxWindows...
    g.app.recentFilesManager.createRecentFilesMenuItems(c)
.. @+node:ekr.20031218072017.3792: *9* << create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)
.. @+node:ekr.20031218072017.3793: *9* << create the tangle submenu >>
tangleMenu = self.createNewMenu("Tan&gle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)
.. @+node:ekr.20031218072017.3794: *9* << create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)
.. @+node:ekr.20031218072017.3795: *9* << create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)
.. @+node:ekr.20031218072017.3796: *9* << create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)
.. @+node:ekr.20031218072017.3786: *8* createEditMenuFromTable
def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    << create the edit body submenu >>
    << create the edit headline submenu >>
    << create the find submenu >>

    self.createMenuEntries(editMenu,self.editMenuTop2Table)
.. @+node:ekr.20031218072017.3787: *9* << create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)
.. @+node:ekr.20031218072017.3788: *9* << create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)
.. @+node:ekr.20031218072017.3789: *9* << create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)
.. @+node:ekr.20031218072017.3797: *8* createOutlineMenuFromTable
def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&Outline")

    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

    << create check submenu >>
    << create expand/contract submenu >>
    << create move submenu >>
    << create mark submenu >>
    << create goto submenu >>
.. @+node:ekr.20040711140738.1: *9* << create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)
.. @+node:ekr.20031218072017.3798: *9* << create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)
.. @+node:ekr.20031218072017.3799: *9* << create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)
.. @+node:ekr.20031218072017.3800: *9* << create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)
.. @+node:ekr.20031218072017.3801: *9* << create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)
.. @+node:ekr.20050921103736: *8* createCmndsMenuFromTable
def createCmndsMenuFromTable (self):

    cmdsMenu = self.createNewMenu('&Cmds')

    # Now in the minibuffer table.
        # Used in top table: q,u,x
        # self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table in (
        # &: a,b,c,d,f,g,h,i,m,n,o,p,r,s,t,u
        ('&Abbrev...',          self.cmdsMenuAbbrevTable),
        ('Body E&ditors',       self.cmdsMenuBodyEditorsTable),
        ('&Buffers...',         self.cmdsMenuBuffersTable),
        ('&Chapters...',        self.cmdsMenuChaptersTable),
        ('C&ursor/Selection...',[]),
        ('&Focus...',           self.cmdsMenuFocusTable),
        ('&Macro...',           self.cmdsMenuMacroTable),
        ('M&inibuffer',         self.cmdsMenuMinibufferTable),
        #('&Panes...',           self.cmdsMenuPanesTable),
        ('&Pickers...',         self.cmdsMenuPickersTable),
        ('&Rectangles...',      self.cmdsMenuRectanglesTable),
        ('Re&gisters...',       self.cmdsMenuRegistersTable),
        ('R&un Script/Tests',   self.cmdsMenuRunTable),
        ('Scr&olling...',       self.cmdsMenuScrollTable),
        ('Spell C&heck...',     self.cmdsMenuSpellCheckTable),
        ('&Text Commands',      self.cmdsMenuTextTable),
        ('Toggle Setti&ngs',    self.cmdsMenuToggleTable),
    ):
        if table == self.cmdsMenuChaptersTable and not self.c.chapterController:
            continue
        menu = self.createNewMenu(name,'&Cmds')
        self.createMenuEntries(menu,table)

    for name,table in (
        # &: b,e,f,s,t,x
        ('Cursor &Back...',                     self.cursorMenuBackTable),
        ('Cursor Back &Extend Selection...',    self.cursorMeuuBackExtendTable),
        ('Cursor Extend &To...',                self.cursorMenuExtendTable),
        ('Cursor &Forward...',                  self.cursorMenuForwardTable),
        ('Cursor Forward E&xtend Selection...', self.cursorMenuForwardExtendTable),
    ):
        menu = self.createNewMenu(name,'C&ursor/Selection...')
        self.createMenuEntries(menu,table)
.. @+node:ekr.20031218072017.3802: *8* createWindowMenuFromTable
def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&Window")

    self.createMenuEntries(windowMenu,self.windowMenuTopTable)
.. @+node:ekr.20031218072017.3803: *8* createHelpMenuFromTable
def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        pass # self.getMacHelpMenu(table)
    else:
        helpMenu = self.createNewMenu("&Help")
        self.createMenuEntries(helpMenu,self.helpMenuTable)
.. @+node:ekr.20070926135612: *8* createMenusFromConfigList & helpers (leoMenu)
def createMenusFromConfigList (self,aList):

    '''Create menus from aList instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    trace = False and not g.unitTesting
    c = self.c
    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))

    table = c.config.getOpenWith() 
    if table:
        if trace:
            for z in table:
                g.trace(z)
        self.createOpenWithMenuFromTable(table)
    
.. @+node:ekr.20070927082205: *9* createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
.. @+node:ekr.20070927172712: *9* handleSpecialMenus
def handleSpecialMenus (self,name,parentName,table=None):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    if table is None: table = []
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.
        # createRecentFilesMenuItems will create the contents later.
        self.createNewMenu(name,parentName)
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
.. @+node:ekr.20031218072017.3752: *7* defineMenuTables & helpers
def defineMenuTables (self):

    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()
    self.defineCmdsMenuTables()
    self.defineHelpMenuTables()

.. @+node:ekr.20031218072017.3753: *8* defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
.. @+node:ekr.20031218072017.839: *9* defineEditMenuTopTable
def defineEditMenuTopTable (self):

    self.editMenuTopTable = [
        # &: u,r reserved for undo/redo: a,d,p,t,y.
        # & (later): e,g,n,v.
        ("Can't Undo",'undo'),
        ("Can't Redo",'redo'), 
        '-',
        ('Cu&t','cut-text'),
        ('Cop&y','copy-text'),
        ('&Paste','paste-text'),
        ('&Delete','backward-delete-char'),
        ('Select &All','select-all'),
        '-',
    ]
.. @+node:ekr.20031218072017.3754: *9* defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):

    self.editMenuEditBodyTable = [
        # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
        '*extract-&section',
        '*extract-&names',
        '*&extract',
        '-',
        '*convert-all-b&lanks',
        '*convert-all-t&abs',
        '*convert-&blanks',
        '*convert-&tabs',
        '*insert-body-&time',
        '*&reformat-paragraph',
        '-',
        '*&indent-region',
        '*&unindent-region',
        '*&match-brackets',
        '*add-comments',
        '*delete-comments',
    ]
.. @+node:ekr.20031218072017.3755: *9* defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):

    self.editMenuEditHeadlineTable = [
        '*edit-&headline',
        '*&end-edit-headline',
        '*&abort-edit-headline',
        '*insert-headline-&time',
        '*toggle-&angle-brackets',
    ]
.. @+node:ekr.20031218072017.3756: *9* defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):

    self.editMenuFindMenuTable = [
        # &: a,b,c,d,e,f,h,i,l,n,o,p,q,r,s,u,w,x
        '*&open-find-tab',
        '*&hide-find-tab',
        '*search-&with-present-options',
        '-',
        '*find-&next',
        '*find-&prev',
        '*&change',
        '*find-&all',
        '*clone-fi&nd-all',
        '*change-a&ll',
        '-',
        '*&find-character',
        '*find-character-extend-&selection',
        '*&backward-find-character',
        '*backward-find-character-&extend-selection',
        '-',
        '*&isearch-forward',
        '*isea&rch-backward',
        '*isearch-forward-rege&xp',
        '*isearch-backward-regex&p',
        '-',
        '*&query-replace',
        '*q&uery-replace-regex',
    ]
.. @+node:ekr.20031218072017.3757: *9* defineEditMenuTop2Table
def defineEditMenuTop2Table (self):

    c = self.c

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")

    self.editMenuTop2Table = [
        '*&goto-global-line',
        '*&execute-script',
        (label,'toggle-invisibles'),
        ("Setti&ngs",'open-leoSettings-leo'),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
.. @+node:ekr.20031218072017.3758: *8* defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
.. @+node:ekr.20031218072017.3759: *9* defineFileMenuTopTable
def defineFileMenuTopTable (self):

    self.fileMenuTopTable = [
        '*&new',
        ('&Open...','open-outline'),
    ]
.. @+node:ekr.20031218072017.3760: *9* defineFileMenuTop2Table
def defineFileMenuTop2Table (self):

    self.fileMenuTop2Table = [
        '-',
        ('&Close','close-window'),
        ('&Save','save-file'),
        ('Save &As','save-file-as'),
        ('Save As &Unzipped','save-file-as-unzipped'),
        ('Save As &Zipped','save-file-as-zipped'),
        ('Save &To','save-file-to'),
        ('Re&vert To Saved','revert'),
    ]
.. @+node:ekr.20031218072017.3761: *9* defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):

    self.fileMenuReadWriteMenuTable = [
        '*&check-derived-file',
        '*check-leo-file',
        '-',
        '*&read-outline-only',
        '*write-&outline-only',
        '-',
        '*read-&file-into-node',
        '*writ&e-file-from-node',
        '-',
        ('Read @&auto Nodes','read-at-auto-nodes'),
        ('Write @a&uto Nodes','write-at-auto-nodes'),
        ('Write D&irty @a&uto Nodes','write-dirty-at-auto-nodes'),
        '-',
        ('Read @file &Nodes','read-at-file-nodes'),
        ('Write &Dirty @file Nodes','write-dirty-at-file-nodes'),
        ('Write &Missing @file Nodes','write-missing-at-file-nodes'),
        ('&Write @file Nodes','write-at-file-nodes'),
    ]

    # a,cd,e,f,i,l,m,n,o,r,u,w
.. @+node:ekr.20031218072017.3762: *9* defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):

    self.fileMenuTangleMenuTable = [
        '*tangle-&all',
        '*tangle-&marked',
        '*&tangle',
    ]
.. @+node:ekr.20031218072017.3763: *9* defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):

    self.fileMenuUntangleMenuTable = [
        '*untangle-&all',
        '*untangle-&marked',
        '*&untangle',
    ]
.. @+node:ekr.20031218072017.3764: *9* defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):

    self.fileMenuImportMenuTable = [
        #&: c,d,f,n,o,r,
        '*import-&derived-file',
        ('Import To @&file','import-at-file'),
        ('Import To @&root','import-at-root'),
        '*import-&cweb-files',
        '*import-&noweb-files',
        '*import-flattened-&outline',
    ]
.. @+node:ekr.20031218072017.3765: *9* defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):

    self.fileMenuExportMenuTable = [
        '*export-&headlines',
        '*outline-to-&cweb',
        '*outline-to-&noweb',
        '*&flatten-outline',
        '*&remove-sentinels',
        '*&weave',
    ]
.. @+node:ekr.20031218072017.3766: *9* defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):

    self.fileMenuTop3MenuTable = [
        ('E&xit','exit-leo'),
    ]
.. @+node:ekr.20031218072017.3767: *8* defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
.. @+node:ekr.20031218072017.3768: *9* defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):

    self.outlineMenuTopMenuTable = [
        '*c&ut-node',
        '*c&opy-node',
        '*&paste-node',
        ('Pas&te Node As Clone','paste-retaining-clones'),
        '*&delete-node',
        '-',
        '*&insert-node',
        '*&clone-node',
        '*sort-childre&n',
        '*&sort-siblings',
        '-',
        '*&hoist',
        ('D&e-Hoist','de-hoist'), # To preserve the '-' in De-Hoist.
        '-',
    ]
    # Ampersand bindings:  a,b,c,d,e,h,i,n,o,p,t,s,y
    # Bindings for entries that go to submenus: a,g,k,m,x
.. @+node:ekr.20040711140738: *9* defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):

    self.outlineMenuCheckOutlineMenuTable = [
        # &: a,c,d,l,o
        '*check-&outline',
        '*&dump-outline',
        '-',
        '*compare-&leo-files',
        '-',
        '*check-&all-python-code',
        '*&check-python-code',
    ]
.. @+node:ekr.20031218072017.3769: *9* defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):

    self.outlineMenuExpandContractMenuTable = [
        '*&contract-all',
        '*contract-&node',
        '*contract-&parent',
        '*contract-or-go-&left',
        '-',
        '*expand-p&rev-level',
        '*expand-n&ext-level',
        '*expand-and-go-right',
        '*expand-or-go-right',
        '-',
        '*expand-to-level-&1',
        '*expand-to-level-&2',
        '*expand-to-level-&3',
        '*expand-to-level-&4',
        '*expand-to-level-&5',
        '*expand-to-level-&6',
        '*expand-to-level-&7',
        '*expand-to-level-&8',
        '-',
        '*expand-&all',
        '*expand-n&ode',
    ]
.. @+node:ekr.20031218072017.3770: *9* defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):

    self.outlineMenuMoveMenuTable = [
        ('Move &Down','move-outline-down'),
        ('Move &Left','move-outline-left'),
        ('Move &Right','move-outline-right'),
        ('Move &Up','move-outline-up'),
        '-',
        '*&promote',
        '*&demote',
    ]
.. @+node:ekr.20031218072017.3771: *9* defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):

    self.outlineMenuMarkMenuTable = [
        '*&mark',
        '*mark-&subheads',
        '*mark-changed-&items',
        # '*mark-changed-&roots',
        '*mark-&clones',
        '*&unmark-all',
    ]
.. @+node:ekr.20031218072017.3772: *9* defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):

    self.outlineMenuGoToMenuTable = [
        # &: a,b,c,d,e,f,g,h,i,l,m,n,o,p,r,s,t,v,
        ('Go To &First Node','goto-first-node'),
        ('Go To First V&isible','goto-first-visible-node'),
        ('Go To First Si&bling','goto-first-sibling'),
        '-',
        ('Go To Next C&hanged','goto-next-changed'),
        ('Go To Next &Clone','goto-next-clone'),
        ('Go To Next &Marked','goto-next-marked'),
        ('Go To Next N&ode','goto-next-node'),
        ('Go To Next &Sibling','goto-next-sibling'),
        ('Go To Next Visibl&e','goto-next-visible'),
        ('Go To Next Visite&d','go-forward'),
        '-',
        ('Go To P&arent','goto-parent'),
        '-',
        ('Go To &Prev Node','goto-prev-node'),
        ('Go To P&rev Sibling','goto-prev-sibling'),
        ('Go To Pre&v Visible','goto-prev-visible'),
        ('Go To Prev Visi&ted','go-back'),
        '-',
        ('Go To Last Node','goto-last-node'),
        ('Go To Last Siblin&g','goto-last-sibling'),
        ('Go To &Last Visible','goto-last-visible-node'),
    ]
.. @+node:ekr.20050921103230: *8* defineCmdsMenuTables & helpers
def defineCmdsMenuTables (self):

    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBodyEditorsTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuChaptersTable()
    self.defineCmdsMenuCursorTable()
    self.defineCmdsMenuFocusTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuMinibufferTable()
    self.defineCmdsMenuPickersTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuRunTable()
    self.defineCmdsMenuScrollTable()
    self.defineCmdsMenuSpellCheckTable()
    self.defineCmdsMenuTextTable()
    self.defineCmdsMenuToggleTable()
.. @+node:ekr.20060117094955.1: *9* defineCmdsMenuAbbrevTable
def defineCmdsMenuAbbrevTable (self):

    self.cmdsMenuAbbrevTable = [
        # &: a,e,i,k,l,r,w,v
        'abbre&v-mode',
        '-',
        '&list-abbrevs',
        '&read-abbrev-file',
        '&write-abbrev-file',
        '-',
        '&add-global-abbrev',
        '&inverse-add-global-abbrev',
        '&kill-all-abbrevs',
        # '-',
        # 'expand-abbrev', # Not a command
        # '&expand-region-abbrevs',
    ]
.. @+node:ekr.20060912093104: *9* defineCmdsMenuBodyEditorsTable
def defineCmdsMenuBodyEditorsTable (self):

    self.cmdsMenuBodyEditorsTable = [
        # &: a,c,d
        '&add-editor',
        '&cycle-editor-focus',
        '&delete-editor',
    ]
.. @+node:ekr.20060117095212: *9* defineCmdsMenuBufferTable
def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        '&append-to-buffer',
        '&kill-buffer',
        'list-&buffers',
        '&list-buffers-alphabetically',
        '&prepend-to-buffer',
        '&rename-buffer',
        '&switch-to-buffer',
    ]
.. @+node:ekr.20070604205927: *9* defineCmdsMenuChaptersTable
def defineCmdsMenuChaptersTable (self):

    self.cmdsMenuChaptersTable = [
        '&clone-node-to-chapter',
        'c&opy-node-to-chapter',
        'c&reate-chapter',
        '&move-node-to-chapter',
        '&remove-chapter',
        '&select-chapter',
    ]
.. @+node:ekr.20060924124119: *9* defineCmdsMenuCursorTable
def defineCmdsMenuCursorTable (self):

    self.cursorMenuBackTable = [
        # &: b,c,l,p,s,v,w
        'back-&char',
        'back-&paragraph',
        'back-&sentence',
        'back-&word',
        '-',
        'beginning-of-&buffer',
        'beginning-of-&line',
        '-',
        'pre&vious-line',
    ]

    self.cursorMeuuBackExtendTable = [
        # &: b,c,l,p,s,v,w
        'back-&char-extend-selection',
        'back-&paragraph-extend-selection',
        'back-&sentence-extend-selection',
        'back-&word-extend-selection',
        '-',
        'beginning-of-&buffer-extend-selection',
        'beginning-of-&line-extend-selection',
        '-',
        'pre&vious-line-extend-selection',
    ]

    self.cursorMenuExtendTable = [
        # &: l,p,s,w
        'extend-to-&line',
        'extend-to-&paragraph',
        'extend-to-&sentence',
        'extend-to-&word',
    ]

    self.cursorMenuForwardTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer',
        'end-of-&line',
        '-',
        'forward-&char',
        'forward-&paragraph',
        'forward-&sentence',
        'forward-&end-word',
        'forward-&word',
        '-',
        '&next-line',
    ]

    self.cursorMenuForwardExtendTable = [
        # &: b,c,e,l,n,p,s,w
        'end-of-&buffer-extend-selection',
        'end-of-&line-extend-selection',
        '-',
        'forward-&char-extend-selection',
        'forward-&paragraph-extend-selection',
        'forward-&sentence-extend-selection',
        'forward-&end-word-extend-selection',
        'forward-&word-extend-selection',#
        '-',
        '&next-line-extend-selection',    
    ]
.. @+node:ekr.20060923060822: *9* defineCmdsMenuFocusTable
def defineCmdsMenuFocusTable (self):

    self.cmdsMenuFocusTable = [
        '&cycle-all-focus',
        'focus-to-&body',          
        'focus-to-&log',             
        'focus-to-&minibuffer',     
        'focus-to-&tree',             
    ]
.. @+node:ekr.20060117114315: *9* defineCmdsMenuMacroTable
def defineCmdsMenuMacroTable (self):

    self.cmdsMenuMacroTable = [
        '&load-file',
        '-',
        '&start-kbd-macro',
        # '&end-kbd-macro',
        '&name-last-kbd-macro',
        '-',
        '&call-last-kbd-macro',
        # '&insert-kbd-macro',
    ]
.. @+node:ekr.20061011084101.1: *9* defineCmdsMenuMinibufferTable
def defineCmdsMenuMinibufferTable (self):

    self.cmdsMenuMinibufferTable = [
        # &: f,h,i,q,r,s,v
        '&full-command',
        'keyboard-&quit',
        '&repeat-complex-command',
        '&view-lossage',
        '-',
        '&show-mini-buffer',
        'h&ide-mini-buffer',
        '-',
        '&help-for-minibuffer',
    ]
.. @+node:ekr.20061011085641: *9* defineCmdsMenuPickersTable
def defineCmdsMenuPickersTable (self):

    self. cmdsMenuPickersTable = [
        'show-&colors',
        'show-find-&options',
        'show-&fonts',
    ]
.. @+node:ekr.20060117095212.2: *9* defineCmdsMenuRectanglesTable
def defineCmdsMenuRectanglesTable (self):

    self.cmdsMenuRectanglesTable = [
        '&clear-rectangle',
        'c&lose-rectangle',
        '&delete-rectangle',
        '&kill-rectangle',
        '&open-rectangle',
        '&string-rectangle',
        '&yank-rectangle',
    ]
.. @+node:ekr.20060117095212.1: *9* defineCmdsMenuRegistersTable
def defineCmdsMenuRegistersTable (self):

    self.cmdsMenuRegistersTable = [
        # &: a,c,e,i,j,n,p,r,v
        '&append-to-register',
        'copy-r&ectangle-to-register',
        '&copy-to-register',
        'i&ncrement-register',
        '&insert-register',
        '&jump-to-register',
        # 'number-to-register',
        '&point-to-register',
        'p&repend-to-register',
        '&view-register',
    ]
.. @+node:ekr.20061119061958: *9* defineCmdsMenuRunTable
def defineCmdsMenuRunTable (self):

    self.cmdsMenuRunTable = [
    # &: e,r
    '&execute-script',
    '&run-unit-tests',
    ]
.. @+node:ekr.20060923060822.1: *9* defineCmdsMenuScrollTable
def defineCmdsMenuScrollTable (self):

    self.cmdsMenuScrollTable = [
        # &: c,d,e,f,l,o,p,r,v,x
        'scroll-outline-down-&line',
        'scroll-outline-down-&page',
        'scroll-outline-le&ft',
        'scroll-outline-&right',
        's&croll-outline-up-line',
        'scr&oll-outline-up-page',
        '-',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-&down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-&up-page',
    ]
.. @+node:ekr.20060117095212.7: *9* defineCmdsMenuSpellCheckTable
def defineCmdsMenuSpellCheckTable (self):

    self.cmdsMenuSpellCheckTable = [
        '&open-spell-tab',
        'spell-&change',
        'spell-change-&then-find',
        'spell-&find',
        'spell-&ignore',
    ]
.. @+node:ekr.20060924161901: *9* defineCmdsMenuTextTable
def defineCmdsMenuTextTable (self):

    self.cmdsMenuTextTable = [
        # &: a,b,c,d,e,f,g,i,l,m,n,o,p,r,s,u
        '&beautify',
        'beautify-&all',
        '-',
        'center-&line',
        'center-&region',
        '-',
        '&capitalize-word',
        '&downcase-word',
        '&upcase-word',
        '-',
        'd&owncase-region',
        'u&pcase-region',
        '-',
        '&indent-region',
        'indent-r&elative',
        'indent-ri&gidly',
        'u&nindent-region',
        '-',
        'sort-colu&mns',
        'sort-&fields',
        '&sort-lines',
    ]
.. @+node:ekr.20060926161940: *9* defineCmdsMenuToggleTable
def defineCmdsMenuToggleTable (self):

    self.cmdsMenuToggleTable = [
        # &: d,e,m,s,t,u,v
        'toggle-a&utocompleter',
        'toggle-call&tips',
        'toggle-&extend-mode',
        'toggle-input-&state',
        'toggle-in&visibles',
        'toggle-&mini-buffer',
        'toggle-split-&direction',
        '-',
        # &: a,b,c,f,h,i,r,w,x
        'toggle-find-&ignore-case-option',
        'toggle-find-in-&body-option',
        'toggle-find-in-&headline-option',
        'toggle-find-mark-&changes-option',
        'toggle-find-mark-&finds-option',
        'toggle-find-rege&x-option',
        'toggle-find-&reverse-option',
        'toggle-find-&word-option',
        'toggle-find-wrap-&around-option',
    ]
.. @+node:ekr.20031218072017.3773: *8* defineWindowMenuTables
def defineWindowMenuTables (self):

    self.windowMenuTopTable = [
        # &: a,b,c,d,e,f,l,m,n,o,p,r,s,t,u,w,x,y
        '*&equal-sized-panes',
        '*&toggle-active-pane',
        '*toggle-&split-direction',
        '-',
        '*contract-&body-pane',
        '*contract-&log-pane',
        '*contract-&outline-pane',
        '*contract-&pane',
        '-',
        '*expand-bo&dy-pane',
        '*expand-lo&g-pane',
        '*expand-o&utline-pane',
        '*expand-pa&ne',
        '-',
        '*&fully-expand-body-pane',
        '*full&y-expand-log-pane',
        '*fully-e&xpand-outline-pane',
        '*fully-exp&and-pane',
        '-',
        '*&resize-to-screen',
        '*&cascade-windows',
        '*&minimize-all',
        '-',
        '*open-compare-window',
        '*open-python-&window',
    ]
.. @+node:ekr.20031218072017.3774: *8* defineHelpMenuTables
def defineHelpMenuTables (self):

    self.helpMenuTable = [
        # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
        ('&About Leo...',           'about-leo'),
        ('Online &Home Page',       'open-online-home'),
        '*open-online-&tutorial',
        '*open-&users-guide',
        '-',
        ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
        ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
        ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
        ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
        ('Open scr&ipts.leo',       'open-scripts-leo'),
        '-',
        '*he&lp-for-minibuffer',
        '*help-for-&command',
        '-',
        '*&apropos-autocompletion',
        '*apropos-&bindings',
        '*apropos-&debugging-commands',
        '*apropos-&find-commands',
        '-',
        '*pri&nt-bindings',
        '*print-c&ommands',
    ]
.. @+node:ekr.20031218072017.3780: *7* hasSelection
# Returns True if text in the outline or body text is selected.

def hasSelection (self):

    c = self.c ; w = c.frame.body.bodyCtrl

    if c.frame.body:
        first,last = w.getSelectionRange()
        return first != last
    else:
        return False
.. @+node:ekr.20051022053758.1: *6* Helpers
.. @+node:ekr.20031218072017.3783: *7* canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):

    return ''.join([ch for ch in name.lower() if ch.isalnum()])

def canonicalizeTranslatedMenuName (self,name):

    return ''.join([ch for ch in name.lower() if ch not in '& \t\n\r'])
.. @+node:ekr.20051022044950: *7* computeOldStyleShortcutKey
def computeOldStyleShortcutKey (self,s):

    '''Compute the old-style shortcut key for @shortcuts entries.'''

    return ''.join([ch for ch in s.strip().lower() if ch.isalnum()])
.. @+node:ekr.20031218072017.1723: *7* createMenuEntries (leoMenu) & helpers
def createMenuEntries (self,menu,table,dynamicMenu=False):

    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''

    c = self.c ; k = c.k
    if g.app.unitTesting: return
    if not menu: return
    
    self.traceMenuTable(table)

    for data in table:
        label,command,done = self.getMenuEntryInfo(data,menu)
        if done: continue
        commandName = self.getMenuEntryBindings(command,dynamicMenu,label)
        if not commandName: continue
            
        masterMenuCallback = self.createMasterMenuCallback(
            dynamicMenu,command,commandName)

        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&")
        realLabel = realLabel.replace("&","")

        # c.add_command ensures that c.outerUpdate is called.
        c.add_command(menu,label=realLabel,
            accelerator='', # The accelerator is now computed dynamically.
            command=masterMenuCallback,
            commandName=commandName,
            underline=amp_index)
.. @+node:ekr.20111102072143.10016: *8* createMasterMenuCallback
def createMasterMenuCallback(self,dynamicMenu,command,commandName):
    
    trace = False and not g.unitTesting
    c = self.c
    
    def setWidget():
        w = c.frame.getFocus()
        if w and sys.platform.startswith('darwin'):
             # 2012/01/11: redirect (MacOS only).
            wname = c.widget_name(w) or ''
            if wname.startswith('head'):
                w = c.frame.tree.edit_widget(c.p)
        return w

    if dynamicMenu:
        if command:
            def masterDynamicMenuCallback (c=c,command=command):
                # 2012/01/07: set w here.
                w = setWidget()
                if trace: g.trace(command.__name__,w) 
                event = g.app.gui.create_key_event(c,None,None,w)
                return c.k.masterCommand(func=command,event=event)
            return masterDynamicMenuCallback
        else:
            g.internalError('no callback for dynamic menu item.')
            def dummyMasterMenuCallback():
                pass
            return dummyMasterMenuCallback
    else:
        def masterStaticMenuCallback (c=c,commandName=commandName):
            # 2011/10/28: Use only the command name to dispatch the command.
            # 2012/01/07: Bug fix: set w here.
            w = setWidget()
            if trace: g.trace(commandName,w,c)
            event = g.app.gui.create_key_event(c,None,None,w)
            return c.k.masterCommand(commandName=commandName,event=event)
        return masterStaticMenuCallback
.. @+node:ekr.20111028060955.16568: *8* getMenuEntryBindings
def getMenuEntryBindings(self,command,dynamicMenu,label):
    
    '''Compute commandName from command.'''

    trace = False and not g.unitTesting
    c = self.c

    if type(command) == type(''):
        # Command is really a command name.
        commandName = command 
    else:
        # First, get the old-style name.
        commandName = self.computeOldStyleShortcutKey(label)
        
    command = c.commandsDict.get(commandName)
        
    if trace and not command and not dynamicMenu:
        # This may come from a plugin that normally isn't enabled.
        g.trace('No inverse for %s' % commandName)
        
    return commandName
.. @+node:ekr.20111028060955.16565: *8* getMenuEntryInfo
def getMenuEntryInfo (self,data,menu):
    
    done = False

    if g.isString(data):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0]=='*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s,removeHyphens)
        command = s.replace('&','').lower()
        if label == '-':
            self.add_separator(menu)
            done = True # That's all.
    else:
        ok = type(data) in (type(()), type([])) and len(data) in (2,3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label,command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label,junk,command = data
    
            if label in (None,'-'):
                self.add_separator(menu)
                done = True # That's all.
        else:
            g.trace('bad data in menu table: %s' % repr(data))
            done = True # Ignore bad data
            
    return label,command,done
.. @+node:ekr.20111028060955.16563: *8* traceMenuTable
def traceMenuTable (self,table):
    
    trace = False and not g.unitTesting
    
    if not trace: return
    format = '%40s %s'
    g.trace('*'*40,g.callers())
    for data in table:
        if type(data) in (type(()), type([])):
            n = len(data)
            if n == 2:
                print(format % (data[0],data[1]))
            elif n == 3:
                name,junk,func = data
                print(format % (name,func and func.__name__ or '<NO FUNC>'))
        else:
            print(format % (data,''))
.. @+node:ekr.20031218072017.3784: *7* createMenuItemsFromTable
def createMenuItemsFromTable (self,menuName,table,dynamicMenu=False):

    try:
        menu = self.getMenu(menuName)
        if menu == None:
            if not g.app.gui.isNullGui:
                g.es_print("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table,dynamicMenu=dynamicMenu)
    except:
        g.es_print("exception creating items for",menuName,"menu")
        g.es_exception()

    g.app.menuWarningsGiven = True
.. @+node:ekr.20031218072017.3804: *7* createNewMenu
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists:",menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0,label=menuName)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating",menuName,"menu")
        g.es_exception()
        return None
.. @+node:ekr.20031218072017.4116: *7* createOpenWithMenuFromTable & helper (leoMenu)
def createOpenWithMenuFromTable (self,table):

    '''Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.'''

    trace = False and not g.unitTesting
    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    if trace: g.trace('parent',parent)
    if not parent:
        if not g.app.batchMode:
            g.es('','createOpenWithMenuFromTable:','no File menu',color="red")
        return

    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except:
            if trace:
                g.trace('unexpected exception')
                g.es_exception()
            return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    if not openWithMenu:
        if trace: g.trace('openWithMenu returns None')
        return
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    
    #### Each item is a dict.
    # for entry in table:
        # if len(entry) != 3: # 6/22/03
            # g.es('','createOpenWithMenuFromTable:','invalid data',color="red")
            # return

    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
.. @+node:ekr.20051022043608.1: *8* createOpenWithMenuItemsFromTable (leoMenu)
def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for d in table:
        label = d.get('name')
        command = d.get('command')
        if command: command = command.split(',')
        # g.trace('command',type(command),command)
        accel = d.get('shortcut') or ''
        if label and command:
            realLabel = self.getRealMenuName(label)
            underline=realLabel.find("&")
            realLabel = realLabel.replace("&","")
            callback = self.defineOpenWithMenuCallback(command) #### openWithData)
            c.add_command(menu,label=realLabel,accel=accel,
                command=callback,underline=underline)
.. @+node:tbrown.20080509212202.7: *7* deleteRecentFilesMenuItems (leoMenu)
def deleteRecentFilesMenuItems(self,menu):
    
    """Delete recent file menu entries"""

    rf = g.app.recentFilesManager

    # Why not just delete all the entries?
    recentFiles = rf.getRecentFiles()
    toDrop = len(recentFiles) + len(rf.getRecentFilesTable())
    self.delete_range(menu,0,toDrop)

    for i in rf.groupedMenus:
        menu = self.getMenu(i)
        if menu:
            self.destroy(menu)
            self.destroyMenu(i)
.. @+node:ekr.20031218072017.4117: *7* defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):
    
    c = self.c

    if minibufferCommand:

        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c,None,None,None)

        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            c = self.c
            return c.doCommand(command,label,event)

        return minibufferMenuCallback

    else:

        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            c.check_event(event)
            return c.doCommand(command,label)

        return legacyMenuCallback
.. @+node:ekr.20031218072017.4118: *7* defineOpenWithMenuCallback (leoMenu)
def defineOpenWithMenuCallback(self,data):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        return self.c.openWith(data=data)

    return openWithMenuCallback
.. @+node:ekr.20031218072017.3805: *7* deleteMenu
def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu:",menuName)
    except:
        g.es("exception deleting",menuName,"menu")
        g.es_exception()
.. @+node:ekr.20031218072017.3806: *7* deleteMenuItem
def deleteMenuItem (self,itemName,menuName="top"):

    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found:",menuName)
    except:
        g.es("exception deleting",itemName,"from",menuName,"menu")
        g.es_exception()
.. @+node:ekr.20031218072017.3782: *7* get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)

def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in","setRealMenuNamesFromTable")
        g.es_exception()
.. @+node:ekr.20031218072017.3807: *7* getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    # if cmn == 'openwith': g.trace('leoMenu',g.dictToString(self.menus))
    return self.menus.get(cmn)

def setMenu (self,menuName,menu):

    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu

def destroyMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
.. @+node:ekr.20031218072017.3808: *6* Must be overridden in menu subclasses
.. @+node:ekr.20031218072017.3809: *7* 9 Routines with Tk spellings
def add_cascade (self,parent,label,menu,underline):
    self.oops()

def add_command (self,menu,**keys):
    self.oops()

def add_separator(self,menu):
    self.oops()

# def bind (self,bind_shortcut,callback):
#     self.oops()

def delete (self,menu,realItemName):
    self.oops()

def delete_range (self,menu,n1,n2):
    self.oops()

def destroy (self,menu):
    self.oops()

def insert (self,menuName,position,label,command,underline=None): # New in Leo 4.4.3 a1
    self.oops()

def insert_cascade (self,parent,index,label,menu,underline):
    self.oops()

def new_menu(self,parent,tearoff=0,label=''): # 2010: added label arg for pylint.
    self.oops() ; return None
.. @+node:ekr.20031218072017.3810: *7* 9 Routines with new spellings
def activateMenu (self,menuName): # New in Leo 4.4b2.
    self.oops()

def clearAccel (self,menu,name):
    self.oops()

def createMenuBar (self,frame):
    self.oops()

def createOpenWithMenu (self,parent,label,index,amp_index):
    self.oops() ; return None

def disableMenu (self,menu,name):
    self.oops()

def enableMenu (self,menu,name,val):
    self.oops()

def getMacHelpMenu (self,table):
    return None

def getMenuLabel (self,menu):
    self.oops()

def setMenuLabel (self,menu,name,label,underline=-1):
    self.oops()
.. @+node:ekr.20110605121601.18340: *5* class leoQtMenu (leoMenu)
class leoQtMenu (leoMenu.leoMenu):

    @others
.. @+node:ekr.20110605121601.18341: *6* leoQtMenu.__init__
def __init__ (self,frame,label):

    assert frame
    assert frame.c

    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)
    
    self.leo_menu_label = label.replace('&','').lower()

    # called from createMenuFromConfigList,createNewMenu,new_menu,qtMenuWrapper.ctor.
    # g.trace('(leoQtMenu) %s' % (self.leo_menu_label or '<no label!>'))

    self.frame = frame
    self.c = c = frame.c

    self.menuBar = c.frame.top.menuBar()
    assert self.menuBar is not None

    # Inject this dict into the commander.
    if not hasattr(c,'menuAccels'):
        setattr(c,'menuAccels',{})

    if 0:
        self.font = c.config.getFontFromParams(
            'menu_text_font_family', 'menu_text_font_size',
            'menu_text_font_slant',  'menu_text_font_weight',
            c.config.defaultMenuFontSize)
.. @+node:ekr.20110605121601.18342: *6* Tkinter menu bindings
# See the Tk docs for what these routines are to do
.. @+node:ekr.20110605121601.18343: *7* Methods with Tk spellings
.. @+node:ekr.20110605121601.18344: *8* add_cascade (leoQtMenu)
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method.

    Adds a submenu to the parent menu, or the menubar."""
    
    # menu and parent are a qtMenuWrappers.
    c = self.c ; leoFrame = c.frame
    n = underline
    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]

    menu.setTitle(label)

    if parent:
        parent.addMenu(menu) # QMenu.addMenu.
    else:
        self.menuBar.addMenu(menu)
        
    label = label.replace('&','').lower()
    menu.leo_menu_label = label

    return menu
.. @+node:ekr.20110605121601.18345: *8* add_command (leoQtMenu) (Called by createMenuEntries)
def add_command (self,**keys):

    """Wrapper for the Tkinter add_command menu method."""
    
    trace = False and not g.unitTesting # and label.startswith('Paste')

    c = self.c
    accel = keys.get('accelerator') or ''
    command = keys.get('command')
    commandName = keys.get('commandName')
    label = keys.get('label')
    n = keys.get('underline')
    menu = keys.get('menu') or self
    if not label: return
    
    if trace: g.trace(label)
        # command is always add_commandCallback,
        # defined in c.add_command.

    if -1 < n < len(label):
        label = label[:n] + '&' + label[n:]
    if accel:
        label = '%s\t%s' % (label,accel)

    action = menu.addAction(label)
    
    # 2012/01/20: Inject the command name into the action
    # so that it can be enabled/disabled dynamically.
    action.leo_command_name = commandName

    if command:
        def qt_add_command_callback(label=label,command=command):
            # g.trace(command)
            return command()

        QtCore.QObject.connect(action,
            QtCore.SIGNAL("triggered()"),qt_add_command_callback)
.. @+node:ekr.20110605121601.18346: *8* add_separator (leoQtMenu)
def add_separator(self,menu):

    """Wrapper for the Tkinter add_separator menu method."""

    if menu:
        action = menu.addSeparator()
        action.leo_menu_label = '*seperator*'
.. @+node:ekr.20110605121601.18347: *8* delete (leoQtMenu)
def delete (self,menu,realItemName='<no name>'):

    """Wrapper for the Tkinter delete menu method."""

    # g.trace(menu)

    # if menu:
        # return menu.delete(realItemName)
.. @+node:ekr.20110605121601.18348: *8* delete_range (leoQtMenu)
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    # Menu is a subclass of QMenu and leoQtMenu.

    # g.trace(menu,n1,n2,g.callers(4))

    for z in menu.actions()[n1:n2]:
        menu.removeAction(z)
.. @+node:ekr.20110605121601.18349: *8* destroy (leoQtMenu)
def destroy (self,menu):

    """Wrapper for the Tkinter destroy menu method."""

    # if menu:
        # return menu.destroy()
.. @+node:ekr.20110605121601.18350: *8* index (leoQtMenu)
def index (self,label):

    '''Return the index of the menu with the given label.'''
    # g.trace(label)

    return 0
.. @+node:ekr.20110605121601.18351: *8* insert (leoQtMenu)
def insert (self,menuName,position,label,command,underline=None):

    # g.trace(menuName,position,label,command,underline)

    menu = self.getMenu(menuName)

    if menu and label:
        n = underline or 0
        if -1 > n > len(label):
            label = label[:n] + '&' + label[n:]
        action = menu.addAction(label)
        if command:
            def insert_callback(label=label,command=command):
                command()
            QtCore.QObject.connect(
                action,QtCore.SIGNAL("triggered()"),insert_callback)
.. @+node:ekr.20110605121601.18352: *8* insert_cascade (leoQtMenu)
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    # g.trace(label,menu)

    menu.setTitle(label)
    
    label.replace('&','').lower()
    menu.leo_menu_label = label # was leo_label

    if parent:
        parent.addMenu(menu)
    else:
        self.menuBar.addMenu(menu)
        
    action = menu.menuAction()
    if action:
        action.leo_menu_label = label
    else:
        g.trace('no action for menu',label)

    return menu
.. @+node:ekr.20110605121601.18353: *8* new_menu (leoQtMenu)
def new_menu(self,parent,tearoff=False,label=''): # label is for debugging.

    """Wrapper for the Tkinter new_menu menu method."""

    c = self.c ; leoFrame = self.frame

    # g.trace(parent,label)

    # Parent can be None, in which case it will be added to the menuBar.
    menu = qtMenuWrapper(c,leoFrame,parent,label)

    return menu
.. @+node:ekr.20110605121601.18354: *7* Methods with other spellings (Qtmenu)
.. @+node:ekr.20110605121601.18355: *8* clearAccel
def clearAccel(self,menu,name):

    pass

    # if not menu:
        # return

    # realName = self.getRealMenuName(name)
    # realName = realName.replace("&","")

    # menu.entryconfig(realName,accelerator='')
.. @+node:ekr.20110605121601.18356: *8* createMenuBar (Qtmenu)
def createMenuBar(self,frame):

    '''Create all top-level menus.
    The menuBar itself has already been created.'''

    self.createMenusFromTables()
.. @+node:ekr.20110605121601.18357: *8* createOpenWithMenu (QtMenu)
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create the File:Open With submenu.

    This is called from leoMenu.createOpenWithMenuFromTable.'''

    # Use the existing Open With menu if possible.
    # g.trace(parent,label,index)

    menu = self.getMenu('openwith')

    if not menu:
        menu = self.new_menu(parent,tearoff=False,label=label)
        menu.insert_cascade(parent,index,
            label,menu,underline=amp_index)

    return menu
.. @+node:ekr.20110605121601.18358: *8* disable/enableMenu (leoQtMenu) (not used)
def disableMenu (self,menu,name):
    self.enableMenu(menu,name,False)

def enableMenu (self,menu,name,val):
    
    '''Enable or disable the item in the menu with the given name.'''
    
    trace = False and name.startswith('Paste') and not g.unitTesting
    
    if trace: g.trace(val,name,menu)

    if menu and name:
        val = bool(val)
        # g.trace('%5s %s %s' % (val,name,menu))
        for action in menu.actions():
            s = g.toUnicode(action.text()).replace('&','')
            if s.startswith(name):
                action.setEnabled(val)
                break
        else:
            if trace: g.trace('not found:',name)
.. @+node:ekr.20110605121601.18359: *8* getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    # At present, it is valid to always return None.
.. @+node:ekr.20110605121601.18360: *8* setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    def munge(s):
        return g.u(s or '').replace('&','')

    # menu is a qtMenuWrapper.
    # g.trace('menu',menu,'name: %20s label: %s' % (name,label))
    if not menu: return

    realName  = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
.. @+node:ekr.20110605121601.18361: *6* Activate menu commands
def activateMenu (self,menuName):

    '''Activate the menu with the given name'''

    c = self.c
    menu = self.getMenu(menuName)
    # g.trace(menuName,menu)
    if menu:
        top = c.frame.top.leo_ui
        pos = menu.pos() # Doesn't do any good.
        r = top.geometry()
        pt = QtCore.QPoint(r.x()+pos.x(),r.y())
        menu.exec_(pt)
.. @+node:ekr.20110605121601.18362: *6* getMacHelpMenu
def getMacHelpMenu (self,table):

    return None
.. @+node:ekr.20070411101643.1: *5* doOpenWith (ParserBaseClass)
def doOpenWith (self,p,kind,name,val):

    # g.trace(self.c.shortFileName(),'kind',kind,'name',name,'val',val)

    d = self.parseOpenWith(p)
    d['name']=name
    d['shortcut']=val
    name = kind = 'openwithtable'
    self.openWithList.append(d)
    self.set(p,kind,name,self.openWithList)
.. @+node:ekr.20070926135612: *5* createMenusFromConfigList & helpers (leoMenu)
def createMenusFromConfigList (self,aList):

    '''Create menus from aList instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    trace = False and not g.unitTesting
    c = self.c
    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))

    table = c.config.getOpenWith() 
    if table:
        if trace:
            for z in table:
                g.trace(z)
        self.createOpenWithMenuFromTable(table)
    
.. @+node:ekr.20070927082205: *6* createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
.. @+node:ekr.20070927172712: *6* handleSpecialMenus
def handleSpecialMenus (self,name,parentName,table=None):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    if table is None: table = []
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.
        # createRecentFilesMenuItems will create the contents later.
        self.createNewMenu(name,parentName)
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
.. @+node:ekr.20031218072017.2823: *5* c.openWith and helpers
def openWith(self,event=None,data=None):

    '''This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    '''

    # g.trace('data',data)
    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook('openwith1',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(arg,fn,openType)
        g.doHook('openwith2',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()

    return # (for Tk) 'break'
.. @+node:ekr.20031218072017.2824: *6* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
.. @+node:ekr.20031218072017.2829: *6* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    if arg is None: arg = ''

    try:
        if trace: g.trace(repr(openType),repr(arg),repr(fn))
        command = '<no command>'
        if openType == 'os.system':
            if 1:
                # This works, *provided* that arg does not contain blanks.  Sheesh.
                command = 'os.system(%s)' % (arg+fn)
                if trace: g.trace(command)
                if not testing: os.system(arg+fn)
            else:
                # XP does not like this format!
                command = 'os.system("%s %s")' % (arg,fn)
                if not testing: os.system('"%s" "%s"' % (arg,fn))
        elif openType == 'os.startfile':
            command = 'os.startfile(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: os.startfile(arg+fn)
        elif openType == 'exec':
            command = 'exec(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: exec(arg+fn,{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            if g.isString(arg):
                if arg:
                    vtuple = arg + ' ' + fn
                else:
                    vtuple = fn
            elif isinstance(arg,(list, tuple)):
                vtuple = arg[:]
                vtuple.append(fn)
                use_shell = False
            command = 'subprocess.Popen(%s)' % repr(vtuple)
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(vtuple,shell=use_shell)
                except OSError:
                    g.es_print('vtuple',repr(vtuple))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
.. @+node:ekr.20100203050306.5797: *6* c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
.. @+node:ekr.20031218072017.2827: *7* c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
.. @+node:ekr.20100203050306.5937: *7* c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if not g.unitTesting:
            if g.os_path_exists(fn):
                g.es('recreating:  ',g.shortFileName(fn),color='red')
            else:
                g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time and not g.unitTesting:
                g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
.. @+node:ekr.20031218072017.2832: *6* c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

     This is overridden in mod_tempfname plugin
     '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
.. @+node:ekr.20120205022040.17006: *5* createPopupMenu (From Tk)
def createPopupMenu (self,event):

    c = self.c ; frame = c.frame


    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)

    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)

    << Create the menu table >>

    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)
.. @+node:ekr.20120205022040.17007: *6* << Create the menu table >>
table = (
    ("&Read @file Nodes",c.readAtFileNodes),
    ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&Tangle",c.tangle),
    ("&Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&Paste Node",c.pasteOutline),
    ("&Delete Node",c.deleteOutline),
    ("-",None),
    ("&Insert Node",c.insertHeadline),
    ("&Clone Node",c.clone),
    ("Sort C&hildren",c.sortChildren),
    ("&Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)
.. @+node:ekr.20120205022040.17010: *5* Changed
.. @+node:ekr.20120205022040.17745: *6* \@openwith name = shortcut
@openwith nodes in @settings trees create menu items. The openWith
plugin must be active for these settings to have any effect.

The headline of an @openwith node has the form::

    @openwith name = shortcut
    
name is name of the menu item. shortcut specifies the shortcut used to invoke
the menu item. shortcut may be None.

The body text @openwith nodes should contain a single line contain a tuple of the form::

    command,arg,ext

For example::
    
    'subprocess.Popen',['pythonw','C:/Python24/Lib/idlelib/idle.pyw'],'.py'
    
When the user selects this menu item Leo executes command(arg+path) where path
is the full path to the temp file. The ext argument specifies the extension of
the temp file. Notes:

- command is a string.  Valid values are::
    
  'subprocess.Popen'
  'os.system'
  'os.startfile'
  'os.spawnl'
  'os.spawnv'
  'exec'
  
- arg is either a single string or a list of strings.

- ext is a string or None. If None, Leo computes a file extension base on what
  @language directive is in effect.
  
- If the .leo file being loaded contains @openwith nodes, the File:Open With
menu contains only the items created by those nodes. Similarly, @openwith nodes
in myLeoSettings.leo override entries in leoSettings.leo.

- If no @openwith nodes are found anywhere the openWith plugin uses hard-coded
tables in the plugin itself.
.. @+node:ekr.20031218072017.2829: *6* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    if arg is None: arg = ''

    try:
        if trace: g.trace(repr(openType),repr(arg),repr(fn))
        command = '<no command>'
        if openType == 'os.system':
            if 1:
                # This works, *provided* that arg does not contain blanks.  Sheesh.
                command = 'os.system(%s)' % (arg+fn)
                if trace: g.trace(command)
                if not testing: os.system(arg+fn)
            else:
                # XP does not like this format!
                command = 'os.system("%s %s")' % (arg,fn)
                if not testing: os.system('"%s" "%s"' % (arg,fn))
        elif openType == 'os.startfile':
            command = 'os.startfile(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: os.startfile(arg+fn)
        elif openType == 'exec':
            command = 'exec(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: exec(arg+fn,{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            if g.isString(arg):
                if arg:
                    vtuple = arg + ' ' + fn
                else:
                    vtuple = fn
            elif isinstance(arg,(list, tuple)):
                vtuple = arg[:]
                vtuple.append(fn)
                use_shell = False
            command = 'subprocess.Popen(%s)' % repr(vtuple)
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(vtuple,shell=use_shell)
                except OSError:
                    g.es_print('vtuple',repr(vtuple))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
.. @+node:ekr.20031218072017.2823: *6* c.openWith and helpers
def openWith(self,event=None,data=None):

    '''This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.

    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:

    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    '''

    # g.trace('data',data)
    c = self ; p = c.p
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook('openwith1',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            ext = c.getOpenWithExt(p,ext)
            fn = c.openWithHelper(p,ext)
            if fn:
                g.enableIdleTimeHook(idleTimeDelay=500)
                c.openTempFileInExternalEditor(arg,fn,openType)
        g.doHook('openwith2',c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()

    return # (for Tk) 'break'
.. @+node:ekr.20031218072017.2824: *7* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
.. @+node:ekr.20031218072017.2829: *7* c.openTempFileInExternalEditor
def openTempFileInExternalEditor(self,arg,fn,openType,testing=False):

    '''Open the closed mkstemp file fn in an external editor.
    The arg and openType args come from the data arg to c.openWith.
    '''

    trace = False and not g.unitTesting
    testing = testing or g.unitTesting
    if arg is None: arg = ''

    try:
        if trace: g.trace(repr(openType),repr(arg),repr(fn))
        command = '<no command>'
        if openType == 'os.system':
            if 1:
                # This works, *provided* that arg does not contain blanks.  Sheesh.
                command = 'os.system(%s)' % (arg+fn)
                if trace: g.trace(command)
                if not testing: os.system(arg+fn)
            else:
                # XP does not like this format!
                command = 'os.system("%s %s")' % (arg,fn)
                if not testing: os.system('"%s" "%s"' % (arg,fn))
        elif openType == 'os.startfile':
            command = 'os.startfile(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: os.startfile(arg+fn)
        elif openType == 'exec':
            command = 'exec(%s)' % (arg+fn)
            if trace: g.trace(command)
            if not testing: exec(arg+fn,{},{})
        elif openType == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg,filename,fn)
            if trace: g.trace(command)
            if not testing: os.spawnl(os.P_NOWAIT,arg,filename,fn)
        elif openType == 'os.spawnv':
            filename = os.path.basename(arg[0]) 
            vtuple = arg[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s,%s)' % (arg[0],repr(vtuple))
            if trace: g.trace(command)
            if not testing: os.spawnv(os.P_NOWAIT,arg[0],vtuple)
        elif openType == 'subprocess.Popen':
            use_shell = True
            if g.isString(arg):
                if arg:
                    vtuple = arg + ' ' + fn
                else:
                    vtuple = fn
            elif isinstance(arg,(list, tuple)):
                vtuple = arg[:]
                vtuple.append(fn)
                use_shell = False
            command = 'subprocess.Popen(%s)' % repr(vtuple)
            if trace: g.trace(command)
            if not testing:
                try:
                    subprocess.Popen(vtuple,shell=use_shell)
                except OSError:
                    g.es_print('vtuple',repr(vtuple))
                    g.es_exception()
        elif g.isCallable(openType):
            # Invoke openWith like this:
            # c.openWith(data=[f,None,None])
            # f will be called with one arg, the filename
            if trace: g.trace('%s(%s)' % (openType,fn))
            command = '%s(%s)' % (openType,fn)
            if not testing: openType(fn)
        else:
            command='bad command:'+str(openType)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:',command)
        g.es_exception()
        return 'oops: %s' % command
.. @+node:ekr.20100203050306.5797: *7* c.openWithHelper
def openWithHelper (self,p,ext):

    '''create or reopen a temp file for p,
    testing for conflicting changes.
    '''

    c = self

    # May be over-ridden by mod_tempfname plugin.
    searchPath = c.openWithTempFilePath(p,ext)
    if not searchPath:
        # Check the mod_tempfname plugin.
        return g.trace('c.openWithTempFilePath failed',color='red')

    # Set d and path if a temp file already refers to p.v
    path = None
    if g.os_path_exists(searchPath):
        for d in g.app.openWithFiles:
            if p.v == d.get('v') and searchPath == d.get('path'):
                path = searchPath ; break

    if path:
        assert d.get('path') == searchPath
        fn = c.createOrRecreateTempFileAsNeeded(p,d,ext)
    else:
        fn = c.createOpenWithTempFile(p,ext)

    return fn # fn may be None.
.. @+node:ekr.20031218072017.2827: *8* c.createOrRecreateTempFileAsNeeded
conflict_message = '''
Conflicting changes in outline and temp file.
Do you want to use the data in the outline?
Yes: use the data in the outline.
No: use the data in the temp file.
Cancel or Escape or Return: do nothing.
'''

def createOrRecreateTempFileAsNeeded (self,p,d,ext):

    '''test for changes in both p and the temp file:

    - If only p's body text has changed, we recreate the temp file.
    - If only the temp file has changed, do nothing here.
    - If both have changed we must prompt the user to see which code to use.

    Return the file name.
    '''
    c = self

    fn = d.get('path')
    # Get the old & new body text and modification times.
    encoding = d.get('encoding')
    old_body = d.get('body')
    new_body = g.toEncodedString(p.b,encoding,reportErrors=True)
    old_time = d.get('time')
    try:
        new_time = g.os_path_getmtime(fn)
    except Exception:
        new_time = None
    body_changed = old_body != new_body
    time_changed = old_time != new_time

    if body_changed and time_changed:
        g.es_print('Conflict in temp file for',p.h,color='red')
        result = g.app.gui.runAskYesNoCancelDialog(c,
            'Conflict!', c.conflict_message,
            yesMessage = 'Outline',
            noMessage = 'File',
            defaultButton = 'Cancel')
        if result is None or result.lower() == 'cancel':
            return False
        rewrite = result.lower() == 'yes'
    else:
        rewrite = body_changed

    if rewrite:
        # May be overridden by the mod_tempfname plugin.
        fn = c.createOpenWithTempFile(p,ext)
    else:
        g.es('reopening:',g.shortFileName(fn),color='blue')

    return fn
.. @+node:ekr.20100203050306.5937: *8* c.createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):

    trace = False and not g.unitTesting
    c = self ; f = None

    # May be over-ridden by mod_tempfname plugin.
    fn = c.openWithTempFilePath(p,ext)

    try:
        if not g.unitTesting:
            if g.os_path_exists(fn):
                g.es('recreating:  ',g.shortFileName(fn),color='red')
            else:
                g.es('creating:  ',g.shortFileName(fn),color='blue')
        f = open(fn,'w')
        # Convert s to whatever encoding is in effect.
        d = c.scanAllDirectives(p)
        encoding = d.get('encoding',None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        if g.isPython3: # 2010/02/09
            s = p.b
        else:
            s = g.toEncodedString(p.b,encoding,reportErrors=True) 
        f.write(s)
        f.flush()
        f.close()
        try:
            time = g.os_path_getmtime(fn)
            if time and not g.unitTesting:
                g.es('time: ',time)
        except:
            time = None

        # Remove previous entry from app.openWithFiles if it exists.
        for d in g.app.openWithFiles[:]:
            if p.v == d.get('v'):
                if trace: g.trace('removing',d.get('path'))
                g.app.openWithFiles.remove(d)

        d = {
            # Used by app.destroyOpenWithFilesForFrame.
            'c':c,
            # Used here and by app.destroyOpenWithFileWithDict.
            'path':fn,
            # Used by c.testForConflicts.
            'body':s,
            'encoding':encoding,
            'time':time,
            # Used by the open_with plugin.
            'p':p.copy(),
            # Used by c.openWithHelper, and below.
            'v':p.v,
        }
        g.app.openWithFiles.append(d)
        return fn
    except:
        if f: f.close()
        g.es('exception creating temp file',color='red')
        g.es_exception()
        return None
.. @+node:ekr.20031218072017.2832: *7* c.openWithTempFilePath (may be over-ridden)
def openWithTempFilePath (self,p,ext):

    '''Return the path to the temp file corresponding to p and ext.

     This is overridden in mod_tempfname plugin
     '''

    fn = '%s_LeoTemp_%s%s' % (
        g.sanitize_filename(p.h),
        str(id(p.v)),ext)
    if g.isPython3: # 2010/02/07
        fn = g.toUnicode(fn)
    td = g.os_path_finalize(tempfile.gettempdir())
    path = g.os_path_join(td,fn)

    return path
.. @+node:ekr.20070926135612: *6* createMenusFromConfigList & helpers (leoMenu)
def createMenusFromConfigList (self,aList):

    '''Create menus from aList instead of 'hard coded' menus.
    The 'top' menu has already been created.'''

    trace = False and not g.unitTesting
    c = self.c
    tag = '@menu'
    for z in aList:
        kind,val,val2 = z
        if kind.startswith(tag):
            name = kind[len(tag):].strip()
            if not self.handleSpecialMenus(name,parentName=None):
                self.createNewMenu(name) # Create top-level menu.
                self.createMenuFromConfigList(name,val,level=0)
        else:
            self.error('%s %s not valid outside @menu tree' % (kind,val))

    table = c.config.getOpenWith() 
    if table:
        if trace:
            for z in table:
                g.trace(z)
        self.createOpenWithMenuFromTable(table)
    
.. @+node:ekr.20070927082205: *7* createMenuFromConfigList
def createMenuFromConfigList (self,parentName,aList,level=0):

    table = [] ; parentMenu = self.getMenu(parentName)

    for z in aList:
        kind,val,val2 = z
        if kind.startswith('@menu'):
            # Menu names can be unicode without any problem.
            name = kind[5:].strip()
            if table:
                self.createMenuEntries(parentMenu,table)
            if not self.handleSpecialMenus(name,parentName,table):
                self.createNewMenu(name,parentName) # Create submenu of parent menu.
                self.createMenuFromConfigList(name,val,level+1)
            table = []
        elif kind == '@item':
            name = str(val) # Item names must always be ascii.
            if val2:
                # Translated names can be unicode.
                table.append((val2,name),)
            else:
                table.append(name)
        else:
            g.trace('can not happen: bad kind:',kind)

    if table:
        self.createMenuEntries(parentMenu,table)
.. @+node:ekr.20070927172712: *7* handleSpecialMenus
def handleSpecialMenus (self,name,parentName,table=None):

    '''Handle a special menu if name is the name of a special menu.
    return True if this method handles the menu.'''

    c = self.c
    if table is None: table = []
    name2 = name.replace('&','').replace(' ','').lower()

    if name2 == 'plugins':
        # Create the plugins menu using a hook.
        g.doHook("create-optional-menus",c=c)
        return True
    elif name2.startswith('recentfiles'):
        # Just create the menu.
        # createRecentFilesMenuItems will create the contents later.
        self.createNewMenu(name,parentName)
        return True
    elif name2 == 'help' and sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu(table)
        return helpMenu is not None
    else:
        return False
.. @+node:ekr.20110605121601.18357: *6* createOpenWithMenu (QtMenu)
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create the File:Open With submenu.

    This is called from leoMenu.createOpenWithMenuFromTable.'''

    # Use the existing Open With menu if possible.
    # g.trace(parent,label,index)

    menu = self.getMenu('openwith')

    if not menu:
        menu = self.new_menu(parent,tearoff=False,label=label)
        menu.insert_cascade(parent,index,
            label,menu,underline=amp_index)

    return menu
.. @+node:ekr.20031218072017.4116: *6* createOpenWithMenuFromTable & helper (leoMenu)
def createOpenWithMenuFromTable (self,table):

    '''Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.'''

    trace = False and not g.unitTesting
    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    if trace: g.trace('parent',parent)
    if not parent:
        if not g.app.batchMode:
            g.es('','createOpenWithMenuFromTable:','no File menu',color="red")
        return

    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except:
            if trace:
                g.trace('unexpected exception')
                g.es_exception()
            return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    if not openWithMenu:
        if trace: g.trace('openWithMenu returns None')
        return
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    
    #### Each item is a dict.
    # for entry in table:
        # if len(entry) != 3: # 6/22/03
            # g.es('','createOpenWithMenuFromTable:','invalid data',color="red")
            # return

    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    
    for entry in table:
        name,shortcut,data = entry
        c.k.bindOpenWith (shortcut,name,data)
.. @+node:ekr.20051022043608.1: *7* createOpenWithMenuItemsFromTable (leoMenu)
def createOpenWithMenuItemsFromTable (self,menu,table):

    '''Create an entry in the Open with Menu from the table.

    Each entry should be a sequence with 2 or 3 elements.'''

    c = self.c ; k = c.k

    if g.app.unitTesting: return

    for d in table:
        label = d.get('name')
        command = d.get('command')
        if command: command = command.split(',')
        # g.trace('command',type(command),command)
        accel = d.get('shortcut') or ''
        if label and command:
            realLabel = self.getRealMenuName(label)
            underline=realLabel.find("&")
            realLabel = realLabel.replace("&","")
            callback = self.defineOpenWithMenuCallback(command) #### openWithData)
            c.add_command(menu,label=realLabel,accel=accel,
                command=callback,underline=underline)
.. @+node:ekr.20031218072017.4118: *6* defineOpenWithMenuCallback (leoMenu)
def defineOpenWithMenuCallback(self,data):

    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        return self.c.openWith(data=data)

    return openWithMenuCallback
.. @+node:ekr.20070411101643.2: *6* parseOpenWith & helper
def parseOpenWith (self,p):

    d = {'command': None,}

    s = p.b
    lines = g.splitLines(s)

    for line in lines:
        self.parseOpenWithLine(line,d)

    return d
.. @+node:ekr.20070411101643.4: *7* parseOpenWithLine
def parseOpenWithLine (self,line,d):

    s = line.strip()
    if not s: return

    try:
        s = str(s)
    except UnicodeError:
        pass

    if not g.match(s,0,'#'):
        d['command'] = s
.. @+node:ekr.20120208062900.10146: *4* new_modes
@nocolor-node

This will eliminate the hacks for *entry-commands* and *command-prompt keys.

ModeController: a wrapper for g.app.config.modeCommandsDict
.. @+node:ekr.20120212060348.10374: *5*  << global switches >>
trace_startup = False
    # These traces use print instead of g.trace so that
    # the traces can add class info the method name.

new_modes = False
    # True: use ModeController and ModeInfo classes.
if new_modes: print('***** new_modes')

new_keys = False
    # This project hardly seems urgent.
    # True: Qt input methods produce a **user setting**, not a stroke.
if new_keys: print('***** new_keys')

# Traces of scrolling problems.
trace_scroll = False
    # Trace calls to get/setYScrollPosition
trace_see = False
    # Trace calls to see and setInsertPoint.

# Switches to trace the garbage collector.
trace_gc = False           
trace_gc_calls = False    
trace_gc_calls = False 
trace_gc_verbose = False
trace_gc_inited = False

trace_masterCommand = False
trace_masterKeyHandler = False
trace_masterKeyHandlerGC = False
trace_minibuffer = False
trace_modes = False

enableDB = True
    # Don't even think about eliminating this constant:
    # it is needed for debugging.
    
# These print statements have been moved to writeWaitingLog.
# This allows for better --silent operation.
if 0:
    print('*** isPython3: %s' % isPython3)
    if not enableDB:
        print('** leoGlobals.py: caching disabled')
.. @+node:ekr.20120208061308.10131: *5* Weird stroke code
@nocolor-node

isFKey and k.isPlainKey don't seem to know the types of their args.
.. @+node:ekr.20061031131434.181: *6* k.Shortcuts & bindings
.. @+node:ekr.20061031131434.176: *7* k.computeInverseBindingDict
def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert g.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])
            
            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,g.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
.. @+node:ekr.20061031131434.179: *7* k.getShortcutForCommand/Name
def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand (self,command):

    k = self ; c = k.c
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == command.__name__:
                    return stroke
    return None
.. @+node:ekr.20090518072506.8494: *7* k.isFKey
def isFKey (self,stroke):

    k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) <= 3 and s[1:].isdigit()
.. @+node:ekr.20061031131434.182: *7* k.isPlainKey
def isPlainKey (self,stroke):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self
    if not stroke: return False

    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for z in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(z) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20061031131434.191: *7* k.prettyPrintKey
def prettyPrintKey (self,stroke,brief=False):

    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke

    if not s: return ''

    shift = s.find("shift") >= 0 or s.find("shft") >= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06
        
    return s
.. @+node:ekr.20061031131434.184: *7* k.strokeFromSetting
def strokeFromSetting (self,setting,addKey=True):

    k = self

    trace = True and not g.unitTesting # and setting.lower().find('ctrl-x') > -1
    verbose = False
    if not setting:
        return None
    
    assert g.isString(setting)

    s = g.stripBrackets(setting.strip())
    << define cmd, ctrl, alt, shift >>
    if k.swap_mac_keys and sys.platform == "darwin":
        << swap cmd and ctrl keys >>
    << convert minus signs to plus signs >>
    << compute the last field >>
    << compute shortcut >>

    if trace and verbose:
        g.trace('%20s %s' % (setting,shortcut),g.callers())
    
    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
### strokeFromSetting = shortcutFromSetting
.. @+node:ekr.20061031131434.185: *8* << define cmd, ctrl, alt, shift >>
s2 = s.lower()

cmd   = s2.find("cmd") >= 0     or s2.find("command") >= 0
ctrl  = s2.find("control") >= 0 or s2.find("ctrl") >= 0
alt   = s2.find("alt") >= 0
shift = s2.find("shift") >= 0   or s2.find("shft") >= 0
meta  = s2.find("meta") >= 0
.. @+node:ekr.20061031131434.186: *8* << swap cmd and ctrl keys >>
if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
.. @+node:ekr.20061031131434.187: *8* << convert minus signs to plus signs >>
# Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
.. @+node:ekr.20061031131434.188: *8* << compute the last field >>
if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s),repr(setting))
            g.trace(g.callers())
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
.. @+node:ekr.20061031131434.189: *8* << compute shortcut >>
table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag,val in table if flag])
.. @+node:ekr.20110606004638.16929: *7* k.stroke2char
def stroke2char (self,stroke):
    
    '''Convert a stroke to an (insertable) char.
    
    This method allows Leo to use strokes everywhere.'''
    
    trace = False and not g.unitTesting
    k = self
    
    if not stroke: return ''
    s = stroke.s
    
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1:-1]
        
    if len(s) == 0: return ''
    if len(s) == 1: return s
        
    for z in ('Alt','Ctrl','Command','Meta'):
        if s.find(z) != -1:            
            return ''
            # This is not accurate: leoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
            
    # Special case the gang of four, plus 'Escape',
    d = {
        'BackSpace':'\b',
        'Escape':'Escape',
        'Linefeed':'\r',
        'Return':'\n',
        'Tab':'\t',
    }
    ch = d.get(s)
    if ch: return ch
            
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke),repr(ch))
        return ch
    
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+','').replace('Shift-','')
    
    last = s #  Everything should have been stripped.
    
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    
    val = g.choose(len(s)==1,s,'')

    if trace: g.trace(repr(stroke),repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20061031131434.100: *5* k.addModeCommands (enterModeCallback) (OLD MODES)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''
    
    trace = False and not g.unitTesting
    
    if trace: g.trace('(k)')

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20120208064440.10192: *5* From leoConfig...
.. @+node:ekr.20060102103625.1: *6* doMode (ParserBaseClass)
def doMode(self,p,kind,name,val):

    '''Parse an @mode node and create the enter-<name>-mode command.'''

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    
    if g.new_modes:
        aList = []
        for line in g.splitLines(p.b):
            line = line.strip()
            if line and not g.match(line,0,'#'):
                name2,si = self.parseShortcutLine('*mode-setting*',line)
                aList.append((name2,si),)
        k.modeController.makeMode(name,aList)
    else:
        name1 = name

        # g.trace('%20s' % (name),c.fileName())
        modeName = self.computeModeName(name)
    
        d = g.TypedDictOfLists(
            name='modeDict for %s' % (modeName),
            keyType=type('commandName'),valType=g.ShortcutInfo)
    
        s = p.b
        lines = g.splitLines(s)
        for line in lines:
            line = line.strip()
            if line and not g.match(line,0,'#'):
                name,si = self.parseShortcutLine('*mode-setting*',line)
                assert g.isShortcutInfo(si),si
                if not name:
                    # An entry command: put it in the special *entry-commands* key.
                    d.add('*entry-commands*',si)
                elif si is not None:
                    # A regular shortcut.
                    si.pane = modeName
                    aList = d.get(name,[])
                    for z in aList:
                        assert g.isShortcutInfo(z),z
                    # Important: use previous bindings if possible.
                    key2,aList2 = c.config.getShortcut(name)
                    for z in aList2:
                        assert g.isShortcutInfo(z),z
                    aList3 = [z for z in aList2 if z.pane != modeName]
                    if aList3:
                        # g.trace('inheriting',[b.val for b in aList3])
                        aList.extend(aList3)
                    aList.append(si)
                    d.replace(name,aList)
                    
                    if 0: #### Why would we want to do this????
                        #### Old code: we have to save/restore self.shortcutsDict.
                            #### self.set(p,"shortcut",name,aList)
                        # Set the entry directly.
                        d2 = self.shortcutsDict
                        gs = d2.get(key2)
                        if gs:
                            assert g.isGeneralSetting(gs)
                            path = gs.path
                            if c.os_path_finalize(c.mFileName) != c.os_path_finalize(path):
                                g.es("over-riding setting:",name,"from",path)
        
                        # Important: we can't use c here: it may be destroyed!
                        d2 [key2] = g.GeneralSetting(
                            kind,path=c.mFileName,val=val,tag='setting')
    
            # Restore the global shortcutsDict.
            ##### self.shortcutsDict = old_d
            
            if trace: g.trace(d.dump())
        
            # Create the command, but not any bindings to it.
            self.createModeCommand(modeName,name1,d)
.. @+node:ekr.20041120112043: *6* parseShortcutLine (ParserBaseClass)
def parseShortcutLine (self,kind,s):

    '''Parse a shortcut line.  Valid forms:

    --> entry-command
    settingName = shortcut
    settingName ! paneName = shortcut
    command-name --> mode-name = binding
    command-name --> same = binding
    '''

    trace = False and not g.unitTesting # and kind == '*mode-setting*'
    c,k = self.c,self.c.k
    assert c
    name = val = nextMode = None ; nextMode = 'none'
    i = g.skip_ws(s,0)

    if g.match(s,i,'-->'): # New in 4.4.1 b1: allow mode-entry commands.
        j = g.skip_ws(s,i+3)
        i = g.skip_id(s,j,'-')
        entryCommandName = s[j:i]
        if trace: g.trace('-->',entryCommandName)
        return None,g.ShortcutInfo('*entry-command*',commandName=entryCommandName)

    j = i
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name:
        if trace: g.trace('no name',repr(s))
        return None,None

    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'->'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]

    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]

    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    stroke = k.strokeFromSetting(val)
    assert g.isStrokeOrNone(stroke),stroke
    # g.trace('stroke',stroke)
    si = g.ShortcutInfo(kind=kind,nextMode=nextMode,pane=pane,stroke=stroke)
    if trace: g.trace('%25s %s' % (name,si))
    return name,si
.. @+node:ekr.20060102103625: *6* createModeCommand (ParserBaseClass)
def createModeCommand (self,modeName,name,modeDict):

    modeName = 'enter-' + modeName.replace(' ','-')

    i = name.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = name[i+2:].strip()
        modeDict ['*command-prompt*'] = g.ShortcutInfo(kind=prompt)

    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    # New in 4.4.1 b2: silently allow redefinitions of modes.
    d [modeName] = modeDict
.. @+node:ekr.20120208064440.10148: *5* class ModeController
class ModeController:
    
    def __init__ (self,c):
        self.c = c
        self.d = {} # Keys are command names, values are modes.
        self.k = c.k
        g.trace(self)
            
    def __repr__(self):
        return '<ModeController %s>' % self.c.shortFileName()
        
    __str__ = __repr__
            
    @others
.. @+node:ekr.20120208064440.10161: *6* addModeCommands (ModeController)
def addModeCommands(self):
    
    g.trace(self,self.d)
    
    for mode in self.d.values():
        mode.createModeCommand()
.. @+node:ekr.20120208064440.10163: *6* getMode (ModeController)
def getMode (self,modeName):
    
    g.trace(self)
    
    mode = self.d.get(modeName)
    g.trace(modeName,mode)
    return mode
    
.. @+node:ekr.20120208064440.10164: *6* makeMode (ModeController)
def makeMode (self,name,aList):


    mode = ModeInfo(self.c,name,aList)
    
    g.trace(self,mode.name,mode)
    self.d[mode.name] = mode
    
.. @+node:ekr.20120208064440.10150: *5* class ModeInfo
class ModeInfo:
    
    def __repr__(self):
        return '<ModeInfo %s>' % self.name
        
    __str__ = __repr__
    
    @others
    
.. @+node:ekr.20120208064440.10193: *6*  ctor (ModeInfo)
def __init__ (self,c,name,aList):
    
    self.c = c
    self.d = {} # The bindings in effect for this mode.
        # Keys are names of (valid) command names, values are ShortcutInfo objects.
    self.entryCommands = []
        # A list of ShortcutInfo objects.
    self.k = c.k
    self.name = self.computeModeName(name)
    self.prompt = self.computeModePrompt(self.name)

    self.init(name,aList)
.. @+node:ekr.20120208064440.10152: *6* computeModeName (ModeInfo)
def computeModeName (self,name):

    s = name.strip().lower()
    j = s.find(' ')
    if j > -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]

    i = s.find('::')
    if i > -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]

    return s + '-mode'
.. @+node:ekr.20120208064440.10156: *6* computeModePrompt (ModeInfo)
def computeModePrompt (self,name):
    
    assert name == self.name
    s = 'enter-' + name.replace(' ','-')
    i = s.find('::')
    if i > -1:
        # The prompt is everything after the '::'
        prompt = s[i+2:].strip()
    else:
        prompt = s
    
    return prompt
.. @+node:ekr.20120208064440.10160: *6* createModeBindings (ModeInfo) (NOT USED)
##### k.createModeBindings is used instead????

def createModeBindings (self,w):

    '''Create mode bindings for w, a text widget.'''

    trace = True and not g.unitTesting
    c,d,k,modeName = self.c,self.d,self.k,self.name
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command: %s Referenced from %s' % (
                commandName,modeName))
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            if trace: g.trace(si)
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                        
                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
                if trace: g.trace(modeName,d2)
.. @+node:ekr.20120208064440.10195: *6* createModeCommand (ModeInfo)
def createModeCommand (self):
    
    g.trace(self)

    c,k = self.c,self.k
    key = 'enter-' + self.name.replace(' ','-')
   
    def enterModeCallback (event=None,self=self):
        self.enterMode()

    c.commandsDict[key] = f = enterModeCallback
    k.inverseCommandsDict [f.__name__] = key
    
    g.trace('(ModeInfo)',f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20120208064440.10180: *6* enterMode (ModeInfo)
def enterMode (self):
    
    g.trace('(ModeInfo)')

    c,k = self.c,self.k
    c.inCommand = False
        # Allow inner commands in the mode.
    event=None ####
    k.generalModeHandler(event,modeName=self.name)
.. @+node:ekr.20120208064440.10153: *6* init (ModeInfo) (Can we check command names here??)
def init (self,name,dataList):
    
    '''aList is a list of tuples (commandName,si).'''
    
    trace = True and not g.unitTesting
    c,d,k,modeName = self.c,self.d,self.c.k,self.name
    for name,si in dataList:
    
        assert g.isShortcutInfo(si),si
        if not name:
            if trace: g.trace('entry command',si)
            #### An entry command: put it in the special *entry-commands* key.
            #### d.add('*entry-commands*',si)
            self.entryCommands.append(si)
        elif si is not None:
            # A regular shortcut.
            si.pane = modeName
            aList = d.get(name,[])
            for z in aList:
                assert g.isShortcutInfo(z),z
            # Important: use previous bindings if possible.
            key2,aList2 = c.config.getShortcut(name)
            for z in aList2:
                assert g.isShortcutInfo(z),z
            aList3 = [z for z in aList2 if z.pane != modeName]
            if aList3:
                if trace: g.trace('inheriting',[si.val for si in aList3])
                aList.extend(aList3)
            aList.append(si)
            d[name] = aList
.. @+node:ekr.20120208064440.10158: *6* initMode (ModeInfo)
def initMode (self):
    
    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    
    ####
    # d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    # if not d:
        # self.badMode(modeName)
        # return
    # else:
        # k.modeBindingsDict = d
        # si = d.get('*command-prompt*')
        # if si:
            # prompt = si.kind # A kludge.
        # else:
            # prompt = modeName
        # if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))

    k.inputModeName = self.name
    k.silentMode = False

    #### aList = d.get('*entry-commands*',[])
    for si in self.entryCommands:
        assert g.isShortcutInfo(si),si
        commandName = si.commandName
        if trace: g.trace('entry command:',commandName)
        k.simulateCommand(commandName)
        # Careful, the command can kill the commander.
        if g.app.quitting or not c.exists: return
        # New in Leo 4.5: a startup command can immediately transfer to another mode.
        if commandName.startswith('enter-'):
            if trace: g.trace('redirect to mode',commandName)
            return

    # Create bindings after we know whether we are in silent mode.
    # w = g.choose(k.silentMode,k.modeWidget,k.w)
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(self.name,self.d,w)
    #### self.createModeBindings(w)
    k.showStateAndMode(prompt=self.name)
.. @+node:ekr.20120208064440.10191: *5* From leoKeys...
.. @+node:ekr.20061031131434.76: *6* k.__init__
def __init__ (self,c):

    '''Create a key handler for c.'''
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.__init__')

    self.c = c
    self.dispatchEvent = None
    self.inited = False         # Set at end of finishCreate.
    self.swap_mac_keys = False  #### How to init this ????
    self.w = None
            # Note: will be None for nullGui.

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    
    self.defineSettingsIvars()
    
    << define externally visible ivars >>
    << define internal ivars >>
    
    if g.new_modes:
        self.modeController = ModeController(c)

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
.. @+node:ekr.20061031131434.78: *7* << define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.argSelectedText = '' # The selected text in state 0.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
# self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
.. @+node:ekr.20061031131434.79: *7* << define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of ShortcutInfo's.
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are ShortcutInfo's.
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

# Keys whose bindings are computed by initSpecialIvars.
self.abortAllModesKey = None
self.autoCompleteForceKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
.. @+node:ekr.20120208064440.10190: *6* k.Mode (OLD & NEW MODES)
.. @+node:ekr.20061031131434.157: *7* k.badMode
def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
.. @+node:ekr.20061031131434.158: *7* k.createModeBindings
def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)
                        
                assert g.isStroke(stroke)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode<%s>' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
.. @+node:ekr.20120208064440.10179: *7* k.endMode
def endMode(self):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
.. @+node:ekr.20061031131434.161: *7* k.exitNamedMode
def exitNamedMode (self,event=None):
    
    '''Exit an input mode.'''

    k = self

    if k.inState():
        k.endMode()

    k.showStateAndMode()
.. @+node:ekr.20061031131434.165: *7* k.modeHelp & helper
def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind <Tab> to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c

    c.endEditing()

    # g.trace(k.inputModeName)
    
    # if g.new_modes:
        # if k.inputMode:
            # k.inputMode.modeHelp()
    # else:
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)

    if not k.silentMode:
        c.minibufferWantsFocus()

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.166: *8* modeHelpHelper
def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data,n = [],0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*','*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si),si
                stroke = si.stroke
                if stroke not in (None,'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()
    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()
    g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
.. @+node:ekr.20061031131434.164: *7* k.reinitMode (call k.createModeBindings???)
def reinitMode (self,modeName):

    k = self ; c = k.c

    d = k.modeBindingsDict

    k.inputModeName = modeName
    w = g.choose(k.silentMode,k.modeWidget,k.w)
    k.createModeBindings(modeName,d,w)

    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ',protect=True)

.. @+node:ekr.20061031131434.156: *6* k.Modes (OLD MODES ONLY)
if not g.new_modes:
    
    @others
.. @+node:ekr.20061031131434.100: *7* k.addModeCommands (enterModeCallback) (OLD MODES)
def addModeCommands (self):

    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''
    
    trace = False and not g.unitTesting
    
    if trace: g.trace('(k)')

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.

    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
.. @+node:ekr.20061031131434.160: *7* k.enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
.. @+node:ekr.20120208064440.10199: *7* k.generalModeHandler (OLD MODES)
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return # (for Tk) 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.163: *7* k.initMode (OLD MODES)
def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting

    if not modeName:
        g.trace('oops: no modeName')
        return
        
    if g.new_modes:
        mode = k.modeController.getMode(modeName)
        if mode:
            mode.initMode()
        else:
            g.trace('***** oops: no mode',modeName)
    else:

        d = g.app.config.modeCommandsDict.get('enter-'+modeName)
        if not d:
            self.badMode(modeName)
            return
        else:
            k.modeBindingsDict = d
            si = d.get('*command-prompt*')
            if si:
                prompt = si.kind # A kludge.
            else:
                prompt = modeName
            if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))
    
        k.inputModeName = modeName
        k.silentMode = False
    
        aList = d.get('*entry-commands*',[])
        if aList:
            for si in aList:
                assert g.isShortcutInfo(si),si
                commandName = si.commandName
                if trace: g.trace('entry command:',commandName)
                k.simulateCommand(commandName)
                # Careful, the command can kill the commander.
                if g.app.quitting or not c.exists: return
                # New in Leo 4.5: a startup command can immediately transfer to another mode.
                if commandName.startswith('enter-'):
                    if trace: g.trace('redirect to mode',commandName)
                    return
    
        # Create bindings after we know whether we are in silent mode.
        w = g.choose(k.silentMode,k.modeWidget,k.w)
        k.createModeBindings(modeName,d,w)
        k.showStateAndMode(prompt=prompt)
.. @+node:ekr.20120208064440.10187: *6* k.Modes (NEW MODES ONLY)
if g.new_modes:
    
    @others
.. @+node:ekr.20120208064440.10201: *7* k.NEWgeneralModeHandler (NEW MODES)
def NEWgeneralModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return # (for Tk) 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'

    return # (for Tk) 'break'
.. @+node:ekr.20120226063218.10211: *4* Before 4.10 b1
@nocolor-node

Release 4.10 b1 after completing the following items:

- Get the Open With menu working again.

- Complete the new_modes work.

- Fix bug 844953: copy-clone-pasted node appears in other tab.

- Fix bug 869429: Undo and Redo delete from context menu does not redo properly.

- Factor the many leo-editor posts that I have marked as pre-writing into Leo's docs.
.. @+node:ekr.20111026091322.16502: *3* Next
.. @+node:ekr.20111019080436.15850: *4*  Fix all significant bugs
.. @+node:ekr.20111125072438.10204: *5* Wishlist bug 882243: Clones sometimes not saved: change how @others works
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/882243

In Leo, I made this file:

@file test.txt
@others
.....test1
     test: these are clones
.....test2
     @others

      what is going on...?
..........test1 <--- this is cloned
          test: these are clones

The output file does not have the cloned node:

#@+leo-ver=5-thin
#@+node:bill.20111025150533.3528: * @thin test.txt
#@+others
#@+node:bill.20111025150533.3527: ** test1
test: these are clones
#@+node:bill.20111025150533.3529: ** test2
#@+others
#@-others

what is going on...?
#@-others
#@-leo

I don't think it is a conflict with @others; it is just that some files do not retain the clones that are displayed.

Here is the copied node:

<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2"/>
<vnodes>
<v t="bill.20111025150533.3528" a="E"><vh>@thin test.txt</vh>
<v t="bill.20111025150533.3527"><vh>test1</vh></v>
<v t="bill.20111025150533.3529" a="E"><vh>test2</vh>
<v t="bill.20111025150533.3527"></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="bill.20111025150533.3527">test: these are clones
</t>
<t tx="bill.20111025150533.3528">@others
</t>
<t tx="bill.20111025150533.3529">@others

what is going on...?</t>
</tnodes>
</leo_file>

Here is the copied leo file:

<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
 <global_window_position top="50" left="50" height="500" width="700"/>
 <global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="bill.20111025150533.3528" a="E"
expanded="bill.20111025150533.3529,"><vh>@thin test.txt</vh></v>
</vnodes>
<tnodes>
</tnodes>
</leo_file>
.. @+node:ekr.20111216105907.10218: *6* My response: this is a wishlist item
@nocolor-node

Reposted from http://groups.google.com/group/leo-editor/browse_thread/thread/67a28984616d09c9
About bug 882243: clones sometimes not saved

I'd like to discuss this bug here, because I would like us all to be aware of the situation, and possible changes.

The surprise
=========

To paraphrase the original bug report, suppose we have the following @file tree:

+ @file test.txt
@others
  + node 1 (cloned)
    node 1 text.
  + node 2
     @others
    + node 1 (cloned)
       node 1 text.

As usual, lines preceded by "+" denote headlines: all other lines are body text.

The surprise is that the cloned node1 node is written to the external file only once (as a child of the root node) and hence does not appear as a (cloned) child of the node2 node when Leo next loads the @file tree.

History
=====

I would like to call this a wishlist item because the present code quite intentionally writes *any* node (including cloned nodes) only once. That is, the write code sets a bit when writing a node, and @others ignores any nodes with that bit set.

You could call this a bug in the @others write logic, but at one time it was done explicitly and on purpose.

I don't remember why this was so, but I do remember it *was* so. It may have been an artifact of Leo's old representation of clones that used both vnodes and tnodes. tnodes no longer exist in the one-node world that we have been living in for several years, and it may well be time to revisit the original design, but I would rather not do that just now because there are several "real" bugs that need attention asap.

Workaround
=========

Because this is an issue involving @others, you might assume that a workaround involving sections would be possible. You would be correct. The following file works as expected::

+ @file test.txt
<< node 1 >>
<< node 2 >>
  + << node 1>> (cloned)
     node 1 text.
  + << node 2 >>
     << node 1 >>
    + << node 1 >>(cloned)
       node 1 text.
.. @+node:ekr.20111026091322.16503: *5* Recent/Easy
.. @+node:ekr.20110619173515.14895: *6* Fix bug: realpath in g.openWithFileName
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/cd5e2125c9e13d8f

g.openWithFileName needs

   fileName = g.os_path_realpath(fileName)

at the start of it, otherwise

g.openWithFileName("/home/tbrown/.leo/.todo.leo", c) will open another
instance of an already open "/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo"
because it doesn't recognize them as being the same.

It would be nice if the original attempt to open
"/home/tbrown/.leo/.todo.leo" was not converted to
"/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo", but I think the POSIX
spec. insists on giving CPython the real path form, so this is hard to
avoid.  You see this when selecting a file using a file dialog, in the
dialog you choose /home/me/myfile.txt, but the return
is /mnt/usr1/usr1/home/me/myfile.txt.

Anyway, let me know if and when I can push that to trunk, impacts seem
to be limited to (a) not failing to detect an already opened file in
g.openWithFileName, which is a bug, and (b) sometimes less attractive
apparent paths, which is annoying, but I think better than the bug.

(this of course trips up UNLs
if /mnt/usr1/usr1/home/tbrown/.leo/.todo.leo is already loaded and the
UNL is /home/tbrown/.leo/.todo.leo#Home-->Paint roof)
.. @+node:ekr.20110621085435.6531: *6* Fix bug: Improve the find panel and find menu
@nocolor-node

Recently, perhaps it was today, there was a remark made about Leo's
Find panel being confusing for newbies.  I have some sympathy for the
remarks.

1.  Looking at Leo's Edit:Find menu, there is no obvious way of doing
a search/replace operation.  I'll fix this soon after 4.9 final.

2.  The Find tab should make it clearer that it is a summary/status
tab only--not a way of actually initiating or continuing searches.
Perhaps using QLabel widgets instead of (disabled) QTextEdit widgets
for the find/change patterns would help a bit.
.. @+node:ekr.20111018104244.15920: *6* Fix bug: Use QLocalSocket in LProtoClient.connect
http://groups.google.com/group/leo-editor/browse_thread/thread/fe9cddc0e7ac8199
.. @+node:ekr.20111024170505.16461: *5* Medium priority
.. @+node:ekr.20111026091322.16499: *6* Bug 824087: Alt+F4 is not the same as Alt+F, c
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/824087

The file menu has an entry with label "Close Alt+F4" with the "C" in "Close"
underlined indicating it is the shortcut.

Command print-bindings shows:
S Alt+F4 close-window

That is, the binding is set in leoSettings.leo

Left clicking this "File - Close" menu entry (or Alt+F, c) is NOT the same as Alt+F4.

Left clicking this "File - Close" menu entry (or Alt+F, c) closes the current tab only.

Alt+F4 closes the Leo-Editor application window (and of course, closes all the tabs).

Is this a bug in the implementation or a bug in the documentation? Either way, the menu entry is misleading and the print-bindings information appears to be correct.
.. @+node:ekr.20111025141618.16484: *6* Bug 879338: Global tables in leoApp.py should describe all languages known to the colorizer
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/879338

Having the colorizer colorize a language properly gives the false illusion that Leo "understands" the language.

Supporting the language in the global tables in leoApp.py makes the illusion a reality.
.. @+node:ekr.20111026091322.16491: *6* Bug 805288: ctr - tab locks up in log pane
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/805288

if the log tab is active in the log pane ctrl-tab will toggle through the body,
tree and log panes. If any other tab is active the key combination will freeze
in the log pane.
.. @+node:ekr.20111026091322.16498: *6* Bug 869098: Context menu settings lost if save as used
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/869098

I I have a Leo file with settings for context menu:
    
@settings
   @data contextmenu_commands
       edit-headline Edit headline
          copy-node Copy Node
          cut-node Cut Node
          paste-node Paste Node

then these settings are lost if I save the leo file to a new name using
File - Save as
If I reload the leo file, they do return
.. @+node:ekr.20111026091322.16504: *6* Bug 501636: Leo's import code should support non-ascii xml tags
https://bugs.launchpad.net/leo-editor/+bug/501636

@language rest

Leo's present @auto import code for xml files supports only ascii tags.

In particular, xmlScanner.isWordChar should allow non-ascii characters as specified in
www.w3.org/TR/2008/REC-xml-20081126/#NT-Name

@language python

NameStartChar ::= ":" | [A-Z] | "_" | [a-z] |
    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
    [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] |
    [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar ::= NameStartChar | "-" | "." | [0-9] | #xB7 |
    [#x0300-#x036F] | [#x203F-#x2040]

The following script, presently in test.leo, may be useful:

import unicodedata as u
table = ('a','9','_',':','.',)
table2 = (
    (0xc0,0xd6),(0xd8,0xf6),(0xf8,0x2ff),(0x370,0x37d),(0x37f,0x1fff),
    (0x200c,0x200d),(0x2070,0x218f),(0x2c00,0x2fef),(0x3001,0xd7ff),
    (0xf900,0xfdcf),(0xfdf0,0xfffd),(0x10000,0xeffff),
    # Valid only after the start of a word.
    (0xb7,0xb7+1),(0x0300,0x036f),(0x203f,0x2040),
)
for ch in table:
    ch = g.u(ch)
    g.es(ch,u.category(ch))
for i,j in table2:
    g.es('*** range %xd %xd' % (i,j))
    for n in range(i,min(i+5,j)):
        if g.isPython3: ch = chr(n)
        else: ch = unichr(n)
        g.es(ch,u.category(ch))

@language rest

Clearly, however, the unicode category of these characters is not helpful.
Instead, a dictionary lookup would be appropriate.
.. @+node:ekr.20111026091322.16495: *6* A nest of bugs involving log, focus, chapters, quickmove
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/820019
Shift-Ctrl-F (quicksearch) Sometimes leaves focus in body

https://bugs.launchpad.net/leo-editor/+bug/823267
when a tab is closed focus may go to a tab other than the visible one

https://bugs.launchpad.net/leo-editor/+bug/831658
@url doesn't leave Chapter

https://bugs.launchpad.net/leo-editor/+bug/844940
Different behavior when clicking on @url statement written either in headline or body of a node

https://bugs.launchpad.net/leo-editor/+bug/869385
Chapters make the nav_qt.py plugin useless.

https://bugs.launchpad.net/leo-editor/+bug/875323
Hoist an @chapter node leaves a non-visible node selected.

https://bugs.launchpad.net/leo-editor/+bug/875327
Positioning outside of hoisted outline" usually causes problems

https://bugs.launchpad.net/leo-editor/+bug/875463
Enabling quickmove.py sends to error messages to console on every outline open 
.. @+node:ekr.20111025062953.16479: *5* Low priority/Easy
.. @+node:ekr.20111017132257.15891: *5* Get IPython working again
.. @+node:ekr.20111017132257.15890: *6* Investigate how IPython hijacks event loops
http://groups.google.com/group/leo-editor/browse_thread/thread/e1dc6439bf8b17f9
.. @+node:ekr.20111009162434.7204: *6* Port ipy_leo.py to latest version of IPython
.. @+node:ekr.20111216163700.10214: *4* Bugs
.. @+node:ekr.20111216163700.10212: *5* High-priority bugs (7)
.. @+node:ekr.20111026091322.16496: *6* Bug 844953: copy-clone-pasted node appears in other tab
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/844953
.. @+node:ekr.20111026091322.16494: *6* Bug 869429: Undo and Redo delete from context menu does not redo properly
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/869429

Delete (node) in context_menu (right click on headline) has unexpected undo /
redo effects. Redo after Undo often fails, but you can Undo again, without the
ReDo taking effect, which mans an extra node is created. In essence: -1 delete,
+1 Undo (restore node), 0 ReDo (should redelete but does nothing), +1 Undo
(again) = 1 Should = 0 (delete, undelete, redelete, undo redelete) Deleting a
node through Outline menu works differently and properly. Thye undo code in the
two delete methods must be different

Terry:  The undo code in the two delete methods must be different

It's different because the context menu delete can delete multiple
nodes at once.

I wrote the context menu delete, but I don't understand the undo system
that well - it's possible it just doesn't support a redo of something
like this.
.. @+node:ekr.20111122080923.10186: *6* Bug 893223: Unpredictable slow operation state cured by writing
@nocolor-node

Leo-editor unpredictably gets into a state where Ctrl-V fails to paste
and every Leo-editor operation takes much longer than usual.  This
resulted in the following red message in the log pane:

ignoring command: already executing a command.

This bad state was ended by writing the .leo file so it was no longer
dirty.  I've noticed this problem off and on for at least several weeks.

Test Conditions:

Leo-Editor Rev 4832
Leo Log Window
Leo 4.9.1 devel, build 4669, 4Q/2011
Python 2.7.2, qt version 4.7.3
linux2
setting leoID from os.getenv('USER'): 'bob'
load dir: /home/bob/bzrWork/pluginPath/leo/core
global config dir: /home/bob/bzrWork/pluginPath/leo/config
home dir: /home/bob
reading settings in /home/bob/bzrWork/pluginPath/leo/config/leoSettings.leo
reading settings in /home/bob/.leo/myLeoSettings.leo
reading settings in /media/sda1/BobH/1/Leo/Leo.leo
reading: /media/sda1/BobH/1/Leo/Leo.leo
reading: @auto /home/bob/.leo/.leoRecentFiles.txt

EKR =======================

There is a blunder in c.executeScript.  It jams False into c.inCommand
without saving and restoring the previous value.  This has to be
wrong.  I'm not sure that this is the entire fix.  I'll put it on the
urgent list.
.. @+node:ekr.20111122080923.10188: *7* Found: inCommand
.. @+node:ekr.20031218072017.2140: *8* c.executeScript & helpers
def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False,
    namespace=None):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        oldLog = g.app.log # 2011/01/19
        log = c.frame.log
        g.app.log = log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.p
                if p: c.setCurrentDirectoryFromContext(p)
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                d['script_args'] = args or []
                if namespace: d.update(namespace)
                # if args: sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                if c.write_script_file:
                    scriptFile = self.writeScriptFile(script)
                    
                    # 2011/10/31: make g.inScript a synonym for g.app.inScript.
                    g.inScript = g.app.inScript = True
                    try:
                        if g.isPython3:
                            exec(compile(script,scriptFile,'exec'),d)
                        else:
                            execfile(scriptFile,d)
                    finally:
                        g.inScript = g.app.inScript = False
                else:
                    g.app.inScript = True
                    try:
                        exec(script,d)
                    finally:
                        g.app.inScript = False
                if 0: # This message switches panes, and can be disruptive.
                    if not script1 and not silent:
                        # Careful: the script may have changed the log tab.
                        tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                        g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        g.app.log = oldLog # 2011/01/19
        self.unredirectScriptOutput()
.. @+node:ekr.20031218072017.2143: *9* redirectScriptOutput
def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
.. @+node:ekr.20110522121957.18230: *9* setCurrentDirectoryFromContext
def setCurrentDirectoryFromContext(self,p):
    
    trace = False and not g.unitTesting
    c = self
    
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    
    curDir = g.os_path_abspath(os.getcwd())

    # g.trace(p.h,'\npath  ',path,'\ncurDir',curDir)
    
    if path and path != curDir:
        if trace: g.trace('calling os.chdir(%s)' % (path))
        try:
            os.chdir(path)
        except Exception:
            pass
.. @+node:EKR.20040627100424: *9* unredirectScriptOutput
def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
.. @+node:ekr.20031218072017.2817: *8*  c.doCommand
command_count = 0

def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.

    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""

    c = self ; p = c.p
    commandName = command and command.__name__
    c.setLog()

    self.command_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_doCommand'):
        g.trace(commandName)

    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return # (for Tk) 'break' # Inhibit all other handlers.

    if c.exists and c.inCommand and not g.unitTesting:
        # g.trace('inCommand',c)
        g.app.commandInterruptFlag = True
        g.es('ignoring command: already executing a command.',color='red')
        return # (for Tk) 'break'

    g.app.commandInterruptFlag = False

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            c.inCommand = True
            val = command(event)
            if c and c.exists: # Be careful: the command could destroy c.
                c.inCommand = False
                c.k.funcReturn = val
            # else: g.pr('c no longer exists',c)
        except Exception:
            c.inCommand = False
            if g.app.unitTesting:
                raise
            else:
                g.es_print("exception executing command")
                g.es_exception(c=c)

        if c and c.exists:
            if c.requestCloseWindow:
                g.trace('Closing window after command')
                c.requestCloseWindow = False
                g.app.closeLeoWindow(c.frame)
            else:
                c.outerUpdate()

    # Be careful: the command could destroy c.
    if c and c.exists:
        p = c.p
        g.doHook("command2",c=c,p=p,v=p,label=label)

    return # (for Tk) "break" # Inhibit all other handlers.
.. @+node:ekr.20061031131434.160: *8* k.enterNamedMode
def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
.. @+node:ekr.20110605121601.18140: *8* closeEvent (DynanicWindow)
def closeEvent (self,event):

    trace = False and not g.unitTesting
    c = self.leo_c

    if not c.exists:
        # Fixes double-prompt bug on Linux.
        if trace: g.trace('destroyed')
        event.accept()
        return

    if c.inCommand:
        if trace: g.trace('in command')
        c.requestCloseWindow = True
    else:
        if trace: g.trace('closing')
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
.. @+node:ekr.20110605121601.18286: *8* frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    f = self ; c = f.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
.. @+node:ekr.20111123043847.9981: *7* Found: set_trace
.. @+node:ekr.20110310093050.14293: *8* pdb (codewise)
def pdb (message=''):

    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    if message:
        print(message)
    pdb.set_trace()
.. @+node:ekr.20041105091148: *8* g.pdb
def pdb (message=''):

    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    if message:
        print(message)
    pdb.set_trace()
.. @+node:ekr.20110605121601.18134: *8* init (qtGui.py top level)
def init():
    
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace and g.trace_startup: print('qtGui.__init__')

    if g.app.unitTesting: # Not Ok for unit testing!
        return False

    if not QtCore:
        return False

    if g.app.gui:
        return g.app.gui.guiName() == 'qt'
    else:
        g.app.gui = leoQtGui()

        # Override g.pdb
        def qtPdb(message=''):
            if message: print(message)
            import pdb
            if not g.app.useIpython:
                QtCore.pyqtRemoveInputHook()
            pdb.set_trace()
        g.pdb = qtPdb

        g.app.gui.finishCreate()
        g.plugin_signon(__name__)
        return True
.. @+node:ekr.20111222113610.10249: *6* Bug 889175: Changing @auto paths overwrites files without warning
@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/889175

I loaded an outline with @auto nodes pointing to an out of date path. So body
texts were empty. I updated the paths in the node headlines and saved the file,
expecting to be prompted for overwriting the existing files (now the paths were
correct again), but they were over-written with the blank content without
warning. Damn. Steps to reproduce in a simpler way below, but don't write the
below of as contrived, because the above is the real problem.

Create @auto /home/tbrown/text.txt

enter text, save file

Edit headline to @auto /home/tbrown/Desktop/text.txt

enter text, save file

Edit headline back to /home/tbrown/text.txt

Save file - /home/tbrown/text.txt is overwritten without warning

=======================

I now see this happens also if the path change is in a @path node ancestor of
the @auto node.

=======================

also see
http://groups.google.com/group/leo-editor/browse_frm/thread/1e5d18b08269fb2a,
which is about how to safely move or update a leo document using @file nodes
(meaning: tread with care, it's easy to lose your data).

.. @+node:ekr.20111222113610.10245: *6* Bug 711158: Warn if same .leo file open in another Leo instance
https://bugs.launchpad.net/leo-editor/+bug/711158
.. @+node:ekr.20111222113610.10244: *6* Bug 613153: unable to describe root directory on thumb drive
@nocolor-node

A very complex bug

https://bugs.launchpad.net/leo-editor/+bug/613153
.. @+node:ekr.20111216163700.10213: *5* Important bugs (4)
.. @+node:ekr.20111125072438.10214: *6* email: Another @shadow bug (test4.leo)
@nocolor-node

email:
http://mail.google.com/mail/#label/Leo%2FBugs/133ac31add8b2c6c

see attachment, shadow file won't get written correctly, and it won't reread
correctly too. Using leo-editor-snapshot- 201111090253.

Hopefully I will be able to look on some bugs myself, but don't know when. Needs
a bit of time, I am not very familiar with python.

===== EKR

Leo doesn't understand .jsp.  @shadow should refuse to work for unknown languages.
.. @+node:ekr.20031218072017.368: *7* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20111109105907.9800: *6* Find out (or create) a way to eliminate spellpyx.txt from bzr repo
.. @+node:ekr.20111123095018.13632: *6* Fix bug: expand Find tab as needed for bigger fonts
.. @+node:ekr.20110605121601.18326: *7* createTab (leoQtLog)
def createTab (self,tabName,widget=None,wrap='none'):
    """ Create a new tab in tab widget

    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """

    trace = False and not g.unitTesting
    c = self.c
    
    if trace: g.trace(tabName,widget and g.app.gui.widget_name(widget) or '<no widget>')

    if widget is None:

        widget = LeoQTextBrowser(parent=None,c=c,wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = leoQTextEditWidget(widget=widget,name='log',c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
            
        if trace: g.trace('** creating',tabName,'self.widget',contents,'wrapper',widget)
        
        widget.setWordWrapMode(
            g.choose(self.wrap,
                QtGui.QTextOption.WordWrap,
                QtGui.QTextOption.NoWrap))

        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.widget = contents # widget is an alias for logCtrl.
            widget.setObjectName('log-widget')

        if True: # 2011/05/28.
            # Set binding on all text widgets.
            theFilter = leoQtEventFilter(c,w=self,tag='log')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
            
        if True and tabName == 'Log':
    
            assert c.frame.top.__class__.__name__ == 'DynamicWindow'
            find_widget = c.frame.top.leo_find_widget
            
            # 2011/11/21: A hack: add an event filter.
            find_widget.leo_event_filter = leoQtEventFilter(c,w=widget,tag='find-widget')
            find_widget.installEventFilter(find_widget.leo_event_filter)
            if trace: g.trace('** Adding event filter for Find',find_widget)
            
            # 2011/11/21: A hack: make the find_widget an official log widget.
            self.contentsDict['Find']=find_widget
    
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget,tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        if trace: g.trace('** using',tabName,widget)
        
        if 1: # Now seems to work.
            theFilter = leoQtEventFilter(c,w=contents,tag='tabWidget')
            self.eventFilters.append(theFilter) # Needed!
            widget.installEventFilter(theFilter)
    
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents,tabName)

    return contents
.. @+node:ekr.20110605121601.18166: *7* createFindTab (DynamicWindow)
def createFindTab (self,parent,tab_widget):

    c,dw = self.leo_c,self
    grid = self.createGrid(parent,'findGrid',margin=10,spacing=10)
    grid.setColumnStretch(0,100)
    grid.setColumnStretch(1,100)
    
    # Row 0: heading.
    lab1 = self.createLabel(parent,'findHeading','Find/Change Settings...')
    grid.addWidget(lab1,0,0,1,2,QtCore.Qt.AlignHCenter)
    
    # Rows 1, 2: the find/change boxes, now disabled.
    findPattern = self.createLineEdit(parent,'findPattern',disabled=True)
    findChange  = self.createLineEdit(parent,'findChange',disabled=True)
    lab2 = self.createLabel(parent,'findLabel','Find:')
    lab3 = self.createLabel(parent,'changeLabel','Change:')
    grid.addWidget(lab2,1,0)
    grid.addWidget(lab3,2,0)
    grid.addWidget(findPattern,1,1)
    grid.addWidget(findChange,2,1)
        
    # Check boxes and radio buttons.
    # Radio buttons are mutually exclusive because they have the same parent.
    def mungeName(name):
        # The value returned here is significant: it creates an ivar.
        return 'checkBox%s' % label.replace(' ','').replace('&','')

    # Rows 3 through 8...
    table = (
        ('box', 'Whole &Word',      2,0),
        ('rb',  '&Entire Outline',  2,1),
        ('box', '&Ignore Case',     3,0),
        ('rb',  '&Suboutline Only', 3,1),
        ('box', 'Wrap &Around',     4,0),
        ('rb',  '&Node Only',       4,1),
        # ('box', '&Reverse',       5,0),
        ('box', 'Search &Headline', 5,1),
        ('box', 'Rege&xp',          5,0), # was 6,0
        ('box', 'Search &Body',     6,1),
        ('box', 'Mark &Finds',      6,0), # was 7,0
        ('box', 'Mark &Changes',    7,0)) # was 7,1
        # a,b,c,e,f,h,i,n,rs,w

    for kind,label,row,col in table:
        name = mungeName(label)
        func = g.choose(kind=='box',
            self.createCheckBox,self.createRadioButton)
        w = func(parent,name,label)
        grid.addWidget(w,row+1,col)
        setattr(self,name,w)

    # Row 9: Widgets that take all additional vertical space.
    w = QtGui.QWidget()
    grid.addWidget(w,9,0)
    grid.addWidget(w,9,1)
    grid.setRowStretch(9,100)

    # Official ivars (in addition to setattr ivars).
    self.leo_find_widget = tab_widget # 2011/11/21: a scrollArea.
    self.findPattern = findPattern
    self.findChange = findChange
    # self.findLab = lab2
    # self.changeLab = lab3
.. @+node:ekr.20110605121601.18156: *7* createGrid (DynamicWindow)
def createGrid (self,parent,name,margin=0,spacing=0):

    w = QtGui.QGridLayout(parent)
    w.setMargin(margin)
    w.setSpacing(spacing)
    self.setName(w,name)
    return w
.. @+node:ekr.20110605121601.18145: *7* createLogPane
def createLogPane (self,parent):

    # Create widgets.
    logFrame = self.createFrame(parent,'logFrame',
        vPolicy = QtGui.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame,'logInnerFrame',
        hPolicy=QtGui.QSizePolicy.Preferred,
        vPolicy=QtGui.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame,'logTabWidget')

    # Pack.
    innerGrid = self.createGrid(innerFrame,'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame,'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    
    # 2011/10/01: Embed the Find tab in a QScrollArea.
    findScrollArea = QtGui.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    findTab = QtGui.QWidget()
    findTab.setObjectName('findTab')
    tabWidget.addTab(findScrollArea,'Find')
    self.createFindTab(findTab,findScrollArea)
    findScrollArea.setWidget(findTab)

    spellTab = QtGui.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab,'Spell')
    self.createSpellTab(spellTab)

    tabWidget.setCurrentIndex(1)

    # Official ivars
    self.tabWidget = tabWidget # Used by leoQtLog.
.. @+node:ekr.20111125072438.10217: *6* Bug: shell interprets characters in at-mime headings
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/07efd66847ac4a64

on linux, parenthesis or angled brackets in @mime headings prevent the file from
being opened, probably because they are interpreted specially by the shell, e.g.
they need to be escaped. Such characters should be escaped before passing the
filename to the shell.

.. @+node:ekr.20111010162047.15678: *6* Imports to @file should put @first/@last directives in root node
@nocolor-node

Especially:
    - Shebang line.
    - Python encoding line.
    
- @auto correctly works for all Python files.
.. @+node:ekr.20111221102703.10288: *7* @test imported shbang line
def setup(p):
    while p.hasChildren():
        p.firstChild().doDelete()
        
setup(p)
child = p.insertAsNthChild(0)
child.h = 'import'
child = p.firstChild()
assert child
assert child.h == 'import'
child.b = ''
c.selectPosition(child)

fn = g.os_path_finalize_join(g.app.loadDir,'..','test','at-auto-at-first-test.py')
assert g.os_path_exists(fn),fn

try:
    c.importCommands.createOutline(fn,parent=child.copy(),atAuto=False,ext='.py')
    s = '#!/usr/bin/env python\n# -*- coding: utf-8 -*-'
    root = child.firstChild()
    assert root
    assert root.h.startswith('@file'),root.h
    assert root.h.endswith('at-auto-at-first-test.py')
    assert root.b.startswith(s),'root.b:...\n\n%s' % (root.b)
finally:
    if not g.app.isExternalUnitTest:
        setup(p)
.. @+node:ekr.20111221102703.10289: *7* @@@nosent ../test/at-auto-at-first-test.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

def spam():
    pass
    
# This is the last line.
.. @+node:ekr.20111109083738.9796: *4* Features
.. @+node:ekr.20111028195854.16607: *5* Allow ruleset-specific colors
@nocolor-node

Like @color html::tags_markup_color = blue
.. @+node:ekr.20111027195140.16561: *5* Create session commands
# http://groups.google.com/group/leo-editor/browse_thread/thread/d5522e1075e746de

def get_session():
   """Return a list of UNLs for open tabs.
   """
   tabs = g.app.windowList
   UNLs = []
   for tab in tabs:
       current = tab.c.currentPosition()
       UNLs.append(current.get_UNL())
   return UNLs

def load_session(c, UNLs):
   """Open a tab for each item in UNLs.
   """
   for UNL in UNLs:
       fname, unl = UNL.split("#")
       c2 = g.openWithFileName(fname,old_c=c)
       if c2:
           for p in c2.all_positions():
               if p.get_UNL() == unl:
                   c2.setCurrentPosition(p)
                   c2.redraw()
                   break

def clear_session(c):
   """Close other tabs.
   The other session functions don't require parameters, use leotools.g
   I don't know how to get this filename from g, hence the ``c`` arg.
   """
   this_fname = c.fileName()
   tabs = g.app.windowList
   cmdrs = [tab.c for tab in tabs]
   for cmdr in cmdrs:
       if cmdr.fileName() !=this_fname:
           cmdr.close()

def session_save_snapshot():
   import json
   session = get_session()
   with file('leo.session', 'w') as f:
       json.dump(session, f)
       f.close()

def session_load_snapshot():
   import json
   with file('leo.session') as f:
       session = json.loads(f.read())
   return session
.. @+node:ekr.20111101050427.16716: *5* Make g.openWithFileName "reentrant"
@nocolor-node

That is, make sure it works when called from within itself.
.. @+node:ekr.20111125072438.10219: *5* Open file dialogs starting with @path directory
@nocolor-node

File 'Open' or 'Import File' command to follow @path directive
http://groups.google.com/group/leo-editor/browse_thread/thread/7e508921c85d18bc

Suppose my focus node is under a @path directive, say @path E:
\Documents\Some Folder\

Is there a setting that would cause the 'File>Open' or 'File>Import
File' commands to begin the search dialog in the directory, E:
\Documents\Some Folder\ instead of the last directory used?

Would others find this a useful feature?
.. @+node:ekr.20111221114145.10217: *6* Found: runOpenFileDialog
# Important: many plugins use g.app.gui.openFileDialog.
.. @+node:ekr.20031218072017.2821: *7* c.open & helper
def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    << Set closeFlag if the only open window is empty >>
    table = [
        # 2010/10/09: Fix an interface blunder. Show all files by default.
        ("All files","*"),
        ("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()
    
    c.init_error_dialogs()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            c2 = g.openWithFileName(fileName,old_c=c)
            if c2:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if c2 and closeFlag:
                g.app.destroyWindow(c.frame)
        elif c.looksLikeDerivedFile(fileName):
            # 2011/10/09: A smart open makes Leo lighter:
            # Create an @file node for files containing Leo sentinels.
            ok = c.importCommands.importDerivedFiles(parent=c.p,
                paths=[fileName],command='Open')
        else:
            # otherwise, create an @edit node.
            ok = c.createNodeFromExternalFile(fileName)
            
    c.raise_error_dialogs(kind='write')

    # openWithFileName sets focus if ok.
    if not ok:
        c.initialFocusHelper()
.. @+node:ekr.20031218072017.2822: *8* << Set closeFlag if the only open window is empty >>
@
If this is the only open window was opened when the app started, and
the window has never been written to or saved, then we will
automatically close that window if this open command completes
successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfUntitledWindows == 1) # Only one untitled window has ever been opened
.. @+node:ekr.20090212054250.9: *8* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20111009162434.7206: *7* Regularized slashes in @edit/@file
@nocolor-node

Examples:
    
    @edit C:/leo.repo/ipython-0.12/IPython/frontend/qt/console/pygments_highlighter.py
        # The filename comes from g.app.gui.runOpenFileDialog
    
    @file C:\leo.repo\ipython-0.12\IPython\frontend\qt\console\pygments_highlighter.py
        # Created by import.
        
The problem was the call to g.os_path_normpath in importDerived files:
    it converts slashes to backslashes on windows (!!)
.. @+node:ekr.20110530124245.18245: *7* c.importAnyFile & helper
def importAnyFile (self,event=None):

    '''Import one or more files.'''

    c = self ; ic = c.importCommands

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()
    
    if names:
        g.chdir(names[0])
    else:
        names = []

    if not names:
        if g.unitTesting:
            # a kludge for unit testing.
            c.init_error_dialogs()
            c.raise_error_dialogs(kind='read')
        return
        
    
    
    # New in Leo 4.9: choose the type of import based on the extension.
    
    c.init_error_dialogs()
    
    derived = [z for z in names if c.looksLikeDerivedFile(z)]
    others = [ z for z in names if not z in derived]
    
    if derived:
        ic.importDerivedFiles(parent=c.p,paths=derived)
    
    for fn in others:
        junk,ext = g.os_path_splitext(fn)
        if ext.startswith('.'): ext = ext[1:]
    
        if ext in ('cw','cweb'):
            ic.importWebCommand([fn],"cweb")
        elif ext in ('nw','noweb'):
            ic.importWebCommand([fn],"noweb")
        elif ext == 'txt':
            ic.importFlattenedOutline([fn])
        else:
            ic.importFilesCommand([fn],"@file")
            
        # No longer supported.
        # c.importCommands.importFilesCommand (names,"@root")
        
    c.raise_error_dialogs(kind='read')
        
# Compatibility
importAtFile = importAnyFile
importAtRoot = importAnyFile
importCWEBFiles = importAnyFile
importDerivedFile = importAnyFile
importFlattenedOutline = importAnyFile
importNowebFiles = importAnyFile
.. @+node:ekr.20110530124245.18248: *8* c.looksLikeDerivedFile
def looksLikeDerivedFile (self,fn):
    
    '''Return True if fn names a file that looks like an
    external file written by Leo.'''
    
    c = self
    
    try:
        f = open(fn,'r')
    except IOError:
        return False
        
    s = f.read()
    f.close()
    
    val = s.find('@+leo-ver=') > -1
    # g.trace(val,fn)
    return val
.. @+node:ekr.20031218072017.2839: *7* readOutlineOnly
def readOutlineOnly (self,event=None):

    '''Open a Leo outline from a .leo file, but do not read any derived files.'''

    c = self
    c.endEditing()

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        g.chdir(fileName)
        c = g.app.newCommander(fileName)
        frame = c.frame
        frame.deiconify()
        frame.lift()
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:",fileName)
.. @+node:ekr.20070915134101: *7* readFileIntoNode
def readFileIntoNode (self,event=None):

    '''Read a file into a single node.'''

    c = self ; undoType = 'Read File Into Node'
    c.endEditing()

    filetypes = [("All files", "*"),("Python files","*.py"),("Leo files", "*.leo"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Read File Into Node",filetypes=filetypes,defaultextension=None)
    if not fileName:return
    s,e = g.readFileIntoString(fileName)
    if s is None: return

    g.chdir(fileName)
    s = '@nocolor\n' + s
    w = c.frame.body.bodyCtrl
    p = c.insertHeadline(op_name=undoType)
    p.setHeadString('@read-file-into-node ' + fileName)
    p.setBodyString(s)
    w.setAllText(s)
    c.redraw(p)
.. @+node:ekr.20031218072017.2859: *7* c.removeSentinels
def removeSentinels (self,event=None):

    '''Import one or more files, removing any sentinels.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.removeSentinelsCommand (names)
.. @+node:ekr.20050920084036.20: *7* readAbbreviations & helper
def readAbbreviations (self,event=None):

    '''Read abbreviations from a file.'''

    fileName = g.app.gui.runOpenFileDialog(
        title = 'Open Abbreviation File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    if fileName:
        self.readAbbreviationsFromFile(fileName)
.. @+node:ekr.20100901080826.6156: *8* readAbbreviationsFromFile
def readAbbreviationsFromFile(self,fileName):

    k = self.c.k

    try:
        f = open(fileName)
        for s in f:
            self.addAbbrevHelper(s,'file')
        f.close()
        k.abbrevOn = True
        g.es("Abbreviations on")
        # self.listAbbrevs()
    except IOError:
        g.es('can not open',fileName)
.. @+node:ekr.20071114081313.1: *7* insertIcon
def insertIcon (self,event=None):
    
    '''Prompt for an icon, and insert it into the node's icon list.'''

    trace = False and not g.unitTesting
    c = self.c ; p = c.p

    iconDir = c.os_path_finalize_join(g.app.loadDir,"..","Icons")
    os.chdir(iconDir)

    paths = g.app.gui.runOpenFileDialog(
        title='Get Icons',
        filetypes=[('All files','*'),('Gif','*.gif'), ('Bitmap','*.bmp'),('Icon','*.ico'),],
        defaultextension=None,
        multiple=True)

    if not paths: return

    aList = [] ; xoffset = 2
    for path in paths:
        xoffset = self.appendImageDictToList(aList,iconDir,path,xoffset)

    aList2 = self.getIconList(p)
    aList2.extend(aList)
    self.setIconList(p, aList2)
    c.setChanged(True)
    c.redraw_after_icons_changed()
.. @+node:ekr.20070920104110: *7* compareLeoFiles
def compareLeoFiles (self,event):
    
    '''Compare two .leo files.'''

    c = c1 = self.c ; w = c.frame.body.bodyCtrl

    # Prompt for the file to be compared with the present outline.
    filetypes = [("Leo files", "*.leo"),("All files", "*"),]
    fileName = g.app.gui.runOpenFileDialog(
        title="Compare .leo Files",filetypes=filetypes,defaultextension='.leo')
    if not fileName: return

    # Read the file into the hidden commander.
    c2 = self.createHiddenCommander(fileName)
    if not c2: return

    # Compute the inserted, deleted and changed dicts.
    d1 = self.createFileDict(c1)
    d2 = self.createFileDict(c2)  
    inserted, deleted, changed = self.computeChangeDicts(d1,d2)
    self.dumpCompareNodes(fileName,c1.mFileName,inserted,deleted,changed)

    # Create clones of all inserted, deleted and changed dicts.
    self.createAllCompareClones(inserted,deleted,changed)
    c2.frame.destroySelf()
    g.app.gui.set_focus(c,w)


.. @+node:ekr.20070921072608: *8* computeChangeDicts
def computeChangeDicts (self,d1,d2):

    '''Compute inserted, deleted, changed dictionaries.'''

    inserted = {}
    for key in d2:
        if not d1.get(key):
            inserted[key] = d2.get(key)

    deleted = {}
    for key in d1:
        if not d2.get(key):
            deleted[key] = d1.get(key)

    changed = {}
    for key in d1:
        if d2.get(key):
            p1 = d1.get(key)
            p2 = d2.get(key)
            if p1.h != p2.h or p1.b != p2.b:
                changed[key] = p1

    return inserted, deleted, changed
.. @+node:ekr.20070921072910: *8* createAllCompareClones & helper
def createAllCompareClones(self,inserted,deleted,changed):

    c = self.c # Always use the visible commander
    # Create parent node at the start of the outline.
    u = c.undoer ; undoType = 'Compare .leo Files'
    u.beforeChangeGroup(c.p,undoType)
    undoData = u.beforeInsertNode(c.p)
    parent = c.p.insertAfter()
    parent.setHeadString(undoType)
    u.afterInsertNode(parent,undoType,undoData,dirtyVnodeList=[])
    for d,kind in (
        (deleted,'deleted'),(inserted,'inserted'),(changed,'changed')
    ):
        self.createCompareClones(d,kind,parent)
    c.selectPosition(parent)
    u.afterChangeGroup(parent,undoType,reportFlag=True) 
    c.redraw()
.. @+node:ekr.20070921074410: *9* createCompareClones
def createCompareClones (self,d,kind,parent):

    c = self.c # Always use the visible commander.

    if d:
        parent = parent.insertAsLastChild()
        parent.setHeadString(kind)

        for key in d:
            p = d.get(key)
            clone = p.clone()
            clone.moveToLastChildOf(parent)
.. @+node:ekr.20070921070101: *8* createHiddenCommander (editFileCommandsClass)
def createHiddenCommander(self,fn):

    '''Read the file into a hidden commander (Similar to g.openWithFileName).'''
    
    import leo.core.leoCommands as leoCommands
    lm = g.app.loadManager

    c2 = leoCommands.Commands(fn,gui=g.app.nullGui)
    theFile = lm.openLeoOrZipFile(fn)

    if theFile:
        c2.fileCommands.openLeoFile(theFile,fn,
            readAtFileNodesFlag=True,silent=True)
        return c2
    else:
        return None
.. @+node:ekr.20070921070101.1: *8* createFileDict
def createFileDict (self,c):

    '''Create a dictionary of all relevant positions in commander c.'''

    d = {}
    for p in c.all_positions():
        try:
            # fileIndices for pre-4.x versions of .leo files have a different format.
            i,j,k = p.v.fileIndex
            d[str(i),str(j),str(k)] = p.copy()
        except Exception:
            pass
    return d
.. @+node:ekr.20070921072608.1: *8* dumpCompareNodes
def dumpCompareNodes (self,fileName1,fileName2,inserted,deleted,changed):

    for d,kind in (
        (inserted,'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n',kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key,p.h))
            else:
                g.pr('%-32s %s' % (key,g.toEncodedString(p.h,'ascii')))
.. @+node:ekr.20050920084036.166: *7* getReadableTextFile
def getReadableTextFile (self):

    fn = g.app.gui.runOpenFileDialog(
        title = 'Open Text File',
        filetypes = [("Text","*.txt"), ("All files","*")],
        defaultextension = ".txt")

    return fn
.. @+node:ekr.20031218072017.3731: *7* app.gui file dialogs
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an open file dialog ."""

    self.oops()

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run a save file dialog ."""

    self.oops()
.. @+node:ekr.20031218072017.3744: *7* dialogs (nullGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")

def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)

def runAskOkCancelStringDialog(self,c,title,message):
    return self.simulateDialog("stringDialog",'')

def runCompareDialog(self,c):
    return self.simulateDialog("compareDialog",'')

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
.. @+node:ekr.20110605121601.18500: *7* runOpenFileDialog (qtGui)
def runOpenFileDialog(self,title,filetypes,defaultextension='',multiple=False,startpath=None):

    """Create and run an Qt open file dialog ."""
    
    if g.unitTesting:
        return ''
    else:
        if startpath is None:
            startpath = os.curdir
            
        parent = None
        filter = self.makeFilter(filetypes)
    
        if multiple:
            lst = QtGui.QFileDialog.getOpenFileNames(parent,title,startpath,filter)
            return [g.u(s) for s in lst]
        else:
            s = QtGui.QFileDialog.getOpenFileName(parent,title,startpath,filter)
            return g.u(s)
.. @+node:ekr.20111125072438.10216: *5* Regularize slashes and back-slashes
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/0d48b507bc8ffc05

v4.9.1 build 4669
WinXP

If I 'Open' a file, I get the following node header:

@edit E:/Documents/index.html

If I 'Import' the same file, I get the following:

@file E:\Documents\index.html

Just wondering why the difference between

E:/ and E:\

This is probably trivial and of no consequence, but I thought it
curious. 
.. @+node:ekr.20111108081936.12524: *6* Create unit tests illustrating path ops
@nocolor-node

viewrendered - file not found
https://groups.google.com/forum/#!topic/leo-editor/kotyIs6_G3w

This would be part of a redesign of Leo's path operations.
.. @+node:ekr.20031218072017.2145: *7* os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
.. @+node:ekr.20031218072017.2146: *8* os_path_abspath
def os_path_abspath(path):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2147: *8* os_path_basename
def os_path_basename(path):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2148: *8* os_path_dirname
def os_path_dirname(path):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2149: *8* os_path_exists
def os_path_exists(path):

    """Return True if path exists."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.exists(path)
.. @+node:ekr.20080922124033.6: *8* os_path_expandExpression
def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    trace = False
    
    s1 = s
    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    if not s:
        if trace: g.trace('no s')
        return ''

    i = s.find('{{')
    j = s.find('}}')
    if -1 < i < j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
                if trace: g.trace(s1,s)
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
.. @+node:ekr.20080921060401.13: *8* os_path_expanduser
def os_path_expanduser(path):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path)

    result = os.path.normpath(os.path.expanduser(path))

    return result
.. @+node:ekr.20080921060401.14: *8* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    return path

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(z,**keys)
            for z in args if z]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
.. @+node:ekr.20031218072017.2150: *8* os_path_getmtime
def os_path_getmtime(path):

    """Return the modification time of path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.getmtime(path)
.. @+node:ekr.20080729142651.2: *8* os_path_getsize
def os_path_getsize (path):

    '''Return the size of path.'''

    path = g.toUnicodeFileEncoding(path)

    return os.path.getsize(path)
.. @+node:ekr.20031218072017.2151: *8* os_path_isabs
def os_path_isabs(path):

    """Return True if path is an absolute path."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isabs(path)
.. @+node:ekr.20031218072017.2152: *8* os_path_isdir
def os_path_isdir(path):

    """Return True if the path is a directory."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isdir(path)
.. @+node:ekr.20031218072017.2153: *8* os_path_isfile
def os_path_isfile(path):

    """Return True if path is a file."""

    path = g.toUnicodeFileEncoding(path)

    return os.path.isfile(path)
.. @+node:ekr.20031218072017.2154: *8* os_path_join
def os_path_join(*args,**keys):

    trace = False and not g.unitTesting
    c = keys.get('c')

    uargs = [g.toUnicodeFileEncoding(arg) for arg in args]

    if trace: g.trace('1',uargs)

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z) for z in uargs if z]

    if trace: g.trace('2',uargs)

    path = os.path.join(*uargs)

    if trace: g.trace('3',path)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path)
    return path
.. @+node:ekr.20031218072017.2156: *8* os_path_normcase
def os_path_normcase(path):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2157: *8* os_path_normpath
def os_path_normpath(path):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20080605064555.2: *8* os_path_realpath
def os_path_realpath(path):


    path = g.toUnicodeFileEncoding(path)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path)

    return path
.. @+node:ekr.20031218072017.2158: *8* os_path_split
def os_path_split(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
.. @+node:ekr.20031218072017.2159: *8* os_path_splitext
def os_path_splitext(path):

    path = g.toUnicodeFileEncoding(path)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head)
    tail = g.toUnicodeFileEncoding(tail)

    return head,tail
.. @+node:ekr.20090829140232.6036: *8* os_startfile
def os_startfile(fname):
    if sys.platform.startswith('win'):
        os.startfile(fname)
    elif sys.platform == 'darwin':
        # From Marc-Antoine Parent.
        try:
            subprocess.call(['open', fname])
        except OSError:
            pass # There may be a spurious "Interrupted system call"
        except ImportError:
            os.system("open '%s'" % (fname,))
    else:
        os.system('xdg-open "%s"'%fname)
.. @+node:ekr.20031218072017.2160: *8* toUnicodeFileEncoding
def toUnicodeFileEncoding(path):

    if path: path = path.replace('\\', os.sep)

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path)
.. @+node:ekr.20111108081936.9750: *7* @test path computations
fj = g.os_path_finalize_join
f  = g.os_path_finalize
eu = g.os_path_expanduser

if g.app.isExternalUnitTest:
    loadDir = fj(g.app.loadDir,'..','test')
else:
    loadDir = g.app.loadDir

table = (
    (fj,'@@file fj-test-1',fj(loadDir,'rel-path')),
)

for func,h,expected in table:
    p = g.findNodeAnywhere(c,h)
    assert p,'not found: "%s"' % (h)
    assert p.h.startswith('@@')
    p.h = p.h[1:] # Remove the first @ sign.
    
    try:
        d = c.scanAllDirectives(p)
        result = d.get('path')
        assert result == expected,'expected "%s", got "%s"' % (
            expected,result)
    finally:
        p.h = '@' + p.h
        c.redraw()
.. @+node:ekr.20111108081936.9768: *8* @path rel-path
.. @+node:ekr.20111108081936.9751: *9* @@file fj-test-1
.. @+node:ekr.20031218072017.3213: *6* createImportParent (importCommands)
def createImportParent (self,current,files):
    
    '''Create a parent node for nodes with a common prefix: x.h & x.cpp.'''

    name0,name1 = files
    prefix0, junk = g.os_path_splitext(name0)
    prefix1, junk = g.os_path_splitext(name1)
    
    if prefix0 and prefix0 == prefix1:
        current = current.insertAsLastChild()
        name,junk = g.os_path_splitext(prefix1)
        name = name.replace('\\','/') # 2011/11/25
        current.initHeadString(name)

    return current
.. @+node:ekr.20031218072017.3210: *6* createOutline (leoImport)
def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s
    w = c.frame.body
    at = c.atFileCommands

    self.default_directory = g.setDefaultDirectory(c,parent,importing=False)
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    fileName = fileName.replace('\\','/') # 2011/11/25
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        if atShadow: kind = '@shadow '
        elif atAuto: kind = '@auto '
        else: kind = ''
        s,e = g.readFileIntoString(fileName,encoding=self.encoding,kind=kind)
        if s is None: return None
        if e: self.encoding = e

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        elif self.treeType is None:
            # 2010/09/29: by convention, we use the short file name.
            p.initHeadString(g.shortFileName(fileName))
        else:
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    if self.treeType == '@root': # 2010/09/29.
        self.rootLine = "@root-code "+self.fileName+'\n'
    else:
        self.rootLine = ''

    if p.isAtAutoRstNode(): # @auto-rst is independent of file extension.
        func = self.scanRstText
    else:
        func = self.importDispatchDict.get(ext)

    if func and not c.config.getBool('suppress_import_parsing',default=False):
        s = s.replace('\r','')
        func(s,p,atAuto=atAuto)
    else:
        # Just copy the file to the parent node.
        s = s.replace('\r','')
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    if atAuto:
        # Fix bug 488894: unsettling dialog when saving Leo file
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName,p)

    p.contract()
    w.setInsertPoint(0)
    w.seeInsertPoint()
    return p
.. @+node:ekr.20081001062423.9: *6* g.setDefaultDirectory & helper
def setDefaultDirectory(c,p,importing=False):

    ''' Return a default directory by scanning @path directives.'''

    name = p.anyAtFileNodeName()
    if name:
        # An absolute path overrides everything.
        d = g.os_path_dirname(name)
        if d and g.os_path_isabs(d):
            return d

    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
        # Returns g.getBaseDirectory(c) by default.
        # However, g.getBaseDirectory can return ''
    if path:
        path = g.os_path_finalize(path)
    else:
        g.checkOpenDirectory(c)
        for d in (c.openDirectory,g.getBaseDirectory(c)):
            # Errors may result in relative or invalid path.
            if d and g.os_path_isabs(d):
                path = d
                break
        else:
            path = ''

    if not importing and not path:
        # This should never happen, but is not serious if it does.
        g.warning("No absolute directory specified anywhere.")

    return path
.. @+node:ekr.20101022124309.6132: *7* g.checkOpenDirectory
def checkOpenDirectory (c):

    if c.openDirectory != c.frame.openDirectory:
        g.error(
            'c.openDirectory != c.frame.openDirectory\n'
            'c.openDirectory: %s\n'
            'c.frame.openDirectory: %s' % (
                c.openDirectory,c.frame.openDirectory))

    if not g.os_path_isabs(c.openDirectory):
        g.error ('relative c.openDirectory: %s' % (
            c.openDirectory))
.. @+node:ekr.20080921060401.14: *6* g.os_path_finalize & os_path_finalize_join
def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c = keys.get('c')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path)
    path = os.path.abspath(path)
    path = os.path.normpath(path)
    return path

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c = keys.get('c')

    if c:
        args = [g.os_path_expandExpression(z,**keys)
            for z in args if z]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
.. @+node:ekr.20111123043847.13423: *4* Code changes
.. @+node:ekr.20111120162254.10216: *5* Get rid of the trace settings
@nocolor-node

Like the one used in k.masterKeyHandler.
.. @+node:ekr.20111109083738.9798: *4* Testing
.. @+node:ekr.20110929165422.15449: *5* Test bug fix: noweb expansions in rst3 command
@nocolor-node

*** Important *** This was all done in Leo 4.9

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references:  default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
.. @+node:ekr.20111018104244.15918: *6* Report
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/15239f5f504cee6f

I tried it out with:

Test
.....@rst test.html
      which contains:
      This is a test (underlined)
      then the reference:
      <<test>>
...............<<test>>
                which contains: Here is some text.

In the top node Test I have:
@ @rst-options
expand_noweb_references=True
expand_noweb_recursively=True
show_headlines=False  (without this, the <<test>> headline becomes a section
heading)
@c

It sort of works:
--------------------------------------------
This is a test

<<test>>Here is some text.

Here is some text.
--------------------------------------------

The reference <<test>> does not get erased, even if the definition actually
gets inserted beside it. On the other hand, though I can suppress the
headline of the definition with the rst option, the body of the definition
gets inserted as a section anyway; definitions are not ignored by rst.

But now I can go see what happens in the code for debugging, since the
option gives a pointer into the code.

Thanks!
.. @+node:ekr.20100813041139.5920: *6* Entry points
.. @+node:ekr.20100812082517.5945: *7* code_to_rst_command & helpers
def code_to_rst_command (self,event=None,p=None,scriptSettingsDict=None,toString=False):

    '''Format the presently selected node as computer code.

    Settings from scriptSettingsDict override normal settings.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    trace = False and not g.unitTesting
    c = self.c
    if p: p = p.copy()
    else: p = c.p
    self.topNode = p.copy()
    self.topLevel = p.level()

    # **Important**: This command works as much like the rst3 command as possible.
    # Difference arise because there is no @rst node to specify a filename.
    # Instead we get the filename from scriptSettingsDict, or use 'code_to_rst.html'

    # Capture the settings, munging all settings.
    self.scriptSettingsDict = {}
    d = scriptSettingsDict
    if d:
        for key in d.keys():
            self.scriptSettingsDict[self.munge(key)] = d.get(key)

    # Init options...
    self.preprocessTree(p)
    self.init_write(p) # scanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')
    fn = self.getOption('output-file-name') or 'code_to_rst.html'
    junk,ext = g.os_path_splitext(fn)

    # Write the rst sources to self.sources...
    self.outputFile = StringIO()
    self.write_code_tree(p,fn)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
.. @+node:ekr.20100812082517.5963: *8* write_code_body & helpers
def write_code_body (self,p):

    trace = False
    self.p = p.copy() # for traces.
    if not p.b.strip():
        return # No need to write any more newlines.

    showDocsAsParagraphs = self.getOption('show_doc_parts_as_paragraphs')
    lines = g.splitLines(p.b)
    parts = self.split_parts(lines,showDocsAsParagraphs)
    result = []
    for kind,lines in parts:
        if trace: g.trace(kind,len(lines),p.h)
        if kind == '@rst-option': # Also handles '@rst-options'
            pass # The prepass has already handled the options.
        elif kind == '@rst-markup':
            lines.extend('\n')
            result.extend(lines)
        elif kind == '@doc':
            if showDocsAsParagraphs:
                result.extend(lines)
                result.append('\n')
            else:
                result.extend(self.write_code_block(lines))
        elif kind == 'code':
            result.extend(self.write_code_block(lines))
        else:
            g.trace('Can not happen',kind)

    # Write the lines with exactly two trailing newlines.
    s = ''.join(result).rstrip() + '\n\n'
    self.write(s)
.. @+node:ekr.20100812082517.5964: *9* split_parts
def split_parts (self,lines,showDocsAsParagraphs):

    '''Split a list of body lines into a list of tuples (kind,lines).'''

    kind,parts,part_lines = 'code',[],[]
    for s in lines:
        if g.match_word(s,0,'@ @rst-markup'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind = '@rst-markup'
            n = len('@ @rst-markup')
            after = s[n:].strip()
            part_lines = g.choose(after,[after],[])
        elif s.startswith('@ @rst-option'):
            if part_lines: parts.append((kind,part_lines[:]),)
            kind,part_lines = '@rst-option',[s] # part_lines will be ignored.
        elif s.startswith('@ ') or s.startswith('@\n') or s.startswith('@doc'):
            if showDocsAsParagraphs:
                if part_lines: parts.append((kind,part_lines[:]),)
                kind = '@doc'
                # Put only what follows @ or @doc
                n = g.choose(s.startswith('@doc'),4,1)
                after = s[n:].lstrip()
                part_lines = g.choose(after,[after],[])
            else:
                part_lines.append(s) # still in code mode.
        elif g.match_word(s,0,'@c') and kind != 'code':
            if kind == '@doc' and not showDocsAsParagraphs:
                part_lines.append(s) # Show the @c as code.
            parts.append((kind,part_lines[:]),)
            kind,part_lines = 'code',[]
        else:
            part_lines.append(s)

    if part_lines:
        parts.append((kind,part_lines[:]),)

    return parts
.. @+node:ekr.20100812082517.5965: *9* write_code_block
def write_code_block (self,lines):

    result = ['::\n\n'] # ['[**code block**]\n\n']

    if self.getOption('number-code-lines'):
        i = 1
        for s in lines:
            result.append('    %d: %s' % (i,s))
            i += 1
    else:
        result.extend(['    %s' % (z) for z in lines])

    s = ''.join(result).rstrip()+'\n\n'
    return g.splitLines(s)
.. @+node:ekr.20100812082517.5966: *8* write_code_headline & helper
def write_code_headline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''


    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.write_code_headline_helper(p)
.. @+node:ekr.20100812082517.5967: *9* write_code_headline_helper
def write_code_headline_helper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-headlines'):
            return

        for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
            if word == prefix:
                h = h [len(word):].strip()
                break

    if not h.strip(): return

    if self.getOption('show_sections'):
        self.write(self.underline(h,p))
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
.. @+node:ekr.20100812082517.5968: *8* write_code_node
def write_code_node (self,p):

    '''Format a node according to the options presently in effect.

    Side effect: advance p'''

    h = p.h.strip()
    self.scanAllOptions(p)

    if self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.write_code_headline(p)
        self.write_code_body(p)
        p.moveToThreadNext()
.. @+node:ekr.20100812082517.5939: *8* write_code_tree
def write_code_tree (self,p,fn):

    '''Write p's tree as code to self.outputFile.'''

    self.scanAllOptions(p) # So we can get the next option.

    if self.getOption('generate_rst_header_comment'):
        self.write('.. rst3: filename: %s\n\n' % fn)

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.write_code_node(p) # Side effect: advances p.
.. @+node:ekr.20090511055302.5793: *7* rst3 command & helpers
def rst3 (self,event=None):

    '''Write all @rst nodes.'''

    self.processTopTree(self.c.p)
.. @+node:ekr.20090502071837.62: *8* processTopTree
def processTopTree (self,p,justOneFile=False):

    c = self.c ; current = p.copy()

    # This strange looking code looks up and down the tree for @rst nodes.
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
            break
        elif h.startswith('@slides'):
            self.processTree(p,ext=None,toString=False,justOneFile=False)
            break
    else:
        self.processTree(current,ext=None,toString=False,justOneFile=justOneFile)

    g.es_print('done',color='blue')
.. @+node:ekr.20090502071837.63: *8* processTree
def processTree(self,p,ext=None,toString=False,justOneFile=False):

    '''Process all @rst nodes in a tree.
    ext is the docutils extention: it's useful for scripts and unit tests.
    '''

    trace = False and not g.unitTesting
    if trace: g.trace(p.h)
    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            fn = h[4:].strip()
            if ((fn and fn[0] != '-') or (toString and not fn)):
                if trace: g.trace('found: %s',p.h)
                found = True
                self.write_rst_tree(p,ext,fn,toString=toString,justOneFile=justOneFile)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        elif g.match(h,0,"@slides"):
            self.write_slides(p)
            found = True
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst or @slides nodes in selected tree',color='blue')
    return None,None
.. @+node:ekr.20090502071837.64: *8* write_rst_tree
def write_rst_tree (self,p,ext,fn,toString=False,justOneFile=False):

    '''Convert p's tree to rst sources.
    Optionally call docutils to convert rst to output.

    On exit:
        self.source contains rst sources
        self.stringOutput contains docutils output if docutils called.
    '''

    c = self.c
    self.topNode = p.copy()
    self.topLevel = p.level()
    if toString:
        ext = ext or '.html' # 2010/08/12: Unit test found this.
    else:
        junk,ext = g.os_path_splitext(fn)
    ext = ext.lower()
    if not ext.startswith('.'): ext = '.' + ext

    # Init options...
    self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
    self.scanAllOptions(p) # Settings for p are valid after this call.
    callDocutils = self.getOption('call_docutils')
    writeIntermediateFile = self.getOption('write_intermediate_file')

    # Write the rst sources to self.source.
    self.outputFile = StringIO()
    self.writeTree(p,fn)
    self.source = self.outputFile.getvalue() # the rST sources.
    self.outputFile = None
    self.stringOutput = None

    if callDocutils or writeIntermediateFile:
        self.write_files(ext,fn,callDocutils,toString,writeIntermediateFile)
.. @+node:ekr.20100822092546.5835: *8* write_slides & helper
def write_slides (self,p,toString=False):

    '''Convert p's children to slides.'''

    c = self.c ; p = p.copy() ; h = p.h
    i = g.skip_id(h,1) # Skip the '@'
    kind,fn = h[:i].strip(),h[i:].strip()
    if not fn: return g.es('%s requires file name' % (kind),color='red')
    title = p and p.firstChild().h or '<no slide>'
    title = title.strip().capitalize()
    n_tot = p.numberOfChildren()

    n = 1
    for child in p.children():
        self.init_write(p) # ScanAllDirectives sets self.path and self.encoding.
        self.scanAllOptions(child) # Settings for child are valid after this call.
        # Compute the slide's file name.
        fn2,ext = g.os_path_splitext(fn)
        fn2 = '%s-%03d%s' % (fn2,n,ext) # Use leading zeros for :glob:.
        n += 1
        # Write the rst sources to self.source.
        self.outputFile = StringIO()
        self.writeSlideTitle(title,n-1,n_tot)
        self.writeBody(child)
        self.source = self.outputFile.getvalue() # the rST sources.
        self.outputFile,self.stringOutput = None,None
        self.write_files(ext,fn2,
            callDocutils=self.getOption('call_docutils'),
            toString=toString,
            writeIntermediateFile=self.getOption('write_intermediate_file'))
.. @+node:ekr.20100822174725.5836: *9* writeSlideTitle
def writeSlideTitle (self,title,n,n_tot):

    '''Write the title, underlined with the '#' character.'''

    if n != 1:
        title = '%s (%s of %s)' % (title,n,n_tot)

    width = max(4,len(g.toEncodedString(title,
        encoding=self.encoding,reportErrors=False)))

    self.write('%s\n%s \n\n' % (title,('#'*width)))
.. @+node:ekr.20090502071837.58: *8* write methods (rst3 command)
.. @+node:ekr.20090502071837.68: *9* getDocPart
def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    << Append whatever follows @doc or @space to result >>
    while n < len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
.. @+node:ekr.20090502071837.69: *10* << Append whatever follows @doc or @space to result >>
if n > 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
.. @+node:ekr.20090502071837.81: *9* handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
.. @+node:ekr.20090502071837.77: *9* isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
.. @+node:ekr.20090502071837.79: *9* isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
.. @+node:ekr.20090502071837.78: *9* isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    # g.trace('kind %s, result %s, s %s' % (
        # repr(kind),result,repr(s)))

    return result
.. @+node:ekr.20090502071837.80: *9* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,1,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20090502071837.82: *9* replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
.. @+node:ekr.20090502071837.70: *9* skip_literal_block
def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n < len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 <= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
.. @+node:ekr.20090502071837.71: *9* writeBody & helpers
def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
.. @+node:ekr.20110610144305.6749: *10* isSectionDef/Ref
def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
.. @+node:ekr.20110610144305.6750: *10* expandSectionRefs
def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20110610144305.6751: *10* findSectionDef
def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
.. @+node:ekr.20090502071837.72: *10* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
.. @+node:ekr.20090502071837.73: *11* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
.. @+node:ekr.20090502071837.74: *11* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
.. @+node:ekr.20090502071837.75: *11* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
.. @+node:ekr.20090502071837.76: *10* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
.. @+node:ekr.20090502071837.83: *9* writeHeadline & helper
def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             = self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    ignoreNowebDefs     = self.getOption('ignore_noweb_definitions')
    showHeadlines       = self.getOption('show_headlines')
    showOrganizers      = self.getOption('show_organizer_nodes')
    showThisHeadline    = self.getOption('show_this_headline')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers or
        ignoreNowebDefs and self.isSectionDef(p) # 2011/06/10.
    ):
        return

    self.writeHeadlineHelper(p)
.. @+node:ekr.20090502071837.84: *10* writeHeadlineHelper
def writeHeadlineHelper (self,p):

    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0)
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip()
    if word:
        # Never generate a section for these...
        if word in (
            '@rst-option','@rst-options',
            '@rst-no-head','@rst-no-headlines'
        ):
            return

        # Remove all other headline commands from the headline.
        for command in self.headlineCommands:
            if word == command:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
.. @+node:ekr.20090502071837.85: *9* writeNode (leoRst)
def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
.. @+node:ekr.20090502071837.86: *9* writePreformat
def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
.. @+node:ekr.20090502071837.87: *9* writeTree
def writeTree(self,p,fn):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % fn))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
.. @+node:ekr.20090502071837.67: *7* writeNodeToString
def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period: .html, .tex or None (specifies rst output).

    Returns (p, s), where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)
.. @+node:ekr.20090512153903.5803: *7* writeAtAutoFile
def writeAtAutoFile (self,p,fileName,outputFile,trialWrite=False):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.trialWrite = trialWrite
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        ok = self.isSafeWrite(p)
        if ok:
            p = p.firstChild() # A hack: ignore the root node.
            while p and p != after:
                self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
    return ok
.. @+node:ekr.20090513073632.5733: *8* initAtAutoWrite (rstCommands)
def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.nodeOptionDict = {}
    self.scanAllOptions(p)
    self.init_write(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.
    # Do the overrides.
    self.outputFile = outputFile
    # Set underlining characters.
    # It makes no sense to use user-defined
    # underlining characters in @auto-rst.
    d = p.v.u.get('rst-import',{})
    underlines2 = d.get('underlines2','')
        # Do *not* set a default for overlining characters.
    if len(underlines2) > 1:
        underlines2 = underlines2[0]
        g.trace('too many top-level underlines, using %s' % (
            underlines2),color='blue')
    underlines1 = d.get('underlines1','')
    # Bug fix:  2010/05/26: pad underlines with default characters.
    default_underlines = '=+*^~"\'`-:><_'
    if underlines1:
        for ch in default_underlines[1:]:
            if ch not in underlines1:
                underlines1 = underlines1 + ch
    else:
        underlines1 = default_underlines
    self.atAutoWriteUnderlines   = underlines2 + underlines1
    self.underlines1 = underlines1
    self.underlines2 = underlines2
.. @+node:ekr.20091228080620.6499: *8* isSafeWrite
def isSafeWrite (self,p):

    '''Return True if node p contributes nothing but
    rst-options to the write.'''

    if self.trialWrite or not p.isAtAutoRstNode():
        return True # Trial writes are always safe.

    lines = g.splitLines(p.b)
    for z in lines:
        if z.strip() and not z.startswith('@') and not z.startswith('.. '):
            # A real line that will not be written.
            g.es('unsafe @auto-rst',color='red')
            g.es('body text will be ignored in\n',p.h)
            return False
    else:
        return True
.. @+node:ekr.20090502071837.41: *6* Options
.. @+node:ekr.20090502071837.42: *7* createDefaultOptionsDict
def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:><_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
.. @+node:ekr.20090502071837.43: *7* dumpSettings (debugging)
def dumpSettings (self):

    d = self.optionsDict
    keys = sorted(d)

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
.. @+node:ekr.20090502071837.44: *7* getOption & setOption
def getOption (self,name):

    # 2010/08/12: munging names here is safe because setOption munges.
    # g.trace(name,self.optionsDict.get(self.munge(name)))
    return self.optionsDict.get(self.munge(name))

def setOption (self,name,val,tag=None):

    self.optionsDict [self.munge(name)] = val
.. @+node:ekr.20090502071837.45: *7* initCodeBlockString
def initCodeBlockString(self,p):

    trace = False and not g.unitTesting
    c = self.c
    # if trace: os.system('cls')
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None: language = 'python'
    else: language = language.lower()
    syntax = SilverCity is not None

    if trace: g.trace('language',language,'language.title()',language.title(),p.h)

    # Note: lines that end with '\n\n' are a signal to handleCodeMode.
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n\n' % (
            language.title())
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n\n'
.. @+node:ekr.20090502071837.46: *7* preprocessTree & helpers
def preprocessTree (self,root):

    self.nodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.nodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.nodeOptionDict.get(key))
.. @+node:ekr.20090502071837.47: *8* preprocessNode
def preprocessNode (self,p):

    d = self.nodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.nodeOptionDict [p.v] = d
.. @+node:ekr.20090502071837.48: *8* parseOptionLine
def parseOptionLine (self,s):

    '''Parse a line containing name=val and return (name,value) or None.

    If no value is found, default to True.'''

    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name: return None
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        # g.trace(val)
        return name,val
    else:
        # g.trace('*True')
        return name,'True'
.. @+node:ekr.20090502071837.49: *8* scanForOptionDocParts
def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n < len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n < len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
.. @+node:ekr.20090502071837.50: *8* scanHeadlineForOptions
def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,'@rst-option'):
        s = h [len('@rst-option'):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,'@rst-options'):
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for option,ivar,val in (
            ('@rst',                'code_mode',False),
            ('@rst-code',           'code_mode',True),
            ('@rst-default-path',   'default_prefix',''),
            ('@rst-doc-only',       'doc_only_mode',True),
            ('@rst-head',           'show_this_headline',True),
            # ('@rst-head' ,        'show_headlines',False),
            ('@rst-ignore',         'ignore_this_tree',True),
            ('@rst-ignore-node',    'ignore_this_node',True),
            ('@rst-ignore-tree',    'ignore_this_tree',True),
            ('@rst-no-head',        'ignore_this_headline',True),
            ('@rst-preformat',      'preformat_this_node',True),
        ):
            if word == option:
                d = { ivar: val }
                # Special case: code mode and doc-only modes are linked.
                if ivar == 'code_mode':
                    d ['doc_only_mode'] = False
                elif ivar == 'doc_only_mode':
                    d ['code_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == '@rst':
                    d ['ignore_this_headline'] = True
                # g.trace(repr(h),d)
                return d

        if h.startswith('@rst'):
            g.trace('unknown kind of @rst headline',p.h,g.callers(4))

        return {}
.. @+node:ekr.20090502071837.51: *8* scanNodeForOptions
def scanNodeForOptions (self,p):

    '''Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.'''
    
    trace = False and not g.unitTesting

    h = p.h

    d = self.scanHeadlineForOptions(p)

    d2 = self.scanForOptionDocParts(p,p.b)

    # A fine point: body options over-ride headline options.
    d.update(d2)
    
    if trace and d:
        g.trace(h)
        for z in sorted(d):
            print('    %s: %s' % (z,d.get(z)))

    return d
.. @+node:ekr.20090502071837.52: *8* scanOption
def scanOption (self,p,s):

    '''Return { name:val } if s is a line of the form name=val.
    Otherwise return {}'''

    if not s.strip() or s.strip().startswith('..'): return {}

    data = self.parseOptionLine(s)

    if data:
        name,val = data
        if self.munge(name) in list(self.defaultOptionsDict.keys()):
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
            return { self.munge(name): val }
        else:
            g.es_print('ignoring unknown option: %s' % (name),color='red')
            return {}
    else:
        g.trace(repr(s))
        s2 = 'bad rst3 option in %s: %s' % (p.h,s)
        g.es_print(s2,color='red')
        return {}
.. @+node:ekr.20090502071837.53: *8* scanOptions
def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
.. @+node:ekr.20090502071837.54: *7* scanAllOptions & helpers
# Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings() # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:] # Suppress inheritance of single-node options.

    # g.trace('-'*20)
    for p in p.self_and_parents():
        d = self.nodeOptionDict.get(p.v,{})
        # g.trace(p.h,d)
        for key in d.keys():
            ivar = self.munge(key)
            if not ivar in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)

    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
.. @+node:ekr.20090502071837.55: *8* initOptionsFromSettings
def initOptionsFromSettings (self):

    c = self.c

    d = self.defaultOptionsDict
    keys = sorted(d)

    for key in keys:
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break

    # 2010/08/12: Script settings override everything else.
    d2 = self.scriptSettingsDict or {}
    for key in d2.keys():
        val = d2.get(key)
        # g.trace(key,val)
        self.setOption(key,val,'initOptionsFromSettings')

    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.es('No http_server_support: can not import mod_http plugin',color='red')
        self.setOption('http_server_support',False)
.. @+node:ekr.20090502071837.56: *8* handleSingleNodeOptions
def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.nodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        #g.trace('%24s %8s %s' % (ivar,val,p.h))
        self.setOption(ivar,val,p.h)

.. @+node:ekr.20090502071837.42: *6* createDefaultOptionsDict
def createDefaultOptionsDict(self):

    # Important: these must be munged names.
    self.defaultOptionsDict = {
        # Http options...
        'clear_http_attributes':   False,
        'http_server_support':     False,
        'http_attributename':      'rst_http_attribute',
        'node_begin_marker':       'http-node-marker-',
        # Path options...
        'default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'stylesheet_name': 'default.css',
        'stylesheet_path': None, # Bug fix: must be None, not ''.
        'stylesheet_embed': True,
        'publish_argv_for_missing_stylesheets': None,
        # Global options...
        'call_docutils': True, # 2010/08/05
        'code_block_string': '',
        'number_code_lines': True,
        'underline_characters': '''#=+*^~"'`-:><_''',
        'verbose':True,
        'write_intermediate_file': False, # Used only if generate_rst is True.
        'write_intermediate_extension': '.txt',
        # Mode options...
        'code_mode': False, # True: generate rst markup from @code and @doc parts.
        'doc_only_mode': False, # True: generate only from @doc parts.
        'generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'expand_noweb_references': False,
        'ignore_noweb_definitions': False,
        'expand_noweb_recursively': True,
        'show_headlines': True,  # Can be set by @rst-no-head headlines.
        'show_organizer_nodes': True,
        'show_options_nodes': False,
        'show_sections': True,
        'strip_at_file_prefixes': True,
        'show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'show_doc_parts_as_paragraphs': False,
        'show_leo_directives': True,
        'show_markup_doc_parts': False,
        'show_options_doc_parts': False,
    }
.. @+node:ekr.20090502071837.71: *6* writeBody & helpers
def writeBody (self,p):

    trace = False and not g.unitTesting
   
    if self.getOption('ignore_noweb_definitions'):
        # 2011/06/10: Ignore section definition nodes.
        name = self.isSectionDef(p)
        if name:
            if trace: g.trace('section def: %s' % (repr(name)))
            return

    # remove trailing cruft and split into lines.
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        # Important: code mode is no longer documented!
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('expand_noweb_references'):
            # 2011/06/10.
            lines = self.expandSectionRefs(lines,p,seen=[])
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    # Write the lines.
    s = ''.join(lines)

    # We no longer add newlines to the start of nodes because
    # we write a blank line after all sections.
    # s = g.ensureLeadingNewlines(s,1)
    s = g.ensureTrailingNewlines(s,2)
    self.write(s)
.. @+node:ekr.20110610144305.6749: *7* isSectionDef/Ref
def isSectionDef (self,p):
    
    return self.isSectionRef(p.h)
    
def isSectionRef (self,s):

    n1 = s.find("<<",0)
    n2 = s.find(">>",0)
    return -1 < n1 < n2 and s[n1+2:n2].strip()
.. @+node:ekr.20110610144305.6750: *7* expandSectionRefs
def expandSectionRefs (self,lines,p,seen):
    
    trace = False and not g.unitTesting
    
    if trace: g.trace(p.h,g.callers())

    result = []
    for s in lines:
        name = self.isSectionRef(s)
        if name:
            p2 = self.findSectionDef(name,p)
            if p2:
                g.trace('expanding: %s from %s' % (name,p2.h))
                result.append(s) # Append the section reference line.
                lines2 = g.splitLines(p2.b)
                if self.getOption('expand_noweb_recursively'):
                    if name in seen:
                        pass # Prevent unbounded recursion
                    else:
                        seen.append(name)
                        result.extend(self.expandSectionRefs(lines2,p,seen))
                else:
                    result.extend(lines2)
            else:
                # Undefined reference.
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20110610144305.6751: *7* findSectionDef
def findSectionDef (self,name,p):
    
    for p2 in p.subtree():
        name2 = self.isSectionDef(p2)
        if name2:
            return p2
    
    return None
.. @+node:ekr.20090502071837.72: *7* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    trace = False and not g.unitTesting
    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        else:
            if not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)

            if trace: g.trace('code line: %s' % repr(s))
            code.append(s)
       
        # elif not code: # Start the code block.
            # result.append('')
            # result.append(self.code_block_string)
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)
        # else: # Continue the code block.
            # if trace: g.trace('code line: %s' % repr(s))
            # code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        # 2010/08/27: Fix bug 618482.
        # elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
.. @+node:ekr.20090502071837.73: *8* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
.. @+node:ekr.20090502071837.74: *8* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    # 2010/08/27: fix bug 618482.
    s = ''.join(theList).rstrip()
    return s.split('\n')
.. @+node:ekr.20090502071837.75: *8* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
.. @+node:ekr.20090502071837.76: *7* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
.. @+node:ekr.20111027083744.16531: *5* Unit tests for scroll bug

    @nocolor-node

QSignalSpy: doesn't exist on PyQt?



Unit testsing without QSignalSpy
http://stackoverflow.com/questions/2045352/pyqt-unittest-testing-signal-and-slots

**just call enableSignalDebugging(emitCall=foo) and spy your signals until you're sick to your stomach**
.. @+node:ekr.20111027083744.16532: *6* enableSignalDebugging (qtGui)
# enableSignalDebugging(emitCall=foo) and spy your signals until you're sick to your stomach.

_oldConnect     = QtCore.QObject.connect
_oldDisconnect  = QtCore.QObject.disconnect
_oldEmit        = QtCore.QObject.emit

def _wrapConnect(self,callableObject):
    """Returns a wrapped call to the old version of QtCore.QObject.connect"""
    @staticmethod
    def call(*args):
        callableObject(*args)
        self._oldConnect(*args)
    return call

def _wrapDisconnect(self,callableObject):
    """Returns a wrapped call to the old version of QtCore.QObject.disconnect"""
    @staticmethod
    def call(*args):
        callableObject(*args)
        self._oldDisconnect(*args)
    return call

def enableSignalDebugging(self,**kwargs):

    """Call this to enable Qt Signal debugging. This will trap all
    connect, and disconnect calls."""

    f = lambda *args: None
    connectCall     = kwargs.get('connectCall', f)
    disconnectCall  = kwargs.get('disconnectCall', f)
    emitCall        = kwargs.get('emitCall', f)

    def printIt(msg):
        def call(*args):
            print(msg,args)
        return call
        
    # Monkey-patch.
    QtCore.QObject.connect    = self._wrapConnect(connectCall)
    QtCore.QObject.disconnect = self._wrapDisconnect(disconnectCall)

    def new_emit(self, *args):
        emitCall(self, *args)
        self._oldEmit(self, *args)

    QtCore.QObject.emit = new_emit
.. @+node:ekr.20110605121601.18540: *6* eventFilter
def eventFilter(self, obj, event):

    trace = (False or g.trace_masterKeyHandler) and not g.unitTesting
    verbose = True
    traceEvent = False # True: call self.traceEvent.
    traceKey = (True or g.trace_masterKeyHandler)
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    # Hack: QLineEdit generates ev.KeyRelease only on Windows,Ubuntu
    lineEditKeyKinds = [ev.KeyPress,ev.KeyRelease]

    # Important:
    # QLineEdit: ignore all key events except keyRelease events.
    # QTextEdit: ignore all key events except keyPress events.
    if eventType in lineEditKeyKinds:
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        # g.trace('instate',k.inState(),'tkKey',tkKey,'ignore',ignore,'len(aList)',len(aList))
        if ignore:
            override = False
        # This is extremely bad.
        # At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)
                c.frame.body.onFocusOut(obj)
        if self.tag in ('tree','log'):
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)

    if self.keyIsActive:
        shortcut = self.toStroke(tkKey,ch) # ch is unused.

        if override:
            # Essentially *all* keys get passed to masterKeyHandler.
            if trace and traceKey:
                g.trace('ignore',ignore,'bound',repr(shortcut),repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            event = self.create_key_event(event,c,w,ch,tkKey,shortcut)
            ret = k.masterKeyHandler(event)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,shortcut)
        
        if trace and traceEvent:
            # Trace key events.
            self.traceEvent(obj,event,tkKey,override)

    elif trace and traceEvent:
        # Trace non-key events.
        self.traceEvent(obj,event,tkKey,override)

    return override
.. @+node:ekr.20110605121601.18548: *6* traceEvent
def traceEvent (self,obj,event,tkKey,override):

    if g.unitTesting: return
    
    traceFocus = False
    traceKey   = True
    traceLayout = False
    traceMouse = False
    
    c,e = self.c,QtCore.QEvent
    eventType = event.type()
    
    show = []
    
    ignore = [
        e.MetaCall, # 43
        e.Timer, # 1
        e.ToolTip, # 110
    ]
    
    focus_events = (
        (e.Enter,'enter'),
        (e.Leave,'leave'),
        (e.FocusIn,'focus-in'),
        (e.FocusOut,'focus-out'),
        (e.Hide,'hide'), # 18
        (e.HideToParent, 'hide-to-parent'), # 27
        (e.HoverEnter, 'hover-enter'), # 127
        (e.HoverLeave,'hover-leave'), # 128
        (e.HoverMove,'hover-move'), # 129
        (e.Show,'show'), # 17
        (e.ShowToParent,'show-to-parent'), # 26
        (e.WindowActivate,'window-activate'), # 24
        (e.WindowBlocked,'window-blocked'), # 103
        (e.WindowUnblocked,'window-unblocked'), # 104
        (e.WindowDeactivate,'window-deactivate'), # 25
    )
    key_events = (
        (e.KeyPress,'key-press'),
        (e.KeyRelease,'key-release'),
        (e.ShortcutOverride,'shortcut-override'),
    )
    layout_events = (
        (e.ChildPolished,'child-polished'), # 69
        #(e.CloseSoftwareInputPanel,'close-sip'), # 200
            # Event does not exist on MacOS.
        (e.ChildAdded,'child-added'), # 68
        (e.DynamicPropertyChange,'dynamic-property-change'), # 170
        (e.FontChange,'font-change'),# 97
        (e.LayoutRequest,'layout-request'),
        (e.Move,'move'), # 13 widget's position changed.
        (e.PaletteChange,'palette-change'),# 39
        (e.ParentChange,'parent-change'), # 21
        (e.Paint,'paint'), # 12
        (e.Polish,'polish'), # 75
        (e.PolishRequest,'polish-request'), # 74
        # (e.RequestSoftwareInputPanel,'sip'), # 199
            # Event does not exist on MacOS.
        (e.Resize,'resize'), # 14
        (e.StyleChange,'style-change'), # 100
        (e.ZOrderChange,'z-order-change'), # 126
    )
    mouse_events = (
        (e.MouseMove,'mouse-move'), # 155
        (e.MouseButtonPress,'mouse-press'), # 2
        (e.MouseButtonRelease,'mouse-release'), # 3
        (e.Wheel,'mouse-wheel'), # 31
    )
    
    option_table = (
        (traceFocus,focus_events),
        (traceKey,key_events),
        (traceLayout,layout_events),
        (traceMouse,mouse_events),
    )
    
    for option,table in option_table:
        if option:
            show.extend(table)
        else:
            for n,tag in table:
                ignore.append(n)

    for val,kind in show:
        if eventType == val:
            g.trace(
                '%5s %18s in-state: %5s key: %s override: %s: obj: %s' % (
                self.tag,kind,repr(c.k and c.k.inState()),tkKey,override,obj))
            return

    if eventType not in ignore:
        g.trace('%3s:%s obj:%s' % (eventType,'unknown',obj))
.. @+node:ekr.20110605121601.18021: *6* mousePress/ReleaseEvent (LeoQTextBrowser)
# def mousePressEvent (self,event):
    # QtGui.QTextBrowser.mousePressEvent(self,event)
    
def mouseReleaseEvent(self,event):
    self.onMouseUp(event)
    QtGui.QTextBrowser.mouseReleaseEvent(self,event)
.. @+node:ekr.20111105222316.9706: *5* Unit test: no unit tests omitted
@nocolor-node

Create a "registry" of unit tests.  Verify that unitTest.leo contains them all.
.. @+node:ekr.20111105222316.9707: *5* Unit test: importing a plugin changes nothing
@nocolor-node

Menu and plugin registry methods can fail if that *particular* unit test is running.
.. @+node:ekr.20111114151846.9856: *5* Create unit test that verifies class relationships
.. @+node:ekr.20111114102224.9936: *6* << define class HighLevelInterface >>
class HighLevelInterface(object):
    
    '''A class to specify Leo's high-level editing interface
    used throughout Leo's core.
    
    The interface has two parts:
        
    1. Standard (immutable) methods that will never be overridden.
    
    2. Other (mutable) methods that subclasses may override.
    '''
    
    @others
.. @+node:ekr.20111114102224.9950: *7* ctor (HighLevelInterface)
def __init__ (self,c):
    
    self.c = c
    
    self.widget = None
    
    self.mutable_methods = (
        'flashCharacter',
        'toPythonIndex',
        'toPythonIndexRowCol',
        # 'toGuiIndex', # A synonym.
    )
.. @+node:ekr.20111114102224.9935: *7* mutable methods (HighLevelInterface)
.. @+node:ekr.20111114102224.9946: *8* flashCharacter
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    pass
    
.. @+node:ekr.20111114102224.9943: *8* toPythonIndex (HighLevelInterface)
def toPythonIndex (self,index):
    
    s = self.getAllText()
    return g.toPythonIndex(s,index)

toGuiIndex = toPythonIndex
.. @+node:ekr.20111114102224.9945: *8* toPythonIndexRowCol (BaseTextWidget)
def toPythonIndexRowCol(self,index):
    
    # This works, but is much slower that the leoQTextEditWidget method.
    s = self.getAllText()
    i = self.toPythonIndex(index)
    row,col = g.convertPythonIndexToRowCol(s,i)
    return i,row,col
.. @+node:ekr.20111114102224.9937: *7* immutable redirection methods (HighLevelInterface)
def appendText(self,s):
    if self.widget: self.widget.appendText(s)
def delete(self,i,j=None):
    if self.widget: self.widget.delete(i,j)
def deleteTextSelection (self):
    if self.widget: self.widget.deleteTextSelection()
def get(self,i,j):
    return self.widget and self.widget.get(i,j) or ''
def getAllText(self):
    return self.widget and self.widget.getAllText() or ''
def getInsertPoint(self):
    return self.widget and self.widget.getInsertPoint() or 0
def getSelectedText(self):
    return self.widget and self.widget.getSelectedText() or ''
def getSelectionRange (self):
    return self.widget and self.widget.getSelectionRange() or (0,0)
def getYScrollPosition (self):
    return self.widget and self.widget.getYScrollPosition() or 0
def hasSelection(self):
    # Take special care with this, for the benefit of LeoQuickSearchWidget.
    # This problem only happens with the qttabs gui.
    w = self.widget
    return bool(w and hasattr(w,'hasSelection') and w.hasSelection())
def insert(self,i,s):
    if self.widget: self.widget.insert(i,s)    
def replace (self,i,j,s):
    if self.widget: self.widget.replace(i,j,s)
def see(self,i):
    if self.widget: self.widget.see(i)
def seeInsertPoint (self):
    if self.widget: self.widget.seeInsertPoint()
def selectAllText (self,insert=None):
    if self.widget: self.widget.selectAllText(insert)
def setAllText (self,s):
    if self.widget: self.widget.setAllText(s)
def setBackgroundColor(self,color):
    if self.widget: self.widget.setBackgroundColor(color)
def setFocus(self):
    if self.widget: self.widget.setFocus()
def setForegroundColor(self,color):
    if self.widget: self.widget.setForegroundColor(color)
def setInsertPoint(self,pos):
    if self.widget: self.widget.setInsertPoint(pos)
def setSelectionRange (self,i,j,insert=None):
    if self.widget: self.widget.setSelectionRange(i,j,insert=insert)
def setYScrollPosition (self,i):
    if self.widget: self.widget.setYScrollPosition(i)
def tag_configure (self,colorName,**keys):
    if self.widget: self.widget.tag_configure(colorName,**keys)
.. @+node:ekr.20111114102224.9940: *7* other immutable methods (HighLevelInterface)
# These all use leoGlobals functions or leoGui methods.

def clipboard_append(self,s):
    s1 = g.app.gui.getTextFromClipboard()
    g.app.gui.replaceClipboardWith(s1 + s)
    
def clipboard_clear (self):
    g.app.gui.replaceClipboardWith('')
    
def getFocus(self):
    return g.app.gui.get_focus(self.c)
    
def rowColToGuiIndex (self,s,row,col):
    return g.convertRowColToPythonIndex(s,row,col)   
    
# def rowColToGuiIndex (self,s,row,col):
    # return self.widget and self.widget.rowColToGuiIndex(s,row,col) or 0 

set_focus = setFocus
.. @+node:ekr.20111114102224.9950: *6* ctor (HighLevelInterface)
def __init__ (self,c):
    
    self.c = c
    
    self.widget = None
    
    self.mutable_methods = (
        'flashCharacter',
        'toPythonIndex',
        'toPythonIndexRowCol',
        # 'toGuiIndex', # A synonym.
    )
.. @+node:ekr.20111114151846.9852: *6* mustBeDefined...
.. @+node:ekr.20111114151846.9850: *7* From baseTextWidget
.. @+node:ekr.20081031074455.3: *8* baseTextWidget.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'clipboard_append', # uses g.app.gui method.
    'clipboard_clear', # usesg.app.gui method.
)
.. @+node:ekr.20081031074455.4: *8* baseTextWidget.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    'appendText',
    'delete',
    'deleteTextSelection',
    'get',
    'getAllText',
    'getFocus',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionRange',
    'getYScrollPosition',
    'insert',
    'see',
    'seeInsertPoint',
    'setAllText',
    'setBackgroundColor',
    'setForegroundColor',
    'setFocus',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
)

.. @+node:ekr.20081031074455.5: *8* baseTextWidget.mustBeDefined...
# These can be do-nothings
mustBeDefined = (
    'flashCharacter',
    'hasSelection',
    'replace',
    'rowColToGuiIndex',
    'selectAllText',
    'tag_configure',
    'toGuiIndex',
    'toPythonIndex',
    'toPythonIndexRowCol',
)
.. @+node:ekr.20111114151846.9851: *7* From leoBody
.. @+node:ekr.20081005065934.9: *8* leoBody.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'after_idle',
    'forceFullRecolor', # The base-class method is usually good enough.
    'initAfterLoad',
    'tag_configure', # used in qtGui.py.
)
.. @+node:ekr.20031218072017.3660: *8* leoBody.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Birth, death & config.
    '__init__',
    'createBindings',
    'createControl',
    'setColorFromConfig',
    'setFontFromConfig'
    # Editors
    'createEditorLabel',
    'setEditorColors',
    # Events...
    'scheduleIdleTimeRoutine',
    # Low-level gui...(May be deleted)
    'getBodyPaneHeight',
    'getBodyPaneWidth',
    'hasFocus',
    'setFocus',
)
.. @+node:ekr.20061109102912: *8* define leoBody.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'getAllText',
    'getColorizer',
    'getInsertLines',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionAreas',
    'getSelectionLines',
    'getYScrollPosition',
    'hasSelection',
    'oops',
    'onBodyChanged',
    'recolor',
    'recolor_now',
    'see',
    'seeInsertPoint',
    'selectAllText',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
    'setSelectionAreas',
    'setYScrollPosition',
    'updateSyntaxColorer',
)
.. @+node:ekr.20111114151846.9853: *7* from leoFrame
.. @+node:ekr.20080429051644.1: *8* leoFrame.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (

    # Icon bar convenience methods.    
    'addIconButton',
    'addIconRow',
    'clearIconBar',
    'createIconBar',
    'getIconBar',
    'getIconBarObject',
    'getNewIconFrame',
    'hideIconBar',
    'initAfterLoad',
    'initCompleteHint',
    'showIconBar',
)
.. @+node:ekr.20061109120726: *8* leoFrame.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (

    'createFirstTreeNode', # New in Leo 4.6: was defined in tkTree.
    'initialRatios',
    'longFileName',
    'oops',
    'promptForSave',
    'scanForTabWidth',
    'shortFileName',

    # Headline editing.
    'abortEditLabelCommand',
    'endEditLabelCommand',
    'insertHeadlineTime',

    # Cut/Copy/Paste.
    'OnPaste',
    'OnPasteFromMenu',
    'copyText',
    'cutText',
    'pasteText',

    # Status line convenience methods.
    'createStatusLine',
    'clearStatusLine',
    'disableStatusLine',
    'enableStatusLine',
    'getStatusLine',
    'getStatusObject',
    'putStatusLine',
    'setFocusStatusLine',
    'statusLineIsEnabled',
    'updateStatusLine',
)
.. @+node:ekr.20061109120704: *8* leoFrame.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    #Gui-dependent commands.
    'cascade',
    'contractBodyPane',
    'contractLogPane',
    'contractOutlinePane',
    'contractPane',
    'equalSizedPanes',
    'expandLogPane',
    'expandPane',
    'fullyExpandBodyPane',
    'fullyExpandLogPane',
    'fullyExpandOutlinePane',
    'fullyExpandPane',
    'hideBodyPane',
    'hideLogPane',
    'hideLogWindow',
    'hideOutlinePane',
    'hidePane',
    'leoHelp',
    'minimizeAll',
    'resizeToScreen',
    'toggleActivePane',
    'toggleSplitDirection',
    # Windowutilities...
    'bringToFront',
    'deiconify',
    'get_window_info',
    'lift',
    'update',
    # Config...
    'resizePanesToRatio',
    'setInitialWindowGeometry',
    'setTopGeometry',
)
.. @+node:ekr.20111114151846.9854: *7* from leoTree
.. @+node:ekr.20081005065934.7: *8* leoTree.mustBeDefined
# List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)
.. @+node:ekr.20061109164512: *8* leoTree.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    # Getters & setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)
.. @+node:ekr.20061109164610: *8* leoTree.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Colors & fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing & scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
.. @+node:ekr.20111114151846.9855: *7* from leoGui
.. @+node:ekr.20061109211054: *8* leoGui.mustBeDefinedOnlyInBaseClass
mustBeDefinedOnlyInBaseClass = (
    'guiName',
    'oops',
    'setScript',
    'widget_name',
)
.. @+node:ekr.20061109211022: *8* leoGui.mustBeDefinedInSubclasses
mustBeDefinedInSubclasses = (
    # Startup & shutdown
    'attachLeoIcon',
    'center_dialog',
    'color',
    #'createComparePanel',          # optional
    #'createFindPanel',             # optional
    'createFindTab',
    # 'createKeyHandlerClass',
    'createLeoFrame',
    'createRootWindow',
    'create_labeled_frame',
    'destroySelf',
    #'eventChar',
    #'eventKeysym',
    'eventWidget',
    # 'eventXY',
    # 'finishCreate', # optional.
    # 'getFontFromParams', # optional
    # 'getFullVersion', # optional.
    'getTextFromClipboard',
    'get_focus',
    'get_window_info',
    'isTextWidget',
    # 'keysym',
    'killGui',
    # 'makeScriptButton', # optional
    'recreateRootWindow',
    'replaceClipboardWith',
    'runAboutLeoDialog',
    'runAskLeoIDDialog',
    'runAskOkCancelNumberDialog',
    'runAskOkDialog',
    'runAskYesNoCancelDialog',
    'runAskYesNoDialog',
    'runMainLoop',
    'runOpenFileDialog',
    'runSaveFileDialog',
    'set_focus',
    #'setIdleTimeHook',             # optional       
    #'setIdleTimeHookAfterDelay',   # optional
)
.. @+node:ekr.20111128103520.10245: *4* leoInspect: create o.token_range getter
.. @+node:ekr.20111128103520.10257: *5* @test leoInspect.token_range (s)
import leo.core.leoInspect as inspect

# g.cls()

def show(o,indent=0):
    pad = ' '*4*indent
    # print('\n%s\n' % o.sd.dump_ast(o.tree()))
    print('%s%s' % (pad,o.format()))
    print('token range: %s' % (repr(o.token_range())))

<< define s >>
print('Input...\n%s\n' % (s.rstrip()))

m = inspect.module(s=s)

if 0:
    show(m,0)
    
if 1:
    print('\nAssignments to a...\n')
    for o in m.assignments_to('a'):
        # print(o.format())
        show(o)
if 0:
    print('\nAssignments using d...\n')
    for o in m.assignments_using('d'):
        # print(o.format())
        show(o)
if 0:    
    print('\nCalls to f...\n')
    for o in m.calls_to('f'):
        # print(o.format())
        show(o)
if 0:
    for s in m.statements():
        show(s)
    
    for f in m.functions():
        show(f,0)
        for z in f.statements():
            show(z,1)
    
    for cls in m.classes():
        show(cls,0)
        for d in cls.defs():
            show(d,1)
            for z in d.statements():
                show(z,1)
.. @+node:ekr.20111128103520.10258: *6* << define s >>
s = '''
# x.y = b(arg1,arg2=5,*args,**args).c[1:2:3].d
a=b+c
# f(a=1,b=2,*args,**keys)
'''


# def outer_function(a,b=99,c=88,*args,**keys):
    # print('hello')
    
# class myClass:
    # def method():
        # pass
    
.. @+node:ekr.20111129084537.10357: *5* Notes
@language rest

> All this means that it would likely be too expensive (or just too
> ugly) to compute the data needed for token_range in the base
> AstTraverser class.  Such computations will be performed by traversing
> the module's entire AST the first time "token_range" is called.

There are two parts to the problem.  Happily, neither requires a
separate tree-traversal class.

A token-info prepass
================

For each node N of a module's tree, we want to inject the following
two new ivars:

- N.end_lineno: the line number of the last character of the token.
- N.end_col_offset: the (byte) offset of the last character of the
token.

After experimenting with a few traversals last night I suddenly
realized tree structure is irrelevant when computing these fields: we
simply want a **sorted** list of (N.lineno,No.col_offset, N) tuples!

The prepass will use ast.walk(root), to generate the list.  After
sorting the list, the prepass will inject inject N.end_lineno and
N.end_col_offset ivars into each node N by stepping through the list.
The ending values of the previous node on the list are the the same as
the beginning values of the next node on the list.

This prepass need only be done once per module.

token_range
===========

To compute token_range for a *particular* N, we want to discover
values M.end_lineno and M.end_col_offset for M, the **last** token in
N's entire tree.

token_range will do the prepass on the modules tree if necessary.
token_range will then call ast.walk(N) to discover all of N's nodes,
sort the list, and return the last element of the list!

In short, token_range is clean and bullet-proof--a happy result.
.. @+node:ekr.20111116103733.10402: *5* << define class Context >>
class Context(object):

    '''The base class of all context-related semantic data.

    All types ultimately resolve to a context.'''

    def __repr__ (self):
        return 'Context: %s' % (self.context_kind)

    __str__ = __repr__

    @others
.. @+node:ekr.20111116103733.10403: *6* cx ctor
def __init__(self,tree,parent_context,sd,kind):

    self.is_temp_context = kind in ['comprehension','for','lambda','with']
    self.context_kind = kind
    # assert kind in ('class','comprehension','def','for','lambda','module','with'),kind
    self.formatter = sd.formatter
    self.parent_context = parent_context
    self.sd = sd
    self.st = SymbolTable(context=self)

    sd.n_contexts += 1

    # Public semantic data: accessed via getters.
    self._classes = [] # Classes defined in this context.
    self._defs = [] # Functions defined in this context.
    self._statements = [] # List of all statements in the context.
    self._tree = tree
    
    # Private semantic data: no getters.
    self.global_names = set() # Names that appear in a global statement in this context.
    self.temp_contexts = [] # List of inner 'comprehension','for','lambda','with' contexts.
    
    # Record the name.ctx contexts.
    self.del_names = set()      # Names with ctx == 'Del'
    self.load_names = set()     # Names with ctx == 'Load'
    self.param_names = set()    # Names with ctx == 'Param'
    self.store_names = set()    # Names with ctx == 'Store'
    
    # Data for the resolution algorithm.
    self.all_global_names = set() # Global names in all parent contexts.
    
    # Compute the class context.
    if self.context_kind == 'module':
        self.class_context = None
    elif self.context_kind == 'class':
        self.class_context = self
    else:
        self.class_context = parent_context.class_context
        
    # Compute the defining context.
    if self.is_temp_context:
        self.defining_context = parent_context.defining_context
    else:
        self.defining_context = self
    
    # Compute the module context.
    if self.context_kind == 'module':
        self.module_context = self
    else:
        self.module_context = parent_context.module_context
.. @+node:ekr.20111116103733.10404: *6* cx.ast_kind
def ast_kind (self,tree):

    return tree.__class__.__name__
.. @+node:ekr.20111116103733.10405: *6* cx.description & name
def description (self):
    
    '''Return a description of this context and all parent contexts.'''
    
    if self.parent_context:
        return  '%s:%s' % (
            self.parent_context.description(),repr(self))
    else:
        return repr(self)

# All subclasses override name.
name = description
.. @+node:ekr.20111116103733.10407: *6* cx.dump
def dump (self,level=0,verbose=False):

    if 0: # Just print the context
        print(repr(self))
    else:
        self.st.dump(level=level)

    if verbose:
        for z in self._classes:
            z.dump(level+1)
        for z in self._defs:
            z.dump(level+1)
        for z in self.temp_contexts:
            z.dump(level+1)
.. @+node:ekr.20111117031039.10099: *6* cx.format
def format(self,brief=True):
    
    cx = self
    
    # return cx.sd.dumper.dumpTreeAsString(cx._tree,brief=brief,outStream=None)
    
    # return ast.dump(cx._tree,annotate_fields=True,include_attributes=not brief)
    
    return AstFormatter().format(cx._tree)
.. @+node:ekr.20111116161118.10113: *6* cx.getters & setters
.. @+node:ekr.20111116161118.10114: *7* cx.assignments & helper
def assignments (self,all=True):
    
    if all:
        return self.all_assignments(result=None)
    else:
        return self.filter_assignments(self._statements)

def all_assignments(self,result):

    if result is None:
        result = []
    result.extend(self.filter_assignments(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_assignments(result)
    return result
    
def filter_assignments(self,aList):
    '''Return all the assignments in aList.'''
    return [z for z in aList
        if z.context_kind in ('assn','aug-assn')]
.. @+node:ekr.20111116161118.10115: *7* cx.assignments_to
def assignments_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        if kind == 'Assign':
            for target in tree.targets:
                lhs = format(target)
                if s == lhs:
                    result.append(assn)
                    break
        else:
            assert kind == 'AugAssign',kind
            lhs = format(tree.target)
            if s == lhs:
                result.append(assn)

    return result
.. @+node:ekr.20111116161118.10116: *7* cx.assignments_using
def assignments_using (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        assert kind in ('Assign','AugAssign'),kind
        rhs = format(tree.value)
        i = rhs.find(s,0)
        while -1 < i < len(rhs):
            if g.match_word(rhs,i,s):
                result.append(assn)
                break
            else:
                i += len(s)

    return result
.. @+node:ekr.20111126074312.10386: *7* cx.calls & helpers
def calls (self,all=True):
    
    if all:
        return self.all_calls(result=None)
    else:
        return self.filter_calls(self._statements)

def all_calls(self,result):

    if result is None:
        result = []
    result.extend(self.filter_calls(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_calls(result)
    return result
    
def filter_calls(self,aList):
    '''Return all the calls in aList.'''
    return [z for z in aList
        if z.context_kind == 'call']
.. @+node:ekr.20111126074312.10384: *7* cx.call_to
def calls_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111126074312.10400: *7* cx.call_args_of
def call_args_of (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111116161118.10163: *7* cx.classes
def classes (self,all=True):
    
    if all:
        return self.all_classes(result=None)
    else:
        return self._classes

def all_classes(self,result):

    if result is None:
        result = []
    result.extend(self._classes)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_classes(result)
    return result
.. @+node:ekr.20111116161118.10164: *7* cx.defs
def defs (self,all=True):
    
    if all:
        return self.all_defs(result=None)
    else:
        return self._defs

def all_defs(self,result):

    if result is None:
        result = []
    result.extend(self._defs)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_defs(result)
    return result
.. @+node:ekr.20111116161118.10152: *7* cx.functions & helpers
def functions (self,all=True):
    
    if all:
        return self.all_functions(result=None)
    else:
        return self.filter_functions(self._defs)

def all_functions(self,result):

    if result is None:
        result = []
    result.extend(self.filter_functions(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_functions(result)
    return result
.. @+node:ekr.20111116161118.10223: *8* cx.filter_functions & is_function
def filter_functions(self,aList):
    return [z for z in aList if self.is_function(z)]

def is_function(self,f):
    '''Return True if f is a function, not a method.'''
    return True
.. @+node:ekr.20111126074312.10449: *7* cx.line_number
def line_number (self):
    
    return self._tree.lineno
.. @+node:ekr.20111116161118.10153: *7* cx.methods & helpers
def methods (self,all=True):
    
    if all:
        return self.all_methods(result=None)
    else:
        return self.filter_methods(self._defs)

def all_methods(self,result):

    if result is None:
        result = []
    result.extend(self.filter_methods(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_methods(result)
    return result
.. @+node:ekr.20111116161118.10225: *8* cx.filter_functions & is_function
def filter_methods(self,aList):
    return [z for z in aList if self.is_method(z)]

def is_method(self,f):
    '''Return True if f is a method, not a function.'''
    return True
.. @+node:ekr.20111116161118.10165: *7* cx.statements
def statements (self,all=True):
    
    if all:
        return self.all_statements(result=None)
    else:
        return self._statements

def all_statements(self,result):

    if result is None:
        result = []
    result.extend(self._statements)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_statements(result)
    return result
.. @+node:ekr.20111128103520.10259: *7* cx.token_range
def token_range (self):
    
    tree = self._tree
    
    # return (
        # g.toUnicode(self.byte_array[:tree.col_offset]),
        # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # )
    
    if hasattr(tree,'col_offset') and hasattr(tree,'end_col_offset'):
        return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    else:
        return -1,-1
.. @+node:ekr.20111116161118.10166: *7* cx.tree
def tree(self):
    
    '''Return the AST (Abstract Syntax Tree) associated with this query object
    (Context Class).  This tree can be passed to the format method for printing.
    '''
    
    return self._tree
.. @+node:ekr.20111116161118.10113: *5* cx.getters & setters
.. @+node:ekr.20111116161118.10114: *6* cx.assignments & helper
def assignments (self,all=True):
    
    if all:
        return self.all_assignments(result=None)
    else:
        return self.filter_assignments(self._statements)

def all_assignments(self,result):

    if result is None:
        result = []
    result.extend(self.filter_assignments(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_assignments(result)
    return result
    
def filter_assignments(self,aList):
    '''Return all the assignments in aList.'''
    return [z for z in aList
        if z.context_kind in ('assn','aug-assn')]
.. @+node:ekr.20111116161118.10115: *6* cx.assignments_to
def assignments_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        if kind == 'Assign':
            for target in tree.targets:
                lhs = format(target)
                if s == lhs:
                    result.append(assn)
                    break
        else:
            assert kind == 'AugAssign',kind
            lhs = format(tree.target)
            if s == lhs:
                result.append(assn)

    return result
.. @+node:ekr.20111116161118.10116: *6* cx.assignments_using
def assignments_using (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for assn in self.assignments(all=all):
        tree = assn.tree()
        kind = self.ast_kind(tree)
        assert kind in ('Assign','AugAssign'),kind
        rhs = format(tree.value)
        i = rhs.find(s,0)
        while -1 < i < len(rhs):
            if g.match_word(rhs,i,s):
                result.append(assn)
                break
            else:
                i += len(s)

    return result
.. @+node:ekr.20111126074312.10386: *6* cx.calls & helpers
def calls (self,all=True):
    
    if all:
        return self.all_calls(result=None)
    else:
        return self.filter_calls(self._statements)

def all_calls(self,result):

    if result is None:
        result = []
    result.extend(self.filter_calls(self._statements))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_calls(result)
    return result
    
def filter_calls(self,aList):
    '''Return all the calls in aList.'''
    return [z for z in aList
        if z.context_kind == 'call']
.. @+node:ekr.20111126074312.10384: *6* cx.call_to
def calls_to (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111126074312.10400: *6* cx.call_args_of
def call_args_of (self,s,all=True):
    
    format,result = self.formatter.format,[]

    for call in self.calls(all=all):
        tree = call.tree()
        func = format(tree.func)
        if s == func:
            result.append(call)

    return result
.. @+node:ekr.20111116161118.10163: *6* cx.classes
def classes (self,all=True):
    
    if all:
        return self.all_classes(result=None)
    else:
        return self._classes

def all_classes(self,result):

    if result is None:
        result = []
    result.extend(self._classes)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_classes(result)
    return result
.. @+node:ekr.20111116161118.10164: *6* cx.defs
def defs (self,all=True):
    
    if all:
        return self.all_defs(result=None)
    else:
        return self._defs

def all_defs(self,result):

    if result is None:
        result = []
    result.extend(self._defs)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_defs(result)
    return result
.. @+node:ekr.20111116161118.10152: *6* cx.functions & helpers
def functions (self,all=True):
    
    if all:
        return self.all_functions(result=None)
    else:
        return self.filter_functions(self._defs)

def all_functions(self,result):

    if result is None:
        result = []
    result.extend(self.filter_functions(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_functions(result)
    return result
.. @+node:ekr.20111116161118.10223: *7* cx.filter_functions & is_function
def filter_functions(self,aList):
    return [z for z in aList if self.is_function(z)]

def is_function(self,f):
    '''Return True if f is a function, not a method.'''
    return True
.. @+node:ekr.20111126074312.10449: *6* cx.line_number
def line_number (self):
    
    return self._tree.lineno
.. @+node:ekr.20111116161118.10153: *6* cx.methods & helpers
def methods (self,all=True):
    
    if all:
        return self.all_methods(result=None)
    else:
        return self.filter_methods(self._defs)

def all_methods(self,result):

    if result is None:
        result = []
    result.extend(self.filter_methods(self._defs))
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_methods(result)
    return result
.. @+node:ekr.20111116161118.10225: *7* cx.filter_functions & is_function
def filter_methods(self,aList):
    return [z for z in aList if self.is_method(z)]

def is_method(self,f):
    '''Return True if f is a method, not a function.'''
    return True
.. @+node:ekr.20111116161118.10165: *6* cx.statements
def statements (self,all=True):
    
    if all:
        return self.all_statements(result=None)
    else:
        return self._statements

def all_statements(self,result):

    if result is None:
        result = []
    result.extend(self._statements)
    for aList in (self._classes,self._defs):
        for cx in aList:
            cx.all_statements(result)
    return result
.. @+node:ekr.20111128103520.10259: *6* cx.token_range
def token_range (self):
    
    tree = self._tree
    
    # return (
        # g.toUnicode(self.byte_array[:tree.col_offset]),
        # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # )
    
    if hasattr(tree,'col_offset') and hasattr(tree,'end_col_offset'):
        return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    else:
        return -1,-1
.. @+node:ekr.20111116161118.10166: *6* cx.tree
def tree(self):
    
    '''Return the AST (Abstract Syntax Tree) associated with this query object
    (Context Class).  This tree can be passed to the format method for printing.
    '''
    
    return self._tree
.. @+node:ekr.20111128103520.10259: *5* cx.token_range
def token_range (self):
    
    tree = self._tree
    
    # return (
        # g.toUnicode(self.byte_array[:tree.col_offset]),
        # g.toUnicode(self.byte_array[:tree_end_col_offset]),
    # )
    
    if hasattr(tree,'col_offset') and hasattr(tree,'end_col_offset'):
        return tree.lineno,tree.col_offset,tree.end_lineno,tree.end_col_offset
    else:
        return -1,-1
.. @+node:ekr.20120118085926.10251: *4* Why does ic.readOneAtAutoNode exist?
.. @+node:ekr.20070909100252: *5* at.readOneAtAutoNode
def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()

    at.default_directory = g.setDefaultDirectory(c,p,importing=True)
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    # 2010/7/28: Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,p)

    s,ok,fileKey = c.cacher.readFile(fileName,p)
    if ok:
        g.doHook('after-auto',c=c,p=p)
            # call after-auto callbacks
            # 2011/09/30: added call to g.doHook here.
        return

    if not g.unitTesting:
        g.es("reading:",p.h)

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        # Note: the file contains an @ignore,
        # so no unintended write can happen.
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        c.cacher.writeFile(p,fileKey)
        g.doHook('after-auto',c=c,p=p)
            # call after-auto callbacks
            # 2011/09/30: add 'c' keyword arg.
.. @+node:ekr.20070806111212: *5* readAtAutoNodes (importCommands) & helper
def readAtAutoNodes (self):

    c = self.c
    p = c.p ; after = p.nodeAfterTree()

    found = False
    while p and p != after:
        if p.isAtAutoNode():
            if p.isAtIgnoreNode():
                g.es_print('ignoring',p.h,color='blue')
                p.moveToThreadNext()
            else:
                self.readOneAtAutoNode(p)
                found = True
                p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
            
    if not g.unitTesting:
        message = g.choose(found,'finished','no @auto nodes in the selected tree')
        g.es(message,color='blue')
    c.redraw()

.. @+node:ekr.20070807084545: *6* readOneAtAutoNode (leoImport)
def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c ; at = c.atFileCommands
    
    fileName=p.atAutoNodeName()

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    self.createOutline(
        fileName=fileName,
        parent=p.copy(),
        atAuto=True)

    # 2010/01/15: Remember that we have read this file.
    # http://groups.google.com/group/leo-editor/browse_thread/thread/b77b5260854ffbf6
    # Important: createOutline usually sets the bit in the wrong node.
    
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName,p)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
.. @+node:ekr.20120219152142.34262: *4* Revert moves the reverted tab to the right
.. @+node:ekr.20031218072017.2837: *5* c.revert
def revert (self,event=None):

    '''Revert the contents of a Leo outline to last saved contents.'''

    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return

    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")
    c.bringToFront()

    if reply=="no":
        return

    # Rename this frame so the open logic won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    c2 = g.openWithFileName(fileName,old_c=c)
    if c2:
        c2.frame.deiconify()
        g.doHook("close-frame",c=c)
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
.. @+node:ekr.20111018220642.15858: *3* Docs
.. @+node:ekr.20111127153202.10264: *4* Document leoInspect
.. @+node:ekr.20111027103125.16540: *4*  Leo's home page and web site
.. @+node:ekr.20110930174206.15470: *5* ** Urgent: Bring screen shots up to date
> While doing so I noted that on the sourceforge project
> page some screenshots are bit old, such as touting Tk.
>
> shows tk - http://webpages.charter.net/edreamleo/screen-shots.html
    Fixed
    
> uses @thin - http://webpages.charter.net/edreamleo/PCWindow.gif

> screenshots shows deprecated plugin manager -
> http://sourceforge.net/projects/leo/
    All souce-forge screenshots need to be replaced.


.. @+node:ekr.20111018104244.15919: *5* Follow up on "Leo as a static site generator
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/840b0998de6c83e8

A long thread, full on interesting things.
.. @+node:ekr.20111027103125.16544: *5* Add screen shot to Leo's home page
@nocolor-node

In downloads folder: leo-4.9_viewrendered-layout.png
.. @+node:ekr.20111027103125.16545: *5* Make sure you can get from TOC to home page
@nocolor-node

AFAICT - once you get below the homepage there is no way to get back to
the home page. Clicking the[ Lion] gets to the TOC. Maybe a link on the
TOC identified as [Home] back to http://webpages.charter.net/edreamleo/ ? 
.. @+node:ekr.20111020120612.15896: *5* Add link to glossary from Leo's home page
@nocolor-node

> Looks good, how about a link "Search", leading to
> http://webpages.charter.net/edreamleo/genindex.html or some other page
> where there's a search box.

Good idea.  I'll do it today.
.. @+node:ekr.20111027103125.16539: *5* Add link to search box from Leo's home page
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/eabbc401bbb9bf0/a705ad30d7900727

how about a link "Search", leading to
> http://webpages.charter.net/edreamleo/genindex.html or some other page
> where there's a search box.

Good idea.  I'll do it today. 
.. @+node:ekr.20111018104244.15924: *5* Revise Leo's wiki
.. @+node:ekr.20111011175652.15696: *5* Register a domain name like leo-editor.org
.. @+node:ekr.20111027103125.16541: *4*  Revise docs
.. @+node:ekr.20111020120612.15894: *5* Review bzr instructions
.. @+node:ekr.20111017102409.15876: *5* Document new organization for @command and @button nodes
@language rest

Recent revs to to the trunk complete, with perhaps one or two small
additions to come, a grand redesign of all of Leo's @command/@button
nodes:

- Significant @command nodes now appear in:

   leoSettings.leo#@settings-->Common @command nodes
   -->@commands-->@ignore

That is, they are define in as common global @command nodes, but they
are ignored.  Move them to myLeoSettings.leo as needed.

- @buttons appear only local to specific files.  See leoSettings.leo
for check buttons and LeoDocs.leo for various preview buttons.

In other words, the new org uses @command for global scripts and
@button for local scripts.  This makes sense for two reasons.  First,
we can't use @button for global scripts because that would overwhelm
the icon area.  Second, using @button for local scripts draws
attention to scripts that only make sense in a local context.  It's
very effect.

Edward

P.S. Except for the relatively minor tweaks, Leo already had
everything needed to support this scheme.  In particular, Leo already
supported the distinction between local and global @command and
@button nodes.

P.P.S. Earlier today I correct an oversight:  Leo now properly
supports @ignore nodes in @commands and @buttons nodes.  This is very
useful: no need for @@button or @@command.
.. @+node:ekr.20111015173019.15681: *5* Document @mark-for-unit-test trees!
@language rest


I would prefer if it would be possible to launch tests externally without loading plug-ins.

As I see in Code-->Testing-->@file leoTest.py-->runUnitTestLeoFile
and in Code-->Testing-->@file leoTest.py-->class runTestExternallyHelperClass-->runTests

there is an option to set gui for testing (g.app.unitTestGui) and default is 'nullGui'.

Maybe there could be an option to disable loading of plug-ins also ?

For the tests that I mostly write and run, loading plug-ins is just wasting time.
Vitalije.

===========================

> I am not sure what happens at present, and I'm not sure whether any settings apply to these commands.

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
.. @+node:ekr.20111014074810.15653: *5* Rewrite MacOs instructions using Ludvig's homebrew instructions
@language rest


http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy!

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R <your user name>:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Ludwig
.. @+node:ekr.20111016072542.15702: *5* FAQ entry: @commands Aha
@language rest

The prefix "DingDing" signifies that this post is an answer to the
lament:

    "Wouldn't it be great if we all could remember what we,
    and others, have already done :-)"

Last night I had a forehead-slapping moment: the place to put @button
nodes is in myLeoSettings.leo.

This morning, I realized that using @command rather than @button
completes the Aha.

This organization has all benefits, and no drawbacks:

- I always know here scripts are.

- No need for duplicates.

- I can organize the scripts within myLeoSettings.leo as usual using
organizer nodes.  This organization can change as needed.

- Using @command rather than @button means that I never have to
disable scripts.  No more @@button.

- Using @command saves screen real estate.  In my experience, having
buttons be visible doesn't prevent them from being hidden in full
view.

- If I use common prefixes, like c_ (for command) or edit_ (for edit-
related scripts) or ekr_ (for personal scripts), the *typing
completion* will let me zero in on the script I want to use:

    <alt-x> c_<tab>
    <alt-x> c_import<tab>

etc.  Furthermore, Ctrl-P (repeat-complex-command) will allow me to
rerun the last script run.  This is a quite common case.

Summary
=======

This Aha substitutes an *already-existing* usage (typing completion)
for a whole set of memory-intensive retrieval problems.  I'm not
likely ever to forget typing completion, although I might forget the
specif prefixes used in @command nodes.  If that happens, I'll know
where to look.

This Aha takes full advantage of Leo's organization strengths and
*concentrates* those strengths by putting all the to-be-organized
material in one place.  This allows for easy reorganization:  changing
command-name prefixes, for instance, would be straightforward.

This is another example of the assertion that Leo already has most of
what is required to handle any task. 
.. @+node:ekr.20110918204916.6811: *5* revise autocompletion docs based on recent posts
.. @+node:ekr.20110929074744.15474: *6* Autocompleter post
@language rest
@pagewidth 65

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass unless otherwise noted.

- The autoComplete method is the entry point. It will be called
  when autocompletion is enabled and the user types either a period
  or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       
.. @+node:ekr.20110929074744.15475: *7* Creating ctags data
On Sep 10, 8:36 am, "Edward K. Ream" <edream...@gmail.com> wrote:

> Later posts will discuss the following:
> 
> - Setting up to use ctags/codewise completion.

This section describes how to use Ville's codewise.py
module in leo\external folder.

**Note**: I've recently made a few changes to codewise.py. The
following discussion reflects the following changes:

- Changed docstring.

- The setup command does not crash if the ~/.ctags file already
  exist.
  
- The setup command does not call the init command, and thus does
  not delete ~/.codewise.db.
  
- Revised various print statements so they look better with Python 3.x.

**Important**: Leo's core contains all necessary autocompletion
code. In particular, enable *neither* the ctagscompleter.py
plugin *nor* the codewisecompleter.py plugin. I plan to remove
these plugins immediately, unless someone gives a good reason not
to do so.

**Important**: I've taken care to with the following
instructions, but there could be oversights or misunderstandings.
I would appreciate any corrections or additions.

Creating codewise/ctags data
============================

1. Make sure you have exuberant ctags (not just regular ctags)
   installed. It's an Ubuntu package, so its easy to install if
   you're using Ubuntu.
   
2. Execute the following commands from Leo's external/codewise.py
   module. **Note**: On Windows, you can use codewise.bat to
   execute these commands. For example::

        python <path to leo>\external\codewise.py %*
    
A. [Optional] Create a custom ~/.ctags file containing default
   configuration settings for ctags::
    
        codewise setup
        
    This command will leave the ~/.ctags file unchanged if it
    exists.  Othewise, the ``codewise setup`` command will
    create a ~/.ctags file containing the following defaults::
    
        --exclude=*.html
        --exclude=*.css
    
    See: http://ctags.sourceforge.net/ctags.html#FILES for more
    details about the .ctags file.
    
B. [Optional] Delete the existing ctags database in ~/.codewise.db::
   
        codewise init
        
C. Add ctags data to the existing ctags database::

        codewise parse <path to directory>
        
   You can add data from multiple sources by running
   the ``codewise parse`` command on multiple directories.
   
.. @+node:ekr.20110929074744.15476: *7* Using Leo's autocompleter (outline form)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
.. @+node:ekr.20110929074744.15477: *8* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15478: *8* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15479: *8* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15480: *8* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15481: *8* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15482: *7* Using Leo's autocompleter (COPY)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
Starting autocompletions
========================

There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autcompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.

Displaying autocompletions
==========================

How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.

Using the QCompleter
====================

When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.

Using the Log pane completer
============================

When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.

Showing docstrings
==================

Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15483: *8* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15484: *8* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15485: *8* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15486: *8* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15487: *8* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15488: *7* Code notes
Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.



.. @+node:ekr.20110929074744.15489: *7* Minor settings
Minor Autocompletion settings
=============================

These are found in leoSettings.leo: @settings-->Autocompleter

- @bool use_codewise = False

True: use codewise completions.
False: use Leo-specific completions.

- @bool use_qcompleter = True

True:  show completions in a QCompleter popup.
False: show completions in Leo's Completions tab.
This option has effect only when using the qt or qttabs gui's.

The following options specify minor user preferences: they have little or no effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15490: *7* Appearance
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

.. @+node:ekr.20110929074744.15491: *7* Codewise notes
Why the codewise module
=======================

- This module supports modern code completion for the Leo editor.

- Exuberant ctags is an excellent code scanner, but TAGS file
  lookup sucks for "find methods of this class".
  
- This module puts all data in a single file, ~/.codewise.db by
  default. In contrast, TAGS files can exist all over the file
  system.

- The code in codewise.py is usable as a python module, or a
  command line tool.


Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.
.. @+node:ekr.20110929074744.15492: *7* Performance
Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

.. @+node:ekr.20110929074744.15493: *7* Completions
os.path.splitdrive.d_rule
os.path.join
.. @+node:ekr.20110929074744.15494: *8* Docs
@language rest


Creating codewise/ctags data
============================

This is adapted from the thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/ca01e7a803d2b546
"HOWTO: make Ville's autocompleter work.

1. Make sure you have exuberant ctags (not just regular ctags) installed.  It's an Ubuntu package, so it's easy to install if you're using Ubuntu.

2. All recent versions of Leo contain Ville's codewise module: leo/external/codewise.py

@pagewidth 60

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass
unless otherwise noted.

- The autoComplete method is the entry point.  It will be called when autocompletion is enabled and the user types either a period or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       


Here are the contents of the discussion of autocompletion from the 4.9 release notes in LeoDocs.leo.  These should be folded into Leo's Users Guide: I'll do that today.

QQQQQ
 
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

QQQQQ

Part 2: New documentation

As I reread the release notes, I see that they are too code-oriented for the general reader.  What is needed are the following:

1. A discussion of Autocompletion settings in 
.. @+node:ekr.20110929074744.15495: *9* Additional options
The following options specify minor user preferences: they have little or no
effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15496: *8* Existing docs
@language rest
@pagewidth 65

Typing a period when @language python is in effect starts
autocompletion. Typing Return or Control-g (keyboard-quit) exits
autocompletion.

Autocompletion shows what may follow a period in code. (Actually
you can specify any character using the auto-complete shortcut
setting.) For example, after typing g. Leo will show a list of
all the global functions in leoGlobals.py. Autocompletion works
much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in
the body pane.

A leading period brings up ‘Autocomplete Modules’. (The period
goes away.) You can also get any module by typing its name. If
more than 25 items would appear in the Autocompleter tab, Leo
shows only the valid starting characters. At this point, typing
an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated
modes.

If x is a list ‘x.!’ shows all its elements, and if x is a Python
dictionary, ‘x.!’ shows x.keys(). For example, ‘sys.modules.!’
Again, further exclamation marks toggles between full and
abbreviated modes.

During autocompletion, typing a question mark shows the docstring
for the object. For example: ‘g.app?’ shows the docstring for
g.app. This doesn’t work (yet) directly for Python globals, but
‘__builtin__.f?’ does. Example: ‘__builtin__.pow?’ shows the
docstring for pow.

Autocompletion works in the Find tab; you can use <Tab> to cycle
through the choices. The ‘Completion’ tab appears while you are
doing this; the Find tab reappears once the completion is
finished. Calltips

Calltips appear after you type an open parenthesis in code.
Calltips shows the expected arguments to a function or method.
Calltips work for any Python function or method, including
Python’s global functions. Typing Return or Control-g
(keyboard-quit) exits calltips.

Examples:

    ‘g.toUnicode(‘ gives ‘g.toUnicode(s, encoding, reportErrors=False’
    ‘c.widgetWantsFocusNow’ gives ‘c.widgetWantsFocusNow(w’
    ‘reduce(‘ gives ‘reduce(function, sequence[, initial]) -> value’

The calltips appear directly in the text and the argument list is highlighted so you can just type to replace it. The calltips appear also in the status line for reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the enable_autocompleter and enable_calltips settings in leoSettings.leo. You may enable or disable these features at any time with these commands: enable-auto-completer-command, enable-calltips-command, disable-auto-completer-command and disable-calltips-command.
The minibuffer

The mini-buffer is a text area at the bottom of the body pane. You use it like the Emacs mini-buffer to invoke commands by their so-called long name. The following commands affect the minibuffer:

    full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit <Return> to execute the command. Tab completion works, but not yet for file names.

    universal-argument: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 a’s.
    keyboard-quit: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands <Return>.

The following sections list the various commands that you can invoke from the minibuffer. Important: you may bind keystrokes to any of these commands. See Customizing Leo for full details.
.. @+node:ekr.20111017132257.15886: *5* Add tip: How to restore focus without the mouse
@language rest

It sometimes happens that the focus gets left in a Leo in a widget
that doesn't support Leo's key bindings.  You would think that you
would have to use the mouse to click in, say, the body pane so that
you can use Leo's key bindings again.

But you don't have to do that.  Instead, use Alt-tab once to change
away from Leo, and then use Alt-tab again to change back to Leo.  When
you do this, Leo puts focus in the body pane and you are all set. This
will work either on Windows or Ubuntu.  A similar trick works on
MacOS.

Edward

P.S. One of the requirements of the recent bug fix was that doing Alt-
tab twice would put the focus in the body pane.  If you think that was
easy, you are sadly mistaken :-) 
.. @+node:ekr.20111018104244.15926: *5* Document loading plugins when running unit tests externally
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b560a3b84e7ec7a8

Good news (mostly): you can set up dynamic unit tests exactly the way you want.

I was going to point you at the documentation but (how can this
possibly be?) the documentation doesn't exist!  I really could have
sworn that everyone knew about what I am about to tell you ;-)  To
quote Alan Greenspan, "I'm shocked.  Shocked."

So here goes...

Let p be the presently selected node when you hit Alt-5
(run-unit-tests).  Leo, that is, the code in
runTestExternallyHelperClass, creates dynamicUnitTest.leo by
assembling all of the following nodes from p's descendants.

- All @test nodes,
- All @suite nodes, and, **most importantly**,
- All children of all @mark-for-unit-tests nodes.

You can use @mark-for-unit-test nodes to include any "supporting data"
you want, including, say, "@common test code" to be imported as
follows::

    exec(g.findTestScript(c,'@common test code'))

Hmm.  I doubt this is really written up properly, although I know for
sure at the time I did write it up on leo-editor.  It's a very cool
pattern.

Now here is the new trick.  It *should* work, but actually does *not*
work yet.  Boo hoo. Are you ready?

- @mark-for-unit-tests
  - @settings
    - @enabled-plugins

Alas, this doesn't work because the test code runs dynamicUnitTest.py,
which runs dynamicUnitTest.leo **using the leoBridge module**.  And,
as I have just verified, the leoBridge module doesn't load *any*
plugins.  Nor does it init any other settings.

So, no matter *what* @enabled-plugins contains, your code will start
off with no plugins at all.  Thus, the following unit test will always
pass when run with Alt-5::

    @test loaded-plugins

    pc = g.app.pluginsController
    aList = pc.getLoadedPlugins()
    assert not aList,aList

However, your tests *can* load plugins if they like, provided they
don't through an exception when loaded with nullGui.  For example, the
following test passes::

    @test load backlink plugin

    pc = g.app.pluginsController
    pc.loadOnePlugin('backlink.py')
    aList = pc.getLoadedPlugins()
    assert 'leo.plugins.backlink' in aList

A similar trick could probably be used to set c.config settings from
the @settings tree, but at present your code would have to do all the
work itself: the leoBridge module does **not** initialize settings.
That is, c.config.getBool(x) returns None for all (strings) x.

I hope this gives you a sense of what is going on.  For full details,
consult leoTest.py.

It has been fun tracking this down.  I'll fix the documentation immediately. 
.. @+node:ekr.20111026083456.16489: *5* Move UNL.py plugins docs somewhere else: it's no longer a plugin.
.. @+node:ekr.20111027103125.16537: *5* Revise Leo's docs re import commands
@nocolor-node

Terry:

I don't think the OP was trying to import MORE data, I think Leo is
incorrectly trying to apply MORE rules on loading a .txt file.

The File->Import command gives no indication it expects MORE data.

OTOH, the simple workaround is to use File->Open.

So perhaps it's a documentation / ui bug to clarify what File->Import
is for.


==============

Rob:
    
I would agree the documentation could be updated to reflect current
practice. The online docs (under the heading 'Importing Files Into Leo
Outlines':

The Import commands do not attempt to do perfect translations; they
merely automate the bulk of the drudgery:

   The Import to @file command creates an @file node from a file.
   The Import CWEB Files command creates an @file node from a CWEB file.
   The Import noweb Files command creates an @file node from a noweb file.
   The Import External File command imports all the nodes in a external file into the outline. Unlike the read commands, the command preserves no outline structure.
   The Import Flattened Outline command converts plain text written in MORE format to an outline.

The Import Flattened Outline command brings up a
dialog.................(more info about MORE spec)

I would say most/all of this has been deprecated as there's only one
Import command.
.. @+node:ekr.20111018104244.15922: *5* Leo on Mac OSX: new installation instructions
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/92ae059cc5213ad3

I bear good tidings of great joy! 

I recently received a new MacBook Pro and did a fresh upgrade to Mac
OS 10.7 (Lion). I then used the opportunity to test out installation
procedures of various software on a clean system. My main finding is
that the excellent Homebrew (mxcl.github.com/homebrew/) makes things
much easier these days.

Why Homebrew? It does not try to replace every single bit of
functionality on your Mac with their own version, like Macports or
fink. It reuses the existing libraries as far as possible. No need to
reinstall Python, for example (one of my pet gripes when people try to
install new software on their Macs, and the source of much confusion
and pain). It installs to /usr/local, the standard place to find
third-party libraries and headers, instead of the obscure /opt or /sw.
It's simple to use and to extend.

I last installed Leo on Mac OS 10.4 (Tiger) back in the Tk days, and
wondered what it looked like in Qt. All the horror stories of PyQT on
Mac discouraged me from trying this before, so I was keen to see if
Homebrew helps. Here is my installation write-up:

- Make sure you have Xcode installed
  (test it by confirming that "gcc" runs in the Terminal)

- In preparation for homebrew, the best option in my opinion is
  to delete /usr/local via::

  sudo rm -rf /usr/local

  and install any software in it via homebrew instead. If this step
  fills you with dread and you do not want to lose your beloved
  third-party software, the second-best option is to make sure you
  have write permission for the directory via::

  sudo chown -R <your user name>:admin /usr/local

  If you don't know your username, run "whoami". :-) This is
  useful because homebrew actually discourages you from
  installing third-party software as the superuser (the usual Mac
  apps in /Applications are also installed as the normal user,
  for that matter).

- Install Homebrew (http://mxcl.github.com/homebrew/) by running
  the following command in the Terminal::

  /usr/bin/ruby -e "$(curl -fsSL https://raw.github.com/gist/323731)"

- Run "brew update" to get the latest formulas

- Now install PyQT (yes, that's it!)::

  brew install pyqt

- Run "brew doctor" and check any further suggestions to improve
  your system.

- Add the following lines to your ~/.bash_profile
  (or ~/.profile on Leopard)::

  export PATH=/usr/local/bin:$PATH
  # This is for SIP (and PyQT) as suggested by Homebrew
  export PYTHONPATH=/usr/local/lib/python:$PYTHONPATH

- Open a new Terminal tab / window so that the above settings
  take effect, and install Leo. I downloaded the Leo-4.9-final-a.zip,
  unzipped it, and ran "python launchLeo.py" inside the Leo
  directory.

We should consider adding a Homebrew formula for Leo. This will
simplify the process even further, to simply "brew install leo". I
started on this, but wasn't sure where to put the various Leo files in
the system hierarchy. The Debian package can give some clues here, but
I haven't looked at it yet.

Now I just have to start using Leo after all these years of checking
it out... :-)

.. @+node:ekr.20111027103125.16542: *4* Document new features
.. @+node:ekr.20111017132257.15892: *5* Add short intro to scripting
@language rest

http://mail.google.com/mail/#inbox/1330f306b947656c

> Maybe I'm missing something here, probably because I've always
> dismissed scripting because I don't have the foggiest notion of how to
> write one.

As you have just discovered, Leo does have scripting docs.

However, let me say a few words about scripting in *this* context.

What makes Leo scripting so important is that the predefined c, g and
p variables give *full* and *easy* access to all the data in your
outlines, as well as hundreds, if not thousands, of useful Python
functions in Leo's core.

You could say that these variables, especially c, define a *very*
easy-to-use DOM (Document Object Model) through which you can get o
set any data in *your** outlines.

The hello world example is::

   for p in c.all_positions():
       indent = '.' * p.level()
       print('%s%s' % (indent,p.h))

Here, c.all_positions() delivers a list of positions, and p.level()
and p.h deliver the indentation level and head string of position p.

Another crucial part of Leo scripting is that you can put Leo script
*anywhere* in a Leo outline.  You can do this in three ways:

1. You can just put the script above in the body of any node and run
it with Ctrl-B (execute-script).

2. You can make a script button by putting the script in an @button node.

3. You can make a new Leo command by putting the script in an @command node.

.. @+node:ekr.20111017124557.15879: *6* Easier scripting
# aList = [z for z in dir(c) if 'hild' in z]
# aList.sort()
# for z in aList:
    # print(z)

c.insertHeadline(event=None, op_name='Insert Node', as_child=False)

x = g.BasicLeoScript()

x.insert()
x.delete()
x.node()
n.h, n.d

.. @+node:ekr.20111017132257.15884: *5* Terry added bookmark scripts
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/b17d140b7ceb8fc9

I've added web page bookmarking from your browser to Leo.

Docs., appended to the mod_http plugin, where this functionality lives,
are pasted below.

Screen shot of the form which pops up when you click the Bookmark
button in your browser attached.  The body text of the corresponding
bookmark node created in Leo is:

    Leo's Home Page
        http://webpages.charter.net/edreamleo/front.html

        Tags: leo, python

        Leo's Home Page

        Collected: Sun 02 Oct 2011 02:52:51 PM CDT

        Keep this under your pillow.

If you had some text selected on the page in your browser that would
also appear in the above, and repeatedly bookmarking the same page with
different selections incrementally adds such quotes to the bookmark
node.

Here are the docs.:

Can also be used for bookmarking directly from the browser to Leo.  To
do this, add a bookmark to the browser with the following URL / Location:

    javascript:w=window;if(w.content){w=w.content}; d=w.document; w.open('http://localhost:8130/_/add/bkmk/?&name=' + escape(d.title) + '&selection=' + escape(window.getSelection()) + '&url=' + escape(w.location.href),%22_blank%22,%22toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=yes, copyhistory=no, width=800, height=300, status=no%22);void(0)

and edit the port (8130 in the example above) to match the port you're using
for mod_http.

Bookmarks are created as the first node in the outline which has been opened longest.
You can set the ``@string`` ``http_bookmark_unl`` to specify an alternative location,
e.g.::

    @string http_bookmark_unl = /home/tbrown/.bookmarks.leo#@bookmarks-->Incoming

to place them in the `Incoming` node in the `@bookmarks` node in the `.bookmarks.leo` outline.

The headline is preceeded with '@url ' *unless* the ``bookmarks`` plugin is loaded.
If the ``bookmarks`` plugin is loaded the bookmark will have to be moved to a ``@bookmarks`` tree to be useful.

The browser may or may not be able to close the bookmark form window for you, depending on settings - set ``dom.allow_scripts_to_close_windows`` to true
in ``about:config`` in Firefox. 
.. @+node:ekr.20111017132257.15889: *5* Document clone/move/delete-marked commands
http://groups.google.com/group/leo-editor/browse_thread/thread/4686ebad81bb1ea1
.. @+node:ekr.20111015194452.15682: *5* Improved quicksearch plugin
@nocolor-node

- Selecting any node using arrow keys shows the node in the outline immediately.

- Clicking a node or hitting <return> puts focus in body pane.

- Still to do: support Ctrl-G in Nav Tab.
.. @+node:ekr.20111104032034.9747: *5* Hidden unit tests
As of rev 4690, Leo supports "hidden" unit tests.  This just may be
the missing piece of Leo's unit testing arsenal.

A hidden unit test is a node that is *not* a section-definition node
and whose body text contains one of the following guards at the start
of a line::

    if g.unitTesting
    if g.app.unitTesting:
    if g.inScript:
    if g.app.inScript:

The typical usage pattern is::

    class myClass:
        ...

    if g.unitTesting:
        x = myClass()
        x.test()

For this reason, hidden unit tests could also be called "in place"
unit tests: they appear in the Leo source file, next to the code being
tested.

Notes:

1. [Important]: Any one of the guards above will prevent the unit
testing code from being executing when importing a file.  Thus, you
can insert a unit test just after the code you want to test.

2. [Spectacular]: The test tests the latest code *without* you having
to reload Leo.  The reason is simple: the code being tests (myClass,
in the example above), is defined by either the unit tests or the
execute-script command.

3. [Happy]:  Within leoPy.leo I redefined alt-4 to mean run-all-unit-
tests-locally, which is the most convenient way to run the test I am
working on: running the other tests doesn't matter, and in fact is a
good check.

4. Because hidden unit tests are not marked with @test, Leo always
tells which hidden tests have been found.

A good day for unit testing in Leo. 
.. @+node:ekr.20111104032034.9748: *5* Use Alt-4 for all unit tests
There is a collapse in complexity here that I just discovered: use
Alt-4 for all tests.

    unitTest.leo: bind Alt-4 to run-selected-unit-tests-externally
    leoPy.leo:    bind Alt-4 to run-marked-unit-tests-locally 

run-marked-unit-tests-externally is the simplest thing that could possibly work.
Bind Alt-4 to this command, marked just the desired tests and then run them with
one keystroke. Brilliantly simple.

Experience shows that being able to run the desired unit tests
*without* selecting any particular node makes an amazingly large
difference.  Being able to run all and only marked unit tests is a big
step forward.
.. @+node:ekr.20111104032034.9746: *5* Weightless unit testsing
As of rev 4725, unit testing in leoPy.leo feels *completely*
weightless.  The last change: running any unit test externally saves
the .leo file automatically first.

Thus, Alt-4 runs all desired unit tests immediately.  To select/
deselect unit tests, just mark/unmark @test nodes.

The difference in workflow is *huge*.  There is no need to select
@test nodes in any way, except for marking them.

So I create an @test node, make changes to that node, or to the code
being tested, and hit Alt-4.  Done.

When I am satisfied with the @test node, I can leave it where it is
(unmarked) or move it to unitTest.leo.

The energy difference between weightless and heavy is astounding.  Try
the new way: you will surely like it. 
.. @+node:ekr.20111027103125.16543: *4* Code related to docs
.. @+node:ekr.20111018104244.15931: *5* Added @command print-cmd-docstrings
Leo must have a check-doc-strings script that will verify that all
commands have non-trivial doc strings.

.. @+node:ekr.20111019080436.15849: *5*  Doc scripts: 2
.. @+node:ekr.20111018104244.15932: *6* Write create-command-docs script
@language rest

This will create large docs for individual commands from docstrings.

Base this on print-cmd-docstrings.
.. @+node:ekr.20111018104244.15933: *6* Write create-plugins-doc script (Use/adapt plugin_catalog.py)
@language rest

Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible. 

Terry wrote plugin_catalog.py.  It is in LeoDocs.leo)
.. @+node:ekr.20111021105253.9476: *5* Make sure all colorizer languages have entries in leoApp.py
.. @+node:ekr.20111021035504.9469: *6* Script: get all comments from modes
import glob
import imp
@others

keys = ("lineComment","commentStart","commentEnd",)
d = {}
    # Keys are language names.
    # Values are a list of comment delims, in keys order.
paths,modes_path = get_paths()
for path in paths:
    module_name = g.shortFileName(path)[:-3]
    module = import_module(module_name,modes_path)
    aList = []
    for key in keys:
        val = module.properties.get(key)
        if val: aList.append(val)
    d[module_name] = aList

print('-'* 20)
print('language_delims_dict')
for key in sorted(d):
    print('%16s: "%s"' % ('"%s"' % (key),' '.join(d.get(key))))
.. @+node:ekr.20111021035504.9470: *7* get_paths
def get_paths():
    
    modes_path = g.os_path_finalize_join(g.app.loadDir,'..','modes')
    pattern = g.os_path_finalize_join(modes_path,'*.py')
    paths = glob.glob(pattern)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    return paths,modes_path
.. @+node:ekr.20111021035504.9471: *7* import_module
def import_module(module_name,modes_path):
    
    data = imp.find_module(module_name,[modes_path])
        # This can open the file.
    theFile,pathname,description = data
    module = imp.load_module(module_name,theFile,pathname,description)
    return module
.. @+node:ekr.20111019104425.15865: *5* Make sure docstrings include present documentation
.. @+node:ekr.20111019080436.15848: *3* Easy new features
.. @+node:ekr.20111019104425.15869: *4* Convert @command nodes to official commands
@nocolor-node

May require command-related settings.

Example:
    @path create-at-auto-nodes-path=C:\apps\pygments\pygments
    @string create-at-auto-nodes-types=.py,
    @bool create-at-auto-nodes-is-recursive=True
.. @+node:ekr.20111012061216.15698: *4* Complete expand/contract commands
.. @+node:ekr.20111017102409.15875: *4* Create print-buttons command
@nocolor-node

- Create print-buttons command, showing source of all @command and @button nodes.
.. @+node:ekr.20111010122531.15569: *4* print-bindings/commands/settings create nodes
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/d302b2715b3ace96

A reminder, the opposite of "light" is "heavy", not "dark" :-)

Leo's print-settings, print-commands and print-bindings commands
create too much text.

Suppose they created outline nodes instead, replacing existing nodes
if they exist.  Something like this:

- Reference (Anywhere you like)
 - @print-settings
    etc.
 - @print-bindings
   etc
 - @print commands
   etc

Doh!  This uses Leo's power.  The subnodes can be as voluminous as
desired, and there can be organizer nodes in each case.  The actual
tree could be specified as in @menus.

Etc., etc.  This could moot the need for separate apropos commands.
Conversely, apropos commands could create their own trees, or
subtrees.

This could be the tip of an iceberg.

The more I think about the light/heavy distinction, the more I think
it is getting close to what makes Leo special.  For example, clones
(and nodes, for that matter) drastically lighten the apparent
complexity of programs or data.
.. @+node:ekr.20111010093113.15547: *4* Add support for ! in minibuffer
.. @+node:ekr.20061031131434.145: *5* k.Master event handlers
.. @+node:ekr.20061031131434.105: *6* k.masterCommand & helpers
def masterCommand (self,commandName=None,event=None,func=None,stroke=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or g.trace_masterCommand) and not g.unitTesting
    verbose = True
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    
    if event: c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.

    char = ch = event and event.char or ''
    w = event and event.w
    
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
        
    # Important: it is *not* an error for func to be None.
    k.func = func
    commandName = commandName or func and func.__name__ or '<no function>'
    k.funcReturn = None # For unit testing.
    << define specialKeysyms >>
    special = char in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke,repr(ch),func and func.__name__))

    if inserted:
        k.setLossage(ch,stroke)

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startRecordingMacro(event)
        # 2011/06/06: Show the key, if possible.
        # return # (for Tk) 'break'

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return # (for Tk) 'break'

    if special: # Don't pass these on.
        return # (for Tk) 'break' 

    # if k.regx.iter:
        # try:
            # k.regXKey = char
            # k.regx.iter.next() # EKR: next() may throw StopIteration.
        # except StopIteration:
            # pass
        # return # (for Tk) 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return # (for Tk) 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
.. @+node:ekr.20061031131434.106: *7* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
.. @+node:ekr.20061031131434.110: *7* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting
    verbose = False

    if trace and verbose:
        g.trace('widget_name',name,'stroke',stroke,'enable alt-ctrl',self.enable_alt_ctrl_bindings)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        import leo.core.leoFrame as leoFrame
        if issubclass(w.__class__,leoFrame.HighLevelInterface):
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                w.logCtrl.insert(i,s)
        else:
            if trace: g.trace('Not a HighLevelInterface object',w)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.146: *6* k.masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event):

    '''This is the handler for almost all key bindings.'''
    
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = g.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True
    
    k,c = self,self.c ; gui = g.app.gui
    c.check_event(event)
    << define vars >>
    
    assert g.isStrokeOrNone(stroke)

    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert g.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        return k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,stroke)
.. @+node:ekr.20061031131434.147: *7* << define vars >>
w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
.. @+node:ekr.20061031131434.108: *7* callStateFunction
def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''

    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
        
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
.. @+node:ekr.20091230094319.6244: *7* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        if val == 'do-standard-keys':
            return False,None # 2011/06/17.
        else:
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
.. @+node:ekr.20091230094319.6240: *7* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    
    assert g.isStroke(stroke)

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si

    return None
.. @+node:ekr.20061031131434.152: *7* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or g.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
        
    assert g.isStroke(stroke)

    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20110209083917.16004: *7* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    assert g.isStrokeOrNone(stroke)
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
.. @+node:ekr.20080510095819.1: *7* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    
    assert g.isStroke(stroke)

    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return None
        
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return None

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return None

    elif k.ignore_unbound_non_ascii_keys and (
        len(char) > 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return None

    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return None

    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        return k.masterCommand(event=event,stroke=stroke)
.. @+node:ekr.20111017132257.15888: *4* Is there a script to diff 2 Leo files & create a tree?
.. @+node:ekr.20111018104244.15927: *4* Allow {{expr}} in URL's (and UNL's?)
.. @+node:ekr.20111018104244.15925: *4* Improve leo.leo by making bookmarks more useful
@nocolor-node

- Some kinds of relative bookmarks don't work.
- Allow {{exp}}
- Convert back slashes to forward slashes.
.. @+node:ekr.20031218072017.2312: *5* tree.OnIconDoubleClick (@url) & helper
# Several plugins handle url's, especially UNL.py.

def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.h.strip()
    if g.match_word(s,0,"@url"): 
        if p.b.strip():
            lines = p.b.split('\n',1)
            url = lines and lines[0].strip() or ''
        else:
            url = s[4:].strip()
        # g.trace(url,g.callers())

        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            g.handleUrlInUrlNode(url, c=c, p=p)
        g.doHook("@url2",c=c,p=p,v=p)

    return # (for Tk) 'break' # 11/19/06
.. @+node:tbrown.20090219095555.61: *5* g.handleUrlInUrlNode
def handleUrlInUrlNode(url, c=None, p=None):
    
    # Note 1: the UNL plugin has its own notion of what a good url is.

    # Note 2: tree.OnIconDoubleClick now uses the body text of an @url
    #         node if it exists.

    if g.unitTesting: return
    
    << check the url; return if bad >>
    << pass the url to the web browser >>
.. @+node:tbrown.20090219095555.62: *6* << check the url; return if bad >>
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

# urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

if not url:
    g.es("no url following @url")
    return

# Add http:// if required.
# if not re.match('^([a-z]{3,}:)',url):
#     url = 'http://' + url
# if not re.match(urlPattern,url):
#     g.es("invalid url:",url)
#     return
.. @+node:tbrown.20090219095555.63: *6* << pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    
    parsed = urlparse(url)
    
    leo_path = parsed.path
    if parsed.netloc:
        leo_path = os.path.join(parsed.netloc, parsed.path)
        # "readme.txt" gets parsed into .netloc...
    
    if c and parsed.scheme in ('', 'file'):
        
        # local UNLs like "node-->subnode", "-->node", and "#node"
        if '-->' in parsed.path:
            g.recursiveUNLSearch(parsed.path.split("-->"), c)
            return
        if not parsed.path and parsed.fragment:
            g.recursiveUNLSearch(parsed.fragment.split("-->"), c)
            return

        # leo aware path
        leo_path = os.path.expanduser(leo_path)
        leo_path = g.os_path_expandExpression(leo_path, c=c)
        if p and not os.path.isabs(leo_path):
            leo_path = os.path.normpath(
                os.path.join(c.getNodePath(p), leo_path))

        # .leo file
        if leo_path.lower().endswith('.leo') and os.path.exists(leo_path):
            # 2011/07/28: Immediately end editing, so that
            # typing in the new window works properly.
            c.endEditing()
            c.redraw_now()
            c2 = g.openWithFileName(leo_path,old_c=c)
            
            # with UNL after path
            if c2 and parsed.fragment:
                g.recursiveUNLSearch(parsed.fragment.split("-->"),c2)
            if c2:
                c2.bringToFront()
                return
                
    if parsed.scheme in ('', 'file'):
        if os.path.exists(leo_path):
            g.os_startfile(leo_path)
            return
        if parsed.scheme == 'file':
            g.es("File '%s' does not exist"%leo_path)
            return
        
    import webbrowser
    # Mozilla throws a weird exception, then opens the file!
    try: webbrowser.open(url)
    except: pass
    
except:
    g.es("exception opening",url)
    g.es_exception()
.. @+node:ekr.20111026075003.16481: *4* Support ~/.leo_config.py
@language rest

1. Imo, it is time to consider adding a typical "startup" file to Leo,
~/leo_config.py, similar to ~/.emacs or ipython_config.py.  This will
make Leo "thicker", that is more professional/standard.

IPython adds lots of bells and whistles to configuration.  Leo
emulates most of them, but .leo_config.py would be a good addition.
Think of .leo_config.py as a lightweight plugin.

leo_config.py should execute after settings have been parsed, but
before plugins have been loaded.  If desired, leo_config.py may
register "start2" event handlers, which execute after all plugins have
been loaded, just before starting the main Qt event loop.

2. Leo commands form a good framework for other solutions to Qt
stylesheet issues.  Consider the following commands::

- qt-stylesheet-set-global-stylesheet
- qt-stylesheet-append-to-global-stylesheet
- qt-stylesheet-set-widget-stylesheet
- qt-stylesheet-append-to-widget-stylesheet

@language python
.. @+node:ekr.20111021105253.9478: *3* Most important
.. @+node:ekr.20111010122531.15568: *4* * @render-rest, @render-html trees
@language rest

The free_layout and viewrendered plugins are a huge step forward.  But
the lighter/heavier distinction suggests a new way to use them.

Suppose Leo supports @render-rest or @render-html.

This means that all nodes in the tree will have the body pane become a
rendering pane for rST or html.

Imagine LeoDocs completely rendered at all times.

Of course, for specific purposes, say in Leo's scripting chapter, we
might want to override these rendering directives (which should be
allowed in headlines too) with @no-render.

The point is that having *both* the original text *and* the rendered
text be visible is often too heavy: the user usually does not want to
know about the sources: the rendering is good enough.

I suppose for sophisticated users, something like show/hide-body pane
would be good commands to have, but that doesn't matter: those
commands to not increase the burden on the user while she is reading
the (rendered) docs.
.. @+node:ekr.20111019104425.15868: *4* * Render to tex, pdf, rst, etc.
.. @+node:ekr.20111003232155.6988: *4* * Use c.db for marks & expansion bits
This would allow us to eliminate @bool put_expansion_bits_in_leo_files.
.. @+node:ekr.20110921094450.6957: *4* Restart vim project
This requires commands that can be composed.
.. @+node:ekr.20111027103125.16538: *5* * Look at vim video
http://video.google.com/videoplay?docid=8810772602188234059
.. @+node:ekr.20111021035504.9467: *4* Play with PyQt Qtest framework
http://groups.google.com/group/leo-editor/browse_thread/thread/b851e7d9855a57c2

http://www.voom.net/pyqt-qtest-example
.. @+node:ekr.20111027143736.16558: *4* Work-flow improvements
@nocolor-node

Considering leo.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/e3ddbe650fc9525b/290e97c593ee950a

> > I think there's a way to search across Leo files: quicksearch multiple
> > files ... ?

> http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab5...

Leo has to have this :-)  It's on my list.  It would be a great way to
find @button nodes.

Furthermore, global searches for attributes in docstrings have
immediate uses.

On the urgent to-do list: drive all aspects of the Nav pane using
keystrokes.

I just reviewed @bookmarks--it's perfect for leo.leo.  The following
would replace all.bat:

- @bookmarks
  - leoPy.leo (url in body)
  - leoPlugins.leo
  - leoSettings.leo
  - myLeoSettings.leo
  - leoDocs.leo
  - leoDist.leo
  - scripts.leo

This way could be said to be much better than all.bat: nothing gets
loaded until needed.  Therefore, even more files could be added.

Imo, URL's in bookmark trees should support {{expression}} notations.

For example, I want the following to work in the body text of a node
in an @bookmarks tree::

file://{{g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo').replace('\\','/')}}

Not bad, eh?  Or maybe the URL logic should do the replace('\\','/')
automatically...

Got to go.  We are nearing a tipping point in Leo's workflow... 
.. @+node:ekr.20111019104425.15861: *3* Scripts
.. @+node:ekr.20111019080436.15849: *4*  Doc scripts: 2
.. @+node:ekr.20111018104244.15932: *5* Write create-command-docs script
@language rest

This will create large docs for individual commands from docstrings.

Base this on print-cmd-docstrings.
.. @+node:ekr.20111018104244.15933: *5* Write create-plugins-doc script (Use/adapt plugin_catalog.py)
@language rest

Leo must have a create-plugins-doc script that does the same for
plugins.  A prototype of this script exists somewhere.  Making it an
@command node will make it much more visible. 

Terry wrote plugin_catalog.py.  It is in LeoDocs.leo)
.. @+node:ekr.20110917104720.9418: *4* convert-names-to-pep8
.. @+node:ekr.20110918204546.6809: *4* convert-to-class
.. @+node:ekr.20111009230326.7036: *3* Important/Later
.. @+node:ekr.20111019104425.15863: *4* Use pygments for syntax coloring?
.. @+node:ekr.20111009080647.15614: *5* pygments test
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
import time

fn = g.os_path_finalize_join(g.app.loadDir,'leoCommands.py')
s = open(fn).read()

# s = 'print "Hello World"'

t1 = time.time()

s2 = highlight(s,PythonLexer(),HtmlFormatter())

t2 = time.time()

print(len(s),len(s2),'%2.2f sec' % (t2-t1))
.. @+node:ekr.20111009080647.15615: *5* pygments install error on pthon26 (python3.2 no problem)
@nocolor-node

c:\apps\pygments>python26 setup.py install

c:\apps\pygments>c:\python26\python.exe setup.py install
running install
running bdist_egg
running egg_info
creating Pygments.egg-info
writing Pygments.egg-info\PKG-INFO
writing top-level names to Pygments.egg-info\top_level.txt
writing dependency_links to Pygments.egg-info\dependency_links.txt
writing entry points to Pygments.egg-info\entry_points.txt
writing manifest file 'Pygments.egg-info\SOURCES.txt'
reading manifest file 'Pygments.egg-info\SOURCES.txt'
reading manifest template 'MANIFEST.in'
writing manifest file 'Pygments.egg-info\SOURCES.txt'
installing library code to build\bdist.win32\egg
running install_lib
running build_py
creating build\bdist.win32
creating build\bdist.win32\egg
creating build\bdist.win32\egg\pygments
copying build\lib\pygments\cmdline.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\console.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\filter.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\filters
copying build\lib\pygments\filters\__init__.py -> build\bdist.win32\egg\pygments\filters
copying build\lib\pygments\formatter.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\bbcode.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\html.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\img.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\latex.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\other.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\rtf.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\svg.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\terminal.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\terminal256.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\_mapping.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\formatters\__init__.py -> build\bdist.win32\egg\pygments\formatters
copying build\lib\pygments\lexer.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\agile.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\asm.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\compiled.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\dotnet.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\functional.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\hdl.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\math.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\other.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\parsers.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\postgres.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\pypylog.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\special.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\templates.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\text.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\web.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_asybuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_clbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_luabuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_mapping.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_phpbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_postgres_builtins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\_vimbuiltins.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\lexers\__init__.py -> build\bdist.win32\egg\pygments\lexers
copying build\lib\pygments\plugin.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\scanner.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\style.py -> build\bdist.win32\egg\pygments
creating build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\autumn.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\borland.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\bw.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\colorful.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\default.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\emacs.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\friendly.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\fruity.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\manni.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\monokai.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\murphy.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\native.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\pastie.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\perldoc.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\tango.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\trac.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\vim.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\vs.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\styles\__init__.py -> build\bdist.win32\egg\pygments\styles
copying build\lib\pygments\token.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\unistring.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\util.py -> build\bdist.win32\egg\pygments
copying build\lib\pygments\__init__.py -> build\bdist.win32\egg\pygments
byte-compiling build\bdist.win32\egg\pygments\cmdline.py to cmdline.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\cmdline.py', 133, 43,
'print("%s not found!" % what, file=sys.stderr)\n'))

byte-compiling build\bdist.win32\egg\pygments\console.py to console.pyc
byte-compiling build\bdist.win32\egg\pygments\filter.py to filter.pyc
byte-compiling build\bdist.win32\egg\pygments\filters\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\formatter.py to formatter.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\bbcode.py to bbcode.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\html.py to html.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\formatters\\html.py', 472, 88, "
       'using current directory as base for the CSS file name', file=sys.stderr)\n"))

byte-compiling build\bdist.win32\egg\pygments\formatters\img.py to img.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\latex.py to latex.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\other.py to other.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\rtf.py to rtf.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\svg.py to svg.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\terminal.py to terminal.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\terminal256.py to terminal256.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\_mapping.py to _mapping.pyc
byte-compiling build\bdist.win32\egg\pygments\formatters\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\lexer.py to lexer.pyc
SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\lexer.py', 40, 30, 'class Lexer(object, metaclass=L
exerMeta):\n'))

byte-compiling build\bdist.win32\egg\pygments\lexers\agile.py to agile.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\asm.py to asm.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\compiled.py to compiled.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\dotnet.py to dotnet.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\functional.py to functional.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\hdl.py to hdl.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\math.py to math.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\other.py to other.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\parsers.py to parsers.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\postgres.py to postgres.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\pypylog.py to pypylog.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\special.py to special.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\templates.py to templates.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\text.py to text.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\web.py to web.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_asybuiltins.py to _asybuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_clbuiltins.py to _clbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_luabuiltins.py to _luabuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_mapping.py to _mapping.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_phpbuiltins.py to _phpbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_postgres_builtins.py to _postgres_builtins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\_vimbuiltins.py to _vimbuiltins.pyc
byte-compiling build\bdist.win32\egg\pygments\lexers\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\plugin.py to plugin.pyc
byte-compiling build\bdist.win32\egg\pygments\scanner.py to scanner.pyc
byte-compiling build\bdist.win32\egg\pygments\style.py to style.pyc

SyntaxError: ('invalid syntax', ('build\\bdist.win32\\egg\\pygments\\style.py', 107, 30,

'class Style(object, metaclass=StyleMeta):\n'))

byte-compiling build\bdist.win32\egg\pygments\styles\autumn.py to autumn.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\borland.py to borland.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\bw.py to bw.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\colorful.py to colorful.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\default.py to default.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\emacs.py to emacs.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\friendly.py to friendly.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\fruity.py to fruity.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\manni.py to manni.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\monokai.py to monokai.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\murphy.py to murphy.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\native.py to native.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\pastie.py to pastie.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\perldoc.py to perldoc.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\tango.py to tango.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\trac.py to trac.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\vim.py to vim.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\vs.py to vs.pyc
byte-compiling build\bdist.win32\egg\pygments\styles\__init__.py to __init__.pyc
byte-compiling build\bdist.win32\egg\pygments\token.py to token.pyc
byte-compiling build\bdist.win32\egg\pygments\unistring.py to unistring.pyc
byte-compiling build\bdist.win32\egg\pygments\util.py to util.pyc
byte-compiling build\bdist.win32\egg\pygments\__init__.py to __init__.pyc
creating build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\PKG-INFO -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\SOURCES.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\dependency_links.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\entry_points.txt -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\not-zip-safe -> build\bdist.win32\egg\EGG-INFO
copying Pygments.egg-info\top_level.txt -> build\bdist.win32\egg\EGG-INFO
creating dist
creating 'dist\Pygments-1.4dev_20111009-py2.6.egg' and adding 'build\bdist.win32\egg' to it
removing 'build\bdist.win32\egg' (and everything under it)
Processing Pygments-1.4dev_20111009-py2.6.egg
creating c:\python26\lib\site-packages\Pygments-1.4dev_20111009-py2.6.egg
Extracting Pygments-1.4dev_20111009-py2.6.egg to c:\python26\lib\site-packages

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\cmdlin
e.py', 133, 43, '        print("%s not found!" % what, file=sys.stderr)\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\lexer.
py', 40, 30, 'class Lexer(object, metaclass=LexerMeta):\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\style.
py', 107, 30, 'class Style(object, metaclass=StyleMeta):\n'))

SyntaxError: ('invalid syntax', ('c:\\python26\\lib\\site-packages\\Pygments-1.4dev_20111009-py2.6.egg\\pygments\\format
ters\\html.py', 472, 88, "                          'using current directory as base for the CSS file name', file=sys.st
derr)\n"))

Removing pygments 1.1.1 from easy-install.pth file
Adding Pygments 1.4dev-20111009 to easy-install.pth file
Installing pygmentize-script.py script to c:\python26\Scripts
Installing pygmentize.exe script to c:\python26\Scripts
Installing pygmentize.exe.manifest script to c:\python26\Scripts

Installed c:\python26\lib\site-packages\pygments-1.4dev_20111009-py2.6.egg
Processing dependencies for Pygments==1.4dev-20111009
Finished processing dependencies for Pygments==1.4dev-20111009

c:\apps\pygments>
.. @+node:ekr.20110930075237.15472: *4* * Improving Leo: think inside the box
@language rest,
.. @+node:ekr.20111019104425.15886: *5* Windows
Terry's work is an enabler.  Just as Blender supports many kinds of
windows, so too should Leo.  Up until now, the outline, body and log
panes have been the only "official" panes.  The rendering pane soon
will be fully official.
.. @+node:ekr.20111019104425.15890: *5* Bridges
This could be an important "new" direction.  True, there are already
bridges for vim, emacs, ipython and docutils, but I think more can be
done.

The first thought is to improve Leo's inter-process communication
capabilities.  I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in
order to resize vim, say, to it automatically tracks Leo's body pane
(or any other pane).
.. @+node:ekr.20111019104425.15887: *5* Host the PyQt demo inside Leo
.. @+node:ekr.20111019104425.15888: *5* Support an openGL window in Leo
.. @+node:ekr.20111019104425.15891: *5* Code tools
Analysis, checking, refactoring and other code-level tools are a
natural for Leo.  When the new-lint project is mature, it could be
folded into Leo.

.. @+node:ekr.20110930075237.15473: *5* Kent's suggestions
@nocolor-node


- 
.. @+node:ekr.20111019104425.15892: *6* Buttons
Enhance the button machinery to allow mixed case, spaces, colors.
Provide cascading rclick capability: rclick on an rclick list ...
.. @+node:ekr.20111019104425.15893: *6* Templating
Solid, simple implementation of one of the standard template engines
providing intuitive template nodes, variable definitions, and rendering options.

.. @+node:ekr.20111019104425.15894: *6* Wizards
Leverage the template capability to offer form-based content creation:
- create a plugin
- generate a test node
- generate a wizard :-]
.. @+node:ekr.20111019104425.15895: *6* LeoFS
- create a Leo implementation of pyfilesystem
http://packages.python.org/fs/implementersguide.html

.. @+node:ekr.20111019104425.15896: *6* Enhansed node attributes: ctime, atime, mtime
.. @+node:ekr.20111019104425.15897: *6* Persistent tab status
Resume editing with same tabs open when using tabbed gui.

.. @+node:ekr.20111019104425.15898: *6* Persistent pane layout
.. @+node:ekr.20110930075237.15474: *5* Matt Wilkie
@nocolor-node

As for user interface, I'd love to see myLeoSettings with a checkbox
interface and filter bar at the top, and a feature to "merge or reset
from LeoSettings".
... or maybe something like Firefox's "about:config" would be better
suited (and probably faster to build).
.. @+node:ekr.20111027103125.16546: *4* What's next
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/19bfe6daf2b324/c50a750606d64f77

Fossil (SCCS) and Leo.

> I think that the interaction of Fossil + Leo could
> solve the idea of having external files in a single "Leo document" that
> would be really a fossil sqlite repository with all the external files in
> it, but syncronizable with the outside world. This kind of instantiated
> image of files in a moment of time in Fossil + Leo, would be like the
> instantiated image of objects in a moment of time of Smalltalk.
.. @+node:ekr.20111014134653.15672: *4* Search across multiple Leo files
http://groups.google.com/group/leo-editor/browse_thread/thread/cf5ab54f29a6c128
.. @+node:ekr.20110929074744.15449: *4* generalize show/hide/select gui elements commands
@nocolor-node

tab-cycle-next makes the following not so important

There is a relationship here with mouseless
programming.  It would seem that all visual elements, especially those
that may exist in multiple versions, must have a name or other
description suitable for generalized commands.

The user might want multiple rendering panes, especially if
one or more are locked.  Without a description, there is no way to
specify exactly what show/hide-rendering pane does.

I haven't forgotten the autocompleter docs.  I'll get to them next.
It looks like autocompletion would be the way to generalize the not-
very-effect commands that switch focus from one ui element to
another.  A related benefit is one generalized command might be more
convenient to use than the present flavors of (buggy) cycle-focus
commands.

In short, contemplating generalized windows leads us to generalized
select/delete/show/hide commands, based on autocompletion, that work
on various ui elements.  This looks like the next project. 
.. @+node:ekr.20110621085435.6532: *4* Request: have equal-sized-panes resize vr pane
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/583bc0a31a6c7979

I noticed that when the renderpane is active it is not affected by the
Window>Equal Sized Panes command. Only the Outline and Body Panes are affected -
just as described in
http://webpages.charter.net/edreamleo/outlines.html#resizing-panes. However from
the user perspective the current behaviour appears as though the command is only
partially successful. Since there are specific commands to contract/expand the
log pane, shouldn't the log and render panes also be affected by the
Window>Equal Sized Panes command?


I suppose so.  I would prefer to wait for Terry to finish his
pane-generalization code before dealing with this.
.. @+node:ekr.20111018104244.15928: *4* Improve Find panel
@nocolor-node

- All open files.
- Show all results as in quicksearch.
.. @+node:ekr.20111017132257.15883: *4* Possible to use IPython completion?
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/014fe61ff9480b2b

I don't know if this is relevant or not, but the IPython autocompletion
capability is awesome.

If I'm investigating code I tend to do the following.

list the modules in a package:
In [1]: from fs import <tab>

this lists the modules, in a package so I pick one
In [1]: from fs import osfs
<the osfs entry is tab-completable>

now I can check the usage of fs.osfs
In [2]: osfs? <enter>

or the source:
In [2]: osfs?? <enter>

or the contents of the module
In [2]: osfs. <tab>

I can instantiate a class:
In [3]: myfs = osfs.OSFS('/')

and examine the ivars and methods:
In [4]: myfs. <tab>

It is such an efficient way to learn and remember the details of code.

I know a bunch of work was done on Leo/IPython integration, don't
know the current status, my wish of synchronized IPython and Leo
may well be one of the many granted wishes I have forgotten about.

I certainly think IPython autocompletion is the gold standard. 
.. @+node:ekr.20110929074744.15499: *4* Allow more panes to be part of the free_layout "action" buttons
.. @+node:ekr.20111009230326.7037: *4* Leo-to-json script for IPython?
.. @+node:ekr.20110527084258.18378: *5* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *6* Notes
.. @+node:ekr.20110609042343.16548: *7* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *7* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *7* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *7* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *6* Code related to uA's
.. @+node:ekr.20040701065235.2: *7* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *7* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *7* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *7* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20120205022040.15412: *4* Refactor the key code (not urgent)
@nocolor-node
    
* Define k factory methods:
    
    k.makeKeyStroke(user_setting_string)
    k.makeKeyStrokeFromData(data)
    k.makeShortcutInfo(...)

* Refactor the Qt input code so it calls k.makeKeyStrokeFromData(data).
  This will require untangling the input code from event handling code.
.. @+node:ekr.20110605121601.18847: *5* create_key_event (leoGui)
def create_key_event (self,c,char,stroke,w,x=None,y=None,x_root=None,y_root=None):
    
    # Do not call strokeFromSetting here!
    # For example, this would wrongly convert Ctrl-C to Ctrl-c,
    # in effect, converting a user binding from Ctrl-Shift-C to Ctrl-C.

    return leoKeyEvent(c,char,stroke,w,x,y,x_root,y_root)
.. @+node:ekr.20110605121601.18537: *5* class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
.. @+node:ekr.20110605121601.18538: *6* << about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys
for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
.. @+node:ekr.20110605121601.18539: *6*  ctor (leoQtEventFilter)
def __init__(self,c,w,tag=''):

    # g.trace('leoQtEventFilter',tag,w)

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Debugging.
    self.keyIsActive = False

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers
    
    # Support for ctagscompleter.py plugin.
    self.ctagscompleter_active = False
    self.ctagscompleter_onKey = None
.. @+node:ekr.20110605121601.18540: *6* eventFilter
def eventFilter(self, obj, event):

    trace = (False or g.trace_masterKeyHandler) and not g.unitTesting
    verbose = True
    traceEvent = False # True: call self.traceEvent.
    traceKey = (True or g.trace_masterKeyHandler)
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    # Hack: QLineEdit generates ev.KeyRelease only on Windows,Ubuntu
    lineEditKeyKinds = [ev.KeyPress,ev.KeyRelease]

    # Important:
    # QLineEdit: ignore all key events except keyRelease events.
    # QTextEdit: ignore all key events except keyPress events.
    if eventType in lineEditKeyKinds:
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        # g.trace('instate',k.inState(),'tkKey',tkKey,'ignore',ignore,'len(aList)',len(aList))
        if ignore:
            override = False
        # This is extremely bad.
        # At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)
                c.frame.body.onFocusOut(obj)
        if self.tag in ('tree','log'):
            if eventType == ev.FocusIn:
                g.app.gui.add_border(c,obj)
            elif eventType == ev.FocusOut:
                g.app.gui.remove_border(c,obj)

    if self.keyIsActive:
        shortcut = self.toStroke(tkKey,ch) # ch is unused.

        if override:
            # Essentially *all* keys get passed to masterKeyHandler.
            if trace and traceKey:
                g.trace('ignore',ignore,'bound',repr(shortcut),repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            event = self.create_key_event(event,c,w,ch,tkKey,shortcut)
            ret = k.masterKeyHandler(event)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,shortcut)
        
        if trace and traceEvent:
            # Trace key events.
            self.traceEvent(obj,event,tkKey,override)

    elif trace and traceEvent:
        # Trace non-key events.
        self.traceEvent(obj,event,tkKey,override)

    return override
.. @+node:ekr.20110605195119.16937: *6* create_key_event (leoQtEventFilter)
def create_key_event (self,event,c,w,ch,tkKey,shortcut):

    trace = True and not g.unitTesting ; verbose = False
    
    if trace and verbose: g.trace('ch: %s, tkKey: %s, shortcut: %s' % (
        repr(ch),repr(tkKey),repr(shortcut)))
        
    # Last-minute adjustments...
    if shortcut == 'Return':
        ch = '\n' # Somehow Qt wants to return '\r'.
    elif shortcut == 'Escape':
        ch = 'Escape'

    # Switch the Shift modifier to handle the cap-lock key.
    if len(ch) == 1 and len(shortcut) == 1 and ch.isalpha() and shortcut.isalpha():
        if ch != shortcut:
            if trace and verbose: g.trace('caps-lock')
            shortcut = ch

    # Patch provided by resi147.
    # See the thread: special characters in MacOSX, like '@'.
    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '€',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            shortcut = darwinmap[tkKey]
            
    char = ch
    # Auxiliary info.
    x      = hasattr(event,'x') and event.x or 0
    y      = hasattr(event,'y') and event.y or 0
    # Support for fastGotoNode plugin
    x_root = hasattr(event,'x_root') and event.x_root or 0
    y_root = hasattr(event,'y_root') and event.y_root or 0
    
    if trace and verbose: g.trace('ch: %s, shortcut: %s printable: %s' % (
        repr(ch),repr(shortcut),ch in string.printable))
                
    return leoGui.leoKeyEvent(c,char,shortcut,w,x,y,x_root,y_root)
.. @+node:ekr.20120204061120.10088: *6* Key construction...
.. @+node:ekr.20110605121601.18543: *7* toTkKey & helpers (must not change!)
def toTkKey (self,event):
    
    '''Return tkKey,ch,ignore:
        
    tkKey: the Tk spelling of the event used to look up
           bindings in k.masterGuiBindingsDict.
           **This must not ever change!**
           
    ch:    the insertable key, or ''.
    
    ignore: True if the key should be ignored.
            This is **not** the same as 'not ch'.
    '''

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
.. @+node:ekr.20110605121601.18546: *8* tkKey & helper
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    ch1 = ch # For tracing.
    use_shift = (
        'Home','End','Tab',
        'Up','Down','Left','Right',
        'Next','Prior', # 2010/01/10: Allow Shift-PageUp and Shift-PageDn.
        # 2011/05/17: Fix bug 681797.
        # There is nothing 'dubious' about these provided that they are bound.
        # If they are not bound, then weird characters will be inserted.
        'Delete','Ins','Backspace',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    )

    # Convert '&' to 'ampersand', etc.
    # *Do* allow shift-bracketleft, etc.
    ch2 = self.char2tkName(ch or toString)
    if ch2: ch = ch2 
    if not ch: ch = ''

    if 'Shift' in mods:
        if trace: g.trace(repr(ch))
        if len(ch) == 1 and ch.isalpha():
            mods.remove('Shift')
            ch = ch.upper()
        elif len(ch) > 1 and ch not in use_shift:
            # Experimental!
            mods.remove('Shift')
        # 2009/12/19: Speculative.
        # if ch in ('parenright','parenleft','braceright','braceleft'):
            # mods.remove('Shift')
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    # *Do* allow bare mod keys, so they won't be passed on.
    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    if trace: g.trace(
        'text: %s toString: %s ch1: %s ch: %s' % (
        repr(text),repr(toString),repr(ch1),repr(ch)))

    ignore = not ch # Essential
    ch = text or toString
    return tkKey,ch,ignore
.. @+node:ekr.20110605121601.18547: *9* char2tkName
char2tkNameDict = {
    # Part 1: same as g.app.guiBindNamesDict
    "&" : "ampersand",
    "^" : "asciicircum",
    "~" : "asciitilde",
    "*" : "asterisk",
    "@" : "at",
    "\\": "backslash",
    "|" : "bar",
    "{" : "braceleft",
    "}" : "braceright",
    "[" : "bracketleft",
    "]" : "bracketright",
    ":" : "colon",  
    "," : "comma",
    "$" : "dollar",
    "=" : "equal",
    "!" : "exclam",
    ">" : "greater",
    "<" : "less",
    "-" : "minus",
    "#" : "numbersign",
    '"' : "quotedbl",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright", 
    "%" : "percent",
    "." : "period",     
    "+" : "plus",
    "?" : "question",
    "`" : "quoteleft",
    ";" : "semicolon",
    "/" : "slash",
    " " : "space",      
    "_" : "underscore",
    # Part 2: special Qt translations.
    'Backspace':'BackSpace',
    'Backtab':  'Tab', # The shift mod will convert to 'Shift+Tab',
    'Esc':      'Escape',
    'Del':      'Delete',
    'Ins':      'Insert', # was 'Return',
    # Comment these out to pass the key to the QTextWidget.
    # Use these to enable Leo's page-up/down commands.
    'PgDown':    'Next',
    'PgUp':      'Prior',
    # New entries.  These simplify code.
    'Down':'Down','Left':'Left','Right':'Right','Up':'Up',
    'End':'End',
    'F1':'F1','F2':'F2','F3':'F3','F4':'F4','F5':'F5',
    'F6':'F6','F7':'F7','F8':'F8','F9':'F9',
    'F10':'F10','F11':'F11','F12':'F12',
    'Home':'Home',
    # 'Insert':'Insert',
    'Return':'Return',
    'Tab':'Tab',
    # 'Tab':'\t', # A hack for QLineEdit.
    # Unused: Break, Caps_Lock,Linefeed,Num_lock
}

# Called only by tkKey.

def char2tkName (self,ch):
    val = self.char2tkNameDict.get(ch)
    # g.trace(repr(ch),repr(val))
    return val
.. @+node:ekr.20120204061120.10087: *7* Common key construction helpers
.. @+node:ekr.20110605121601.18541: *8* isSpecialOverride
def isSpecialOverride (self,tkKey,ch):

    '''Return True if tkKey is a special Tk key name.
    '''

    return tkKey or ch in self.flashers
.. @+node:ekr.20110605121601.18542: *8* toStroke (leoQtEventFilter)
def toStroke (self,tkKey,ch):  # ch is unused
    
    '''Convert the official tkKey name to a stroke.'''

    trace = False and not g.unitTesting
    k = self.c.k ; s = tkKey

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
.. @+node:ekr.20110605121601.18544: *8* qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.

    Modifiers are handled separately.
    
    Return keynum,text,toString,ch
    
    keynum: event.key()
    ch:     g.u(chr(keynum)) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    '''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.

    qt = QtCore.Qt
    d = {
        qt.Key_Shift:   'Key_Shift',
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta:	'Key_Meta',     # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Alt:	    'Key_Alt',	 
        qt.Key_AltGr:	'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
    }

    if d.get(keynum):
        toString = d.get(keynum)
    else:
        toString = QtGui.QKeySequence(keynum).toString()

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = g.u(ch1)
    except UnicodeError:
        ch = ch1

    text     = g.u(text)
    toString = g.u(toString)

    if trace and self.keyIsActive:
        mods = '+'.join(self.qtMods(event))
        g.trace(
            'keynum %7x ch %3s toString %s %s' % (
            keynum,repr(ch),mods,repr(toString)))

    return keynum,text,toString,ch
.. @+node:ekr.20120204061120.10084: *8* qtMods
def qtMods (self,event):

    '''Return the text version of the modifiers of the key event.'''

    modifiers = event.modifiers()

    # The order of this table must match the order created by k.strokeFromSetting.
    # When g.new_keys is True, k.strokeFromSetting will canonicalize the setting.

    qt = QtCore.Qt
    
    if sys.platform.startswith('darwin'):
        # Yet another MacOS hack:
        table = (
            (qt.AltModifier,     'Alt'), # For Apple keyboard.
            (qt.MetaModifier,    'Alt'), # For Microsoft keyboard.
            (qt.ControlModifier, 'Control'),
            # No way to generate Meta.
            (qt.ShiftModifier,   'Shift'),
        )
        
    else:
        table = (
            (qt.AltModifier,     'Alt'),
            (qt.ControlModifier, 'Control'),
            (qt.MetaModifier,    'Meta'),
            (qt.ShiftModifier,   'Shift'),
        )

    mods = [b for a,b in table if (modifiers & a)]
    return mods
.. @+node:ekr.20110605121601.18548: *6* traceEvent
def traceEvent (self,obj,event,tkKey,override):

    if g.unitTesting: return
    
    traceFocus = False
    traceKey   = True
    traceLayout = False
    traceMouse = False
    
    c,e = self.c,QtCore.QEvent
    eventType = event.type()
    
    show = []
    
    ignore = [
        e.MetaCall, # 43
        e.Timer, # 1
        e.ToolTip, # 110
    ]
    
    focus_events = (
        (e.Enter,'enter'),
        (e.Leave,'leave'),
        (e.FocusIn,'focus-in'),
        (e.FocusOut,'focus-out'),
        (e.Hide,'hide'), # 18
        (e.HideToParent, 'hide-to-parent'), # 27
        (e.HoverEnter, 'hover-enter'), # 127
        (e.HoverLeave,'hover-leave'), # 128
        (e.HoverMove,'hover-move'), # 129
        (e.Show,'show'), # 17
        (e.ShowToParent,'show-to-parent'), # 26
        (e.WindowActivate,'window-activate'), # 24
        (e.WindowBlocked,'window-blocked'), # 103
        (e.WindowUnblocked,'window-unblocked'), # 104
        (e.WindowDeactivate,'window-deactivate'), # 25
    )
    key_events = (
        (e.KeyPress,'key-press'),
        (e.KeyRelease,'key-release'),
        (e.ShortcutOverride,'shortcut-override'),
    )
    layout_events = (
        (e.ChildPolished,'child-polished'), # 69
        #(e.CloseSoftwareInputPanel,'close-sip'), # 200
            # Event does not exist on MacOS.
        (e.ChildAdded,'child-added'), # 68
        (e.DynamicPropertyChange,'dynamic-property-change'), # 170
        (e.FontChange,'font-change'),# 97
        (e.LayoutRequest,'layout-request'),
        (e.Move,'move'), # 13 widget's position changed.
        (e.PaletteChange,'palette-change'),# 39
        (e.ParentChange,'parent-change'), # 21
        (e.Paint,'paint'), # 12
        (e.Polish,'polish'), # 75
        (e.PolishRequest,'polish-request'), # 74
        # (e.RequestSoftwareInputPanel,'sip'), # 199
            # Event does not exist on MacOS.
        (e.Resize,'resize'), # 14
        (e.StyleChange,'style-change'), # 100
        (e.ZOrderChange,'z-order-change'), # 126
    )
    mouse_events = (
        (e.MouseMove,'mouse-move'), # 155
        (e.MouseButtonPress,'mouse-press'), # 2
        (e.MouseButtonRelease,'mouse-release'), # 3
        (e.Wheel,'mouse-wheel'), # 31
    )
    
    option_table = (
        (traceFocus,focus_events),
        (traceKey,key_events),
        (traceLayout,layout_events),
        (traceMouse,mouse_events),
    )
    
    for option,table in option_table:
        if option:
            show.extend(table)
        else:
            for n,tag in table:
                ignore.append(n)

    for val,kind in show:
        if eventType == val:
            g.trace(
                '%5s %18s in-state: %5s key: %s override: %s: obj: %s' % (
                self.tag,kind,repr(c.k and c.k.inState()),tkKey,override,obj))
            return

    if eventType not in ignore:
        g.trace('%3s:%s obj:%s' % (eventType,'unknown',obj))
.. @+node:ekr.20110605195119.16937: *5* create_key_event (leoQtEventFilter)
def create_key_event (self,event,c,w,ch,tkKey,shortcut):

    trace = True and not g.unitTesting ; verbose = False
    
    if trace and verbose: g.trace('ch: %s, tkKey: %s, shortcut: %s' % (
        repr(ch),repr(tkKey),repr(shortcut)))
        
    # Last-minute adjustments...
    if shortcut == 'Return':
        ch = '\n' # Somehow Qt wants to return '\r'.
    elif shortcut == 'Escape':
        ch = 'Escape'

    # Switch the Shift modifier to handle the cap-lock key.
    if len(ch) == 1 and len(shortcut) == 1 and ch.isalpha() and shortcut.isalpha():
        if ch != shortcut:
            if trace and verbose: g.trace('caps-lock')
            shortcut = ch

    # Patch provided by resi147.
    # See the thread: special characters in MacOSX, like '@'.
    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '€',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            shortcut = darwinmap[tkKey]
            
    char = ch
    # Auxiliary info.
    x      = hasattr(event,'x') and event.x or 0
    y      = hasattr(event,'y') and event.y or 0
    # Support for fastGotoNode plugin
    x_root = hasattr(event,'x_root') and event.x_root or 0
    y_root = hasattr(event,'y_root') and event.y_root or 0
    
    if trace and verbose: g.trace('ch: %s, shortcut: %s printable: %s' % (
        repr(ch),repr(shortcut),ch in string.printable))
                
    return leoGui.leoKeyEvent(c,char,shortcut,w,x,y,x_root,y_root)
.. @+node:ekr.20070228160107: *5* class leoKeyEvent (leoGui.py)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''
    
    @others

    def __repr__ (self):

        return 'leoKeyEvent: stroke: %s, char: %s, w: %s' % (
            repr(self.stroke),repr(self.char),repr(self.w))
            
    def type(self):
        return 'leoKeyEvent'
.. @+node:ekr.20110605121601.18846: *6* ctor (leoKeyEvent)
def __init__ (self,c,char,shortcut,w,x,y,x_root,y_root):
    
    trace = False and not g.unitTesting
    k = c.k
    
    if g.isStroke(shortcut):
        g.trace('***** (leoKeyEvent) oops: already a stroke',shortcut,g.callers())
        stroke = shortcut
    else:
        stroke = g.KeyStroke(shortcut) if shortcut else None

    assert g.isStrokeOrNone(stroke),'(leoKeyEvent) %s %s' % (
        repr(stroke),g.callers())
        
    if trace: g.trace('(leoKeyEvent) stroke',stroke)
    
    self.c = c
    self.char = char or ''
    self.stroke = stroke
    self.w = self.widget = w
    
    # Optional ivars
    self.x = x
    self.y = y

    # Support for fastGotoNode plugin
    self.x_root = x_root
    self.y_root = y_root
.. @+node:ekr.20111018220642.15862: *3* Plugins
.. @+node:ekr.20111017132257.15882: *4* Study import_xml plugin
@language rest

http://groups.google.com/group/leo-editor/browse_thread/thread/b5c2982778a2df53

Provides commands (Alt-x) for importing and exporting XML from a Leo
outline. These commands are to XML what ``@auto-rst`` is to
reStructuredText.

``xml2leo`` imports an .xml file into the node following the currently
selected node.  ``leo2xml`` exports the current subtree to an .xml file
the user selects.

``xml_validate``, if executed on the top node in the
Leo xml tree, reports any errors in XML generation or DTD validation,
based on the DTD referenced from the XML itself.  If there's no DTD
it reports that as an error.

``leo2xml2leo`` takes the selected Leo subtree representing an XML file,
converts it to XML internally, and then creates a new Leo subtree from
that XML after the original, with 'NEW ' at the start of the top node's
name.  This updates all the headlines, so that the convenience only
previews (see below) are updated.  The original can be deleted if the
new subtree seems correct.

Conventions
===========

This is a valid XML file::

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE dml SYSTEM "dml.dtd">
    <?xml-stylesheet href="common.css"?>
    <dml xmlns='http://example.com/' xmlns:other='http://other.com/'/>
      <block type='example'>Here's <other:b>some</other:b> text</block>
    </dml>
    <!-- This is the last line -->

Note the processing instruction (xml-stylesheet), the DTD (DOCTYPE),
the trailing comment (after the closing tag), and the pernicious
mixed content (three separate pieces of text in the ``<block/>`` element).
These commands attempt to deal with all of this.

 - A top level Leo node is created to hold these top level parts.  Its
   headline is the basename of the file.
 - The xml declaration is placed in the body of
   this top level Leo node
 - Below that, in the same body text, appears a simple namespace map::

     http://example.com/
     other: http://other.com/
     ...

   i.e. the default namespace first, and then any prefixed name spaces.
 - Below that, in the same body text, appears the ``DOCTYPE`` declaration
 - Children are added to this top level Leo node to represent the
   top level elements in the xml file.  Headlines have the following
   meanings:

       - ``? pi-target some="other" __CHK`` - i.e. questionmark,
         space, name of processing instruction target, start of processing
         instruction content.  Only the questionmark, which indicates
         the processing instruction, and the first word, which indicates
         the processing instruction target, matter.  The remainder is just
         a convenience preview of the processing instruction content, which
         is the Leo node's body text.

       - ``# This is *really* imp`` - i.e. hash,
         space, start of comment content.  Only the hash, which indicates
         the comment, matters.  The remainder is just
         a convenience preview of the comment content, which
         is the Leo node's body text.

       - ``tagname name_attribute start of element text`` - i.e. the name
         of an element followed by a convenience preview of the element's
         text content.  If the element has a ``name`` attribute that's
         included at the start of the text preview.  Only the first word
         matters, it's the name of the element.

 - Element's text is placed in the Leo node's body.  If the element has
   tailing text (the ``" text"`` tailing the ``<other:b/>`` element
   in the above example), that occurs in the Leo node's body separated
   by the `tailing text sentinel`::

       @________________________________TAIL_TEXT_______________________________

 - Element's attributes are stored in a dict ``p.v.u['_XML']['_edit']``
   on the Leo node. ``'_XML'`` is the uA prefix for these commands, and
   ``'_edit'`` is used by the ``attrib_edit`` plugin to identify
   attributes it should present to the user for editing. The
   ``attrib_edit`` plugin **should be enabled** and its ``v.u mode``
   activated (through its submenu on the Plugins menu). The attribute
   edit panel initially appears as a tab in the log pane, although it
   can be moved around by right clicking on the pane dividers if the
   ``viewrendered`` and ``free_layout`` plugins are enabled. 
.. @+node:ekr.20111004090723.15495: *4* Finish leoOPML plugin
.. @+node:ekr.20111027143736.16557: *4* Study leo_screen
@nocolor-node

Ville mentioned leoremote for driving Leo from the command line.
There's also leoscreen, for driving the command line from Leo,
providing you use screen, which is probably unix/cygwin only.
.. @+node:ekr.20111018220642.15860: *3* Bugs/Minor
.. @+node:ekr.20111014074810.15652: *4* viewrendered should work better when docutils does not exist
.. @+node:ekr.20111008073427.15595: *4* Macro bug: really must have a shortcut for call-last-macro
.. @+node:ekr.20111010062725.15543: *4* ctrl-k twice (second time on blank line) doesn't work
.. @+node:ekr.20111013065147.9424: *3* Code cleanup
.. @+node:ekr.20111012061216.15699: *4* ?use @g.command for all Leo commands?
.. @+node:ekr.20111010093113.15548: *4* Lighten Leo's code base; remove wrapper layers
@nocolor-node

Almost from day one, Leo has defined gui base classes in the core, and
subclasses in gui plugins.

I plan to continue that organization, but I would like to remove some of the
wrapping layers if possible. The present scheme has one or two too many
redirection layers, and they are more of a nuisance than a help.

One idea would be to define **interface classes** that define the desired api's.
Unit tests could test that subclass implements the interface class, without
having to resort to quite as much error-prone machinery as at present.
.. @+node:ekr.20110620065017.14900: *3* Bugs/Can't/Won't fix
.. @+node:ekr.20111011062533.15693: *4* Make headline widgets scrollable, if possible
# It doesn't seem easy.
.. @+node:ekr.20110605121601.18422: *5* editLabelHelper (leoQtTree)
def editLabelHelper (self,item,selectAll=False,selection=None):

    '''Called by nativeTree.editLabel to do
    gui-specific stuff.'''

    trace = False and not g.unitTesting
    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item,0) # A QLineEdit.

    if e:
        s = e.text() ; len_s = len(s)
        if s == 'newHeadline': selectAll=True
        if selection:
            i,j,ins = selection
            start,n = i,abs(i-j)
                # Not right for backward searches.
        elif selectAll: start,n,ins = 0,len_s,len_s
        else:           start,n,ins = len_s,0,len_s
        e.setObjectName('headline')
        e.setSelection(start,n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        wrapper = self.connectEditorWidget(e,item) # Hook up the widget.

    if trace: g.trace(e,wrapper)
    return e,wrapper # 2011/02/11
.. @+node:ekr.20110619173515.14896: *4* Fix bug: wrong modality level on autocompleter
Just noticed the autocompleter pop-up is modal globally, not just for
the Leo windows.  Probably should only block the Leo windows.
.. @+node:ekr.20110620083705.14901: *4* Fix or disable curses gui
leoBridge.py requires the nullGui.
.. @+node:ekr.20110921094450.6956: ** To do: 4.10.1
3. Bridges


.. @+node:ekr.20110921094450.6954: *3* Important
.. @+node:ekr.20110921094450.6955: *4* Windows
Leo should support more new windows.


Terry's plugins have also created nifty new windows.

Here are some other ideas:

A.  Hosting the PyQt demo inside Leo.

B. Making an OpenGl window an official Leo window. This might be the start of a
   prototype for "Blender in a Leo Window".
.. @+node:ekr.20110528034751.18272: *5* Support for tabifying Leo's core panes
Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
.. @+node:ekr.20110525112110.18402: *5* Ideas:
.. @+node:ekr.20101104191857.5820: *6* QWebView makes Leo a presentation tool
http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

.. @+node:ekr.20060227123536: *6* Tiddlywiki and related comments about rendering body text (Mulder)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
.. @+node:ekr.20110921094450.6958: *4* Bridges
There are already bridges for vim, emacs, ipython and docutils, but I think more
can be done.

The first thought is to improve Leo's inter-process communication capabilities.
I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in order to
resize vim, say, to it automatically tracks Leo's body pane (or any other pane).
.. @+node:ekr.20110921094450.6959: *4* Code tools
Analysis, checking, refactoring and other code-level tools are a natural for
Leo. When the new-lint project is mature, it could be folded into Leo.

* Rewrite the beautify-python command using a much simpler tokenizer.

.. @+node:ekr.20110921094450.6960: *4* Documentation tools
Perhaps Leo's documentation could be built primarily from docstrings. In any
event, documentation tools are always needed.
.. @+node:ekr.20110531190516.19365: *3* Maybe
@language rest

.. @+node:ekr.20110611043506.16494: *4*  Ashland sprint items: 3
.. @+node:ekr.20110527084258.18378: *5* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *6* Notes
.. @+node:ekr.20110609042343.16548: *7* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *7* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *7* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *7* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *6* Code related to uA's
.. @+node:ekr.20040701065235.2: *7* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *7* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *7* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *7* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20110528034751.18273: *5* Global search in Nav plugin?
.. @+node:ekr.20110613110911.16421: *5* Read/write files in json format
.. @+node:ekr.20051110155735.1: *4* Improve Spell tab & spell checker
@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
.. @+node:ekr.20090907080624.6081: *5* Spell checker should check headlines
.. @+node:ekr.20101004092958.5914: *4* Write treepad scanner
@ treepad.py is from the treepad website
.. @+node:ekr.20101004092958.5939: *5* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

.. @+node:ekr.20101004092958.5940: *6* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
.. @+node:ekr.20101004092958.5941: *6* class Node
class Node:
    @others
.. @+node:ekr.20101004092958.5942: *7* __init__ (Node/treepad)
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
.. @+node:ekr.20101004092958.5943: *7* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
.. @+node:ekr.20101004092958.5944: *7* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
.. @+node:ekr.20101004092958.5945: *7* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
.. @+node:ekr.20101004092958.5946: *7* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
.. @+node:ekr.20101004092958.5947: *7* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

.. @+node:ekr.20101004092958.5948: *6* class NodeReader
class NodeReader:
    @others
.. @+node:ekr.20101004092958.5949: *7* __init__ (NodeReader)
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
.. @+node:ekr.20101004092958.5950: *7* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
.. @+node:ekr.20101004092958.5951: *7* readstart
def readstart(self):
    self.expect(VERSION)
.. @+node:ekr.20101004092958.5952: *7* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

.. @+node:ekr.20101004092958.5953: *6* class TreeReader
class TreeReader:
    @others
.. @+node:ekr.20101004092958.5954: *7* __init__(TreeReader)
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
.. @+node:ekr.20101004092958.5955: *7* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
.. @+node:ekr.20101004092958.5956: *7* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

.. @+node:ekr.20101004092958.5957: *6* class TreeWriter
class TreeWriter:
    @others
.. @+node:ekr.20101004092958.5958: *7* __init__ (TreeWriter)
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
.. @+node:ekr.20101004092958.5959: *7* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

.. @+node:ekr.20101004092958.5960: *6* class Main
class Main:
    @others
.. @+node:ekr.20101004092958.5961: *7* __init__ (Main)
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
.. @+node:ekr.20101004092958.5962: *7* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

.. @+node:ekr.20110520051220.18203: *4* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
.. @+node:ekr.20071001052501: *4* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
.. @+node:ekr.20080802070659.11: *4* Make node attributes visible, and supported by Leo's core
.. @+node:ekr.20110614123640.6587: *4* Add headline/color functions to Leo's core
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/7e279fe3dedf42be/f00fde4df5b39ded

What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&lt;something&gt;"
namespace?

-------------------

Terry Brown

Sounds like something I may have brought up, long ago.

I was thinking that setting the fore/background color of nodes in the
tree should be a "gui core" function, and that the info should be
stored in uA, and so wanted to know what key should be used in uA for
that.  I think the docs say top level keys starting with "leo_" are
reserved, and probably wanted a ruling on

v.u['leo_fg'] = 'red'

vs

v.u['leo_tree_style']['fg'] = 'red'

etc.

I think the question may be more complicated than just what to call the
key, so you can probably retire the todo item.
.. @+node:ekr.20100112051224.6226: *4* Vim-related: Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20110601105631.19373: *5* Simple vim bindings
.. @+node:ekr.20110601105631.19374: *6* Cursors
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
.. @+node:ekr.20110601105631.19375: *6* Enter insert mode after ctrl-h
.. @+node:ekr.20110601105631.19376: *6* Colorize headline text depending on state
.. @+node:ekr.20110601105631.19377: *6* colon destroys alt-x binding
This project reorganizes makeBindingFromCommandsDict
.. @+node:ekr.20110530063322.18333: *4* scala not colored properly
.. @+node:ekr.20110518103946.18179: *4* Add external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
.. @+node:ekr.20090801103907.6018: *4* Add entries to global dicts for more languages (waiting for requests)
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.

** Only c.getOpenWithExt uses app.language_extension_dict.

I'll wait until I get requests for particular language.
.. @+node:ekr.20110528103005.18323: *5* Found: extension_dict
.. @+node:ekr.20080819075811.13: *6* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
.. @+node:ekr.20090212054250.9: *6* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20031218072017.2824: *6* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
.. @+node:EKR.20040504150046.4: *6* g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', '', '')

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    ('', '<!--', '-->')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
.. @+node:ekr.20080811174246.1: *6* languageForExtension
def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
.. @+node:ekr.20031218072017.368: *5* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "javascript"    : "// /* */", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "<%-- --%>", # EKR: 2011/11/25
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "matlab"        : "%", # EKR: 2011/10/21
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "javascript"    : "js", # EKR: 2011/11/12: For javascript import test.
    "javaserverpage": "jsp", # EKR: 2011/11/25
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "matlab"        : "m", # EKR: 2011/10/21
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "js"    : "javascript", # EKR: 2011/11/12: For javascript import test.
    "jsp"   : "javaserverpage", # EKR: 2011/11/25: For @shadow.
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "m"     : "matlab", # EKR 2011/10/21
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20110528103005.18319: *5* Script to global data structures from in modes/*.py files
import glob
import imp

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)
theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

print('-'*40,len(aList))
known_keys = list(g.app.language_delims_dict.keys())
known_keys.sort()
known = []
computed = {}
for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2.startswith('__'): continue
    # if name2 in known_keys:
        # known.append(name)
        # continue
    try:
        theFile, pathname, description = imp.find_module(name2,[theDir])
        m = imp.load_module(name2, theFile, pathname, description)
    except Exception:
        g.es_exception()
        m = None
    if m:
        aList2 = [m.properties.get(z)
            for z in ('lineComment','commentStart','commentEnd')
                if m.properties.get(z)]
        print('%-20s : "%s",' % (
            '"%s"' % (name2),
            ' '.join(aList2)))
        computed[name2] = ' '.join(aList2)
mismatches = 0
for z in known_keys:
    val = g.app.language_delims_dict.get(z)
    val2 = computed.get(z)
    if not val:
        print('oops: no val',z)
    elif not val2:
        print('oops: no val2',z)
    elif val != val2:
        mismatches += 1
        print('mismatch for %s' % z)
        print(repr(val))
        print(repr(val2))
print('%s total languages' % len(aList))
print('%s new languages' % (len(list(computed.keys())) - len(known_keys)))
print('%s mismatches' % mismatches)
print('%s known language: %s' % (len(known_keys),known_keys))
.. @+node:ekr.20110527225107.18351: *4* Vague
@language rest

**Important**: These items are not scheduled for any release. They will be done
only if there are specific requests for them.

Eventually, all these items will move to the dreaded to-do-later list.
.. @+node:ekr.20110529115328.18238: *5* Emacs related: 5
I'll do these if and and only if somebody asks for them.
.. @+node:ekr.20110529104352.18248: *6* Complete k.universalDispatcher
.. @+node:ekr.20110529104352.18249: *6* Complete number-to-register command
.. @+node:ekr.20031218072017.753: *6* Emacs comint-mode
@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
.. @+node:ekr.20071004120359.2: *6* expand-region-abbrev
See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
.. @+node:ekr.20060628103226.3: *6* Make sure repeat counts work on basic editing commands
.. @-all
.. @-leo
