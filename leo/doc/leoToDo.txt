.. @+leo-ver=5-thin
.. @+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
.. @@language rest # override the default .txt coloring.

.. @+all
.. @+node:ekr.20110520051220.18187: ** To do: 4.9
@language rest
.. @+node:ekr.20110527182640.18358: *3* b3
.. @+node:ekr.20110526083709.18337: *4* * Simplify Key handling
@nocolor-node

To do:
    
- Check that all event.ivar references are guarded.

- Use only a single kev arg to k.masterKeyHandler.
   This simplifies the macro handling.

? Leave BackSpace,LineFeed,Return and Tab alone?

- Improve/rewrite the theory of operation.

Done:
    
- Eliminated event.keysym from Leo's core: test only ev.char and ev.stroke.

- Replaced all dummy (g.bunch) events in Leo's core and in unitTest.leo.
    
- Replaced w.event_generate by g.app.gui.event_generate everywhere.
    
- Rewrote leoGui.leoKeyEvent.

- Created leoGui.create_key_event and leoQtEventFilter.create_key_event.
.. @+node:ekr.20110605195119.16938: *5* Found...
.. @+node:ekr.20110604043410.16735: *6* Use ascii characters instead of Tk names
@nocolor-node

It is not a great idea to try to replace these.
It would have subtle effects everywhere and does not really simplify the core.
.. @+node:ekr.20110604043410.16737: *7* Should not change
.. @+node:ekr.20070123143428: *8* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20110604182206.16765: *8* Found: tkNamesList
.. @+node:ekr.20070123143428: *9* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20070123085931: *9* k.defineSpecialKeys
def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        ">" : "greater",
        "<" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

.. @+node:ekr.20110604182206.16763: *7* Found: ['"]backspace['"]
.. @+node:ekr.20050920084036.27: *8* expandAbbrev
def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event.char
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    if stroke=='BackSpace': return False
    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke,stroke)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event.char
    else:
        ch = event.char
        
    if trace: g.trace('event.char',repr(event.char),'ch',repr(ch),'stroke',repr(stroke))

    if len(ch) != 1 or (len(ch) == 1 and ch.isalpha()):
        # Normal chars other special chars abort abbreviations.
        return False

    # Get the text and insert point.
    s = w.getAllText()
    i = i1 = w.getInsertPoint()

    # Find the word to the left of the insert point.
    j = i ; i -= 1
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i -= 1
    if 0 <= i < len(s) and s[i] == '@':
        i -= 1
    i += 1
    word = s[i:j].strip()
    if trace: g.trace(i,j,repr(word))
    if not word: return False

    # First, look up the word without ch.
    val,tag = self.abbrevs.get(word,(None,None))
    if trace: g.trace(word,val,tag)
    
    if val:
        # Add ch to the result.
        if ch: val = val + ch
    else:
        # Look up the word with ch.
        if ch and not val:
            val,tag = self.abbrevs.get(word+ch,(None,None))
            if trace: g.trace(word+ch,val,tag)
    if val:
        if trace: g.trace('**inserting',repr(val))
        oldSel = j,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return val is not None
.. @+node:ekr.20050920084036.83: *8* viewLossage
def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es('',stroke or d.get(ch) or ch or 'None')
.. @+node:ekr.20090204084607.2: *8* iSearch
def iSearch (self,again=False):

    '''Handle the actual incremental search.'''

    c = self.c ; k = self.k ; p = c.p
    ifinder = self.ifinder
    reverse = not self.forward
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        return self.abortSearch()
    ifinder.c = c ; ifinder.p = p.copy()
    # Get the base ivars from the find tab.
    ifinder.update_ivars()
    # Save
    oldPattern = ifinder.find_text
    oldRegexp  = ifinder.pattern_match
    oldReverse = ifinder.reverse
    oldWord =  ifinder.whole_word
    # Override
    ifinder.pattern_match = self.regexp
    ifinder.reverse = reverse
    ifinder.find_text = pattern
    ifinder.whole_word = False # Word option can't be used!
    # Prepare the search.
    if len(self.stack) <= 1: ifinder.in_headline = False
    w = self.setWidget()
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if again:   ins = g.choose(reverse,i,j+len(pattern))
    else:       ins = g.choose(reverse,j+len(pattern),i)
    ifinder.init_s_ctrl(s,ins)
    # Do the search!
    pos, newpos = ifinder.findNextMatch()
    # Restore.
    ifinder.find_text = oldPattern
    ifinder.pattern_match = oldRegexp
    ifinder.reverse = oldReverse
    ifinder.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None: # success.
        w = ifinder.showSuccess(pos,newpos,showState=False)
        if w: i,j = w.getSelectionRange(sort=False)
        # else: g.trace('****')
        if not again: self.push(c.p,i,j,ifinder.in_headline)
    elif ifinder.wrapping:
        g.es("end of wrapped search")
    else:
        g.es("not found","'%s'" % (pattern))
        event = g.app.gui.create_key_event(c,'\b','BackSpace',w)
        k.updateLabel(event)
.. @+node:ekr.20050920084036.264: *8* iSearchStateHandler
# Called from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k
    stroke = event.stroke
    if trace: g.trace('stroke',repr(stroke))

    # No need to recognize ctrl-z.
    if stroke in ('Escape','Return'):
        self.endSearch()
    elif stroke in self.iSearchStrokes:
        self.iSearch(again=True)
    elif stroke == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif stroke.startswith('Ctrl+') or stroke.startswith('Alt+'):
        # End the search and execute the command.
        self.endSearch()
        k.masterKeyHandler(event,stroke=stroke)
    else:
        if trace: g.trace('event',event)
        k.updateLabel(event)
        self.iSearch()
.. @+node:ekr.20061031131434.11: *8* auto_completer_state_handler
def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    
    ch = char = event and event.char or ''
    stroke = event and event.stroke or ''
    is_plain = k.isPlainKey(stroke)

    if trace: g.trace('state: %s, char: %s, stroke: %s' % (
        state,repr(char),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif char == 'Return':
        self.exit()
    elif char == 'Escape':
        self.exit()
    elif char == 'Tab':
        self.doTabCompletion()
    elif char in ('\b','BackSpace'):
        self.do_backspace()
    elif char == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif char == '?':
        self.info()
    elif char == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = g.choose(self.verbose,'ON','OFF')
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    elif ch == 'Down' and hasattr(self,'onDown'):
        self.onDown()
    elif ch == 'Up' and hasattr(self,'onUp'):
        self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(char)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.es('No completions',color='blue')
                self.exit()
            return
        else:
            if trace: g.trace('ignore non plain key',repr(stroke))
            return 'do-standard-keys'
.. @+node:ekr.20070123143428: *8* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        i = w.logCtrl.getInsertPoint()
        if not stroke:
            stroke = event.stroke # 2010/05/04.
        if stroke.lower() == 'return': stroke = '\n'
        elif stroke.lower() == 'tab': stroke = '\t'
        elif stroke.lower() == 'backspace': stroke = '\b'
        elif stroke.lower() == 'period': stroke = '.'
        w.logCtrl.insert(i,stroke)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.111: *8* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    
    c.check_event(event)
    
    ch = char = event and event.char or ''
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,char)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('Tab','\t'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.112: *9* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
.. @+node:ekr.20061031131434.128: *8* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    
    c.check_event(event)

    char = event and event.char or ''
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.129: *9* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
.. @+node:ekr.20061031131434.152: *8* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20061031131434.168: *8* getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.169: *9* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.170: *9* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.171: *9* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
.. @+node:ekr.20061031131434.172: *9* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
.. @+node:ekr.20061031131434.173: *9* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
.. @+node:ekr.20061031131434.174: *9* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
.. @+node:ekr.20110604182206.16761: *7* Found: ['"]linefeed['"]
.. @+node:ekr.20070123143428: *8* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20110604043410.16736: *7* Found: ['"]return['"]
.. @+node:ekr.20050920084036.211: *8* getUserResponse
def getUserResponse (self,event):

    w = self.editWidget(event)
    if not w or not hasattr(event,'keysym'): return

    # g.trace(event.keysym)
    if event.keysym == 'y':
        self.doOneReplace(event)
        if not self.findNextMatch(event):
            self.quitSearch(event)
    elif event.keysym in ('q','Return'):
        self.quitSearch(event)
    elif event.keysym == '!':
        while self.findNextMatch(event):
            self.doOneReplace(event)
    elif event.keysym in ('n','Delete'):
        # Skip over the present match.
        i = w.getInsertPoint()
        w.setInsertPoint(i + len(self.qQ))
        if not self.findNextMatch(event):
            self.quitSearch(event)

    w.seeInsertPoint()
.. @+node:ekr.20050920084036.27: *8* expandAbbrev
def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event.char
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    if stroke=='BackSpace': return False
    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke,stroke)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event.char
    else:
        ch = event.char
        
    if trace: g.trace('event.char',repr(event.char),'ch',repr(ch),'stroke',repr(stroke))

    if len(ch) != 1 or (len(ch) == 1 and ch.isalpha()):
        # Normal chars other special chars abort abbreviations.
        return False

    # Get the text and insert point.
    s = w.getAllText()
    i = i1 = w.getInsertPoint()

    # Find the word to the left of the insert point.
    j = i ; i -= 1
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i -= 1
    if 0 <= i < len(s) and s[i] == '@':
        i -= 1
    i += 1
    word = s[i:j].strip()
    if trace: g.trace(i,j,repr(word))
    if not word: return False

    # First, look up the word without ch.
    val,tag = self.abbrevs.get(word,(None,None))
    if trace: g.trace(word,val,tag)
    
    if val:
        # Add ch to the result.
        if ch: val = val + ch
    else:
        # Look up the word with ch.
        if ch and not val:
            val,tag = self.abbrevs.get(word+ch,(None,None))
            if trace: g.trace(word+ch,val,tag)
    if val:
        if trace: g.trace('**inserting',repr(val))
        oldSel = j,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return val is not None
.. @+node:ekr.20050920084036.64: *8* escEvaluate (Revise)
def escEvaluate (self,event):
    
    c,k = self.c,self.k
    
    w = self.editWidget(event)
    if not w: return
    
    char = event and event.char or ''

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if char == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            i = w.getInsertPoint()
            w.insert(i,result)
            ok = True
        finally:
            k.keyboardQuit()
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
.. @+node:ekr.20061103114242: *8* << set local vars >>
p = c.p
gui = g.app.gui
stroke = event and event.stroke or ''
ch = event and event.char or ''

if ch == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
.. @+node:ekr.20050920084036.83: *8* viewLossage
def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es('',stroke or d.get(ch) or ch or 'None')
.. @+node:ekr.20050920084036.264: *8* iSearchStateHandler
# Called from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k
    stroke = event.stroke
    if trace: g.trace('stroke',repr(stroke))

    # No need to recognize ctrl-z.
    if stroke in ('Escape','Return'):
        self.endSearch()
    elif stroke in self.iSearchStrokes:
        self.iSearch(again=True)
    elif stroke == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif stroke.startswith('Ctrl+') or stroke.startswith('Alt+'):
        # End the search and execute the command.
        self.endSearch()
        k.masterKeyHandler(event,stroke=stroke)
    else:
        if trace: g.trace('event',event)
        k.updateLabel(event)
        self.iSearch()
.. @+node:ekr.20080531075119.6: *8* tracer
def tracer (self, frame, event, arg):

    '''A function to be passed to sys.settrace.'''

    n = len(self.stack)
    if event == 'return': n = max(0,n-1)
    pad = '.' * n

    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) < self.limit):
            g.trace('%scall' % (pad),name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    elif event == 'return':
        if self.stack:
            name = self.stack.pop()
            if self.trace and self.verbose and (self.limit == 0 or len(self.stack) < self.limit):
                g.trace('%sret ' % (pad),name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        else:
            self.stop()
            return None
    else:
        return self.tracer
.. @+node:ekr.20061031131434.11: *8* auto_completer_state_handler
def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    
    ch = char = event and event.char or ''
    stroke = event and event.stroke or ''
    is_plain = k.isPlainKey(stroke)

    if trace: g.trace('state: %s, char: %s, stroke: %s' % (
        state,repr(char),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif char == 'Return':
        self.exit()
    elif char == 'Escape':
        self.exit()
    elif char == 'Tab':
        self.doTabCompletion()
    elif char in ('\b','BackSpace'):
        self.do_backspace()
    elif char == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif char == '?':
        self.info()
    elif char == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = g.choose(self.verbose,'ON','OFF')
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    elif ch == 'Down' and hasattr(self,'onDown'):
        self.onDown()
    elif ch == 'Up' and hasattr(self,'onUp'):
        self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(char)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.es('No completions',color='blue')
                self.exit()
            return
        else:
            if trace: g.trace('ignore non plain key',repr(stroke))
            return 'do-standard-keys'
.. @+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        i = w.logCtrl.getInsertPoint()
        if not stroke:
            stroke = event.stroke # 2010/05/04.
        if stroke.lower() == 'return': stroke = '\n'
        elif stroke.lower() == 'tab': stroke = '\t'
        elif stroke.lower() == 'backspace': stroke = '\b'
        elif stroke.lower() == 'period': stroke = '.'
        w.logCtrl.insert(i,stroke)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.111: *8* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    
    c.check_event(event)
    
    ch = char = event and event.char or ''
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,char)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('Tab','\t'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.112: *9* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
.. @+node:ekr.20061031131434.122: *8* repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return # (for Tk) 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui
    
    char = event and event.char or ''
   
    if char == 'Return' and k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return # (for Tk) 'break'
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20061031131434.128: *8* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    
    c.check_event(event)

    char = event and event.char or ''
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.129: *9* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
.. @+node:ekr.20061031131434.152: *8* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20061031131434.168: *8* getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.169: *9* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.170: *9* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.171: *9* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
.. @+node:ekr.20061031131434.172: *9* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
.. @+node:ekr.20061031131434.173: *9* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
.. @+node:ekr.20061031131434.174: *9* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
.. @+node:ekr.20110604182206.16762: *7* Found: ['"]tab['"]
.. @+node:ekr.20050920084036.27: *8* expandAbbrev
def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event.char
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    if stroke=='BackSpace': return False
    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke,stroke)
        if len(ch) > 1:
            if (stroke.find('Ctrl+') > -1 or
                stroke.find('Alt+') > -1 or
                stroke.find('Meta+') > -1
            ):
                ch = ''
            else:
                ch = event.char
    else:
        ch = event.char
        
    if trace: g.trace('event.char',repr(event.char),'ch',repr(ch),'stroke',repr(stroke))

    if len(ch) != 1 or (len(ch) == 1 and ch.isalpha()):
        # Normal chars other special chars abort abbreviations.
        return False

    # Get the text and insert point.
    s = w.getAllText()
    i = i1 = w.getInsertPoint()

    # Find the word to the left of the insert point.
    j = i ; i -= 1
    while 0 <= i < len(s) and g.isWordChar(s[i]):
        i -= 1
    if 0 <= i < len(s) and s[i] == '@':
        i -= 1
    i += 1
    word = s[i:j].strip()
    if trace: g.trace(i,j,repr(word))
    if not word: return False

    # First, look up the word without ch.
    val,tag = self.abbrevs.get(word,(None,None))
    if trace: g.trace(word,val,tag)
    
    if val:
        # Add ch to the result.
        if ch: val = val + ch
    else:
        # Look up the word with ch.
        if ch and not val:
            val,tag = self.abbrevs.get(word+ch,(None,None))
            if trace: g.trace(word+ch,val,tag)
    if val:
        if trace: g.trace('**inserting',repr(val))
        oldSel = j,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return val is not None
.. @+node:ekr.20061103114242: *8* << set local vars >>
p = c.p
gui = g.app.gui
stroke = event and event.stroke or ''
ch = event and event.char or ''

if ch == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
.. @+node:ekr.20050920084036.83: *8* viewLossage
def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es('',stroke or d.get(ch) or ch or 'None')
.. @+node:ekr.20061031131434.11: *8* auto_completer_state_handler
def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    
    ch = char = event and event.char or ''
    stroke = event and event.stroke or ''
    is_plain = k.isPlainKey(stroke)

    if trace: g.trace('state: %s, char: %s, stroke: %s' % (
        state,repr(char),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif char == 'Return':
        self.exit()
    elif char == 'Escape':
        self.exit()
    elif char == 'Tab':
        self.doTabCompletion()
    elif char in ('\b','BackSpace'):
        self.do_backspace()
    elif char == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif char == '?':
        self.info()
    elif char == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = g.choose(self.verbose,'ON','OFF')
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    elif ch == 'Down' and hasattr(self,'onDown'):
        self.onDown()
    elif ch == 'Up' and hasattr(self,'onUp'):
        self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(char)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.es('No completions',color='blue')
                self.exit()
            return
        else:
            if trace: g.trace('ignore non plain key',repr(stroke))
            return 'do-standard-keys'
.. @+node:ekr.20070123143428: *8* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        i = w.logCtrl.getInsertPoint()
        if not stroke:
            stroke = event.stroke # 2010/05/04.
        if stroke.lower() == 'return': stroke = '\n'
        elif stroke.lower() == 'tab': stroke = '\t'
        elif stroke.lower() == 'backspace': stroke = '\b'
        elif stroke.lower() == 'period': stroke = '.'
        w.logCtrl.insert(i,stroke)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.111: *8* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    
    c.check_event(event)
    
    ch = char = event and event.char or ''
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,char)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('Tab','\t'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.112: *9* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
.. @+node:ekr.20061031131434.128: *8* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    
    c.check_event(event)

    char = event and event.char or ''
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.129: *9* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
.. @+node:ekr.20061031131434.152: *8* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20061031131434.168: *8* getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.169: *9* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.170: *9* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.171: *9* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
.. @+node:ekr.20061031131434.172: *9* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
.. @+node:ekr.20061031131434.173: *9* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
.. @+node:ekr.20061031131434.174: *9* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
.. @+node:ekr.20061031131434.182: *8* isPlainKey
def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('<') and shortcut.endswith('>'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
.. @+node:ekr.20110604182206.16764: *7* Found: defineTkNames
.. @+node:ekr.20070123143428: *8* k.defineTkNames
def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
.. @+node:ekr.20061031131434.76: *8*  ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    self.c = c
    self.dispatchEvent = None
    self.inited = False # Set at end of finishCreate.
    self.w = c.frame.miniBufferWidget
    self.new_bindings = True
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = getBool('trace_masterClickHandler')
    self.traceMasterCommand             = getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = getBool('trace_key_event')
    self.trace_minibuffer               = getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    << define externally visible ivars >>
    << define internal ivars >>

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    fn = c.shortFileName()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
.. @+node:ekr.20061031131434.78: *9* << define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.argSelectedText = '' # The selected text in state 0.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
.. @+node:ekr.20061031131434.79: *9* << define internal ivars >>
self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

# Keys whose bindings are computed by initSpecialIvars.
self.abortAllModesKey = None
self.autoCompleteForceKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
.. @+node:ekr.20110604182206.16755: *6* Found: \.masterKeyHandler
.. @+node:ekr.20050920084036.206: *7* endKbdMacro
def endKbdMacro (self,event=None):

    '''Stop recording a keyboard macro.'''

    k = self.k
    self.recordingMacro = False
        # Tell k.masterKeyHandler and masterCommandHandler we are done.

    if self.macro:
        # self.macro = self.macro [: -4]
        self.macros.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelBlue('Keyboard macro defined, not named')
    else:
        k.setLabelBlue('Empty keyboard macro')
.. @+node:ekr.20050920084036.203: *7* executeMacro
def executeMacro (self,macro):

    c = self.c ; k = self.k

    c.bodyWantsFocus()

    for event in macro:
        # New in Leo 4.6: macro entries are leoKeyEvents.
        g.trace(event.stroke)
        k.masterKeyHandler(event,stroke=event.stroke)
.. @+node:ekr.20050920084036.197: *7* loadMacros
def loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    c = self.c ; w = c.frame.body.bodyCtrl
    try:
        d = pickle.load(f)
    except pickle.UnpicklingError:
        g.es('error unpickling %s' % f.name)
        return

    # g.trace(f.name,d)

    for name in d:
        aList = d.get(name)
        macro = []
        for stroke in aList:
            # Create a dummy event with just enough attribute
            # to keep k.masterKeyHandler happy
            # actualEvent = g.Bunch(stroke=stroke,char=stroke,widget=w)
            # event = g.app.gui.leoKeyEvent(actualEvent,c)
            event = g.app.gui.create_key_event(c,None,stroke,w)
            macro.append(event)
        self.addToDoAltX(name,macro)
            # sets self.namedMacros[name]=macro


.. @+node:ekr.20050920084036.204: *7* startKbdMacro
def startKbdMacro (self,event=None):

    '''Start recording a keyboard macro.'''

    g.trace(self.recordingMacro)

    k = self.k

    if not self.recordingMacro:
        self.recordingMacro = True
            # A flag for k.masterCommandHandler & k.masterKeyHandler.
        k.setLabelBlue('Recording macro. ctrl-g to end...',protect=True)
    else:
        g.trace(event)
        self.macro.append(event)
.. @+node:ekr.20050920084036.264: *7* iSearchStateHandler
# Called from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k
    stroke = event.stroke
    if trace: g.trace('stroke',repr(stroke))

    # No need to recognize ctrl-z.
    if stroke in ('Escape','Return'):
        self.endSearch()
    elif stroke in self.iSearchStrokes:
        self.iSearch(again=True)
    elif stroke == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif stroke.startswith('Ctrl+') or stroke.startswith('Alt+'):
        # End the search and execute the command.
        self.endSearch()
        k.masterKeyHandler(event,stroke=stroke)
    else:
        if trace: g.trace('event',event)
        k.updateLabel(event)
        self.iSearch()
.. @+node:ekr.20061031131434.97: *7* k.completeAllBindings
def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        k.makeMasterGuiBinding(stroke,w=w)
.. @+node:ekr.20061031131434.103: *7* k.makeMasterGuiBinding
def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    if stroke.lower().startswith('key'):
        g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),g.callers(5))

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
.. @+node:ekr.20061031131434.105: *7* masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    
    c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.

    char = ch = event and event.char or ''
    w = event and event.w
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = char in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return # (for Tk) 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return # (for Tk) 'break'

    if special: # Don't pass these on.
        return # (for Tk) 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return # (for Tk) 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = char
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return # (for Tk) 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return # (for Tk) 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
.. @+node:ekr.20061031131434.106: *8* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
.. @+node:ekr.20061031131434.107: *8* << add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
.. @+node:ekr.20061031131434.109: *8* callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(commandName)

    return func
.. @+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        i = w.logCtrl.getInsertPoint()
        if not stroke:
            stroke = event.stroke # 2010/05/04.
        if stroke.lower() == 'return': stroke = '\n'
        elif stroke.lower() == 'tab': stroke = '\t'
        elif stroke.lower() == 'backspace': stroke = '\b'
        elif stroke.lower() == 'period': stroke = '.'
        w.logCtrl.insert(i,stroke)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.155: *7* masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('stroke',stroke,'func',func and func.__name__,commandName)

    # Create a minimal event for commands that require them.
    event = g.app.gui.create_key_event(c,None,stroke,w)
    
    c.check_event(event)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
.. @+node:ekr.20070228074312.2: *7* onChar (baseTextWidget)
# Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

# Must be defined in subclasses.

def onChar (self, event):
    
    g.trace('can not happen: must be defined in subclasses')
.. @+node:ekr.20070228074312.15: *7* event_generate (baseTextWidget)
def event_generate(self,stroke,keysym=None):
    
    g.trace('can not happen: must be defined in subclasses')
    return
.. @+node:ekr.20110604182206.16768: *6* Found: \.getArg
@nocolor-node

Theres should be an event arg for all calls.
### Marks where I changed the code to propagate an event arg from caller.
.. @+node:ekr.20050920084036.215: *7* stateHandler
def stateHandler (self,event):

    k = self.k ; state = k.getState('query-replace')

    prompt = g.choose(self.regexp,'Query replace regexp','Query replace')

    if state == 0: # Get the first arg.
        self.init()
        k.setLabelBlue(prompt + ': ',protect=True)
        k.getArg(event,'query-replace',1,self.stateHandler)
    elif state == 1: # Get the second arg.
        self.qQ = k.arg
        if len(k.arg) > 0:
            prompt = '%s %s with: ' % (prompt,k.arg)
            k.setLabelBlue(prompt)
            k.getArg(event,'query-replace',2,self.stateHandler)
        else:
            k.resetLabel()
            k.clearState()
    elif state == 2: # Set the prompt and find the first match.
        self.qR = k.arg # Null replacement arg is ok.
        k.setLabelBlue('Query replacing %s with %s\n' % (self.qQ,self.qR) +
            'y: replace, (n or Delete): skip, !: replace all, (q or Return): quit',
            protect=True)
        k.setState('query-replace',3,self.stateHandler)
        self.findNextMatch(event)
    elif state == 3:
        self.getUserResponse(event)
.. @+node:ekr.20061031131434.128: *7* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    
    c.check_event(event)

    char = event and event.char or ''
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.129: *8* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
.. @+node:ekr.20061031131434.152: *7* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20061031131434.168: *7* getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.169: *8* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.170: *8* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.171: *8* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
.. @+node:ekr.20061031131434.172: *8* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
.. @+node:ekr.20061031131434.173: *8* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
.. @+node:ekr.20061031131434.174: *8* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
.. @+node:ekr.20070317085437.50: *7* cc.cloneNodeToChapter & helper
def cloneNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then clone the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'clone-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Clone node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.cloneNodeToChapterHelper(k.arg)
.. @+node:ekr.20070604155815.1: *8* cc.cloneToChapterHelper
def cloneNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; p = c.p ; u = c.undoer
    undoType = 'Clone Node To Chapter'
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('chapter "%s" does not exist' % toChapterName)
    if fromChapter.name == 'main' and g.match_word(p.h,0,'@chapter'):
        return cc.error('can not clone @chapter node')

    # Open the group undo.
    c.undoer.beforeChangeGroup(toChapter.root,undoType)
    # Do the clone.  c.clone handles the inner undo.
    clone = c.clone()
    # Do the move.
    undoData2 = u.beforeMoveNode(clone)
    if toChapter.name == 'main':
        clone.moveAfter(toChapter.p)
    else:
        clone.moveToLastChildOf(toChapter.root)
    u.afterMoveNode(clone,'Move Node',undoData2,dirtyVnodeList=[])
    c.redraw(clone)
    c.setChanged(True)
    # Close the group undo.
    # Only the ancestors of the moved node get set dirty.
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.undoer.afterChangeGroup(clone,undoType,reportFlag=False,dirtyVnodeList=dirtyVnodeList)

    toChapter.p = clone.copy()
    toChapter.select()
    fromChapter.p = p.copy()
.. @+node:ekr.20070608072116: *7* cc.convertNodeToChapter
def convertNodeToChapter (self,event=None):

    '''convert-node-to-chapter command.

    Make the selected node into a new chapter, 'in place'.
    That is, create the new @chapter node as the next sibling of the node,
    then move the node as the first child of the new @chapter node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'convert-node-to-chapter'
    state = k.getState(tag)

    p = c.p
    if p.h.startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Convert node to chapter: ',protect=True)
        k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=c.p,
                undoType='Convert Node To Chapter')
.. @+node:ekr.20070317085437.51: *7* cc.copyNodeToChapter & helper
def copyNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then copy the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'copy-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.copyNodeToChapterHelper(k.arg)
.. @+node:ekr.20070604155815.2: *8* cc.copyNodeToChapterHelper
def copyNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; p = c.p ; u = c.undoer
    undoType = 'Copy Node To Chapter'
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('no such chapter: %s' % toChapterName)
    if fromChapter.name == 'main' and g.match_word(p.h,0,'@chapter'):
        return cc.error('can not copy @chapter node')

    # For undo, we treat the copy like a pasted (inserted) node.
    undoData = u.beforeInsertNode(toChapter.root,pasteAsClone=False,copiedBunchList=[])
    s = c.fileCommands.putLeoOutline()
    p2 = c.fileCommands.getLeoOutline(s)
    p2.moveToLastChildOf(toChapter.root)
    c.redraw(p2)
    u.afterInsertNode(p2,undoType,undoData)
    c.setChanged(True)

    toChapter.p = p2.copy()
    toChapter.select()
    fromChapter.p = p.copy()
.. @+node:ekr.20070317085437.31: *7* cc.createChapter
def createChapter (self,event=None):

    '''create-chapter command.
    Create a chapter with a dummy first node.'''

    cc = self ; k = cc.c.k ; tag = 'create-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter: ',protect=True)
        k.getArg(event,tag,1,self.createChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=None,
                undoType='Create Chapter')
.. @+node:ekr.20070607092909: *7* cc.createChapterFromNode
def createChapterFromNode (self,event=None):

    '''create-chapter-from-node command.

    Create a chapter whose first node is a clone of the presently selected node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'create-chapter-from-node'
    state = k.getState(tag)

    p = c.p
    if p.h.startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter from node: ',protect=True)
        k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,
                undoType='Create Chapter From Node')
.. @+node:ekr.20070604155815.3: *7* cc.moveNodeToChapter & helper
def moveNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then move the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'move-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Move node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.moveNodeToChapterHelper(k.arg)
.. @+node:ekr.20070317085437.52: *8* cc.moveNodeToChapterHelper (works)
def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; p = c.p ; u = c.undoer
    undoType = 'Move Node To Chapter'
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('chapter "%s" does not exist' % toChapterName)
    if fromChapter.name == 'main' and g.match_word(p.h,0,'@chapter'):
        return cc.error('can not move @chapter node')

    if toChapter.name == 'main':
        sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
    else:
        sel = p.threadBack() or p.nodeAfterTree()
    if sel:
        # Get 'before' undo data.
        inAtIgnoreRange = p.inAtIgnoreRange()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        # Do the move.
        if toChapter.name == 'main':
            p.moveAfter(toChapter.p)
        else:
            p.moveToLastChildOf(toChapter.root)
        c.redraw(sel)
        c.setChanged(True)
        # Do the 'after' undo operation.
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last remaining node of a chapter.')
.. @+node:ekr.20070317085437.41: *7* cc.renameChapter
# newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = list(cc.chaptersDict.keys())
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw()
.. @+node:ekr.20070604165126: *7* cc.selectChapter
def selectChapter (self,event=None):

    '''Use the minibuffer to get a chapter name,
    then create the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'select-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Select chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.selectChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.selectChapterByName(k.arg)
.. @+node:ekr.20070605110441: *7* dynamicExpandHelper (added event arg)
def dynamicExpandHelper (self,event,prefix=None,rlist=None,w=None):

    c,k = self.c,self.k ; tag = 'dabbrev-expand'
    state = k.getState(tag)
    
    if state == 0:
        self.w = w
        if w:
            names = rlist
            prefix2 = 'dabbrev-expand: '
            k.setLabelBlue(prefix2+prefix,protect=True)
            k.getArg(event,tag,1,self.dynamicExpandHelper,prefix=prefix2,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ins = w.getInsertPoint()
            i,j = g.getWord(s,ins)
            w.delete(i,j)
            w.insert(i,k.arg)
.. @+node:ekr.20050920084036.25: *7* addAbbreviation
def addAbbreviation (self,event):

    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''

    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ',protect=True)
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        value = k.argSelectedText # 2010/09/01.
        if k.arg.strip():
            self.abbrevs [k.arg] = value,'dynamic'
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviation (on): '%s' = '%s'" % (
                    k.arg,value))
.. @+node:ekr.20051004080550: *7* addInverseAbbreviation
def addInverseAbbreviation (self,event):

    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''

    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ',protect=True)
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg,'add-inverse-abbr'
.. @+node:ekr.20050927093851: *7* getBufferName (added event arg)
def getBufferName (self,event,finisher):

    '''Get a buffer name into k.arg and call k.setState(kind,n,handler).'''

    c,k = self.c,self.k
    state = k.getState('getBufferName')
    
    if state == 0:
        self.computeData()
        self.getBufferNameFinisher = finisher
        prefix = k.getLabel()
        k.getArg(event,'getBufferName',1,self.getBufferName,
            prefix=prefix,tabList=self.nameList)
    else:
        k.resetLabel()
        k.clearState()
        finisher = self.getBufferNameFinisher
        self.getBufferNameFinisher = None
        finisher(k.arg)
.. @+node:ekr.20050920084036.158: *7* shellCommand
def shellCommand (self,event):

    '''Execute a shell command.'''

    if subprocess:
        k = self.k ; state = k.getState('shell-command')

        if state == 0:
            k.setLabelBlue('shell-command: ',protect=True)
            k.getArg(event,'shell-command',1,self.shellCommand)
        else:
            command = k.arg
            k.commandName = 'shell-command: %s' % command
            k.clearState()
            self.executeSubprocess(event,command)
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
.. @+node:ekr.20050920084036.65: *7* evalExpression
def evalExpression (self,event):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    k = self.k ; state = k.getState('eval-expression')

    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -> %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
.. @+node:ekr.20050920084036.68: *7* setFillColumn
def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            # Bug fix: 2011/05/23: set the fillColumn ivar!
            self.fillColumn = n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
.. @+node:ekr.20060417194232.1: *7* findCharacterHelper
def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward
        self.extend = extend or self.extendMode # Bug fix: 2010/01/19
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' & extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward
        extend = self.extend or self.extendMode
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        else:
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j > -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
.. @+node:ekr.20080408060320.1: *7* findWordHelper
def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i < end:
                i = s.find(ch,i+1,end) # Ensure progress and i > 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
.. @+node:ekr.20050929115226: *7* gotoCharacter
def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n >= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
.. @+node:ekr.20060417181052: *7* gotoGlobalLine
def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    c = self.c
    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            c.goToLineNumber(c).go(n=int(n))
.. @+node:ekr.20050929124234: *7* gotoLine
def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
.. @+node:ekr.20110530082209.18248: *7* replaceCurrentCharacter
def replaceCurrentCharacter (self,event):

    c = self.c ; k = self.k ; tag = 'replace-current-character'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Replace Character: ',protect=True)
            k.getArg(event,tag,1,self.replaceCurrentCharacter)
    else:
        w = self.w
        ch = k.arg
        if ch:
            i,j = w.getSelectionRange()
            if i > j: i,j = j,i
            # Use raw insert/delete to retain the coloring.
            if i == j:
                i = max(0,i-1)
                w.delete(i)
            else:
                w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
.. @+node:ekr.20050920084036.80: *7* howMany
def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
.. @+node:ekr.20050920084036.90: *7* flushLines
def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
.. @+node:ekr.20051002095724: *7* keepLines
def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
.. @+node:ekr.20110527105255.18386: *7* setUa
def setUa (self,event):
    
    c,k = self.c,self.k
    tag = 'set-ua' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Set uA: ',protect=True)
            k.getArg(event,tag,1,self.setUa)
    elif state == 1:
        self.uaName = k.arg
        s = 'Set uA: %s To: ' % (self.uaName)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,tag,2,self.setUa,completion=False,prefix=s)
    else:
        assert state == 2,state
        val = k.arg
        d = c.p.v.u
        d[self.uaName] = val
        self.printUas()
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
.. @+node:ekr.20050920084036.164: *7* deleteFile
def deleteFile (self,event):

    '''Prompt for the name of a file and delete it.'''

    k = self.k ; state = k.getState('delete_file')

    if state == 0:
        prefix = 'Delete File: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'delete_file',1,self.deleteFile,prefix=prefix)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.remove(k.arg)
            k.setLabel('Deleted: %s' % k.arg)
        except Exception:
            k.setLabel('Not Deleted: %s' % k.arg)
.. @+node:ekr.20050920084036.168: *7* makeDirectory
def makeDirectory (self,event):

    '''Prompt for the name of a directory and create it.'''

    k = self.k ; state = k.getState('make_directory')

    if state == 0:
        prefix = 'Make Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'make_directory',1,self.makeDirectory,prefix=prefix)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.mkdir(k.arg)
            k.setLabel("Created: %s" % k.arg)
        except Exception:
            k.setLabel("Not Create: %s" % k.arg)
.. @+node:ekr.20050920084036.169: *7* removeDirectory
def removeDirectory (self,event):

    '''Prompt for the name of a directory and delete it.'''

    k = self.k ; state = k.getState('remove_directory')

    if state == 0:
        prefix = 'Remove Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'remove_directory',1,self.removeDirectory,prefix=prefix)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.rmdir(k.arg)
            k.setLabel('Removed: %s' % k.arg)
        except Exception:
            k.setLabel('Not Remove: %s' % k.arg)
.. @+node:ekr.20060602154458: *7* pythonHelp
def pythonHelp (self,event=None):

    '''Prompt for a arg for Python's help function, and put it to the log pane.'''

    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)

    if state == 0:
        c.minibufferWantsFocus()
        k.setLabelBlue('Python help: ',protect=True)
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            g.redirectStderr()
            g.redirectStdout()
            try: help(str(s))
            except Exception: pass
            g.restoreStderr()
            g.restoreStdout()
.. @+node:ekr.20050920084036.194: *7* callNamedMacro
def callNamedMacro (self,event):

    '''Prompts for a macro name to save, then executes it.'''

    k = self.k ; tag = 'macro-name'
    state = k.getState(tag)
    prompt = 'Call macro named: '

    if state == 0:
        k.setLabelBlue(prompt,protect=True)
        k.getArg(event,tag,1,self.callNamedMacro)
    else:
        macro = self.namedMacros.get(k.arg)
        # Must do this first!
        k.clearState()
        if macro:
            self.executeMacro(macro)
        else:
            g.es('no macro named %s' % k.arg)
        k.resetLabel()

.. @+node:ekr.20050920084036.198: *7* nameLastKbdMacro
def nameLastKbdMacro (self,event):

    '''Prompt for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ',protect=True)
        k.getArg(event,'name-macro',1,self.nameLastKbdMacro)
    else:
        k.clearState()
        name = k.arg
        self.addToDoAltX(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
.. @+node:ekr.20050920084036.232: *7* stringRectangle
def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ',protect=True)
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        r1, r2, r3, r4 = self.stringRect
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)
        self.endCommand()
        # 2010/1/1: Fix bug 480422:
        # string-rectangle kills syntax highlighting.
        c.frame.body.recolor(c.p,incremental=False)

.. @+node:ekr.20070105123800: *7* changeAll (minibufferFind)
def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        # Bug fix: 2009-5-31.
        # None denotes that we use the present value of the option.
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)
.. @+node:ekr.20060209064140: *7* findAll
def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
.. @+node:ekr.20050920084036.113: *7* replaceString
def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
.. @+node:ekr.20060124140224.3: *7* reSearchBackward/Forward
def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
.. @+node:ekr.20060124140224.1: *7* seachForward/Backward
def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
.. @+node:ekr.20060125093807: *7* searchWithPresentOptions
def searchWithPresentOptions (self,event):

    trace = False and not g.unitTesting
    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if trace: g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
.. @+node:ekr.20060210173041: *7* stateZeroHelper
def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
.. @+node:ekr.20091230094319.6244: *7* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
.. @+node:ekr.20110604182206.16766: *6* Found: keysym
@nocolor-node

Added assert that event.keysym == event.char  Marked with ####
.. @+node:ekr.20050920084036.211: *7* getUserResponse
def getUserResponse (self,event):

    w = self.editWidget(event)
    if not w or not hasattr(event,'keysym'): return

    # g.trace(event.keysym)
    if event.keysym == 'y':
        self.doOneReplace(event)
        if not self.findNextMatch(event):
            self.quitSearch(event)
    elif event.keysym in ('q','Return'):
        self.quitSearch(event)
    elif event.keysym == '!':
        while self.findNextMatch(event):
            self.doOneReplace(event)
    elif event.keysym in ('n','Delete'):
        # Skip over the present match.
        i = w.getInsertPoint()
        w.setInsertPoint(i + len(self.qQ))
        if not self.findNextMatch(event):
            self.quitSearch(event)

    w.seeInsertPoint()
.. @+node:ekr.20061031131434.105: *7* masterCommand & helpers
def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    
    c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.

    char = ch = event and event.char or ''
    w = event and event.w
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '<no function>'
    << define specialKeysyms >>
    special = char in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        << add character to history >>

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return # (for Tk) 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return # (for Tk) 'break'

    if special: # Don't pass these on.
        return # (for Tk) 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return # (for Tk) 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = char
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return # (for Tk) 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return # (for Tk) 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
.. @+node:ekr.20061031131434.106: *8* << define specialKeysyms >>
specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
.. @+node:ekr.20061031131434.107: *8* << add character to history >>
if stroke or len(ch) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
.. @+node:ekr.20061031131434.109: *8* callKeystrokeFunction (not used)
def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(commandName)

    return func
.. @+node:ekr.20061031131434.110: *8* k.handleDefaultChar
def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') > -1 or stroke.find('Alt') > -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        i = w.logCtrl.getInsertPoint()
        if not stroke:
            stroke = event.stroke # 2010/05/04.
        if stroke.lower() == 'return': stroke = '\n'
        elif stroke.lower() == 'tab': stroke = '\t'
        elif stroke.lower() == 'backspace': stroke = '\b'
        elif stroke.lower() == 'period': stroke = '.'
        w.logCtrl.insert(i,stroke)
        return # None
    else:
        # Let the widget handle the event.
        return # None
.. @+node:ekr.20061031131434.155: *7* masterMenuHandler
def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('stroke',stroke,'func',func and func.__name__,commandName)

    # Create a minimal event for commands that require them.
    event = g.app.gui.create_key_event(c,None,stroke,w)
    
    c.check_event(event)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
.. @+node:ekr.20070228074312.2: *7* onChar (baseTextWidget)
# Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

# Must be defined in subclasses.

def onChar (self, event):
    
    g.trace('can not happen: must be defined in subclasses')
.. @+node:ekr.20051106040126: *7* c.executeMinibufferCommand
def executeMinibufferCommand (self,commandName):

    c = self ; k = c.k

    func = c.commandsDict.get(commandName)

    if func:
        event = g.app.gui.create_key_event(c,None,stroke,w)
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.error('no such command: %s %s' % (commandName,g.callers()))
        return None
.. @+node:ekr.20060923202156: *7* c.onCanvasKey
def onCanvasKey (self,event):

    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''

    # g.trace(event and event.char)

    if not event or not event.char or not event.char.isalnum():
        return
    c  = self ; p = c.p ; p1 = p.copy()
   
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event and event.char or ''
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        c.selectPosition(p)
        c.redraw_after_select(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.h)
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocus()
.. @+node:ekr.20061002095711.1: *8* c.navQuickKey
def navQuickKey (self):

    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''

    c = self

    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime < deltaTime
        return nearTime
.. @+node:ekr.20061002095711: *8* c.navHelper
def navHelper (self,p,ch,extend):

    c = self ; h = p.h.lower()

    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch

    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent',):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n < len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) < len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
.. @+node:ekr.20050920084036.250: *7* _checkIfRectangle
def _checkIfRectangle (self,event):

    c,k = self.c,self.k
    
    key = event and event.char.lower() or ''

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
.. @+node:ekr.20050920084036.63: *7* watchEscape (Revise)
def watchEscape (self,event):

    c,k = self.c,self.k
    
    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = leoKeys.keyHandlerClass.lossage[0]
        data2 = leoKeys.keyHandlerClass.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and event.char == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.char not in ('Shift_L','Shift_R'):
            k.keyboardQuit()
.. @+node:ekr.20050920084036.64: *7* escEvaluate (Revise)
def escEvaluate (self,event):
    
    c,k = self.c,self.k
    
    w = self.editWidget(event)
    if not w: return
    
    char = event and event.char or ''

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if char == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            i = w.getInsertPoint()
            w.insert(i,result)
            ok = True
        finally:
            k.keyboardQuit()
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
.. @+node:ekr.20051125080855: *7* selfInsertCommand, helpers
def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    
    c,k = self.c,self.k
   
    verbose = True
    w = self.editWidget(event)
    if not w: return # (for Tk) 'break'
    << set local vars >>
    if trace: g.trace('ch',repr(ch),'stroke',stroke)
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return # (for Tk) "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i > j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return # (for Tk) 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return # (for Tk) 'break'
.. @+node:ekr.20061103114242: *8* << set local vars >>
p = c.p
gui = g.app.gui
stroke = event and event.stroke or ''
ch = event and event.char or ''

if ch == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if ch == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
.. @+node:ekr.20090213065933.14: *8* doPlainTab
def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width > 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
.. @+node:ekr.20060627091557: *8* flashCharacter
def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
.. @+node:ekr.20060627083506: *8* flashMatchingBracketsHelper
def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
.. @+node:ekr.20060804095512: *8* initBracketMatcher
def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
.. @+node:ekr.20051026171121: *8* insertNewlineHelper
def insertNewlineHelper (self,w,oldSel,undoType):

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'
    if trace:
        s = w.widget.toPlainText()
        g.trace(i,j,len(s),w)

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
.. @+node:ekr.20051026171121.1: *8* updateAutoIndent (leoEditCommands)
def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) > 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
.. @+node:ekr.20051027172949: *8* updateAutomatchBracket
def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins<len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
.. @+node:ekr.20051026092433: *8* updateTab
def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i <= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
.. @+node:ekr.20050920084036.238: *7* appendToRegister
def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'append-to-register' ; state = k.getState(tag)
    
    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Append to Register: ',protect=True)
        k.setState(tag,1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.char.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.char.lower()
                val = self.registers.get(key,'')
                val = val + w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.237: *7* prependToRegister
def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'prepend-to-register' ; state = k.getState(tag)
    
    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Prepend to Register: ',protect=True)
        k.setState(tag,1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.char.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.char.lower()
                val = self.registers.get(key,'')
                val = w.getSelectedText() + val
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.239: *7* copyRectangleToRegister
def copyRectangleToRegister (self,event):

    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')
    
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.char.isalpha():
            key = event.char.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 <= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.240: *7* copyToRegister
def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'copy-to-register' ; state = k.getState(tag)
    
    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Copy to Register: ',protect=True)
        k.setState(tag,1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.char.isalpha():
                key = event.char.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                val = w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.241: *7* incrementRegister
def incrementRegister (self,event):

    '''Prompt for a register name and increment its value if it has a numeric value.'''

    c = self.c ; k = self.k ; state = k.getState('increment-reg')
    
    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.char.isalpha():
            key = event.char.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.242: *7* insertRegister
def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.char.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.char.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    i = w.getInsertPoint()
                    w.insert(i,val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.243: *7* jumpToRegister
def jumpToRegister (self,event):

    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')
    
    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.char.isalpha():
            if self._checkIfRectangle(event): return
            key = event.char.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.setInsertPoint(val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.244: *7* numberToRegister (not used)
@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):

    c,k = self.c,self.k
    state = k.getState('number-to-reg')
    
    char = event and event.char or ''
    
    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if char.isalpha():
            # self.registers[event.char.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
.. @+node:ekr.20050920084036.245: *7* pointToRegister
def pointToRegister (self,event):

    '''Prompt for a register name and put a value indicating the insert point in the register.'''

    c = self.c ; k = self.k ; state = k.getState('point-to-reg')
    
    char = event and event.char or ''

    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if char.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.char.lower()
            val = w.getInsertPoint()
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20050920084036.246: *7* viewRegister
def viewRegister (self,event):

    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')
    
    

    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.char.isalpha():
            key = event.char.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
.. @+node:ekr.20090204084607.2: *7* iSearch
def iSearch (self,again=False):

    '''Handle the actual incremental search.'''

    c = self.c ; k = self.k ; p = c.p
    ifinder = self.ifinder
    reverse = not self.forward
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        return self.abortSearch()
    ifinder.c = c ; ifinder.p = p.copy()
    # Get the base ivars from the find tab.
    ifinder.update_ivars()
    # Save
    oldPattern = ifinder.find_text
    oldRegexp  = ifinder.pattern_match
    oldReverse = ifinder.reverse
    oldWord =  ifinder.whole_word
    # Override
    ifinder.pattern_match = self.regexp
    ifinder.reverse = reverse
    ifinder.find_text = pattern
    ifinder.whole_word = False # Word option can't be used!
    # Prepare the search.
    if len(self.stack) <= 1: ifinder.in_headline = False
    w = self.setWidget()
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if again:   ins = g.choose(reverse,i,j+len(pattern))
    else:       ins = g.choose(reverse,j+len(pattern),i)
    ifinder.init_s_ctrl(s,ins)
    # Do the search!
    pos, newpos = ifinder.findNextMatch()
    # Restore.
    ifinder.find_text = oldPattern
    ifinder.pattern_match = oldRegexp
    ifinder.reverse = oldReverse
    ifinder.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None: # success.
        w = ifinder.showSuccess(pos,newpos,showState=False)
        if w: i,j = w.getSelectionRange(sort=False)
        # else: g.trace('****')
        if not again: self.push(c.p,i,j,ifinder.in_headline)
    elif ifinder.wrapping:
        g.es("end of wrapped search")
    else:
        g.es("not found","'%s'" % (pattern))
        event = g.app.gui.create_key_event(c,'\b','BackSpace',w)
        k.updateLabel(event)
.. @+node:ekr.20061031131434.11: *7* auto_completer_state_handler
def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    
    ch = char = event and event.char or ''
    stroke = event and event.stroke or ''
    is_plain = k.isPlainKey(stroke)

    if trace: g.trace('state: %s, char: %s, stroke: %s' % (
        state,repr(char),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif char == 'Return':
        self.exit()
    elif char == 'Escape':
        self.exit()
    elif char == 'Tab':
        self.doTabCompletion()
    elif char in ('\b','BackSpace'):
        self.do_backspace()
    elif char == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif char == '?':
        self.info()
    elif char == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = g.choose(self.verbose,'ON','OFF')
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    elif ch == 'Down' and hasattr(self,'onDown'):
        self.onDown()
    elif ch == 'Up' and hasattr(self,'onUp'):
        self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(char)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.es('No completions',color='blue')
                self.exit()
            return
        else:
            if trace: g.trace('ignore non plain key',repr(stroke))
            return 'do-standard-keys'
.. @+node:ekr.20061031131434.39: *7* insert_general_char
def insert_general_char (self,ch):

    trace = False and not g.unitTesting
    c,k = self.c,self.k ; w = self.w
    
    if trace: g.trace(repr(ch))

    if g.isWordChar(ch):
        self.insert_string(ch)
        common_prefix,prefix,aList = self.compute_completion_list()
        if trace: g.trace('ch',repr(ch),'prefix',repr(prefix),'len(aList)',len(aList))
        if not aList:
            if 0: # Annoying. Let the user type "by hand".
                # Delete the character we just inserted.
                self.do_backspace()
        elif self.auto_tab and len(common_prefix) > len(prefix):
            extend = common_prefix[len(prefix):]
            if trace: g.trace('*** extend',extend)
            ins = w.getInsertPoint()
            w.insert(ins,extend)
    else:
        if ch == '(' and k.enable_calltips:
            # This calls self.exit if the '(' is valid.
            self.calltip()
        else:
            if trace: g.trace('ch',repr(ch),'calling exit')
            self.insert_string(ch)
            self.exit()
.. @+node:ekr.20061031131434.111: *7* fullCommand (alt-x) & helper
def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    
    c.check_event(event)
    
    ch = char = event and event.char or ''
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,char)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('Tab','\t'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) > 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.112: *8* callAltXFunction
def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
.. @+node:ekr.20061031131434.118: *7* numberCommand
def numberCommand (self,event,stroke,number):

    k = self ; c = self.c
    k.stroke = stroke
    w = event and event.widget
    
    k.universalDispatcher(event)
    g.app.gui.event_generate(c,chr(number),chr(number),w)
    return # (for Tk) 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
.. @+node:ekr.20061031131434.122: *7* repeatComplexCommand & helper
def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return # (for Tk) 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui
    
    char = event and event.char or ''
   
    if char == 'Return' and k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return # (for Tk) 'break'
    else:
        # g.trace('oops')
        return k.keyboardQuit()
.. @+node:ekr.20061031131434.127: *7* simulateCommand
def simulateCommand (self,commandName):

    k = self ; c = k.c

    commandName = commandName.strip()
    if not commandName: return

    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]

    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        stroke = None
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c,None,None,None)
            
        k.masterCommand(event,func,stroke)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        g.trace('no command for %s' % (commandName),color='red')
        if g.app.unitTesting:
            raise AttributeError
        else:
            return None
.. @+node:ekr.20061031131434.128: *7* getArg
def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    
    c.check_event(event)

    char = event and event.char or ''
    
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.129: *8* << init altX vars >>
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
.. @+node:ekr.20061031131434.146: *7* masterKeyHandler & helpers
master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''
    
    k,c = self,self.c ; gui = g.app.gui
    
    c.check_event(event)

    << define vars >>
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event.char),'ch:',repr(event.char),'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke)
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,stroke)
.. @+node:ekr.20061031131434.147: *8* << define vars >>
w = event.widget
char = event and event.char or ''
stroke = event and event.stroke or ''
w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
.. @+node:ekr.20061031131434.108: *8* callStateFunction
def callStateFunction (self,event):

    k = self ; val = None 
    
    ch = event and event.char or ''

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) < 32 or ord(ch) > 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
.. @+node:ekr.20091230094319.6244: *8* doMode
def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
.. @+node:ekr.20091230094319.6240: *8* getPaneBinding
def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and b.commandName in table:
                        if trace: g.trace('***** special case',b.commandName)
                        pass
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(b.stroke),b.commandName))
                        return b
.. @+node:ekr.20061031131434.152: *8* handleMiniBindings
def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
.. @+node:ekr.20110209083917.16004: *8* isAutoCompleteChar
def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    return True
    return False
.. @+node:ekr.20080510095819.1: *8* k.handleUnboundKeys
def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)

    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event.char),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return # (for Tk) 'break'

    elif k.isFKey(stroke):
        if trace: g.trace('ignoring F-key',stroke)
        return # (for Tk) 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  <Return> is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') > -1 or stroke.find('Ctrl+') > -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',stroke,char)
        return # (for Tk) 'break'

    elif k.ignore_unbound_non_ascii_keys and len(char) > 1:
        if trace: g.trace('ignoring unbound non-ascii key',repr(stroke))
        return # (for Tk) 'break'

    elif (
        char and char.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return # (for Tk) 'break'

    else:
        if trace: g.trace('no func',stroke)
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
.. @+node:ekr.20061031170011.12: *7* updateLabel
def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or self.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    
    ch = char = (event and event.char) or ''

    if trace: g.trace('ch',ch,'k.stroke',k.stroke)

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) > len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
.. @+node:ekr.20061031131434.168: *7* getFileName & helpers
def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    char = event and event.char or ''
    # g.trace('state',state,'char',char)

    if state == 0:
        k.arg = ''
        << init altX vars >>
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif char == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif char in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif char == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.169: *8* << init altX vars >>
k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
.. @+node:ekr.20061031131434.170: *8* k.doFileNameBackSpace
def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) > len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) > len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
.. @+node:ekr.20061031131434.171: *8* k.doFileNameChar
def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
.. @+node:ekr.20061031131434.172: *8* k.doFileNameTab
def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
.. @+node:ekr.20061031131434.173: *8* k.computeFileNameCompletionList
# This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
.. @+node:ekr.20061031131434.174: *8* k.showFileNameTabList
def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
.. @+node:ekr.20061031131434.200: *7* k.universalDispatcher & helpers
def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    << about repeat counts >>

    c,k = self.c,self ; gui = g.app.gui
    state = k.getState('u-arg')
    
    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        char = event and event.char or ''
        # g.trace(state,char)
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n,stroke=stroke) ##
            k.keyboardQuit()
            # k.clearState()
            # k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '<Control-x>':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return # (for Tk) 'break'
.. @+node:ekr.20061031131434.201: *8* << about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
.. @+node:ekr.20061031131434.202: *8* executeNTimes
def executeNTimes (self,event,n,stroke):

    trace = False and not g.unitTesting
    c,k = self.c,self

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        b = k.getPaneBinding(stroke,event.widget)
        if b:
            if trace: g.trace('repeat',n,'method',b.func.__name__,
                'stroke',stroke,'widget',event.widget)
            for z in range(n):
                event = g.app.gui.create_key_event(c,None,stroke,w)
                k.masterCommand(event,stroke)
        else:
            w = event.widget
            for z in range(n):
                k.masterKeyHandler(event,stroke=event.stroke)
.. @+node:ekr.20061031131434.203: *8* doControlU
def doControlU (self,event,stroke):

    k = self ; c = k.c

    ch = event and event.char or ''

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
.. @+node:ekr.20070228160107: *7* class leoKeyEvent (leoGui) (Changed)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''
    
    @others

    def __repr__ (self):

        return 'leoKeyEvent: stroke: %s, char: %s, w: %s' % (
            repr(self.stroke),repr(self.char),repr(self.w))
.. @+node:ekr.20110605121601.18846: *8* ctor (leoKeyEvent)
def __init__ (self,c,char,stroke,w,x,y,x_root,y_root):
    
    self.c = c
    self.char = char or ''
    self.stroke = stroke or ''
    self.w = self.widget = w
    
    # Optional ivars
    self.x = x
    self.y = y
    # Support for fastGotoNode plugin
    self.x_root = x_root
    self.y_root = y_root

    # self.actualEvent = event
    # self.state  = hasattr(event,'state') and event.state or 0
.. @+node:ekr.20031218072017.4117: *7* defineMenuCallback
def defineMenuCallback(self,command,name,minibufferCommand):
    
    c = self.c

    if minibufferCommand:

        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c,None,None,None)

        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            c = self.c
            return c.doCommand(command,label,event)

        return minibufferMenuCallback

    else:

        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            c.check_event(event)
            return c.doCommand(command,label)

        return legacyMenuCallback
.. @+node:ekr.20110605040658.17004: *6* Found: event_generate
.. @+node:ekr.20061031131434.118: *7* numberCommand
def numberCommand (self,event,stroke,number):

    k = self ; c = self.c
    k.stroke = stroke
    w = event and event.widget
    
    k.universalDispatcher(event)
    g.app.gui.event_generate(c,chr(number),chr(number),w)
    return # (for Tk) 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
.. @+node:ekr.20061031131434.126: *7* manufactureKeyPressForCommandName (changed)
def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    # g.trace('stroke',repr(stroke),'commandName',commandName,'w',w,g.callers())

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(c,None,stroke,w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.trace(message,color='red')
.. @+node:ekr.20061031131434.202: *7* executeNTimes
def executeNTimes (self,event,n,stroke):

    trace = False and not g.unitTesting
    c,k = self.c,self

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        b = k.getPaneBinding(stroke,event.widget)
        if b:
            if trace: g.trace('repeat',n,'method',b.func.__name__,
                'stroke',stroke,'widget',event.widget)
            for z in range(n):
                event = g.app.gui.create_key_event(c,None,stroke,w)
                k.masterCommand(event,stroke)
        else:
            w = event.widget
            for z in range(n):
                k.masterKeyHandler(event,stroke=event.stroke)
.. @+node:ekr.20110605195119.16939: *5* Changed & new...
.. @+node:ekr.20110605040658.17005: *6* c.check_event
def check_event (self,event):
    
    trace = False and not g.unitTesting
    c,k = self,self.k
    
    import leo.core.leoGui as leoGui
    
    def test(val,message):
        # g.trace(g.unitTesting)
        if g.unitTesting and not trace:
            assert val,message
        else:
            if not val: print('check_event',message)
    
    if not event:
        return
        
    isLeoKeyEvent = isinstance(event,leoGui.leoKeyEvent)
    stroke = event.stroke
    got = event.char

    if g.unitTesting:
        if stroke in ('Ins','Delete',):
             expected = event.char
                # disable the test for now.
        elif stroke in ('Backspace','Linefeed','Return','Tab'):
            expected = event.char
                # disable the test for now.
        else:
            expected = k.stroke2char(event.stroke)
                # Be more strict for unit testing.
    else:
        if trace or k.isPlainKey(stroke):
            expected = k.stroke2char(event.stroke)
                # Perform the full test.
        else:
            expected = event.char
                # disable the test.
                # We will use the (weird) key value for, say, Ctrl-s,
                # if there is no binding for Ctrl-s.
                
    test(isLeoKeyEvent,'not leo event: %s, callers: %s' % (
        repr(event),g.callers()))

    test(hasattr(event,'char'),'no char ivar: %s' % (event))

    test(expected == got,'stroke: %s, expected char: %s, got: %s' % (
            repr(stroke),repr(expected),repr(got)))
.. @+node:ekr.20070228160107: *6* class leoKeyEvent (leoGui) (Changed)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''
    
    @others

    def __repr__ (self):

        return 'leoKeyEvent: stroke: %s, char: %s, w: %s' % (
            repr(self.stroke),repr(self.char),repr(self.w))
.. @+node:ekr.20110605121601.18846: *7* ctor (leoKeyEvent)
def __init__ (self,c,char,stroke,w,x,y,x_root,y_root):
    
    self.c = c
    self.char = char or ''
    self.stroke = stroke or ''
    self.w = self.widget = w
    
    # Optional ivars
    self.x = x
    self.y = y
    # Support for fastGotoNode plugin
    self.x_root = x_root
    self.y_root = y_root

    # self.actualEvent = event
    # self.state  = hasattr(event,'state') and event.state or 0
.. @+node:ekr.20110605121601.18537: *6* class leoQtEventFilter
class leoQtEventFilter(QtCore.QObject):

    << about internal bindings >>

    @others
.. @+node:ekr.20110605121601.18538: *7* << about internal bindings >>
@nocolor-node
@

Here are the rules for translating key bindings (in leoSettings.leo) into keys
for k.bindingsDict:

1.  The case of plain letters is significant:  a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore (with a
warning) the shift prefix applied to any other binding, e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is *not*
significant. Thus, the Shift- prefix is required if you want an upper-case
letter (with the exception of 'bare' uppercase letters.)

The following table illustrates these rules. In each row, the first entry is the
key (for k.bindingsDict) and the other entries are equivalents that the user may
specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is consistent
with Tk's key-event specifiers). It is also, I think, the least confusing set of
rules.
.. @+node:ekr.20110605121601.18539: *7*  ctor
def __init__(self,c,w,tag=''):

    # g.trace('leoQtEventFilter',tag,w)

    # Init the base class.
    QtCore.QObject.__init__(self)

    self.c = c
    self.w = w      # A leoQtX object, *not* a Qt object.
    self.tag = tag

    # Debugging.
    self.keyIsActive = False
    self.trace_masterKeyHandler = c.config.getBool('trace_masterKeyHandler')

    # Pretend there is a binding for these characters.
    close_flashers = c.config.getString('close_flash_brackets') or ''
    open_flashers  = c.config.getString('open_flash_brackets') or ''
    self.flashers = open_flashers + close_flashers
    
    # Support for ctagscompleter.py plugin.
    self.ctagscompleter_active = False
    self.ctagscompleter_onKey = None
.. @+node:ekr.20110605121601.18540: *7* eventFilter
def eventFilter(self, obj, event):

    trace = (False or self.trace_masterKeyHandler) and not g.unitTesting
    verbose = True
    traceEvent = False
    traceKey = (False or self.trace_masterKeyHandler)
    traceFocus = False
    c = self.c ; k = c.k
    eventType = event.type()
    ev = QtCore.QEvent
    gui = g.app.gui
    aList = []

    # if trace and verbose: g.trace('*****',eventType)

    kinds = [ev.ShortcutOverride,ev.KeyPress,ev.KeyRelease]

    if trace and traceFocus: self.traceFocus(eventType,obj)
    
    # Hack: QLineEdit generates ev.KeyRelease only on Windows,Ubuntu
    lineEditKeyKinds = [ev.KeyPress,ev.KeyRelease]
        
    if eventType in lineEditKeyKinds:
        p = c.currentPosition()
        isEditWidget = obj == c.frame.tree.edit_widget(p)
        self.keyIsActive = g.choose(
            isEditWidget,
            eventType == ev.KeyRelease,
            eventType == ev.KeyPress)
        # g.trace(isEditWidget,eventType,obj)
    else:
        self.keyIsActive = False

    if eventType == ev.WindowActivate:
        gui.onActivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType == ev.WindowDeactivate:
        gui.onDeactivateEvent(event,c,obj,self.tag)
        override = False ; tkKey = None
    elif eventType in kinds:
        tkKey,ch,ignore = self.toTkKey(event)
        aList = c.k.masterGuiBindingsDict.get('<%s>' %tkKey,[])
        if ignore:
            override = False
        # This is extremely bad.  At present, it is needed to handle tab properly.
        elif self.isSpecialOverride(tkKey,ch):
            override = True
        elif k.inState():
            override = not ignore # allow all keystrokes.
        else:
            override = len(aList) > 0
        # if trace and verbose: g.trace(
            # tkKey,len(aList),'ignore',ignore,'override',override)
    else:
        override = False ; tkKey = '<no key>'
        if self.tag == 'body':
            if eventType == ev.FocusIn:
                c.frame.body.onFocusIn(obj)
            elif eventType == ev.FocusOut:
                c.frame.body.onFocusOut(obj)

    if self.keyIsActive:
        stroke = self.toStroke(tkKey,ch)

        if override:
            if trace and traceKey and not ignore:
                g.trace('bound',repr(stroke)) # repr(aList))
            w = self.w # Pass the wrapper class, not the wrapped widget.
            event = self.create_key_event(event,c,w,ch,tkKey,stroke)
            ret = k.masterKeyHandler(event,stroke=stroke)
            c.outerUpdate()
        else:
            if trace and traceKey and verbose:
                g.trace(self.tag,'unbound',tkKey,stroke)
        
        if trace and traceKey:
            # Trace key events.
            self.traceEvent(obj,event,tkKey,override)

    elif trace and traceEvent:
        # Trace non-key events.
        self.traceEvent(obj,event,tkKey,override)

    return override
.. @+node:ekr.20110605195119.16937: *7* create_key_event (leoQtEventFilter) (new)
def create_key_event (self,event,c,w,ch,tkKey,stroke):

    trace = False and not g.unitTesting

    if trace: g.trace('ch: %s, tkKey: %s, stroke: %s' % (
        repr(ch),repr(tkKey),repr(stroke)))

    # Last minute-munges to char.
    if tkKey in ('Return','Tab','Escape',
        'Linefeed','BackSpace', ####
    ): # 'Ins'
        ch = tkKey
    
    stroke = stroke.replace('\t','Tab')
    tkKey = tkKey.replace('\t','Tab')

    # Patch provided by resi147.
    # See the thread: special characters in MacOSX, like '@'.
    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '€',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            tkKey = stroke = darwinmap[tkKey]
            
    char = ch
    # Auxiliary info.
    x      = hasattr(event,'x') and event.x or 0
    y      = hasattr(event,'y') and event.y or 0
    # Support for fastGotoNode plugin
    x_root = hasattr(event,'x_root') and event.x_root or 0
    y_root = hasattr(event,'y_root') and event.y_root or 0
    
    # Call the base class.
    # return leoGui.leoGui.create_key_event(self,c,char,stroke,w,
        # x=x,y=y,x_root=x_root,y_root=y_root)

    return leoGui.leoKeyEvent(c,char,stroke,w,x,y,x_root,y_root)

    # g.trace('qt.leoKeyEvent: %s' % repr(self))
.. @+node:ekr.20110605121601.18541: *7* isSpecialOverride
def isSpecialOverride (self,tkKey,ch):

    '''Return True if tkKey is a special Tk key name.
    '''

    return tkKey or ch in self.flashers
.. @+node:ekr.20110605121601.18542: *7* toStroke
def toStroke (self,tkKey,ch):
    
    '''Convert the official tkKey name to a stroke.'''

    trace = False and not g.unitTesting
    k = self.c.k ; s = tkKey

    table = (
        ('Alt-','Alt+'),
        ('Ctrl-','Ctrl+'),
        ('Control-','Ctrl+'),
        # Use Alt+Key-1, etc.  Sheesh.
        # ('Key-','Key+'),
        ('Shift-','Shift+')
    )
    for a,b in table:
        s = s.replace(a,b)

    if trace: g.trace('tkKey',tkKey,'-->',s)
    return s
.. @+node:ekr.20110605121601.18543: *7* toTkKey & helpers (must not change!)
def toTkKey (self,event):
    
    '''Return tkKey,ch,ignore:
        
    tkKey: the Tk spelling of the event used to look up
           bindings in k.masterGuiBindingsDict.
           **This must not ever change!**
           
    ch:    the insertable key, or ''.
    
    ignore: True if the key should be ignored.
            This is **not** the same as 'not ch'.
    '''

    mods = self.qtMods(event)

    keynum,text,toString,ch = self.qtKey(event)

    tkKey,ch,ignore = self.tkKey(
        event,mods,keynum,text,toString,ch)

    return tkKey,ch,ignore
.. @+node:ekr.20110605121601.18544: *8* qtKey
def qtKey (self,event):

    '''Return the components of a Qt key event.

    Modifiers are handled separately.
    
    Return keynum,text,toString,ch
    
    keynum: event.key()
    ch:     g.u(chr(keynum)) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the stroke.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    '''

    trace = False and not g.unitTesting
    keynum = event.key()
    text   = event.text() # This is the unicode text.

    qt = QtCore.Qt
    d = {
        qt.Key_Shift:   'Key_Shift',
        qt.Key_Control: 'Key_Control',  # MacOS: Command key
        qt.Key_Meta:	'Key_Meta',     # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Alt:	    'Key_Alt',	 
        qt.Key_AltGr:	'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
    }

    if d.get(keynum):
        toString = d.get(keynum)
    else:
        toString = QtGui.QKeySequence(keynum).toString()

    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''

    try:
        ch = g.u(ch1)
    except UnicodeError:
        ch = ch1

    text     = g.u(text)
    toString = g.u(toString)

    if trace and self.keyIsActive:
        mods = '+'.join(self.qtMods(event))
        g.trace(
            'keynum %7x ch %3s toString %s %s' % (
            keynum,repr(ch),mods,repr(toString)))

    return keynum,text,toString,ch
.. @+node:ekr.20110605121601.18545: *8* qtMods
def qtMods (self,event):

    '''Return the text version of the modifiers of the key event.'''

    modifiers = event.modifiers()

    # The order of this table is significant.
    # It must the order of modifiers in bindings
    # in k.masterGuiBindingsDict

    qt = QtCore.Qt
    
    if sys.platform.startswith('darwin'):
        # Yet another MacOS hack:
        table = (
            (qt.AltModifier,     'Alt'), # For Apple keyboard.
            (qt.MetaModifier,    'Alt'), # For Microsoft keyboard.
            (qt.ControlModifier, 'Control'),
            # No way to generate Meta.
            (qt.ShiftModifier,   'Shift'),
        )
        
    else:
        table = (
            (qt.AltModifier,     'Alt'),
            (qt.ControlModifier, 'Control'),
            (qt.MetaModifier,    'Meta'),
            (qt.ShiftModifier,   'Shift'),
        )

    mods = [b for a,b in table if (modifiers & a)]
    #g.trace(mods)

    return mods
.. @+node:ekr.20110605121601.18546: *8* tkKey & helper
def tkKey (self,event,mods,keynum,text,toString,ch):

    '''Carefully convert the Qt key to a 
    Tk-style binding compatible with Leo's core
    binding dictionaries.'''

    trace = False and not g.unitTesting
    ch1 = ch # For tracing.
    use_shift = (
        'Home','End','Tab',
        'Up','Down','Left','Right',
        'Next','Prior', # 2010/01/10: Allow Shift-PageUp and Shift-PageDn.
        # 2011/05/17: Fix bug 681797.
        # There is nothing 'dubious' about these provided that they are bound.
        # If they are not bound, then weird characters will be inserted.
        'Delete','Ins','Backspace',
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    )

    # Convert '&' to 'ampersand', etc.
    # *Do* allow shift-bracketleft, etc.
    ch2 = self.char2tkName(ch or toString)
    if ch2: ch = ch2 
    if not ch: ch = ''

    if 'Shift' in mods:
        if trace: g.trace(repr(ch))
        if len(ch) == 1 and ch.isalpha():
            mods.remove('Shift')
            ch = ch.upper()
        elif len(ch) > 1 and ch not in use_shift:
            # Experimental!
            mods.remove('Shift')
        # 2009/12/19: Speculative.
        # if ch in ('parenright','parenleft','braceright','braceleft'):
            # mods.remove('Shift')
    elif len(ch) == 1:
        ch = ch.lower()

    if ('Alt' in mods or 'Control' in mods) and ch and ch in string.digits:
        mods.append('Key')

    # *Do* allow bare mod keys, so they won't be passed on.
    tkKey = '%s%s%s' % ('-'.join(mods),mods and '-' or '',ch)

    if trace: g.trace(
        'text: %s toString: %s ch1: %s ch: %s' % (
        repr(text),repr(toString),repr(ch1),repr(ch)))

    ignore = not ch # Essential
    ch = text or toString
    return tkKey,ch,ignore
.. @+node:ekr.20110605121601.18547: *9* char2tkName
char2tkNameDict = {
    # Part 1: same as k.guiBindNamesDict
    "&" : "ampersand",
    "^" : "asciicircum",
    "~" : "asciitilde",
    "*" : "asterisk",
    "@" : "at",
    "\\": "backslash",
    "|" : "bar",
    "{" : "braceleft",
    "}" : "braceright",
    "[" : "bracketleft",
    "]" : "bracketright",
    ":" : "colon",  
    "," : "comma",
    "$" : "dollar",
    "=" : "equal",
    "!" : "exclam",
    ">" : "greater",
    "<" : "less",
    "-" : "minus",
    "#" : "numbersign",
    '"' : "quotedbl",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright", 
    "%" : "percent",
    "." : "period",     
    "+" : "plus",
    "?" : "question",
    "`" : "quoteleft",
    ";" : "semicolon",
    "/" : "slash",
    " " : "space",      
    "_" : "underscore",
    # Part 2: special Qt translations.
    'Backspace':'BackSpace',
    'Backtab':  'Tab', # The shift mod will convert to 'Shift+Tab',
    'Esc':      'Escape',
    'Del':      'Delete',
    'Ins':      'Insert', # was 'Return',
    # Comment these out to pass the key to the QTextWidget.
    # Use these to enable Leo's page-up/down commands.
    'PgDown':    'Next',
    'PgUp':      'Prior',
    # New entries.  These simplify code.
    'Down':'Down','Left':'Left','Right':'Right','Up':'Up',
    'End':'End',
    'F1':'F1','F2':'F2','F3':'F3','F4':'F4','F5':'F5',
    'F6':'F6','F7':'F7','F8':'F8','F9':'F9',
    'F10':'F10','F11':'F11','F12':'F12',
    'Home':'Home',
    # 'Insert':'Insert',
    'Return':'Return',
    # 'Tab':'Tab',
    'Tab':'\t', # A hack for QLineEdit.
    # Unused: Break, Caps_Lock,Linefeed,Num_lock
}

# Called only by tkKey.

def char2tkName (self,ch):
    val = self.char2tkNameDict.get(ch)
    # g.trace(repr(ch),repr(val))
    return val
.. @+node:ekr.20110605121601.18548: *7* traceEvent
def traceEvent (self,obj,event,tkKey,override):

    if g.unitTesting: return

    c = self.c ; e = QtCore.QEvent
    keys = True ; traceAll = True 
    eventType = event.type()

    show = [
        # (e.Enter,'enter'),(e.Leave,'leave'),
        # (e.FocusIn,'focus-in'),(e.FocusOut,'focus-out'),
        # (e.MouseMove,'mouse-move'),
        (e.MouseButtonPress,'mouse-dn'),
        (e.MouseButtonRelease,'mouse-up'),
    ]

    if keys:
        show2 = [
            (e.KeyPress,'key-press'),
            (e.KeyRelease,'key-release'),
            (e.ShortcutOverride,'shortcut-override'),
        ]
        show.extend(show2)

    ignore = (
        1,16,67,70,
        e.ChildPolished,
        e.DeferredDelete,
        e.DynamicPropertyChange,
        e.Enter,e.Leave,
        e.FocusIn,e.FocusOut,
        e.FontChange,
        e.Hide,e.HideToParent,
        e.HoverEnter,e.HoverLeave,e.HoverMove,
        e.LayoutRequest,
        e.MetaCall,e.Move,e.Paint,e.Resize,
        e.MouseMove,
        #e.MouseButtonPress,e.MouseButtonRelease,
        e.PaletteChange,
        e.ParentChange,
        e.Polish,e.PolishRequest,
        e.Show,e.ShowToParent,
        e.StyleChange,
        e.ToolTip,
        e.WindowActivate,e.WindowDeactivate,
        e.WindowBlocked,e.WindowUnblocked,
        e.ZOrderChange,
    )

    for val,kind in show:
        if eventType == val:
            g.trace(
                '%5s %18s in-state: %5s key: %s override: %s: obj: %s' % (
                self.tag,kind,repr(c.k.inState()),tkKey,override,obj))
            return

    if traceAll and eventType not in ignore:
        g.trace('%3s:%s obj:%s' % (eventType,'unknown',obj))
.. @+node:ekr.20110605121601.18549: *7* traceFocus
def traceFocus (self,eventType,obj):

    ev = QtCore.QEvent

    table = (
        (ev.FocusIn,        'focus-in'),
        (ev.FocusOut,       'focus-out'),
        (ev.WindowActivate, 'activate'),
        (ev.WindowDeactivate,'deactivate'),
    )

    for evKind,kind in table:
        if eventType == evKind:
            g.trace('%11s %s %s %s' % (
                (kind,id(obj),
                # event.reason(),
                obj.objectName(),obj)))
                # g.app.gui.widget_name(obj) or obj)))

    # else: g.trace('unknown kind: %s' % eventType)
.. @+node:ekr.20110605121601.18847: *6* create_key_event (leoGui) (new)
def create_key_event (self,c,char,stroke,w,x=None,y=None,x_root=None,y_root=None):
    
    # if not char:
        # char = stroke # The value before calling shortcutFromSetting.

    stroke = c.k.shortcutFromSetting(stroke)

    return leoKeyEvent(c,char,stroke,w,x,y,x_root,y_root)
.. @+node:ekr.20110605195119.16937: *6* create_key_event (leoQtEventFilter) (new)
def create_key_event (self,event,c,w,ch,tkKey,stroke):

    trace = False and not g.unitTesting

    if trace: g.trace('ch: %s, tkKey: %s, stroke: %s' % (
        repr(ch),repr(tkKey),repr(stroke)))

    # Last minute-munges to char.
    if tkKey in ('Return','Tab','Escape',
        'Linefeed','BackSpace', ####
    ): # 'Ins'
        ch = tkKey
    
    stroke = stroke.replace('\t','Tab')
    tkKey = tkKey.replace('\t','Tab')

    # Patch provided by resi147.
    # See the thread: special characters in MacOSX, like '@'.
    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '€',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            tkKey = stroke = darwinmap[tkKey]
            
    char = ch
    # Auxiliary info.
    x      = hasattr(event,'x') and event.x or 0
    y      = hasattr(event,'y') and event.y or 0
    # Support for fastGotoNode plugin
    x_root = hasattr(event,'x_root') and event.x_root or 0
    y_root = hasattr(event,'y_root') and event.y_root or 0
    
    # Call the base class.
    # return leoGui.leoGui.create_key_event(self,c,char,stroke,w,
        # x=x,y=y,x_root=x_root,y_root=y_root)

    return leoGui.leoKeyEvent(c,char,stroke,w,x,y,x_root,y_root)

    # g.trace('qt.leoKeyEvent: %s' % repr(self))
.. @+node:ekr.20061031131434.162: *6* generalModeHandler (changed)
def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = False or c.config.getBool('trace_modes')

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return # (for Tk) 'break'
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
        return # (for Tk) 'break'
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            savedModeName = k.inputModeName # Remember this: it may be cleared.
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                # event = g.Bunch(widget = k.modeWidget)
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                return # (for Tk) 'break'
            if nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --> set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                if g.app.quitting or not c.exists: return # (for Tk) 'break'

    return # (for Tk) 'break'
.. @+node:ekr.20110606004638.16929: *6* k.stroke2char (new)
def stroke2char (self,stroke):
    
    '''Convert a stroke to an (insertable) char.
    
    This method allows Leo to use strokes everywhere.
    
    '''
    
    trace = False and not g.unitTesting
    k = self ; s = stroke
    
    if not s:
        return ''
    
    # Allow bare angle brackets for unit tests.
    if s.startswith('<') and s.endswith('>'):
        s = s[1:-1]
        
    if len(s) == 0:
        return ''
        
    if len(s) == 1:
        return s
        
    for z in ('Alt','Ctrl','Command','Meta'):
        if s.find(z) != -1:            
            return ''
    
    if 0: # Convert the gang of four:
        d = { 'BackSpace':'\b','Lineend':'\r','Return':'\n','Tab':'\t' }
        ch = d.get(s)
        if d: return ch
    else:
        if s == 'Tab':
            return '\t'
        # if s == 'BackSpace':
            # return '\b'
            
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke),repr(ch))
        return ch
    
    # A much-simplified form of code in k.shortcutFromSetting.
    shift = s.find('Shift+') > -1 or s.find('Shift-') > -1
    s = s.replace('Shift+','').replace('Shift-','')
    
    last = s #  Everything should have been stripped.
    
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    
    val = g.choose(len(s)==1,s,'')

    if trace: g.trace(repr(stroke),repr(val)) # 'shift',shift,
    return val
.. @+node:ekr.20110606001347.16927: *4* Important: 3
.. @+node:ekr.20110604043410.17850: *5* topics to discuss
@nocolor-node

- <attr>

- patch command

- macros
.. @+node:ekr.20110524141405.18370: *5* Get macros working well
.. @+node:ekr.20110528034751.18278: *6* Add apropos-macros
.. @+node:ekr.20060628103226.2: *6* Alt-x handlers should add to lossage
Probably useful as part of macro handling.
.. @+node:ekr.20110527084258.18378: *5* New file format
@nocolor-node

Stuff that got left out:
    
- Use uuid's?

- Remove spaces from user names.
.. @+node:ekr.20110427135155.14306: *6* Add <attr> elements to .leo files
@language rest

- <attr> solves pickle problem.
.. @+node:ekr.20110414065052.6100: *6* * Treat gnx's as strings: don't parse them
http://mail.google.com/mail/#inbox/12f3d4950fbabeea
.. @+node:ekr.20101123131018.5842: *6* * Don't save expansion bits in uA if not saving expansion bits
@bool put_expansion_bits_in_leo_files = False

It's illogical to save bits in uA's if they aren't save in in the <v> elements.
.. @+node:ekr.20110421132230.6107: *6* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *6* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110415173840.6098: *6* new uA's
.. @+node:ekr.20040701065235.2: *7* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *7* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *7* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *7* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20110414164347.6082: *6* Reference for json stuff
.. @+node:ekr.20031218072017.1997: *7* scanGnx
def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
.. @+node:ekr.20060919104530: *7* Sax (reading)
.. @+node:ekr.20090525144314.6526: *8* cleanSaxInputString
def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
.. @+node:ekr.20060919110638.5: *8* fc.createSaxChildren & helpers
def createSaxChildren (self, sax_node, parent_v):

    c = self.c
    trace = False and not g.unitTesting # and c.shortFileName().find('small') > -1
    children = []

    for sax_child in sax_node.children:
        tnx = sax_child.tnx
        v = self.gnxDict.get(tnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.createSaxVnode(sax_child,parent_v,v=v)   
        else:
            v = self.createSaxVnode(sax_child,parent_v)
            self.createSaxChildren(sax_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace: g.trace(
            '*** added parent',parent_v,'to',child,
            'len(child.parents)',len(child.parents))

    return children
.. @+node:ekr.20060919110638.7: *9* fc.createSaxVnode & helpers
def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') > -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
.. @+node:ekr.20060919110638.8: *10* handleTnodeSaxAttributes
def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
.. @+node:ekr.20061004053644: *10* handleVnodeSaxAttributes
# The native attributes of <v> elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
.. @+node:ekr.20060919110638.2: *8* dumpSaxTree
def dumpSaxTree (self,root,dummy):

    if not root:
        g.pr('dumpSaxTree: empty tree')
        return
    if not dummy:
        root.dump()
    for child in root.children:
        self.dumpSaxTree(child,dummy=False)
.. @+node:ekr.20061003093021: *8* getSaxUa
def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a <v> or <t> element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if type(val) == type(''):
            return val
        elif type(val) == type(b''):
            # 2011/05/26.
            return g.toUnicode(val)

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
.. @+node:ekr.20060919110638.14: *8* parse_leo_file
def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the <?xml> element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
.. @+node:ekr.20060919110638.3: *8* readSaxFile
def readSaxFile (self,theFile,fileName,silent,inClipboard,reassignIndices,s=None):

    dump = False and not g.unitTesting
    fc = self ; c = fc.c

    # Pass one: create the intermediate nodes.
    saxRoot = fc.parse_leo_file(theFile,fileName,
        silent=silent,inClipboard=inClipboard,s=s)

    if dump: fc.dumpSaxTree(saxRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    if saxRoot:
        parent_v = c.hiddenRootNode
        children = fc.createSaxChildren(saxRoot,parent_v)
        assert c.hiddenRootNode.children == children
        v = children and children[0] or None
        return v
    else:
        return None
.. @+node:ekr.20060919110638.11: *8* resolveTnodeLists
def resolveTnodeLists (self):

    trace = False and not g.unitTesting
    c = self.c

    for p in c.all_unique_positions():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                v = self.gnxDict.get(index)
                if v:
                    if trace: g.trace(tnx,v)
                    result.append(v)
                else:
                    g.trace('*** No vnode for %s' % tnx)
            if result:
                p.v.tnodeList = result
                # g.trace('*** tnodeList for',p.h,result)
            delattr(p.v,'tempTnodeList')
.. @+node:ekr.20080805132422.3: *8* resolveArchivedPosition  (New in Leo 4.5)
def resolveArchivedPosition(self,archivedPosition,root_v):

    '''Return a vnode corresponding to the archived position relative to root node root_v.'''

    def oops (message):
        if not g.app.unitTesting:
            g.es_print('bad archived position: %s' % (message),color='red')

    try:
        aList = [int(z) for z in archivedPosition.split('.')]
        aList.reverse()
    except Exception:
        return oops('"%s"' % archivedPosition)

    if not aList:
        return oops('empty')

    last_v = root_v
    n = aList.pop()
    if n != 0:
        return oops('root index="%s"' % n )

    while aList:
        n = aList.pop()
        children = last_v.children
        if n < len(children):
            last_v = children[n]
        else:
            return oops('bad index="%s", len(children)="%s"' % (n,len(children)))

    return last_v
.. @+node:ekr.20060919110638.13: *8* setPositionsFromVnodes & helper (sax read)
def setPositionsFromVnodes (self):

    trace = False and not g.unitTesting
    c = self.c ; p = c.rootPosition()
    current,str_pos = None,None

    use_db = g.enableDB and c.mFileName
    if use_db:
        str_pos = c.cacher.getCachedStringPosition()

    if not str_pos:
        d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
        if d: str_pos = d.get('str_leo_pos')
        if trace: g.trace('from p.v.u',str_pos)

    if str_pos:
        current = self.archivedPositionToPosition(str_pos)

    c.setCurrentPosition(current or c.rootPosition())
.. @+node:ekr.20061006104837.1: *9* archivedPositionToPosition
def archivedPositionToPosition (self,s):

    c = self.c
    s = g.toUnicode(s) # 2011/02/25
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level < len(aList):
        i = aList[level]
        while i > 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level < len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
.. @+node:ekr.20090218115025.3: *6* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20090601083544.6051: *5* Add expand_noweb_references for rst3 plugin
http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
.. @+node:ekr.20090601083544.6052: *6* post
I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  <<code fragment>>

Unfortunately, <<code fragment>> will not be expanded. Furthermore, in order to
get to this work, I should have <<code fragment>> under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
.. @+node:ekr.20110605212009.16932: *4* Minor bugs: 5
.. @+node:ekr.20110605065044.17008: *5* Fix chapters problems
http://groups.google.com/group/leo-editor/browse_thread/thread/3f15a855ca38b26e

.. @+node:ekr.20110604182206.16760: *5* alt-ctrl-keys abort the find command!
.. @+node:ekr.20110604182206.16757: *5* regex word-only does not work
.. @+node:ekr.20110604043410.16734: *5* Regularize command names
For abbreviations, macros, registers, etc.

Look for the getPublicCommands methods in leoEditCommands.py
.. @+node:ekr.20110605121601.17012: *5* On Mac: change qttabs to qt
.. @+node:ekr.20040329094003: *4* Apply patch command
.. @+node:ekr.20110604043410.17848: *5* Script
import leo.extensions.patch_11_01 as patch

fn = 'xyzzy.patch'

if g.os_path_exists(fn):
    patch.fromfile(fn)
else:
    g.es_print('not found:',fn)
.. @+node:ekr.20110604043410.17824: *5* patch-11.01.py (study only)
""" Patch utility to apply unified diffs

    Brute-force line-by-line non-recursive parsing 

    Copyright (c) 2008-2011 anatoly techtonik
    Available under the terms of MIT license

    Project home: http://code.google.com/p/python-patch/

    $Id: patch.py 117 2011-01-09 16:38:03Z techtonik $
    $HeadURL: https://python-patch.googlecode.com/svn/trunk/patch.py $
"""

@language python
@tabwidth -2

__author__ = "techtonik.rainforce.org"
__version__ = "11.01"

<< imports >>
<< global data >>

@others

if __name__ == "__main__":
  main()
.. @+node:ekr.20110604043410.17843: *6* << imports >>

import copy
import logging
import re
# cStringIO doesn't support unicode in 2.5
from StringIO import StringIO
import urllib2

from os.path import exists, isfile, abspath
from os import unlink
.. @+node:ekr.20110604043410.17844: *6* << global data >>
# Logging is controlled by "python_patch" logger

debugmode = False
logger = logging.getLogger("python_patch")
loghandler = logging.StreamHandler()
logger.addHandler(loghandler)
debug = logger.debug
info = logger.info
warning = logger.warning

#: disable library logging by default
logger.setLevel(logging.CRITICAL)

# constants for patch types

DIFF = PLAIN = "plain"
HG = MERCURIAL = "mercurial"
SVN = SUBVERSION = "svn"
.. @+node:ekr.20110604043410.17845: *6* top-level
.. @+node:ekr.20110604043410.17826: *7* fromfile
def fromfile(filename):
  """ Parse patch file and return Patch() object
  """
  debug("reading %s" % filename)
  fp = open(filename, "rb")
  patch = Patch(fp)
  fp.close()
  return patch
.. @+node:ekr.20110604043410.17827: *7* fromstring
def fromstring(s):
  """ Parse text string and return Patch() object
  """
  return Patch( StringIO(s) )
.. @+node:ekr.20110604043410.17828: *7* fromurl
def fromurl(url):
  """ Read patch from URL
  """
  return Patch( urllib2.urlopen(url) )
.. @+node:ekr.20110604043410.17829: *6* class Hunk
class Hunk(object):

  """ Parsed hunk data container (hunk starts with @@ -R +R @@) """
  
  @others
.. @+node:ekr.20110604043410.17830: *7* __init__
def __init__(self):

  self.startsrc=None #: line count starts with 1
  self.linessrc=None
  self.starttgt=None
  self.linestgt=None
  self.invalid=False
  self.text=[]
.. @+node:ekr.20110604043410.17831: *7* copy
def copy(self):
  
  return copy.copy(self)
.. @+node:ekr.20110604043410.17847: *7* apply
#  def apply(self, estream):
#    """ write hunk data into enumerable stream
#        return strings one by one until hunk is
#        over
#
#        enumerable stream are tuples (lineno, line)
#        where lineno starts with 0
#    """
#    pass
.. @+node:ekr.20110604043410.17832: *6* class Patch
class Patch(object):

  @others
.. @+node:ekr.20110604043410.17833: *7* __init__
def __init__(self, stream=None):

  # define Patch data members
  # table with a row for every source file

  #: list of source filenames
  self.source=None
  self.target=None
  #: list of lists of hunks
  self.hunks=None
  #: file endings statistics for every hunk
  self.hunkends=None
  #: headers for each file
  self.header=None

  #: patch type - one of constants
  self.type = None

  if stream:
    self.parse(stream)
.. @+node:ekr.20110604043410.17834: *7* copy
def copy(self):
  
  return copy.copy(self)
.. @+node:ekr.20110604043410.17835: *7* parse & helper class
def parse(self, stream):
  """ parse unified diff """
  self.header = []

  self.source = []
  self.target = []
  self.hunks = []
  self.hunkends = []

  lineends = dict(lf=0, crlf=0, cr=0)
  nextfileno = 0
  nexthunkno = 0    #: even if index starts with 0 user messages number hunks from 1

  # hunkinfo variable holds parsed values, hunkactual - calculated
  hunkinfo = Hunk()
  hunkactual = dict(linessrc=None, linestgt=None)
  
  @others # Define class wraumerate.

  # define states (possible file regions) that direct parse flow
  headscan  = True  # start with scanning header
  filenames = False # lines starting with --- and +++

  hunkhead = False  # @@ -R +R @@ sequence
  hunkbody = False  #
  hunkskip = False  # skipping invalid hunk mode

  hunkparsed = False # state after successfully parsed hunk

  # regexp to match start of hunk, used groups - 1,3,4,6
  re_hunk_start = re.compile("^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))?")
  
  # start of main cycle
  # each parsing block already has line available in fe.line
  fe = wrapumerate(stream)
  while fe.next():

    # -- deciders: these only switch state to decide who should process
    # --           line fetched at the start of this cycle
    if hunkparsed:
      hunkparsed = False
      if re_hunk_start.match(fe.line):
          hunkhead = True
      elif fe.line.startswith("--- "):
          filenames = True
      else:
          headscan = True
    # -- ------------------------------------

    # read out header
    if headscan:
      header = ''
      while not fe.is_empty and not fe.line.startswith("--- "):
          header += fe.line
          fe.next()
      if fe.is_empty:
          if len(self.source) == 0:
            warning("warning: no patch data is found")
          else:
            info("%d unparsed bytes left at the end of stream" % len(header))
          # this is actually a loop exit
          continue
      self.header.append(header)

      headscan = False
      # switch to filenames state
      filenames = True

    line = fe.line
    lineno = fe.lineno

    # hunkskip and hunkbody code skipped until definition of hunkhead is parsed
    if hunkbody:
      # process line first
      if re.match(r"^[- \+\\]", line):
          # gather stats about line endings
          if line.endswith("\r\n"):
            self.hunkends[nextfileno-1]["crlf"] += 1
          elif line.endswith("\n"):
            self.hunkends[nextfileno-1]["lf"] += 1
          elif line.endswith("\r"):
            self.hunkends[nextfileno-1]["cr"] += 1
            
          if line.startswith("-"):
            hunkactual["linessrc"] += 1
          elif line.startswith("+"):
            hunkactual["linestgt"] += 1
          elif not line.startswith("\\"):
            hunkactual["linessrc"] += 1
            hunkactual["linestgt"] += 1
          hunkinfo.text.append(line)
          # todo: handle \ No newline cases
      else:
          warning("invalid hunk no.%d at %d for target file %s" % (nexthunkno, lineno+1, self.target[nextfileno-1]))
          # add hunk status node
          self.hunks[nextfileno-1].append(hunkinfo.copy())
          self.hunks[nextfileno-1][nexthunkno-1]["invalid"] = True
          # switch to hunkskip state
          hunkbody = False
          hunkskip = True

      # check exit conditions
      if hunkactual["linessrc"] > hunkinfo.linessrc or hunkactual["linestgt"] > hunkinfo.linestgt:
          warning("extra lines for hunk no.%d at %d for target %s" % (nexthunkno, lineno+1, self.target[nextfileno-1]))
          # add hunk status node
          self.hunks[nextfileno-1].append(hunkinfo.copy())
          self.hunks[nextfileno-1][nexthunkno-1]["invalid"] = True
          # switch to hunkskip state
          hunkbody = False
          hunkskip = True
      elif hunkinfo.linessrc == hunkactual["linessrc"] and hunkinfo.linestgt == hunkactual["linestgt"]:
          # hunk parsed successfully
          self.hunks[nextfileno-1].append(hunkinfo.copy())
          # switch to hunkparsed state
          hunkbody = False
          hunkparsed = True

          # detect mixed window/unix line ends
          ends = self.hunkends[nextfileno-1]
          if ((ends["cr"]!=0) + (ends["crlf"]!=0) + (ends["lf"]!=0)) > 1:
            warning("inconsistent line ends in patch hunks for %s" % self.source[nextfileno-1])
          if debugmode:
            debuglines = dict(ends)
            debuglines.update(file=self.target[nextfileno-1], hunk=nexthunkno)
            debug("crlf: %(crlf)d  lf: %(lf)d  cr: %(cr)d\t - file: %(file)s hunk: %(hunk)d" % debuglines)
          # fetch next line
          continue

    if hunkskip:
      if re_hunk_start.match(line):
        # switch to hunkhead state
        hunkskip = False
        hunkhead = True
      elif line.startswith("--- "):
        # switch to filenames state
        hunkskip = False
        filenames = True
        if debugmode and len(self.source) > 0:
          debug("- %2d hunks for %s" % (len(self.hunks[nextfileno-1]), self.source[nextfileno-1]))

    if filenames:
      if line.startswith("--- "):
        if nextfileno in self.source:
          warning("skipping invalid patch for %s" % self.source[nextfileno])
          del self.source[nextfileno]
          # double source filename line is encountered
          # attempt to restart from this second line
        re_filename = "^--- ([^\t]+)"
        match = re.match(re_filename, line)
        # todo: support spaces in filenames
        if match:
          self.source.append(match.group(1).strip())
        else:
          warning("skipping invalid filename at line %d" % lineno)
          # switch back to headscan state
          filenames = False
          headscan = True
      elif not line.startswith("+++ "):
        if nextfileno in self.source:
          warning("skipping invalid patch with no target for %s" % self.source[nextfileno])
          del self.source[nextfileno]
        else:
          # this should be unreachable
          warning("skipping invalid target patch")
        filenames = False
        headscan = True
      else:
        if nextfileno in self.target:
          warning("skipping invalid patch - double target at line %d" % lineno)
          del self.source[nextfileno]
          del self.target[nextfileno]
          nextfileno -= 1
          # double target filename line is encountered
          # switch back to headscan state
          filenames = False
          headscan = True
        else:
          re_filename = "^\+\+\+ ([^\t]+)"
          match = re.match(re_filename, line)
          if not match:
            warning("skipping invalid patch - no target filename at line %d" % lineno)
            # switch back to headscan state
            filenames = False
            headscan = True
          else:
            self.target.append(match.group(1).strip())
            nextfileno += 1
            # switch to hunkhead state
            filenames = False
            hunkhead = True
            nexthunkno = 0
            self.hunks.append([])
            self.hunkends.append(lineends.copy())
            continue

    if hunkhead:
      match = re.match("^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))?", line)
      if not match:
        if nextfileno-1 not in self.hunks:
          warning("skipping invalid patch with no hunks for file %s" % self.target[nextfileno-1])
          # switch to headscan state
          hunkhead = False
          headscan = True
          continue
        else:
          # switch to headscan state
          hunkhead = False
          headscan = True
      else:
        hunkinfo.startsrc = int(match.group(1))
        hunkinfo.linessrc = 1
        if match.group(3): hunkinfo.linessrc = int(match.group(3))
        hunkinfo.starttgt = int(match.group(4))
        hunkinfo.linestgt = 1
        if match.group(6): hunkinfo.linestgt = int(match.group(6))
        hunkinfo.invalid = False
        hunkinfo.text = []

        hunkactual["linessrc"] = hunkactual["linestgt"] = 0

        # switch to hunkbody state
        hunkhead = False
        hunkbody = True
        nexthunkno += 1
        continue


  if not hunkparsed:
    if hunkskip:
      warning("warning: finished with warnings, some hunks may be invalid")
    elif headscan:
      if len(self.source) == 0:
        warning("error: no patch data found!")
        # ? sys.exit(-1)
      else: # extra data at the end of file
        pass 
    else:
      warning("error: patch stream is incomplete!")

  if debugmode and len(self.source) > 0:
      debug("- %2d hunks for %s" % (len(self.hunks[nextfileno-1]), self.source[nextfileno-1]))

  debug("total files: %d  total hunks: %d" % (len(self.source), sum(len(hset) for hset in self.hunks)))
.. @+node:ekr.20110604043410.17846: *8* class wrapumerate
class wrapumerate(enumerate):
  """Enumerate wrapper that uses boolean end of stream status instead of
  StopIteration exception, and properties to access line information.
  """

  def __init__(self, *args, **kwargs):
    # we don't call parent, it is magically created by __new__ method

    self._exhausted = False
    self._lineno = False     # after end of stream equal to the num of lines
    self._line = False       # will be reset to False after end of stream

  def next(self):
    """Try to read the next line and return True if it is available,
       False if end of stream is reached."""
    if self._exhausted:
      return False

    try:
      self._lineno, self._line = super(wrapumerate, self).next()
    except StopIteration:
      self._exhausted = True
      self._line = False
      return False
    return True

  @property
  def is_empty(self):
    return self._exhausted

  @property
  def line(self):
    return self._line

  @property
  def lineno(self):
    return self._lineno
.. @+node:ekr.20110604043410.17836: *7* apply
def apply(self):
  """ apply parsed patch
      return True on success
  """

  total = len(self.source)
  errors = 0
  for fileno, filename in enumerate(self.source):

    f2patch = filename
    if not exists(f2patch):
      f2patch = self.target[fileno]
      if not exists(f2patch):
        warning("source/target file does not exist\n--- %s\n+++ %s" % (filename, f2patch))
        errors += 1
        continue
    if not isfile(f2patch):
      warning("not a file - %s" % f2patch)
      errors += 1
      continue
    filename = f2patch

    debug("processing %d/%d:\t %s" % (fileno+1, total, filename))

    # validate before patching
    f2fp = open(filename)
    hunkno = 0
    hunk = self.hunks[fileno][hunkno]
    hunkfind = []
    hunkreplace = []
    validhunks = 0
    canpatch = False
    for lineno, line in enumerate(f2fp):
      if lineno+1 < hunk.startsrc:
        continue
      elif lineno+1 == hunk.startsrc:
        hunkfind = [x[1:].rstrip("\r\n") for x in hunk.text if x[0] in " -"]
        hunkreplace = [x[1:].rstrip("\r\n") for x in hunk.text if x[0] in " +"]
        #pprint(hunkreplace)
        hunklineno = 0

        # todo \ No newline at end of file

      # check hunks in source file
      if lineno+1 < hunk.startsrc+len(hunkfind)-1:
        if line.rstrip("\r\n") == hunkfind[hunklineno]:
          hunklineno+=1
        else:
          info("file %d/%d:\t %s" % (fileno+1, total, filename))
          info(" hunk no.%d doesn't match source file at line %d" % (hunkno+1, lineno))
          info("  expected: %s" % hunkfind[hunklineno])
          info("  actual  : %s" % line.rstrip("\r\n"))
          # not counting this as error, because file may already be patched.
          # check if file is already patched is done after the number of
          # invalid hunks if found
          # TODO: check hunks against source/target file in one pass
          #   API - check(stream, srchunks, tgthunks)
          #           return tuple (srcerrs, tgterrs)

          # continue to check other hunks for completeness
          hunkno += 1
          if hunkno < len(self.hunks[fileno]):
            hunk = self.hunks[fileno][hunkno]
            continue
          else:
            break

      # check if processed line is the last line
      if lineno+1 == hunk.startsrc+len(hunkfind)-1:
        debug(" hunk no.%d for file %s  -- is ready to be patched" % (hunkno+1, filename))
        hunkno+=1
        validhunks+=1
        if hunkno < len(self.hunks[fileno]):
          hunk = self.hunks[fileno][hunkno]
        else:
          if validhunks == len(self.hunks[fileno]):
            # patch file
            canpatch = True
            break
    else:
      if hunkno < len(self.hunks[fileno]):
        warning("premature end of source file %s at hunk %d" % (filename, hunkno+1))
        errors += 1

    f2fp.close()

    if validhunks < len(self.hunks[fileno]):
      if self._match_file_hunks(filename, self.hunks[fileno]):
        warning("already patched  %s" % filename)
      else:
        warning("source file is different - %s" % filename)
        errors += 1
    if canpatch:
      backupname = filename+".orig"
      if exists(backupname):
        warning("can't backup original file to %s - aborting" % backupname)
      else:
        import shutil
        shutil.move(filename, backupname)
        if self.write_hunks(backupname, filename, self.hunks[fileno]):
          info("successfully patched %d/%d:\t %s" % (fileno+1, total, filename))
          unlink(backupname)
        else:
          errors += 1
          warning("error patching file %s" % filename)
          shutil.copy(filename, filename+".invalid")
          warning("invalid version is saved to %s" % filename+".invalid")
          # todo: proper rejects
          shutil.move(backupname, filename)

  # todo: check for premature eof
  return (errors == 0)
.. @+node:ekr.20110604043410.17837: *7* can_patch
def can_patch(self, filename):
  """ Check if specified filename can be patched. Returns None if file can
  not be found among source filenames. False if patch can not be applied
  clearly. True otherwise.

  :returns: True, False or None
  """
  idx = self._get_file_idx(filename, source=True)
  if idx == None:
    return None
  return self._match_file_hunks(filename, self.hunks[idx])
.. @+node:ekr.20110604043410.17838: *7* _match_file_hunks
def _match_file_hunks(self, filepath, hunks):
  matched = True
  fp = open(abspath(filepath))

  class NoMatch(Exception):
    pass

  lineno = 1
  line = fp.readline()
  hno = None
  try:
    for hno, h in enumerate(hunks):
      # skip to first line of the hunk
      while lineno < h.starttgt:
        if not len(line): # eof
          debug("check failed - premature eof before hunk: %d" % (hno+1))
          raise NoMatch
        line = fp.readline()
        lineno += 1
      for hline in h.text:
        if hline.startswith("-"):
          continue
        if not len(line):
          debug("check failed - premature eof on hunk: %d" % (hno+1))
          # todo: \ No newline at the end of file
          raise NoMatch
        if line.rstrip("\r\n") != hline[1:].rstrip("\r\n"):
          debug("file is not patched - failed hunk: %d" % (hno+1))
          raise NoMatch
        line = fp.readline()
        lineno += 1

  except NoMatch:
    matched = False
    # todo: display failed hunk, i.e. expected/found

  fp.close()
  return matched
.. @+node:ekr.20110604043410.17839: *7* patch_stream
def patch_stream(self, instream, hunks):
  """ Generator that yields stream patched with hunks iterable
  
      Converts lineends in hunk lines to the best suitable format
      autodetected from input
  """

  # todo: At the moment substituted lineends may not be the same
  #       at the start and at the end of patching. Also issue a
  #       warning/throw about mixed lineends (is it really needed?)

  hunks = iter(hunks)

  srclineno = 1

  lineends = {'\n':0, '\r\n':0, '\r':0}
  def get_line():
    """
    local utility function - return line from source stream
    collecting line end statistics on the way
    """
    line = instream.readline()
      # 'U' mode works only with text files
    if line.endswith("\r\n"):
      lineends["\r\n"] += 1
    elif line.endswith("\n"):
      lineends["\n"] += 1
    elif line.endswith("\r"):
      lineends["\r"] += 1
    return line

  for hno, h in enumerate(hunks):
    debug("hunk %d" % (hno+1))
    # skip to line just before hunk starts
    while srclineno < h.startsrc:
      yield get_line()
      srclineno += 1

    for hline in h.text:
      # todo: check \ No newline at the end of file
      if hline.startswith("-") or hline.startswith("\\"):
        get_line()
        srclineno += 1
        continue
      else:
        if not hline.startswith("+"):
          get_line()
          srclineno += 1
        line2write = hline[1:]
        # detect if line ends are consistent in source file
        if sum([bool(lineends[x]) for x in lineends]) == 1:
          newline = [x for x in lineends if lineends[x] != 0][0]
          yield line2write.rstrip("\r\n")+newline
        else: # newlines are mixed
          yield line2write
   
  for line in instream:
    yield line
.. @+node:ekr.20110604043410.17840: *7* write_hunks
def write_hunks(self, srcname, tgtname, hunks):
  src = open(srcname, "rb")
  tgt = open(tgtname, "wb")

  debug("processing target file %s" % tgtname)

  tgt.writelines(self.patch_stream(src, hunks))

  tgt.close()
  src.close()
  return True
.. @+node:ekr.20110604043410.17841: *7* _get_file_idx
def _get_file_idx(self, filename, source=None):

  """ Detect index of given filename within patch.

      :param filename:
      :param source: search filename among sources (True),
                     targets (False), or both (None)
      :returns: int or None
  """
  filename = abspath(filename)
  if source == True or source == None:
    for i,fnm in enumerate(self.source):
      if filename == abspath(fnm):
        return i  
  if source == False or source == None:
    for i,fnm in enumerate(self.target):
      if filename == abspath(fnm):
        return i  


.. @+node:ekr.20110604043410.17842: *6* main
def main():
  
  from optparse import OptionParser
  from os.path import exists
  import sys

  opt = OptionParser(usage="1. %prog [options] unipatch-file\n"
                    "       2. %prog [options] http://host/patch",
                     version="python-patch %s" % __version__)
  opt.add_option("-q", "--quiet", action="store_const", dest="verbosity",
                                  const=0, help="print only warnings and errors", default=1)
  opt.add_option("-v", "--verbose", action="store_const", dest="verbosity",
                                  const=2, help="be verbose")
  opt.add_option("--debug", action="store_true", dest="debugmode", help="debug mode")
  (options, args) = opt.parse_args()

  if not args:
    opt.print_version()
    opt.print_help()
    sys.exit()
  debugmode = options.debugmode

  verbosity_levels = {0:logging.WARNING, 1:logging.INFO, 2:logging.DEBUG}
  loglevel = verbosity_levels[options.verbosity]
  logformat = "%(message)s"
  if debugmode:
    loglevel = logging.DEBUG
    logformat = "%(levelname)8s %(message)s"
  logger.setLevel(loglevel)
  loghandler.setFormatter(logging.Formatter(logformat))


  patchfile = args[0]
  urltest = patchfile.split(':')[0]
  if (':' in patchfile and urltest.isalpha()
      and len(urltest) > 1): # one char before : is a windows drive letter
    patch = fromurl(patchfile)
  else:
    if not exists(patchfile) or not isfile(patchfile):
      sys.exit("patch file does not exist - %s" % patchfile)
    patch = fromfile(patchfile)

  #pprint(patch)
  patch.apply() or sys.exit(-1)

  # todo: document and test line ends handling logic - patch.py detects proper line-endings
  #       for inserted hunks and issues a warning if patched file has incosistent line ends
.. @+node:ekr.20110527084258.18377: *4* Ashland sprint: 2
.. @+node:ekr.20110527084258.18374: *5*  Summary of the Ashland sprint
http://groups.google.com/group/leo-editor/browse_thread/thread/9b1dbebd56d50e14/d5a690127ddad38e
 
"Sprint" isn't really the correct term.  We wrote no code.  Instead,
we discussed what seemed to each of us as the most important
directions for Leo.

After much pleasant discussion, we reached agreement, dreaded or not,
on just about everything. I'll summarize the topics here, and
elaborate about file format issues in a separate thread.

1.  (Done) Make .leo files as standards-compliant as possible.

This will demonstrate to newbies that we have some sophistication re
web standards, and it will allow external tools to handle .leo files
in the easiest possible way.

I've delegated the design of this project to Kent.  I'll be in charge
of implementation.

2. Simplify and revise Leo's file format.

Details in a separate thread: some items deserve just a bit more
discussion.  In particular, we want the about-to-be-renamed <t>
elements to contain headline text so that <t> elements represent key/
value pairs directly.  The question is, should the about-to-be-renamed
<v> elements contain headline text (readable, but "denormalized")?

3. Support reading and writing Leo outlines in JSON format.

This will allow closer cooperation with databases and other tools.
I'll do this.

4. Complete the transition to Terry's free_layout plugin.

A. Place separate body editors in free_layout areas.  This should
*easy* to do!  Almost nothing changes in the code, but the visual
effect should be much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane)
and "untabified."  There are a few details to be handled, but nothing
major.

Terry and I will collaborate on this.

5. Add global search to the quicksearch plugin and to Leo's find
command.

6. (Abandoned) Add node-specific undo asap.

The present undo is almost useless after a few levels.  Node-specific
undo would be much more useful. This has been on the list forever.  It
should be done yesterday.

7.  Rejected direct support for .ini files instead of Leo's @settings
nodes.

After some discussion we decided that the present .ini importer should
suffice.  In other words, it seems like a bad idea to support .ini
settings *instead* of, or in *addition* to, .ini files.  However,
scripts or commands to import/export Leo settings to one or more .ini
files would be fine.

8.  Make uA's first class citizens.

There should be commands to get and set uA's.  This is easy to do:
it's just an oversight.

Summary
=======

Looking back on the discussions, I am struck once again by how minor
the suggestions are.  Most of these items can be done in a day or two,
or a week or two at most.  The conclusion is that Leo has reached a
mature state.

Kent, Terry, did I omit anything?  Misstate anything? 
.. @+node:ekr.20110528034751.18270: *6* Notes
- Viewrendered @html is a good way to learn/debug .css.

- Study blender interface.
.. @+node:ekr.20110528034751.18273: *5* Global search in Nav plugin?
.. @+node:ekr.20110528034751.18272: *5* Support for tabifying Leo's core panes
Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
.. @+node:ekr.20110531190516.19365: *4* Minor/Maybe: 4
@language rest

.. @+node:ekr.20100112051224.6226: *5* Vim-related: Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20110601105631.19373: *6* Simple vim bindings
.. @+node:ekr.20110601105631.19374: *7* Cursors
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
.. @+node:ekr.20110601105631.19375: *7* Enter insert mode after ctrl-h
.. @+node:ekr.20110601105631.19376: *7* Colorize headline text depending on state
.. @+node:ekr.20110601105631.19377: *7* colon destroys alt-x binding
This project reorganizes makeBindingFromCommandsDict
.. @+node:ekr.20110530063322.18333: *5* scala not colored properly
.. @+node:ekr.20110518103946.18179: *5* Add external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
.. @+node:ekr.20090801103907.6018: *5* Add entries to global dicts for more languages (waiting for requests)
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.

** Only c.getOpenWithExt uses app.language_extension_dict.

I'll wait until I get requests for particular language.
.. @+node:ekr.20110528103005.18323: *6* Found: extension_dict
.. @+node:ekr.20080819075811.13: *7* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
.. @+node:ekr.20090212054250.9: *7* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20031218072017.2824: *7* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
.. @+node:EKR.20040504150046.4: *7* g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', '', '')

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    ('', '<!--', '-->')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
.. @+node:ekr.20080811174246.1: *7* languageForExtension
def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
.. @+node:ekr.20031218072017.368: *6* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20110528103005.18319: *6* Script to global data structures from in modes/*.py files
import glob
import imp

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)
theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

print('-'*40,len(aList))
known_keys = list(g.app.language_delims_dict.keys())
known_keys.sort()
known = []
computed = {}
for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2.startswith('__'): continue
    # if name2 in known_keys:
        # known.append(name)
        # continue
    try:
        theFile, pathname, description = imp.find_module(name2,[theDir])
        m = imp.load_module(name2, theFile, pathname, description)
    except Exception:
        g.es_exception()
        m = None
    if m:
        aList2 = [m.properties.get(z)
            for z in ('lineComment','commentStart','commentEnd')
                if m.properties.get(z)]
        print('%-20s : "%s",' % (
            '"%s"' % (name2),
            ' '.join(aList2)))
        computed[name2] = ' '.join(aList2)
mismatches = 0
for z in known_keys:
    val = g.app.language_delims_dict.get(z)
    val2 = computed.get(z)
    if not val:
        print('oops: no val',z)
    elif not val2:
        print('oops: no val2',z)
    elif val != val2:
        mismatches += 1
        print('mismatch for %s' % z)
        print(repr(val))
        print(repr(val2))
print('%s total languages' % len(aList))
print('%s new languages' % (len(list(computed.keys())) - len(known_keys)))
print('%s mismatches' % mismatches)
print('%s known language: %s' % (len(known_keys),known_keys))
.. @+node:ekr.20110527225107.18351: *3* Vague
@language rest

**Important**: These items are not scheduled for any release. They will be done
only if there are specific requests for them.

Eventually, all these items will move to the dreaded to-do-later list.
.. @+node:ekr.20110529115328.18238: *4* Emacs related: 5
I'll do these if and and only if somebody asks for them.
.. @+node:ekr.20110529104352.18248: *5* Complete k.universalDispatche
.. @+node:ekr.20110529104352.18249: *5* Complete number-to-register command
.. @+node:ekr.20031218072017.753: *5* Emacs comint-mode
@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
.. @+node:ekr.20071004120359.2: *5* expand-region-abbrev
See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
.. @+node:ekr.20060628103226.3: *5* Make sure repeat counts work on basic editing commands
.. @+node:ekr.20110527225107.18352: *4* Maybe: 5
.. @+node:ekr.20090724081340.5987: *5* Improve recursive import script and @auto
Instead of adding an @ignore directive, it might be better
to change @auto to @@auto.

Should @auto be more lenient with C files?

Improve the recursive import script.
    - Minimize the path names
    - Option to include/exclude the @auto itself

.. @+node:ekr.20051110155735.1: *5* Improve Spell tab & spell checker
@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
.. @+node:ekr.20090907080624.6081: *6* Spell checker should check headlines
.. @+node:ekr.20101004092958.5914: *5* Write treepad scanner
@ treepad.py is from the treepad website
.. @+node:ekr.20101004092958.5939: *6* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

.. @+node:ekr.20101004092958.5940: *7* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
.. @+node:ekr.20101004092958.5941: *7* class Node
class Node:
    @others
.. @+node:ekr.20101004092958.5942: *8* __init__
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
.. @+node:ekr.20101004092958.5943: *8* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
.. @+node:ekr.20101004092958.5944: *8* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
.. @+node:ekr.20101004092958.5945: *8* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
.. @+node:ekr.20101004092958.5946: *8* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
.. @+node:ekr.20101004092958.5947: *8* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

.. @+node:ekr.20101004092958.5948: *7* class NodeReader
class NodeReader:
    @others
.. @+node:ekr.20101004092958.5949: *8* __init__
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
.. @+node:ekr.20101004092958.5950: *8* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
.. @+node:ekr.20101004092958.5951: *8* readstart
def readstart(self):
    self.expect(VERSION)
.. @+node:ekr.20101004092958.5952: *8* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

.. @+node:ekr.20101004092958.5953: *7* class TreeReader
class TreeReader:
    @others
.. @+node:ekr.20101004092958.5954: *8* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
.. @+node:ekr.20101004092958.5955: *8* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
.. @+node:ekr.20101004092958.5956: *8* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

.. @+node:ekr.20101004092958.5957: *7* class TreeWriter
class TreeWriter:
    @others
.. @+node:ekr.20101004092958.5958: *8* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
.. @+node:ekr.20101004092958.5959: *8* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

.. @+node:ekr.20101004092958.5960: *7* class Main
class Main:
    @others
.. @+node:ekr.20101004092958.5961: *8* __init__
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
.. @+node:ekr.20101004092958.5962: *8* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

.. @+node:ekr.20110520051220.18203: *5* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
.. @+node:ekr.20110525112110.18402: *4* Ideas: 4
.. @+node:ekr.20071001052501: *5* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
.. @+node:ekr.20101104191857.5820: *5* QWebView makes Leo a presentation tool
http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

.. @+node:ekr.20080802070659.11: *5* Make node attributes visible, and supported by Leo's core
.. @+node:ekr.20060227123536: *5* Tiddlywiki and related comments about rendering body text (Mulder)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
.. @+node:ekr.20101129095441.5963: *3* Improve screenshots page
.. @-all
.. @-leo
