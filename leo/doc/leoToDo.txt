.. @+leo-ver=5-thin
.. @+node:ekr.20100119205347.6015: * @file ../doc/leoToDo.txt
.. @@language rest # override the default .txt coloring.

.. @+all
.. @+node:ekr.20110609102702.16471: ** To do: 4.9.1
I am willing to fix bugs, but I would like to declare a moratorium on feature additions until 2012.
.. @+node:ekr.20110921132705.6960: *3* To do first
.. @+node:ekr.20110930174206.15470: *4* * Bring screen shots up to date
> While doing so I noted that on the sourceforge project
> page some screenshots are bit old, such as touting Tk.
>
> shows tk - http://webpages.charter.net/edreamleo/screen-shots.html
> uses @thin - http://webpages.charter.net/edreamleo/PCWindow.gif
> screenshots shows deprecated plugin manager -
> http://sourceforge.net/projects/leo/
.. @+node:ekr.20110918204916.6811: *4* * revise autocompletion docs based on recent posts
.. @+node:ekr.20110929074744.15474: *5* Autocompleter post
@language rest
@pagewidth 65

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass unless otherwise noted.

- The autoComplete method is the entry point. It will be called
  when autocompletion is enabled and the user types either a period
  or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       
.. @+node:ekr.20110929074744.15475: *6* Creating ctags data
On Sep 10, 8:36 am, "Edward K. Ream" <edream...@gmail.com> wrote:

> Later posts will discuss the following:
> 
> - Setting up to use ctags/codewise completion.

This section describes how to use Ville's codewise.py
module in leo\external folder.

**Note**: I've recently made a few changes to codewise.py. The
following discussion reflects the following changes:

- Changed docstring.

- The setup command does not crash if the ~/.ctags file already
  exist.
  
- The setup command does not call the init command, and thus does
  not delete ~/.codewise.db.
  
- Revised various print statements so they look better with Python 3.x.

**Important**: Leo's core contains all necessary autocompletion
code. In particular, enable *neither* the ctagscompleter.py
plugin *nor* the codewisecompleter.py plugin. I plan to remove
these plugins immediately, unless someone gives a good reason not
to do so.

**Important**: I've taken care to with the following
instructions, but there could be oversights or misunderstandings.
I would appreciate any corrections or additions.

Creating codewise/ctags data
============================

1. Make sure you have exuberant ctags (not just regular ctags)
   installed. It's an Ubuntu package, so its easy to install if
   you're using Ubuntu.
   
2. Execute the following commands from Leo's external/codewise.py
   module. **Note**: On Windows, you can use codewise.bat to
   execute these commands. For example::

        python <path to leo>\external\codewise.py %*
    
A. [Optional] Create a custom ~/.ctags file containing default
   configuration settings for ctags::
    
        codewise setup
        
    This command will leave the ~/.ctags file unchanged if it
    exists.  Othewise, the ``codewise setup`` command will
    create a ~/.ctags file containing the following defaults::
    
        --exclude=*.html
        --exclude=*.css
    
    See: http://ctags.sourceforge.net/ctags.html#FILES for more
    details about the .ctags file.
    
B. [Optional] Delete the existing ctags database in ~/.codewise.db::
   
        codewise init
        
C. Add ctags data to the existing ctags database::

        codewise parse <path to directory>
        
   You can add data from multiple sources by running
   the ``codewise parse`` command on multiple directories.
   
.. @+node:ekr.20110929074744.15476: *6* Using Leo's autocompleter (outline form)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
.. @+node:ekr.20110929074744.15477: *7* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15478: *7* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15479: *7* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15480: *7* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15481: *7* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15482: *6* Using Leo's autocompleter (COPY)
@language rest

Leo's autocompletion suggests **completions**, text may be valid in a given
point, or **context** in source code. For example, suppose the context is::

    os.path.s
    
That is, suppose the cursor follows ``os.path.s`` in the body pane. The valid
completions are all the members of Python's os.path module whose names start with 's',
namely::

    samefile
    sameopenfile
    sep
    split
    splitdrive
    splitext
    splitunc
    stat
    supports_unicode_filenames
    sys
    
Starting autocompletions
========================

There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autcompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.

Displaying autocompletions
==========================

How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.

Using the QCompleter
====================

When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.

Using the Log pane completer
============================

When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.

Showing docstrings
==================

Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15483: *7* Starting autocompletions
There are two ways to have Leo show autocompletions, manually and automatically.
You can use both at the same time.

**Manual autocompletion**: Leo will show autocompletions whenever you execute
the auto-complete-force (ctrl-space) command.

**Automatic autocompletion**: If (automatic) autocompletion is enabled, Leo will show completions
whenever you type a period in the body pane.

You can enable autocompletion in several ways:

1. By setting @bool enable_autocompleter_initially = True.

2. By using the toggle-autocompleter (Alt-1) command.
.. @+node:ekr.20110929074744.15484: *7* Displaying autocompletions
How Leo displays these completions depends on the setting::

    @bool use_qcompleter
    
True: Leo shows completions in the QCompleter popup window.
False: Leo shows completions in the log pane.
    


.. @+node:ekr.20110929074744.15485: *7* Using the QCompleter
When the ``@bool use_qcompleter`` setting is False, Leo shows all completions in a
popup window, regardless of how many completions there are. To **accept** a
completion, use the up and down arrows to select a completion, then type the
return key. To **cancel** completion, type the escape key. As an important
shortcut, if the popup window contains only one entry, you may accept a
completion by simply typing the return key.
.. @+node:ekr.20110929074744.15486: *7* Using the Log pane completer
When the ``@bool use_qcompleter`` setting is True, Leo shows completions in in
Leo's log pane. When there are more than 20 completions, Leo shows only the
characters that start a completions. For example, when completing ``os.path.``
the log pane will show::

    _ 17
    a 2
    b 1
    c 2
    d 3
    e 4
    g 5
    i 5
    j 1
    l 1
    n 2
    o 1
    p 2
    r 2
    s 10
    
To see the complete list, type the '!' character.  You will see::

    __all__
    __builtins__
    __cached__
    __doc__
    __file__
    __name__
    __package__
    _get_altsep
    _get_bothseps
    _get_colon
    _get_dot
    _get_empty
    _get_sep
    _get_special
    _getfileinformation
    _getfinalpathname
    _getfullpathname
    abspath
    altsep
    basename
    commonprefix
    curdir
    defpath
    devnull
    dirname
    exists
    ...

Typically, however, you would simply type one of the valid prefix characters.
For example, typing the letter 'a' would create the context ``os.path.a`` and
the log pane would show::

    abspath
    altsep
    
As you type, Leo enters the longest common prefix of all completions into the
body pane. Typing return, escape or ctrl-g (or any other alt or ctrl key) ends
completion.
.. @+node:ekr.20110929074744.15487: *7* Showing docstrings
Regardless of the setting of ``@bool use_qcompleter``,
typing '?' while autocompleting will show the docstring of
the present context.  For example, if the context is
``os.path.join``, typing '?' will show::

    Join two or more pathname components, inserting "\" as needed.
    If any component is an absolute path, all previous path components
    will be discarded.
    
It is not possible to copy the docstring from the log pane
when using the QCompleter because the QCompleter popup window is a modal dialog.
.. @+node:ekr.20110929074744.15488: *6* Code notes
Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.



.. @+node:ekr.20110929074744.15489: *6* Minor settings
Minor Autocompletion settings
=============================

These are found in leoSettings.leo: @settings-->Autocompleter

- @bool use_codewise = False

True: use codewise completions.
False: use Leo-specific completions.

- @bool use_qcompleter = True

True:  show completions in a QCompleter popup.
False: show completions in Leo's Completions tab.
This option has effect only when using the qt or qttabs gui's.

The following options specify minor user preferences: they have little or no effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15490: *6* Appearance
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

.. @+node:ekr.20110929074744.15491: *6* Codewise notes
Why the codewise module
=======================

- This module supports modern code completion for the Leo editor.

- Exuberant ctags is an excellent code scanner, but TAGS file
  lookup sucks for "find methods of this class".
  
- This module puts all data in a single file, ~/.codewise.db by
  default. In contrast, TAGS files can exist all over the file
  system.

- The code in codewise.py is usable as a python module, or a
  command line tool.


Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.
.. @+node:ekr.20110929074744.15492: *6* Performance
Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

.. @+node:ekr.20110929074744.15493: *6* Completions
os.path.splitdrive.d_rule
os.path.join
.. @+node:ekr.20110929074744.15494: *7* Docs
@language rest


Creating codewise/ctags data
============================

This is adapted from the thread:
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/ca01e7a803d2b546
"HOWTO: make Ville's autocompleter work.

1. Make sure you have exuberant ctags (not just regular ctags) installed.  It's an Ubuntu package, so it's easy to install if you're using Ubuntu.

2. All recent versions of Leo contain Ville's codewise module: leo/external/codewise.py

@pagewidth 60

Overview of the code
====================

All notes refer to methods in class AutoCompleterClass
unless otherwise noted.

- The autoComplete method is the entry point.  It will be called when autocompletion is enabled and the user types either a period or ctrl-space (


The legacy autocompleter is eval based.

 uses Leo-specific code to when editing specific .leo files: leoDocs.leo, leoPlugins.leo, etc.
       


Here are the contents of the discussion of autocompletion from the 4.9 release notes in LeoDocs.leo.  These should be folded into Leo's Users Guide: I'll do that today.

QQQQQ
 
Appearance
==========

There is little change to the legacy completer, except that
no text is highlighted in the body pane during completion.
This is calmer than before. Furthermore, there is no longer
any need for highlighting, because when the user types a
backspace the legacy completer now simply deletes a single
character instead of the highlighted text.

One minor change: the legacy completer now *does* insert
characters that do not match the start of any possible
completion. This is an experimental feature, but it might
play well with using codewise completions as a fallback to
Leo-related completions.

Function and design
===================

Both the legacy and new completer now work *exactly* the
same way, because they both use the AutoCompleterClass to
compute the list of completions.

The strict "stateless" requirement means that the
"intermediate" completions must be entered into the body
pane while completion is active. It works well as a visual
cue when using the tabbed completer: indeed, the tabbed
completer would be difficult to use without this cue.

The situation is slightly different with the qcompleter.
Adding code before the user accepts the completion might be
considered an "advanced" feature. However, it does have two
important advantages, especially when "chaining" across
periods: it indicates the status of the chaining and it
limits what must appear in the qcompleter window.

Codewise completions
====================

The codewise-oriented completions appear to work well. In
large part, this is due to adding the global "self."
completions to all class-related completions (kind ==
'class' in ac.get_codewise_completions). This looks like a
really good hack, and it eliminates the need for the
ContextSniffer class.

Performance
===========

Performance of Leo-related completions is *much* better than
before. The old code used Python's inspect module and was
horribly complex. The new code uses eval and is perfectly
straightforward.

The present codewise-related code caches completions for all
previously-seen prefixes. This dramatically speeds up
backspacing. Global caching is possible because completions
depend *only* on the present prefix, *not* on the presently
selected node. If ContextSniffer were used, completions
would depend on the selected node and caching would likely
be impractical. Despite these improvements, the performance
of codewise-oriented completions is noticeably slower than
Leo-related completions.

Performance notes
=================

The ac.get_cached_options cuts back the prefix until it
finds a cached prefix. ac.compute_completion_list then uses
this (perhaps-way-too-long-list) as a starting point, and
computes the final completion list by calling
g.itemsMatchingPrefixInList.

This may not be absolutely the fastest way, but it is much
simpler and more robust than attempting to do "prefix AI"
based on comparing old and new prefixes. Furthermore, this
scheme is completely independent of the how completions are
actually computed. The autocompleter now caches options
lists, regardless of whether using eval or codewise.

In most cases the scheme is extremely fast: calls to
get_completions replace calls to
g.itemsMatchingPrefixInList. However, for short prefixes,
the list that g.g.itemsMatchingPrefixInList scans can have
thousands of items. Scanning large lists can't be helped in
any case for short prefixes.

Happily, the new scheme is still *completely* stateless: the
completionDict does *not* define state (it is valid
everywhere) and no state variables had to be added. In
short, the new caching scheme is much better than before,
and it probably is close to optimal in most situations.

QQQQQ

Part 2: New documentation

As I reread the release notes, I see that they are too code-oriented for the general reader.  What is needed are the following:

1. A discussion of Autocompletion settings in 
.. @+node:ekr.20110929074744.15495: *8* Additional options
The following options specify minor user preferences: they have little or no
effect on the design or code of the autocompleter:

- @bool auto_tab_complete = False

True: Automatically extend the completed text to the longest common prefix of all completions.

- @bool autocomplete-brackets = False

True: When typing an opening bracket '(','[' or '{', immediately type the corresponding closing bracket.  To move past the closing bracket, just type it.

- @bool enable_calltips_initially = False

- @bool forbid_invalid_completions = False

True: Don't add characters during autocompletion that are not part of any computed completion.
.. @+node:ekr.20110929074744.15496: *7* Existing docs
@language rest
@pagewidth 65

Typing a period when @language python is in effect starts
autocompletion. Typing Return or Control-g (keyboard-quit) exits
autocompletion.

Autocompletion shows what may follow a period in code. (Actually
you can specify any character using the auto-complete shortcut
setting.) For example, after typing g. Leo will show a list of
all the global functions in leoGlobals.py. Autocompletion works
much like tab completion in the minibuffer. Unlike the
minibuffer, the presently selected completion appears directly in
the body pane.

A leading period brings up ‘Autocomplete Modules’. (The period
goes away.) You can also get any module by typing its name. If
more than 25 items would appear in the Autocompleter tab, Leo
shows only the valid starting characters. At this point, typing
an exclamation mark shows the complete list. Thereafter, typing
further exclamation marks toggles between full and abbreviated
modes.

If x is a list ‘x.!’ shows all its elements, and if x is a Python
dictionary, ‘x.!’ shows x.keys(). For example, ‘sys.modules.!’
Again, further exclamation marks toggles between full and
abbreviated modes.

During autocompletion, typing a question mark shows the docstring
for the object. For example: ‘g.app?’ shows the docstring for
g.app. This doesn’t work (yet) directly for Python globals, but
‘__builtin__.f?’ does. Example: ‘__builtin__.pow?’ shows the
docstring for pow.

Autocompletion works in the Find tab; you can use <Tab> to cycle
through the choices. The ‘Completion’ tab appears while you are
doing this; the Find tab reappears once the completion is
finished. Calltips

Calltips appear after you type an open parenthesis in code.
Calltips shows the expected arguments to a function or method.
Calltips work for any Python function or method, including
Python’s global functions. Typing Return or Control-g
(keyboard-quit) exits calltips.

Examples:

    ‘g.toUnicode(‘ gives ‘g.toUnicode(s, encoding, reportErrors=False’
    ‘c.widgetWantsFocusNow’ gives ‘c.widgetWantsFocusNow(w’
    ‘reduce(‘ gives ‘reduce(function, sequence[, initial]) -> value’

The calltips appear directly in the text and the argument list is highlighted so you can just type to replace it. The calltips appear also in the status line for reference after you have started to replace the args.

Options

Both autocompletion and calltips are initially enabled or disabled by the enable_autocompleter and enable_calltips settings in leoSettings.leo. You may enable or disable these features at any time with these commands: enable-auto-completer-command, enable-calltips-command, disable-auto-completer-command and disable-calltips-command.
The minibuffer

The mini-buffer is a text area at the bottom of the body pane. You use it like the Emacs mini-buffer to invoke commands by their so-called long name. The following commands affect the minibuffer:

    full-command: (default shortcut: Alt-x) Puts the focus in the minibuffer. Type a full command name, then hit <Return> to execute the command. Tab completion works, but not yet for file names.

    universal-argument: (default shortcut: Alt-u) Like Emacs Ctrl-u. Adds a repeat count for later command. Ctrl-u 999 a adds 999 a’s.
    keyboard-quit: (default shortcut: Ctrl-g) Exits any minibuffer mode and puts the focus in the body pane.

For example, to print a list of all commands type Alt-X print-commands <Return>.

The following sections list the various commands that you can invoke from the minibuffer. Important: you may bind keystrokes to any of these commands. See Customizing Leo for full details.
.. @+node:ekr.20110930075237.15472: *4* Improving Leo: think inside the box
@nocolor-node

There is plenty of room for improving Leo, and my recent energy spike
promises to carry over to Leo itself.  Here are the major areas that I
see that can be improved:

1. Windows.

Terry's work is an enabler.  Just as Blender supports many kinds of
windows, so too should Leo.  Up until now, the outline, body and log
panes have been the only "official" panes.  The rendering pane soon
will be fully official.

Terry's plugins have also created nifty new windows.

Here are some other ideas:

A.  Hosting the PyQt demo inside Leo.

B.  Making an OpenGL window an official Leo window.  This might be the
start of a prototype for "Blender in a Leo Window"

2. Keystrokes

Restarting the vim-keys project is conceivable.  I stopped work on the
project when I realized that vim bindings only make sense when
*commands* can be composed as in vim.

3. Bridges

This could be an important "new" direction.  True, there are already
bridges for vim, emacs, ipython and docutils, but I think more can be
done.

The first thought is to improve Leo's inter-process communication
capabilities.  I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in
order to resize vim, say, to it automatically tracks Leo's body pane
(or any other pane).

4. Code tools

Analysis, checking, refactoring and other code-level tools are a
natural for Leo.  When the new-lint project is mature, it could be
folded into Leo.

5. Documentation

Perhaps Leo's documentation could be built primarily from docstrings.
In any event, documentation tools are always needed.
.. @+node:ekr.20110930075237.15473: *5* Kent's suggestions
@nocolor-node

Buttons:
Enhance the button machinery to allow mixed case, spaces, colors.
Provide cascading rclick capability: rclick on an rclick list ...

Templating:
Solid, simple implementation of one of the standard template engines
providing intuitive template nodes, variable definitions, and rendering options.

Wizards:
Leverage the template capability to offer form-based content creation:
- create a plugin
- generate a test node
- generate a wizard :-]

LeoFS:
- create a Leo implementation of pyfilesystem
http://packages.python.org/fs/implementersguide.html

Enhanced node attributes:
ctime, atime, mtime

remove expansion data from .leo file

- provide persistence of tab status
 (resume editing with same tabs open when using tabbed gui)
.. @+node:ekr.20110930075237.15474: *5* Matt Wilkie
@nocolor-node

As for user interface, I'd love to see myLeoSettings with a checkbox
interface and filter bar at the top, and a feature to "merge or reset
from LeoSettings".
... or maybe something like Firefox's "about:config" would be better
suited (and probably faster to build).
.. @+node:ekr.20110929074744.15499: *4* Allow more panes to be part of the free_layout "action" buttons
.. @+node:ekr.20110929074744.15449: *4* Allow mouseless leo (really)
@nocolor-node

Alt-x show (tab name).  For example: show-tab<tab> (typing completion)

There is a relationship here with mouseless
programming.  It would seem that all visual elements, especially those
that may exist in multiple versions, must have a name or other
description suitable for generalized commands.

At present, the most serious hole in Leo's commands is that there is
no way to close or select a tab in the qttabs gui that represents an
entire file: afaik, you have to use the mouse to change files.  By
extension, the user might want multiple rendering panes, especially if
one or more are locked.  Without a description, there is no way to
specify exactly what show/hide-rendering pane does.

I haven't forgotten the autocompleter docs.  I'll get to them next.
It looks like autocompletion would be the way to generalize the not-
very-effect commands that switch focus from one ui element to
another.  A related benefit is one generalized command might be more
convenient to use than the present flavors of (buggy) cycle-focus
commands.

In short, contemplating generalized windows leads us to generalized
select/delete/show/hide commands, based on autocompletion, that work
on various ui elements.  This looks like the next project. 
.. @+node:ekr.20110929165422.15431: *4* Fun scripts
.. @+node:ekr.20110919113533.6818: *5* split-defs-into-node
.. @+node:ekr.20110919113533.6820: *6* methods
# Normalize a type. Replaces type with fully qualified version
def normalize_type(ty):
    SwigType *qty
    if CPlusPlus:
        Replaceall(ty,"struct ","")
        Replaceall(ty,"union ","")
        Replaceall(ty,"class ","")
    qty = SwigType_typedef_qualified(ty)
    #    Printf(stdout,"%s -. %s\n",ty,qty);
    Clear(ty)
    Append(ty,qty)
    Delete(qty)
# Normaldef normalize_parms(p):
#     while(p)
#         SwigType *ty = Getattr(p,"type");
#         normalize_type(ty);
#         /* This is a check for a function type
            SwigType *qty = SwigType_typedef_resolve_all(ty)
            if SwigType_isfunction(qty):
                SwigType_add_pointer(ty)
            Delete(qty)
        String *value = Getattr(p,"value")
        if value:
            Node *n = Swig_symbol_clookup(value,0)
            if n:
                String *q = Swig_symbol_qualified(n)
                if q and Len(q):
                    String *vb = Swig_scopename_last(value)
                    Clear(value)
                    Printf(value,"%s::%s",SwigType_namestr(q),vb)
                    Delete(q)
        if value and SwigType_istemplate(value):
            String *nv = SwigType_namestr(value)
            Setattr(p,"value",nv)
        p = nextSibling(p)
void normalize_later(ParmList *p)
    while p:
        SwigType *ty = Getattr(p,"type")
        Append(normalize,ty)
        p = nextSibling(p)
# Walk through entries in normalize list and patch them up
def normalize_list():
    Hash *currentsym = Swig_symbol_current()
    normal_node *nn = patch_list
    normal_node *np
    while nn:
        Swig_symbol_setscope(nn.symtab)
        SwigType_set_scope(nn.typescope)
        Iterator t
        for t = First(nn.normallist); t.item; t = Next(t):
            normalize_type(t.item)
        Delete(nn.normallist)
        np = nn.next
        delete(nn)
        nn = np
    Swig_symbol_setscope(currentsym)
# generate C++ inheritance type-relationships
def cplus_inherit_types_impl(first,cls,clsname,bases,baselist,ispublic,cast):
    if first == cls:
        return
    			# The Marcelo check
    if !cls:
        cls = first
    List *alist = 0
    List *ilist = Getattr(cls,bases)
    if !ilist:
        List *nlist = Getattr(cls,baselist)
        if nlist:
             len = Len(nlist)
             i
            for i = 0; i < len; i++:
                Node *bcls = 0
                 clsforward = 0
                String *bname = Getitem(nlist,i)
                String *sname = bname
                String *tname = 0
                # Try to locate the base class.   We look in the symbol table and we chase
#      typedef declarations to get to the base class if necessary
                Symtab *st = Getattr(cls,"sym:symtab")
                if SwigType_istemplate(bname):
                    tname = SwigType_typedef_resolve_all(bname)
                    sname = tname
                while 1:
                    String *qsname = SwigType_typedef_qualified(sname)
                    bcls = Swig_symbol_clookup(qsname,st)
                    Delete(qsname)
                    if bcls:
                        if Strcmp(nodeType(bcls),"class")!= 0:
                            # Not a class.   The symbol could be a typedef.
                            if checkAttribute(bcls,"storage","typedef"):
                                SwigType *decl = Getattr(bcls,"decl")
                                if !decl or !(Len(decl)):
                                    sname = Getattr(bcls,"type")
                                    st = Getattr(bcls,"sym:symtab")
                                    if SwigType_istemplate(sname):
                                        if tname:
                                            Delete(tname)
                                        tname = SwigType_typedef_resolve_all(sname)
                                        sname = tname
                                    continue
                            if Strcmp(nodeType(bcls),"classforward")!= 0:
                                Swig_error(Getfile(bname),Getline(bname),"'%s' is not a valid base class.\n",SwigType_namestr(bname))
                                Swig_error(Getfile(bcls),Getline(bcls),"See definition of '%s'.\n",SwigType_namestr(bname))
                             else:
                                Swig_warning(WARN_TYPE_INCOMPLETE,Getfile(bname),Getline(bname),"Base class '%s' is incomplete.\n",SwigType_namestr(bname))
                                Swig_warning(WARN_TYPE_INCOMPLETE,Getfile(bcls),Getline(bcls),"Only forward declaration '%s' was found.\n",SwigType_namestr(bname))
                                clsforward = 1
                            bcls = 0
                         else:
                            if Getattr(bcls,"typepass:visit"):
                                if !ilist:
                                    ilist = alist = NewList()
                                Append(ilist,bcls)
                             else:
                                Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bname),Getline(bname),"Base class '%s' undefined.\n",SwigType_namestr(bname))
                                Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bcls),Getline(bcls),"'%s' must be defined before it is used as a base class.\n",SwigType_namestr(bname))
                    break
                if tname:
                    Delete(tname)
                if !bcls:
                    if !clsforward:
                        if ispublic and !Getmeta(bname,"already_warned"):
                            Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bname),Getline(bname),"Nothing known about base class '%s'. Ignored.\n",SwigType_namestr(bname))
                            if Strchr(bname,'<'):
                                Swig_warning(WARN_TYPE_UNDEFINED_CLASS,Getfile(bname),Getline(bname),"Maybe you forgot to instantiate '%s' using %%template.\n",SwigType_namestr(bname))
                            Setmeta(bname,"already_warned","1")
                    SwigType_inherit(clsname,bname,cast,0)
        if ilist:
            Setattr(cls,bases,ilist)
    if alist:
        Delete(alist)
    if !ilist:
        return
     len = Len(ilist)
     i
    for i = 0; i < len; i++:
        Node *n = Getitem(ilist,i)
        String *bname = Getattr(n,"name")
        Node *bclass = n; # Getattr(n,"class");
        Hash *scopes = Getattr(bclass,"typescope")
        SwigType_inherit(clsname,bname,cast,0)
        String *smartptr = Getattr(first,"feature:smartptr")
        if smartptr:
            SwigType *smart = 0
            SwigType *spt = Swig_cparse_type(smartptr)
            if spt:
                smart = SwigType_typedef_resolve_all(spt)
                Delete(spt)
                # Record a(fake)inheritance relationship between smart pointer
#      and smart pointer to base class,so that smart pointer upcasts
#      are automatically generated.
                SwigType *bsmart = Copy(smart)
                SwigType *rclsname = SwigType_typedef_resolve_all(clsname)
                SwigType *rbname = SwigType_typedef_resolve_all(bname)
                Replaceall(bsmart,rclsname,rbname)
                Delete(rclsname)
                Delete(rbname)
                String *smartnamestr = SwigType_namestr(smart)
                String *bsmartnamestr = SwigType_namestr(bsmart)
                # construct casting code
                String *convcode = NewStringf("\n    *newmemory = SWIG_CAST_NEW_MEMORY;\n    return(void *)new %s(*(%s *)$from);\n",bsmartnamestr,smartnamestr)
                Delete(bsmartnamestr)
                Delete(smartnamestr)
                # setup inheritance relationship between smart pointer templates
                SwigType_inherit(smart,bsmart,0,convcode)
                if !GetFlag(bclass,"feature:smartptr"):
                    Swig_warning(WARN_LANG_SMARTPTR_MISSING,Getfile(first),Getline(first),"Base class '%s' of '%s' is not similarly marked as a smart pointer.\n",SwigType_namestr(Getattr(bclass,"name")),SwigType_namestr(Getattr(first,"name")))
                Delete(convcode)
                Delete(bsmart)
                Delete(smart)
             else:
                Swig_error(Getfile(first),Getline(first),"Invalid type(%s)in 'smartptr' feature for class %s.\n",SwigType_namestr(smartptr),SwigType_namestr(clsname))
         else:
            if GetFlag(bclass,"feature:smartptr"):
                Swig_warning(WARN_LANG_SMARTPTR_MISSING,Getfile(first),Getline(first),"Derived class '%s' of '%s' is not similarly marked as a smart pointer.\n",SwigType_namestr(Getattr(first,"name")),SwigType_namestr(Getattr(bclass,"name")))
        if !importmode:
            String *btype = Copy(bname)
            SwigType_add_pointer(btype)
            SwigType_remember(btype)
            Delete(btype)
        if scopes:
            SwigType_inherit_scope(scopes)
        # Set up inheritance in the symbol table
        Symtab *st = Getattr(cls,"symtab")
        Symtab *bst = Getattr(bclass,"symtab")
        if st == bst:
            Swig_warning(WARN_PARSE_REC_INHERITANCE,Getfile(cls),Getline(cls),"Recursive scope inheritance of '%s'.\n",SwigType_namestr(Getattr(cls,"name")))
            continue
        Symtab *s = Swig_symbol_current()
        Swig_symbol_setscope(st)
        Swig_symbol_inherit(bst)
        Swig_symbol_setscope(s)
        # Recursively hit base classes
        String *namestr = SwigType_namestr(Getattr(bclass,"name"))
        String *newcast = NewStringf("(%s *)%s",namestr,cast)
        Delete(namestr)
        cplus_inherit_types_impl(first,bclass,clsname,bases,baselist,ispublic,newcast)
        Delete(newcast)
void append_list(List *lb,List *la)
    if la and lb:
        for Iterator bi = First(la); bi.item; bi = Next(bi):
            Append(lb,bi.item)
void cplus_inherit_types(Node *first,Node *cls,String *clsname,String *cast = 0)
    cplus_inherit_types_impl(first,cls,clsname,"bases","baselist",1,cast)
    cplus_inherit_types_impl(first,cls,clsname,"protectedbases","protectedbaselist",0,cast)
    cplus_inherit_types_impl(first,cls,clsname,"privatebases","privatebaselist",0,cast)
    if !cls:
        cls = first
    List *allbases = NewList()
    append_list(allbases,Getattr(cls,"bases"))
    append_list(allbases,Getattr(cls,"protectedbases"))
    append_list(allbases,Getattr(cls,"privatebases"))
    if Len(allbases):
        Setattr(cls,"allbases",allbases)
    Delete(allbases)
# ------------------------------------------------------------
# * top()
# * ------------------------------------------------------------
def top(n):
    importmode = 0
    module = Getattr(n,"module")
    inclass = 0
    normalize = 0
    nsname = 0
    nssymname = 0
    classhash = Getattr(n,"classes")
    emit_children(n)
    normalize_list()
    SwigType_set_scope(0)
    return SWIG_OK
# ------------------------------------------------------------
# * moduleDirective()
# * ------------------------------------------------------------
virtual int moduleDirective(Node *n)
    if !module:
        module = n
    return SWIG_OK
# ------------------------------------------------------------
# * importDirective()
# * ------------------------------------------------------------
def importDirective(n):
    String *oldmodule = module
     oldimport = importmode
    importmode = 1
    module = 0
    emit_children(n)
    importmode = oldimport
    module = oldmodule
    return SWIG_OK
# ------------------------------------------------------------
# * includeDirective()
# * externDirective()
# * extendDirective()
# * ------------------------------------------------------------
virtual int includeDirective(Node *n)
    return emit_children(n)
def externDeclaration(n):
    return emit_children(n)
virtual int edef xtendDirective(n):
    return emit_children(n)
# ------------------------------------------------------------
# * classDeclaration()
# * ------------------------------------------------------------
def classDeclaration(n):
    String *name = Getattr(n,"name")
    String *tdname = Getattr(n,"tdname")
    String *unnamed = Getattr(n,"unnamed")
    String *storage = Getattr(n,"storage")
    String *kind = Getattr(n,"kind")
    Node *oldinclass = inclass
    List *olist = normalize
    Symtab *symtab
    String *nname = 0
    String *fname = 0
    String *scopename = 0
    normalize = NewList()
    if name:
        if SwigType_istemplate(name):
            # We need to fully resolve the name to make templates work correctly */
Node *cn
            fname = SwigType_typedef_resolve_all(name)
            if Strcmp(fname,name)!= 0 and(cn = Swig_symbol_clookup_local(fname,0)):
                if(n == cn)
      or(Strcmp(nodeType(cn),"template")== 0)
      or(Getattr(cn,"feature:onlychildren")!= 0)
      or(Getattr(n,"feature:onlychildren")!= 0):
                    Swig_symbol_cadd(fname,n)
                    SwigType_typedef_class(fname)
                    scopename = Copy(fname)
                 else:
                    Swig_warning(WARN_TYPE_REDEFINED,Getfile(n),Getline(n),"Template '%s' was already wrapped,\n",SwigType_namestr(name))
                    Swig_warning(WARN_TYPE_REDEFINED,Getfile(cn),Getline(cn),"previous wrap of '%s'.\n",SwigType_namestr(Getattr(cn,"name")))
                    scopename = 0
             else:
                Swig_symbol_cadd(fname,n)
                SwigType_typedef_class(fname)
                scopename = Copy(fname)
         else:
            if(CPlusPlus)or(unnamed):
                SwigType_typedef_class(name)
             else:
                SwigType_typedef_class(NewStringf("%s %s",kind,name))
            scopename = Copy(name)
     else:
        scopename = 0
    Setattr(n,"typepass:visit","1")
    # Need to set up a typedef if unnamed
    if unnamed and tdname and(Cmp(storage,"typedef")== 0):
        SwigType_typedef(unnamed,tdname)
    if nsname:
        nname = NewStringf("%s::%s",nsname,name)
        String *tdname = Getattr(n,"tdname")
        if tdname:
            tdname = NewStringf("%s::%s",nsname,tdname)
            Setattr(n,"tdname",tdname)
    if nssymname:
        if GetFlag(n,"feature:nspace"):
            Setattr(n,"sym:nspace",nssymname)
    SwigType_new_scope(scopename)
    SwigType_attach_symtab(Getattr(n,"symtab"))
    # Inherit type definitions into the class
    if name:
        cplus_inherit_types(n,0,nname ? nname:(fname ? fname: name))
    inclass = n
    symtab = Swig_symbol_setscope(Getattr(n,"symtab"))
    emit_children(n)
    Swig_symbol_setscope(symtab)
    Hash *ts = SwigType_pop_scope()
    Setattr(n,"typescope",ts)
    Delete(ts)
    Setattr(n,"module",module)
    # Normalize deferred types
        normal_node *nn = new normal_node()
        nn.normallist = normalize
        nn.symtab = Getattr(n,"symtab")
        nn.next = patch_list
        nn.typescope = Getattr(n,"typescope")
        patch_list = nn
    normalize = olist
    inclass = oldinclass
    # If in a namespace,patch the class name
    if nname:
        Setattr(n,"name",nname)
        Delete(nname)
    return SWIG_OK
# ------------------------------------------------------------
# * namespaceDeclaration()
# * ------------------------------------------------------------
virtual int templateDeclaration(Node *n)
    String *name = Getattr(n,"name")
    String *ttype = Getattr(n,"templatetype")
    if Strcmp(ttype,"class")== 0:
        String *rname = SwigType_typedef_resolve_all(name)
        SwigType_typedef_class(rname)
        Delete(rname)
     elif Strcmp(ttype,"classforward")== 0:
        String *rname = SwigType_typedef_resolve_all(name)
        SwigType_typedef_class(rname)
        Delete(rname)
        #      SwigType_typedef_class(name);
    return SWIG_OK
# ------------------------------------------------------------
# * classforwardDeclaration()
# * ------------------------------------------------------------
def classforwardDeclaration(n):
    # Temporary hack. Can't do inside a class because it breaks
#    C nested structure wrapping
    if(!inclass)or(CPlusPlus):
        String *name = Getattr(n,"name")
        String *nname
        SwigType_typedef_class(name)
        if nsname:
            nname = NewStringf("%s::%s",nsname,name)
            Setattr(n,"name",nname)
    return SWIG_OK
# ------------------------------------------------------------
# * namespaceDeclaration()
# * ------------------------------------------------------------
virtual int namespaceDeclaration(Node *n)
    Symtab *symtab
    String *name = Getattr(n,"name")
    String *alias = Getattr(n,"alias")
    List *olist = normalize
    normalize = NewList()
    if alias:
        Typetab *ts = Getattr(n,"typescope")
        if !ts:
            Node *ns
            # Create a empty scope for the alias
            ns = Getattr(n,"namespace")
            if ns:
                SwigType_scope_alias(name,Getattr(ns,"typescope"))
            ts = Getattr(ns,"typescope")
            Setattr(n,"typescope",ts)
        # Namespace alias
        return SWIG_OK
     else:
        if name:
            Node *nn = Swig_symbol_clookup(name,n)
            Hash *ts = 0
            if nn:
                ts = Getattr(nn,"typescope")
            if !ts:
                SwigType_new_scope(name)
                SwigType_attach_symtab(Getattr(n,"symtab"))
             else:
                SwigType_set_scope(ts)
        String *oldnsname = nsname
        String *oldnssymname = nssymname
        nsname = Swig_symbol_qualified(Getattr(n,"symtab"))
        nssymname = Swig_symbol_qualified_language_scopename(Getattr(n,"symtab"))
        symtab = Swig_symbol_setscope(Getattr(n,"symtab"))
        emit_children(n)
        Swig_symbol_setscope(symtab)
        if name:
            Hash *ts = SwigType_pop_scope()
            Setattr(n,"typescope",ts)
            Delete(ts)
        # Normalize deferred types
            normal_node *nn = new normal_node()
            nn.normallist = normalize
            nn.symtab = Getattr(n,"symtab")
            nn.next = patch_list
            nn.typescope = Getattr(n,"typescope")
            patch_list = nn
        normalize = olist
        Delete(nssymname)
        nssymname = oldnssymname
        Delete(nsname)
        nsname = oldnsname
        return SWIG_OK
# ------------------------------------------------------------
# * cDeclaration()
# * ------------------------------------------------------------
def cDeclaration(n):
    if NoExcept:
        Delattr(n,"throws")
    # Normalize types.
    SwigType *ty = Getattr(n,"type")
    normalize_type(ty)
    SwigType *decl = Getattr(n,"decl")
    if decl:
        normalize_type(decl)
    normalize_parms(Getattr(n,"parms"))
    normalize_parms(Getattr(n,"throws"))
    if GetFlag(n,"conversion_operator"):
        # The call to the operator in the generated wrapper must be fully qualified in order to compile
        SwigType *name = Getattr(n,"name")
        SwigType *qualifiedname = Swig_symbol_string_qualify(name,0)
        Clear(name)
        Append(name,qualifiedname)
        Delete(qualifiedname)
    if checkAttribute(n,"storage","typedef"):
        String *name = Getattr(n,"name")
        ty = Getattr(n,"type")
        decl = Getattr(n,"decl")
        SwigType *t = Copy(ty)
            # If the typename is qualified,make sure the scopename is fully qualified when making a typedef
            if Swig_scopename_check(t)and strncmp(Char(t),"::",2):
                String *base,*prefix,*qprefix
                base = Swig_scopename_last(t)
                prefix = Swig_scopename_prefix(t)
                qprefix = SwigType_typedef_qualified(prefix)
                Delete(t)
                t = NewStringf("%s::%s",qprefix,base)
                Delete(base)
                Delete(prefix)
                Delete(qprefix)
        SwigType_push(t,decl)
        if CPlusPlus:
            Replaceall(t,"struct ","")
            Replaceall(t,"union ","")
            Replaceall(t,"class ","")
        SwigType_typedef(t,name)
    # If namespaces are active.  We need to patch the name with a namespace prefix
    if nsname and !inclass:
        String *name = Getattr(n,"name")
        if name:
            String *nname = NewStringf("%s::%s",nsname,name)
            Setattr(n,"name",nname)
            Delete(nname)
    clean_overloaded(n)
    return SWIG_OK
# ------------------------------------------------------------
# * constructorDeclaration()
# * ------------------------------------------------------------
virtual int constructorDeclaration(Node *n)
    if NoExcept:
        Delattr(n,"throws")
    normalize_parms(Getattr(n,"parms"))
    normalize_parms(Getattr(n,"throws"))
    # If in a namespace,patch the class name
    if nsname:
        String *nname = NewStringf("%s::%s",nsname,Getattr(n,"name"))
        Setattr(n,"name",nname)
    clean_overloaded(n)
    return SWIG_OK
# ------------------------------------------------------------
# * destructorDeclaration()
# * ------------------------------------------------------------
def destructorDeclaration(n):
    # If in a namespace,patch the class name
    if nsname:
        String *nname = NewStringf("%s::%s",nsname,Getattr(n,"name"))
        Setattr(n,"name",nname)
    return SWIG_OK
# ------------------------------------------------------------
# * constantDirective()
# * ------------------------------------------------------------
virtual int constantDirective(Node *n)
    SwigType *ty = Getattr(n,"type")
    if ty:
        Setattr(n,"type",SwigType_typedef_qualified(ty))
    return SWIG_OK
# ------------------------------------------------------------
# * enumDeclaration()
# * ------------------------------------------------------------
def enumDeclaration(n):
    String *name = Getattr(n,"name")
    if name:
        String *scope = 0
        # Add a typedef to the type table so that we can use 'enum Name' as well as just 'Name'
  if nsname or inclass:
            # But first correct the name and tdname to contain the fully qualified scopename
if nsname and inclass:
                scope = NewStringf("%s::%s",nsname,Getattr(inclass,"name"))
             elif nsname:
                scope = NewStringf("%s",nsname)
             elif inclass:
                scope = NewStringf("%s",Getattr(inclass,"name"))
            String *nname = NewStringf("%s::%s",scope,name)
            Setattr(n,"name",nname)
            String *tdname = Getattr(n,"tdname")
            if tdname:
                tdname = NewStringf("%s::%s",scope,tdname)
                Setattr(n,"tdname",tdname)
            SwigType *t = NewStringf("enum %s",nname)
            SwigType_typedef(t,name)
         else:
            SwigType *t = NewStringf("enum %s",name)
            SwigType_typedef(t,name)
        Delete(scope)
    String *tdname = Getattr(n,"tdname")
    String *unnamed = Getattr(n,"unnamed")
    String *storage = Getattr(n,"storage")
    # Construct enumtype - for declaring an enum of this type with SwigType_ltype()etc
String *enumtype = 0
    if unnamed and tdname and(Cmp(storage,"typedef")== 0):
        enumtype = Copy(Getattr(n,"tdname"))
     elif name:
        enumtype = NewStringf("%s%s",CPlusPlus ? "": "enum ",Getattr(n,"name"))
     else:
        # anonymous enums
  enumtype = Copy(Getattr(n,"type"))
    Setattr(n,"enumtype",enumtype)
    if nssymname:
        if GetFlag(n,"feature:nspace"):
            Setattr(n,"sym:nspace",nssymname)
    # This block of code is for dealing with %ignore on an enum item where the target language
# attempts to use the C enum value in the target language itself and expects the previous enum value
# to be one more than the previous value... the previous enum item might not exist if it is ignored!
# - It sets the first non-ignored enum item with the "firstenumitem" attribute.
# - It adds an enumvalue attribute if the previous enum item is ignored
        Node *c
         count = 0
        String *previous = 0
        bool previous_ignored = false
        bool firstenumitem = false
        for c = firstChild(n); c; c = nextSibling(c):
            assert(strcmp(Char(nodeType(c)),"enumitem")== 0)
            bool reset
            String *enumvalue = Getattr(c,"enumvalue")
            if GetFlag(c,"feature:ignore")or !Getattr(c,"sym:name"):
                reset = enumvalue ? true: false
                previous_ignored = true
             else:
                if !enumvalue and previous_ignored:
                    if previous:
                        Setattr(c,"enumvalue",NewStringf("(%s)+ %d",previous,count+1))
                    else:
                    Setattr(c,"enumvalue",NewStringf("%d",count))
                    SetFlag(c,"virtenumvalue")# identify enumvalue as virtual,ie not from the parsed source
                if !firstenumitem:
                    SetFlag(c,"firstenumitem")
                    firstenumitem = true
                reset = true
                previous_ignored = false
            if reset:
                previous = enumvalue ? enumvalue: Getattr(c,"name")
                count = 0
             else:
                count++
    emit_children(n)
    return SWIG_OK
# ------------------------------------------------------------
# * enumvalueDeclaration()
# * ------------------------------------------------------------
virtual int enumvalueDeclaration(Node *n)
    String *name = Getattr(n,"name")
    String *value = Getattr(n,"value")
    if !value:
        value = name
    if Strcmp(value,name)== 0:
        String *new_value
        if(nsname or inclass)and cparse_cplusplus:
            new_value = NewStringf("%s::%s",SwigType_namestr(Swig_symbol_qualified(n)),value)
         else:
            new_value = NewString(value)
        if(nsname or inclass)and !cparse_cplusplus:
            String *cppvalue = NewStringf("%s::%s",SwigType_namestr(Swig_symbol_qualified(n)),value)
            Setattr(n,"cppvalue",cppvalue); # for target languages that always generate C++ code even when wrapping C code
        Setattr(n,"value",new_value)
        Delete(new_value)
    Node *next = nextSibling(n)
    # Make up an enumvalue if one was not specified in the parsed code(not designed to be used on enum items and %ignore - enumvalue will be set instead)
if !GetFlag(n,"feature:ignore"):
        if Getattr(n,"_last")and !Getattr(n,"enumvalue"):  	# Only the first enum item has _last set(Note: first non-ignored enum item has firstenumitem set)
Setattr(n,"enumvalueex","0")
        if next and !Getattr(next,"enumvalue"):
            Setattr(next,"enumvalueex",NewStringf("%s + 1",Getattr(n,"sym:name")))
    return SWIG_OK
# ------------------------------------------------------------
# * enumforwardDeclaration()
# * ------------------------------------------------------------
def enumforwardDeclaration(n):
    # Use enumDeclaration()to do all the hard work.
# Note that no children can be emitted in a forward declaration as there aren't any.
return enumDeclaration(n)
ifdef DEBUG_OVERLOADED
static void show_overloaded(Node *n)
    Node *c = Getattr(n,"sym:overloaded")
    Node *checkoverloaded = c
    Printf(stdout,"-------------------- overloaded start %s sym:overloaded():%p -------------------------------\n",Getattr(n,"name"),c)
    while c:
        if Getattr(c,"error"):
            c = Getattr(c,"sym:nextSibling")
            continue
        if Getattr(c,"sym:overloaded")!= checkoverloaded:
            Printf(stdout,"sym:overloaded error c:%p checkoverloaded:%p\n",c,checkoverloaded)
            Swig_print_node(c)
            exit(1)
        String *decl = Strcmp(nodeType(c),"using")== 0 ? NewString("------"): Getattr(c,"decl")
        Printf(stdout,"  show_overloaded %s::%s(%s)         [%s] nodeType:%s\n",parentNode(c)? Getattr(parentNode(c),"name"): "NOPARENT",Getattr(c,"name"),decl,Getattr(c,"sym:overname"),nodeType(c))
        if !Getattr(c,"sym:overloaded"):
            Printf(stdout,"sym:overloaded error.....%p\n",c)
            Swig_print_node(c)
            exit(1)
        c = Getattr(c,"sym:nextSibling")
    Printf(stdout,"-------------------- overloaded end   %s -------------------------------\n",Getattr(n,"name"))
# ------------------------------------------------------------
# * usingDeclaration()
# * ------------------------------------------------------------
def usingDeclaration(n):
    if Getattr(n,"namespace"):
        # using namespace id
        # For a namespace import.   We set up inheritance in the type system
        Node *ns = Getattr(n,"node")
        if ns:
            Typetab *ts = Getattr(ns,"typescope")
            if ts:
                SwigType_using_scope(ts)
        return SWIG_OK
     else:
        Node *ns
        # using id
        Symtab *stab = Getattr(n,"sym:symtab")
        if stab:
            String *uname = Getattr(n,"uname")
            ns = Swig_symbol_clookup(uname,stab)
            if !ns and SwigType_istemplate(uname):
                String *tmp = Swig_symbol_template_deftype(uname,0)
                if !Equal(tmp,uname):
                    ns = Swig_symbol_clookup(tmp,stab)
                Delete(tmp)
         else:
            ns = 0
        if !ns:
            if is_public(n):
                Swig_warning(WARN_PARSE_USING_UNDEF,Getfile(n),Getline(n),"Nothing known about '%s'.\n",SwigType_namestr(Getattr(n,"uname")))
         else:
            # Only a single symbol is being used.  There are only a few symbols that
#    we actually care about.  These are typedef,class declarations,and enum
            String *ntype = nodeType(ns)
            if Strcmp(ntype,"cdecl")== 0:
                if checkAttribute(ns,"storage","typedef"):
                    # A typedef declaration
                    String *uname = Getattr(n,"uname")
                    SwigType_typedef_using(uname)
                 else:
                    # A normal C declaration.
                    if(inclass)and(!GetFlag(n,"feature:ignore"))and(Getattr(n,"sym:name")):
                        Node *c = ns
                        Node *unodes = 0,*last_unodes = 0
                         ccount = 0
                        String *symname = Getattr(n,"sym:name")
                        while c:
                            if Strcmp(nodeType(c),"cdecl")== 0:
                                if !(checkAttribute(c,"storage","static")
        or checkAttribute(c,"storage","typedef")
        or checkAttribute(c,"storage","friend")
        or(Getattr(c,"feature:extend")and !Getattr(c,"code"))
        or GetFlag(c,"feature:ignore")):
                                    # Don't generate a method if the method is overridden in this class,
#          * for example don't generate another m(bool)should there be a Base::m(bool):
#          * struct Derived: Base
#          *   void m(bool);
#          *   using Base::m;
#          * ;
#
                                    String *csymname = Getattr(c,"sym:name")
                                    if !csymname or(Strcmp(csymname,symname)== 0):
                                            String *decl = Getattr(c,"decl")
                                            Node *over = Getattr(n,"sym:overloaded")
                                             match = 0
                                            while over:
                                                String *odecl = Getattr(over,"decl")
                                                if Cmp(decl,odecl)== 0:
                                                    match = 1
                                                    break
                                                over = Getattr(over,"sym:nextSibling")
                                            if match:
                                                c = Getattr(c,"csym:nextSibling")
                                                continue
                                        Node *nn = copyNode(c)
                                        Delattr(nn,"access")	# access might be different from the method in the base class
          Setattr(nn,"access",Getattr(n,"access"))
                                        if !Getattr(nn,"sym:name"):
                                            Setattr(nn,"sym:name",symname)
                                        if !GetFlag(nn,"feature:ignore"):
                                            ParmList *parms = CopyParmList(Getattr(c,"parms"))
                                             is_pointer = SwigType_ispointer_return(Getattr(nn,"decl"))
                                             is_void = checkAttribute(nn,"type","void")and !is_pointer
                                            Setattr(nn,"parms",parms)
                                            Delete(parms)
                                            if Getattr(n,"feature:extend"):
                                                String *ucode = is_void ? NewStringf(" self.%s(",Getattr(n,"uname")): NewStringf(" return self.%s(",Getattr(n,"uname"))
                                                for ParmList *p = parms; p;:
                                                    Append(ucode,Getattr(p,"name"))
                                                    p = nextSibling(p)
                                                    if p:
                                                        Append(ucode,",")
                                                Append(ucode,"); ")
                                                Setattr(nn,"code",ucode)
                                                Delete(ucode)
                                            ParmList *throw_parm_list = Getattr(c,"throws")
                                            if throw_parm_list:
                                                Setattr(nn,"throws",CopyParmList(throw_parm_list))
                                            ccount++
                                            if !last_unodes:
                                                last_unodes = nn
                                                unodes = nn
                                             else:
                                                Setattr(nn,"previousSibling",last_unodes)
                                                Setattr(last_unodes,"nextSibling",nn)
                                                Setattr(nn,"sym:previousSibling",last_unodes)
                                                Setattr(last_unodes,"sym:nextSibling",nn)
                                                Setattr(nn,"sym:overloaded",unodes)
                                                Setattr(unodes,"sym:overloaded",unodes)
                                                last_unodes = nn
                                         else:
                                            Delete(nn)
                            c = Getattr(c,"csym:nextSibling")
                        if unodes:
                            set_firstChild(n,unodes)
                            if ccount > 1:
                                if !Getattr(n,"sym:overloaded"):
                                    Setattr(n,"sym:overloaded",n)
                                    Setattr(n,"sym:overname","_SWIG_0")
                        # Hack the parse tree symbol table for overloaded methods. Replace the "using" node with the
#        * list of overloaded methods we have just added in as child nodes to the "using" node.
#        * The node will still exist,it is just the symbol table linked list of overloaded methods
#        * which is hacked.
                        if Getattr(n,"sym:overloaded"):
                             cnt = 0
                            ifdef DEBUG_OVERLOADED
    Node *debugnode = n
                            show_overloaded(n)
    if !firstChild(n):
                                # Remove from overloaded list('using' node does not actually end up adding in any methods)
      Node *ps = Getattr(n,"sym:previousSibling")
                                Node *ns = Getattr(n,"sym:nextSibling")
                                if ps:
                                    Setattr(ps,"sym:nextSibling",ns)
                                if ns:
                                    Setattr(ns,"sym:previousSibling",ps)
                             else:
                                # The 'using' node results in methods being added in - slot in the these methods here
      Node *ps = Getattr(n,"sym:previousSibling")
                                Node *ns = Getattr(n,"sym:nextSibling")
                                Node *fc = firstChild(n)
                                Node *pp = fc
                                Node *firstoverloaded = Getattr(n,"sym:overloaded")
                                if firstoverloaded == n:
                                    # This 'using' node we are cutting out was the first node in the overloaded list.
        # Change the first node in the list to its first sibling
        Delattr(firstoverloaded,"sym:overloaded")
                                    Node *nnn = Getattr(firstoverloaded,"sym:nextSibling")
                                    firstoverloaded = fc
                                    while nnn:
                                        Setattr(nnn,"sym:overloaded",firstoverloaded)
                                        nnn = Getattr(nnn,"sym:nextSibling")
                                while pp:
                                    Node *ppn = Getattr(pp,"sym:nextSibling")
                                    Setattr(pp,"sym:overloaded",firstoverloaded)
                                    Setattr(pp,"sym:overname",NewStringf("%s_%d",Getattr(n,"sym:overname"),cnt++))
                                    if ppn:
                                        pp = ppn
                                    else:
                                    break
                                if ps:
                                    Setattr(ps,"sym:nextSibling",fc)
                                    Setattr(fc,"sym:previousSibling",ps)
                                if ns:
                                    Setattr(ns,"sym:previousSibling",pp)
                                    Setattr(pp,"sym:nextSibling",ns)
                                ifdef DEBUG_OVERLOADED
      debugnode = firstoverloaded
                            Delattr(n,"sym:previousSibling")
                            Delattr(n,"sym:nextSibling")
                            Delattr(n,"sym:overloaded")
                            Delattr(n,"sym:overname")
                            ifdef DEBUG_OVERLOADED
    show_overloaded(debugnode)
    clean_overloaded(n)# Needed?
             elif(Strcmp(ntype,"class")== 0)or((Strcmp(ntype,"classforward")== 0)):
                # We install the using class name as kind of a typedef back to the original class
                String *uname = Getattr(n,"uname")
                # Import into current type scope
                SwigType_typedef_using(uname)
             elif Strcmp(ntype,"enum")== 0:
                SwigType_typedef_using(Getattr(n,"uname"))
    return SWIG_OK
# ------------------------------------------------------------
# * typemapDirective()
# * ------------------------------------------------------------
virtual int typemapDirective(Node *n)
    if inclass or nsname:
        Node *items = firstChild(n)
        while items:
            Parm *pattern = Getattr(items,"pattern")
            Parm *parms = Getattr(items,"parms")
            normalize_later(pattern)
            normalize_later(parms)
            items = nextSibling(items)
    return SWIG_OK
# ------------------------------------------------------------
# * typemapcopyDirective()
# * ------------------------------------------------------------
def typemapcopyDirective(n):
    if inclass or nsname:
        Node *items = firstChild(n)
        ParmList *pattern = Getattr(n,"pattern")
        normalize_later(pattern)
        while items:
            ParmList *npattern = Getattr(items,"pattern")
            normalize_later(npattern)
            items = nextSibling(items)
    return SWIG_OK
# ------------------------------------------------------------
# * applyDirective()
# * ------------------------------------------------------------
virtual int applyDirective(Node *n)
    if inclass or nsname:
        ParmList *pattern = Getattr(n,"pattern")
        normalize_later(pattern)
        Node *items = firstChild(n)
        while items:
            Parm *apattern = Getattr(items,"pattern")
            normalize_later(apattern)
            items = nextSibling(items)
    return SWIG_OK
# ------------------------------------------------------------
# * clearDirective()
# * ------------------------------------------------------------
def clearDirective(n):
    if inclass or nsname:
        Node *p
        for p = firstChild(n); p; p = nextSibling(p):
            ParmList *pattern = Getattr(p,"pattern")
            normalize_later(pattern)
    return SWIG_OK
public:
statdef pass(n):
    TypePass t
    t.top(n)
.. @+node:ekr.20110917104720.9418: *5* convert-names-to-pep8
.. @+node:ekr.20110918204546.6809: *5* convert-to-class
.. @+node:ekr.20110929165422.15449: *4* Add expand_noweb_references for rst3 plugin
@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

> What would work for me is if named sections in a @rst subtree
> would work exactly as they work for other derived files: they
> get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
.. @+node:ekr.20110929165422.15450: *5* post
@nocolor-node

I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  <<code fragment>>

Unfortunately, <<code fragment>> will not be expanded. Furthermore, in order to
get to this work, I should have <<code fragment>> under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
.. @+node:ekr.20110929165422.15451: *5* writeBody & helpers
def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n') 

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
.. @+node:ekr.20110929165422.15452: *6* handleCodeMode & helper
def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
.. @+node:ekr.20110929165422.15453: *7* formatCodeModeLine
def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
.. @+node:ekr.20110929165422.15454: *7* rstripList
def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
.. @+node:ekr.20110929165422.15455: *7* finishCodePart
def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
.. @+node:ekr.20110929165422.15456: *6* handleDocOnlyMode
def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result
.. @+node:ekr.20110929165422.15457: *6* isAnyDocPart
def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
.. @+node:ekr.20110929165422.15458: *6* isSpecialDocPart
def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) > 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
.. @+node:ekr.20110929165422.15459: *6* isAnySpecialDocPart
def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
.. @+node:ekr.20110929165422.15460: *6* removeLeoDirectives
def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
.. @+node:ekr.20110929165422.15461: *6* handleSpecialDocParts
def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
.. @+node:ekr.20110929165422.15462: *6* replaceCodeBlockDirectives
def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n < len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
.. @+node:ekr.20110620065017.14900: *3* Bugs
.. @+node:ekr.20110621085435.6531: *4* Improve the find panel and find menu
@nocolor-node

Recently, perhaps it was today, there was a remark made about Leo's
Find panel being confusing for newbies.  I have some sympathy for the
remarks.

1.  Looking at Leo's Edit:Find menu, there is no obvious way of doing
a search/replace operation.  I'll fix this soon after 4.9 final.

2.  The Find tab should make it clearer that it is a summary/status
tab only--not a way of actually initiating or continuing searches.
Perhaps using QLabel widgets instead of (disabled) QTextEdit widgets
for the find/change patterns would help a bit.
.. @+node:ekr.20110620083705.14901: *4* Fix or disable curses and none gui's
See scanOptions.
.. @+node:ekr.20110619173515.14895: *4* Fix bug: realpath in g.openWithFileName
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/cd5e2125c9e13d8f

g.openWithFileName needs

   fileName = g.os_path_realpath(fileName)

at the start of it, otherwise

g.openWithFileName("/home/tbrown/.leo/.todo.leo", c) will open another
instance of an already open "/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo"
because it doesn't recognize them as being the same.

It would be nice if the original attempt to open
"/home/tbrown/.leo/.todo.leo" was not converted to
"/mnt/usr1/usr1/home/tbrown/.leo/.todo.leo", but I think the POSIX
spec. insists on giving CPython the real path form, so this is hard to
avoid.  You see this when selecting a file using a file dialog, in the
dialog you choose /home/me/myfile.txt, but the return
is /mnt/usr1/usr1/home/me/myfile.txt.

Anyway, let me know if and when I can push that to trunk, impacts seem
to be limited to (a) not failing to detect an already opened file in
g.openWithFileName, which is a bug, and (b) sometimes less attractive
apparent paths, which is annoying, but I think better than the bug.

(this of course trips up UNLs
if /mnt/usr1/usr1/home/tbrown/.leo/.todo.leo is already loaded and the
UNL is /home/tbrown/.leo/.todo.leo#Home-->Paint roof)
.. @+node:ekr.20110619173515.14896: *4* Fix bug: wrong modality level on autocompleter
Just noticed the autocompleter pop-up is modal globally, not just for
the Leo windows.  Probably should only block the Leo windows.
.. @+node:ekr.20110621085435.6532: *4* Request: have equal-sized-panes resize vr pane
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/583bc0a31a6c7979

I noticed that when the renderpane is active it is not affected by the
Window>Equal Sized Panes command. Only the Outline and Body Panes are affected -
just as described in
http://webpages.charter.net/edreamleo/outlines.html#resizing-panes. However from
the user perspective the current behaviour appears as though the command is only
partially successful. Since there are specific commands to contract/expand the
log pane, shouldn't the log and render panes also be affected by the
Window>Equal Sized Panes command?


I suppose so.  I would prefer to wait for Terry to finish his
pane-generalization code before dealing with this.
.. @+node:ekr.20110921094450.6956: ** To do: 4.10
3. Bridges


.. @+node:ekr.20110921094450.6954: *3* Important
.. @+node:ekr.20110921094450.6955: *4* Windows
Leo should support more new windows.


Terry's plugins have also created nifty new windows.

Here are some other ideas:

A.  Hosting the PyQt demo inside Leo.

B. Making an OpenGl window an official Leo window. This might be the start of a
   prototype for "Blender in a Leo Window".
.. @+node:ekr.20110528034751.18272: *5* Support for tabifying Leo's core panes
Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
.. @+node:ekr.20110525112110.18402: *5* Ideas:
.. @+node:ekr.20101104191857.5820: *6* QWebView makes Leo a presentation tool
http://groups.google.com/group/leo-editor/browse_thread/thread/4ea2d3f7d2c68106#

Ville:

Create one QWebView window, zoom it in to have large fonts.

Create @button that converts current node containing restructuredtext to html,
and pushes that html to QWebView.

Voila', instant presentation tool. The webview window would be on projector, and
leo would be in your private computer. You can easily edit the text, or find new
interesting slides to present in privacy of your own screen.

.. @+node:ekr.20060227123536: *6* Tiddlywiki and related comments about rendering body text (Mulder)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3578252
By: bwmulder

I have been thinking for a while that it ought to be possible to somehow  to
unite Leo with wiki features (my thinking is still vague at this point).

If you look at systems like Tiddlywiki (http://www.tiddlywiki.com/) you will
find that they already pretty much provide all the formatting features mentioned
in the article.

MoinMoin, another wiki (http://moinmoin.wikiwikiweb.de), has started to use
a graphical interface for editing in the latest version.

Maybe Leo can be split up into three components:

1. A storage component is responsible for storing nodes. Currently, this is
just memory, but databases like shelve, Zope or sqllite should also be possible.

2. The control component is responsible for converting from the internal format
to external files which can be processed by existing compilers, searching within
a document, and the like.

3. A display component is responsible for interfacing with the user. If can
be TK, but it can also be something like the Tiddlywiki interface, which immediately
shows the formatting applied to text.

I don't know much about javascript, so I would have to learn more about this
language before doing anything in this direction.

As an intermediate step, maybe we could allow mixing RST processing with regular
program text.  Leo would produce two documents out of a source file: a version
for the compiler in plain ascii, and an HTML file for reading the source.
.. @+node:ekr.20110921094450.6957: *4* Keys: restart vim project
This requires commands that can be composed.
.. @+node:ekr.20110921094450.6958: *4* Bridges
There are already bridges for vim, emacs, ipython and docutils, but I think more
can be done.

The first thought is to improve Leo's inter-process communication capabilities.
I'm not sure what that entails...

As a blue-sky project, could Leo interact with the window manager in order to
resize vim, say, to it automatically tracks Leo's body pane (or any other pane).
.. @+node:ekr.20110921094450.6959: *4* Code tools
Analysis, checking, refactoring and other code-level tools are a natural for
Leo. When the new-lint project is mature, it could be folded into Leo.

* Rewrite the beautify-python command using a much simpler tokenizer.

.. @+node:ekr.20110921094450.6960: *4* Documentation tools
Perhaps Leo's documentation could be built primarily from docstrings. In any
event, documentation tools are always needed.
.. @+node:ekr.20110531190516.19365: *3* Maybe
@language rest

.. @+node:ekr.20110611043506.16494: *4*  Ashland sprint items: 3
.. @+node:ekr.20110527084258.18378: *5* New file format
@nocolor-node

** remove window state, expansion status etc.
   stuff from .leo file, and move that over to c.db

- <attr> solves pickle problem.

* Treat gnx's as strings: don't parse them.
  http://mail.google.com/mail/#inbox/12f3d4950fbabeea
  
* Don't save expansion bits in uA if not saving expansion bits. It's illogical
  to save bits in uA's if they aren't save in in the <v> elements.
  
    @bool put_expansion_bits_in_leo_files = False

- Use uuid's?

- Remove spaces from user names.

.. @+node:ekr.20110609042343.16546: *6* Notes
.. @+node:ekr.20110609042343.16548: *7* File format, v3 draft 5
@language rest
@pagewidth 65

http://groups.google.com/group/leo-editor/browse_thread/thread/2ddb57c62e67825c

Leo's file format: version 3, draft 5

This draft is intended to reflect minimal changes from Leo's
present file format, but with improvements mentioned at the
Ashland sprint and developed afterward.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

This draft contains significant invention by EKR. See the next
section. Don't panic: it can be changed :-)

Summary of changes from draft 4
===============================

- Elements will be renamed as follows::

    old         new
    ====        ====
    <vnodes>    <directed-acyclic-graph>
    <tnodes>    <data-list>
    <v>         <node>
    <t>         <data>

- Nesting of <node> elements represents the structure of the DAG,
  just as nesting of <v> elements does at present.
  
- Thus, there will be no <edge> elements.

- Headlines will move from <v> elements to <data> elements.
  This "normalizes" the data: headlines will appear only once.
  
- <attr> elements will represent uA's.  A full discussion below.

  Ideally, I would like to support only string and json formats
  for <attr> elements.  This is open to discussion. 

- Only <node> elements will contain <attr> elements.

- <node> elements for @file nodes will contain
  <at-file-attributes> elements, representing Leo's "hidden
  machinery" attributes.  <at-file-attributes> will contain
  <attr> elements. 

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear within
<node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <directed-acyclic-graph>
        <node id="gnx">
            <!-- contained node elements, if any.
        </node>
        <node id="gnx">
            <!-- contained v elements, if any.
        </node>
        ...
    </directed-acyclic-graph>
    <data-list>
        <data id="gnx">
            <!-- marked attribute appears only if the tnode/vnode is marked -->
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </data>
        ...
    </data-list>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
The value will be a string by default.

If possible, I would like to support only the string and json
formats. This would make the data as transparent as possible.
Please mentally amend the following discussion...

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may optionally be contained in
the <node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
.. @+node:ekr.20110421132230.6107: *7* File format, v3 draft 4
@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in <attr> elements (and "type" in <edge> elements.)

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <at-file-attributes>
                <attr>key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx">value
                </attr>
                ...
            </at-file-attributes>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </leo_file>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <at-file-attributes> element may be contained in the
<node> element for @file nodes::

    <at-file-attributes>
        <attr>key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx">value
        </attr>
        ...
    </at-file-attributes>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20110419083918.6104: *7* File format, v3 graphml
@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in <edge> elements if that
would be preferable.

Recent changes
==============

- Added <graphml> element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed <leo_file> to <leo:outline>
    - Renamed <descendant-attributes> to <leo:at-file-attributes>

- Used <leo:at-file-attributes> for marks, removing the special case.

- Enclosed <leo:descendant-attributes> in a (graphml) <data> element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
        

No session data
===============

There will be no <globals>, <preferences> or
<find_panel_settings> elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within <node> elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    <?xml version="1.0" encoding="utf-8"?>
    <?xml-stylesheet my_stylesheet?>
    <!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
    <leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/>
    <graphml xmlns="http://graphml.graphdrawing.org/xmlns"/>
    <graph>
    <nodes>
        <!-- marked attribute appears only if the vnode is marked -->
        <node id="gnx"> 
            <head>headline text</head>
            <attr key="marked">1</attr>
            <!-- uA's... -->
            <!-- format="string" is the default -->
            <attr key="a">a string</attr>
            <attr key="b" format="json">a json string</attr>
            <attr key="c" format="pickle">a pickled string</attr>
            <attr key="d" format="binhex">a binhexed string</attr>
            ...
            <body>body text</body>
        </node>
        ...
        <!-- @file nodes contain a <data> package -->
        <node id="gnx">
            <head>@file x.py</head>
            ...
            <data>
                <leo:at-file-attributes>
                    <attr>key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx">value
                    </attr>
                    ...
                </leo:at-file-attributes>
            </data>
        </node>
        ...
    </nodes>
    <edges>
        <edge type="child" from="gnx" to="gnx"</edge>
        ...
    </edges>
    </graph>
    </graphml>
    </leo:outline>

<attr> elements
===============

<attr> elements will one of the following forms::

    <attr key="a">a unicode string</attr>
    <attr key="b" format="json">a json string</attr>
    <attr key="c" format="pickle">a json string</attr>
    <attr key="d" format="binhex">a binhexed string</attr>
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No <attr> element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

<edge> elements
===============

<edge> elements will have the form::

    <edge type="child" from="gnx" to="gnx"/>
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    <edge type="undirected" from="gnx" to="gnx"/>
    <edge type="bidirectional" from="gnx" to="gnx"/>
    <edge type="backlink" from="gnx" to="gnx"/>
    <edge type="myPlugin" from="gnx" to="gnx"/>
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The <leo:at-file-attributes> element may be contained in the
<node> element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    <data>
        <leo:at-file-attributes>
            <attr>key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx">value
            </attr>
            ...
        </leo:at-file-attributes>
    </data>
    
In other words, we use the graphml <attr> element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
.. @+node:ekr.20090218115025.3: *7* Why are attributes pickled by default?
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

> On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney <ktenney@gmail.com> wrote:
>>
>> Currently, Leo pickles the value of unknown attributes unless
>> the name starts with 'str_'
>>
>> Running the following code in node 'UA'
>>
>> p = c.currentPosition()
>> p.v.u = {'hello':'world', 'str_hello':'world'}
>>
>> results in the following in the .leo file:
>>
>> <v t="ktenney.20090218114928.367" str_hello="world"
>> hello="5505776f726c6471002e"><vh>UA</vh></v>
>>
>> I think this is surprising, Python-centric and contrary to the
>> spirit of Leo as a flexible data management platform.
>
> I suppose your point is that you can't create an arbitrarily named attribute
> with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

> As far as being Python-centric, can you suggest any other way of converting
> arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

> Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
.. @+node:ekr.20110415173840.6098: *6* Code related to uA's
.. @+node:ekr.20040701065235.2: *7* putDescendentAttributes
def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
.. @+node:ekr.20080805071954.2: *7* putDescendentVnodeUas
def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
.. @+node:EKR.20040526202501: *7* putUnknownAttributes
def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
.. @+node:ekr.20090130114732.6: *7* v.u Property
def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
.. @+node:ekr.20110528034751.18273: *5* Global search in Nav plugin?
.. @+node:ekr.20110613110911.16421: *5* Read/write files in json format
.. @+node:ekr.20051110155735.1: *4* Improve Spell tab & spell checker
@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color
.. @+node:ekr.20090907080624.6081: *5* Spell checker should check headlines
.. @+node:ekr.20101004092958.5914: *4* Write treepad scanner
@ treepad.py is from the treepad website
.. @+node:ekr.20101004092958.5939: *5* treepad.py
@first #! /usr/local/bin/python

# treepad.py

@language python
@tabwidth -4
@others
if __name__ == '__main__':
    Main().Run()

.. @+node:ekr.20101004092958.5940: *6* treepad declarations
import sys, os, re, string

# constants
VERSION = "<Treepad version 2.7>"

# regexes
END_RE = re.compile(r'^<end node> ([^ ]+)$')
.. @+node:ekr.20101004092958.5941: *6* class Node
class Node:
    @others
.. @+node:ekr.20101004092958.5942: *7* __init__
def __init__(self):
    self.title    = ""
    self.level    = 0
    self.article  = []
    self.children = []
    self.parent   = None
    self.end      = ""
.. @+node:ekr.20101004092958.5943: *7* __str__
def __str__(self):
    return "%s/%d" % (self.title, self.level)
.. @+node:ekr.20101004092958.5944: *7* addchild
def addchild(self, node):
    assert self.level == node.level-1 and node.parent is None
    node.parent = self
    self.children.append( node )
.. @+node:ekr.20101004092958.5945: *7* findparent
def findparent(self, node):
    if self.level == (node.level-1): return self
    return self.parent.findparent(node)
.. @+node:ekr.20101004092958.5946: *7* writenode
def writenode(self, fp):
    fp.write("dt=Text\n")
    fp.write("<node>\n")
    fp.write("%s\n" % self.title)
    fp.write("%s\n" % self.level)
    for line in self.article:
        fp.write("%s\n" % line)
    fp.write("<end node> %s\n" % self.end)
.. @+node:ekr.20101004092958.5947: *7* writetree
def writetree(self, fp):
    self.writenode(fp)
    for node in self.children:
        node.writetree(fp)

.. @+node:ekr.20101004092958.5948: *6* class NodeReader
class NodeReader:
    @others
.. @+node:ekr.20101004092958.5949: *7* __init__
def __init__(self, fname, fp):
    self.fname    = fname
    self.fp       = fp
.. @+node:ekr.20101004092958.5950: *7* expect
def expect(self, text, line=None):
    if line is None:
        line = self.fp.readline().strip()
    assert line == text, "expected " + line + " == " + text
.. @+node:ekr.20101004092958.5951: *7* readstart
def readstart(self):
    self.expect(VERSION)
.. @+node:ekr.20101004092958.5952: *7* readnode
def readnode(self):
    line = self.fp.readline()
    if line is None:
        return None
    line = line.strip()
    if len(line) < 1:
        return None
    self.expect("dt=Text", line)
    self.expect("<node>")
    node = Node()
    node.title = self.fp.readline().strip()
    node.level = int(self.fp.readline().strip())
    while 1:
        line = self.fp.readline()
        m = re.match(END_RE, line)
        if m:
            node.end = m.group(1).strip()
            break
        node.article.append( line.strip() )
    return node

.. @+node:ekr.20101004092958.5953: *6* class TreeReader
class TreeReader:
    @others
.. @+node:ekr.20101004092958.5954: *7* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'r')
    self.nodereader = NodeReader(fname, fp)
    self.root = None
    self.prev = None
.. @+node:ekr.20101004092958.5955: *7* add
def add(self, node):
    if self.prev is None:
        assert node.level == 0
        self.root = node
    else:
        assert node.level > 0
        parent = self.prev.findparent(node)
        parent.addchild( node )
    self.prev = node
.. @+node:ekr.20101004092958.5956: *7* read
def read(self):
    self.nodereader.readstart()
    prev = None
    while 1:
        node = self.nodereader.readnode()
        if node is None: break
        self.add(node)

.. @+node:ekr.20101004092958.5957: *6* class TreeWriter
class TreeWriter:
    @others
.. @+node:ekr.20101004092958.5958: *7* __init__
def __init__(self, fname, fp=None):
    if fp is None: fp = open(fname, 'w')
    self.fname = fname
    self.fp    = fp
.. @+node:ekr.20101004092958.5959: *7* write
def write(self, root):
    self.fp.write("%s\n" % VERSION)
    root.writetree(self.fp)

.. @+node:ekr.20101004092958.5960: *6* class Main
class Main:
    @others
.. @+node:ekr.20101004092958.5961: *7* __init__
def __init__(self):
    self.infile  = sys.argv[1]
    self.outfile = sys.argv[2]
    self.reader  = TreeReader(self.infile)
    self.writer  = TreeWriter(self.outfile)
.. @+node:ekr.20101004092958.5962: *7* Run

def Run(self):
    self.reader.read()
    self.writer.write(self.reader.root)

.. @+node:ekr.20110520051220.18203: *4* Cross-tab search
@language rest

This would be a substitute for cross-file clones.
.. @+node:ekr.20071001052501: *4* Versioning for nodes
@nocolor

One feature I have not seen in SCS system is something which might be called
"history compression": I might be interested in having both version 5 and 6
in my source tree, when the current version is 7, but I am not really interested
in the 2000 steps which transformed 5 into 6 (just suggested this feature to
the bazaar people). This happens actually quite often to me, since I use the
SCS as a back-up system, saving many (uninteresting) intermediate steps while
implementing a new feature.
.. @+node:ekr.20080802070659.11: *4* Make node attributes visible, and supported by Leo's core
.. @+node:ekr.20110614123640.6587: *4* Add headline/color functions to Leo's core
@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/7e279fe3dedf42be/f00fde4df5b39ded

What uA should be used to specify node colors?

if the foreground / background color API uses uAs,
would/should the uAs use the reserved "leo_&lt;something&gt;"
namespace?

-------------------

Terry Brown

Sounds like something I may have brought up, long ago.

I was thinking that setting the fore/background color of nodes in the
tree should be a "gui core" function, and that the info should be
stored in uA, and so wanted to know what key should be used in uA for
that.  I think the docs say top level keys starting with "leo_" are
reserved, and probably wanted a ruling on

v.u['leo_fg'] = 'red'

vs

v.u['leo_tree_style']['fg'] = 'red'

etc.

I think the question may be more complicated than just what to call the
key, so you can probably retire the todo item.
.. @+node:ekr.20100112051224.6226: *4* Vim-related: Range prefix to commands/objects (k.getArgs)
The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
.. @+node:ekr.20110601105631.19373: *5* Simple vim bindings
.. @+node:ekr.20110601105631.19374: *6* Cursors
Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
.. @+node:ekr.20110601105631.19375: *6* Enter insert mode after ctrl-h
.. @+node:ekr.20110601105631.19376: *6* Colorize headline text depending on state
.. @+node:ekr.20110601105631.19377: *6* colon destroys alt-x binding
This project reorganizes makeBindingFromCommandsDict
.. @+node:ekr.20110530063322.18333: *4* scala not colored properly
.. @+node:ekr.20110518103946.18179: *4* Add external/leosax.py to leoPyRef.leo
http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
.. @+node:ekr.20090801103907.6018: *4* Add entries to global dicts for more languages (waiting for requests)
http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.

** Only c.getOpenWithExt uses app.language_extension_dict.

I'll wait until I get requests for particular language.
.. @+node:ekr.20110528103005.18323: *5* Found: extension_dict
.. @+node:ekr.20080819075811.13: *6* adjustTargetLanguage
def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
.. @+node:ekr.20090212054250.9: *6* c.createNodeFromExternalFile
def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
.. @+node:ekr.20031218072017.2824: *6* c.getOpenWithExt
def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @<file> tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
.. @+node:EKR.20040504150046.4: *6* g.comment_delims_from_extension
def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    >>> import leo.core.leoGlobals as g
    >>> g.comment_delims_from_extension(".py")
    ('#', '', '')

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    >>> g.comment_delims_from_extension(".html")
    ('', '<!--', '-->')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
.. @+node:ekr.20080811174246.1: *6* languageForExtension
def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
.. @+node:ekr.20031218072017.368: *5* << define global data structures >> (leoApp.py)
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @>", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "<!-- -->",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "<!-- -->",
    "xslt"          : "<!-- -->",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
.. @+node:ekr.20110528103005.18319: *5* Script to global data structures from in modes/*.py files
import glob
import imp

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)
theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

print('-'*40,len(aList))
known_keys = list(g.app.language_delims_dict.keys())
known_keys.sort()
known = []
computed = {}
for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2.startswith('__'): continue
    # if name2 in known_keys:
        # known.append(name)
        # continue
    try:
        theFile, pathname, description = imp.find_module(name2,[theDir])
        m = imp.load_module(name2, theFile, pathname, description)
    except Exception:
        g.es_exception()
        m = None
    if m:
        aList2 = [m.properties.get(z)
            for z in ('lineComment','commentStart','commentEnd')
                if m.properties.get(z)]
        print('%-20s : "%s",' % (
            '"%s"' % (name2),
            ' '.join(aList2)))
        computed[name2] = ' '.join(aList2)
mismatches = 0
for z in known_keys:
    val = g.app.language_delims_dict.get(z)
    val2 = computed.get(z)
    if not val:
        print('oops: no val',z)
    elif not val2:
        print('oops: no val2',z)
    elif val != val2:
        mismatches += 1
        print('mismatch for %s' % z)
        print(repr(val))
        print(repr(val2))
print('%s total languages' % len(aList))
print('%s new languages' % (len(list(computed.keys())) - len(known_keys)))
print('%s mismatches' % mismatches)
print('%s known language: %s' % (len(known_keys),known_keys))
.. @+node:ekr.20110527225107.18351: *4* Vague
@language rest

**Important**: These items are not scheduled for any release. They will be done
only if there are specific requests for them.

Eventually, all these items will move to the dreaded to-do-later list.
.. @+node:ekr.20110529115328.18238: *5* Emacs related: 5
I'll do these if and and only if somebody asks for them.
.. @+node:ekr.20110529104352.18248: *6* Complete k.universalDispatcher
.. @+node:ekr.20110529104352.18249: *6* Complete number-to-register command
.. @+node:ekr.20031218072017.753: *6* Emacs comint-mode
@nocolor

The improved Execute Script command does most of this

Michael Manti
mmanti@mac.com

P.S. I think a feature that could make Leo *the* IDE for developing in 
interpreted languages is something like the (X)Emacs comint-mode.el for 
interacting with the shell and interpreters.

comint-mode.el serves as the basis for interactive modes for a number of
languages--OCaml, Haskell, SML, among them. It allows for editing expressions in
one buffer and triggering their evaluation in another buffer that has an
interpreter running in it, along with entering commands in the interpreter
buffer and moving back and forth through the history of their evaluation.

Imagine being able to highlight a node in Leo, and have all the code in it and
its children evaluated in an interpreter running in a separate window or pane,
much as Leo can open a Python shell now. Users of those languages could build
plug-ins specific to their language atop that layer, and the @language directive
could activate that. I think that would be very cool.
.. @+node:ekr.20071004120359.2: *6* expand-region-abbrev
See: regionalExpandAbbrev.

You may wish to expand an abbrev with a prefix attached; for example, if `cnst'
expands into `construction', you might want to use it to enter `reconstruction'.
It does not work to type recnst, because that is not necessarily a defined
abbrev. What you can do is use the command M-' (abbrev-prefix-mark) in between
the prefix `re' and the abbrev `cnst'. First, insert `re'. Then type M-'; this
inserts a hyphen in the buffer to indicate that it has done its work. Then
insert the abbrev `cnst'; the buffer now contains `re-cnst'. Now insert a
non-word character to expand the abbrev `cnst' into `construction'. This
expansion step also deletes the hyphen that indicated M-' had been used. The
result is the desired `reconstruction'.

If you actually want the text of the abbrev in the buffer, rather than its
expansion, you can accomplish this by inserting the following punctuation with
C-q. Thus, foo C-q , leaves `foo,' in the buffer.
.. @+node:ekr.20060628103226.3: *6* Make sure repeat counts work on basic editing commands
.. @-all
.. @-leo
