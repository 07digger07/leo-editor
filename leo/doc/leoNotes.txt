#@+leo-ver=4-thin
#@+node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@@nocolor

#@+all
#@+node:ekr.20061116060847:@url http://www.jhorman.org/wikidPad/
#@-node:ekr.20061116060847:@url http://www.jhorman.org/wikidPad/
#@+node:ekr.20080917153158.10:Bzr notes
@nocolor

How to create/use private branches

===== Do this first: creates a branch directly, **without** having to use launchpad.

bzr push bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor-team/leo-editor/whatever  (public)

bzr push bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever (private)

===== pushes a branch after it has been created on launchpad

bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever

====== remembers the push

bzr push --remember bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever

===== creates branch on local machine: do this from leo.repo directory

bzr branch bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/whatever

-- OR --

bzr branch lp:leo-editor new-branch-name 

====== To resolve conflicts

kdiff3 file1 file2 file3 -m


Docs:
- http://doc.bazaar-vcs.org/latest/en/user-guide/index.html
    - http://bazaar-vcs.org/BzrWhy (referenced in sec 1.1.3 of the guide)
        - http://ianclatworthy.files.wordpress.com/2007/10/dvcs-why-and-how3.pdf
        - PQM: https://launchpad.net/pqm (google)
        - BB Bundle buggy: http://bundlebuggy.aaronbentley.com/help (google)
        - Spike solution: http://www.extremeprogramming.org/rules/spike.html (google)
- My log was at: http://bzr.arbash-meinel.com/irc_log/bzr/2008/02/bzr-2008-02-25.html

Windows

- Configuration file is .bazaar in XP C:\Documents and Settings\HP_Administrator\Application Data\bazaar\2.0

Linux:

- Configuration file is bazaar.conf in ~/.bazaar directory
#@-node:ekr.20080917153158.10:Bzr notes
#@+node:ekr.20081113095540.1:Bzr/ubuntu notes
/etc/apt/sources.list.d is a directory
It contains, on my machine, files called edgy-universe.list.x
The prefix doesn't matter, but the contents of these files must contain the proper ubuntu distro name,
for example, gutsy, hardy, intrepid.
#@nonl
#@-node:ekr.20081113095540.1:Bzr/ubuntu notes
#@+node:ekr.20070614094933:EasyInstall installation notes--XP
C:\prog>c:\python25\python ez_setup.py
Downloading http://cheeseshop.python.org/packages/2.5/s/setuptools/setuptools-0.6c6-py2.5.egg
Processing setuptools-0.6c6-py2.5.egg
Copying setuptools-0.6c6-py2.5.egg to c:\python25\lib\site-packages
Adding setuptools 0.6c6 to easy-install.pth file
Installing easy_install-script.py script to c:\python25\Scripts
Installing easy_install.exe script to c:\python25\Scripts
Installing easy_install-2.5-script.py script to c:\python25\Scripts
Installing easy_install-2.5.exe script to c:\python25\Scripts

Installed c:\python25\lib\site-packages\setuptools-0.6c6-py2.5.egg
Processing dependencies for setuptools==0.6c6
Finished processing dependencies for setuptools==0.6c6

C:\prog>c:\python24\python ez_setup.py
Downloading http://cheeseshop.python.org/packages/2.4/s/setuptools/setuptools-0.6c6-py2.4.egg
Processing setuptools-0.6c6-py2.4.egg
creating c:\python24\lib\site-packages\setuptools-0.6c6-py2.4.egg
Extracting setuptools-0.6c6-py2.4.egg to c:\python24\lib\site-packages
Adding setuptools 0.6c6 to easy-install.pth file
Installing easy_install-script.py script to c:\python24\Scripts
Installing easy_install.exe script to c:\python24\Scripts
Installing easy_install-2.4-script.py script to c:\python24\Scripts
Installing easy_install-2.4.exe script to c:\python24\Scripts

Installed c:\python24\lib\site-packages\setuptools-0.6c6-py2.4.egg
Processing dependencies for setuptools==0.6c6
#@nonl
#@-node:ekr.20070614094933:EasyInstall installation notes--XP
#@+node:ekr.20071104222805:Emacs/Pymacs notes
#@+node:ekr.20071102191642.1:xemacs/pymacs install notes
@nocolor

Added the following line to setup.py and setup files.

# -*- coding: utf-8 -*-

The second installation script installs the Emacs Lisp part only.
[snip]
I couldn't get this script to work.  Instead, I just created a pymacs folder at::

    C:\XEmacs\xemacs-packages\lisp\pymacs

For Win32 systems, I created create c:\Windows\pymacs-services.bat containing::

    c:\Python25\python C:\prog\Pymacs-0.22\scripts\pymacs-services

To check that pymacs.el is properly installed, start Emacs and do::

    M-x load-library RET pymacs

You should not receive any error.
(works)

To check that pymacs.py is properly installed, start an interactive Python session and type::

    from Pymacs import lisp

you should not receive any error.
(works)

To check that pymacs-services is properly installed, type the following in a console::

    pymacs-services </dev/null

You should then get a line ending with (pymacs-version version), and another saying : Protocol error : `>' expected..
(works, mostly: I omitted the </dev/null

The rest is from Leo's Chapter 18::

    ; Step 1: load leoPymacs if it has not already been loaded.
    (setq reload nil)
    (if (or reload (not (boundp 'leoPymacs)))
        (setq leoPymacs (pymacs-load "leoPymacs" "leo-"))
        (message "leoPymacs already loaded")
    )

    ; Step 2: compute the path to leo/test/ut.leo using a Leo script.
    (setq script
        "g.app.scriptResult = g.os_path_abspath(
            g.os_path_join(g.app.loadDir,'..','test','ut.leo'))"
    )
    (setq fileName (leo-run-script nil script))

    ; Step 3: execute a script in ut.leo.
    (setq c (leo-open fileName))
    (setq script "print 'c',c.shortFileName() ,'current:',c.currentPosition().headString()")
    (leo-run-script c script)
#@nonl
#@-node:ekr.20071102191642.1:xemacs/pymacs install notes
#@+node:ekr.20071103090504:Pymacs docs
@killcolor
#@nonl
#@+node:ekr.20071103090504.1:Emacs Lisp structures and Python objects
#@+node:ekr.20071103090504.2:Emacs lisp structures and Python
Conversions

Whenever Emacs Lisp calls Python functions giving them arguments, these arguments are Emacs Lisp structures that should be converted into Python objects in some way. Conversely, whenever Python calls Emacs Lisp functions, the arguments are Python objects that should be received as Emacs Lisp structures. We need some conventions for doing such conversions.

Conversions generally transmit mutable Emacs Lisp structures as mutable objects on the Python side, in such a way that transforming the object in Python will effectively transform the structure on the Emacs Lisp side (strings are handled a bit specially however, see below). The other way around, Python objects transmitted to Emacs Lisp often loose their mutability, so transforming the Emacs Lisp structure is not reflected on the Python side.

Pymacs sticks to standard Emacs Lisp, it explicitly avoids various Emacs Lisp extensions. One goal for many Pymacs users is taking some distance from Emacs Lisp, so Pymacs is not overly pushing users deeper into it.
#@-node:ekr.20071103090504.2:Emacs lisp structures and Python
#@+node:ekr.20071103090504.3:Simple objects
Simple objects

Emacs Lisp nil and the equivalent Emacs Lisp () yield Python None. Python None and the Python empty list [] are returned as nil in Emacs Lisp.

Emacs Lisp numbers, either integer or floating, are converted in equivalent Python numbers. Emacs Lisp characters are really numbers and yield Python numbers. In the other direction, Python numbers are converted into Emacs Lisp numbers, with the exception of long Python integers and complex numbers.

Emacs Lisp strings are usually converted into equivalent Python narrow strings. As Python strings do not have text properties, these are not reflected. This may be changed by setting the pymacs-mutable-strings option : if this variable is not nil, Emacs Lisp strings are then transmitted opaquely. Python strings, except Unicode, are always converted into Emacs Lisp strings.

Emacs Lisp symbols yield the special lisp.symbol or lisp[string] notations on the Python side. The first notation is used when the Emacs Lisp symbol starts with a letter, and contains only letters, digits and hyphens, in which case Emacs Lisp hyphens get replaced by Python underscores. This convention is welcome, as Emacs Lisp programmers commonly prefer using dashes, where Python programmers use underlines. Otherwise, the second notation is used. Conversely, lisp.symbol on the Python side yields an Emacs Lisp symbol with underscores replaced with hyphens, while lisp[string] corresponds to an Emacs Lisp symbol printed with that string which, of course, should then be a valid Emacs Lisp symbol name.
#@-node:ekr.20071103090504.3:Simple objects
#@+node:ekr.20071103090504.4:Sequences
Sequences

The case of strings has been discussed in the previous section.

Proper Emacs Lisp lists, those for which the cdr of last cell is nil, are normally transmitted opaquely to Python. If pymacs-forget-mutability is set, or if Python later asks for these to be expanded, proper Emacs Lisp lists get converted into Python lists, if we except the empty list, which is always converted as Python None. In the other direction, Python lists are always converted into proper Emacs Lisp lists.

Emacs Lisp vectors are normally transmitted opaquely to Python. However, if pymacs-forget-mutability is set, or if Python later asks for these to be expanded, Emacs Lisp vectors get converted into Python tuples. In the other direction, Python tuples are always converted into Emacs Lisp vectors.

Remember the rule : Round parentheses correspond to square brackets!. It works for lists, vectors, tuples, seen from either Emacs Lisp or Python.

The above choices were debatable. Since Emacs Lisp proper lists and Python lists are the bread-and-butter of algorithms modifying structures, at least in my experience, I guess they are more naturally mapped into one another, this spares many casts in practice. While in Python, the most usual idiom for growing lists is appending to their end, the most usual idiom in Emacs Lisp to grow a list is by cons'ing new items at its beginning :

     (setq accumulator (cons 'new-item accumulator))


or more simply :

     (push 'new-item accumulator)


So, in case speed is especially important and many modifications happen in a row on the same side, while order of elements ought to be preserved, some (nreverse ...) on the Emacs Lisp side or .reverse() on the Python side side might be needed. Surely, proper lists in Emacs Lisp and lists in Python are the normal structure for which length is easily modified.

We cannot so easily change the size of a vector, the same as it is a bit more of a stunt to modify a tuple. The shape of these objects is fixed. Mapping vectors to tuples, which is admittedly strange, will only be done if the Python side requests an expanded copy, otherwise an opaque Emacs Lisp object is seen in Python. In the other direction, whenever an Emacs Lisp vector is needed, one has to write tuple(python_list) while transmitting the object. Such transmissions are most probably to be unusual, as people are not going to blindly transmit whole big structures back and forth between Emacs and Python, they would rather do it once in a while only, and do only local modifications afterwards. The infrequent casting to tuple for getting an Emacs Lisp vector seems to suggest that we did a reasonable compromise.

In Python, both tuples and lists have O(1) access, so there is no real speed consideration there. Emacs Lisp is different : vectors have O(1) access while lists have O(N) access. The rigidity of Emacs Lisp vectors is such that people do not resort to vectors unless there is a speed issue, so in real Emacs Lisp practice, vectors are used rather parsimoniously. So much, in fact, that Emacs Lisp vectors are overloaded for what they are not meant : for example, very small vectors are used to represent X events in key-maps, programmers only want to test vectors for their type, or users just like bracketed syntax. The speed of access is hardly an issue then.
#@-node:ekr.20071103090504.4:Sequences
#@-node:ekr.20071103090504.1:Emacs Lisp structures and Python objects
#@+node:ekr.20071103090504.5:Opaque objects
#@+node:ekr.20071103090504.6:Emacs lisp handles
Emacs Lisp handles

When a Python function is called from Emacs Lisp, the function arguments have already been converted to Python types from Emacs Lisp types and the function result is going to be converted back to Emacs Lisp.

Several Emacs Lisp objects do not have Python equivalents, like for Emacs windows, buffers, markers, overlays, etc. It is nevertheless useful to pass them to Python functions, hoping that these Python functions will operate on these Emacs Lisp objects. Of course, the Python side may not itself modify such objects, it has to call for Emacs services to do so. Emacs Lisp handles are a mean to ease this communication.

Whenever an Emacs Lisp object may not be converted to a Python object, an Emacs Lisp handle is created and used instead. Whenever that Emacs Lisp handle is returned into Emacs Lisp from a Python function, or is used as an argument to an Emacs Lisp function from Python, the original Emacs Lisp object behind the Emacs Lisp handle is automatically retrieved.

Emacs Lisp handles are either instances of the internal Lisp class, or of one of its subclasses. If object is an Emacs Lisp handle, and if the underlying Emacs Lisp object is an Emacs Lisp sequence, then whenever object[index], object[index] = value and len(object) are meaningful, these may be used to fetch or alter an element of the sequence directly in Emacs Lisp space. Also, if object corresponds to an Emacs Lisp function, object(arguments) may be used to apply the Emacs Lisp function over the given arguments. Since arguments have been evaluated the Python way on the Python side, it would be conceptual overkill evaluating them again the Emacs Lisp way on the Emacs Lisp side, so Pymacs manage to quote arguments for defeating Emacs Lisp evaluation. The same logic applies the other way around.

Emacs Lisp handles have a value() method, which merely returns self. They also have a copy() method, which tries to open the box if possible. Emacs Lisp proper lists are turned into Python lists, Emacs Lisp vectors are turned into Python tuples. Then, modifying the structure of the copy on the Python side has no effect on the Emacs Lisp side.

For Emacs Lisp handles, str() returns an Emacs Lisp representation of the handle which should be eq to the original object if read back and evaluated in Emacs Lisp. repr() returns a Python representation of the expanded Emacs Lisp object. If that Emacs Lisp object has an Emacs Lisp representation which Emacs Lisp could read back, then repr() value is such that it could be read back and evaluated in Python as well, this would result in another object which is equal to the original, but not neccessarily eq.
#@-node:ekr.20071103090504.6:Emacs lisp handles
#@+node:ekr.20071103090504.7:Python handles
Python handles

The same as Emacs Lisp handles are useful for handling Emacs Lisp objects on the Python side, Python handles are useful for handling Python objects on the Emacs Lisp side.

Many Python objects do not have direct Emacs Lisp equivalents, including long integers, complex numbers, Unicode strings, modules, classes, instances and surely a lot of others. When such are being transmitted to the Emacs Lisp side, Pymacs use Python handles. These are automatically recovered into the original Python objects whenever transmitted back to Python, either as arguments to a Python function, as the Python function itself, or as the return value of an Emacs Lisp function called from Python.

The objects represented by these Python handles may be inspected or modified using the basic library of Python functions. For example, in :

     (setq matcher (pymacs-eval "re.compile('pattern').match"))
     (pymacs-call matcher argument)


the initial setq above could be decomposed into :

           (setq compiled (pymacs-eval "re.compile('pattern')")
     	    matcher (pymacs-call "getattr" compiled "match"))


This example shows that one may use pymacs-call with getattr as the function, to get a wanted attribute for a Python object.
#@-node:ekr.20071103090504.7:Python handles
#@-node:ekr.20071103090504.5:Opaque objects
#@+node:ekr.20071103090504.8:Usages on the Emacs lisp side
#@+node:ekr.20071103090504.9:pymacs-eval/apply

pymacs-eval

Function (pymacs-eval text) gets text evaluated as a Python expression, and returns the value of that expression converted back to Emacs Lisp.

pymacs-call

Function (pymacs-call function argument...) will get Python to apply the given function over zero or more argument. function is either a string holding Python source code for a function (like a mere name, or even an expression), or else, a Python handle previously received from Python, and hopefully holding a callable Python object. Each argument gets separately converted to Python before the function is called. pymacs-call returns the resulting value of the function call, converted back to Emacs Lisp.

pymacs-apply

Function (pymacs-apply function arguments) will get Python to apply the given function over the given arguments. arguments is a list containing all arguments, or nil if there is none. Besides arguments being bundled together instead of given separately, the function acts pretty much like pymacs-call.

We do not expect that pymacs-eval, pymacs-call or pymacs-apply will be much used, if ever. In practice, the Emacs Lisp side of a Pymacs application might call pymacs-load a few times for linking into the Python modules, with the indirect effect of defining trampoline functions for these modules on the Emacs Lisp side, which can later be called like usual Emacs Lisp functions.
#@-node:ekr.20071103090504.9:pymacs-eval/apply
#@+node:ekr.20071103090504.10:pymacs-load
pymacs-load

Function (pymacs-load module prefix) imports the Python module into Emacs Lisp space.

module is the name of the file containing the module, without any .py or .pyc extension. If the directory part is omitted in module, the module will be looked into the current Python search path. Dot notation may be used when the module is part of a package. Each top-level function in the module produces a trampoline function in Emacs Lisp having the same name, except that underlines in Python names are turned into dashes in Emacs Lisp, and that prefix is uniformly added before the Emacs Lisp name (as a way to avoid name clashes).

prefix may be omitted, in which case it defaults to base name of module with underlines turned into dashes, and followed by a dash.

Whenever pymacs_load_hook is defined in the loaded Python module, pymacs-load calls it without arguments, but before creating the Emacs view for that module. So, the pymacs_load_hook function may create new definitions or even add interaction attributes to functions.

The return value of a successful pymacs-load is the module object. An optional third argument, noerror, when given and not nil, will have pymacs-load to return nil instead of raising an error, if the Python module could not be found.

When later calling one of these trampoline functions, all provided arguments are converted to Python and transmitted, and the function return value is later converted back to Emacs Lisp. It is left to the Python side to check for argument consistency. However, for an interactive function, the interaction specification drives some checking on the Emacs Lisp side. Currently, there is no provision for collecting keyword arguments in Emacs Lisp.
#@-node:ekr.20071103090504.10:pymacs-load
#@-node:ekr.20071103090504.8:Usages on the Emacs lisp side
#@+node:ekr.20071103091052:Usage on the Python side
#@+node:ekr.20071103091052.1:Python setup
Python setup

Pymacs requires little or no setup in the Python modules which are meant to be used from Emacs, for the simple situations where these modules receive nothing but Emacs nil, numbers or strings, or return nothing but Python None, numbers or strings.

Otherwise, use from Pymacs import lisp. If you need more Pymacs features, like the Let class, write from Pymacs import lisp, Let.
#@-node:ekr.20071103091052.1:Python setup
#@+node:ekr.20071103091052.2:Response mode
Response mode

When Python receives a request from Emacs in the context of Pymacs, and until it returns the reply, Emacs keeps listening to serve Python requests. Emacs is not listening otherwise. Other Python threads, if any, may not call Emacs without very careful synchronisation.
#@-node:ekr.20071103091052.2:Response mode
#@+node:ekr.20071103091052.3:Emacs lisp symbols
Emacs Lisp symbols

lisp is a special object which has useful built-in magic. Its attributes do nothing but represent Emacs Lisp symbols, created on the fly as needed (symbols also have their built-in magic).

lisp.nil or lisp["nil"], are the same as None.

Otherwise, lisp.symbol and lisp[string] yield objects of the internal Symbol type. These are genuine Python objects, that could be referred to by simple Python variables. One may write quote = lisp.quote, for example, and use quote afterwards to mean that Emacs Lisp symbol. If a Python function received an Emacs Lisp symbol as an argument, it can check with == if that argument is lisp.never or lisp.ask, say. A Python function may well choose to return lisp.t.

In Python, writing lisp.symbol = value or lisp[string] = value does assign value to the corresponding symbol in Emacs Lisp space. Beware that in such cases, the lisp. prefix may not be [omitted] spared. After result = lisp.result, one cannot hope that a later result = 3 will have any effect in the Emacs Lisp space : this would merely change the Python variable result, which was a reference to a Symbol instance, so it is now a reference to the number 3.

The Symbol class has value() and copy() methods. One can use either lisp.symbol.value() or lisp.symbol.copy() to access the Emacs Lisp value of a symbol, after conversion to some Python object, of course. However, if value() would have given an Emacs Lisp handle, lisp.symbol.copy() has the effect of lisp.symbol.value().copy(), that is, it returns the value of the symbol as opened as possible.

A symbol may also be used as if it was a Python function, in which case it really names an Emacs Lisp function that should be applied over the following function arguments. The result of the Emacs Lisp function becomes the value of the call, with all due conversions of course.
#@-node:ekr.20071103091052.3:Emacs lisp symbols
#@+node:ekr.20071103091052.4:Dynamic bindings (The let class)
Dynamic bindings

As Emacs Lisp uses dynamic bindings, it is common that Emacs Lisp programs use let for temporarily setting new values for some Emacs Lisp variables having global scope. These variables recover their previous value automatically when the let gets completed, even if an error occurs which interrupts the normal flow of execution.

Pymacs has a Let class to represent such temporary settings. Suppose for example that you want to recover the value of lisp.mark() when the transient mark mode is active on the Emacs Lisp side. One could surely use lisp.mark(lisp.t) to force reading the mark in such cases, but for the sake of illustration, let's ignore that, and temporarily deactivate transient mark mode instead. This could be done this way :

         try :
     	let = Let()
     	let.push(transient_mark_mode=None)
     	... user code ...
         finally :
     	let.pop()


let.push() accepts any number of keywords arguments. Each keyword name is interpreted as an Emacs Lisp symbol written the Pymacs way, with underlines. The value of that Emacs Lisp symbol is saved on the Python side, and the value of the keyword becomes the new temporary value for this Emacs Lisp symbol. A later let.pop() restores the previous value for all symbols which were saved together at the time of the corresponding let.push(). There may be more than one let.push() call for a single Let instance, they stack within that instance. Each let.pop() will undo one and only one let.push() from the stack, in the reverse order or the pushes.

When the Let instance disappears, either because the programmer does del let or let = None, or just because the Python let variable goes out of scope, all remaining let.pop() get automatically executed, so the try/finally statement may be omitted in practice. For this omission to work flawlessly, the programmer should be careful at not keeping extra references to the Let instance.

The constructor call let = Let() also has an implied initial .push() over all given arguments, so the explicit let.push() may be omitted as well. In practice, this sums up and the above code could be reduced to a mere :

     let = Let(transient_mark_mode=None)
     ... user code ...


Be careful at assigning the result of the constructor to some Python variable. Otherwise, the instance would disappear immediately after having been created, restoring the Emacs Lisp variable much too soon.

Any variable to be bound with Let should have been bound in advance on the Emacs Lisp side. This restriction usually does no kind of harm. Yet, it will likely be lifted in some later version of Pymacs.

The Let class has other methods meant for some macros which are common in Emacs Lisp programming, in the spirit of let bindings. These method names look like push_* or pop_*, where Emacs Lisp macros are save-*. One has to use the matching pop_* for undoing the effect of a given push_* rather than a mere .pop() : the Python code is clearer, this also ensures that things are undone in the proper order. The same Let instance may use many push_* methods, their effects nest.

push_excursion() and pop_excursion() save and restore the current buffer, point and mark. push_match_data() and pop_match_data() save and restore the state of the last regular expression match. push_restriction() and pop_restriction() save and restore the current narrowing limits. push_selected_window() and pop_selected_window() save and restore the fact that a window holds the cursor. push_window_excursion() and pop_window_excursion() save and restore the current window configuration in the Emacs display.

As a convenience, let.push() and all other push_* methods return the Let instance. This helps chaining various push_* right after the instance generation. For example, one may write :

         let = Let().push_excursion()
         if True :
     	... user code ...
         del let


The if True: (use if 1: with older Python releases, some people might prefer writing if let: anyway), has the only goal of indenting user code, so the scope of the let variable is made very explicit. This is purely stylistic, and not at all necessary. The last del let might be omitted in a few circumstances, for example if the excursion lasts until the end of the Python function.
#@-node:ekr.20071103091052.4:Dynamic bindings (The let class)
#@+node:ekr.20071103091052.5:Raw Emacs lisp expression
Raw Emacs Lisp expressions

Pymacs offers a device for evaluating a raw Emacs Lisp expression, or a sequence of such, expressed as a string. One merely uses lisp as a function, like this :

     lisp("""
     ...
     possibly-long-sequence-of-lisp-expressions
     ...
     """)


The Emacs Lisp value of the last or only expression in the sequence becomes the value of the lisp call, after conversion back to Python.
#@-node:ekr.20071103091052.5:Raw Emacs lisp expression
#@+node:ekr.20071103091052.6:User interaction
User interaction

Emacs functions have the concept of user interaction for completing the specification of their arguments while being called. This happens only when a function is interactively called by the user, it does not happen when a function is programmatically called by another. As Python does not have a corresponding facility, a bit of trickery was needed to retrofit that facility on the Python side.

After loading a Python module but prior to creating an Emacs view for this module, Pymacs decides whether loaded functions will be interactively callable from Emacs, or not. Whenever a function has an interaction attribute, this attribute holds the Emacs interaction specification for this function. The specification is either another Python function or a string. In the former case, that other function is called without arguments and should, maybe after having consulted the user, return a list of the actual arguments to be used for the original function. In the latter case, the specification string is used verbatim as the argument to the (interactive ...) function on the Emacs side. To get a short reminder about how this string is interpreted on the Emacs side, try C-h f interactive within Emacs. Here is an example where an empty string is used to specify that an interactive has no arguments :

         from Pymacs import lisp

         def hello_world() :
     	"`Hello world' from Python."
     	lisp.insert("Hello from Python!")
         hello_world.interaction = ''

Versions of Python released before the integration of PEP 232 do not allow users to add attributes to functions, so there is a fallback mechanism. Let's presume that a given function does not have an interaction attribute as explained above. If the Python module contains an interactions global variable which is a dictionary, if that dictionary has an entry for the given function with a value other than None, that function is going to be interactive on the Emacs side. Here is how the preceeding example should be written for an older version of Python, or when portability is at premium :

         from Pymacs import lisp
         interactions = {}

         def hello_world() :
     	"`Hello world' from Python."
     	lisp.insert("Hello from Python!")
         interactions[hello_world] = ''

One might wonder why we do not merely use lisp.interactive(...) from within Python. There is some magic in the Emacs Lisp interpreter itself, looking for that call before the function is actually entered, this explains why (interactive ...) has to appear first in an Emacs Lisp defun. Pymacs could try to scan the already compiled form of the Python code, seeking for lisp.interactive, but as the evaluation of lisp.interactive arguments could get arbitrarily complex, it would a real challenge un-compiling that evaluation into Emacs Lisp.
#@-node:ekr.20071103091052.6:User interaction
#@+node:ekr.20071103091052.7:Key bindings
Keybindings

An interactive function may be bound to a key sequence.

To translate bindings like C-x w, say, one might have to know a bit more how Emacs Lisp processes string escapes like \C-x or \M-\C-x in Emacs Lisp, and emulate it within Python strings, since Python does not have such escapes. \C-L, where L is an upper case letter, produces a character which ordinal is the result of subtracting 0x40 from ordinal of L. \M- has the ordinal one gets by adding 0x80 to the ordinal of following described character. So people can use self-inserting non-ASCII characters, \M- is given another representation, which is to replace the addition of 0x80 by prefixing with `ESC', that is 0x1b.

So \C-x in Emacs is '\x18' in Python. This is easily found, using an interactive Python session, by givin it : chr(ord('X') - ord('A') + 1). An easier way would be using the kbd function on the Emacs Lisp side, like with lisp.kbd('C-x w') or lisp.kbd('M-<f2>').

To bind the F1 key to the helper function in some module :

     lisp.global_set_key((lisp.f1,), lisp.module_helper)


(item,) is a Python tuple yielding an Emacs Lisp vector. lisp.f1 translates to the Emacs Lisp symbol f1. So, Python (lisp.f1,) is Emacs Lisp [f1]. Keys like [M-f2] might require some more ingenuity, one may write either (lisp['M-f2'],) or (lisp.M_f2,) on the Python side.
#@-node:ekr.20071103091052.7:Key bindings
#@-node:ekr.20071103091052:Usage on the Python side
#@+node:ekr.20071103092153:Debugging
#@+node:ekr.20071103092153.1:The *pymacs* buffer
The *Pymacs* buffer

Emacs and Python are two separate processes (well, each may use more than one process). Pymacs implements a simple communication protocol between both, and does whatever needed so the programmers do not have to worry about details. The main debugging tool is the communication buffer between Emacs and Python, which is named *Pymacs*. As it is sometimes helpful to understand the communication protocol, it is briefly explained here, using an artificially complex example to do so. Consider :

     (pymacs-eval "lisp('(pymacs-eval \"`2L**111`\")')")
     "2596148429267413814265248164610048L"

Here, Emacs asks Python to ask Emacs to ask Python for a simple bignum computation. Note that Emacs does not natively know how to handle big integers, nor has an internal representation for them. This is why I use backticks, so Python returns a string representation of the result, instead of the result itself. Here is a trace for this example. The < character flags a message going from Python to Emacs and is followed by an expression written in Emacs Lisp. The > character flags a message going from Emacs to Python and is followed by a expression written in Python. The number gives the length of the message.

     <22   (pymacs-version "0.3")
     >49   eval("lisp('(pymacs-eval \"`2L**111`\")')")
     <25   (pymacs-eval "`2L**111`")
     >18   eval("`2L**111`")
     <47   (pymacs-reply "2596148429267413814265248164610048L")
     >45   reply("2596148429267413814265248164610048L")
     <47   (pymacs-reply "2596148429267413814265248164610048L")

Python evaluation is done in the context of the Pymacs.pymacs module, so for example a mere reply really means Pymacs.pymacs.reply. On the Emacs Lisp side, there is no concept of module namespaces, so we use the pymacs- prefix as an attempt to stay clean. Users should ideally refrain from naming their Emacs Lisp objects with a pymacs- prefix.

reply and pymacs-reply are special functions meant to indicate that an expected result is finally transmitted. error and pymacs-error are special functions that introduce a string which explains an exception which recently occurred. pymacs-expand is a special function implementing the copy() methods of Emacs Lisp handles or symbols. In all other cases, the expression is a request for the other side, that request stacks until a corresponding reply is received.

Part of the protocol manages memory, and this management generates some extra-noise in the *Pymacs* buffer. Whenever Emacs passes a structure to Python, an extra pointer is generated on the Emacs side to inhibit garbage collection by Emacs. Python garbage collector detects when the received structure is no longer needed on the Python side, at which time the next communication will tell Emacs to remove the extra pointer. It works symmetrically as well, that is, whenever Python passes a structure to Emacs, an extra Python reference is generated to inhibit garbage collection on the Python side. Emacs garbage collector detects when the received structure is no longer needed on the Emacs side, after which Python will be told to remove the extra reference. For efficiency, those allocation-related messages are delayed, merged and batched together within the next communication having another purpose.

Variable pymacs-trace-transit may be modified for controlling how and when the *Pymacs* buffer, or parts thereof, get erased.
#@-node:ekr.20071103092153.1:The *pymacs* buffer
#@+node:ekr.20071103092153.2:Usual Emacs debugging
Emacs usual debugging

If cross-calls between Emacs Lisp and Python nest deeply, an error will raise successive exceptions alternatively on both sides as requests unstack, and the diagnostic gets transmitted back and forth, slightly growing as we go. So, errors will eventually be reported by Emacs. I made no kind of effort to transmit the Emacs Lisp backtrace on the Python side, as I do not see a purpose for it : all debugging is done within Emacs windows anyway.

On recent Emacses, the Python backtrace gets displayed in the mini-buffer, and the Emacs Lisp backtrace is simultaneously shown in the *Backtrace* window. One useful thing is to allow to mini-buffer to grow big, so it has more chance to fully contain the Python backtrace, the last lines of which are often especially useful. Here, I use :

         (setq resize-mini-windows t
     	  max-mini-window-height .85)


in my .emacs file, so the mini-buffer may use 85% of the screen, and quickly shrinks when fewer lines are needed. The mini-buffer contents disappear at the next keystroke, but you can recover the Python backtrace by looking at the end of the *Messages* buffer. In which case the ffap package in Emacs may be yet another friend! From the *Messages* buffer, once ffap activated, merely put the cursor on the file name of a Python module from the backtrace, and C-x C-f RET will quickly open that source for you.
#@-node:ekr.20071103092153.2:Usual Emacs debugging
#@+node:ekr.20071103092153.3:Auto-reloading on save
Auto-reloading on save

I found useful to automatically pymacs-load some Python files whenever they get saved from Emacs. This can be decided on a per-file or per-directory basis. To get a particular Python file to be reloaded automatically on save, add the following lines at the end :

     # Local Variables :
     # pymacs-auto-reload : t
     # End :


Here is an example of automatic reloading on a per-directory basis. The code below assumes that Python files meant for Pymacs are kept in ~/share/emacs/python.

         (defun fp-maybe-pymacs-reload ()
           (let ((pymacsdir (expand-file-name "~/share/emacs/python/")))
     	(when (and (string-equal (file-name-directory buffer-file-name)
     				 pymacsdir)
     		   (string-match "\\.py\\'" buffer-file-name))
     	  (pymacs-load (substring buffer-file-name 0 -3)))))
         (add-hook 'after-save-hook 'fp-maybe-pymacs-reload)
#@-node:ekr.20071103092153.3:Auto-reloading on save
#@-node:ekr.20071103092153:Debugging
#@+node:ekr.20071103092153.4:Example 1: defining an Emacs command in Python
@nocolor
Let's say I have a a module, call it manglers.py, containing this simple python function::

    def break_on_whitespace(some_string) :
         words = some_string.split()
         return '\n'.join(words)

The goal is telling Emacs about this function so that I can call it on a region of text and replace the region with the result of the call. We shall also bind this function to the key [f7].

Here is the Python side::
@color

    from Pymacs import lisp
    interactions = {}

    def break_on_whitespace():
        # start and end may be given in any order.
        start,end = lisp.point(),lisp.mark(lisp.t)
        words = lisp.buffer_substring(start, end).split()
        lisp.delete_region(start,end)
        lisp.insert('\n'.join(words))

    interactions[break_on_whitespace] = ''
@nocolor

Here is the emacs side::

    (pymacs-load "manglers")
    (global-set-key [f7] 'manglers-break-on-whitespace)
#@-node:ekr.20071103092153.4:Example 1: defining an Emacs command in Python
#@+node:ekr.20071103093725:Example 3: defining a rebox tool
For comments held within boxes, it is painful to fill paragraphs, while
stretching or shrinking the surrounding box by hand, as needed. This piece of
Python code eases my life on this. It may be used interactively from within
Emacs through the Pymacs interface, or in batch as a script which filters a
single region to be reformatted.

In batch mode, the reboxing is driven by command options and arguments and expects a
complete, self-contained boxed comment from a file.

Emacs function rebox-region also presumes that the region encloses a single
boxed comment.

Emacs rebox-comment is different, as it has to chase itself the extent of the
surrounding boxed comment.

#@+node:ekr.20071103094355:The python side
Design notes for rebox.py:

Pymacs specific features are used exclusively from within the pymacs_load_hook function and the Emacs_Rebox class. In batch mode, Pymacs is not even imported.

In batch mode, as well as with rebox-region, the text to handle is turned over to Python, and fully processed in Python, with practically no Pymacs interaction while the work gets done. On the other hand, rebox-comment is rather Pymacs intensive: the comment boundaries are chased right from the Emacs buffer, as directed by the function Emacs_Rebox.find_comment. Once the boundaries are found, the remainder of the work is essentially done on the Python side.

Once the boxed comment has been reformatted in Python, the old comment is removed in a single delete operation, the new comment is inserted in a second operation. This occurs in Emacs_Rebox.process_emacs_region. But by doing so, if point was within the boxed comment before the reformatting, its precise position is lost. To well preserve point, Python might have driven all reformatting details directly in the Emacs buffer. We really preferred doing it all on the Python side : as we gain legibility by expressing the algorithms in pure Python, the same Python code may be used in batch or interactively, and we avoid the slowdown that would result from heavy use of Emacs services.

To avoid completely loosing point, I kludged a Marker class, which goal is to estimate the new value of point from the old. Reformatting may change the amount of white space, and either delete or insert an arbitrary number characters meant to draw the box. The idea is to initially count the number of characters between the beginning of the region and point, while ignoring any problematic character. Once the comment has been reboxed, point is advanced from the beginning of the region until we get the same count of characters, skipping all problematic characters. This Marker class works fully on the Python side, it does not involve Pymacs at all, but it does solve a problem that resulted from my choice of keeping the data on the Python side instead of handling it directly in the Emacs buffer.

We want a comment reformatting to appear as a single operation, in the context of Emacs Undo. The method Emacs_Rebox.clean_undo_after handles the general case for this. Not that we do so much in practice : a reformatting implies one delete-region and one insert, and maybe some other little adjustements at Emacs_Rebox.find_comment time. Even if this method scans and mofifies an Emacs Lisp list directly in the Emacs memory, the code doing this stays neat and legible. However, I found out that the undo list may grow quickly when the Emacs buffer use markers, with the consequence of making this routine so Pymacs intensive that most of the CPU is spent there. I rewrote that routine in Emacs Lisp so it executes in a single Pymacs interaction.

Function Emacs_Rebox.remainder_of_line could have been written in Python, but it was probably not worth going away from this one-liner in Emacs Lisp. Also, given this routine is often called by find_comment, a few Pymacs protocol interactions are spared this way. This function is useful when there is a need to apply a regexp already compiled on the Python side, it is probably better fetching the line from Emacs and do the pattern match on the Python side, than transmitting the source of the regexp to Emacs for it to compile and apply it.

For refilling, I could have either used the refill algorithm built within in Emacs, programmed a new one in Python, or relied on Ross Paterson's fmt, distributed by GNU and available on most Linuxes. In fact, refill_lines prefers the latter. My own Emacs setup is such that the built-in refill algorithm is already overridden by GNU fmt, and it really does a much better job. Experience taught me that calling an external program is fast enough to be very bearable, even interactively. If Python called Emacs to do the refilling, Emacs would itself call GNU fmt in my case, I preferred that Python calls GNU fmt directly. I could have reprogrammed GNU fmt in Python. Despite interesting, this is an uneasy project : fmt implements the Knuth refilling algorithm, which depends on dynamic programming techniques; Ross did carefully fine tune them, and took care of many details. If GNU fmt fails, for not being available, say, refill_lines falls back on a dumb refilling algorithm, which is better than none.
#@-node:ekr.20071103094355:The python side
#@+node:ekr.20071103094355.1:The emacs side
For most Emacs language editing modes, refilling does not make sense
outside comments, one may redefine the `M-q' command and link it to this
Pymacs module.  For example, I use this in my `.emacs' file::

    (add-hook 'c-mode-hook 'fp-c-mode-routine)
    (defun fp-c-mode-routine ()
        (local-set-key "\M-q" 'rebox-comment))
    (autoload 'rebox-comment "rebox" nil t)
    (autoload 'rebox-region "rebox" nil t)

with a "rebox.el" file having this single line:

    (pymacs-load "Pymacs.rebox")

The Emacs function `rebox-comment' automatically discovers the extent of the
boxed comment near the cursor, possibly refills the text, then adjusts the box
style. When this command is executed, the cursor should be within a comment, or
else it should be between two comments, in which case the command applies to the
next comment.

The Emacs function `rebox-region' does the same, except that it takes the
current region as a boxed comment. Both commands obey numeric prefixes to add or
remove a box, force a particular box style, or to prevent refilling of text.
Without such prefixes, the commands may deduce the current box style from the
comment itself so the style is preserved.

The default style initial value is nil or 0.  It may be preset to another
value through calling `rebox-set-default-style' from Emacs LISP, or changed
to anything else though using a negative value for a prefix, in which case
the default style is set to the absolute value of the prefix.

A `C-u' prefix avoids refilling the text, but forces using the default box
style.  `C-u -' lets the user interact to select one attribute at a time.

Adding new styles
-----------------

Let's suppose you want to add your own boxed comment style, say:

    //--------------------------------------------+
    // This is the style mandated in our company.
    //--------------------------------------------+

You might modify `rebox.py' but then, you will have to edit it whenever you
get a new release of `pybox.py'.  Emacs users might modify their `.emacs'
file or their `rebox.el' bootstrap, if they use one.  In either cases,
after the `(pymacs-load "Pymacs.rebox")' line, merely add:

    (rebox-Template NNN MMM ["//-----+"
                             "// box  "
                             "//-----+"])

In batch mode [If you use the `rebox' script rather than Emacs], the simplest is to make
your own.  This is easy, as it is very small.  For example, the above
style could be implemented by using this script instead of `rebox':

    #!/usr/bin/env python
    import sys
    from Pymacs import rebox
    rebox.Template(226, 325, ('//-----+',
                              '// box  ',
                              '//-----+'))
    apply(rebox.main, tuple(sys.argv[1:]))

In all cases, NNN is the style three-digit number, with no zero digit.
Pick any free style number, you are safe with 911 and up.  MMM is the
recognition priority, only used to disambiguate the style of a given boxed
comments, when it matches many styles at once.  Try something like 400.
Raise or lower that number as needed if you observe false matches.

Usually, the template uses three lines of equal length.  Do not worry if
this implies a few trailing spaces, they will be cleaned up automatically
at box generation time.  The first line or the third line may be omitted
to create vertically opened boxes.  But the middle line may not be omitted,
it ought to include the word `box', which will get replaced by your actual
comment.  If the first line is shorter than the middle one, it gets merged
at the start of the comment.  If the last line is shorter than the middle
one, it gets merged at the end of the comment and is refilled with it.
#@nonl
#@-node:ekr.20071103094355.1:The emacs side
#@+node:ekr.20071103093725.1:rebox.py
@color
@language python
@tabwidth -4

@others
<< templates >>

if __name__ == '__main__':
    apply(main, sys.argv[1:])
#@+node:ekr.20071103093725.2:rebox declarations
#!/usr/bin/env python
# Copyright © 1991-1998, 2000, 2002 Progiciels Bourbeau-Pinard inc.
# François Pinard <pinard@iro.umontreal.ca>, April 1991.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""\
Handling of boxed comments in various box styles.

Introduction
------------

For comments held within boxes, it is painful to fill paragraphs, while
stretching or shrinking the surrounding box "by hand", as needed.  This piece
of Python code eases my life on this.  It may be used interactively from
within Emacs through the Pymacs interface, or in batch as a script which
filters a single region to be reformatted.  I find only fair, while giving
all sources for a package using such boxed comments, to also give the
means I use for nicely modifying comments.  So here they are!

Box styles
----------

Each supported box style has a number associated with it.  This number is
arbitrary, yet by _convention_, it holds three non-zero digits such the the
hundreds digit roughly represents the programming language, the tens digit
roughly represents a box quality (or weight) and the units digit roughly
a box type (or figure).  An unboxed comment is merely one of box styles.
Language, quality and types are collectively referred to as style attributes.

When rebuilding a boxed comment, attributes are selected independently
of each other.  They may be specified by the digits of the value given
as Emacs commands argument prefix, or as the `-s' argument to the `rebox'
script when called from the shell.  If there is no such prefix, or if the
corresponding digit is zero, the attribute is taken from the value of the
default style instead.  If the corresponding digit of the default style
is also zero, than the attribute is recognised and taken from the actual
boxed comment, as it existed before prior to the command.  The value 1,
which is the simplest attribute, is ultimately taken if the parsing fails.

A programming language is associated with comment delimiters.  Values are
100 for none or unknown, 200 for `/*' and `*/' as in plain C, 300 for `//'
as in C++, 400 for `#' as in most scripting languages, 500 for `;' as in
LISP or assembler and 600 for `%' as in TeX or PostScript.

Box quality differs according to language. For unknown languages (100) or
for the C language (200), values are 10 for simple, 20 for rounded, and
30 or 40 for starred.  Simple quality boxes (10) use comment delimiters
to left and right of each comment line, and also for the top or bottom
line when applicable. Rounded quality boxes (20) try to suggest rounded
corners in boxes.  Starred quality boxes (40) mostly use a left margin of
asterisks or X'es, and use them also in box surroundings.  For all others
languages, box quality indicates the thickness in characters of the left
and right sides of the box: values are 10, 20, 30 or 40 for 1, 2, 3 or 4
characters wide.  With C++, quality 10 is not useful, it is not allowed.

Box type values are 1 for fully opened boxes for which boxing is done
only for the left and right but not for top or bottom, 2 for half
single lined boxes for which boxing is done on all sides except top,
3 for fully single lined boxes for which boxing is done on all sides,
4 for half double lined boxes which is like type 2 but more bold,
or 5 for fully double lined boxes which is like type 3 but more bold.

The special style 221 is for C comments between a single opening `/*'
and a single closing `*/'.  The special style 111 deletes a box.

Batch usage
-----------

Usage is `rebox [OPTION]... [FILE]'.  By default, FILE is reformatted to
standard output by refilling the comment up to column 79, while preserving
existing boxed comment style.  If FILE is not given, standard input is read.
Options may be:

  -n         Do not refill the comment inside its box, and ignore -w.
  -s STYLE   Replace box style according to STYLE, as explained above.
  -t         Replace initial sequence of spaces by TABs on each line.
  -v         Echo both the old and the new box styles on standard error.
  -w WIDTH   Try to avoid going over WIDTH columns per line.

So, a single boxed comment is reformatted by invocation.  `vi' users, for
example, would need to delimit the boxed comment first, before executing
the `!}rebox' command (is this correct? my `vi' recollection is far away).

Batch usage is also slow, as internal structures have to be reinitialised
at every call.  Producing a box in a single style is fast, but recognising
the previous style requires setting up for all possible styles.

Emacs usage
-----------

For most Emacs language editing modes, refilling does not make sense
outside comments, one may redefine the `M-q' command and link it to this
Pymacs module.  For example, I use this in my `.emacs' file:

     (add-hook 'c-mode-hook 'fp-c-mode-routine)
     (defun fp-c-mode-routine ()
       (local-set-key "\M-q" 'rebox-comment))
     (autoload 'rebox-comment "rebox" nil t)
     (autoload 'rebox-region "rebox" nil t)

with a "rebox.el" file having this single line:

     (pymacs-load "Pymacs.rebox")

Install Pymacs from `http://www.iro.umontreal.ca/~pinard/pymacs.tar.gz'.

The Emacs function `rebox-comment' automatically discovers the extent of
the boxed comment near the cursor, possibly refills the text, then adjusts
the box style.  When this command is executed, the cursor should be within
a comment, or else it should be between two comments, in which case the
command applies to the next comment.  The function `rebox-region' does
the same, except that it takes the current region as a boxed comment.
Both commands obey numeric prefixes to add or remove a box, force a
particular box style, or to prevent refilling of text.  Without such
prefixes, the commands may deduce the current box style from the comment
itself so the style is preserved.

The default style initial value is nil or 0.  It may be preset to another
value through calling `rebox-set-default-style' from Emacs LISP, or changed
to anything else though using a negative value for a prefix, in which case
the default style is set to the absolute value of the prefix.

A `C-u' prefix avoids refilling the text, but forces using the default box
style.  `C-u -' lets the user interact to select one attribute at a time.

Adding new styles
-----------------

Let's suppose you want to add your own boxed comment style, say:

    //--------------------------------------------+
    // This is the style mandated in our company.
    //--------------------------------------------+

You might modify `rebox.py' but then, you will have to edit it whenever you
get a new release of `pybox.py'.  Emacs users might modify their `.emacs'
file or their `rebox.el' bootstrap, if they use one.  In either cases,
after the `(pymacs-load "Pymacs.rebox")' line, merely add:

    (rebox-Template NNN MMM ["//-----+"
                             "// box  "
                             "//-----+"])

If you use the `rebox' script rather than Emacs, the simplest is to make
your own.  This is easy, as it is very small.  For example, the above
style could be implemented by using this script instead of `rebox':

    #!/usr/bin/env python
    import sys
    from Pymacs import rebox
    rebox.Template(226, 325, ('//-----+',
                              '// box  ',
                              '//-----+'))
    apply(rebox.main, tuple(sys.argv[1:]))

In all cases, NNN is the style three-digit number, with no zero digit.
Pick any free style number, you are safe with 911 and up.  MMM is the
recognition priority, only used to disambiguate the style of a given boxed
comments, when it matches many styles at once.  Try something like 400.
Raise or lower that number as needed if you observe false matches.

On average, the template uses three lines of equal length.  Do not worry if
this implies a few trailing spaces, they will be cleaned up automatically
at box generation time.  The first line or the third line may be omitted
to create vertically opened boxes.  But the middle line may not be omitted,
it ought to include the word `box', which will get replaced by your actual
comment.  If the first line is shorter than the middle one, it gets merged
at the start of the comment.  If the last line is shorter than the middle
one, it gets merged at the end of the comment and is refilled with it.

History
-------

I first observed rounded corners, as in style 223 boxes, in code from
Warren Tucker, a previous maintainer of the `shar' package, circa 1980.

Except for very special files, I carefully avoided boxed comments for
real work, as I found them much too hard to maintain.  My friend Paul
Provost was working at Taarna, a computer graphics place, which had boxes
as part of their coding standards.  He asked that we try something to get
him out of his misery, and this how `rebox.el' was originally written.
I did not plan to use it for myself, but Paul was so enthusiastic that I
timidly started to use boxes in my things, very little at first, but more
and more as time passed, still in doubt that it was a good move.  Later,
many friends spontaneously started to use this tool for real, some being very
serious workers.  This convinced me that boxes are acceptable, after all.

I do not use boxes much with Python code.  It is so legible that boxing
is not that useful.  Vertical white space is less necessary, too.  I even
avoid white lines within functions.  Comments appear prominent enough when
using highlighting editors like Emacs or nice printer tools like `enscript'.

After Emacs could be extended with Python, in 2001, I translated `rebox.el'
into `rebox.py', and added the facility to use it as a batch script.
"""

## Note: This code is currently compatible down to Python version 1.5.2.
## It is probably worth keeping it that way for a good while, still.

## Note: a double hash comment introduces a group of functions or methods.

import re, string, sys

#@-node:ekr.20071103093725.2:rebox declarations
#@+node:ekr.20071103093725.3:main
def main(*arguments):
    refill = 1
    style = None
    tabify = 0
    verbose = 0
    width = 79
    import getopt
    options, arguments = getopt.getopt(arguments, 'ns:tvw:', ['help'])
    for option, value in options:
        if option == '--help':
            sys.stdout.write(__doc__)
            sys.exit(0)
        elif option == '-n':
            refill = 0
        elif option == '-s':
            style = int(value)
        elif option == '-t':
            tabify = 1
        elif option == '-v':
            verbose = 1
        elif option == '-w':
            width = int(value)
    if len(arguments) == 0:
        text = sys.stdin.read()
    elif len(arguments) == 1:
        text = open(arguments[0]).read()
    else:
        sys.stderr.write("Invalid usage, try `rebox --help' for help.\n")
        sys.exit(1)
    old_style, new_style, text, position = engine(
        text, style=style, width=width, refill=refill, tabify=tabify)
    if text is None:
        sys.stderr.write("* Cannot rebox to style %d.\n" % new_style)
        sys.exit(1)
    sys.stdout.write(text)
    if verbose:
        if old_style == new_style:
            sys.stderr.write("Reboxed with style %d.\n" % old_style)
        else:
            sys.stderr.write("Reboxed from style %d to %d.\n"
                             % (old_style, new_style))

#@-node:ekr.20071103093725.3:main
#@+node:ekr.20071103093725.4:pymacs_load_hook
def pymacs_load_hook():
    global interactions, lisp, Let, region, comment, set_default_style
    from Pymacs import lisp, Let
    emacs_rebox = Emacs_Rebox()
    # Declare functions for Emacs to import.
    interactions = {}
    region = emacs_rebox.region
    interactions[region] = 'P'
    comment = emacs_rebox.comment
    interactions[comment] = 'P'
    set_default_style = emacs_rebox.set_default_style

#@-node:ekr.20071103093725.4:pymacs_load_hook
#@+node:ekr.20071103093725.5:class Emacs_Rebox
class Emacs_Rebox:
    @others
#@+node:ekr.20071103093725.6:__init__

def __init__(self):
    self.default_style = None

#@-node:ekr.20071103093725.6:__init__
#@+node:ekr.20071103093725.7:set_default_style
def set_default_style(self, style):
    """\
Set the default style to STYLE.
"""
    self.default_style = style

#@-node:ekr.20071103093725.7:set_default_style
#@+node:ekr.20071103093725.8:region
def region(self, flag):
    """\
Rebox the boxed comment in the current region, obeying FLAG.
"""
    self.emacs_engine(flag, self.find_region)

#@-node:ekr.20071103093725.8:region
#@+node:ekr.20071103093725.9:comment
def comment(self, flag):
    """\
Rebox the surrounding boxed comment, obeying FLAG.
"""
    self.emacs_engine(flag, self.find_comment)

#@-node:ekr.20071103093725.9:comment
#@+node:ekr.20071103093725.10:emacs_engine
def emacs_engine(self, flag, find_limits):
    """\
Rebox text while obeying FLAG.  Call FIND_LIMITS to discover the extent
of the boxed comment.
"""
    # `C-u -' means that box style is to be decided interactively.
    if flag == lisp['-']:
        flag = self.ask_for_style()
    # If FLAG is zero or negative, only change default box style.
    if type(flag) is type(0) and flag <= 0:
        self.default_style = -flag
        lisp.message("Default style set to %d" % -flag)
        return
    # Decide box style and refilling.
    if flag is None:
        style = self.default_style
        refill = 1
    elif type(flag) == type(0):
        if self.default_style is None:
            style = flag
        else:
            style = merge_styles(self.default_style, flag)
        refill = 1
    else:
        flag = flag.copy()
        if type(flag) == type([]):
            style = self.default_style
            refill = 0
        else:
            lisp.error("Unexpected flag value %s" % flag)
    # Prepare for reboxing.
    lisp.message("Reboxing...")
    checkpoint = lisp.buffer_undo_list.value()
    start, end = find_limits()
    text = lisp.buffer_substring(start, end)
    width = lisp.fill_column.value()
    tabify = lisp.indent_tabs_mode.value() is not None
    point = lisp.point()
    if start <= point < end:
        position = point - start
    else:
        position = None
    # Rebox the text and replace it in Emacs buffer.
    old_style, new_style, text, position = engine(
        text, style=style, width=width,
        refill=refill, tabify=tabify, position=position)
    if text is None:
        lisp.error("Cannot rebox to style %d" % new_style)
    lisp.delete_region(start, end)
    lisp.insert(text)
    if position is not None:
        lisp.goto_char(start + position)
    # Collapse all operations into a single one, for Undo.
    self.clean_undo_after(checkpoint)
    # We are finished, tell the user.
    if old_style == new_style:
        lisp.message("Reboxed with style %d" % old_style)
    else:
        lisp.message("Reboxed from style %d to %d"
                     % (old_style, new_style))

#@-node:ekr.20071103093725.10:emacs_engine
#@+node:ekr.20071103093725.11:ask_for_style
def ask_for_style(self):
    """\
Request the style interactively, using the minibuffer.
"""
    language = quality = type = None
    while language is None:
        lisp.message("\
Box language is 100-none, 200-/*, 300-//, 400-#, 500-;, 600-%%")
        key = lisp.read_char()
        if key >= ord('0') and key <= ord('6'):
            language = key - ord('0')
    while quality is None:
        lisp.message("\
Box quality/width is 10-simple/1, 20-rounded/2, 30-starred/3 or 40-starred/4")
        key = lisp.read_char()
        if key >= ord('0') and key <= ord('4'):
            quality = key - ord('0')
    while type is None:
        lisp.message("\
Box type is 1-opened, 2-half-single, 3-single, 4-half-double or 5-double")
        key = lisp.read_char()
        if key >= ord('0') and key <= ord('5'):
            type = key - ord('0')
    return 100*language + 10*quality + type

#@-node:ekr.20071103093725.11:ask_for_style
#@+node:ekr.20071103093725.12:find_region
def find_region(self):
    """\
Return the limits of the region.
"""
    return lisp.point(), lisp.mark(lisp.t)

#@-node:ekr.20071103093725.12:find_region
#@+node:ekr.20071103093725.13:find_comment
def find_comment(self):
    """\
Find and return the limits of the block of comments following or enclosing
the cursor, or return an error if the cursor is not within such a block
of comments.  Extend it as far as possible in both directions.
"""
    let = Let()
    let.push_excursion()
    # Find the start of the current or immediately following comment.
    lisp.beginning_of_line()
    lisp.skip_chars_forward(' \t\n')
    lisp.beginning_of_line()
    if not language_matcher[0](self.remainder_of_line()):
        temp = lisp.point()
        if not lisp.re_search_forward('\\*/', None, lisp.t):
            lisp.error("outside any comment block")
        lisp.re_search_backward('/\\*')
        if lisp.point() > temp:
            lisp.error("outside any comment block")
        temp = lisp.point()
        lisp.beginning_of_line()
        lisp.skip_chars_forward(' \t')
        if lisp.point() != temp:
            lisp.error("text before start of comment")
        lisp.beginning_of_line()
    start = lisp.point()
    language = guess_language(self.remainder_of_line())
    # Find the end of this comment.
    if language == 2:
        lisp.search_forward('*/')
        if not lisp.looking_at('[ \t]*$'):
            lisp.error("text after end of comment")
    lisp.end_of_line()
    if lisp.eobp():
        lisp.insert('\n')
    else:
        lisp.forward_char(1)
    end = lisp.point()
    # Try to extend the comment block backwards.
    lisp.goto_char(start)
    while not lisp.bobp():
        if language == 2:
            lisp.skip_chars_backward(' \t\n')
            if not lisp.looking_at('[ \t]*\n[ \t]*/\\*'):
                break
            if lisp.point() < 2:
                break
            lisp.backward_char(2)
            if not lisp.looking_at('\\*/'):
                break
            lisp.re_search_backward('/\\*')
            temp = lisp.point()
            lisp.beginning_of_line()
            lisp.skip_chars_forward(' \t')
            if lisp.point() != temp:
                break
            lisp.beginning_of_line()
        else:
            lisp.previous_line(1)
            if not language_matcher[language](self.remainder_of_line()):
                break
        start = lisp.point()
    # Try to extend the comment block forward.
    lisp.goto_char(end)
    while language_matcher[language](self.remainder_of_line()):
        if language == 2:
            lisp.re_search_forward('[ \t]*/\\*')
            lisp.re_search_forward('\\*/')
            if lisp.looking_at('[ \t]*$'):
                lisp.beginning_of_line()
                lisp.forward_line(1)
                end = lisp.point()
        else:
            lisp.forward_line(1)
            end = lisp.point()
    return start, end

#@-node:ekr.20071103093725.13:find_comment
#@+node:ekr.20071103093725.14:remainder_of_line
def remainder_of_line(self):
    """\
Return all characters between point and end of line in Emacs buffer.
"""
    return lisp('''\
(buffer-substring (point) (save-excursion (skip-chars-forward "^\n") (point)))
''')

#@-node:ekr.20071103093725.14:remainder_of_line
#@+node:ekr.20071103093725.15:clean_undo_after_old
def clean_undo_after_old(self, checkpoint):
    """\
Remove all intermediate boundaries from the Undo list since CHECKPOINT.
"""
    # Declare some LISP functions.
    car = lisp.car
    cdr = lisp.cdr
    eq = lisp.eq
    setcdr = lisp.setcdr
    # Remove any `nil' delimiter recently added to the Undo list.
    cursor = lisp.buffer_undo_list.value()
    if not eq(cursor, checkpoint):
        tail = cdr(cursor)
        while not eq(tail, checkpoint):
            if car(tail):
                cursor = tail
                tail = cdr(cursor)
            else:
                tail = cdr(tail)
                setcdr(cursor, tail)

#@-node:ekr.20071103093725.15:clean_undo_after_old
#@+node:ekr.20071103093725.16:clean_undo_after
def clean_undo_after(self, checkpoint):
    """\
Remove all intermediate boundaries from the Undo list since CHECKPOINT.
"""
    lisp("""
(let ((undo-list %s))
(if (not (eq buffer-undo-list undo-list))
  (let ((cursor buffer-undo-list))
(while (not (eq (cdr cursor) undo-list))
  (if (car (cdr cursor))
      (setq cursor (cdr cursor))
    (setcdr cursor (cdr (cdr cursor)))))))
nil)
"""
         % (checkpoint or 'nil'))

#@-node:ekr.20071103093725.16:clean_undo_after
#@-node:ekr.20071103093725.5:class Emacs_Rebox
#@+node:ekr.20071103093725.17:engine
def engine(text, style=None, width=79, refill=1, tabify=0, position=None):
    """\
Add, delete or adjust a boxed comment held in TEXT, according to STYLE.
STYLE values are explained at beginning of this file.  Any zero attribute
in STYLE indicates that the corresponding attribute should be recovered
from the currently existing box.  Produced lines will not go over WIDTH
columns if possible, if refilling gets done.  But if REFILL is false, WIDTH
is ignored.  If TABIFY is true, the beginning of produced lines will have
spaces replace by TABs.  POSITION is either None, or a character position
within TEXT.  Returns four values: the old box style, the new box style,
the reformatted text, and either None or the adjusted value of POSITION in
the new text.  The reformatted text is returned as None if the requested
style does not exist.
"""
    last_line_complete = text and text[-1] == '\n'
    if last_line_complete:
        text = text[:-1]
    lines = string.split(string.expandtabs(text), '\n')
    # Decide about refilling and the box style to use.
    new_style = 111
    old_template = guess_template(lines)
    new_style = merge_styles(new_style, old_template.style)
    if style is not None:
        new_style = merge_styles(new_style, style)
    new_template = template_registry.get(new_style)
    # Interrupt processing if STYLE does not exist.
    if not new_template:
        return old_template.style, new_style, None, None
    # Remove all previous comment marks, and left margin.
    if position is not None:
        marker = Marker()
        marker.save_position(text, position, old_template.characters())
    lines, margin = old_template.unbuild(lines)
    # Ensure only one white line between paragraphs.
    counter = 1
    while counter < len(lines) - 1:
        if lines[counter] == '' and lines[counter-1] == '':
            del lines[counter]
        else:
            counter = counter + 1
    # Rebuild the boxed comment.
    lines = new_template.build(lines, width, refill, margin)
    # Retabify to the left only.
    if tabify:
        for counter in range(len(lines)):
            tabs = len(re.match(' *', lines[counter]).group()) / 8
            lines[counter] = '\t' * tabs + lines[counter][8*tabs:]
    # Restore the point position.
    text = string.join(lines, '\n')
    if last_line_complete:
        text = text + '\n'
    if position is not None:
        position = marker.get_position(text, new_template.characters())
    return old_template.style, new_style, text, position

#@-node:ekr.20071103093725.17:engine
#@+node:ekr.20071103093725.18:guess_language
def guess_language(line):
    """\
Guess the language in use for LINE.
"""
    for language in range(len(language_matcher) - 1, 1, -1):
        if language_matcher[language](line):
            return language
    return 1

#@-node:ekr.20071103093725.18:guess_language
#@+node:ekr.20071103093725.19:guess_template
def guess_template(lines):
    """\
Find the heaviest box template matching LINES.
"""
    best_template = None
    for template in template_registry.values():
        if best_template is None or template > best_template:
            if template.match(lines):
                best_template = template
    return best_template

#@-node:ekr.20071103093725.19:guess_template
#@+node:ekr.20071103093725.20:left_margin_size
def left_margin_size(lines):
    """\
Return the width of the left margin for all LINES.  Ignore white lines.
"""
    margin = None
    for line in lines:
        counter = len(re.match(' *', line).group())
        if counter != len(line):
            if margin is None or counter < margin:
                margin = counter
    if margin is None:
        margin = 0
    return margin

#@-node:ekr.20071103093725.20:left_margin_size
#@+node:ekr.20071103093725.21:merge_styles
def merge_styles(original, update):
    """\
Return style attributes as per ORIGINAL, in which attributes have been
overridden by non-zero corresponding style attributes from UPDATE.
"""
    style = [original / 100, original / 10 % 10, original % 10]
    merge = update / 100, update / 10 % 10, update % 10
    for counter in range(3):
        if merge[counter]:
            style[counter] = merge[counter]
    return 100*style[0] + 10*style[1] + style[2]

#@-node:ekr.20071103093725.21:merge_styles
#@+node:ekr.20071103093725.22:refill_lines
def refill_lines(lines, width):
    """\
Refill LINES, trying to not produce lines having more than WIDTH columns.
"""
    # Try using GNU `fmt'.
    import tempfile, os
    name = tempfile.mktemp()
    open(name, 'w').write(string.join(lines, '\n') + '\n')
    process = os.popen('fmt -cuw %d %s' % (width, name))
    text = process.read()
    os.remove(name)
    if process.close() is None:
        return map(string.expandtabs, string.split(text, '\n')[:-1])
    # If `fmt' failed, do refilling more naively, wihtout using the
    # Knuth algorithm, nor protecting full stops at end of sentences.
    lines.append(None)
    new_lines = []
    new_line = ''
    start = 0
    for end in range(len(lines)):
        if not lines[end]:
            margin = left_margin_size(lines[start:end])
            for line in lines[start:end]:
                counter = len(re.match(' *', line).group())
                if counter > margin:
                    if new_line:
                        new_lines.append(' ' * margin + new_line)
                        new_line = ''
                    indent = counter - margin
                else:
                    indent = 0
                for word in string.split(line):
                    if new_line:
                        if len(new_line) + 1 + len(word) > width:
                            new_lines.append(' ' * margin + new_line)
                            new_line = word
                        else:
                            new_line = new_line + ' ' + word
                    else:
                        new_line = ' ' * indent + word
                        indent = 0
            if new_line:
                new_lines.append(' ' * margin + new_line)
                new_line = ''
            if lines[end] is not None:
                new_lines.append('')
                start = end + 1
    return new_lines

#@-node:ekr.20071103093725.22:refill_lines
#@+node:ekr.20071103093725.23:class Marker
class Marker:
    @others
#@+node:ekr.20071103093725.24:save_position

## Heuristic to simulate a marker while reformatting boxes.

def save_position(self, text, position, ignorable):
    """\
Given a TEXT and a POSITION in that text, save the adjusted position
by faking that all IGNORABLE characters before POSITION were removed.
"""
    ignore = {}
    for character in ' \t\r\n' + ignorable:
        ignore[character] = None
    counter = 0
    for character in text[:position]:
        if character in ignore:
            counter = counter + 1
    self.position = position - counter

#@-node:ekr.20071103093725.24:save_position
#@+node:ekr.20071103093725.25:get_position
def get_position(self, text, ignorable, latest=0):
    """\
Given a TEXT, return the value that would yield the currently saved position,
if it was saved by `save_position' with IGNORABLE.  Unless the position lies
within a series of ignorable characters, LATEST has no effect in practice.
If LATEST is true, return the biggest possible value instead of the smallest.
"""
    ignore = {}
    for character in ' \t\r\n' + ignorable:
        ignore[character] = None
    counter = 0
    position = 0
    if latest:
        for character in text:
            if character in ignore:
                counter = counter + 1
            else:
                if position == self.position:
                    break
                position = position + 1
    elif self.position > 0:
        for character in text:
            if character in ignore:
                counter = counter + 1
            else:
                position = position + 1
                if position == self.position:
                    break
    return position + counter

#@-node:ekr.20071103093725.25:get_position
#@-node:ekr.20071103093725.23:class Marker
#@+node:ekr.20071103093725.26:class Template
## Template processing.

class Template:
    @others
#@+node:ekr.20071103093725.27:__init__

def __init__(self, style, weight, lines):
    """\
Digest and register a single template.  The template is numbered STYLE,
has a parsing WEIGHT, and is described by one to three LINES.
STYLE should be used only once through all `declare_template' calls.

One of the lines should contain the substring `box' to represent the comment
to be boxed, and if three lines are given, `box' should appear in the middle
one.  Lines containing only spaces are implied as necessary before and after
the the `box' line, so we have three lines.

Normally, all three template lines should be of the same length.  If the first
line is shorter, it represents a start comment string to be bundled within the
first line of the comment text.  If the third line is shorter, it represents
an end comment string to be bundled at the end of the comment text, and
refilled with it.
"""
    assert style not in template_registry, \
           "Style %d defined more than once" % style
    self.style = style
    self.weight = weight
    # Make it exactly three lines, with `box' in the middle.
    start = string.find(lines[0], 'box')
    if start >= 0:
        line1 = None
        line2 = lines[0]
        if len(lines) > 1:
            line3 = lines[1]
        else:
            line3 = None
    else:
        start = string.find(lines[1], 'box')
        if start >= 0:
            line1 = lines[0]
            line2 = lines[1]
            if len(lines) > 2:
                line3 = lines[2]
            else:
                line3 = None
        else:
            assert 0, "Erroneous template for %d style" % style
    end = start + len('box')
    # Define a few booleans.
    self.merge_nw = line1 is not None and len(line1) < len(line2)
    self.merge_se = line3 is not None and len(line3) < len(line2)
    # Define strings at various cardinal directions.
    if line1 is None:
        self.nw = self.nn = self.ne = None
    elif self.merge_nw:
        self.nw = line1
        self.nn = self.ne = None
    else:
        if start > 0:
            self.nw = line1[:start]
        else:
            self.nw = None
        if line1[start] != ' ':
            self.nn = line1[start]
        else:
            self.nn = None
        if end < len(line1):
            self.ne = string.rstrip(line1[end:])
        else:
            self.ne = None
    if start > 0:
        self.ww = line2[:start]
    else:
        self.ww = None
    if end < len(line2):
        self.ee = line2[end:]
    else:
        self.ee = None
    if line3 is None:
        self.sw = self.ss = self.se = None
    elif self.merge_se:
        self.sw = self.ss = None
        self.se = string.rstrip(line3)
    else:
        if start > 0:
            self.sw = line3[:start]
        else:
            self.sw = None
        if line3[start] != ' ':
            self.ss = line3[start]
        else:
            self.ss = None
        if end < len(line3):
            self.se = string.rstrip(line3[end:])
        else:
            self.se = None
    # Define parsing regexps.
    if self.merge_nw:
        self.regexp1 = re.compile(' *' + regexp_quote(self.nw) + '.*$')
    elif self.nw and not self.nn and not self.ne:
        self.regexp1 = re.compile(' *' + regexp_quote(self.nw) + '$')
    elif self.nw or self.nn or self.ne:
        self.regexp1 = re.compile(
            ' *' + regexp_quote(self.nw) + regexp_ruler(self.nn)
            + regexp_quote(self.ne) + '$')
    else:
        self.regexp1 = None
    if self.ww or self.ee:
        self.regexp2 = re.compile(
            ' *' + regexp_quote(self.ww) + '.*'
            + regexp_quote(self.ee) + '$')
    else:
        self.regexp2 = None
    if self.merge_se:
        self.regexp3 = re.compile('.*' + regexp_quote(self.se) + '$')
    elif self.sw and not self.ss and not self.se:
        self.regexp3 = re.compile(' *' + regexp_quote(self.sw) + '$')
    elif self.sw or self.ss or self.se:
        self.regexp3 = re.compile(
            ' *' + regexp_quote(self.sw) + regexp_ruler(self.ss)
            + regexp_quote(self.se) + '$')
    else:
        self.regexp3 = None
    # Save results.
    template_registry[style] = self

#@-node:ekr.20071103093725.27:__init__
#@+node:ekr.20071103093725.28:__cmp__
def __cmp__(self, other):
    return cmp(self.weight, other.weight)

#@-node:ekr.20071103093725.28:__cmp__
#@+node:ekr.20071103093725.29:characters
def characters(self):
    """\
Return a string of characters which may be used to draw the box.
"""
    characters = ''
    for text in (self.nw, self.nn, self.ne,
                 self.ww, self.ee,
                 self.sw, self.ss, self.se):
        if text:
            for character in text:
                if character not in characters:
                    characters = characters + character
    return characters

#@-node:ekr.20071103093725.29:characters
#@+node:ekr.20071103093725.30:match
def match(self, lines):
    """\
Returns true if LINES exactly match this template.
"""
    start = 0
    end = len(lines)
    if self.regexp1 is not None:
        if start == end or not self.regexp1.match(lines[start]):
            return 0
        start = start + 1
    if self.regexp3 is not None:
        if end == 0 or not self.regexp3.match(lines[end-1]):
            return 0
        end = end - 1
    if self.regexp2 is not None:
        for line in lines[start:end]:
            if not self.regexp2.match(line):
                return 0
    return 1

#@-node:ekr.20071103093725.30:match
#@+node:ekr.20071103093725.31:unbuild
def unbuild(self, lines):
    """\
Remove all comment marks from LINES, as hinted by this template.  Returns the
cleaned up set of lines, and the size of the left margin.
"""
    margin = left_margin_size(lines)
    # Remove box style marks.
    start = 0
    end = len(lines)
    if self.regexp1 is not None:
        lines[start] = unbuild_clean(lines[start], self.regexp1)
        start = start + 1
    if self.regexp3 is not None:
        lines[end-1] = unbuild_clean(lines[end-1], self.regexp3)
        end = end - 1
    if self.regexp2 is not None:
        for counter in range(start, end):
            lines[counter] = unbuild_clean(lines[counter], self.regexp2)
    # Remove the left side of the box after it turned into spaces.
    delta = left_margin_size(lines) - margin
    for counter in range(len(lines)):
        lines[counter] = lines[counter][delta:]
    # Remove leading and trailing white lines.
    start = 0
    end = len(lines)
    while start < end and lines[start] == '':
        start = start + 1
    while end > start and lines[end-1] == '':
        end = end - 1
    return lines[start:end], margin

#@-node:ekr.20071103093725.31:unbuild
#@+node:ekr.20071103093725.32:build
def build(self, lines, width, refill, margin):
    """\
Put LINES back into a boxed comment according to this template, after
having refilled them if REFILL.  The box should start at column MARGIN,
and the total size of each line should ideally not go over WIDTH.
"""
    # Merge a short end delimiter now, so it gets refilled with text.
    if self.merge_se:
        if lines:
            lines[-1] = lines[-1] + '  ' + self.se
        else:
            lines = [self.se]
    # Reduce WIDTH according to left and right inserts, then refill.
    if self.ww:
        width = width - len(self.ww)
    if self.ee:
        width = width - len(self.ee)
    if refill:
        lines = refill_lines(lines, width)
    # Reduce WIDTH further according to the current right margin,
    # and excluding the left margin.
    maximum = 0
    for line in lines:
        if line:
            if line[-1] in '.!?':
                length = len(line) + 1
            else:
                length = len(line)
            if length > maximum:
                maximum = length
    width = maximum - margin
    # Construct the top line.
    if self.merge_nw:
        lines[0] = ' ' * margin + self.nw + lines[0][margin:]
        start = 1
    elif self.nw or self.nn or self.ne:
        if self.nn:
            line = self.nn * width
        else:
            line = ' ' * width
        if self.nw:
            line = self.nw + line
        if self.ne:
            line = line + self.ne
        lines.insert(0, string.rstrip(' ' * margin + line))
        start = 1
    else:
        start = 0
    # Construct all middle lines.
    for counter in range(start, len(lines)):
        line = lines[counter][margin:]
        line = line + ' ' * (width - len(line))
        if self.ww:
            line = self.ww + line
        if self.ee:
            line = line + self.ee
        lines[counter] = string.rstrip(' ' * margin + line)
    # Construct the bottom line.
    if self.sw or self.ss or self.se and not self.merge_se:
        if self.ss:
            line = self.ss * width
        else:
            line = ' ' * width
        if self.sw:
            line = self.sw + line
        if self.se and not self.merge_se:
            line = line + self.se
        lines.append(string.rstrip(' ' * margin + line))
    return lines

#@-node:ekr.20071103093725.32:build
#@-node:ekr.20071103093725.26:class Template
#@+node:ekr.20071103093725.33:regexp_quote
def regexp_quote(text):
    """\
Return a regexp matching TEXT without its surrounding space, maybe
followed by spaces.  If STRING is nil, return the empty regexp.
Unless spaces, the text is nested within a regexp parenthetical group.
"""
    if text is None:
        return ''
    if text == ' ' * len(text):
        return ' *'
    return '(' + re.escape(string.strip(text)) + ') *'

#@-node:ekr.20071103093725.33:regexp_quote
#@+node:ekr.20071103093725.34:regexp_ruler
def regexp_ruler(character):
    """\
Return a regexp matching two or more repetitions of CHARACTER, maybe
followed by spaces.  Is CHARACTER is nil, return the empty regexp.
Unless spaces, the ruler is nested within a regexp parenthetical group.
"""
    if character is None:
        return ''
    if character == ' ':
        return '  +'
    return '(' + re.escape(character + character) + '+) *'

#@-node:ekr.20071103093725.34:regexp_ruler
#@+node:ekr.20071103093725.35:unbuild_clean
def unbuild_clean(line, regexp):
    """\
Return LINE with all parenthetical groups in REGEXP erased and replaced by an
equivalent number of spaces, except for trailing spaces, which get removed.
"""
    match = re.match(regexp, line)
    groups = match.groups()
    for counter in range(len(groups)):
        if groups[counter] is not None:
            start, end = match.span(1 + counter)
            line = line[:start] + ' ' * (end - start) + line[end:]
    return string.rstrip(line)

#@-node:ekr.20071103093725.35:unbuild_clean
#@+node:ekr.20071103093725.36:make_generic
## Template data.

# Matcher functions for a comment start, indexed by numeric LANGUAGE.
language_matcher = []
for pattern in (r' *(/\*|//+|#+|;+|%+)',
                r'',            # 1
                r' */\*',       # 2
                r' *//+',       # 3
                r' *#+',        # 4
                r' *;+',        # 5
                r' *%+'):       # 6
    language_matcher.append(re.compile(pattern).match)

# Template objects, indexed by numeric style.
template_registry = {}

def make_generic(style, weight, lines):
    """\
Add various language digit to STYLE and generate one template per language,
all using the same WEIGHT.  Replace `?' in LINES accordingly.
"""
    for language, character in ((300, '/'),  # C++ style comments
                                (400, '#'),  # scripting languages
                                (500, ';'),  # LISP and assembler
                                (600, '%')): # TeX and PostScript
        new_style = language + style
        if 310 < new_style <= 319:
            # Disallow quality 10 with C++.
            continue
        new_lines = []
        for line in lines:
            new_lines.append(string.replace(line, '?', character))
        Template(new_style, weight, new_lines)

#@-node:ekr.20071103093725.36:make_generic
#@+node:ekr.20071103093725.37:<< templates >>

make_generic(11, 115, ('? box',))

make_generic(12, 215, ('? box ?',
                       '? --- ?'))

make_generic(13, 315, ('? --- ?',
                       '? box ?',
                       '? --- ?'))

make_generic(14, 415, ('? box ?',
                       '???????'))

make_generic(15, 515, ('???????',
                       '? box ?',
                       '???????'))

make_generic(21, 125, ('?? box',))

make_generic(22, 225, ('?? box ??',
                       '?? --- ??'))

make_generic(23, 325, ('?? --- ??',
                       '?? box ??',
                       '?? --- ??'))

make_generic(24, 425, ('?? box ??',
                       '?????????'))

make_generic(25, 525, ('?????????',
                       '?? box ??',
                       '?????????'))

make_generic(31, 135, ('??? box',))

make_generic(32, 235, ('??? box ???',
                       '??? --- ???'))

make_generic(33, 335, ('??? --- ???',
                       '??? box ???',
                       '??? --- ???'))

make_generic(34, 435, ('??? box ???',
                       '???????????'))

make_generic(35, 535, ('???????????',
                       '??? box ???',
                       '???????????'))

make_generic(41, 145, ('???? box',))

make_generic(42, 245, ('???? box ????',
                       '???? --- ????'))

make_generic(43, 345, ('???? --- ????',
                       '???? box ????',
                       '???? --- ????'))

make_generic(44, 445, ('???? box ????',
                       '?????????????'))

make_generic(45, 545, ('?????????????',
                       '???? box ????',
                       '?????????????'))

# Textual (non programming) templates.

Template(111, 113, ('box',))

Template(112, 213, ('| box |',
                    '+-----+'))

Template(113, 313, ('+-----+',
                    '| box |',
                    '+-----+'))

Template(114, 413, ('| box |',
                    '*=====*'))

Template(115, 513, ('*=====*',
                    '| box |',
                    '*=====*'))

Template(121, 123, ('| box |',))

Template(122, 223, ('| box |',
                    '`-----\''))

Template(123, 323, ('.-----.',
                    '| box |',
                    '`-----\''))

Template(124, 423, ('| box |',
                    '\\=====/'))

Template(125, 523, ('/=====\\',
                    '| box |',
                    '\\=====/'))

Template(141, 143, ('| box ',))

Template(142, 243, ('* box *',
                    '*******'))

Template(143, 343, ('*******',
                    '* box *',
                    '*******'))

Template(144, 443, ('X box X',
                    'XXXXXXX'))

Template(145, 543, ('XXXXXXX',
                    'X box X',
                    'XXXXXXX'))
# C language templates.

Template(211, 118, ('/* box */',))

Template(212, 218, ('/* box */',
                    '/* --- */'))

Template(213, 318, ('/* --- */',
                    '/* box */',
                    '/* --- */'))

Template(214, 418, ('/* box */',
                    '/* === */'))

Template(215, 518, ('/* === */',
                    '/* box */',
                    '/* === */'))

Template(221, 128, ('/* ',
                    '   box',
                    '*/'))

Template(222, 228, ('/*    .',
                    '| box |',
                    '`----*/'))

Template(223, 328, ('/*----.',
                    '| box |',
                    '`----*/'))

Template(224, 428, ('/*    \\',
                    '| box |',
                    '\\====*/'))

Template(225, 528, ('/*====\\',
                    '| box |',
                    '\\====*/'))

Template(231, 138, ('/*    ',
                    ' | box',
                    ' */   '))

Template(232, 238, ('/*        ',
                    ' | box | ',
                    ' *-----*/'))

Template(233, 338, ('/*-----* ',
                    ' | box | ',
                    ' *-----*/'))

Template(234, 438, ('/* box */',
                    '/*-----*/'))

Template(235, 538, ('/*-----*/',
                    '/* box */',
                    '/*-----*/'))

Template(241, 148, ('/*    ',
                    ' * box',
                    ' */   '))

Template(242, 248, ('/*     * ',
                    ' * box * ',
                    ' *******/'))

Template(243, 348, ('/******* ',
                    ' * box * ',
                    ' *******/'))

Template(244, 448, ('/* box */',
                    '/*******/'))

Template(245, 548, ('/*******/',
                    '/* box */',
                    '/*******/'))

Template(251, 158, ('/* ',
                    ' * box',
                    ' */   '))

#@-node:ekr.20071103093725.37:<< templates >>
#@-node:ekr.20071103093725.1:rebox.py
#@-node:ekr.20071103093725:Example 3: defining a rebox tool
#@-node:ekr.20071103090504:Pymacs docs
#@-node:ekr.20071104222805:Emacs/Pymacs notes
#@+node:ekr.20050123161408:ExamDiff files & scripts
0 leo.py
1 leoApp.py
2 leoAtFile.py
3 leoColor.py
4 leoCommands.py
5 leoCompare.py
6 leoConfig.py
7 leoFileCommands.py
8 leoFind.py
9 leoFrame.py
10 leoGlobals.py
11 leoGui.py
12 leoImport.py
13 leoKeys.py
14 leoMenu.py
15 leoNodes.py
16 leoPlugins.py
17 leoTangle.py
18 leoTkinterComparePanel.py
19 leoTkinterDialog.py
20 leoTkinterFind.py
21 leoTkinterFontPanel.py
22 leoTkinterFrame.py
23 leoTkinterGui.py
24 leoTkinterKeys.py
25 leoTkinterMenu.py
26 leoTkinterTree.py
27 leoUndo.py
#@nonl
#@+node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
print '-' * 20
d = []

for p in c.allNodes_iter():
    s = p.headString()
    if s.startswith('@thin'):
        d.append(s[5:].strip())

d.sort()

for s in d:
    print s



#@-node:ekr.20050123160215.1:Put all files in alpha order in ExamDiff
#@-node:ekr.20050123161408:ExamDiff files & scripts
#@+node:ekr.20070515083528:Focus notes
@nocolor

Focus issues create some of the most difficult programming problems in Leo.  The following are notes to myself about the issues involved.

- BringToFront can ruin a carefully set focus.

- There is no perfect place to set focus.

- The find code must be especially careful to set focus properly in headlines.

- The setEditLabelState method shows the *minimum* needed to set focus properly in a headline.
  It
#@nonl
#@-node:ekr.20070515083528:Focus notes
#@+node:ekr.20031218072017.365:How to...
#@+node:ekr.20060208112908:CVS stuff...
#@+node:ekr.20060331094112:How to generate keys using putty
To generate a SSH key using PuTTY:

Execute c:\"Program Files"\tortoiseCVS\PUTTYGEN.EXE

Select "SSH2 DSA", within the "Parameters" section.

Click on the "Generate" button. Follow the instruction to move the mouse over
the blank area of the program in order to create random data used by PUTTYGEN to
generate secure keys. Key generation will occur once PUTTYGEN has collected
sufficient random data.

Enter edream@cvs.sourceforge.net for the key comment (depends on what host the
key is for)

(Omit) Enter the desired passphrase in the "Key passphrase" and "Confirm passphrase"
fields. If the key will be used for automation of operations (i.e. as part of a
script), you may choose to omit this step from the key generation process.

Click on the "Save private key" button. Use the resulting dialog to save your
private key data for future use. You may use a filename such as
"SourceForge-Shell.ppk" or "SourceForge-CF.ppk". The .ppk extension is used for
PuTTY Private Key files.

Go to the SSH key posting page on the SourceForge.net site: http://sourceforge.net/account/

Copy your public key data from the "Public key for pasting into OpenSSH
authorized_keys2 file" section of the PuTTY Key Generator, and paste the key
data to the provided form on the SourceForge.net site. Click on the "Update"
button to complete the posting process.

Exit the PuTTY Key Generator (PUTTYGEN).

Key data sync to hosts from the SourceForge.net site occurs on regular
intervals. Your key data will be synchronized to the designated servers (either
shell and CVS, or the Compile Farm) after a short delay.
#@nonl
#@-node:ekr.20060331094112:How to generate keys using putty
#@+node:ekr.20060208112908.1:How to check out leo from SourceForge
The Tortoise cvs params:

:ext:edream@cvs.sourceforge.net:/cvsroot/leo

That is...

Protocol: pserver
Server: cvs.sourceforge.net
Repository folder: /cvsroot/leo
User name: your cvs name

### :pserver:anonymous@cvs.sourceforge.net:/cvsroot/leo
#@nonl
#@-node:ekr.20060208112908.1:How to check out leo from SourceForge
#@+node:ekr.20031218072017.366:How to add and remove files from CVS repository
use the command line option in the admin menu to do the following:

add leoConfig.py and leoConfig.txt
	cvs add leoConfig.txt
	cvs add leoConfig.py
	(then do commit)

remove readme*.doc
	remove files from working area (done)
	cvs remove readme1.doc
	cvs remove readme2.doc
	...
	(then do commit)
#@nonl
#@-node:ekr.20031218072017.366:How to add and remove files from CVS repository
#@+node:ekr.20031218072017.391:How to use CVS branches
@nocolor

I have a fair bit of expertise on CVS branches. It's late at night, so I don't have time for a long soapbox spiel at the moment. I will try to post something tomorrow. 

The brief picture is: 

* Check out code from CVS at the point you want to create the branch. 

* Make sure none of the files in your sandbox is modified. 

* Create the branch (cvs tag -b branchname). The branch name must start with a letter (upper or lower case) and thereafter can have alphanumeric characters, hyphens, and underscores (no periods or spaces). 

* The branch is created on the repository, but your sandbox is still checked out on the main branch. To check out on the new branch, do "cvs up -r branchname". 

When you want to merge changes back into the main branch, you can use "cvs up -r MAIN" to retrieve the main branch, then "cvs up -j branchname" to merge changes, then "cvs commit" to commit the merged version to the main branch AFTER YOU HAVE VERIFIED IT. 

I would recommend caution with merging because as you have noted, leo files are not well set up for CVS. They don't merge well because of inconsistent sentinel values. 

You may want to look at manually merging changes back into the main branch until leo implements invariant unique (UUID) sentinel indices. 

This will not hurt your ability to use branches, only your ability to automatically merge changes from one branch onto another.
#@nonl
#@-node:ekr.20031218072017.391:How to use CVS branches
#@-node:ekr.20060208112908:CVS stuff...
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add new entries in the following Python dictionariues in leoApp.py:
  self.language_delims_dict, self.language_extension_dict and self.extension_dict

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done.

- If the language is case insensitive, add it to the list of
case_insensitiveLanguages found in  << define global colorizer data >>

- Create the files theLanguage.xml and theLanguage.py file was added to the leo\modes directory.
  See Chapter 15 of Leo's users guide for full details.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

@color
#@nonl
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20080814134319.1:How to create and push to a private bzr branch
@nocolor

C:\leo.repo\trunk>bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/leo-4-5-1

C:\leo.repo\trunk>bzr push --use-existing-dir bzr+ssh://edreamleo@bazaar.launchpad.net/~edreamleo/leo-editor/leo-4-5-1

#@-node:ekr.20080814134319.1:How to create and push to a private bzr branch
#@+node:ekr.20051203084725:How to expand java .jar files
- Put whatever.jar in c:\prog
- cd: c:\prog
- jar xvf whatever.jar
#@nonl
#@-node:ekr.20051203084725:How to expand java .jar files
#@+node:ekr.20031218072017.384:How to export syntax colored code preserving colors
Scite has the option to "Export as html" and "export as rtf", and it will be
full of colour and fonts - and you can define them in properties, so it will be
the same as during editing.
#@nonl
#@-node:ekr.20031218072017.384:How to export syntax colored code preserving colors
#@+node:ekr.20031218072017.385:How to Increase environment space
To increase the size of environment space, add the following to config.sys:

shell=C:\windows\command\command.com /p:4096

Notes:

1. The path C:\windows\command\command.com may vary.
Check you system for the location of command.com.

2. This works for versions of Windows prior to Me.
On Me you set the registry somehow.
No information on XP.
#@nonl
#@-node:ekr.20031218072017.385:How to Increase environment space
#@+node:ekr.20051203084725.1:How to install and run jythonShell
Install:

Put JythonShellEA.jar in c:\prog\JythonShell

(optional) Expand the jar so you can see the code:

jar xvf JythonShellEA.jar

Run:

Here is the contents of jythonShell.bat:

cd c:\prog\jythonShell
java -cp c:\jython-2.2a1\jython.jar;c:\prog\jythonShell\JythonShellEA2.1.jar org.leo.shell.JythonShell
#@nonl
#@-node:ekr.20051203084725.1:How to install and run jythonShell
#@+node:ekr.20050316092232:How to install jyLeo
- Unpack the .zip file, placing the result somewhere, say in c:\prog\jyleo-Jan-11-06

- Edit jleo.bat so it refers to jyleo-Jan-11-06.  For example:

rem open jyLeo
set ARGS= 
:loop 
if [%1] == [] goto end 
set ARGS=%ARGS% %1 
shift 
goto loop 
:end 

cd c:\prog\jyleo-Jan-11-06
java -jar c:\jython-2.2a1\jython.jar src\leo.py
#@nonl
#@+node:ekr.20050716104357:Old instructions
@nocolor

- put the jyleo-nnn.jar file in c:\prog

- Execute the following command in a console window
    cd c:\prog
    jar xvf j-leo-nnn.jar

This creates a folder called j-leo-nnn

- Do the following, or execute jleo.bat

cd c:\prog\j-leo-nnn\src
java -jar c:\jython22a0\jython.jar leo.py

Note:  at present this gives KeyError: HOME

In leo.py, in computeHomeDir, I changed:
@color

home = os.getenv('HOME' )#,default=dotDir)

to:

try:
    home = os.getenv('HOME' )#,default=dotDir)
except Exception:
    home = ''
#@-node:ekr.20050716104357:Old instructions
#@+node:ekr.20050317153447:jy-Leo install instructions by Paul Paterson
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3053534
By: paulpaterson

Very interesting indeed - great work! 

I didn't have Java/Jython installed so for others in the same boat here's what I had to do to get it work on my platform (Win2k). Some of this is in the README but I had to do some extra but I'm not sure why. 

1. Install 1.5 JDK  
http://java.sun.com/j2se/1.5.0/download.jsp 

2. Install Jython 
http://www.jython.org/jython22a1.zip 

3. Edit Jython.bat file - the part that calls Java.exe to ... 
"C:\Program Files\Java\jdk1.5.0_02\jre\bin\java" -cp "C:\Program Files\Java\jdk1.5.0_02\jre\lib";"c:\Apps\Python23\Jython";"C:\Apps\jLeo\j-leo-MAR15\Icons";"C:\Apps\jLeo\j-leo-MAR15\skins";"C:\Apps\jLeo\j-leo-MAR15\src";"C:\Apps\jLeo\j-leo-MAR15\skinimages" -Dpython.home="c:\Apps\Python23\Jython" -jar jython.jar %ARGS% 

Where  
- Java installed at C:\Program Files\Java\jdk1.5.0_02 
- Jython at c:\Apps\Python23\Jython 
- jLeo at C:\Apps\jLeo\j-leo-MAR15 

Change your paths as appropriate! There must be a better way to do this - Java confuses me! 

4. Edit leo.py in jleo/src directory to fix failure to find HOME env variable. 

line 241 becomes ... 

....try:home = os.getenv('HOME' )#,default=dotDir) 
....except KeyError:home="" 


Then, from the Jython install directory ... 

Jython " 
C:\Apps\jLeo\j-leo-MAR15\src\leo.py" 

Works a treat!  

Paul
#@-node:ekr.20050317153447:jy-Leo install instructions by Paul Paterson
#@-node:ekr.20050316092232:How to install jyLeo
#@+node:ekr.20051129084430:How to install jython
@nocolor

- Download jython_Release_2_2alpha1.jar and put it anywhere (say on the desktop)

- Double-click the file.  This brings up an installer.  Follow the direction.
  (I installed to c:\jython-2.2a1

- Using the Control Panel, System, Advanced tab, environment variables,
  add c:\jython-2.2a1\jython.jar to CLASSPATH (in user variables)
#@nonl
#@+node:ekr.20051129084430.1:@url http://www.jython.org/install.html
#@-node:ekr.20051129084430.1:@url http://www.jython.org/install.html
#@-node:ekr.20051129084430:How to install jython
#@+node:ekr.20070623150151:How to make Leo commands undoable
The chapter commands provide a good example.  In this file, see the node:

Code-->Core classes...-->@thin leoChapters.py-->class chapterController-->Undo

The general plan is this:

1. The command handler calls a **beforeCommand** method before changing the outline.

The beforeCommand method creates a g.Bunch that contains all the information needed to
restore the outline to its previous state. Typically, the beforeCommand method
will call c.undoer.createCommonBunch(p), where p is, as usual,
c.currentPosition().

2. After changing the outline the command handler calls an **afterCommand** method.

This method should take as one argument the g.Bunch returned by the
beforeCommand method. In the discussion below, denote this bunch by b. The
afterCommand method adds any information required to redo the operation after
the operation has been undone.

The afterCommand method also sets b.undoHelper and b.redoHelper to two method
that actually perform the undo and redo operations. (Actually, the beforeCommand
method could also set these two entries).

When the afterCommand method has 'filled in' all the entries of b, the
afterCommand method must call u.pushBead(b). This pushes all the undo
operation on a stack managed by the Leo's undoer, i.e., c.commands.undoer.

3. The undoer calls the undoHelper and redoHelper methods to perform the actual undo and redo operations.

The undoer handles most of the housekeeping chores related to undo and redo.  All the undoHelper and redoHelper methods have to do is actually alter Leo's outline.

**Note**: the undoer creates an ivar (instance variable) of the *undoer* class for every entry in the bunch b passed as an argument to u.pushBead(b).  For example, suppose u = c.commands.under and that b has ivars 'a','b' and 'c'.  Then, on entry to the undoHelper and the redoHelper the u.a, u.b and u.c ivars will be defined.  This makes it unnecessary for the undoHelper or the redoHelper to 'unpack' b explicitly.

Writing correct undo and redo helpers is usually a bit tricky.  The code is often subtly different from the original code that implements a command.  That just can't be helped.




#@-node:ekr.20070623150151:How to make Leo commands undoable
#@+node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
teknico ( Nicola Larosa ) 
 RE: Removing '\r' characters?   
2002-09-16 14:27  
> I am plowing through old bug reports, and I found the following, from whom 
> I don't know: 

That's from me, *again*. You are kindly advised to stop forgetting the attribution to all my bug reports. ;^) 

>> - Source files still have the dreaded \r in them. Why don't you switch 
>> to \n only, once and for all, and live happily ever after? ;^) 

> I sure whould like to do that, and I'm not sure how to do this. All 
> versions of the read code attempt to remove '\r' characters, and all 
> versions of the write code write '\n' only for newlines. 

Sorry for being a bit vague, I was talking about the Leo source files themselves. I don't know what you use to edit them, ;^))) but in version 3.6 they still have \r\n as end-of-line. 

If Leo itself does not solve the problem, may I suggest the 
Tools/scripts/crlf.py script in the Python source distibution? It's nice and simple, and skips binary files, too. That's what I use every time I install a new version of Leo. :^) 

#@+node:ekr.20031218072017.387:The solution
Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". The unix python interpreter ignores trailing "\r" in python source files. There are no such guarantees for other languages. Unix users should be able to get rid of the cosmetically detrimental "\r" either by running dos2unix on the offending files, or, if they're part of a .leo project, reading them into leo and writing them out again.  


By: edream ( Edward K. Ream ) 
 RE: Removing '\r' characters?   
2002-09-17 09:34  
Oh, I see. Thanks very much for this clarification. 

Just to make sure I understand you: the problem with '\r' characters is that: 

1. I am creating LeoPy.leo and LeoDocs.leo on Windows and 
2. People are then using these files on Linux. 

and the way to remove the '\r' characters: 

1. I could run dos2unix on all distributed files just before committing to CVS or making a final distribution or 
2. People could, say, do the following: 

Step 1: Read and Save the .leo files, thereby eliminating the '\r' in those files and 
Step 2: Use the Write @file nodes command on all derived files to clear the '\r' in those files. 

Do you agree so far? 

> Under unix, python writes "\n" as "\n"; under windows, it writes it as "\r\n". 

I am going to see if there is any way to get Python to write a "raw" '\n' to a file. I think there must be. This would solve the problem once and for all. 

Thanks again for this most helpful comment. 

Edward
#@nonl
#@-node:ekr.20031218072017.387:The solution
#@+node:ekr.20031218072017.388:cursed newline answer
In 2.3 you can open files with the "U" flag and get "universal newline"
support: 

% python
Python 2.3a0 (#86, Sep 4 2002, 21:13:00) 
[GCC 2.96 20000731 (Mandrake Linux 8.1 2.96-0.62mdk)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> f = open("crlf.txt")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline"
problem,\r\n'
>>> f = open("crlf.txt", "rU")
>>> line = f.readline()
>>> line
'This is an example of what I have come to call the "cursed newline" problem,\n'

#@-node:ekr.20031218072017.388:cursed newline answer
#@+node:ekr.20031218072017.389:cursed newline answer 2
> You can open the file in 'binary' mode (adding 'b' to the mode string) and
> the file will contain '\r\n' on both platforms (and any other platforms.)

Nope. Exactly wrong. In 2.2 and those before, when files are opened in
*text* mode (no "b") then reading them will provide Unix-style line endings
(newline only). When you open files in binary mode then you see the bytes
stored in the file.

On Unix systems there's no difference in the contents of a file whether in
binary or text mode. On Windows a file is shorter by the number of carriage
returns. On the Mac I have no idea what they do. Probably just carriage
returns, to be different :-)

2.3 will be a bit more flexible about such mattrers.
#@-node:ekr.20031218072017.389:cursed newline answer 2
#@-node:ekr.20031218072017.386:How to remove cursed newlines: use binary mode
#@+node:ekr.20061023153133:How to run patch
patch -p1 < patchfile
#@-node:ekr.20061023153133:How to run patch
#@+node:ekr.20031218072017.390:How to run Pychecker
Do the following in Idle:

import pychecker.checker ; import leo

To run Idle(Python2.3 version) directly:

cd c:\prog\leoCvs\leo\src
c:\python23\python c:\python23\Lib\idlelib\idle.py

The HOME var must be set to c:\prog\leoCVS for .pycheckrc to be effective.

To suppress warnings from the standard library set ignoreStandardLibrary=1 in .pycheckrc
#@nonl
#@-node:ekr.20031218072017.390:How to run Pychecker
#@+node:ekr.20050510071834:How to use a temp file with pdb
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3137690
By: nobody

I dont know if anyone has solved this for regular Leo, but in the JyLeo JythonShell,
when the user executes a script with Pdb it:
1. dumps the script in a tmp file system's tmp directory.
2. Executes pdb based off of that tmp file.

that way you get all the goodness that pdb can offer.
#@-node:ekr.20050510071834:How to use a temp file with pdb
#@+node:ekr.20041214135556:How to use Tile
@nocolor
https://sourceforge.net/forum/message.php?msg_id=2882718
By: nobody

if anyone is interested here is some code that Tilefied my Leo instance, its
does some patching in the LeoGui program.

@color

def createRootWindow(self):

    """Create a hidden Tk root window."""
    #import Tix
    self.root = root = Tk.Tk()
    root.tk.call( 'package', 'require', 'tile' )
    #root.tk.call( 'namespace', 'import', '-force', 'ttk::*' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::scrollbar' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::label' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::entry' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menu' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::button' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::frame' )
    root.tk.call( 'namespace', 'import', '-force', 'ttk::menubutton' )
    root.tk.call( 'tile::setTheme', 'clam' )
    #self.root = root = Tix.Tk()
    root.title("Leo Main Window")
    root.withdraw()

    self.setDefaultIcon()
    self.getDefaultConfigFont(g.app.config)
    self.createGlobalWindows()

    return root
#@nonl
#@-node:ekr.20041214135556:How to use Tile
#@-node:ekr.20031218072017.365:How to...
#@+node:ekr.20070215183046:IronPython notes
@nocolor

- IronPython does not accept 'from __future__ import x'
  I could work around this, but perhaps it is time to abandon Python 2.2.2.

- Amazingly, it is possible to add Python24\Lib to IronPython's path!
  Almost all of those modules import correct.

- IronPython has troubles with the xml modules.
  It complains about a missing 'strict' codec.

- IronPython has trouble with the pdb module, so some other way must be found to debug IronPython programs.
#@nonl
#@-node:ekr.20070215183046:IronPython notes
#@+node:ekr.20080114142724:leoGtkNotes
@nocolor

@all
#@nonl
#@+node:ekr.20080112175736: gtk: to do
gtkGui:

** Rewrite leoKeyEventClass.
   This should be done by EKR: it is an essential part of all key handline.
- There is no root ivar in the gtk gui.  Rewrite all code that uses self.root.
- Rewrite runOpenFileDialog
- Rewrite runSaveFileDialog

gtkFrame:
- What is the correct way to close a window?
- Should there be a separate minibuffer class?
- Should there be separate files for the log, body, etc.?
- Should there be smaller methods to create components and make bindings?

gtkFind:
- Create the find tab.

gtkComparePanel:
- At present this does not exist.  The compare window is optional.

General:
- Write unit tests for all new gui code.
- Unit tests for showFindPanel and openCompareWindow.

#@-node:ekr.20080112175736: gtk: to do
#@+node:ekr.20080113061130: gtk: what I did
- Added code to Leo's code to do nothing it the compare panel and stand-alone find panel do not exist.
#@nonl
#@-node:ekr.20080113061130: gtk: what I did
#@-node:ekr.20080114142724:leoGtkNotes
#@+node:ekr.20050214055018:Mac Notes
#@+node:ekr.20050221054932:How to make monolithic Leo app on MacOS X
 @killcolor
http://sourceforge.net/forum/message.php?msg_id=3007062
By: jgleeson

Sorry to take so long to reply.  I've been buried in work and haven't kept up
with some email.

Here's the link to the site where I posted the folder you have:
<http://homepage.mac.com/jdgleeson/>  It's the small file named "Leo.zip" (23
KB), not the large file "Leo-4.3-alpha-2.dmg" (20 MB).

I agree that I did not write very clear instructions, beginnng with the first
step, where I should have also said:  "It is important to use version 1.1.8
of py2app, which is only available through svn.  The version on the py2app website
is 1.1.7, which creates buggy Tkinter apps. If you try to use version 1.1.7,
the Leo app it creates will give you a message saying that Tkinter is not properly
installed.  Your installation is fine; otherwise you could not have even built
Leo.app with py2app, because py2app copies the essential parts of Tcl/Tk into
the application bundle to make the app completely standalone."

I haven't tried intalling the Fink subversion -- I'm using DarwinPorts
<http://darwinports.opendarwin.org/>.  But there's a simpler alternative than
DarwinPorts. Metissian releases OS X packages of Subversion clients
<http://metissian.com/projects/macosx/subversion/>

AFAIK, the command "python setup.py bdist_mpkg --open" only applies to the py2app
1.1.8 distribution.  By the way, bdist_mpkg is distributed with py2app. It creates
a package around the setup.py script (more specialized than Platypus).  I don't
have any experience with bdist_mpkg yet.

'Copy the leo folder into this directory' is horrible. I'm glad you figured
it out -- I'm not sure I could have.

"python setup.py py2app -a" should be run in the folder with the readme file,
which also contains the setup.py file that the command refers to.  Most importantly,
the folder in which this command is run must contain the leo folder -- which
it does only if you are brilliant enough to decode my instructions.   ;) 

HTH

-John
#@nonl
#@-node:ekr.20050221054932:How to make monolithic Leo app on MacOS X
#@+node:ekr.20050214055018.4:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@-node:ekr.20050214055018.4:@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)
#@+node:ekr.20050214055018.5:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@-node:ekr.20050214055018.5:@url http://www.wordtech-software.com/leo.html  (Mac Bundle)
#@+node:ekr.20050513164506:Problems with run script command on Mac x11
@killcolor

Jon Schull <jschull@softlock.com>  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 

I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations:
- Leo runs under X11 as well as under OS X.
- My X11 python configuration was created using the recipe at XXX (which enables vpython).
- The OS X configuration is vanilla MacPython from MacPython.org, along with AquaTclTk batteries included XXX.

In both environments I can run leo under python leo.py and under idle.
Under OS X we get font smoothing, but we can't run visual python programs (python crashes;  this is a known incompatibility with  MacPython.)

- Under X11 we can run visual python programs like this one
    #box.py
    from visual import *
    box()

And we can even run them under leo (under X11). HOWEVER, when the visual python program is terminated, leo vanishes (leo and the vp program apparently run in the same space)

Under x11, we can keep leo alive by putting the vp program in its own space:

    os.popen3('/sw/bin/python /Users/jis/box.py')

However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...

    def do(cmd='ls'):
        from os import popen3
        pIn,pOut,pErr=0,1,2
        popenResults=popen3(cmd)
        print popenResults[pOut].read()
        print popenResults[pErr].read()

    import os	
    do('/sw/bin/python /Users/jis/box.py')

...but only when the vpython program terminates.

Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).

    import os	
    os.chdir('/sw/lib/python2.3/idlelib')
    os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')

#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.

Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.

It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
#@nonl
#@-node:ekr.20050513164506:Problems with run script command on Mac x11
#@+node:ekr.20040104162835.8:Linux/Mac notes: Dan Winkler
#@+node:ekr.20040104162835.13:Fink & aqua
Yes, fink does have pre-built Pythons, both 2.1 and 2.2.  (If you don't 
see them it probably means you don't have the right servers listed in 
your /sw/etc/apt/sources.list file.)  However, the versions of Python 
you'd get through fink are set up to run under X Windows, which I don't 
think is what you want.

I think what you want is MacPython which can run Tk programs like Leo 
under Aqua.  That's what I use these days.

I can tell from your question that you don't understand the following 
differences between the versions of Python available:

1) The version that comes with OS X is a text only one which doesn't 
have Tk.  Leo can't run under that.  Also, I hate Apple for including 
this instead of one that does have Tk and I hope they'll fix it some 
day.

2) You can get a version of Python from fink with has Tk but which runs 
under X Windows.  I don't think you want that.

3). You can also get MacPython which has Tk but it's a version of Tk 
that uses the Aqua windowing system, not X Windows.

So Tk can either be present or not and if it is present it can use 
either X Windows or Aqua.  You want it present and using Aqua, I think.


#@-node:ekr.20040104162835.13:Fink & aqua
#@+node:ekr.20040104162835.14:Mac, Fink, etc.
> 1. The python that FC installs is MacPython.  I think that because the
> MacPython docs talk about Fink.

Nope.  The python installed by FC knows nothing about the Mac.  It 
thinks it's running on a Unix machine.  And it uses a version of Tk 
which thinks it's running on a Unix machine.  The window standard on 
Unix is called X (or X11 or XFree86, all the same thing).  So the main 
reason to run Leo this way would be to get an idea of how it works for 
Unix/Linux users.  But when programs run under X, they don't look like 
Mac programs.  They don't get all those glossy, translucent widgets 
that Aqua provides.  They really look like they would on a Unix/Linux 
machine.

Aqua is the native windowing system on Mac.  MacPython is set up to 
work with it.  Most Mac users will want Leo to work this way.  That's 
what I do.

>
>
> I have the TkTclAquBI (Batteries included) installer.  Is installing 
> this
> enough to get Leo to work with Aqua?  Do I have to de-install the
> present tk stuff that I installed with FC?

Yes, I think that's all I installed to get Tk to work under Aqua.  You 
don't have to deinstall the FC stuff.  All the FC stuff lives in its 
own world under /sw and runs under X.  It won't conflict with the Mac 
world.

#@-node:ekr.20040104162835.14:Mac, Fink, etc.
#@+node:ekr.20040104162835.15:Double clicking on Linux
Double-clickable things (i.e. Macintosh applications) are usually 
actually folders with a name that ends in .app.  The file you found is 
probably executable only from the command line, not by double clicking 
it.  So I think if you run it from the command line it will work but 
will not know about Tk because Apple's version was built without Tk 
support.

You can also execute the .app programs from the command line by using 
the open command, so "open foo.app" will do the same thing as double 
clicking on foo in the finder (the .app extension is suppressed).  The 
idea behind this is that an application can look like just one opaque 
icon in the finder but actually have all its resources nicely organized 
in subfolders.
#@-node:ekr.20040104162835.15:Double clicking on Linux
#@-node:ekr.20040104162835.8:Linux/Mac notes: Dan Winkler
#@-node:ekr.20050214055018:Mac Notes
#@+node:ekr.20060111112513.1:New jyLeo notes
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3516227
By: nobody

Some highlights:
* simpler startup:
jyleo leo.py
should be sufficient to start it up.
* new editor colorization
* the JythonShell is much more powerful and cooler
* new plugins
* Chapters support
* mod_script is in place.
* dyna-menu was converted.  I guess 'e' will have to judge the conversion.
* multi-language script support.
* drag and drop
* some powerful new editor commands.  Try keyword completing on the language
in effect.  Say if it is python:
se(Tab)
becomes
self

Some warnings:
1. Be careful about reading your regular leo files into jyleo and saving them.
Its quite conceivable that jyleo will write it out to an XML format that regular
leo can't handle.  Why?  Well jyleo is using an XML library to spit its XML
out while leo uses a home grown method.  The library can handle leo's XML, but
Ive seen regular leo not be able to handle jyleo's XML.  Its based around <tag/>
I believe.

2. If you move jyleo after executing it you will need to clear out your compiled
py files as the __file__ attribute is hard compiled into the resulting objects.
Not what we want.  We want it to be set at runtime.  Ive been waiting a long
time for jython to release again and hopefully fix this, but Im not holding
my breath anymore.

----------
Its hard to give this thing a number, I want to call it jyleo2, but jyleo is
sufficient.  Dependent upon bug reports the next release could be much sooner
than before, maybe even weeks.  I hope one thing, that the dreaded "I can't
get it to start" problems are gone.  I took the snapshot and expanded it in
Windows XP.  Went to the src directory and typed: jython leo.py
and it started.  That's what I wanted to see.  I didn't have to mess with the
CLASSPATH or anything.

things needed:
java 5
a jython2.2a1 or beyond.  jython2.2a1 is the most recent snapshot.

Beyond bug fixing, I will be planning to add more SwingMacs command as time
goes along.  But I think most major features are in place.  Of course the 3D
experiments in the future could change that... :D

A NOTE ON STARTUP TIMES: In my experience it takes awhile for jyleo to start.
It will take much longer the first time you execute it because the py files
are being compiled.  Ive haven't been able to figure out what eats the time,
it may just have a slow startup in the aggregate.  So don't think its not doing
anything, it probably is.

leouser
#@nonl
#@-node:ekr.20060111112513.1:New jyLeo notes
#@+node:ekr.20071217231348:Pylint docs
@nocolor



















#@+node:ekr.20071217231348.1:options
General options

rcfile:	Specify a configuration file.
init-hook:	Python code to execute, usually for sys.path manipulation such as pygtk.require().
rpython-mode:	enable the rpython checker which is disabled by default
errors-only:	In debug mode, checkers without error messages are disabled and for others, only the ERROR messages are displayed, and no reports are done by default
profile:	Profiled execution.
ignore:	Add <file or directory> to the black list. It should be a base name, not a path. You may set this option multiple times. Default: CVS
persistent:	Pickle collected data for later comparisons. Default: yes
cache-size:	Set the cache size for astng objects. Default: 500
load-plugins:	List of plugins (as comma separated values of python modules names) to load, usually to register additional checkers.

Commands options

help-msg:	Display a help message for the given message id and exit. The value may be a comma separated list of message ids.
list-msgs:	Generate pylint's full documentation.
generate-rcfile:
 	Generate a sample configuration file according to the current configuration. You can put other options before this one to get them in the generated configuration.
generate-man:	Generate pylint's man page.

Messages control options

enable-checker:	Enable only checker(s) with the given id(s). This option conflict with the disable-checker option
disable-checker: Enable all checker(s) except those with the given id(s). This option conflict with the disable-checker option
enable-msg-cat:	Enable all messages in the listed categories.
disable-msg-cat: Disable all messages in the listed categories.
enable-msg:	Enable the message(s) with the given id(s).
disable-msg:	Disable the message(s) with the given id(s).

Reports options

output-format:	set the output format. Available formats are text, parseable, colorized, msvs (visual studio) and html Default: text
include-ids:	Include message's id in output
files-output:	Put messages in a separate file for each module / package specified on the command line instead of printing them on stdout. Reports (if any) will be written in a file name "pylint_global.[txt|html]".
reports:	Tells wether to display a full report or only the messages Default: yes
evaluation:	Python expression which should return a note less than 10 (10 is the highest note).You have access to the variables errors warning, statement which respectivly contain the number of errors / warnings messages and the total number of statements analyzed. This is used by the global evaluation report (R0004). Default: 10.0 - ((float(5 * error + warning + refactor + convention) / statement) * 10)
comment:	Add a comment according to your evaluation note. This is used by the global evaluation report (R0004).
enable-report:	Enable the report(s) with the given id(s).
disable-report:	Disable the report(s) with the given id(s).
#@nonl
#@-node:ekr.20071217231348.1:options
#@+node:ekr.20071217231348.2:Main messages and reports
Main messages

E0001:	Used when a syntax error is raised for a module.
E0011:	Unrecognized file option %r Used when an unknown inline option is encountered.
E0012:	Bad option value %r Used when a bad value for an inline option is encountered.

I0001:	Unable to run raw checkers on built-in module %s Used to inform that a built-in module has not been checked using the raw checkers.
I0010:	Unable to consider inline option %r Used when an inline option is either badly formatted or can't be used inside modules.
I0011:	Locally disabling %s Used when an inline option disable a message or a messages category.
I0012:	Locally enabling %s Used when an inline option enable a message or a messages category.
I0013:	Ignoring entire file Used to inform that the file will not be checked
F0001:	Used when an error occured preventing the analyzing of a module (unable to find it for instance).
F0002:	%s: %s Used when an unexpected error occured while building the ASTNG representation. This is usually accomopagned by a traceback. Please report such errors !
F0003:	ignored builtin module %s Used to indicate that the user asked to analyze a builtin module which has been skipped.
F0004:	unexpected infered value %s Used to indicate that some value of an unexpected type has been infered.

Main reports

R0001:	Messages by category
R0002:	% errors / warnings by module
R0003:	Messages
R0004:	Global evaluation
#@nonl
#@-node:ekr.20071217231348.2:Main messages and reports
#@+node:ekr.20071217231348.3:Basic
Basic checker

Options

required-attributes:
 	Required attributes for module, separated by a comma
no-docstring-rgx:
 	Regular expression which should only match functions or classes name which do not require a docstring Default: __.*__
module-rgx:	Regular expression which should only match correct module names Default: (([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$
const-rgx:	Regular expression which should only match correct module level names Default: (([A-Z_][A-Z1-9_]*)|(__.*__))$
class-rgx:	Regular expression which should only match correct class names Default: [A-Z_][a-zA-Z0-9]+$
function-rgx:	Regular expression which should only match correct function names Default: [a-z_][a-z0-9_]{2,30}$
method-rgx:	Regular expression which should only match correct method names Default: [a-z_][a-z0-9_]{2,30}$
attr-rgx:	Regular expression which should only match correct instance attribute names Default: [a-z_][a-z0-9_]{2,30}$
argument-rgx:	Regular expression which should only match correct argument names Default: [a-z_][a-z0-9_]{2,30}$
variable-rgx:	Regular expression which should only match correct variable names Default: [a-z_][a-z0-9_]{2,30}$
inlinevar-rgx:	Regular expression which should only match correct list comprehension / generator expression variable names Default: [A-Za-z_][A-Za-z0-9_]*$
good-names:	Good variable names which should always be accepted, separated by a comma Default: i,j,k,ex,Run,_
bad-names:	Bad variable names which should always be refused, separated by a comma Default: foo,bar,baz,toto,tutu,tata
bad-functions:	List of builtins function names that should not be used, separated by a comma Default: map,filter,apply,input

Messages

E0100:	__init__ method is a generator Used when the special class method __init__ is turned into a generator by a yield in its body.
E0101:	Explicit return in __init__ Used when the special class method __init__ has an explicit return value.
E0102:	%s already defined line %s Used when a function / class / method is redefined.
E0103:	%r not properly in loop Used when break or continue keywords are used outside a loop.
E0104:	return outside function Used when a "return" statement is found outside a function or method.
E0105:	yield outside function Used when a "yield" statement is found outside a function or method.
E0106:	return with argument inside generator Used when a "return" statement with an argument is found outside in a generator function or method (e.g. with some "yield" statements).

W0101:	Unreachable code Used when there is some code behind a "return" or "raise" statement, which will never be accessed.
W0102:	Dangerous default value %s as argument Used when a mutable value as list or dictionary is detected in a default value for an argument.
W0104:	Statement seems to have no effect Used when a statement doesn't have (or at least seems to) any effect.
W0105:	String statement has no effect Used when a string is used as a statement (which of course has no effect). This is a particular case of W0104 with its own message so you can easily disable it if you're using those strings as documentation, instead of comments.
W0106:	Unnecessary semicolon Used when a statement is endend by a semi-colon (";"), which isn't necessary (that's python, not C ;).
W0107:	Unnecessary pass statement Used when a "pass" statement that can be avoided is encountered.)
W0122:	Use of the exec statement Used when you use the "exec" statement, to discourage its usage. That doesn't mean you can not use it !
W0141:	Used builtin function %r Used when a black listed builtin function is used (see the bad-function option). Usual black listed functions are the ones like map, or filter , where Python offers now some cleaner alternative like list comprehension.
W0142:	Used * or * magic* Used when a function or method is called using *args or **kwargs to dispatch arguments. This doesn't improve readility and should be used with care.

C0102:	Black listed name "%s" Used when the name is listed in the black list (unauthorized names).
C0103:	Invalid name "%s" (should match %s) Used when the name doesn't match the regular expression associated to its type (constant, variable, class...).
C0111:	Missing docstring Used when a module, function, class or method has no docstring. Some special methods like __init__ doesn't necessary require a docstring.
C0112:	Empty docstring Used when a module, function, class or method has an empty docstring (it would be too easy ;).
C0121:	Missing required attribute "%s" Used when an attribute required for modules is missing.

Reports

R0101:	Statistics by type
#@-node:ekr.20071217231348.3:Basic
#@+node:ekr.20071217231348.4:Type
Typecheck checker

Options

ignore-mixin-members:
 	Tells wether missing members accessed in mixin class should be ignored. A mixin class is detected if its name ends with "mixin" (case insensitive). Default: yes
zope:	When zope mode is activated, consider the acquired-members option to ignore access to some undefined attributes.
acquired-members:
 	List of members which are usually get through zope's acquisition mecanism and so shouldn't trigger E0201 when accessed (need zope=yes to be considered). Default: REQUEST,acl_users,aq_parent

Messages

E1101:	%s %r has no %r member  A variable is accessed for an unexistant member.
E1102:	%s is not callable      An object being called has been infered to a non callable object
E1103:	%s %r has no %r member (but some types could not be inferred) 
                               A variable is accessed for an unexistant member, but astng was not able to interpret all possible types of this variable.
E1111:	Assigning to function call which doesn't return     An assigment is done on a function call but the infered function doesn't return anything.
W1111:	Assigning to function call which only returns None  An assigment is done on a function call but the infered function returns nothing but None.
#@nonl
#@-node:ekr.20071217231348.4:Type
#@+node:ekr.20071217231348.5:Variables
Variables checker

Options

init-import:	Tells wether we should check for unused import in __init__ files.
dummy-variables-rgx:
 	A regular expression matching names used for dummy variables (i.e. not used). Default: _|dummy
additional-builtins:
 	List of additional names supposed to be defined in builtins. Remember that you should avoid to define new builtins when possible.

Messages

E0601:	Using variable %r before assignment Used when a local variable is accessed before it's assignment.
E0602:	Undefined variable %r Used when an undefined variable is accessed.
E0611:	No name %r in module %r Used when a name cannot be found in a module.

W0601:	Global variable %r undefined at the module level Used when a variable is defined through the "global" statement but the variable is not defined in the module scope.
W0602:	Using global for %r but no assigment is done Used when a variable is defined through the "global" statement but no assigment to this variable is done.
W0603:	Using the global statement Used when you use the "global" statement to update a global variable.
PyLint just try to discourage this usage. That doesn't mean you can not use it !
W0604:	Using the global statement at the module level Used when you use the "global" statement at the module level since it has no effect
W0611:	Unused import %s Used when an imported module or variable is not used.
W0612:	Unused variable %r Used when a variable is defined but not used.
W0613:	Unused argument %r Used when a function or method argument is not used.
W0614:	Unused import %s from wildcard import Used when an imported module or variable is not used from a 'from X import *' style import.

W????: Inline emphasis start-string without end-string.
W0621:	Redefining name %r from outer scope (line %s) Used when a variable's name hide a name defined in the outer scope.
W0622:	Redefining built-in %r Used when a variable or function override a built-in.
W0631:	Using possibly undefined loop variable %r Used when an loop variable (i.e. defined by a for loop or a list comprehension or a generator expression) is used outside the loop.
#@nonl
#@-node:ekr.20071217231348.5:Variables
#@+node:ekr.20071217231501:Classes
Classes checker

Options

ignore-iface-methods:
 	List of interface methods to ignore, separated by a comma. This is used for instance to not check methods defines in Zope's Interface base class. Default: isImplementedBy,deferred,extends,names,namesAndDescriptions,queryDescriptionFor,getBases,getDescriptionFor,getDoc,getName,getTaggedValue,getTaggedValueTags,isEqualOrExtendedBy,setTaggedValue,isImplementedByInstancesOf,adaptWith,is_implemented_by
defining-attr-methods:
 	List of method names used to declare (i.e. assign) instance attributes. Default: __init__,__new__,setUp

Messages

E0202:	An attribute inherited from %s hide this method Used when a class defines a method which is hiden by an instance attribute from an ancestor class.
E0203:	Access to member %r before its definition line %s Used when an instance member is accessed before it's actually assigned.
E0211:	Method has no argument Used when a method which should have the bound instance as first argument has no argument defined.
E0213:	Method should have "self" as first argument Used when a method has an attribute different the "self" as first argument. This is considered as an error since this is a soooo common convention that you should'nt break it!
E0221:	Interface resolved to %s is not a class Used when a class claims to implement an interface which is not a class.
E0222:	Missing method %r from %s interface Used when a method declared in an interface is missing from a class implementing this interface

W0201:	Attribute %r defined outside __init__ Used when an instance attribute is defined outside the __init__ method.
W0211:	Static method with %r as first argument Used when a static method has "self" or "cls" as first argument.
W0212:	Access to a protected member %s of a client class Used when a protected member (i.e. class member with a name beginning with an underscore) is access outside the class or a descendant of the class where it's defined.
W0221:	Arguments number differs from %s method Used when a method has a different number of arguments than in the implemented interface or in an overridden method.
W0222:	Signature differs from %s method Used when a method signature is different than in the implemented interface or in an overridden method.
W0223:	Method %r is abstract in class %r but is not overridden Used when an abstract method (ie raise NotImplementedError) is not overridden in concrete class.
W0231:	__init__ method from base class %r is not called Used when an ancestor class method has an __init__ method which is not called by a derived class.
W0232:	Class has no __init__ method Used when a class has no __init__ method, neither its parent classes.
W0233:	__init__ method from a non direct base class %r is called Used when an __init__ method is called on a class which is not in the direct ancestors for the analysed class.
R0201:	Method could be a function Used when a method doesn't use its bound instance, and so could be written as a function.
C0202:	Class method should have "cls" as first argument Used when a class method has an attribute different than "cls" as first argument, to easily differentiate them from regular instance methods.
C0203:	Metaclass method should have "mcs" as first argument Used when a metaclass method has an attribute different the "mcs" as first argument.
F0202:	Unable to check methods signature (%s / %s) Used when PyLint has been unable to check methods signature compatibility for an unexpected raison. Please report this kind if you don't make sense of it.
F0220:	failed to resolve interfaces implemented by %s (%s) Used when a PyLint as failed to find interfaces implemented by a class
#@-node:ekr.20071217231501:Classes
#@+node:ekr.20071217231501.1:Design
Design checker

Options
max-args:	Maximum number of arguments for function / method Default: 5
max-locals:	Maximum number of locals for function / method body Default: 15
max-returns:	Maximum number of return / yield for function / method body Default: 6
max-branchs:	Maximum number of branch for function / method body Default: 12
max-statements:	Maximum number of statements in function / method body Default: 50
max-parents:	Maximum number of parents for a class (see R0901). Default: 7
max-attributes:	Maximum number of attributes for a class (see R0902). Default: 7
min-public-methods:
 	Minimum number of public methods for a class (see R0903). Default: 2
max-public-methods:
 	Maximum number of public methods for a class (see R0904). Default: 20

Messages

R0901:	Too many ancestors (%s/%s) Used when class has too many parent classes, try to reduce this to get a more simple (and so easier to use) class.
R0902:	Too many instance attributes (%s/%s) Used when class has too many instance attributes, try to reduce this to get a more simple (and so easier to use) class.
R0903:	Too few public methods (%s/%s) Used when class has too few public methods, so be sure it's really worth it.
R0904:	Too many public methods (%s/%s) Used when class has too many public methods, try to reduce this to get a more simple (and so easier to use) class.
R0911:	Too many return statements (%s/%s) Used when a function or method has too many return statement, making it hard to follow.
R0912:	Too many branches (%s/%s) Used when a function or method has too many branches, making it hard to follow.
R0913:	Too many arguments (%s/%s) Used when a function or method takes too many arguments.
R0914:	Too many local variables (%s/%s) Used when a function or method has too many local variables.
R0915:	Too many statements (%s/%s) Used when a function or method has too many statements. You should then split it in smaller functions / methods.
R0921:	Abstract class not referenced Used when an abstract class is not used as ancestor anywhere.
R0922:	Abstract class is only referenced %s times Used when an abstract class is used less than X times as ancestor.
R0923:	Interface not implemented Used when an interface class is not implemented anywhere.
#@nonl
#@-node:ekr.20071217231501.1:Design
#@+node:ekr.20071217231501.2:Imports
Imports checker

Options

deprecated-modules:
 	Deprecated modules which should not be used, separated by a comma Default: regsub,string,TERMIOS,Bastion,rexec
import-graph:	Create a graph of every (i.e. internal and external) dependencies in the given file (report R0402 must not be disabled)
ext-import-graph:
 	Create a graph of external dependencies in the given file (report R0402 must not be disabled)
int-import-graph:
 	Create a graph of internal dependencies in the given file (report R0402 must not be disabled)

Messages

W0401:	Wildcard import %s Used when from module import * is detected.
W0402:	Uses of a deprecated module %r Used a module marked as deprecated is imported.
W0403:	Relative import %r Used when an import relative to the package directory is detected.
W0404:	Reimport %r (imported line %s) Used when a module is reimported multiple times.
W0406:	Module import itself Used when a module is importing itself.
W0410:	__future__ import is not the first non docstring statement Python 2.5 and greater require __future__ import to be the first non docstring statement in the module.
R0401:	Cyclic import (%s) Used when a cyclic import between two or more modules is detected.
F0401:	Unable to import %r (%s) Used when pylint has been unable to import a module.

Reports

R0401:	External dependencies
R0402:	Modules dependencies graph
#@nonl
#@-node:ekr.20071217231501.2:Imports
#@+node:ekr.20071217231501.3:Newstyle
Newstyle checker


Messages

E1001:	Use __slots__ on an old style class Used when an old style class use the __slots__ attribute.
E1002:	Use super on an old style class Used when an old style class use the super builtin.
E1003:	Bad first argument %r given to super class Used when another argument than the current class is given as first argument of the super builtin.
E1010:	Raising a new style class Used when a new style class is raised since it's not possible with python < 2.5.
W1001:	Use of "property" on an old style class Used when PyLint detect the use of the builtin "property" on an old style class while this is relying on new style classes 
features
W1010:	Exception doesn't inherit from standard "Exception" class Used when a custom exception class is raised but doesn't inherit from the builtin "Exception" class.
#@nonl
#@-node:ekr.20071217231501.3:Newstyle
#@+node:ekr.20071217231828:Exceptions
Exceptions checker

Messages

E0701:	Bad except clauses order (%s) Used when except clauses are not in the correct order (from the more specific to the more generic). If you don't fix the order, some exceptions may not be catched by the most specific handler.
E0702:	Raising %s while only classes, instances or string are allowed Used when something which is neither a class, an instance or a string is raised (i.e. a TypeError will be raised).
W0701:	Raising a string exception Used when a string exception is raised.
W0702:	No exception's type specified Used when an except clause doesn't specify exceptions type to catch.
W0703:	Catch "Exception" Used when an except catch Exception instances.
W0704:	Except doesn't do anything Used when an except clause does nothing but "pass" and there is no "else" clause.
W0706:	Identifier %s used to raise an exception is assigned to %s Used when a variable used to raise an exception is initially assigned to a value which can't be used as an exception.
#@nonl
#@-node:ekr.20071217231828:Exceptions
#@+node:ekr.20071217231828.1:Format
Format checker

Options

max-line-length:
 	Maximum number of characters on a single line. Default: 80
max-module-lines:
 	Maximum number of lines in a module Default: 1000
indent-string:	String used as indentation unit. This is usually " " (4 spaces) or "t" (1 tab). Default: ' '

Messages

W0311:	Bad indentation. Found %s %s, expected %s Used when an unexpected number of indentation's tabulations or spaces has been found.
W0312:	Found indentation with %ss instead of %ss Used when there are some mixed tabs and spaces in a module.
W0331:	Use of the <> operator Used when the deprecated "<>" operator is used instead of "!=".
W0332:	Use l as long integer identifier Used when a lower case "l" is used to mark a long integer. You should use a upper case "L" since the letter "l" looks too much like the digit "1"
C0301:	Line too long (%s/%s) Used when a line is longer than a given number of characters.
C0302:	Too many lines in module (%s) Used when a module has too much lines, reducing its readibility.
C0321:	More than one statement on a single line Used when more than on statement are found on the same line.
C0322:	Operator not preceded by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not preceded by a space.
C0323:	Operator not followed by a space Used when one of the following operator (!= | <= | == | >= | < | > | = | += | -= | *= | /= | %) is not followed by a space.
C0324:	Comma not followed by a space Used when a comma (",") is not followed by a space.
F0321:	Format detection error in %r Used when an unexpected error occured in bad format detection. Please report the error if it occurs.
#@nonl
#@-node:ekr.20071217231828.1:Format
#@+node:ekr.20071217231828.2:Miscellaneous
Miscellaneous checker

Options

notes:	List of note tags to take in consideration, separated by a comma. Default: FIXME,XXX,TODO

Messages

E0501:	Non ascii characters found but no encoding specified (PEP 263) Used when some non ascii characters are detected but now encoding is specified, as explicited in the PEP 263.
E0502:	Wrong encoding specified (%s) Used when a known encoding is specified but the file doesn't seem to be actually in this encoding.
E0503:	Unknown encoding specified (%s) Used when an encoding is specified, but it's unknown to Python.
W0511:	Used when a warning note as FIXME or XXX is detected.
#@nonl
#@-node:ekr.20071217231828.2:Miscellaneous
#@+node:ekr.20071217231828.3:Metrics
Metrics checker


Reports

R0701:	Raw metrics
#@-node:ekr.20071217231828.3:Metrics
#@+node:ekr.20071217231828.4:Simularities
Similarities checker

min-similarity-lines:
 	Minimum lines number of a similarity. Default: 4
ignore-comments:
 	Ignore comments when computing similarities. Default: yes
ignore-docstrings:
 	Ignore docstrings when computing similarities. Default: yes

Messages

R0801:	Similar lines in %s files Indicates that a set of similar lines has been detected among multiple file. This usually means that the code should be refactored to avoid this duplication.

Reports

R0801:	Duplication
#@-node:ekr.20071217231828.4:Simularities
#@-node:ekr.20071217231348:Pylint docs
#@+node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20031218072017.398:How to call any Python method from the C API
In general, everything you can do in Python is accessible through the C API.

	lines = block.split('\n');

> That will be

	lines = PyObject_CallMethod(block, "split", "s", "\n");
#@-node:ekr.20031218072017.398:How to call any Python method from the C API
#@+node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@+node:ekr.20031218072017.400:setting the PATHEXT env var
It is worth noting that NT, Win2K and XP all have an alternative which is
to add .PY to the PATHEXT environment variable. Then you can run any .PY
file directly just by typing the name of the script without the extension. 

e.g.
C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD

C:\>set PATH=%PATH%;c:\python22\tools\Scripts

C:\>google
'google' is not recognized as an internal or external command,
operable program or batch file.

C:\>set PATHEXT=.COM;.EXE;.BAT;.CMD;.PY

C:\>google
Usage: C:\python22\tools\Scripts\google.py querystring

C:\>
#@-node:ekr.20031218072017.400:setting the PATHEXT env var
#@+node:ekr.20031218072017.401:Yet another Python .bat wrapper
>> It has a header of just one line. All the ugly stuff is at the end.
>>
>> -------------------------------------------------------------------
>> goto ="python"
>>
>> # Python code goes here
>>
>> ''' hybrid python/batch footer:
>> @:="python"
>> @python.exe %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
>> @if errorlevel 9009 echo Python may be downloaded from
>www.python.org/download
>> @rem '''
>> -------------------------------------------------------------------
>>
>>         Oren
>>
>

It's for running python scripts on windows, without having to type:

[<path to python>\]python[.exe] <scriptname> [<arguments>*]

and almost takes the place of the "shabang" line at the top of *nix
scripts.

#@-node:ekr.20031218072017.401:Yet another Python .bat wrapper
#@-node:ekr.20031218072017.399:How to run Python programs easily on NT,2K,XP
#@-node:ekr.20031218072017.392:Python Notes...
#@+node:ekr.20070308062440:Thread notes
#@+node:ekr.20070308062440.1:Posting 2
On 2/26/07, Edward Ream <edreamleo@charter.net> wrote:

> threads will swap after sys.getcheckinterval() bytecodes have been
> processed for that thread.

Many thanks for this detailed summary.  I think this is the guarantee I need
a) to experiment with threads and b) to fiddle with settings should that 
appear to be necessary.

Just be careful.  Test your assumptions before you rely on them, especially regarding threads.  Generally threading is seen as a "hard" problem.  If you want to help make them easier, use Queues to handle inter-thread communication. 


> you can use a technique known as 'cooperative multithreading with 
> generators'.

Googling this leads directly to an entry in the Python Cookbook.  The site
is down at present.  I'll study this entry when it's back up.

The basic idea is to have each task be a generator, with each generator giving up control after some amount of work.  Here's a variant of the recipe in the cookbook... 

 - Josiah

import collections

tasks = collections.deque()

def busy():
    while 1:
        yield None

def delay(v):
    import time
    while 1:
        time.sleep(v)
        yield None 

def xpasses(x):
    while x > 0:
        x -= 1
        yield None

def runtasks():
    while 1:
        task = tasks.popleft()
        try:
            task.next()
        except StopIteration: 
            pass
        else:
            tasks.append(task)
#@nonl
#@-node:ekr.20070308062440.1:Posting 2
#@-node:ekr.20070308062440:Thread notes
#@+node:ekr.20050306070535:Tk Notes
@killcolor
#@nonl
#@+node:ekr.20050306070535.3:How to detect changes in text
http://sourceforge.net/forum/message.php?msg_id=1864564
By: btheado

WAS:RE: Leo 3.10 comments
edream wrote:

>This is due to apparent glitches in the Tk event dispatching. The problem is
that pressing a control or alt or shift key _all by themselves_ will generate
keypress events that are passed on to Leo's key handlers

This should be easy to make simpler--just bind an empty script to <Alt-KeyPress>,
<Shift-KeyPress>, etc.  Tk chooses the most specific event it can find, so the
more general <KeyPress> handler will not fire.

On a broader note, when programming the text widget in Tcl/Tk, watching key
events is not the easiest way to detect changes in the text.  The only way the
text in a text widget can change is if either the delete or the insert subcommands
(methods) are called.  Any keypresses that end up changing text will have called
one of these subcommands.

So the simplest way to detect changes is to just intercept the calls to insert
and delete.  In Tcl/Tk intercepting these calls is pretty straightforward. 
I don't know if the same is true in Tkinter.

Also note the text widget in Tk8.4 (http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M72)
has a built-in way of seeing if the text has changed

Brian Theado
#@nonl
#@-node:ekr.20050306070535.3:How to detect changes in text
#@-node:ekr.20050306070535:Tk Notes
#@+node:ekr.20031218072017.434:Unused code
@ignore
@language python
@color
#@nonl
#@+node:ekr.20031218072017.3821:Gui Tkinter classes
#@+node:ekr.20031218072017.3838:@@thin leoTkinterComparePanel.py
"""Leo's base compare class."""

@language python
@tabwidth -4
@pagewidth 80

import leo.core.leoGlobals as g
import leo.core.leoCompare as leoCompare
import leo.core.leoTkinterDialog as leoTkinterDialog
import Tkinter as Tk
import tkFileDialog

class leoTkinterComparePanel (leoCompare.leoCompare,leoTkinterDialog.leoTkinterDialog):

    """A class that creates Leo's compare panel."""

    @others
#@+node:ekr.20031218072017.3839:Birth...
#@+node:ekr.20031218072017.3840: tkinterComparePanel.__init__
def __init__ (self,c):

    # Init the base class.
    leoCompare.leoCompare.__init__ (self,c)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,"Compare files and directories",resizeable=False)

    if g.app.unitTesting: return

    self.c = c

    << init tkinter compare ivars >>

    # These ivars are set from Entry widgets.
    self.limitCount = 0
    self.limitToExtension = None

    # The default file name in the "output file name" browsers.
    self.defaultOutputFileName = "CompareResults.txt"

    self.createTopFrame()
    self.createFrame()
#@+node:ekr.20031218072017.3841:<< init tkinter compare ivars >>
# Ivars pointing to Tk elements.
self.browseEntries = []
self.extensionEntry = None
self.countEntry = None
self.printButtons = []

# No corresponding ivar in the leoCompare class.
self.useOutputFileVar = Tk.IntVar()

# These all correspond to ivars in leoCompare
self.appendOutputVar             = Tk.IntVar()

self.ignoreBlankLinesVar         = Tk.IntVar()
self.ignoreFirstLine1Var         = Tk.IntVar()
self.ignoreFirstLine2Var         = Tk.IntVar()
self.ignoreInteriorWhitespaceVar = Tk.IntVar()
self.ignoreLeadingWhitespaceVar  = Tk.IntVar()
self.ignoreSentinelLinesVar      = Tk.IntVar()

self.limitToExtensionVar         = Tk.IntVar()
self.makeWhitespaceVisibleVar    = Tk.IntVar()

self.printBothMatchesVar         = Tk.IntVar()
self.printMatchesVar             = Tk.IntVar()
self.printMismatchesVar          = Tk.IntVar()
self.printTrailingMismatchesVar  = Tk.IntVar()
self.stopAfterMismatchVar        = Tk.IntVar()
#@-node:ekr.20031218072017.3841:<< init tkinter compare ivars >>
#@-node:ekr.20031218072017.3840: tkinterComparePanel.__init__
#@+node:ekr.20031218072017.3842:finishCreate (tkComparePanel)
# Initialize ivars from config parameters.

def finishCreate (self):

    c = self.c

    # File names.
    for i,option in (
        (0,"compare_file_1"),
        (1,"compare_file_2"),
        (2,"output_file") ):

        name = c.config.getString(option)
        if name and len(name) > 0:
            e = self.browseEntries[i]
            e.delete(0,"end")
            e.insert(0,name)

    name = c.config.getString("output_file")
    b = g.choose(name and len(name) > 0,1,0)
    self.useOutputFileVar.set(b)

    # File options.
    b = c.config.getBool("ignore_first_line_of_file_1")
    if b == None: b = 0
    self.ignoreFirstLine1Var.set(b)

    b = c.config.getBool("ignore_first_line_of_file_2")
    if b == None: b = 0
    self.ignoreFirstLine2Var.set(b)

    b = c.config.getBool("append_output_to_output_file")
    if b == None: b = 0
    self.appendOutputVar.set(b)

    ext = c.config.getString("limit_directory_search_extension")
    b = ext and len(ext) > 0
    b = g.choose(b and b != 0,1,0)
    self.limitToExtensionVar.set(b)
    if b:
        e = self.extensionEntry
        e.delete(0,"end")
        e.insert(0,ext)

    # Print options.
    b = c.config.getBool("print_both_lines_for_matches")
    if b == None: b = 0
    self.printBothMatchesVar.set(b)

    b = c.config.getBool("print_matching_lines")
    if b == None: b = 0
    self.printMatchesVar.set(b)

    b = c.config.getBool("print_mismatching_lines")
    if b == None: b = 0
    self.printMismatchesVar.set(b)

    b = c.config.getBool("print_trailing_lines")
    if b == None: b = 0
    self.printTrailingMismatchesVar.set(b)

    n = c.config.getInt("limit_count")
    b = n and n > 0
    b = g.choose(b and b != 0,1,0)
    self.stopAfterMismatchVar.set(b)
    if b:
        e = self.countEntry
        e.delete(0,"end")
        e.insert(0,str(n))

    # bool options...
    for option,var,default in (
        # Whitespace options.
        ("ignore_blank_lines",self.ignoreBlankLinesVar,1),
        ("ignore_interior_whitespace",self.ignoreInteriorWhitespaceVar,0),
        ("ignore_leading_whitespace",self.ignoreLeadingWhitespaceVar,0),
        ("ignore_sentinel_lines",self.ignoreSentinelLinesVar,0),
        ("make_whitespace_visible", self.makeWhitespaceVisibleVar,0),
    ):
        b = c.config.getBool(option)
        if b is None: b = default
        var.set(b)

    if 0: # old code
        b = c.config.getBool("ignore_blank_lines")
        if b == None: b = 1 # unusual default.
        self.ignoreBlankLinesVar.set(b)

        b = c.config.getBool("ignore_interior_whitespace")
        if b == None: b = 0
        self.ignoreInteriorWhitespaceVar.set(b)

        b = c.config.getBool("ignore_leading_whitespace")
        if b == None: b = 0
        self.ignoreLeadingWhitespaceVar.set(b)

        b = c.config.getBool("ignore_sentinel_lines")
        if b == None: b = 0
        self.ignoreSentinelLinesVar.set(b)

        b = c.config.getBool("make_whitespace_visible")
        if b == None: b = 0
        self.makeWhitespaceVisibleVar.set(b)
#@-node:ekr.20031218072017.3842:finishCreate (tkComparePanel)
#@+node:ekr.20031218072017.3843:createFrame (tkComparePanel)
def createFrame (self):

    gui = g.app.gui ; top = self.top

    << create the organizer frames >>
    << create the browser rows >>
    << create the extension row >>
    << create the whitespace options frame >>
    << create the print options frame >>
    << create the compare buttons >>

    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
    top.protocol("WM_DELETE_WINDOW", self.onClose)
#@+node:ekr.20031218072017.3844:<< create the organizer frames >>
outer = Tk.Frame(self.frame, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)
#@-node:ekr.20031218072017.3844:<< create the organizer frames >>
#@+node:ekr.20031218072017.3845:<< create the browser rows >>
for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)

    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)

    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")
#@-node:ekr.20031218072017.3845:<< create the browser rows >>
#@+node:ekr.20031218072017.3846:<< create the extension row >>
b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)
#@-node:ekr.20031218072017.3846:<< create the extension row >>
#@+node:ekr.20031218072017.3847:<< create the whitespace options frame >>
w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")

for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):

    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")

spacer = Tk.Frame(f)
spacer.pack(padx="1i")
#@-node:ekr.20031218072017.3847:<< create the whitespace options frame >>
#@+node:ekr.20031218072017.3848:<< create the print options frame >>
w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(1,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):

    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)

# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")
#@-node:ekr.20031218072017.3848:<< create the print options frame >>
#@+node:ekr.20031218072017.3849:<< create the compare buttons >>
for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):

    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)
#@-node:ekr.20031218072017.3849:<< create the compare buttons >>
#@-node:ekr.20031218072017.3843:createFrame (tkComparePanel)
#@+node:ekr.20031218072017.3850:setIvarsFromWidgets
def setIvarsFromWidgets (self):

    # File paths: checks for valid file name.
    e = self.browseEntries[0]
    self.fileName1 = e.get()

    e = self.browseEntries[1]
    self.fileName2 = e.get()

    # Ignore first line settings.
    self.ignoreFirstLine1 = self.ignoreFirstLine1Var.get()
    self.ignoreFirstLine2 = self.ignoreFirstLine2Var.get()

    # Output file: checks for valid file name.
    if self.useOutputFileVar.get():
        e = self.browseEntries[2]
        name = e.get()
        if name != None and len(name) == 0:
            name = None
        self.outputFileName = name
    else:
        self.outputFileName = None

    # Extension settings.
    if self.limitToExtensionVar.get():
        self.limitToExtension = self.extensionEntry.get()
        if len(self.limitToExtension) == 0:
            self.limitToExtension = None
    else:
        self.limitToExtension = None

    self.appendOutput = self.appendOutputVar.get()

    # Whitespace options.
    self.ignoreBlankLines         = self.ignoreBlankLinesVar.get()
    self.ignoreInteriorWhitespace = self.ignoreInteriorWhitespaceVar.get()
    self.ignoreLeadingWhitespace  = self.ignoreLeadingWhitespaceVar.get()
    self.ignoreSentinelLines      = self.ignoreSentinelLinesVar.get()
    self.makeWhitespaceVisible    = self.makeWhitespaceVisibleVar.get()

    # Print options.
    self.printMatches            = self.printMatchesVar.get()
    self.printMismatches         = self.printMismatchesVar.get()
    self.printTrailingMismatches = self.printTrailingMismatchesVar.get()

    if self.printMatches:
        self.printBothMatches = self.printBothMatchesVar.get()
    else:
        self.printBothMatches = False

    if self.stopAfterMismatchVar.get():
        try:
            count = self.countEntry.get()
            self.limitCount = int(count)
        except: self.limitCount = 0
    else:
        self.limitCount = 0
#@-node:ekr.20031218072017.3850:setIvarsFromWidgets
#@-node:ekr.20031218072017.3839:Birth...
#@+node:ekr.20031218072017.3851:bringToFront
def bringToFront(self):

    self.top.deiconify()
    self.top.lift()
#@-node:ekr.20031218072017.3851:bringToFront
#@+node:ekr.20031218072017.3852:browser
def browser (self,n):

    types = [
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py"),
        ("Text files","*.txt"),
        ("All files","*") ]

    fileName = tkFileDialog.askopenfilename(
        title="Choose compare file" + n,
        filetypes=types,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        # The dialog also warns about this, so this may never happen.
        if not g.os_path_exists(fileName):
            self.show("not found: " + fileName)
            fileName = None
    else: fileName = None

    return fileName
#@-node:ekr.20031218072017.3852:browser
#@+node:ekr.20031218072017.3853:Event handlers...
#@+node:ekr.20031218072017.3854:onBrowse...
def onBrowse1 (self):

    fileName = self.browser("1")
    if fileName:
        e = self.browseEntries[0]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()

def onBrowse2 (self):

    fileName = self.browser("2")
    if fileName:
        e = self.browseEntries[1]
        e.delete(0,"end")
        e.insert(0,fileName)
    self.top.deiconify()

def onBrowse3 (self): # Get the name of the output file.

    fileName = tkFileDialog.asksaveasfilename(
        initialfile = self.defaultOutputFileName,
        title="Set output file",
        filetypes=[("Text files", "*.txt")],
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        self.defaultOutputFileName = fileName
        self.useOutputFileVar.set(1) # The user will expect this.
        e = self.browseEntries[2]
        e.delete(0,"end")
        e.insert(0,fileName)
#@-node:ekr.20031218072017.3854:onBrowse...
#@+node:ekr.20031218072017.3855:onClose
def onClose (self):

    self.top.withdraw()
#@-node:ekr.20031218072017.3855:onClose
#@+node:ekr.20031218072017.3856:onCompare...
def onCompareDirectories (self):

    self.setIvarsFromWidgets()
    self.compare_directories(self.fileName1,self.fileName2)

def onCompareFiles (self):

    self.setIvarsFromWidgets()
    self.compare_files(self.fileName1,self.fileName2)
#@-node:ekr.20031218072017.3856:onCompare...
#@+node:ekr.20031218072017.3857:onPrintMatchedLines
def onPrintMatchedLines (self):

    v = self.printMatchesVar.get()
    b = self.printButtons[1]
    state = g.choose(v,"normal","disabled")
    b.configure(state=state)
#@-node:ekr.20031218072017.3857:onPrintMatchedLines
#@-node:ekr.20031218072017.3853:Event handlers...
#@-node:ekr.20031218072017.3838:@@thin leoTkinterComparePanel.py
#@+node:ekr.20031218072017.3858:@@thin leoTkinterDialog.py
@language python
@tabwidth -4
@pagewidth 80

import leo.core.leoGlobals as g
# import string

try:
    import tkinter as Tk
except ImportError:
    import Tkinter as Tk

Pmw = g.importExtension("Pmw",    pluginName='LeoTkinterDialog',verbose=True,required=True)

@others
#@+node:ekr.20031218072017.3859: class leoTkinterDialog
class leoTkinterDialog:
    """The base class for all Leo Tkinter dialogs"""
    @others
#@+node:ekr.20031218072017.3860:__init__ (tkDialog)
def __init__(self,c,title="",resizeable=True,canClose=True,show=True):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.c = c # For use by delayed focus methods in c.frame.
    self.resizeable = resizeable
    self.title = title
    self.modal = None

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # g.app.root
    self.showFlag = show
    self.top = None # The toplevel Tk widget.
    self.focus_widget = None # The widget to get the first focus.
    self.canClose = canClose
#@-node:ekr.20031218072017.3860:__init__ (tkDialog)
#@+node:ekr.20031218072017.3861:cancelButton, noButton, okButton, yesButton
def cancelButton(self):

    """Do default click action in cancel button."""

    self.answer="cancel"
    self.top.destroy()

def noButton(self):

    """Do default click action in no button."""

    self.answer="no"
    self.top.destroy()

def okButton(self):

    """Do default click action in ok button."""

    self.answer="ok"
    self.top.destroy()

def yesButton(self):

    """Do default click action in yes button."""

    self.answer="yes"
    self.top.destroy()
#@-node:ekr.20031218072017.3861:cancelButton, noButton, okButton, yesButton
#@+node:ekr.20031218072017.3862:center
def center(self):

    """Center any leoTkinterDialog."""

    g.app.gui.center_dialog(self.top)
#@-node:ekr.20031218072017.3862:center
#@+node:ekr.20031218072017.3863:createButtons
def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","<missing button name>")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
#@-node:ekr.20031218072017.3863:createButtons
#@+node:ekr.20031218072017.3864:createMessageFrame
def createMessageFrame (self,message):

    """Create a frame containing a Tk.Label widget."""

    label = Tk.Label(self.frame,text=message)
    label.pack(pady=10)
#@-node:ekr.20031218072017.3864:createMessageFrame
#@+node:ekr.20031218072017.3865:createTopFrame
def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    if g.app.unitTesting: return

    self.root = g.app.root
    # g.trace("leoTkinterDialog",'root',self.root)

    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)

    if not self.resizeable:
        self.top.resizable(0,0) # neither height or width is resizable.

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    if not self.canClose:
        self.top.protocol("WM_DELETE_WINDOW", self.onClose)

    if not g.app.unitTesting: # Do this at idle time.
        def attachIconCallback(top=self.top):
            g.app.gui.attachLeoIcon(top)

        self.top.after_idle(attachIconCallback)
#@-node:ekr.20031218072017.3865:createTopFrame
#@+node:ekr.20040731065422:onClose
def onClose (self):

    """Disable all attempts to close this frame with the close box."""

    pass
#@-node:ekr.20040731065422:onClose
#@+node:ekr.20031218072017.3866:run (tkDialog)
def run (self,modal):

    """Run a leoTkinterDialog."""

    if g.app.unitTesting: return None

    c = self.c ; self.modal = modal

    self.center() # Do this after all packing complete.
    if self.showFlag:
        self.top.lift()
    else:
        self.top.withdraw()

    # Get all keystrokes.
    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.

    if self.focus_widget == None:
        self.focus_widget = self.top

    if c:
        c.widgetWantsFocusNow(self.focus_widget)

    self.root.wait_window(self.top)

    if self.modal:
        return self.answer
    else:
        return None
#@-node:ekr.20031218072017.3866:run (tkDialog)
#@-node:ekr.20031218072017.3859: class leoTkinterDialog
#@+node:ekr.20031218072017.3867:class tkinterAboutLeo
class tkinterAboutLeo (leoTkinterDialog):

    """A class that creates the Tkinter About Leo dialog."""

    @others
#@+node:ekr.20031218072017.3868:tkinterAboutLeo.__init__
def __init__ (self,c,version,theCopyright,url,email):

    """Create a Tkinter About Leo dialog."""

    leoTkinterDialog.__init__(self,c,"About Leo",resizeable=True) # Initialize the base class.

    if g.app.unitTesting: return

    self.copyright = theCopyright
    self.email = email
    self.url = url
    self.version = version

    c.inCommand = False # Allow the app to close immediately.

    self.createTopFrame()
    self.createFrame()
#@-node:ekr.20031218072017.3868:tkinterAboutLeo.__init__
#@+node:ekr.20031218072017.3869:tkinterAboutLeo.createFrame
def createFrame (self):

    """Create the frame for an About Leo dialog."""

    if g.app.unitTesting: return

    c = self.c

    frame = self.frame
    theCopyright = self.copyright ; email = self.email
    url = self.url ; version = self.version

    # Calculate the approximate height & width. (There are bugs in Tk here.)
    lines = theCopyright.split('\n')
    height = len(lines) + 8 # Add lines for version,url,email,spacing.
    width = 0
    for line in lines:
        width = max(width,len(line))
    width = max(width,len(url))
    width += 10 # 9/9/02

    frame.pack(padx=6,pady=4)

    self.text = w = g.app.gui.plainTextWidget(
        frame,height=height,width=width,bd=0,bg=frame.cget("background"))
    w.pack(pady=10)

    try:
        bitmap_name = g.os_path_join(g.app.loadDir,"..","Icons","Leoapp.GIF") # 5/12/03
        image = Tk.PhotoImage(file=bitmap_name)
        w.image_create("1.0",image=image,padx=10)
    except Exception:
        pass # This can sometimes happen for mysterious reasons.

    w.insert("end",version) #,tag="version")
    w.tag_add('version','end-%dc' %(len(version)+1),'end-1c')
    w.insert("end",theCopyright) #,tag="copyright")
    w.tag_add('copyright','end-%dc' %(len(theCopyright)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",url)
    w.tag_add('url','end-%dc' %(len(url)+1),'end-1c')
    w.insert("end",'\n')
    w.insert("end",email)
    w.tag_add('url','end-%dc' %(len(email)+1),'end-1c')

    w.tag_config("version",justify="center")
    w.tag_config("copyright",justify="center",spacing1="3")
    w.tag_config("url",underline=1,justify="center",spacing1="10")

    c.tag_bind(w,"url","<Button-1>",self.onAboutLeoUrl)
    c.tag_bind(w,"url","<Enter>",self.setArrowCursor)
    c.tag_bind(w,"url","<Leave>",self.setDefaultCursor)

    w.tag_config("email",underline=1,justify="center",spacing1="10")
    c.tag_bind(w,"email","<Button-1>",self.onAboutLeoEmail)
    c.tag_bind(w,"email","<Enter>",self.setArrowCursor)
    c.tag_bind(w,"email","<Leave>",self.setDefaultCursor)

    w.configure(state="disabled")
#@-node:ekr.20031218072017.3869:tkinterAboutLeo.createFrame
#@+node:ekr.20031218072017.3870:tkinterAboutLeo.onAboutLeoEmail
def onAboutLeoEmail(self,event=None):

    """Handle clicks in the email link in an About Leo dialog."""

    try:
        import webbrowser
        webbrowser.open("mailto:" + self.email)
    except:
        g.es("not found:",self.email)
#@-node:ekr.20031218072017.3870:tkinterAboutLeo.onAboutLeoEmail
#@+node:ekr.20031218072017.3871:tkinterAboutLeo.onAboutLeoUrl
def onAboutLeoUrl(self,event=None):

    """Handle clicks in the url link in an About Leo dialog."""

    try:
        import webbrowser
        webbrowser.open(self.url)
    except:
        g.es("not found:",self.url)
#@-node:ekr.20031218072017.3871:tkinterAboutLeo.onAboutLeoUrl
#@+node:ekr.20031218072017.3872:tkinterAboutLeo: setArrowCursor, setDefaultCursor
def setArrowCursor (self,event=None):

    """Set the cursor to an arrow in an About Leo dialog."""

    self.text.configure(cursor="arrow")

def setDefaultCursor (self,event=None):

    """Set the cursor to the default cursor in an About Leo dialog."""

    self.text.configure(cursor="xterm")
#@-node:ekr.20031218072017.3872:tkinterAboutLeo: setArrowCursor, setDefaultCursor
#@-node:ekr.20031218072017.3867:class tkinterAboutLeo
#@+node:ekr.20031218072017.1983:class tkinterAskLeoID
class tkinterAskLeoID (leoTkinterDialog):

    """A class that creates the Tkinter About Leo dialog."""

    @others
#@+node:ekr.20031218072017.1984:tkinterAskLeoID.__init__
def __init__(self,c=None):

    """Create the Leo Id dialog."""

    # Initialize the base class: prevent clicks in the close box from closing.
    leoTkinterDialog.__init__(self,c,"Enter unique id",resizeable=False,canClose=False)

    if g.app.unitTesting: return

    self.id_entry = None
    self.answer = None

    self.createTopFrame()
    if c:
        c.bind(self.top,"<Key>", self.onKey)
    else:
        g.trace('can not use c.bind')
        self.top.bind("<Key>", self.onKey)

    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs login name is a good choice.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    self.createFrame(message)
    self.focus_widget = self.id_entry

    buttons = {"text":"OK","command":self.onButton,"default":True}, # Singleton tuple.
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0]
    self.ok_button.configure(state="disabled")
#@-node:ekr.20031218072017.1984:tkinterAskLeoID.__init__
#@+node:ekr.20031218072017.1985:tkinterAskLeoID.createFrame
def createFrame(self,message):

    """Create the frame for the Leo Id dialog."""

    if g.app.unitTesting: return

    f = self.frame

    label = Tk.Label(f,text=message)
    label.pack(pady=10)

    self.id_entry = text = Tk.Entry(f,width=20)
    text.pack()
#@-node:ekr.20031218072017.1985:tkinterAskLeoID.createFrame
#@+node:ekr.20031218072017.1987:tkinterAskLeoID.onButton
def onButton(self):

    """Handle clicks in the Leo Id close button."""

    s = self.id_entry.get().strip()
    if len(s) < 3:  # Require at least 3 characters in an id.
        return

    self.answer = g.app.leoID = s

    self.top.destroy() # terminates wait_window
    self.top = None
#@-node:ekr.20031218072017.1987:tkinterAskLeoID.onButton
#@+node:ekr.20031218072017.1988:tkinterAskLeoID.onKey
def onKey(self,event):

    """Handle keystrokes in the Leo Id dialog."""

    << eliminate invalid characters >>
    << enable the ok button if there are 3 or more valid characters >>

    ch = event.char.lower()
    if ch in ('\n','\r'):
        self.onButton()
    return "break"
#@+node:ekr.20031218072017.1989:<< eliminate invalid characters >>
e = self.id_entry
s = e.get().strip()
i = 0 ; ok = True
while i < len(s):
    ch = s[i]
    if not ch.isalnum():
        e.delete(str(i))
        s = e.get()
        ok = False
    else:
        i += 1
if not ok: return
#@-node:ekr.20031218072017.1989:<< eliminate invalid characters >>
#@+node:ekr.20031218072017.1990:<< enable the ok button if there are 3 or more valid characters >>
e = self.id_entry
b = self.ok_button

if len(e.get().strip()) >= 3:
    b.configure(state="normal")
else:
    b.configure(state="disabled")
#@-node:ekr.20031218072017.1990:<< enable the ok button if there are 3 or more valid characters >>
#@-node:ekr.20031218072017.1988:tkinterAskLeoID.onKey
#@-node:ekr.20031218072017.1983:class tkinterAskLeoID
#@+node:ekr.20031218072017.3873:class tkinterAskOk
class tkinterAskOk(leoTkinterDialog):

    """A class that creates a Tkinter dialog with a single OK button."""

    @others
#@+node:ekr.20031218072017.3874:class tkinterAskOk.__init__
def __init__ (self,c,title,message=None,text="Ok",resizeable=False):

    """Create a dialog with one button"""

    leoTkinterDialog.__init__(self,c,title,resizeable) # Initialize the base class.

    if g.app.unitTesting: return

    self.text = text
    self.createTopFrame()

    c.bind(self.top,"<Key>", self.onKey)

    if message:
        self.createMessageFrame(message)

    buttons = {"text":text,"command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
#@-node:ekr.20031218072017.3874:class tkinterAskOk.__init__
#@+node:ekr.20031218072017.3875:class tkinterAskOk.onKey
def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    ch = event.char.lower()

    if ch in (self.text[0].lower(),'\n','\r'):
        self.okButton()

    return "break"
#@-node:ekr.20031218072017.3875:class tkinterAskOk.onKey
#@-node:ekr.20031218072017.3873:class tkinterAskOk
#@+node:ekr.20031218072017.3876:class tkinterAskOkCancelNumber
class  tkinterAskOkCancelNumber (leoTkinterDialog):

    """Create and run a modal Tkinter dialog to get a number."""

    @others
#@+node:ekr.20031218072017.3877:tkinterAskOKCancelNumber.__init__
def __init__ (self,c,title,message):

    """Create a number dialog"""

    leoTkinterDialog.__init__(self,c,title,resizeable=False) # Initialize the base class.

    if g.app.unitTesting: return

    self.answer = -1
    self.number_entry = None

    self.createTopFrame()
    c.bind(self.top,"<Key>", self.onKey)

    self.createFrame(message)
    self.focus_widget = self.number_entry

    buttons = (
            {"text":"Ok",    "command":self.okButton,     "default":True},
            {"text":"Cancel","command":self.cancelButton} )
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0] # Override the default kind of Ok button.
#@-node:ekr.20031218072017.3877:tkinterAskOKCancelNumber.__init__
#@+node:ekr.20031218072017.3878:tkinterAskOKCancelNumber.createFrame
def createFrame (self,message):

    """Create the frame for a number dialog."""

    if g.app.unitTesting: return

    c = self.c

    lab = Tk.Label(self.frame,text=message)
    lab.pack(pady=10,side="left")

    self.number_entry = w = Tk.Entry(self.frame,width=20)
    w.pack(side="left")

    c.set_focus(w)
#@-node:ekr.20031218072017.3878:tkinterAskOKCancelNumber.createFrame
#@+node:ekr.20031218072017.3879:tkinterAskOKCancelNumber.okButton, cancelButton
def okButton(self):

    """Handle clicks in the ok button of a number dialog."""

    s = self.number_entry.get().strip()

    try:
        self.answer=int(s)
    except:
        self.answer=-1 # Cancel the operation.

    self.top.destroy()

def cancelButton(self):

    """Handle clicks in the cancel button of a number dialog."""

    self.answer=-1
    self.top.destroy()
#@-node:ekr.20031218072017.3879:tkinterAskOKCancelNumber.okButton, cancelButton
#@+node:ekr.20031218072017.3880:tkinterAskOKCancelNumber.onKey
def onKey (self,event):

    << eliminate non-numbers >>

    ch = event.char.lower()

    if ch in ('o','\n','\r'):
        self.okButton()
    elif ch == 'c':
        self.cancelButton()

    return "break"
#@+node:ekr.20031218072017.3881:<< eliminate non-numbers >>
e = self.number_entry
s = e.get().strip()

i = 0
while i < len(s):
    ch = s[i]
    if not ch.isdigit():
        e.delete(str(i))
        s = e.get()
    else:
        i += 1
#@-node:ekr.20031218072017.3881:<< eliminate non-numbers >>
#@-node:ekr.20031218072017.3880:tkinterAskOKCancelNumber.onKey
#@-node:ekr.20031218072017.3876:class tkinterAskOkCancelNumber
#@+node:ekr.20070122103505:class tkinterAskOkCancelString
class  tkinterAskOkCancelString (leoTkinterDialog):

    """Create and run a modal Tkinter dialog to get a string."""

    @others
#@+node:ekr.20070122103505.1:tkinterAskOKCancelString.__init__
def __init__ (self,c,title,message):

    """Create a number dialog"""

    leoTkinterDialog.__init__(self,c,title,resizeable=False) # Initialize the base class.

    if g.app.unitTesting: return

    self.answer = -1
    self.number_entry = None

    self.createTopFrame()
    c.bind(self.top,"<Key>", self.onKey)

    self.createFrame(message)
    self.focus_widget = self.number_entry

    buttons = (
            {"text":"Ok",    "command":self.okButton,     "default":True},
            {"text":"Cancel","command":self.cancelButton} )
    buttonList = self.createButtons(buttons)
    self.ok_button = buttonList[0] # Override the default kind of Ok button.
#@-node:ekr.20070122103505.1:tkinterAskOKCancelString.__init__
#@+node:ekr.20070122103505.2:tkinterAskOkCancelString.createFrame
def createFrame (self,message):

    """Create the frame for a number dialog."""

    if g.app.unitTesting: return

    c = self.c

    lab = Tk.Label(self.frame,text=message)
    lab.pack(pady=10,side="left")

    self.number_entry = w = Tk.Entry(self.frame,width=20)
    w.pack(side="left")

    c.set_focus(w)
#@-node:ekr.20070122103505.2:tkinterAskOkCancelString.createFrame
#@+node:ekr.20070122103505.3:tkinterAskOkCancelString.okButton, cancelButton
def okButton(self):

    """Handle clicks in the ok button of a string dialog."""

    self.answer = self.number_entry.get().strip()
    self.top.destroy()

def cancelButton(self):

    """Handle clicks in the cancel button of a string dialog."""

    self.answer=''
    self.top.destroy()
#@-node:ekr.20070122103505.3:tkinterAskOkCancelString.okButton, cancelButton
#@+node:ekr.20070122103505.4:tkinterAskOkCancelString.onKey
def onKey (self,event):

    ch = event.char.lower()

    if ch in ('\n','\r'):
        self.okButton()

    return "break"
#@-node:ekr.20070122103505.4:tkinterAskOkCancelString.onKey
#@-node:ekr.20070122103505:class tkinterAskOkCancelString
#@+node:ekr.20031218072017.3882:class tkinterAskYesNo
class tkinterAskYesNo (leoTkinterDialog):

    """A class that creates a Tkinter dialog with two buttons: Yes and No."""

    @others
#@+node:ekr.20031218072017.3883:tkinterAskYesNo.__init__
def __init__ (self,c,title,message=None,resizeable=False):

    """Create a dialog having yes and no buttons."""

    leoTkinterDialog.__init__(self,c,title,resizeable) # Initialize the base class.

    if g.app.unitTesting: return

    self.createTopFrame()
    c.bind(self.top,"<Key>",self.onKey)

    if message:
        self.createMessageFrame(message)

    buttons = (
        {"text":"Yes","command":self.yesButton,  "default":True},
        {"text":"No", "command":self.noButton} )
    self.createButtons(buttons)
#@-node:ekr.20031218072017.3883:tkinterAskYesNo.__init__
#@+node:ekr.20031218072017.3884:tkinterAskYesNo.onKey
def onKey(self,event):

    """Handle keystroke events in dialogs having yes and no buttons."""

    ch = event.char.lower()

    if ch in ('y','\n','\r'):
        self.yesButton()
    elif ch == 'n':
        self.noButton()

    return "break"
#@-node:ekr.20031218072017.3884:tkinterAskYesNo.onKey
#@-node:ekr.20031218072017.3882:class tkinterAskYesNo
#@+node:ekr.20031218072017.3885:class tkinterAskYesNoCancel
class tkinterAskYesNoCancel(leoTkinterDialog):

    """A class to create and run Tkinter dialogs having three buttons.

    By default, these buttons are labeled Yes, No and Cancel."""

    @others
#@+node:ekr.20031218072017.3886:askYesNoCancel.__init__
def __init__ (self,c,title,
    message=None,
    yesMessage="Yes",
    noMessage="No",
    defaultButton="Yes",
    resizeable=False):

    """Create a dialog having three buttons."""

    leoTkinterDialog.__init__(self,c,title,resizeable,canClose=False) # Initialize the base class.

    if g.app.unitTesting: return

    self.yesMessage,self.noMessage = yesMessage,noMessage
    self.defaultButton = defaultButton

    self.createTopFrame()
    c.bind(self.top,"<Key>",self.onKey)

    if message:
        self.createMessageFrame(message)

    buttons = (
        {"text":yesMessage,"command":self.yesButton,   "default":yesMessage==defaultButton},
        {"text":noMessage, "command":self.noButton,    "default":noMessage==defaultButton},
        {"text":"Cancel",  "command":self.cancelButton,"default":"Cancel"==defaultButton} )
    self.createButtons(buttons)
#@-node:ekr.20031218072017.3886:askYesNoCancel.__init__
#@+node:ekr.20031218072017.3887:askYesNoCancel.onKey
def onKey(self,event):

    """Handle keystrokes in dialogs with three buttons."""

    ch = event.char.lower()

    if ch in ('\n','\r'):
        ch = self.defaultButton[0].lower()

    if ch == self.yesMessage[0].lower():
        self.yesButton()
    elif ch == self.noMessage[0].lower():
        self.noButton()
    elif ch == 'c':
        self.cancelButton()

    return "break"
#@-node:ekr.20031218072017.3887:askYesNoCancel.onKey
#@+node:ekr.20031218072017.3888:askYesNoCancel.noButton & yesButton
def noButton(self):

    """Handle clicks in the 'no' (second) button in a dialog with three buttons."""

    self.answer=self.noMessage.lower()
    self.top.destroy()

def yesButton(self):

    """Handle clicks in the 'yes' (first) button in a dialog with three buttons."""

    self.answer=self.yesMessage.lower()
    self.top.destroy()
#@-node:ekr.20031218072017.3888:askYesNoCancel.noButton & yesButton
#@-node:ekr.20031218072017.3885:class tkinterAskYesNoCancel
#@+node:ekr.20031218072017.3889:class tkinterListboxDialog
class tkinterListBoxDialog (leoTkinterDialog):

    """A base class for Tkinter dialogs containing a Tk Listbox"""

    @others
#@+node:ekr.20031218072017.3890:tkinterListboxDialog.__init__
def __init__ (self,c,title,label):

    """Constructor for the base listboxDialog class."""

    leoTkinterDialog.__init__(self,c,title,resizeable=True) # Initialize the base class.

    if g.app.unitTesting: return

    self.createTopFrame()
    self.top.protocol("WM_DELETE_WINDOW", self.destroy)

    # Initialize common ivars.
    self.label = label
    self.positionList = []
    self.buttonFrame = None

    # Fill in the frame.
    self.createFrame()
    self.fillbox()

    # Make the common bindings after creating self.box.
    c.bind(self.box,"<Double-Button-1>",self.go)
#@-node:ekr.20031218072017.3890:tkinterListboxDialog.__init__
#@+node:ekr.20031218072017.3891:addStdButtons
def addStdButtons (self,frame):

    """Add standard buttons to a listBox dialog."""

    # Create the ok and cancel buttons.
    self.ok = ok = Tk.Button(frame,text="Go",width=6,command=self.go)
    self.hideButton = hide = Tk.Button(frame,text="Hide",width=6,command=self.hide)

    ok.pack(side="left",pady=2,padx=5)
    hide.pack(side="left",pady=2,padx=5)
#@-node:ekr.20031218072017.3891:addStdButtons
#@+node:ekr.20031218072017.3892:createFrame
def createFrame(self):

    """Create the essentials of a listBoxDialog frame

    Subclasses will add buttons to self.buttonFrame"""

    if g.app.unitTesting: return

    self.outerFrame = f = Tk.Frame(self.frame)
    f.pack(expand=1,fill="both")

    if self.label:
        labf = Tk.Frame(f)
        labf.pack(pady=2)
        lab = Tk.Label(labf,text=self.label)
        lab.pack()

    f2 = Tk.Frame(f)
    f2.pack(expand=1,fill="both")

    self.box = box = Tk.Listbox(f2,height=20,width=30)
    box.pack(side="left",expand=1,fill="both")

    bar = Tk.Scrollbar(f2)
    bar.pack(side="left", fill="y")

    bar.config(command=box.yview)
    box.config(yscrollcommand=bar.set)
#@-node:ekr.20031218072017.3892:createFrame
#@+node:ekr.20031218072017.3893:destroy
def destroy (self,event=None):

    """Hide, do not destroy, a listboxDialog window

    subclasses may override to really destroy the window"""

    self.top.withdraw() # Don't allow this window to be destroyed.
#@-node:ekr.20031218072017.3893:destroy
#@+node:ekr.20031218072017.3894:hide
def hide (self):

    """Hide a list box dialog."""

    self.top.withdraw()
#@-node:ekr.20031218072017.3894:hide
#@+node:ekr.20031218072017.3895:fillbox
def fillbox(self,event=None):

    """Fill a listbox from information.

    Overridden by subclasses"""

    pass
#@-node:ekr.20031218072017.3895:fillbox
#@+node:ekr.20031218072017.3896:go
def go(self,event=None):

    """Handle clicks in the "go" button in a list box dialog."""

    c = self.c ; box = self.box

    # Work around an old Python bug.  Convert strings to ints.
    items = box.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        p = self.positionList[n]
        c.frame.tree.expandAllAncestors(p)
        c.selectPosition(p)
        c.redraw()
#@-node:ekr.20031218072017.3896:go
#@-node:ekr.20031218072017.3889:class tkinterListboxDialog
#@-node:ekr.20031218072017.3858:@@thin leoTkinterDialog.py
#@+node:ekr.20031218072017.3897:@@thin leoTkinterFind.py
@language python
@tabwidth -4
@pagewidth 80

import leo.core.leoGlobals as g
import leo.core.leoFind as leoFind

import sys

# import leo.core.leoTkinterDialog as leoTkinterDialog
import Tkinter as Tk

Pmw = g.importExtension('Pmw',pluginName=None,verbose=False)

@others
#@+node:ekr.20041025152343:class underlinedTkButton
class underlinedTkButton:

    @others
#@+node:ekr.20041025152712:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")

    self.text = text # for traces
#@+node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@-node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20041025152712:__init__
#@+node:ekr.20041026080125:bindHotKey
def bindHotKey (self,widget):

    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.buttonCallback)
#@-node:ekr.20041026080125:bindHotKey
#@+node:ekr.20041025152717:buttonCallback
# The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):

    # g.trace(self.text)
    self.button.invoke ()

    # See if this helps.
    return 'break'
#@-node:ekr.20041025152717:buttonCallback
#@-node:ekr.20041025152343:class underlinedTkButton
#@+node:ekr.20061212085958:class tkFindTab (findTab)
class tkFindTab (leoFind.findTab):

    '''A subclass of the findTab class containing all Tk code.'''

    @others
#@nonl
#@+node:ekr.20061212085958.1: Birth
#@+node:ekr.20080707150137.4: ctor (tkFindTab)
if 0: # Use the base class ctor.

    def __init__ (self,c,parentFrame):

        leoFind.findTab.__init__(self,c,parentFrame)
            # Init the base class.
            # Calls initGui, createFrame, createBindings & init(c), in that order.

#@-node:ekr.20080707150137.4: ctor (tkFindTab)
#@+node:ekr.20051020120306.12:initGui
def initGui (self):

    self.svarDict = {}

    for key in self.intKeys:
        self.svarDict[key] = Tk.IntVar()

    for key in self.newStringKeys:
        self.svarDict[key] = Tk.StringVar()

#@-node:ekr.20051020120306.12:initGui
#@+node:ekr.20051020120306.13:createFrame (tkFindTab)
def createFrame (self,parentFrame):

    c = self.c

    # g.trace('findTab')

    << Create the outer frames >>
    << Create the Find and Change panes >>
    << Create two columns of radio and checkboxes >>

    if  self.optionsOnly:
        buttons = []
    else:
        << Create two columns of buttons >>

    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
#@+node:ekr.20051020120306.14:<< Create the outer frames >>
configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)
#@-node:ekr.20051020120306.14:<< Create the outer frames >>
#@+node:ekr.20051020120306.15:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = g.app.gui.plainTextWidget(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = g.app.gui.plainTextWidget(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = g.app.gui.plainTextWidget(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = g.app.gui.plainTextWidget(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
<< Bind Tab and control-tab >>

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')

    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")
#@+node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
def setFocus(w):
    c = self.c
    c.widgetWantsFocusNow(w)
    w.setSelectionRange(0,0)
    return "break"

def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)

def insertTab(w):
    data = w.getSelectionRange()
    if data: start,end = data
    else: start = end = w.getInsertPoint()
    w.replace(start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

c.bind(ftxt,"<Tab>",toChange)
c.bind(ctxt,"<Tab>",toFind)
c.bind(ftxt,"<Control-Tab>",insertFindTab)
c.bind(ctxt,"<Control-Tab>",insertChangeTab)
#@-node:ekr.20051020120306.16:<< Bind Tab and control-tab >>
#@-node:ekr.20051020120306.15:<< Create the Find and Change panes >>
#@+node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in range(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in range(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&t Change",self.svarDict["script_change"]),
    ("Whole &Word", self.svarDict["whole_word"]),
    ("&Ignore Case",self.svarDict["ignore_case"]),
    ("Wrap &Around",self.svarDict["wrap"]),
    ("&Reverse",    self.svarDict["reverse"]),
    ('Rege&xp',     self.svarDict['pattern_match']),
    ("Mark &Finds", self.svarDict["mark_finds"]),
]

radioLists[1] = [
    (self.svarDict["radio-search-scope"],"&Entire Outline","entire-outline"),
    (self.svarDict["radio-search-scope"],"&Suboutline Only","suboutline-only"),  
    (self.svarDict["radio-search-scope"],"&Node Only","node-only"),
]

checkLists[1] = [
    ("Search &Headline", self.svarDict["search_headline"]),
    ("Search &Body",     self.svarDict["search_body"]),
    ("Mark &Changes",    self.svarDict["mark_changes"]),
]

for i in range(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        c.bind(box.button,"<Button-1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        c.bind(box.button,"<Button-1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@-node:ekr.20051020120306.17:<< Create two columns of radio and checkboxes >>
#@+node:ekr.20051020120306.18:<< Create two columns of buttons >>
# Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)
#@-node:ekr.20051020120306.18:<< Create two columns of buttons >>
#@-node:ekr.20051020120306.13:createFrame (tkFindTab)
#@+node:ekr.20051023181449:createBindings (tkFindTab)
def createBindings (self):

    c = self.c ; k = c.k

    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)

    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        c.outerUpdate()
        return 'break'

    def rightClickCallback(event=None):
        val = k.masterClick3Handler(event, self.onRightClick)
        c.outerUpdate()
        return val

    table = [
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  rightClickCallback),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       resetWrapCallback),
        ('<Return>',    findButtonBindingCallback),
        ("<Escape>",    self.hideTab),
    ]

    # table2 = (
        # ('<Button-2>',  self.frame.OnPaste,  k.masterClickHandler),
    # )

    # if c.config.getBool('allow_middle_button_paste'):
        # table.extend(table2)

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            c.bind(w,event,callback)
#@-node:ekr.20051023181449:createBindings (tkFindTab)
#@+node:bobjack.20080401211408.2:onRightClick
def onRightClick(self, event):

    context_menu = self.c.widget_name(event.widget)
    return g.doHook('rclick-popup', c=self.c, event=event, context_menu=context_menu)
#@-node:bobjack.20080401211408.2:onRightClick
#@+node:ekr.20070212091209:tkFindTab.init
def init (self,c):

    # g.trace('tkFindTab',g.callers())

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.svarDict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@+node:ekr.20070212091209.1:<< set find/change widgets >>
self.find_ctrl.delete(0,"end")
self.change_ctrl.delete(0,"end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@-node:ekr.20070212091209.1:<< set find/change widgets >>
#@+node:ekr.20070212091209.2:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.svarDict[var].get()
    if val:
        self.svarDict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.svarDict["radio-find-type"].set("plain-search")

found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only"),
):
    val = self.svarDict[var].get()
    if val:
        self.svarDict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.svarDict["radio-search-scope"].set("entire-outline")
#@-node:ekr.20070212091209.2:<< set radio buttons from ivars >>
#@-node:ekr.20070212091209:tkFindTab.init
#@-node:ekr.20061212085958.1: Birth
#@+node:ekr.20070212092458:Support for minibufferFind class (tkFindTab)
#@+node:ekr.20070212093026:getOption
def getOption (self,ivar):

    var = self.svarDict.get(ivar)

    if var:
        val = var.get()
        # g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None
#@-node:ekr.20070212093026:getOption
#@+node:ekr.20070212092525:setOption
def setOption (self,ivar,val):

    if ivar in self.intKeys:
        if val is not None:
            var = self.svarDict.get(ivar)
            var.set(val)
            # g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070212092525:setOption
#@+node:ekr.20070212093026.1:toggleOption
def toggleOption (self,ivar):

    if ivar in self.intKeys:
        var = self.svarDict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)
#@-node:ekr.20070212093026.1:toggleOption
#@-node:ekr.20070212092458:Support for minibufferFind class (tkFindTab)
#@-node:ekr.20061212085958:class tkFindTab (findTab)
#@+node:ekr.20051025071455.22:class tkSpellTab
class tkSpellTab:

    @others
#@+node:ekr.20070212132230.1:tkSpellTab.__init__
def __init__ (self,c,handler,tabName):

    self.c = c
    self.handler = handler
    self.tabName = tabName
    self.change_i, change_j = None,None
    self.createFrame()
    self.createBindings()
    self.fillbox([])
    self.positionList = []
#@-node:ekr.20070212132230.1:tkSpellTab.__init__
#@+node:ekr.20051025120920:createBindings
def createBindings (self):

    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.handler.hide),
            ('spell-add',               self.handler.add),
            ('spell-find',              self.handler.find),
            ('spell-ignore',            self.handler.ignore),
            ('spell-change-then-find',  self.handler.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    c.bind(w,shortcut,func)

    for binding,func in (
        ("<Double-1>",  self.onChangeThenFindButton),
        ("<Button-1>",  self.onSelectListBox),
        ("<Map>",       self.onMap),
        # These never get called because focus is always in the body pane!
        # ("<Up>",        self.up),
        # ("<Down>",      self.down),
    ):
        c.bind(self.listBox,binding,func)
#@-node:ekr.20051025120920:createBindings
#@+node:ekr.20070212132230.2:createFrame
def createFrame (self):

    c = self.c ; log = c.frame.log ; tabName = self.tabName
    setFont = False

    parentFrame = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'

    if setFont:
        fontSize = g.choose(sys.platform.startswith('win'),9,14)

    << Create the outer frames >>
    << Create the text and suggestion panes >>
    << Create the spelling buttons >>

    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
#@+node:ekr.20051113090322:<< Create the outer frames >>
self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)
#@-node:ekr.20051113090322:<< Create the outer frames >>
#@+node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')

if setFont:
    self.wordLabel.configure(font=('verdana',fontSize,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
if setFont:
    self.listBox.configure(font=('verdana',fontSize,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')
#@-node:ekr.20051025071455.23:<< Create the text and suggestion panes >>
#@+node:ekr.20051025071455.24:<< Create the spelling buttons >>
# Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = []
if setFont:
    font = ('verdana',fontSize,'normal')
width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    if setFont:
        b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    else:
        b = Tk.Button(frame,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList
#@-node:ekr.20051025071455.24:<< Create the spelling buttons >>
#@-node:ekr.20070212132230.2:createFrame
#@+node:ekr.20051025071455.29:Event handlers
#@+node:ekr.20051025071455.30:onAddButton
def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.handler.add()
    self.change_i, self.change_j = None,None
#@-node:ekr.20051025071455.30:onAddButton
#@+node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.handler.change()
    self.updateButtons()
    self.change_i, self.change_j = None,None


def onChangeThenFindButton(self,event=None):

    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.handler.change():
        self.handler.find()
    self.updateButtons()
    self.change_i, self.change_j = None,None
#@-node:ekr.20051025071455.32:onChangeButton & onChangeThenFindButton
#@+node:ekr.20051025071455.33:onFindButton
def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    c = self.c
    self.handler.find()
    self.updateButtons()
    c.invalidateFocus()
    c.bodyWantsFocusNow()
    self.change_i, self.change_j = None,None
#@-node:ekr.20051025071455.33:onFindButton
#@+node:ekr.20051025071455.34:onHideButton
def onHideButton(self):

    """Handle a click in the Hide button in the Spell tab."""

    self.handler.hide()
    self.change_i, self.change_j = None,None
#@-node:ekr.20051025071455.34:onHideButton
#@+node:ekr.20051025071455.31:onIgnoreButton
def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.handler.ignore()
    self.change_i, self.change_j = None,None
#@nonl
#@-node:ekr.20051025071455.31:onIgnoreButton
#@+node:ekr.20051025071455.49:onMap
def onMap (self, event=None):
    """Respond to a Tk <Map> event."""

    # self.update(show= False, fill= False)
    self.updateButtons()
#@-node:ekr.20051025071455.49:onMap
#@+node:ekr.20051025071455.50:onSelectListBox
def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""

    c = self.c ; w = c.frame.body.bodyCtrl

    if self.change_i is None:
        # A bad hack to get around the fact that only one selection
        # exists at any one time on Linux.
        i,j = w.getSelectionRange()
        # g.trace('setting',i,j)
        self.change_i,self.change_j = i,j

    self.updateButtons()

    return 'continue'
#@-node:ekr.20051025071455.50:onSelectListBox
#@+node:ekr.20080404095546.1:down/up
def down (self,event):

    # Work around an old Python bug.  Convert strings to ints.
    w = self.listBox ; items = w.curselection()
    try: items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        if n + 1 < len(self.positionList):
            w.selection_clear(n)
            w.selection_set(n+1)
    else:
        w.selection_set(0)
    w.focus_force()
    return 'break'


def up (self,event):

    # Work around an old Python bug.  Convert strings to ints.
    w = self.listBox ; items = w.curselection()
    try: items = map(int, items)
    except ValueError: pass

    if items: n = items[0]
    else:     n = 0
    w.selection_clear(n)
    w.selection_set(max(0,n-1))
    w.focus_force()
    return 'break'
#@-node:ekr.20080404095546.1:down/up
#@-node:ekr.20051025071455.29:Event handlers
#@+node:ekr.20051025071455.42:Helpers
#@+node:ekr.20051025071455.43:bringToFront
def bringToFront (self):

    # g.trace('tkSpellTab',g.callers())
    self.c.frame.log.selectTab('Spell')
#@-node:ekr.20051025071455.43:bringToFront
#@+node:ekr.20051025071455.44:fillbox
def fillbox(self, alts, word=None):
    """Update the suggestions listBox in the Check Spelling dialog."""

    self.suggestions = alts

    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in range(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])

    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1)
#@-node:ekr.20051025071455.44:fillbox
#@+node:ekr.20051025071455.48:getSuggestion
def getSuggestion(self):
    """Return the selected suggestion from the listBox."""

    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None
#@-node:ekr.20051025071455.48:getSuggestion
#@+node:ekr.20051025071455.52:updateButtons (spellTab)
def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c ; w = c.frame.body.bodyCtrl

    start, end = w.getSelectionRange()

    # Bug fix: enable buttons when start = 0.
    state = g.choose(self.suggestions and start is not None,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')
#@-node:ekr.20051025071455.52:updateButtons (spellTab)
#@-node:ekr.20051025071455.42:Helpers
#@-node:ekr.20051025071455.22:class tkSpellTab
#@-node:ekr.20031218072017.3897:@@thin leoTkinterFind.py
#@+node:ekr.20031218072017.3939:@@thin leoTkinterFrame.py
@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4
@pagewidth 80

<< imports >>

@others
#@+node:ekr.20041221070525:<< imports >>
import leo.core.leoGlobals as g

import leo.core.leoChapters as leoChapters
import leo.core.leoColor as leoColor
import leo.core.leoFrame as leoFrame
# import leo.core.leoNodes as leoNodes
import leo.core.leoTkinterMenu as leoTkinterMenu
import leo.core.leoTkinterTree as leoTkinterTree

import Tkinter as Tk
import tkFont
import os
# import string
import sys

Pmw = g.importExtension("Pmw",pluginName="leoTkinterFrame.py",verbose=False)
tkColorChooser = g.importExtension('tkColorChooser',pluginName=None,verbose=False)

# import time
#@-node:ekr.20041221070525:<< imports >>
#@+node:ekr.20031218072017.3996:class leoTkinterBody
class leoTkinterBody (leoFrame.leoBody):

    """A class that represents the body pane of a Tkinter window."""

    @others
#@+node:ekr.20031218072017.3997: Birth & death
#@+node:ekr.20031218072017.2182:tkBody. __init__
def __init__ (self,frame,parentFrame):

    # g.trace("leoTkinterBody")

    # Call the base class constructor.
    leoFrame.leoBody.__init__(self,frame,parentFrame)

    c = self.c ; p = c.currentPosition()
    self.editor_name = None
    self.editor_v = None

    self.trace_onBodyChanged = c.config.getBool('trace_onBodyChanged')
    self.bodyCtrl = self.createControl(parentFrame,p)
    self.colorizer = leoColor.colorizer(c)
#@-node:ekr.20031218072017.2182:tkBody. __init__
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,w=None):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''

    frame = self.frame ; c = self.c ; k = c.k
    if not w: w = self.bodyCtrl

    c.bind(w,'<Key>', k.masterKeyHandler)

    def onFocusOut(event,c=c):
        # This interferes with inserting new nodes.
            # c.k.setDefaultInputState()
        self.setEditorColors(
            bg=c.k.unselected_body_bg_color,
            fg=c.k.unselected_body_fg_color)
        # This is required, for example, when typing Alt-Shift-anyArrow in insert mode.
        # But we suppress coloring in the widget.
        oldState = k.unboundKeyAction
        k.unboundKeyAction = k.defaultUnboundKeyAction
        c.k.showStateAndMode(w=g.app.gui.get_focus(c))
        k.unboundKeyAction = oldState

    def onFocusIn(event,c=c):
        # g.trace('callback')
        c.k.setDefaultInputState()
        c.k.showStateAndMode()  # TNB - fix color when window manager returns focus to Leo

    c.bind(w,'<FocusOut>', onFocusOut)
    c.bind(w,'<FocusIn>', onFocusIn)

    table = [
        ('<Button-1>',  frame.OnBodyClick,          k.masterClickHandler),
        ('<Button-3>',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('<Double-1>',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('<Double-3>',  None,                       k.masterDoubleClick3Handler),
        ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    ]

    table2 = (
        ('<Button-2>',  frame.OnPaste,              k.masterClickHandler),
    )

    if c.config.getBool('allow_middle_button_paste'):
        table.extend(table2)

    for kind,func,handler in table:
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        c.bind(w,kind,bodyClickCallback)
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.3998:tkBody.createControl
def createControl (self,parentFrame,p):

    c = self.c

    # New in 4.4.1: make the parent frame a Pmw.PanedWidget.
    self.numberOfEditors = 1 ; name = '1'
    self.totalNumberOfEditors = 1

    orient = c.config.getString('editor_orientation') or 'horizontal'
    if orient not in ('horizontal','vertical'): orient = 'horizontal'

    self.pb = pb = Pmw.PanedWidget(parentFrame,orient=orient)
    parentFrame = pb.add(name)
    pb.pack(expand=1,fill='both') # Must be done after the first page created.

    w = self.createTextWidget(parentFrame,p,name)
    self.editorWidgets[name] = w

    return w
#@-node:ekr.20031218072017.3998:tkBody.createControl
#@+node:ekr.20060528100747.3:tkBody.createTextWidget
def createTextWidget (self,parentFrame,p,name):

    c = self.c

    parentFrame.configure(bg='LightSteelBlue1')

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")

    # Setgrid=1 cause severe problems with the font panel.
    body = w = leoTkTextWidget (parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)

    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')

    def yscrollCallback(x,y,bodyBar=bodyBar,w=w):
        # g.trace(x,y,g.callers())
        if hasattr(w,'leo_scrollBarSpot'):
            w.leo_scrollBarSpot = (x,y)
        return bodyBar.set(x,y)

    body['yscrollcommand'] = yscrollCallback # bodyBar.set

    bodyBar['command'] =  body.yview
    bodyBar.pack(side="right", fill="y")

    # Always create the horizontal bar.
    bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview

    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")

    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)

    # Inject ivars
    if name == '1':
        w.leo_p = w.leo_v = None # Will be set when the second editor is created.
    else:
        w.leo_p = p.copy()
        w.leo_v = w.leo_p.v

    w.leo_active = True
    # New in Leo 4.4.4 final: inject the scrollbar items into the text widget.
    w.leo_bodyBar = bodyBar # 2007/10/31
    w.leo_bodyXBar = bodyXBar # 2007/10/31
    w.leo_chapter = None
    w.leo_frame = parentFrame
    w.leo_name = name
    w.leo_label = None
    w.leo_label_s = None
    w.leo_scrollBarSpot = None
    w.leo_insertSpot = None
    w.leo_selection = None

    return w
#@-node:ekr.20060528100747.3:tkBody.createTextWidget
#@-node:ekr.20031218072017.3997: Birth & death
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self,w=None):

    c = self.c
    if w is None: w = self.bodyCtrl

    bg = c.config.getColor("body_text_background_color") or 'white'
    # g.trace(id(w),bg)

    try: w.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()

    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: w.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: w.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()

    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: w.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: w.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()

    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: w.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@+node:ekr.20031218072017.2183:tkBody.setFontFromConfig
def setFontFromConfig (self,w=None):

    c = self.c

    if not w: w = self.bodyCtrl

    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    w.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@-node:ekr.20031218072017.2183:tkBody.setFontFromConfig
#@+node:ekr.20031218072017.4003:Focus (tkBody)
def hasFocus (self):

    return self.bodyCtrl == self.frame.top.focus_displayof()

def setFocus (self):

    self.c.widgetWantsFocus(self.bodyCtrl)
#@-node:ekr.20031218072017.4003:Focus (tkBody)
#@+node:ekr.20031218072017.4000:Tk bindings (tkBody)
#@+node:ekr.20031218072017.4002:Color tags (Tk spelling) (tkBody)
def tag_add (self,tagName,index1,index2):
    self.bodyCtrl.tag_add(tagName,index1,index2)

def tag_bind (self,tagName,event,callback):
    self.c.tag_bind(self.bodyCtrl,tagName,event,callback)

def tag_configure (self,colorName,**keys):
    self.bodyCtrl.tag_configure(colorName,keys)

def tag_delete(self,tagName):
    self.bodyCtrl.tag_delete(tagName)

def tag_names(self,*args): # New in Leo 4.4.1.
    return self.bodyCtrl.tag_names(*args)

def tag_remove (self,tagName,index1,index2):
    return self.bodyCtrl.tag_remove(tagName,index1,index2)
#@-node:ekr.20031218072017.4002:Color tags (Tk spelling) (tkBody)
#@+node:ekr.20031218072017.2184:Configuration (Tk spelling) (tkBody)
def cget(self,*args,**keys):

    val = self.bodyCtrl.cget(*args,**keys)

    if g.app.trace:
        g.trace(val,args,keys)

    return val

def configure (self,*args,**keys):

    # g.trace(args,keys)

    return self.bodyCtrl.configure(*args,**keys)
#@-node:ekr.20031218072017.2184:Configuration (Tk spelling) (tkBody)
#@+node:ekr.20031218072017.4004:Height & width
# def getBodyPaneHeight (self):

    # return self.bodyCtrl.winfo_height()

# def getBodyPaneWidth (self):

    # return self.bodyCtrl.winfo_width()
#@-node:ekr.20031218072017.4004:Height & width
#@+node:ekr.20031218072017.4005:Idle time...
def scheduleIdleTimeRoutine (self,function,*args,**keys):

    if not g.app.unitTesting:
        self.bodyCtrl.after_idle(function,*args,**keys)
#@-node:ekr.20031218072017.4005:Idle time...
#@+node:ekr.20031218072017.4017:Menus (tkBody) (May cause problems)
def bind (self,*args,**keys):

    c = self.c
    return self.bodyCtrl.bind(*args,**keys)
#@-node:ekr.20031218072017.4017:Menus (tkBody) (May cause problems)
#@-node:ekr.20031218072017.4000:Tk bindings (tkBody)
#@+node:ekr.20070424053629.2:Editors (tkBody)
#@+node:ekr.20070424054235:createEditorFrame
def createEditorFrame (self,pane):

    f = Tk.Frame(pane)
    f.pack(side='top',expand=1,fill='both')
    return f
#@-node:ekr.20070424054235:createEditorFrame
#@+node:ekr.20070424054810:packEditorLabelWidget
def packEditorLabelWidget (self,w):

    '''Create a Tk label widget.'''

    if not hasattr(w,'leo_label') or not w.leo_label:
        # g.trace('w.leo_frame',id(w.leo_frame))
        w.pack_forget()
        w.leo_label = Tk.Label(w.leo_frame)
        w.leo_label.pack(side='top')
        w.pack(expand=1,fill='both')
#@nonl
#@-node:ekr.20070424054810:packEditorLabelWidget
#@+node:ekr.20060606090542:setEditorColors
def setEditorColors (self,bg,fg):

    c = self.c ; d = self.editorWidgets

    for key in d:
        w2 = d.get(key)
        # g.trace(id(w2),bg,fg)
        try:
            w2.configure(bg=bg,fg=fg)
        except Exception:
            g.es_exception()
#@-node:ekr.20060606090542:setEditorColors
#@-node:ekr.20070424053629.2:Editors (tkBody)
#@-node:ekr.20031218072017.3996:class leoTkinterBody
#@+node:ekr.20031218072017.3940:class leoTkinterFrame
class leoTkinterFrame (leoFrame.leoFrame):

    """A class that represents a Leo window rendered in Tk/tkinter."""

    @others
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBarClass = self.tkIconBarClass
    self.statusLineClass = self.tkStatusLineClass
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >> (removed frame.bodyCtrl ivar)
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
# self.treeBar = None # Replaced by injected frame.canvas.leo_treeBar.

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >> (removed frame.bodyCtrl ivar)
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20031218072017.2176:tkFrame.finishCreate & helpers
def finishCreate (self,c):

    f = self ; f.c = c
    # g.trace('tkFrame','c',c,g.callers())

    self.bigTree           = c.config.getBool('big_outline_pane')
    self.trace_status_line = c.config.getBool('trace_status_line')
    self.use_chapters      = c.config.getBool('use_chapters')
    self.use_chapter_tabs  = c.config.getBool('use_chapter_tabs')

    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBar()
    f.createLeoSplitters(f.outerFrame)
    f.createSplitterComponents()
    f.createStatusLine()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()

    # f.enableTclTraces()
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.

    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)

    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    c.bind(f.top,"<Button-1>", f.OnActivateLeoEvent)

    c.bind(f.top,"<Control-KeyPress>",f.OnControlKeyDown)
    c.bind(f.top,"<Control-KeyRelease>",f.OnControlKeyUp)

    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    # c.bind(f.top,"<Activate>",f.OnActivateLeoEvent)
    # c.bind(f.top,"<Deactivate>",f.OnDeactivateLeoEvent)

    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009045208:createSplitterComponents (tkFrame) (removed frame.bodyCtrl ivar)
def createSplitterComponents (self):

    f = self ; c = f.c

    # Create the canvas, tree, log and body.
    if f.use_chapters:
        c.chapterController = cc = leoChapters.chapterController(c)

    # split1.pane1 is the secondary splitter.

    if self.bigTree: # Put outline in the main splitter.
        if self.use_chapters and self.use_chapter_tabs:
            cc.tt = leoTkinterTreeTab(c,f.split1Pane2,cc)
        f.canvas = f.createCanvas(f.split1Pane1)
        f.tree  = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
        f.log   = leoTkinterLog(f,f.split2Pane2)
        f.body  = leoTkinterBody(f,f.split2Pane1)
    else:
        if self.use_chapters and self.use_chapter_tabs:
            cc.tt = leoTkinterTreeTab(c,f.split2Pane1,cc)
        f.canvas = f.createCanvas(f.split2Pane1)
        f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
        f.log    = leoTkinterLog(f,f.split2Pane2)
        f.body   = leoTkinterBody(f,f.split1Pane2)

    # Yes, this an "official" ivar: this is a kludge.
    # f.bodyCtrl = f.body.bodyCtrl

    # Configure.
    f.setTabWidth(c.tab_width)
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@-node:ekr.20051009045208:createSplitterComponents (tkFrame) (removed frame.bodyCtrl ivar)
#@+node:ekr.20051121092320:f.enableTclTraces
def enableTclTraces (self):

    c = self.c
    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("<FocusIn>")
    # c.frame.bar1.unbind_all("<FocusOut>")

    # Any widget would do:
    w = c.frame.bar1
    if True:
        def focusIn (event):
            g.pr("Focus in  %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        def focusOut (event):
            g.pr("Focus out %s (%s)" % (
                event.widget,event.widget.winfo_class()))

        w.bind_all("<FocusIn>", focusIn)
        w.bind_all("<FocusOut>", focusOut)
    else:
        def tracewidget(event):
            g.trace('enabling widget trace')
            Pmw.tracetk(event.widget, 1)

        def untracewidget(event):
            g.trace('disabling widget trace')
            Pmw.tracetk(event.widget,0)

        w.bind_all("<Control-1>", tracewidget)
        w.bind_all("<Control-Shift-1>", untracewidget)
#@-node:ekr.20051121092320:f.enableTclTraces
#@-node:ekr.20031218072017.2176:tkFrame.finishCreate & helpers
#@+node:ekr.20031218072017.3944:tkFrame.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):

    c = self.c

    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)
    self.setCanvasColorFromConfig(canvas)

    return canvas
#@nonl
#@+node:ekr.20041221071131.1:f.createTkTreeCanvas & callbacks
def createTkTreeCanvas (self,parentFrame,scrolls,pack):

    frame = self ; c = frame.c

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    treeBar = Tk.Scrollbar(parentFrame,name="treeBar")

    # New in Leo 4.4.3 b1: inject the ivar into the canvas.
    canvas.leo_treeBar = treeBar

    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        c.bind(canvas,"<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>

    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")

    if pack:
        canvas.pack(expand=1,fill="both")

    c.bind(canvas,"<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        c.bind(canvas,"<MouseWheel>", frame.OnMouseWheel)

    # g.print_bindings("canvas",canvas)
    return canvas
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

c.bind2(canvas,"<ButtonPress>",mapWheel,add=1)
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20031218072017.998:Scrolling callbacks (tkFrame)
def setCallback (self,*args,**keys):

    """Callback to adjust the scrollbar.

    Args is a tuple of two floats describing the fraction of the visible area."""

    #g.trace(self.tree.redrawCount,args,g.callers())
    self.canvas.leo_treeBar.set(*args,**keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)

def yviewCallback (self,*args,**keys):

    """Tell the canvas to scroll"""

    #g.trace(vyiewCallback,args,keys,g.callers())

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    self.canvas.yview(*args,**keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (tkFrame)
#@-node:ekr.20041221071131.1:f.createTkTreeCanvas & callbacks
#@+node:ekr.20070327094252:f.setCanvasColorFromConfig
def setCanvasColorFromConfig (self,canvas):

    c = self.c

    bg = c.config.getColor("outline_pane_background_color") or 'white'

    try:
        canvas.configure(bg=bg)
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()
#@-node:ekr.20070327094252:f.setCanvasColorFromConfig
#@-node:ekr.20031218072017.3944:tkFrame.createCanvas & helpers
#@+node:ekr.20041221123325:tkFrame.createLeoSplitters & helpers
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these
invariants. So most of this code is specialized for Leo's window. OTOH, creating
a single splitter window would be much easier than this code.
@c

def createLeoSplitters (self,parentFrame):

    # Splitter 1 is the main splitter.
    f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
        parentFrame,self.splitVerticalFlag,'splitter1')

    self.f1,self.bar1 = f1,bar1
    self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

    # ** new **
    split2parent = g.choose(self.bigTree,split1Pane2,split1Pane1)

    # Splitter 2 is the secondary splitter.
    f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
        # split1Pane1,not self.splitVerticalFlag,'splitter2')
        split2parent,not self.splitVerticalFlag,'splitter2')

    self.f2,self.bar2 = f2,bar2
    self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):

    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)

    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    c = self.c

    if verticalFlag == self.splitVerticalFlag:
        c.bind(bar,"<B1-Motion>", self.onDragMainSplitBar)

    else:
        c.bind(bar,"<B1-Motion>", self.onDragSecondarySplitBar)
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    # if self.bigTree:
        # pane1,pane2 = pane2,pane1

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    # if self.bigTree:
        # pane1,pane2 = pane2,pane1

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@-node:ekr.20031218072017.3952:placeSplitter
#@-node:ekr.20041221123325:tkFrame.createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the tkFrame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # g.printGcAll()

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    if c.chapterController: # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.chapterController)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)

    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)

#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.all_positions_with_unique_vnodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if key not in tDict:
            tDict[key] = p.v.t

for key in tDict:
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""

    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf (tkFrame)
def destroySelf (self):

    # g.trace(self)

    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c

    # Indicate that the commander is no longer valid.
    c.exists = False

    # New in Leo 4.4.8: Finish all window tasks before killing the window.
    top.update()

    # g.trace(self)

    # Important: this destroys all the objects of the commander too.
    self.destroyAllObjects()

    # New in Leo 4.4.8: Finish all window tasks before killing the window.
    top.update()

    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()
#@-node:ekr.20031218072017.1974:destroySelf (tkFrame)
#@-node:ekr.20031218072017.3964:Destroying the tkFrame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20041223104933:class tkStatusLineClass (tkFrame)
class tkStatusLineClass:

    '''A class representing the status line.'''

    @others
#@+node:ekr.20031218072017.3961:ctor
def __init__ (self,c,parentFrame):

    self.c = c
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0, fcol 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)

    bg = self.statusFrame.cget("background")
    self.textWidget = w = g.app.gui.bodyTextWidget(
        self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    c.bind(w,"<Button-1>", self.onActivate)
    self.show()

    c.frame.statusFrame = self.statusFrame
    c.frame.statusLabel = self.labelWidget
    c.frame.statusText  = self.textWidget
#@-node:ekr.20031218072017.3961:ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):

    w = self.textWidget
    if not w: return

    w.configure(state="normal")
    w.delete(0,"end")
    w.configure(state="disabled")
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):

    c = self.c ; w = self.textWidget
    if w:
        if not background:
            background = self.statusFrame.cget("background")
        w.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()

def enable (self,background="white"):

    # g.trace()
    c = self.c ; w = self.textWidget
    if w:
        w.configure(state="normal",background=background)
        c.widgetWantsFocus(w)
    self.enabled = True

def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):

    w = self.textWidget
    if w:
        return w.getAllText()
    else:
        return ""
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):

    return self.statusFrame
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):

    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):

    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

show = pack
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
def put(self,s,color=None):

    # g.trace('tkStatusLine',self.textWidget,s)

    w = self.textWidget
    if not w:
        g.trace('tkStatusLine','***** disabled')
        return

    w.configure(state="normal")
    w.insert("end",s)

    if color:
        if color not in self.colorTags:
            self.colorTags.append(color)
            w.tag_config(color,foreground=color)
        w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        w.tag_config("black",foreground="black")
        w.tag_add("black","end")

    w.configure(state="disabled")
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame:statusLineClass)
#@+node:ekr.20071215114822:setBindings (tkStatusLine)
def setBindings (self):

    c = self.c ; k = c.keyHandler ; w = self.textWidget

    c.bind(w,'<Key>',k.masterKeyHandler)

    k.completeAllBindingsForWidget(w)
#@-node:ekr.20071215114822:setBindings (tkStatusLine)
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):

    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update (statusLine)
def update (self):

    c = self.c ; bodyCtrl = c.frame.body.bodyCtrl

    if g.app.killed or not self.isVisible:
        return

    s = bodyCtrl.getAllText()    
    index = bodyCtrl.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,index)
    if col > 0:
        s2 = s[index-col:index]
        s2 = g.toUnicode(s2,g.app.tkEncoding)
        col = g.computeWidth (s2,c.tab_width)
    p = c.currentPosition()
    fcol = col + p.textOffset()

    # Important: this does not change the focus because labels never get focus.
    self.labelWidget.configure(text="line %d, col %d, fcol %d" % (row,col,fcol))
    self.lastRow = row
    self.lastCol = col
    self.lastFcol = fcol
#@-node:ekr.20031218072017.1733:update (statusLine)
#@-node:ekr.20041223104933:class tkStatusLineClass (tkFrame)
#@+node:ekr.20041223102225:class tkIconBarClass
class tkIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
#@+node:ekr.20041223102225.1: ctor
def __init__ (self,c,parentFrame):

    self.c = c

    self.buttons = {}

    # Create a parent frame that will never be unpacked.
    # This allows us to pack and unpack the container frame without it moving.
    self.iconFrameParentFrame = Tk.Frame(parentFrame)
    self.iconFrameParentFrame.pack(fill="x",pady=0)

    # Create a container frame to hold individual row frames.
    # We hide all icons by doing pack_forget on this one frame.
    self.iconFrameContainerFrame = Tk.Frame(self.iconFrameParentFrame)
        # Packed in self.show()

    self.addRow()
    self.font = None
    self.parentFrame = parentFrame
    self.visible = False
    self.widgets_per_row = c.config.getInt('icon_bar_widgets_per_row') or 10
    self.show() # pack the container frame.
#@-node:ekr.20041223102225.1: ctor
#@+node:ekr.20031218072017.3958:add
def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    self.addRowIfNeeded()
    f = self.iconFrame # Bind this after possibly creating a new row.

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback(n=g.app.iconWidgetCount):
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        << create a picture >>
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
#@+node:ekr.20031218072017.3959:<< create a picture >>
try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
#@-node:ekr.20031218072017.3959:<< create a picture >>
#@-node:ekr.20031218072017.3958:add
#@+node:ekr.20080930072519.2:addRow
def addRow(self,height=None):

    if height is None:
        height = '5m'

    w = Tk.Frame(self.iconFrameContainerFrame,height=height,bd=2,relief="groove")
    w.pack(fill="x",pady=2)
    self.iconFrame = w
    self.c.frame.iconFrame = w
    return w
#@-node:ekr.20080930072519.2:addRow
#@+node:ekr.20080930072519.5:addRowIfNeeded
def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    try:
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 0

    if n >= self.widgets_per_row:
        g.app.iconWidgetCount = 0
        self.addRow()

    g.app.iconWidgetCount += 1
#@-node:ekr.20080930072519.5:addRowIfNeeded
#@+node:ekr.20080930072519.6:addWidget
def addWidget (self,w):

    self.addRowIfNeeded()
    w.pack(side="left", fill="none")


#@-node:ekr.20080930072519.6:addWidget
#@+node:ekr.20031218072017.3956:clear
def clear(self):

    """Destroy all the widgets in the icon bar"""

    f = self.iconFrameContainerFrame

    for slave in f.pack_slaves():
        slave.pack_forget()
    f.pack_forget()

    self.addRow(height='0m')

    self.visible = False

    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
#@-node:ekr.20031218072017.3956:clear
#@+node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
def deleteButton (self,w):

    w.pack_forget()
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
#@-node:ekr.20061213091114.1:deleteButton (new in Leo 4.4.3)
#@+node:ekr.20041223114821:getFrame & getNewFrame
def getFrame (self):

    return self.iconFrame

def getNewFrame (self):

    # Pre-check that there is room in the row, but don't bump the count.
    self.addRowIfNeeded()
    g.app.iconWidgetCount -= 1

    # Allocate the frame in the possibly new row.
    frame = Tk.Frame(self.iconFrame)
    return frame

#@-node:ekr.20041223114821:getFrame & getNewFrame
#@+node:ekr.20041223102225.2:pack (show)
def pack (self):

    """Show the icon bar by repacking it"""

    if not self.visible:
        self.visible = True
        self.iconFrameContainerFrame.pack(fill='x',pady=2)

show = pack
#@-node:ekr.20041223102225.2:pack (show)
#@+node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
def setCommandForButton(self,b,command):

    b.configure(command=command)
#@-node:ekr.20061213092103:setCommandForButton (new in Leo 4.4.3)
#@+node:ekr.20031218072017.3955:unpack (hide)
def unpack (self):

    """Hide the icon bar by unpacking it."""

    if self.visible:
        self.visible = False
        w = self.iconFrameContainerFrame
        w.pack_forget()

hide = unpack
#@-node:ekr.20031218072017.3955:unpack (hide)
#@-node:ekr.20041223102225:class tkIconBarClass
#@+node:ekr.20051014154752:Minibuffer methods (tkFrame)
#@+node:ekr.20060203115311:showMinibuffer
def showMinibuffer (self):

    '''Make the minibuffer visible.'''

    frame = self

    if not frame.minibufferVisible:
        frame.minibufferFrame.pack(side='bottom',fill='x')
        frame.minibufferVisible = True
#@-node:ekr.20060203115311:showMinibuffer
#@+node:ekr.20060203115311.1:hideMinibuffer
def hideMinibuffer (self):

    '''Hide the minibuffer.'''

    frame = self
    if frame.minibufferVisible:
        frame.minibufferFrame.pack_forget()
        frame.minibufferVisible = False
#@-node:ekr.20060203115311.1:hideMinibuffer
#@+node:ekr.20050920094212:f.createMiniBufferWidget
def createMiniBufferWidget (self):

    '''Create the minbuffer below the status line.'''

    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')

    label = g.app.gui.plainTextWidget(
        f,height=1,relief='groove',background='lightgrey',name='minibuffer')
    label.pack(side='left',fill='x',expand=1,padx=2,pady=1)

    frame.minibufferVisible = c.showMinibuffer

    return label
#@-node:ekr.20050920094212:f.createMiniBufferWidget
#@+node:ekr.20060203114017:f.setMinibufferBindings
def setMinibufferBindings (self):

    '''Create bindings for the minibuffer..'''

    f = self ; c = f.c ; k = c.k ; w = f.miniBufferWidget

    table = [
        ('<Key>',           k.masterKeyHandler),
        ('<Button-1>',      k.masterClickHandler),
        ('<Button-3>',      k.masterClick3Handler),
        ('<Double-1>',      k.masterDoubleClickHandler),
        ('<Double-3>',      k.masterDoubleClick3Handler),
    ]

    table2 = (
        ('<Button-2>',      k.masterClickHandler),
    )

    if c.config.getBool('allow_middle_button_paste'):
        table.extend(table2)

    for kind,callback in table:
        c.bind(w,kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            c.bind(w,"<Button-2>",f.OnPaste)
#@-node:ekr.20060203114017:f.setMinibufferBindings
#@-node:ekr.20051014154752:Minibuffer methods (tkFrame)
#@+node:ekr.20031218072017.3967:Configuration (tkFrame)
#@+node:ekr.20031218072017.3968:configureBar (tkFrame)
def configureBar (self,bar,verticalFlag):

    c = self.c

    # Get configuration settings.
    w = c.config.getInt("split_bar_width")
    if not w or w < 1: w = 7
    relief = c.config.get("split_bar_relief","relief")
    if not relief: relief = "flat"
    color = c.config.getColor("split_bar_color")
    if not color: color = "LightSteelBlue2"

    try:
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(relief=relief,height=w,bg=color,cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(relief=relief,width=w,bg=color,cursor="sb_h_double_arrow")
    except: # Could be a user error. Use all defaults
        g.es("exception in user configuration for splitbar")
        g.es_exception()
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(height=7,cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(width=7,cursor="sb_h_double_arrow")
#@-node:ekr.20031218072017.3968:configureBar (tkFrame)
#@+node:ekr.20031218072017.3969:configureBarsFromConfig (tkFrame)
def configureBarsFromConfig (self):

    c = self.c

    w = c.config.getInt("split_bar_width")
    if not w or w < 1: w = 7

    relief = c.config.get("split_bar_relief","relief")
    if not relief or relief == "": relief = "flat"

    color = c.config.getColor("split_bar_color")
    if not color or color == "": color = "LightSteelBlue2"

    if self.splitVerticalFlag:
        bar1,bar2=self.bar1,self.bar2
    else:
        bar1,bar2=self.bar2,self.bar1

    try:
        bar1.configure(relief=relief,height=w,bg=color)
        bar2.configure(relief=relief,width=w,bg=color)
    except: # Could be a user error.
        g.es("exception in user configuration for splitbar")
        g.es_exception()
#@-node:ekr.20031218072017.3969:configureBarsFromConfig (tkFrame)
#@+node:ekr.20031218072017.2246:reconfigureFromConfig (tkFrame)
def reconfigureFromConfig (self):

    frame = self ; c = frame.c

    frame.tree.setFontFromConfig()
    frame.configureBarsFromConfig()

    frame.body.setFontFromConfig()
    frame.body.setColorFromConfig()

    frame.setTabWidth(c.tab_width)
    frame.log.setFontFromConfig()
    frame.log.setColorFromConfig()

    c.redraw_now()
#@-node:ekr.20031218072017.2246:reconfigureFromConfig (tkFrame)
#@+node:ekr.20031218072017.1625:setInitialWindowGeometry (tkFrame)
def setInitialWindowGeometry(self):

    """Set the position and size of the frame to config params."""

    c = self.c

    h = c.config.getInt("initial_window_height") or 500
    w = c.config.getInt("initial_window_width") or 600
    x = c.config.getInt("initial_window_left") or 10
    y = c.config.getInt("initial_window_top") or 10

    if h and w and x and y:
        self.setTopGeometry(w,h,x,y)
#@-node:ekr.20031218072017.1625:setInitialWindowGeometry (tkFrame)
#@+node:ekr.20031218072017.722:setTabWidth (tkFrame)
def setTabWidth (self, w):

    try: # This can fail when called from scripts
        # Use the present font for computations.
        font = self.body.bodyCtrl.cget("font") # 2007/10/27
        root = g.app.root # 4/3/03: must specify root so idle window will work properly.
        font = tkFont.Font(root=root,font=font)
        tabw = font.measure(" " * abs(w)) # 7/2/02
        self.body.bodyCtrl.configure(tabs=tabw)
        self.tab_width = w
        # g.trace(w,tabw)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.722:setTabWidth (tkFrame)
#@+node:ekr.20031218072017.1540:setWrap (tkFrame)
def setWrap (self,p):

    c = self.c
    theDict = c.scanAllDirectives(p)
    if not theDict: return

    wrap = theDict.get("wrap")
    if self.body.wrapState == wrap: return

    self.body.wrapState = wrap
    w = self.body.bodyCtrl

    # g.trace(wrap)
    if wrap:
        w.configure(wrap="word") # 2007/10/25
        w.leo_bodyXBar.pack_forget() # 2007/10/31
    else:
        w.configure(wrap="none")
        # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
        w.pack_forget()  # 2007/10/25
        w.leo_bodyXBar.pack(side="bottom", fill="x") # 2007/10/31
        w.pack(expand=1,fill="both")  # 2007/10/25
#@-node:ekr.20031218072017.1540:setWrap (tkFrame)
#@+node:ekr.20031218072017.2307:setTopGeometry (tkFrame)
def setTopGeometry(self,w,h,x,y,adjustSize=True):

    # Put the top-left corner on the screen.
    x = max(10,x) ; y = max(10,y)

    if adjustSize:
        top = self.top
        sw = top.winfo_screenwidth()
        sh = top.winfo_screenheight()

        # Adjust the size so the whole window fits on the screen.
        w = min(sw-10,w)
        h = min(sh-10,h)

        # Adjust position so the whole window fits on the screen.
        if x + w > sw: x = 10
        if y + h > sh: y = 10

    geom = "%dx%d%+d%+d" % (w,h,x,y)

    self.top.geometry(geom)
#@-node:ekr.20031218072017.2307:setTopGeometry (tkFrame)
#@+node:ekr.20031218072017.3970:reconfigurePanes (use config bar_width) (tkFrame)
def reconfigurePanes (self):

    c = self.c

    border = c.config.getInt('additional_body_text_border')
    if border == None: border = 0

    # The body pane needs a _much_ bigger border when tiling horizontally.
    border = g.choose(self.splitVerticalFlag,2+border,6+border)
    self.body.bodyCtrl.configure(bd=border) # 2007/10/25

    # The log pane needs a slightly bigger border when tiling vertically.
    border = g.choose(self.splitVerticalFlag,4,2) 
    self.log.configureBorder(border)
#@-node:ekr.20031218072017.3970:reconfigurePanes (use config bar_width) (tkFrame)
#@+node:ekr.20060915124834:resizePanesToRatio (tkFrame)
def resizePanesToRatio(self,ratio,ratio2):

    # g.trace(ratio,ratio2,g.callers())

    self.divideLeoSplitter(self.splitVerticalFlag,ratio)
    self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@-node:ekr.20060915124834:resizePanesToRatio (tkFrame)
#@-node:ekr.20031218072017.3967:Configuration (tkFrame)
#@+node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
# Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):

    f = self ; c = f.c

    if c.inCommand:
        # g.trace('requesting window close')
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
#@-node:ekr.20031218072017.3972:frame.OnCloseLeoEvent
#@+node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
def OnControlKeyDown (self,event=None):

    self.controlKeyIsDown = True

def OnControlKeyUp (self,event=None):

    self.controlKeyIsDown = False
#@-node:ekr.20031218072017.3973:frame.OnControlKeyUp/Down
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):

    try:
        frame = self ; c = frame.c
        c.setLog()
        w = c.get_focus()
        if w != c.frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        c.bodyWantsFocusNow()
    except:
        g.es_event_exception("activate body")

    return 'break'
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):

    '''Handle a click anywhere in the Leo window.'''

    self.c.setLog()

def OnDeactivateLeoEvent(self,event=None):

    pass # This causes problems on the Mac.
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20031218072017.3976:OnActivateTree
def OnActivateTree (self,event=None):

    try:
        frame = self ; c = frame.c
        c.setLog()

        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            c.bodyWantsFocus()

    except:
        g.es_event_exception("activate tree")
#@-node:ekr.20031218072017.3976:OnActivateTree
#@+node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
def OnBodyClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyclick1",c=c,p=p,v=p,event=event):
            self.OnActivateBody(event=event)
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if not g.doHook("bodyrclick1",c=c,p=p,v=p,event=event):
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodyrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.3977:OnBodyClick, OnBodyRClick (Events)
#@+node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; p = c.currentPosition()
        if event and not g.doHook("bodydclick1",c=c,p=p,v=p,event=event):
            c.editCommands.extendToWord(event) # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.bodyCtrl)
        g.doHook("bodydclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("bodydclick")

    return "break" # Restore this to handle proper double-click logic.
#@-node:ekr.20031218072017.3978:OnBodyDoubleClick (Events)
#@+node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
# Contributed by Tomaz Ficko.  This works on some systems.
# On XP it causes a crash in tcl83.dll.  Clearly a Tk bug.

def OnMouseWheel(self, event=None):

    try:
        if event.delta < 1:
            self.canvas.yview(Tk.SCROLL, 1, Tk.UNITS)
        else:
            self.canvas.yview(Tk.SCROLL, -1, Tk.UNITS)
    except:
        g.es_event_exception("scroll wheel")

    return "break"
#@-node:ekr.20031218072017.1803:OnMouseWheel (Tomaz Ficko)
#@-node:ekr.20031218072017.3971:Event handlers (tkFrame)
#@+node:ekr.20031218072017.3979:Gui-dependent commands
#@+node:ekr.20060209110128:Minibuffer commands... (tkFrame)

#@+node:ekr.20060209110128.1:contractPane
def contractPane (self,event=None):

    '''Contract the selected pane.'''

    f = self ; c = f.c
    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.contractBodyPane()
    elif wname.startswith('log'):
        f.contractLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.contractOutlinePane()
#@-node:ekr.20060209110128.1:contractPane
#@+node:ekr.20060209110128.2:expandPane
def expandPane (self,event=None):

    '''Expand the selected pane.'''

    f = self ; c = f.c

    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.expandBodyPane()
    elif wname.startswith('log'):
        f.expandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.expandOutlinePane()
#@-node:ekr.20060209110128.2:expandPane
#@+node:ekr.20060210123852:fullyExpandPane
def fullyExpandPane (self,event=None):

    '''Fully expand the selected pane.'''

    f = self ; c = f.c

    w = c.get_requested_focus()
    wname = c.widget_name(w)

    # g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.fullyExpandBodyPane()
    elif wname.startswith('log'):
        f.fullyExpandLogPane()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.fullyExpandOutlinePane()
#@-node:ekr.20060210123852:fullyExpandPane
#@+node:ekr.20060209143933:hidePane
def hidePane (self,event=None):

    '''Completely contract the selected pane.'''

    f = self ; c = f.c

    w = c.get_requested_focus()
    wname = c.widget_name(w)

    g.trace(wname)
    if not w: return

    if wname.startswith('body'):
        f.hideBodyPane()
        c.treeWantsFocusNow()
    elif wname.startswith('log'):
        f.hideLogPane()
        c.bodyWantsFocusNow()
    elif wname.startswith('head') or wname.startswith('canvas'):
        f.hideOutlinePane()
        c.bodyWantsFocusNow()
#@-node:ekr.20060209143933:hidePane
#@+node:ekr.20060209110936:expand/contract/hide...Pane
@ The first arg to divideLeoSplitter means the following:

    f.splitVerticalFlag: use the primary   (tree/body) ratio.
not f.splitVerticalFlag: use the secondary (tree/log) ratio.
@c

def contractBodyPane (self,event=None):
    '''Contract the body pane.'''
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def contractLogPane (self,event=None):
    '''Contract the log pane.'''
    f = self ; r = min(1.0,f.ratio+0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def contractOutlinePane (self,event=None):
    '''Contract the outline pane.'''
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(f.splitVerticalFlag,r)

def expandBodyPane (self,event=None):
    '''Expand the body pane.'''
    self.contractOutlinePane()

def expandLogPane(self,event=None):
    '''Expand the log pane.'''
    f = self ; r = max(0.0,f.ratio-0.1)
    f.divideLeoSplitter(not f.splitVerticalFlag,r)

def expandOutlinePane (self,event=None):
    '''Expand the outline pane.'''
    self.contractBodyPane()
#@-node:ekr.20060209110936:expand/contract/hide...Pane
#@+node:ekr.20060210123852.1:fullyExpand/hide...Pane
def fullyExpandBodyPane (self,event=None):
    '''Fully expand the body pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)

def fullyExpandLogPane (self,event=None):
    '''Fully expand the log pane.'''
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,0.0)

def fullyExpandOutlinePane (self,event=None):
    '''Fully expand the outline pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideBodyPane (self,event=None):
    '''Completely contract the body pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,1.0)

def hideLogPane (self,event=None):
    '''Completely contract the log pane.'''
    f = self ; f.divideLeoSplitter(not f.splitVerticalFlag,1.0)

def hideOutlinePane (self,event=None):
    '''Completely contract the outline pane.'''
    f = self ; f.divideLeoSplitter(f.splitVerticalFlag,0.0)
#@-node:ekr.20060210123852.1:fullyExpand/hide...Pane
#@-node:ekr.20060209110128:Minibuffer commands... (tkFrame)
#@+node:ekr.20031218072017.3984:Window Menu...
#@+node:ekr.20031218072017.3985:toggleActivePane (tkFrame)
def toggleActivePane (self,event=None):

    '''Toggle the focus between the outline and body panes.'''

    frame = self ; c = frame.c

    if c.get_focus() == frame.body.bodyCtrl: # 2007/10/25
        c.treeWantsFocusNow()
    else:
        c.endEditing()
        c.bodyWantsFocusNow()
#@-node:ekr.20031218072017.3985:toggleActivePane (tkFrame)
#@+node:ekr.20031218072017.3986:cascade
def cascade (self,event=None):

    '''Cascade all Leo windows.'''

    x,y,delta = 10,10,10
    for frame in g.app.windowList:
        top = frame.top

        # Compute w,h
        top.update_idletasks() # Required to get proper info.
        geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
        dim,junkx,junky = geom.split('+')
        w,h = dim.split('x')
        w,h = int(w),int(h)

        # Set new x,y and old w,h
        frame.setTopGeometry(w,h,x,y,adjustSize=False)

        # Compute the new offsets.
        x += 30 ; y += 30
        if x > 200:
            x = 10 + delta ; y = 40 + delta
            delta += 10
#@-node:ekr.20031218072017.3986:cascade
#@+node:ekr.20031218072017.3987:equalSizedPanes
def equalSizedPanes (self,event=None):

    '''Make the outline and body panes have the same size.'''

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20031218072017.3987:equalSizedPanes
#@+node:ekr.20031218072017.3988:hideLogWindow
def hideLogWindow (self,event=None):

    frame = self
    frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)
#@-node:ekr.20031218072017.3988:hideLogWindow
#@+node:ekr.20031218072017.3989:minimizeAll
def minimizeAll (self,event=None):

    '''Minimize all Leo's windows.'''

    self.minimize(g.app.pythonFrame)
    for frame in g.app.windowList:
        self.minimize(frame)
        self.minimize(frame.findPanel)

def minimize(self,frame):

    if frame and frame.top.state() == "normal":
        frame.top.iconify()
#@-node:ekr.20031218072017.3989:minimizeAll
#@+node:ekr.20031218072017.3990:toggleSplitDirection (tkFrame)
# The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.

def toggleSplitDirection (self,event=None):

    '''Toggle the split direction in the present Leo window.'''

    # Switch directions.
    c = self.c
    self.splitVerticalFlag = not self.splitVerticalFlag
    orientation = g.choose(self.splitVerticalFlag,"vertical","horizontal")
    c.config.set("initial_splitter_orientation","string",orientation)

    self.toggleTkSplitDirection(self.splitVerticalFlag)
#@+node:ekr.20041221122440.2:toggleTkSplitDirection
def toggleTkSplitDirection (self,verticalFlag):

    # Abbreviations.
    frame = self
    bar1 = self.bar1 ; bar2 = self.bar2
    split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
    split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
    # Reconfigure the bars.
    bar1.place_forget()
    bar2.place_forget()
    self.configureBar(bar1,verticalFlag)
    self.configureBar(bar2,not verticalFlag)
    # Make the initial placements again.
    self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
    self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
    # Adjust the log and body panes to give more room around the bars.
    self.reconfigurePanes()
    # Redraw with an appropriate ratio.
    vflag,ratio,secondary_ratio = frame.initialRatios()
    self.resizePanesToRatio(ratio,secondary_ratio)
#@-node:ekr.20041221122440.2:toggleTkSplitDirection
#@-node:ekr.20031218072017.3990:toggleSplitDirection (tkFrame)
#@+node:EKR.20040422130619:resizeToScreen
def resizeToScreen (self,event=None):

    '''Resize the Leo window so it fill the entire screen.'''

    top = self.top

    w = top.winfo_screenwidth()
    h = top.winfo_screenheight()

    if sys.platform.startswith('win'):
        top.state('zoomed')
    elif sys.platform == 'darwin':
        # Must leave room to get at very small resizing area.
        geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)
        top.geometry(geom)
    else:
        # Fill almost the entire screen.
        # Works on Windows. YMMV for other platforms.
        geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)
        top.geometry(geom)
#@-node:EKR.20040422130619:resizeToScreen
#@-node:ekr.20031218072017.3984:Window Menu...
#@+node:ekr.20031218072017.3991:Help Menu...
#@+node:ekr.20031218072017.3992:leoHelp
def leoHelp (self,event=None):

    '''Open Leo's offline tutorial.'''

    frame = self ; c = frame.c

    theFile = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

    if g.os_path_exists(theFile):
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")

        if answer == "yes":
            try:
                if 0: # Download directly.  (showProgressBar needs a lot of work)
                    url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
                    import urllib
                    self.scale = None
                    urllib.urlretrieve(url,theFile,self.showProgressBar)
                    if self.scale:
                        self.scale.destroy()
                        self.scale = None
                else:
                    url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                    import webbrowser
                    os.chdir(g.app.loadDir)
                    webbrowser.open_new(url)
            except:
                g.es("exception downloading","sbooks.chm")
                g.es_exception()
#@+node:ekr.20031218072017.3993:showProgressBar
def showProgressBar (self,count,size,total):

    # g.trace("count,size,total:",count,size,total)
    if self.scale == None:
        << create the scale widget >>
    self.scale.set(count*size)
    self.scale.update_idletasks()
#@+node:ekr.20031218072017.3994:<< create the scale widget >>
top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()
#@-node:ekr.20031218072017.3994:<< create the scale widget >>
#@-node:ekr.20031218072017.3993:showProgressBar
#@-node:ekr.20031218072017.3992:leoHelp
#@-node:ekr.20031218072017.3991:Help Menu...
#@-node:ekr.20031218072017.3979:Gui-dependent commands
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20031218072017.3995:Tk bindings... (tkFrame)
def bringToFront (self):
    # g.trace(g.callers())
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.body.bodyCtrl # 2007/10/25

def getTitle (self):
    return self.top.title()

def setTitle (self,title):
    return self.top.title(title)

def get_window_info(self):
    return g.app.gui.get_window_info(self.top)

def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()

def lift (self):
    self.top.lift()

def update (self):
    self.top.update()
#@-node:ekr.20031218072017.3995:Tk bindings... (tkFrame)
#@-node:ekr.20031218072017.3940:class leoTkinterFrame
#@+node:ekr.20031218072017.4039:class leoTkinterLog
class leoTkinterLog (leoFrame.leoLog):

    """A class that represents the log pane of a Tkinter window."""

    @others
#@+node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20031218072017.4040:tkLog.__init__
def __init__ (self,frame,parentFrame):

    # g.trace("leoTkinterLog")

    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)

    self.c = c = frame.c # Also set in the base constructor, but we need it here.

    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")

    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.

    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()



#@-node:ekr.20031218072017.4040:tkLog.__init__
#@+node:ekr.20031218072017.4042:tkLog.createControl
def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        return self.onRightClick(event,menu)

    c.bind(self.nb,'<Button-3>',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # Create and activate the default tabs.

    return self.logCtrl
#@-node:ekr.20031218072017.4042:tkLog.createControl
#@+node:ekr.20070114070939:tkLog.finishCreate
def finishCreate (self):

    # g.trace('tkLog')

    c = self.c ; log = self

    c.searchCommands.openFindTab(show=False)
    c.spellCommands.openSpellTab()
    log.selectTab('Log')
#@-node:ekr.20070114070939:tkLog.finishCreate
#@+node:ekr.20071002143627:tkLog.createCanvasWidget
def createCanvasWidget (self,parentFrame):

    self.logNumber += 1

    w = Tk.Canvas(parentFrame)

    logBar = Tk.Scrollbar(parentFrame,name="logBar")
    w['yscrollcommand'] = logBar.set
    logBar['command'] = w.yview
    logBar.pack(side="right", fill="y")

    logXBar = Tk.Scrollbar(parentFrame,name='logXBar',orient="horizontal") 
    w['xscrollcommand'] = logXBar.set 
    logXBar['command'] = w.xview 
    logXBar.pack(side="bottom", fill="x")

    w.pack(expand=1, fill="both")

    # Set the background color.
    configName = 'log_canvas_pane_tab_background_color'
    bg = self.c.config.getColor(configName) or 'MistyRose1'
    try: w.configure(bg=bg)
    except Exception: pass # Could be a user error.

    return w
#@-node:ekr.20071002143627:tkLog.createCanvasWidget
#@+node:ekr.20051016103459:tkLog.createTextWidget
def createTextWidget (self,parentFrame):

    self.logNumber += 1
    log = g.app.gui.plainTextWidget(
        parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")

    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview

    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log
#@-node:ekr.20051016103459:tkLog.createTextWidget
#@+node:ekr.20051019134106.1:tkLog.makeTabMenu
def makeTabMenu (self,tabName=None,allowRename=True):

    '''Create a tab popup menu.'''

    # g.trace(tabName,g.callers())

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.

    menu = Tk.Menu(hull,tearoff=0)
    c.add_command(menu,label='New Tab',command=self.newTabFromMenu)
    c.add_command(menu,label='New CanvasTab',command=self.newCanvasTabFromMenu)

    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            return self.deleteTab(tabName)

        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        c.add_command(menu,label=label,command=deleteTabCallback)

        def renameTabCallback():
            return self.renameTabFromMenu(tabName)

        if allowRename:
            c.add_command(menu,label='Rename This Tab',command=renameTabCallback)

    return menu
#@-node:ekr.20051019134106.1:tkLog.makeTabMenu
#@-node:ekr.20051016095907:tkLog Birth
#@+node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
def configureBorder(self,border):

    self.logCtrl.configure(bd=border)

def configureFont(self,font):

    self.logCtrl.configure(font=font)
#@-node:ekr.20031218072017.4041:tkLog.configureBorder & configureFont
#@+node:ekr.20031218072017.4043:tkLog.getFontConfig
def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font
#@-node:ekr.20031218072017.4043:tkLog.getFontConfig
#@+node:ekr.20041222043017:tkLog.restoreAllState
def restoreAllState (self,d):

    '''Restore the log from a dict created by saveAllState.'''

    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors:
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)
#@-node:ekr.20041222043017:tkLog.restoreAllState
#@+node:ekr.20041222043017.1:tkLog.saveAllState
def saveAllState (self):

    '''Return a dict containing all data needed to recreate the log in another widget.'''

    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.getAllText()

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)

    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d
#@-node:ekr.20041222043017.1:tkLog.saveAllState
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):

    c = self.c

    bg = c.config.getColor("log_pane_background_color") or 'white'

    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass

setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@-node:ekr.20051016095907.1:Config & get/saveState
#@+node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@+node:ekr.20031218072017.4044:tkLog.hasFocus
def hasFocus (self):

    return self.c.get_focus() == self.logCtrl
#@-node:ekr.20031218072017.4044:tkLog.hasFocus
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            g.pr(s,newline=False) # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            g.pr(g.toEncodedString(s,'utf-8'))
    else:
        self.logCtrl.update_idletasks()
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20051016095907.2:Focus & update (tkLog)
#@+node:ekr.20051016101927:put & putnl (tkLog)
@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...
#@+node:ekr.20031218072017.1473:put
# All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):

    c = self.c

    # g.pr('tkLog.put',s)
    # g.pr('tkLog.put',len(s),g.callers())

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)

    # Note: this must be done after the call to selectTab.
    w = self.logCtrl
    if w:
        << put s to log control >>
        self.logCtrl.update_idletasks()
    else:
        << put s to logWaiting and print s >>
#@+node:EKR.20040423082910:<< put s to log control >>
if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see('end')
self.forceLogUpdate(s)
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

g.pr("Null tkinter log")

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

g.pr(s)
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@-node:ekr.20031218072017.1473:put
#@+node:ekr.20051016101927.1:putnl
def putnl (self,tabName='Log'):

    if g.app.quitting:
        return

    # g.pr('tkLog.putnl' # ,g.callers())

    if tabName:
        self.selectTab(tabName)

    w = self.logCtrl

    if w:
        w.insert("end",'\n')
        w.see('end')
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        g.pr("Null tkinter log")
#@-node:ekr.20051016101927.1:putnl
#@-node:ekr.20051016101927:put & putnl (tkLog)
#@+node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051017212057:clearTab
def clearTab (self,tabName,wrap='none'):

    self.selectTab(tabName,wrap=wrap)
    w = self.logCtrl
    if w: w.delete(0,'end')
#@-node:ekr.20051017212057:clearTab
#@+node:ekr.20071002143627.1:createCanvas
def createCanvas (self,tabName=None):

    c = self.c ; k = c.k

    if tabName is None:
        self.logNumber += 1
        tabName = 'Canvas %d' % self.logNumber

    tabFrame = self.nb.add(tabName)
    menu = self.makeTabMenu(tabName,allowRename=False)

    w = self.createCanvasWidget(tabFrame)

    self.canvasDict [tabName ] = w
    self.textDict [tabName] = None
    self.frameDict [tabName] = tabFrame

    self.setCanvasTabBindings(tabName,menu)

    return w
#@-node:ekr.20071002143627.1:createCanvas
#@+node:ekr.20051024173701:createTab
def createTab (self,tabName,createText=True,wrap='none'):

    # g.trace(tabName,wrap)

    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    if createText:
        << Create the tab's text widget >>
    else:
        self.canvasDict [tabName] = None
        self.textDict [tabName] = None
        self.frameDict [tabName] = tabFrame

    if tabName != 'Log':
        # c.k doesn't exist when the log pane is created.
        # k.makeAllBindings will call setTabBindings('Log')
        self.setTabBindings(tabName)
#@+node:ekr.20051018072306:<< Create the tab's text widget >>
w = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'

if wrap not in ('none','char','word'): wrap = 'none'
try: w.configure(bg=bg,wrap=wrap)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=w)

self.canvasDict [tabName ] = None
self.frameDict [tabName] = tabFrame
self.textDict [tabName] = w

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags
#@-node:ekr.20051018072306:<< Create the tab's text widget >>
#@-node:ekr.20051024173701:createTab
#@+node:ekr.20060613131217:cycleTabFocus
def cycleTabFocus (self,event=None,stop_w = None):

    '''Cycle keyboard focus between the tabs in the log pane.'''

    c = self.c ; d = self.frameDict # Keys are page names. Values are Tk.Frames.
    w = d.get(self.tabName)
    # g.trace(self.tabName,w)
    values = d.values()
    if self.numberOfVisibleTabs() > 1:
        i = i2 = values.index(w) + 1
        if i == len(values): i = 0
        tabName = d.keys()[i]
        self.selectTab(tabName)
        return 
#@nonl
#@-node:ekr.20060613131217:cycleTabFocus
#@+node:ekr.20051018102027:deleteTab
def deleteTab (self,tabName,force=False):

    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell') and not force:
        self.selectTab('Log')

    elif tabName in self.nb.pagenames():
        # g.trace(tabName,force)
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.canvasDict [tabName ] = None
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')

    # New in Leo 4.4b1.
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20051018102027:deleteTab
#@+node:ekr.20060204124347:hideTab
def hideTab (self,tabName):

    self.selectTab('Log')
#@-node:ekr.20060204124347:hideTab
#@+node:ekr.20051027114433:getSelectedTab
def getSelectedTab (self):

    return self.tabName
#@-node:ekr.20051027114433:getSelectedTab
#@+node:ekr.20051018061932.1:lower/raiseTab
def lowerTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.invalidateFocus()
    self.c.bodyWantsFocus()
#@-node:ekr.20051018061932.1:lower/raiseTab
#@+node:ekr.20060613131345:numberOfVisibleTabs
def numberOfVisibleTabs (self):

    return len([val for val in self.frameDict.values() if val != None])
#@-node:ekr.20060613131345:numberOfVisibleTabs
#@+node:ekr.20051019170806:renameTab
def renameTab (self,oldName,newName):

    # g.trace('newName',newName)

    label = self.nb.tab(oldName)
    label.configure(text=newName)
#@-node:ekr.20051019170806:renameTab
#@+node:ekr.20051016101724.1:selectTab
def selectTab (self,tabName,createText=True,wrap='none'):

    '''Create the tab if necessary and make it active.'''

    c = self.c

    tabFrame = self.frameDict.get(tabName)
    logCtrl = self.textDict.get(tabName)

    if tabFrame and logCtrl:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    elif not tabFrame:
        self.createTab(tabName,createText=createText,wrap=wrap)

    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    w = self.textDict.get(tabName)
    if w: self.logCtrl = w
    self.tabFrame = self.frameDict.get(tabName)

    if 0: # Absolutely do not do this here!  It is a cause of the 'sticky focus' problem.
        c.widgetWantsFocusNow(self.logCtrl)
    return tabFrame
#@-node:ekr.20051016101724.1:selectTab
#@+node:ekr.20051022162730:setTabBindings
def setTabBindings (self,tabName):

    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName) or self.frameDict.get(tabName)

    def logTextRightClickCallback(event):
        return c.k.masterClick3Handler(event,self.onLogTextRightClick)


    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('<Key>',       k.masterKeyHandler),
        ('<Button-1>',  k.masterClickHandler),
        ('<Button-3>',  logTextRightClickCallback),
    ):
        c.bind(w,kind,handler)

    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    c.bind(tab,'<Button-1>',tabMenuClickCallback)
    c.bind(tab,'<Button-3>',tabMenuRightClickCallback)

    k.completeAllBindingsForWidget(w)
#@-node:ekr.20051022162730:setTabBindings
#@+node:bobjack.20080401113759.3:onLogTextRightClick
def onLogTextRightClick(self, event):

    g.doHook('rclick-popup', c=self.c, event=event, context_menu='log')
#@-node:bobjack.20080401113759.3:onLogTextRightClick
#@+node:ekr.20071003090546:setCanvasTabBindings
def setCanvasTabBindings (self,tabName,menu):

    c = self.c ; tab = self.nb.tab(tabName)

    def tabMenuRightClickCallback(event,menu=menu):
        return self.onRightClick(event,menu)

    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)

    c.bind(tab,'<Button-1>',tabMenuClickCallback)
    c.bind(tab,'<Button-3>',tabMenuRightClickCallback)

#@-node:ekr.20071003090546:setCanvasTabBindings
#@+node:ekr.20051019134106:Tab menu callbacks & helpers
#@+node:ekr.20051019134422:onRightClick & onClick
def onRightClick (self,event,menu):

    c = self.c
    menu.post(event.x_root,event.y_root)


def onClick (self,event,tabName):

    self.selectTab(tabName)
#@-node:ekr.20051019134422:onRightClick & onClick
#@+node:ekr.20051019140004.1:newTabFromMenu & newCanvasTabFromMenu
def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)

    # This is called by getTabName.
    def selectTabCallback (newName):
        return self.selectTab(newName)

    self.getTabName(selectTabCallback)

def newCanvasTabFromMenu (self):

    self.createCanvas()
#@-node:ekr.20051019140004.1:newTabFromMenu & newCanvasTabFromMenu
#@+node:ekr.20051019165401:renameTabFromMenu
def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename',tabName,'tab',color='blue')
    else:
        def renameTabCallback (newName):
            return self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)
#@-node:ekr.20051019165401:renameTabFromMenu
#@+node:ekr.20051019172811:getTabName
def getTabName (self,exitCallback):

    canvas = self.nb.component('hull')

    # Overlay what is there!
    c = self.c
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)

    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)

    def closeTabNameCallback (event=None):
        f.pack_forget()

    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)

    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    g.app.gui.set_focus(c,e)
    c.bind(e,'<Return>',getNameCallback)
#@-node:ekr.20051019172811:getTabName
#@-node:ekr.20051019134106:Tab menu callbacks & helpers
#@-node:ekr.20051018061932:Tab (TkLog)
#@+node:ekr.20051019183105.3:tkLog color tab stuff
def createColorPicker (self,tabName):

    log = self

    << define colors >>

    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    colors = list(colors)
    bg = parent.cget('background')

    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)

    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')

    label = g.app.gui.plainTextWidget(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    << create optionMenu and callback >>
    << create picker button and callback >>
#@+node:ekr.20051019183105.2:<< define colors >>
colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@-node:ekr.20051019183105.2:<< define colors >>
#@+node:ekr.20051019183105.4:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@-node:ekr.20051019183105.4:<< create optionMenu and callback >>
#@+node:ekr.20051019183105.5:<< create picker button and callback >>
def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)
#@-node:ekr.20051019183105.5:<< create picker button and callback >>
#@-node:ekr.20051019183105.3:tkLog color tab stuff
#@+node:ekr.20070212102521:tkLog font tab stuff
#@+node:ekr.20051019201809.1:createFontPicker
def createFontPicker (self,tabName):

    log = self ; c = self.c
    parent = log.frameDict.get(tabName)
    w = log.textDict.get(tabName)
    w.pack_forget()

    bg = parent.cget('background')
    font = self.getFont()
    << create the frames >>
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    << create the sample text widget >>
    << create and bind the callbacks >>
    self.createBindings()
#@+node:ekr.20051019202139:<< create the frames >>
f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')
#@-node:ekr.20051019202139:<< create the frames >>
#@+node:ekr.20051019201809.2:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

self.familyBox = familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.2:<< create the family combo box >>
#@+node:ekr.20051019201809.3:<< create the size entry >>
Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4)
sizeEntry.insert(0,'12')
sizeEntry.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.3:<< create the size entry >>
#@+node:ekr.20051019201809.4:<< create the weight combo box >>
weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.4:<< create the weight combo box >>
#@+node:ekr.20051019201809.5:<< create the slant combo box>>
slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)
#@-node:ekr.20051019201809.5:<< create the slant combo box>>
#@+node:ekr.20051019202139.1:<< create the sample text widget >>
self.sampleWidget = sample = g.app.gui.plainTextWidget(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert(0,s)
#@-node:ekr.20051019202139.1:<< create the sample text widget >>
#@+node:ekr.20051019202328:<< create and bind the callbacks >>
def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

c.bind(sizeEntry,'<Return>',fontCallback)
#@-node:ekr.20051019202328:<< create and bind the callbacks >>
#@-node:ekr.20051019201809.1:createFontPicker
#@+node:ekr.20060726133852:createBindings (fontPicker)
def createBindings (self):

    c = self.c ; k = c.k

    table = (
        ('<Button-1>',  k.masterClickHandler),
        ('<Double-1>',  k.masterClickHandler),
        ('<Button-3>',  k.masterClickHandler),
        ('<Double-3>',  k.masterClickHandler),
        ('<Key>',       k.masterKeyHandler),
        ("<Escape>",    self.hideFontTab),
    )

    w = self.sampleWidget
    for event, callback in table:
        c.bind(w,event,callback)

    k.completeAllBindingsForWidget(w)
#@-node:ekr.20060726133852:createBindings (fontPicker)
#@+node:ekr.20051019201809.6:getFont
def getFont(self,family=None,size=12,slant='roman',weight='normal'):

    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es('','family,size,slant,weight:','',family,'',size,'',slant,'',weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@-node:ekr.20051019201809.6:getFont
#@+node:ekr.20051019201809.7:setFont
def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):

    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','<none>',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)
#@-node:ekr.20051019201809.7:setFont
#@+node:ekr.20060726134339:hideFontTab
def hideFontTab (self,event=None):

    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
#@-node:ekr.20060726134339:hideFontTab
#@-node:ekr.20070212102521:tkLog font tab stuff
#@-node:ekr.20031218072017.4039:class leoTkinterLog
#@+node:ekr.20070317073627.3:class leoTkinterTreeTab
class leoTkinterTreeTab (leoFrame.leoTreeTab):

    '''A class representing a tabbed outline pane drawn with Tkinter.'''

    @others
#@nonl
#@+node:ekr.20070320090557.1: Birth & death
#@+node:ekr.20070317073819.1: ctor (leoTreeTab)
def __init__ (self,c,parentFrame,chapterController):

    leoFrame.leoTreeTab.__init__ (self,c,chapterController,parentFrame)
        # Init the base class.  Sets self.c, self.cc and self.parentFrame.

    self.tabNames = [] # The list of tab names.  Changes when tabs are renamed.

    self.createControl()
#@-node:ekr.20070317073819.1: ctor (leoTreeTab)
#@+node:ekr.20070317073819.2:tt.createControl
def createControl (self):

    tt = self ; c = tt.c

    # Create the main container, possibly in a new row.
    tt.frame = c.frame.getNewIconFrame()

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)

    # Actually add tt.frame to the icon row.
    c.frame.addIconWidget(tt.frame)
#@nonl
#@-node:ekr.20070317073819.2:tt.createControl
#@-node:ekr.20070320090557.1: Birth & death
#@+node:ekr.20070320093038:Tabs...
#@+node:ekr.20070317074824:tt.createTab
def createTab (self,tabName,select=True):

    tt = self

    if tabName not in tt.tabNames:
        tt.tabNames.append(tabName)
        tt.setNames()
#@-node:ekr.20070317074824:tt.createTab
#@+node:ekr.20070317074824.1:tt.destroyTab
def destroyTab (self,tabName):

    tt = self

    if tabName in tt.tabNames:
        tt.tabNames.remove(tabName)
        tt.setNames()
#@-node:ekr.20070317074824.1:tt.destroyTab
#@+node:ekr.20070317074824.3:tt.selectTab
def selectTab (self,tabName):

    tt = self

    if tabName not in self.tabNames:
        tt.createTab(tabName)

    tt.cc.selectChapterByName(tabName)

    self.c.redraw()
    self.c.outerUpdate()
#@-node:ekr.20070317074824.3:tt.selectTab
#@+node:ekr.20070604192627:tt.setTabLabel
def setTabLabel (self,tabName):

    tt = self
    tt.chapterVar.set(tabName)
#@-node:ekr.20070604192627:tt.setTabLabel
#@+node:ekr.20070604210618:tt.setNames
def setNames (self):

    '''Recreate the list of items.'''

    tt = self
    names = tt.tabNames[:]
    if 'main' in names: names.remove('main')
    names.sort()
    names.insert(0,'main')
    tt.chapterMenu.setitems(names)
#@-node:ekr.20070604210618:tt.setNames
#@-node:ekr.20070320093038:Tabs...
#@-node:ekr.20070317073627.3:class leoTkinterTreeTab
#@+node:ekr.20061113151148.1:class leoTkTextWidget (Tk.Text)
class leoTkTextWidget (Tk.Text):

    '''A class to wrap the Tk.Text widget.
    Translates Python (integer) indices to and from Tk (string) indices.

    This class inherits almost all tkText methods: you call use them as usual.'''

    # The signatures of tag_add and insert are different from the Tk.Text signatures.

    def __repr__(self):
        name = hasattr(self,'_name') and self._name or '<no name>'
        return 'leoTkTextWidget id: %s name: %s' % (id(self),name)

    @others
#@nonl
#@+node:ekr.20070213170937:bindings (not used)
# Specify the names of widget-specific methods.
# These particular names are the names of wx.TextCtrl methods.

# def _appendText(self,s):            return self.widget.insert(s)
# def _get(self,i,j):                 return self.widget.get(i,j)
# def _getAllText(self):              return self.widget.get('1.0','end')
# def _getFocus(self):                return self.widget.focus_get()
# def _getInsertPoint(self):          return self.widget.index('insert')
# def _getLastPosition(self):         return self.widget.index('end')
# def _getSelectedText(self):         return self.widget.get('sel.start','sel.end')
# def _getSelectionRange(self):       return self.widget.index('sel.start'),self.widget.index('sel.end')
# def _hitTest(self,pos):             pass
# def _insertText(self,i,s):          return self.widget.insert(i,s)
# def _scrollLines(self,n):           pass
# def _see(self,i):                   return self.widget.see(i)
# def _setAllText(self,s):            self.widget.delete('1.0','end') ; self.widget.insert('1.0',s)
# def _setBackgroundColor(self,color): return self.widget.configure(background=color)
# def _setForegroundColor(self,color): return self.widget.configure(background=color)
# def _setFocus(self):                return self.widget.focus_set()
# def _setInsertPoint(self,i):        return self.widget.mark_set('insert',i)
# def _setSelectionRange(self,i,j):   return self.widget.SetSelection(i,j)
#@-node:ekr.20070213170937:bindings (not used)
#@+node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061117085824:w.toGuiIndex
def toGuiIndex (self,i,s=None):
    '''Convert a Python index to a Tk index as needed.'''
    w = self
    if i is None:
        g.trace('can not happen: i is None',g.callers())
        return '1.0'
    elif type(i) == type(99):
        # The 's' arg supports the threaded colorizer.
        if s is None:
            # This *must* be 'end-1c', even if other code must change.
            s = Tk.Text.get(w,'1.0','end-1c')
        row,col = g.convertPythonIndexToRowCol(s,i)
        i = '%s.%s' % (row+1,col)
        # g.trace(len(s),i,repr(s))
    else:
        try:
            i = Tk.Text.index(w,i)
        except Exception:
            # g.es_exception()
            g.trace('Tk.Text.index failed:',repr(i),g.callers())
            i = '1.0'
    return i
#@nonl
#@-node:ekr.20061117085824:w.toGuiIndex
#@+node:ekr.20061117085824.1:w.toPythonIndex
def toPythonIndex (self,i):
    '''Convert a Tk index to a Python index as needed.'''
    w =self
    if i is None:
        g.trace('can not happen: i is None')
        return 0

    elif type(i) in (type('a'),type(u'a')):
        s = Tk.Text.get(w,'1.0','end') # end-1c does not work.
        i = Tk.Text.index(w,i) # Convert to row/column form.
        row,col = i.split('.')
        row,col = int(row),int(col)
        row -= 1
        i = g.convertRowColToPythonIndex(s,row,col)
        #g.es_print('',i)
    return i
#@-node:ekr.20061117085824.1:w.toPythonIndex
#@+node:ekr.20061117085824.2:w.rowColToGuiIndex
# This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return '%s.%s' % (row+1,col)
#@nonl
#@-node:ekr.20061117085824.2:w.rowColToGuiIndex
#@-node:ekr.20061113151148.2:Index conversion (leoTextWidget)
#@+node:ekr.20061113151148.3:Wrapper methods (leoTextWidget)
#@+node:ekr.20061113151148.4:delete
def delete(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.delete(w,i)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.delete(w,i,j)
#@-node:ekr.20061113151148.4:delete
#@+node:ekr.20061113151148.12:flashCharacter
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75): # tkTextWidget.

    w = self

    def addFlashCallback(w,count,index):
        # g.trace(count,index)
        i,j = w.toGuiIndex(index),w.toGuiIndex(index+1)
        Tk.Text.tag_add(w,'flash',i,j)
        Tk.Text.after(w,delay,removeFlashCallback,w,count-1,index)

    def removeFlashCallback(w,count,index):
        # g.trace(count,index)
        Tk.Text.tag_remove(w,'flash','1.0','end')
        if count > 0:
            Tk.Text.after(w,delay,addFlashCallback,w,count,index)

    try:
        Tk.Text.tag_configure(w,'flash',foreground=fg,background=bg)
        addFlashCallback(w,flashes,i)
    except Exception:
        pass # g.es_exception()
#@nonl
#@-node:ekr.20061113151148.12:flashCharacter
#@+node:ekr.20061113151148.5:get
def get(self,i,j=None):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        return Tk.Text.get(w,i)
    else:
        j = w.toGuiIndex(j)
        return Tk.Text.get(w,i,j)
#@-node:ekr.20061113151148.5:get
#@+node:ekr.20061113151148.13:getAllText
def getAllText (self): # tkTextWidget.

    """Return all the text of Tk.Text widget w converted to unicode."""

    w = self
    s = Tk.Text.get(w,"1.0","end-1c") # New in 4.4.1: use end-1c.

    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)
#@-node:ekr.20061113151148.13:getAllText
#@+node:ekr.20061113151148.14:getInsertPoint
def getInsertPoint(self): # tkTextWidget.

    w = self
    i = Tk.Text.index(w,'insert')
    i = w.toPythonIndex(i)
    return i
#@-node:ekr.20061113151148.14:getInsertPoint
#@+node:ekr.20061117160129:getName
def getName (self):

    w = self
    return hasattr(w,'_name') and w._name or repr(w)
#@nonl
#@-node:ekr.20061117160129:getName
#@+node:ekr.20061113151148.15:getSelectedText
def getSelectedText (self): # tkTextWidget.

    w = self
    i,j = w.getSelectionRange()
    if i != j:
        i,j = w.toGuiIndex(i),w.toGuiIndex(j)
        s = Tk.Text.get(w,i,j)
        return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""
#@-node:ekr.20061113151148.15:getSelectedText
#@+node:ekr.20061113151148.16:getSelectionRange
def getSelectionRange (self,sort=True): # tkTextWidget.

    """Return a tuple representing the selected range.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        i,j = sel
    else:
        i = j = Tk.Text.index(w,"insert")

    i,j = w.toPythonIndex(i),w.toPythonIndex(j)  
    if sort and i > j: i,j = j,i
    return i,j
#@nonl
#@-node:ekr.20061113151148.16:getSelectionRange
#@+node:ekr.20070212204016:getWidth
def getWidth (self):

    '''Return the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    return w.cget('width')
#@-node:ekr.20070212204016:getWidth
#@+node:ekr.20070211185433.1:getYScrollPosition
def getYScrollPosition (self):

    w = self
    return w.yview()
#@-node:ekr.20070211185433.1:getYScrollPosition
#@+node:ekr.20061113151148.17:hasSelection
def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
#@-node:ekr.20061113151148.17:hasSelection
#@+node:ekr.20070213104858.1:indexIsVisible
def indexIsVisible (self,i):

    w = self

    return w.dlineinfo(i)
#@nonl
#@-node:ekr.20070213104858.1:indexIsVisible
#@+node:ekr.20061113151148.6:insert
# The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.insert(w,i,s)

#@-node:ekr.20061113151148.6:insert
#@+node:ekr.20061113151148.7:mark_set NO LONGER USED
# def mark_set(self,markName,i):

    # w = self
    # i = w.toGuiIndex(i)
    # Tk.Text.mark_set(w,markName,i)
#@-node:ekr.20061113151148.7:mark_set NO LONGER USED
#@+node:ekr.20061113151148.18:replace
def replace (self,i,j,s): # tkTextWidget

    w = self
    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    Tk.Text.delete(w,i,j)
    Tk.Text.insert(w,i,s)
#@-node:ekr.20061113151148.18:replace
#@+node:ekr.20061113180616:see
def see (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    Tk.Text.see(w,i)
#@-node:ekr.20061113180616:see
#@+node:ekr.20061113175002:seeInsertPoint
def seeInsertPoint (self): # tkTextWidget.

    w = self
    Tk.Text.see(w,'insert')
#@-node:ekr.20061113175002:seeInsertPoint
#@+node:ekr.20061113151148.19:selectAllText
def selectAllText (self,insert=None): # tkTextWidget

    '''Select all text of the widget, *not* including the extra newline.'''

    w = self ; s = w.getAllText()
    if insert is None: insert = len(s)
    w.setSelectionRange(0,len(s),insert=insert)
#@-node:ekr.20061113151148.19:selectAllText
#@+node:ekr.20061113151148.20:setAllText
def setAllText (self,s): # tkTextWidget

    w = self

    state = Tk.Text.cget(w,"state")
    Tk.Text.configure(w,state="normal")

    Tk.Text.delete(w,'1.0','end')
    if s: Tk.Text.insert(w,'1.0',s) # The 'if s:' is a workaround for a fedora bug.

    Tk.Text.configure(w,state=state)
#@-node:ekr.20061113151148.20:setAllText
#@+node:ekr.20070218122857:setBackgroundColor & setForegroundColor
def setBackgroundColor (self,color):

    w = self
    w.configure(background=color)

def setForegroundColor (self,color):

    w = self
    w.configure(foreground=color)
#@nonl
#@-node:ekr.20070218122857:setBackgroundColor & setForegroundColor
#@+node:ekr.20061113151148.21:setInsertPoint
def setInsertPoint (self,i): # tkTextWidget.

    w = self
    i = w.toGuiIndex(i)
    # g.trace(i,g.callers())
    Tk.Text.mark_set(w,'insert',i)
#@-node:ekr.20061113151148.21:setInsertPoint
#@+node:ekr.20061113151148.22:setSelectionRange
def setSelectionRange (self,i,j,insert=None): # tkTextWidget

    w = self

    i,j = w.toGuiIndex(i),w.toGuiIndex(j)

    # g.trace('i,j,insert',repr(i),repr(j),repr(insert),g.callers())

    # g.trace('i,j,insert',i,j,repr(insert))
    if Tk.Text.compare(w,i, ">", j): i,j = j,i
    Tk.Text.tag_remove(w,"sel","1.0",i)
    Tk.Text.tag_add(w,"sel",i,j)
    Tk.Text.tag_remove(w,"sel",j,"end")

    if insert is not None:
        w.setInsertPoint(insert)
#@-node:ekr.20061113151148.22:setSelectionRange
#@+node:ekr.20070212081121:setWidth
def setWidth (self,width):

    '''Set the width of the widget.
    This is only called for headline widgets,
    and gui's may choose not to do anything here.'''

    w = self
    w.configure(width=width)
#@-node:ekr.20070212081121:setWidth
#@+node:ekr.20070211185433:setYScrollPosition
def setYScrollPosition (self,i):

    w = self
    w.yview('moveto',i)
#@nonl
#@-node:ekr.20070211185433:setYScrollPosition
#@+node:ekr.20061113151148.8:tag_add
# The signature is slightly different than the Tk.Text.insert method.

def tag_add(self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_add(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_add(w,tagName,i,j,*args)

#@-node:ekr.20061113151148.8:tag_add
#@+node:ekr.20061113151148.9:tag_ranges
def tag_ranges(self,tagName):

    w = self
    aList = Tk.Text.tag_ranges(w,tagName)
    aList = [w.toPythonIndex(z) for z in aList]
    return tuple(aList)
#@-node:ekr.20061113151148.9:tag_ranges
#@+node:ekr.20070116073907:tag_remove
# The signature is slightly different than the Tk.Text.insert method.

def tag_remove (self,tagName,i,j=None,*args):

    w = self
    i = w.toGuiIndex(i)

    if j is None:
        Tk.Text.tag_remove(w,tagName,i,*args)
    else:
        j = w.toGuiIndex(j)
        Tk.Text.tag_remove(w,tagName,i,j,*args)


#@-node:ekr.20070116073907:tag_remove
#@+node:ekr.20061113151148.11:deleteTextSelection
def deleteTextSelection (self): # tkTextWidget

    w = self
    sel = Tk.Text.tag_ranges(w,"sel")
    if len(sel) == 2:
        start,end = sel
        if Tk.Text.compare(w,start,"!=",end):
            Tk.Text.delete(w,start,end)
#@-node:ekr.20061113151148.11:deleteTextSelection
#@+node:ekr.20061113151148.23:xyToGui/PythonIndex
def xyToGuiIndex (self,x,y): # tkTextWidget

    w = self
    return Tk.Text.index(w,"@%d,%d" % (x,y))

def xyToPythonIndex(self,x,y): # tkTextWidget

    w = self
    i = Tk.Text.index(w,"@%d,%d" % (x,y))
    i = w.toPythonIndex(i)
    return i
#@-node:ekr.20061113151148.23:xyToGui/PythonIndex
#@-node:ekr.20061113151148.3:Wrapper methods (leoTextWidget)
#@-node:ekr.20061113151148.1:class leoTkTextWidget (Tk.Text)
#@-node:ekr.20031218072017.3939:@@thin leoTkinterFrame.py
#@+node:ekr.20031218072017.4047:@@thin leoTkinterGui.py
@first # -*- coding: utf-8 -*-

"""Leo's Tkinter Gui module."""

@language python
@tabwidth -4
@pagewidth 80

<< imports >>

class tkinterGui(leoGui.leoGui):

    """A class encapulating all calls to tkinter."""

    @others
#@+node:ekr.20041228050845:<< imports >>
import leo.core.leoGlobals as g
import leo.core.leoGui as leoGui
import leo.core.leoTkinterComparePanel as leoTkinterComparePanel
import leo.core.leoTkinterDialog as leoTkinterDialog
import leo.core.leoTkinterFind as leoTkinterFind
import leo.core.leoTkinterFrame as leoTkinterFrame
import tkFont
import tkFileDialog
import os
# import string
import sys
import Tkinter as Tk

Pmw = g.importExtension('Pmw',    pluginName='leoTkinterGui',verbose=True)
#@-node:ekr.20041228050845:<< imports >>
#@+node:ekr.20031218072017.4048:tkGui birth & death
#@+node:ekr.20031218072017.837: tkGui.__init__
def __init__ (self):

    # Initialize the base class.
    leoGui.leoGui.__init__(self,"tkinter")

    self.bitmap_name = None
    self.bitmap = None
    self.win32clipboard = None
    self.defaultFont = None
    self.defaultFontFamily = None
    self.bodyTextWidget =  leoTkinterFrame.leoTkTextWidget
    self.plainTextWidget = leoTkinterFrame.leoTkTextWidget

    if 0: # This seems both dangerous and non-functional.
        if sys.platform == "win32":
            try:
                import win32clipboard
                self.win32clipboard = win32clipboard
            except:
                g.es_exception()
#@-node:ekr.20031218072017.837: tkGui.__init__
#@+node:ekr.20061031172934:createKeyHandlerClass (tkGui)
def createKeyHandlerClass (self,c,useGlobalKillbuffer=True,useGlobalRegisters=True):

    import leo.core.leoTkinterKeys as leoTkinterKeys # Do this here to break any circular dependency.

    return leoTkinterKeys.tkinterKeyHandlerClass(c,useGlobalKillbuffer,useGlobalRegisters)
#@nonl
#@-node:ekr.20061031172934:createKeyHandlerClass (tkGui)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        # g.trace('Pmw.init')
        self.root = root = Tk.Tk()
        Pmw.initialise(self.root)

    root.title("Leo Main Window")
    root.withdraw()

    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)

    root.withdraw()

    return root
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):

    """Set the icon to be used in all Leo windows.

    This code does nothing for Tk versions before 8.4.3."""

    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        # g.trace(repr(version),g.CheckVersion(version,"8.4.3"))
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32":

            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es('','LeoApp16.ico','not in','Icons','directory',color="red")
            else:
                g.es('','Icons','directory not found:',path, color="red")
    except:
        g.pr("exception setting bitmap")
        import traceback ; traceback.print_exc()
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):

    """Get the default font from a new text widget."""

    # g.trace(g.callers())

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        w = g.app.gui.plainTextWidget()
        fn = w.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # g.pr('***** getDefaultConfigFont',repr(family))

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@+node:ekr.20031218072017.4051:destroySelf
def destroySelf (self):

    if 0: # Works in Python 2.1 and 2.2.  Leaves Python window open.
        self.root.destroy()

    else: # Works in Python 2.3.  Closes Python window.
        self.root.quit()
#@-node:ekr.20031218072017.4051:destroySelf
#@+node:ekr.20031218072017.4053:killGui
def killGui(self,exitFlag=True):

    """Destroy a gui and terminate Leo if exitFlag is True."""

    pass # No need to do anything.
#@-node:ekr.20031218072017.4053:killGui
#@+node:ekr.20031218072017.4054:recreateRootWindow
def recreateRootWindow(self):
    """A do-nothing base class to create the hidden root window of a gui

    after a previous gui has terminated with killGui(False)."""

    pass # No need to do anything.
#@-node:ekr.20031218072017.4054:recreateRootWindow
#@+node:ekr.20031218072017.4055:runMainLoop (tkGui)
def runMainLoop(self):

    """Run tkinter's main loop."""

    # Avoid an erroneous pylint complaint.
    # script = self.script
    script = getattr(self,'script')

    if script:
        log = g.app.log
        if log:
            g.pr('Start of batch script...\n')
            log.c.executeScript(script=script)
            g.pr('End of batch script')
        else:
            g.pr('no log, no commander for executeScript in tkInterGui.runMainLoop')
    else:
         # g.trace("tkinterGui")
        self.root.mainloop()
#@-node:ekr.20031218072017.4055:runMainLoop (tkGui)
#@-node:ekr.20031218072017.4048:tkGui birth & death
#@+node:ekr.20031218072017.4056:tkGui dialogs & panels
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run a Tkinter About Leo dialog."""
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
    return d.run(modal=False)

def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    d = leoTkinterDialog.tkinterAskLeoID()
    return d.run(modal=True)

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run a Tkinter an askOK dialog ."""
    d = leoTkinterDialog.tkinterAskOk(c,title,message,text)
    return d.run(modal=True)

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelNumber(c,title,message)
    return d.run(modal=True)

def runAskOkCancelStringDialog(self,c,title,message):
    """Create and run askOkCancelString dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelString(c,title,message)
    return d.run(modal=True)

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    d = leoTkinterDialog.tkinterAskYesNo(c,title,message)
    return d.run(modal=True)

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        c,title,message,yesMessage,noMessage,defaultButton)
    return d.run(modal=True)

# The compare panel has no run dialog.

# def runCompareDialog(self,c):
    # """Create and run an askYesNo dialog."""
    # if not g.app.unitTesting:
        # leoTkinterCompareDialog(c)
#@+node:ekr.20070212132230:tkGui.createSpellTab
def createSpellTab(self,c,spellHandler,tabName):

    return leoTkinterFind.tkSpellTab(c,spellHandler,tabName)
#@-node:ekr.20070212132230:tkGui.createSpellTab
#@+node:ekr.20031218072017.4057:tkGui file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.
#@+node:ekr.20060212061804:runOpenFileDialog
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""

    initialdir = g.app.globalOpenDir or g.os_path_finalize(os.getcwd())

    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        if (
            g.CheckVersion(version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)
#@-node:ekr.20060212061804:runOpenFileDialog
#@+node:ekr.20060212061804.1:runSaveFileDialog
def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    initialdir=g.app.globalOpenDir or g.os_path_finalize(os.getcwd())

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)
#@-node:ekr.20060212061804.1:runSaveFileDialog
#@-node:ekr.20031218072017.4057:tkGui file dialogs
#@+node:ekr.20031218072017.4058:tkGui panels
def createComparePanel(self,c):
    """Create a Tkinter color picker panel."""
    return leoTkinterComparePanel.leoTkinterComparePanel(c)

# def createFindPanel(self,c):
    # """Create a hidden Tkinter find panel."""
    # panel = leoTkinterFind.leoTkinterFind(c)
    # panel.top.withdraw()
    # return panel

def createFindTab (self,c,parentFrame):
    """Create a Tkinter find tab in the indicated frame."""
    return leoTkinterFind.tkFindTab(c,parentFrame)

def createLeoFrame(self,title):
    """Create a new Leo frame."""
    # g.pr('tkGui.createLeoFrame')
    gui = self
    return leoTkinterFrame.leoTkinterFrame(title,gui)
#@-node:ekr.20031218072017.4058:tkGui panels
#@-node:ekr.20031218072017.4056:tkGui dialogs & panels
#@+node:ekr.20031218072017.4059:tkGui utils
#@+node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20031218072017.845:replaceClipboardWith
def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)
#@-node:ekr.20031218072017.845:replaceClipboardWith
#@+node:ekr.20031218072017.846:getTextFromClipboard
def getTextFromClipboard (self):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None
#@-node:ekr.20031218072017.846:getTextFromClipboard
#@-node:ekr.20031218072017.844:Clipboard (tkGui)
#@+node:ekr.20061109215304:color
# g.es calls gui.color to do the translation,
# so most code in Leo's core can simply use Tk color names.

def color (self,color):
    '''Return the gui-specific color corresponding to the Tk color name.'''
    return color

#@-node:ekr.20061109215304:color
#@+node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):

    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = geom.split('+')
    w,h = dim.split('x')
    w,h,x,y = int(w),int(h),int(x),int(y)

    return w,h,x,y
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.4062:center_dialog
def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)

    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))

    return w,h,x,y
#@-node:ekr.20031218072017.4062:center_dialog
#@+node:ekr.20031218072017.4063:create_labeled_frame
# Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")

    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)

    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")

    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")

    # Add the caption.
    if caption and len(caption) > 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f
#@-node:ekr.20031218072017.4063:create_labeled_frame
#@-node:ekr.20031218072017.4060:Dialog
#@+node:ekr.20061109215734:Events (tkGui)
def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    # g.trace('tkGui','kind',kind,'w',w,'args,keys',*args,**keys)
    # g.trace(g.callers())
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''   
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0
#@nonl
#@-node:ekr.20061109215734:Events (tkGui)
#@+node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4065:tkGui.get_focus
def get_focus(self,c):

    """Returns the widget that has focus, or body if None."""

    try:
        return c.frame.top.focus_displayof()
    except Exception:
        return None
#@-node:ekr.20031218072017.4065:tkGui.get_focus
#@+node:ekr.20031218072017.2373:tk.Gui.set_focus
set_focus_count = 0

def set_focus(self,c,w):

    """Put the focus on the widget."""

    if not g.app.unitTesting and c and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        # Do not call trace here: that might affect focus!
        g.pr('gui.set_focus: %4d %10s %s' % (
            self.set_focus_count,c and c.shortFileName(),
            c and c.widget_name(w)), g.callers(5))

    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()

            # This often fails.  The focus will be delayed until later...
            # if not w != w.focus_get():
                # g.trace('*** can not happen:',repr(w),repr(w.focus_get()))
            return True
        except Exception:
            # g.es_exception()
            return False
#@-node:ekr.20031218072017.2373:tk.Gui.set_focus
#@-node:ekr.20031218072017.4064:Focus
#@+node:ekr.20031218072017.4066:Font
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):

    family_name = family

    try:
        # g.trace('tkGui','family',family,'size',size,'defaultSize',defaultSize)
        font = tkFont.Font(family=family,size=size or defaultSize,slant=slant,weight=weight)
        return font
    except:
        g.es("exception setting font from",family_name)
        g.es('','family,size,slant,weight:','',family,'',size,'',slant,'',weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@-node:ekr.20031218072017.4066:Font
#@+node:ekr.20070212144559:getFullVersion
def getFullVersion (self,c):

    tkLevel = c.frame.top.getvar("tk_patchLevel")

    return 'Tk %s, Pmw %s' % (tkLevel,Pmw.version())
#@-node:ekr.20070212144559:getFullVersion
#@+node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
def attachLeoIcon (self,w):

    """Try to attach a Leo icon to the Leo Window.

    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None

    if self.bitmap == None:
        try:
            << try to use the PIL and tkIcon packages to draw the icon >>
        except:
            # import traceback ; traceback.print_exc()
            # g.es_exception()
            self.leoIcon = None
#@+node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon # pychecker complains, but this *is* used.

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    try: self.leoIcon.attach(w.winfo_id())
    except: pass

# No commander is available here, and we don't need to call c.outerUpdate.
w.bind("<Visibility>",visibilityCallback)

if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)
#@-node:ekr.20031218072017.4069:<< try to use the PIL and tkIcon packages to draw the icon >>
#@+node:ekr.20031218072017.4070:createLeoIcon
# This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):

    try:
        import Image,_tkicon

        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None
#@-node:ekr.20031218072017.4070:createLeoIcon
#@-node:ekr.20031218072017.4068:attachLeoIcon & createLeoIcon
#@-node:ekr.20031218072017.4067:Icons
#@+node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):

    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)
#@-node:ekr.20031218072017.4073:setIdleTimeHookAfterDelay
#@-node:ekr.20031218072017.4071:Idle Time
#@+node:ekr.20051220144507:isTextWidget
def isTextWidget (self,w):

    '''Return True if w is a Text widget suitable for text-oriented commands.'''

    return w and isinstance(w,Tk.Text)
#@-node:ekr.20051220144507:isTextWidget
#@+node:ekr.20060621164312:makeScriptButton (tkGui)
def makeScriptButton (self,c,
    args=None,
    p=None, # A node containing the script.
    script=None, # The script itself.
    buttonText=None,
    balloonText='Script Button',
    shortcut=None,bg='LightSteelBlue1',
    define_g=True,define_name='__main__',silent=False, # Passed on to c.executeScript.
):

    '''Create a script button for the script in node p.
    The button's text defaults to p.headString'''

    k = c.k
    if p and not buttonText: buttonText = p.headString().strip()
    if not buttonText: buttonText = 'Unnamed Script Button'
    << create the button b >>
    << define the callbacks for b >>
    b.configure(command=executeScriptCallback)
    c.bind(b,'<Button-3>',deleteButtonCallback)
    if shortcut:
        << bind the shortcut to executeScriptCallback >>
    << create press-buttonText-button command >>
#@+node:ekr.20060621164312.1:<< create the button b >>
iconBar = c.frame.getIconBarObject()
b = iconBar.add(text=buttonText)

if balloonText and balloonText != buttonText:
    Pmw = g.importExtension('Pmw',pluginName='gui.makeScriptButton',verbose=False)
    if Pmw:
        balloon = Pmw.Balloon(b,initwait=100)
        c.bind(balloon,b,balloonText)

if sys.platform == "win32":
    width = int(len(buttonText) * 0.9)
    b.configure(width=width,font=('verdana',7,'bold'),bg=bg)
#@-node:ekr.20060621164312.1:<< create the button b >>
#@+node:ekr.20060621164312.2:<< define the callbacks for b >>
def deleteButtonCallback(event=None,b=b,c=c):
    if b: b.pack_forget()
    c.bodyWantsFocus()

def executeScriptCallback (event=None,
    args=args,b=b,c=c,buttonText=buttonText,p=p and p.copy(),script=script):

    if c.disableCommandsMessage:
        g.es('',c.disableCommandsMessage,color='blue')
    else:
        g.app.scriptDict = {}
        c.executeScript(args=args,p=p,script=script,
        define_g= define_g,define_name=define_name,silent=silent)
        # Remove the button if the script asks to be removed.
        if g.app.scriptDict.get('removeMe'):
            g.es("removing","'%s'" % (buttonText),"button at its request")
            b.pack_forget()
    # Do not assume the script will want to remain in this commander.
#@-node:ekr.20060621164312.2:<< define the callbacks for b >>
#@+node:ekr.20060621164312.3:<< bind the shortcut to executeScriptCallback >>
func = executeScriptCallback
shortcut = k.canonicalizeShortcut(shortcut)
ok = k.bindKey ('button', shortcut,func,buttonText)
if ok:
    g.es_print('bound @button',buttonText,'to',shortcut,color='blue')
#@-node:ekr.20060621164312.3:<< bind the shortcut to executeScriptCallback >>
#@+node:ekr.20060621164312.4:<< create press-buttonText-button command >>
aList = [g.choose(ch.isalnum(),ch,'-') for ch in buttonText]

buttonCommandName = ''.join(aList)
buttonCommandName = buttonCommandName.replace('--','-')
buttonCommandName = 'press-%s-button' % buttonCommandName.lower()

# This will use any shortcut defined in an @shortcuts node.
k.registerCommand(buttonCommandName,None,executeScriptCallback,pane='button',verbose=False)
#@-node:ekr.20060621164312.4:<< create press-buttonText-button command >>
#@-node:ekr.20060621164312:makeScriptButton (tkGui)
#@+node:bobjack.20080427200147.2:killPopupMenu
def killPopupMenu(self, event=None):
    """If there is a popup menu, destroy it."""

    if event:
        g.trace('focusout')

    try:
        menu = self.lastPopupMenu
        try:
            menu.unpost()
        finally:
            menu.destroy()
    except:
        pass


#@-node:bobjack.20080427200147.2:killPopupMenu
#@+node:bobjack.20080428071655.3:postPopupMenu
def postPopupMenu(self, c, m, x, y):

    """Post a popup menu after killing any previous menu."""

    self.killPopupMenu()
    self.lastPopupMenu = m

    try:
        m.post(x, y)
    except:
        pass

#@-node:bobjack.20080428071655.3:postPopupMenu
#@-node:ekr.20031218072017.4059:tkGui utils
#@+node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c):

        # g.trace('leoKeyEvent(tkGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.state  = hasattr(event,'state') and event.state or 0
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        self.widget = self.w

    def __repr__ (self):

        return 'tkGui.leoKeyEvent: char: %s, keysym: %s' % (repr(self.char),repr(self.keysym))
#@nonl
#@-node:ekr.20061112152012.2:class leoKeyEvent (tkGui)
#@-node:ekr.20031218072017.4047:@@thin leoTkinterGui.py
#@+node:ekr.20031218072017.4099:@@thin leoTkinterKeys.py
"""Tkinter keystroke handling for Leo."""

@language python
@tabwidth -4
@pagewidth 80

# import Tkinter as Tk
import leo.core.leoKeys as leoKeys

class tkinterKeyHandlerClass (leoKeys.keyHandlerClass):
    '''Tkinter overrides of base keyHandlerClass.'''
    @others
#@nonl
#@+node:ekr.20061031170011:tkKeys.ctor
def __init__(self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    # Init the base class.
    leoKeys.keyHandlerClass.__init__(self,c,useGlobalKillbuffer,useGlobalRegisters)

    # Create
    self.createTkIvars()
#@-node:ekr.20061031170011:tkKeys.ctor
#@+node:ekr.20061031170011.1:createTkIvars
def createTkIvars(self):

    pass
#@-node:ekr.20061031170011.1:createTkIvars
#@+node:ekr.20070613190239:tkKeys.propagateKeyEvent
def propagateKeyEvent (self,event):
    return 'continue'
#@nonl
#@-node:ekr.20070613190239:tkKeys.propagateKeyEvent
#@-node:ekr.20031218072017.4099:@@thin leoTkinterKeys.py
#@+node:ekr.20031218072017.4100:@@thin leoTkinterMenu.py
"""Tkinter menu handling for Leo."""

@language python
@tabwidth -4
@pagewidth 80

import leo.core.leoGlobals as g
import leo.core.leoMenu as leoMenu
import Tkinter as Tk
import tkFont

class leoTkinterMenu (leoMenu.leoMenu):
    """A class that represents a Leo window."""
    @others
#@+node:ekr.20031218072017.4101:Birth & death
#@+node:ekr.20031218072017.4102:leoTkinterMenu.__init__
def __init__ (self,frame):

    # Init the base class.
    leoMenu.leoMenu.__init__(self,frame)

    self.top = frame.top
    self.c = c = frame.c
    self.frame = frame

    self.font = c.config.getFontFromParams(
        'menu_text_font_family', 'menu_text_font_size',
        'menu_text_font_slant',  'menu_text_font_weight',
        c.config.defaultMenuFontSize)
#@-node:ekr.20031218072017.4102:leoTkinterMenu.__init__
#@-node:ekr.20031218072017.4101:Birth & death
#@+node:ekr.20060211101811:Activate menu commands
#@+node:ekr.20060211100905.1:tkMenu.activateMenu
def activateMenu (self,menuName):

    c = self.c ;  top = c.frame.top
    topx,topy = top.winfo_rootx(),top.winfo_rooty()
    menu = c.frame.menu.getMenu(menuName)

    if menu:
        d = self.computeMenuPositions()
        x = d.get(menuName)
        if x is None:
            x = 0 ; g.trace('oops, no menu offset: %s' % menuName)

        menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
    else:
        g.trace('oops, no menu: %s' % menuName)
#@-node:ekr.20060211100905.1:tkMenu.activateMenu
#@+node:ekr.20060210133835.1:tkMenu.computeMenuPositions
def computeMenuPositions (self):

    # A hack.  It would be better to set this when creating the menus.
    menus = ('File','Edit','Outline','Plugins','Cmds','Window','Help')

    # Compute the *approximate* x offsets of each menu.
    d = {}
    n = 0
    for z in menus:
        menu = self.getMenu(z)
        fontName = menu.cget('font')
        font = tkFont.Font(font=fontName)
        # g.pr('%8s' % (z),menu.winfo_reqwidth(),menu.master,menu.winfo_x())
        d [z] = n
        # A total hack: sorta works on windows.
        n += font.measure(z+' '*4)+1

    return d
#@-node:ekr.20060210133835.1:tkMenu.computeMenuPositions
#@-node:ekr.20060211101811:Activate menu commands
#@+node:ekr.20031218072017.4103:Tkinter menu bindings
# See the Tk docs for what these routines are to do
#@+node:ekr.20031218072017.4104:Methods with Tk spellings
#@+node:ekr.20031218072017.4105:add_cascade
def add_cascade (self,parent,label,menu,underline):

    """Wrapper for the Tkinter add_cascade menu method."""

    if parent:
        return parent.add_cascade(label=label,menu=menu,underline=underline)
#@-node:ekr.20031218072017.4105:add_cascade
#@+node:ekr.20031218072017.4106:add_command
def add_command (self,menu,**keys):

    """Wrapper for the Tkinter add_command menu method."""

    if menu:
        return self.c.add_command(menu,**keys)
#@-node:ekr.20031218072017.4106:add_command
#@+node:ekr.20031218072017.4107:add_separator
def add_separator(self,menu):

    """Wrapper for the Tkinter add_separator menu method."""

    if menu:
        menu.add_separator()
#@-node:ekr.20031218072017.4107:add_separator
#@+node:ekr.20031218072017.4108:bind (not called)
def bind (self,bind_shortcut,callback):

    """Wrapper for the Tkinter bind menu method."""

    g.trace(bind_shortcut,g.callers())

    c = self.c

    return c.bind(self.top,bind_shortcut,callback)
#@-node:ekr.20031218072017.4108:bind (not called)
#@+node:ekr.20031218072017.4109:delete
def delete (self,menu,realItemName):

    """Wrapper for the Tkinter delete menu method."""

    if menu:
        return menu.delete(realItemName)
#@-node:ekr.20031218072017.4109:delete
#@+node:ekr.20031218072017.4110:delete_range
def delete_range (self,menu,n1,n2):

    """Wrapper for the Tkinter delete menu method."""

    if menu:
        return menu.delete(n1,n2)
#@-node:ekr.20031218072017.4110:delete_range
#@+node:ekr.20031218072017.4111:destroy
def destroy (self,menu):

    """Wrapper for the Tkinter destroy menu method."""

    if menu:
        return menu.destroy()
#@-node:ekr.20031218072017.4111:destroy
#@+node:ekr.20070124150514:insert
def insert (self,menuName,position,label,command,underline=None):

    menu = self.getMenu(menuName)
    if menu:
        if underline is None:
            menu.insert(position,'command',label=label,command=command)
        else:
            menu.insert(position,'command',label=label,command=command,underline=underline)
#@-node:ekr.20070124150514:insert
#@+node:ekr.20031218072017.4112:insert_cascade
def insert_cascade (self,parent,index,label,menu,underline):

    """Wrapper for the Tkinter insert_cascade menu method."""

    if parent:
        return parent.insert_cascade(
            index=index,label=label,
            menu=menu,underline=underline)
#@-node:ekr.20031218072017.4112:insert_cascade
#@+node:ekr.20031218072017.4113:new_menu
def new_menu(self,parent,tearoff=False):

    """Wrapper for the Tkinter new_menu menu method."""

    if self.font:
        try:
            return Tk.Menu(parent,tearoff=tearoff,font=self.font)
        except Exception:
            g.es_exception()
            return Tk.Menu(parent,tearoff=tearoff)
    else:
        return Tk.Menu(parent,tearoff=tearoff)
#@-node:ekr.20031218072017.4113:new_menu
#@-node:ekr.20031218072017.4104:Methods with Tk spellings
#@+node:ekr.20031218072017.4114:Methods with other spellings (Tkmenu)
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):

    if not menu:
        return

    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@-node:ekr.20041228063406:clearAccel
#@+node:ekr.20031218072017.4115:createMenuBar (Tkmenu)
def createMenuBar(self,frame):

    top = frame.top

    # Note: font setting has no effect here.
    topMenu = Tk.Menu(top,postcommand=self.updateAllMenus)

    # Do gui-independent stuff.
    self.setMenu("top",topMenu)
    self.createMenusFromTables()

    top.config(menu=topMenu) # Display the menu.
#@nonl
#@-node:ekr.20031218072017.4115:createMenuBar (Tkmenu)
#@+node:ekr.20051022042645:createOpenWithMenu
def createOpenWithMenu(self,parent,label,index,amp_index):

    '''Create a submenu.'''

    menu = Tk.Menu(parent,tearoff=0)
    if menu:
        parent.insert_cascade(index,label=label,menu=menu,underline=amp_index)
    return menu
#@-node:ekr.20051022042645:createOpenWithMenu
#@+node:ekr.20031218072017.4119:disableMenu
def disableMenu (self,menu,name):

    if not menu:
        return

    try:
        menu.entryconfig(name,state="disabled")
    except: 
        try:
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            menu.entryconfig(realName,state="disabled")
        except:
            g.pr("disableMenu menu,name:",menu,name)
            g.es_exception()
#@-node:ekr.20031218072017.4119:disableMenu
#@+node:ekr.20031218072017.4120:enableMenu
# Fail gracefully if the item name does not exist.

def enableMenu (self,menu,name,val):

    if not menu:
        return

    state = g.choose(val,"normal","disabled")
    try:
        menu.entryconfig(name,state=state)
    except:
        try:
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            menu.entryconfig(realName,state=state)
        except:
            g.pr("enableMenu menu,name,val:",menu,name,val)
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4120:enableMenu
#@+node:ekr.20060622075612:getMenuLabel
def getMenuLabel (self,menu,name):

    '''Return the index of the menu item whose name (or offset) is given.
    Return None if there is no such menu item.'''

    try:
        index = menu.index(name)
    except:
        index = None

    return index
#@-node:ekr.20060622075612:getMenuLabel
#@+node:ekr.20031218072017.4121:setMenuLabel
def setMenuLabel (self,menu,name,label,underline=-1):

    if not menu:
        return

    try:
        if type(name) == type(0):
            # "name" is actually an index into the menu.
            menu.entryconfig(name,label=label,underline=underline)
        else:
            # Bug fix: 2/16/03: use translated name.
            realName = self.getRealMenuName(name)
            realName = realName.replace("&","")
            # Bug fix: 3/25/03" use tranlasted label.
            label = self.getRealMenuName(label)
            label = label.replace("&","")
            menu.entryconfig(realName,label=label,underline=underline)
    except:
        if not g.app.unitTesting:
            g.pr("setMenuLabel menu,name,label:",menu,name,label)
            g.es_exception()
#@-node:ekr.20031218072017.4121:setMenuLabel
#@-node:ekr.20031218072017.4114:Methods with other spellings (Tkmenu)
#@-node:ekr.20031218072017.4103:Tkinter menu bindings
#@+node:ekr.20071220094941:getMacHelpMenu
def getMacHelpMenu (self,table):

    defaultTable = [
            # &: a,b,c,d,e,f,h,l,m,n,o,p,r,s,t,u
            ('&About Leo...',           'about-leo'),
            ('Online &Home Page',       'open-online-home'),
            '*open-online-&tutorial',
            '*open-&users-guide',
            '-',
            ('Open Leo&Docs.leo',       'open-leoDocs-leo'),
            ('Open Leo&Plugins.leo',    'open-leoPlugins-leo'),
            ('Open Leo&Settings.leo',   'open-leoSettings-leo'),
            ('Open &myLeoSettings.leo', 'open-myLeoSettings-leo'),
            ('Open scr&ipts.leo',       'open-scripts-leo'),
            '-',
            '*he&lp-for-minibuffer',
            '*help-for-&command',
            '-',
            '*&apropos-autocompletion',
            '*apropos-&bindings',
            '*apropos-&debugging-commands',
            '*apropos-&find-commands',
            '-',
            '*pri&nt-bindings',
            '*print-c&ommands',
        ]

    try:
        topMenu = self.getMenu('top')
        # Use the name argument to create the special Macintosh Help menu.
        helpMenu = Tk.Menu(topMenu,name='help',tearoff=0)
        self.add_cascade(topMenu,label='Help',menu=helpMenu,underline=0)
        self.createMenuEntries(helpMenu,table or defaultTable)
        return helpMenu

    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20071220094941:getMacHelpMenu
#@-node:ekr.20031218072017.4100:@@thin leoTkinterMenu.py
#@+node:ekr.20040803072955:@@thin leoTkinterTree.py
'''Override outline drawing code to test optimized drawing

This class implements a tree control similar to Windows explorer.

The code is based on code found in Python's IDLE program.'''

@language python
@tabwidth -4
@pagewidth 80

<< about drawing >>
<< imports >>

class leoTkinterTree (leoFrame.leoTree):

    """Leo tkinter tree class."""

    callbacksInjected = False

    @others
#@+node:ekr.20040803072955.1:  << About drawing >>
@

New in Leo 4.5: The 'Newest World Order':

- Redrawing the screen and setting focus only happen in c.outerUpdate.
- c.redraw only requests a redraw.
- c.redraw_now is equivalent to c.redraw() followed by c.outerUpdate.
- c.beginUpdate does nothing.  c.endUpdate(False) does nothing.
- c.endUpdate() is equivalent to c.redraw()
- There is no longer any need to ensure c.endUpdate is called for every c.beginUpdate.
  Thus, there is no need for the associated try/finally statements.
#@-node:ekr.20040803072955.1:  << About drawing >>
#@+node:ekr.20040928101836:<< imports >>
import leo.core.leoGlobals as g

if g.app and g.app.use_psyco:
    # g.pr("enabled psyco classes",__file__)
    try: from psyco.classes import *
    except ImportError: pass

Pmw = g.importExtension("Pmw",pluginName='LeoTkinterTree',verbose=True,required=True)

import leo.core.leoFrame as leoFrame
import Tkinter as Tk
import tkFont

# import sys
#@-node:ekr.20040928101836:<< imports >>
#@+node:ekr.20040803072955.2:  Notes
@killcolor
#@+node:ekr.20040803072955.3:Changes made since first update
@

- disabled drawing of user icons.  They weren't being hidden, which messed up scrolling.

- Expanded clickBox so all clicks fall inside it.

- Added binding for plugBox so it doesn't interfere with the clickBox.  Another weirdness.

- Re-enabled code in drawText that sets the headline state.

- eventToPosition now returns p.copy, which means that nobody can change the list.

- Likewise, clear self.iconIds so old icon id's don't confuse findVnodeWithIconId.

- All drawing methods must do p = p.copy() at the beginning if they make any changes to p.
    - This ensures neither they nor their allies can change the caller's position.
    - In fact, though, only drawTree changes position.  It makes a copy before calling drawNode.
    *** Therefore, all positions in the drawing code are immutable!

- Fixed the race conditions that caused drawing sometimes to fail.  The essential idea is that we must not call w.config if we are about to do a redraw.  For full details, see the Notes node in the Race Conditions section.
#@-node:ekr.20040803072955.3:Changes made since first update
#@+node:ekr.20040803072955.4:Changes made since second update
@

- Removed duplicate code in tree.select.  The following code was being called twice (!!):
    self.endEditLabel()
    self.setUnselectedLabelState(old_p)

- Add p.copy() instead of p when inserting nodes into data structures in select.

- Fixed a _major_ bug in Leo's core.  c.setCurrentPosition must COPY the position given to it!  It's _not_ enough to return a copy of position: it may already have changed!!

- Fixed a another (lesser??) bug in Leo's core.  handleUserClick should also make a copy.

- Fixed bug in mod_scripting.py.  The callback was failing if the script was empty.

- Put in the self.recycle ivar AND THE CODE STILL FAILS.
    It seems to me that this shows there is a bug in my code somewhere, but where ???????????????????
#@-node:ekr.20040803072955.4:Changes made since second update
#@+node:ekr.20040803072955.5:Most recent changes
@

- Added generation count.
    - Incremented on each redraw.
    - Potentially a barrior to race conditions, but it never seemed to do anything.
    - This code is a candidate for elimination.

- Used vnodes rather than positions in several places.
    - I actually don't think this was involved in the real problem, and it doesn't hurt.

- Added much better traces: the beginning of the end for the bugs :-)
    - Added self.verbose option.
    - Added align keyword option to g.trace.
    - Separate each set of traces by a blank line.
        - This makes clear the grouping of id's.

- Defensive code: Disable dragging at start of redraw code.
    - This protects against race conditions.

- Fixed blunder 1: Fixed a number of bugs in the dragging code.
    - I had never looked at this code!
    - Eliminating false drags greatly simplifies matters.

- Fixed blunder 2: Added the following to eventToPosition:
        x = canvas.canvasx(x)
        y = canvas.canvasy(y)
    - Apparently this was the cause of false associations between icons and id's.
    - It's amazing that the code didn't fail earlier without these!

- Converted all module-level constants to ivars.

- Lines no longer interfere with eventToPosition.
    - The problem was that find_nearest or find_overlapping don't depend on stacking order!
    - Added p param to horizontal lines, but not vertical lines.
    - EventToPosition adds 1 to the x coordinate of vertical lines, then recomputes the id.

- Compute indentation only in forceDrawNode.  Removed child_indent constant.

- Simplified drawTree to use indentation returned from forceDrawNode.

- setHeadlineText now ensures that state is "normal" before attempting to set the text.
    - This is the robust way.

7/31/04: newText must call setHeadlineText for all nodes allocated, even if p matches.
#@-node:ekr.20040803072955.5:Most recent changes
#@-node:ekr.20040803072955.2:  Notes
#@+node:ekr.20040803072955.15: Birth... (tkTree)
#@+node:ekr.20040803072955.16:__init__ (tkTree)
def __init__(self,c,frame,canvas):

    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Configuration and debugging settings.
    # These must be defined here to eliminate memory leaks.
    self.allow_clone_drags          = c.config.getBool('allow_clone_drags')
    self.center_selected_tree_node  = c.config.getBool('center_selected_tree_node')
    self.enable_drag_messages       = c.config.getBool("enable_drag_messages")
    self.expanded_click_area        = c.config.getBool('expanded_click_area')
    self.gc_before_redraw           = c.config.getBool('gc_before_redraw')

    self.headline_text_editing_foreground_color = c.config.getColor(
        'headline_text_editing_foreground_color')
    self.headline_text_editing_background_color = c.config.getColor(
        'headline_text_editing_background_color')
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        'headline_text_editing_selection_foreground_color')
    self.headline_text_editing_selection_background_color = c.config.getColor(
        'headline_text_editing_selection_background_color')
    self.headline_text_selected_foreground_color = c.config.getColor(
        "headline_text_selected_foreground_color")
    self.headline_text_selected_background_color = c.config.getColor(
        "headline_text_selected_background_color")
    self.headline_text_editing_selection_foreground_color = c.config.getColor(
        "headline_text_editing_selection_foreground_color")
    self.headline_text_editing_selection_background_color = c.config.getColor(
        "headline_text_editing_selection_background_color")
    self.headline_text_unselected_foreground_color = c.config.getColor(
        'headline_text_unselected_foreground_color')
    self.headline_text_unselected_background_color = c.config.getColor(
        'headline_text_unselected_background_color')

    self.idle_redraw = c.config.getBool('idle_redraw')
    self.initialClickExpandsOrContractsNode = c.config.getBool(
        'initialClickExpandsOrContractsNode')
    self.look_for_control_drag_on_mouse_down = c.config.getBool(
        'look_for_control_drag_on_mouse_down')
    self.select_all_text_when_editing_headlines = c.config.getBool(
        'select_all_text_when_editing_headlines')

    self.stayInTree     = c.config.getBool('stayInTreeAfterSelect')
    self.trace          = c.config.getBool('trace_tree')
    self.trace_alloc    = c.config.getBool('trace_tree_alloc')
    self.trace_chapters = c.config.getBool('trace_chapters')
    self.trace_edit     = c.config.getBool('trace_tree_edit')
    self.trace_gc       = c.config.getBool('trace_tree_gc')
    self.trace_redraw   = c.config.getBool('trace_tree_redraw')
    self.trace_select   = c.config.getBool('trace_select')
    self.trace_stats    = c.config.getBool('show_tree_stats')
    self.use_chapters   = c.config.getBool('use_chapters')

    # Objects associated with this tree.
    self.canvas = canvas

    << define drawing constants >>
    << old ivars >>
    << inject callbacks into the position class >>

    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.

    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount <= 0
    self.verbose = True

    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()

    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Dictionaries of free, hidden widgets...
    # Keys are id's, values are widgets.
    self.freeBoxes = {}
    self.freeClickBoxes = {}
    self.freeIcons = {}
    self.freeLines = {}
    self.freeText = {} # New in 4.4b2: a list of free Tk.Text widgets

    self.freeUserIcons = {}

    self._block_canvas_menu = False
#@nonl
#@+node:ekr.20040803072955.17:<< define drawing constants >>
self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height
#@-node:ekr.20040803072955.17:<< define drawing constants >>
#@+node:ekr.20040803072955.18:<< old ivars >>
# Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if present headline is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = 0.0
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    c.bind(self.frame.bar1,"<Button-1-ButtonRelease>", self.redraw_now)
#@-node:ekr.20040803072955.18:<< old ivars >>
#@+node:ekr.20040803072955.19:<< inject callbacks into the position class >>
# The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()
#@-node:ekr.20040803072955.19:<< inject callbacks into the position class >>
#@-node:ekr.20040803072955.16:__init__ (tkTree)
#@+node:ekr.20051024102724:tkTtree.setBindings & helper
def setBindings (self,):

    '''Create master bindings for all headlines.'''

    tree = self ; k = self.c.k

    # g.trace('self',self,'canvas',self.canvas)

    tree.setBindingsHelper()

    tree.setCanvasBindings(self.canvas)

    k.completeAllBindingsForWidget(self.canvas)

    k.completeAllBindingsForWidget(self.bindingWidget)

#@+node:ekr.20060131173440:tkTree.setBindingsHelper
def setBindingsHelper (self):

    tree = self ; c = tree.c ; k = c.k

    self.bindingWidget = w = g.app.gui.plainTextWidget(
        self.canvas,name='bindingWidget')

    c.bind(w,'<Key>',k.masterKeyHandler)

    table = [
        ('<Button-1>',       k.masterClickHandler,          tree.onHeadlineClick),
        ('<Button-3>',       k.masterClick3Handler,         tree.onHeadlineRightClick),
        ('<Double-Button-1>',k.masterDoubleClickHandler,    tree.onHeadlineClick),
        ('<Double-Button-3>',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
    ]

    for a,handler,func in table:
        def treeBindingCallback(event,handler=handler,func=func):
            # g.trace('func',func)
            return handler(event,func)
        c.bind(w,a,treeBindingCallback)

    self.textBindings = w.bindtags()
#@-node:ekr.20060131173440:tkTree.setBindingsHelper
#@-node:ekr.20051024102724:tkTtree.setBindings & helper
#@+node:ekr.20070327103016:tkTree.setCanvasBindings
def setCanvasBindings (self,canvas):

    c = self.c ; k = c.k

    c.bind(canvas,'<Key>',k.masterKeyHandler)
    c.bind(canvas,'<Button-1>',self.onTreeClick)
    c.bind(canvas,'<Button-3>',self.onTreeRightClick)
    # c.bind(canvas,'<FocusIn>',self.onFocusIn)

    << make bindings for tagged items on the canvas >>
    << create baloon bindings for tagged items on the canvas >>
#@nonl
#@+node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '<Button-1>',self.onClickBoxClick),
    ('iconBox','<Button-1>',self.onIconBoxClick),
    ('iconBox','<Double-1>',self.onIconBoxDoubleClick),
    ('iconBox','<Button-3>',self.onIconBoxRightClick),
    ('iconBox','<Double-3>',self.onIconBoxRightClick),
    ('iconBox','<B1-Motion>',self.onDrag),
    ('iconBox','<Any-ButtonRelease-1>',self.onEndDrag),

    ('plusBox','<Button-3>', self.onPlusBoxRightClick),
    ('plusBox','<Button-1>', self.onClickBoxClick),
    ('clickBox','<Button-3>',  self.onClickBoxRightClick),
)
for tag,event_kind,callback in table:
    c.tag_bind(canvas,tag,event_kind,callback)
#@-node:ekr.20060131173440.2:<< make bindings for tagged items on the canvas >>
#@+node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
if 0: # I find these very irritating.
    for tag,text in (
        # ('plusBox','plusBox'),
        ('iconBox','Icon Box'),
        ('selectBox','Click to select'),
        ('clickBox','Click to expand or contract'),
        # ('textBox','Headline'),
    ):
        # A fairly long wait is best.
        balloon = Pmw.Balloon(self.canvas,initwait=700)
        balloon.tagbind(self.canvas,tag,balloonHelp=text)
#@-node:ekr.20060307080642:<< create baloon bindings for tagged items on the canvas >>
#@-node:ekr.20070327103016:tkTree.setCanvasBindings
#@-node:ekr.20040803072955.15: Birth... (tkTree)
#@+node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20040803072955.7:newBox
def newBox (self,p,x,y,image):

    canvas = self.canvas ; tag = "plusBox"

    if self.freeBoxes:
        # theId = self.freeBoxes.pop(0)
        d = self.freeBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleBoxes: 
        self.visibleBoxes.append(theId)

    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.7:newBox
#@+node:ekr.20040803072955.8:newClickBox
def newClickBox (self,p,x1,y1,x2,y2):

    canvas = self.canvas ; defaultColor = ""
    tag = g.choose(p.hasChildren(),'clickBox','selectBox')

    if self.freeClickBoxes:
        # theId = self.freeClickBoxes.pop(0)
        d = self.freeClickBoxes ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
        canvas.itemconfig(theId,tag=tag)
    else:
        theId = self.canvas.create_rectangle(x1,y1,x2,y2,tag=tag)
        canvas.itemconfig(theId,fill=defaultColor,outline=defaultColor)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleClickBoxes:
        self.visibleClickBoxes.append(theId)
    if p:
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.8:newClickBox
#@+node:ekr.20040803072955.9:newIcon
def newIcon (self,p,x,y,image):

    canvas = self.canvas ; tag = "iconBox"

    if self.freeIcons:
        # theId = self.freeIcons.pop(0)
        d = self.freeIcons ; theId = d.keys()[0] ; del d[theId]
        canvas.itemconfigure(theId,image=image)
        canvas.coords(theId,x,y)
    else:
        theId = canvas.create_image(x,y,image=image,anchor="nw",tag=tag)
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if theId not in self.visibleIcons:
        self.visibleIcons.append(theId)

    if p:
        data = p,self.generation
        self.iconIds[theId] = data # Remember which vnode belongs to the icon.
        self.ids[theId] = p

    return theId
#@-node:ekr.20040803072955.9:newIcon
#@+node:ekr.20040803072955.10:newLine
def newLine (self,p,x1,y1,x2,y2):

    canvas = self.canvas

    if self.freeLines:
        # theId = self.freeLines.pop(0)
        d = self.freeLines ; theId = d.keys()[0] ; del d[theId]
        canvas.coords(theId,x1,y1,x2,y2)
    else:
        theId = canvas.create_line(x1,y1,x2,y2,tag="lines",fill="gray50") # stipple="gray25")
        if self.trace_alloc: g.trace("%3d %s" % (theId,p and p.headString()),align=-20)

    if p:
        self.ids[theId] = p

    if theId not in self.visibleLines:
        self.visibleLines.append(theId)

    return theId
#@-node:ekr.20040803072955.10:newLine
#@+node:ekr.20040803072955.11:newText (tkTree) and helper
def newText (self,p,x,y):

    canvas = self.canvas ; tag = "textBox"
    c = self.c ;  k = c.k
    if self.freeText:
        # w,theId = self.freeText.pop()
        d = self.freeText ; data = d.keys()[0] ; w,theId = data ; del d[data]
        canvas.coords(theId,x,y) # Make the window visible again.
            # theId is the id of the *window* not the text.
    else:
        # Tags are not valid in Tk.Text widgets.
        self.textNumber += 1
        w = g.app.gui.plainTextWidget(
            canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
        w.bindtags(self.textBindings) # Set the bindings for this widget.

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>

        theId = canvas.create_window(x,y,anchor="nw",window=w,tag=tag)
        w.leo_window_id = theId # Never changes.

        if self.trace_alloc: g.trace('%3d %6s' % (theId,id(w)),align=-20)

    # Common configuration.
    if 0: # Doesn't seem to work.
        balloon = Pmw.Balloon(canvas,initwait=700)
        balloon.tagbind(canvas,theId,balloonHelp='Headline')

    if p:
        self.ids[theId] = p # Add the id of the *window*
        self.setHeadlineText(theId,w,p.headString())
        w.configure(width=self.headWidth(p=p))
        w.leo_position = p # This p never changes.
            # *Required*: onHeadlineClick uses w.leo_position to get p.

        # Keys are p.key().  Entries are (w,theId)
        self.visibleText [p.key()] = w,theId
    else:
        g.trace('**** can not happen.  No p')

    return w
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

instance_tag = w.bindtags()[0]
w.bind_class(instance_tag, "<Button-4>", PropagateButton4)
w.bind_class(instance_tag, "<Button-5>", PropagateButton5)
w.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@+node:ekr.20040803072955.32:tree.setHeadlineText
def setHeadlineText (self,theId,w,s):

    """All changes to text widgets should come here."""

    # if self.trace_alloc: g.trace('%4d %6s %s' % (theId,self.textAddr(w),s),align=-20)

    state = w.cget("state")
    if state != "normal":
        w.configure(state="normal")
    w.delete(0,"end")
    # Important: do not allow newlines in headlines.
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]
    w.insert("end",s)
    # g.trace(repr(s))
    if state != "normal":
        w.configure(state=state)
#@-node:ekr.20040803072955.32:tree.setHeadlineText
#@-node:ekr.20040803072955.11:newText (tkTree) and helper
#@+node:ekr.20040803072955.12:recycleWidgets
def recycleWidgets (self):

    canvas = self.canvas

    for theId in self.visibleBoxes:
        # if theId not in self.freeBoxes:
            # self.freeBoxes.append(theId)
        self.freeBoxes[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleBoxes = []

    for theId in self.visibleClickBoxes:
        # if theId not in self.freeClickBoxes:
            # self.freeClickBoxes.append(theId)
        self.freeClickBoxes[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleClickBoxes = []

    for theId in self.visibleIcons:
        # if theId not in self.freeIcons:
            # self.freeIcons.append(theId)
        self.freeIcons[theId] = theId
        canvas.coords(theId,-100,-100)
    self.visibleIcons = []

    for theId in self.visibleLines:
        # if theId not in self.freeLines:
            # self.freeLines.append(theId)
        self.freeLines[theId] = theId
        canvas.coords(theId,-100,-100,-100,-100)
    self.visibleLines = []

    aList = self.visibleText.values()
    for data in aList:
        w,theId = data
        # assert theId == w.leo_window_id
        canvas.coords(theId,-100,-100)
        w.leo_position = None # Allow the position to be freed.
        # if data not in self.freeText:
            # self.freeText.append(data)
        self.freeText[data] = data
    self.visibleText = {}

    # g.trace('deleting visible user icons!')
    for theId in self.visibleUserIcons:
        # The present code does not recycle user Icons.
        self.canvas.delete(theId)
    self.visibleUserIcons = []
#@-node:ekr.20040803072955.12:recycleWidgets
#@+node:ekr.20040803072955.13:destroyWidgets
def destroyWidgets (self):

    self.ids = {}

    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleUserIcons = []

    self.visibleText = {}

    self.freeText = {}
    self.freeBoxes = {}
    self.freeClickBoxes = {}
    self.freeIcons = {}
    self.freeLines = {}

    self.canvas.delete("all")
#@-node:ekr.20040803072955.13:destroyWidgets
#@+node:ekr.20060202125419:showStats
def showStats (self):

    z = []
    for kind,a,b in (
        ('boxes',self.visibleBoxes,self.freeBoxes),
        ('clickBoxes',self.visibleClickBoxes,self.freeClickBoxes),
        ('icons',self.visibleIcons,self.freeIcons),
        ('lines',self.visibleLines,self.freeLines),
        ('tesxt',self.visibleText.values(),self.freeText),
    ):
        z.append('%10s used: %4d free: %4d' % (kind,len(a),len(b)))

    s = '\n' + '\n'.join(z)
    g.es_print('',s)
#@-node:ekr.20060202125419:showStats
#@-node:ekr.20040803072955.6:Allocation...
#@+node:ekr.20040803072955.26:Config & Measuring...
#@+node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font

def setFont (self,font=None, fontName=None):

    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font

    self.setLineHeight(self.font)

# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    # g.trace()
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize)

    self.setFont(font)
#@-node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20040803072955.28:headWidth & widthInPixels
def headWidth(self,p=None,s=''):

    """Returns the proper width of the entry widget for the headline."""

    if p: s = p.headString()

    return self.font.measure(s)/self.font.measure('0')+1


def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)

    return self.font.measure(s)
#@-node:ekr.20040803072955.28:headWidth & widthInPixels
#@+node:ekr.20040803072955.29:setLineHeight
def setLineHeight (self,font):

    try:
        metrics = font.metrics()
        linespace = metrics ["linespace"]
        self.line_height = linespace + 5 # Same as before for the default font on Windows.
        # g.pr(metrics)
    except:
        self.line_height = self.default_line_height
        g.es("exception setting outline line height")
        g.es_exception()
#@-node:ekr.20040803072955.29:setLineHeight
#@-node:ekr.20040803072955.26:Config & Measuring...
#@+node:ekr.20040803072955.31:Debugging...
#@+node:ekr.20040803072955.33:textAddr
def textAddr(self,w):

    """Return the address part of repr(Tk.Text)."""

    s = repr(w)
    i = s.find('id: ')
    if i != -1:
        return s[i+4:i+12].lower()
    else:
        return s
#@-node:ekr.20040803072955.33:textAddr
#@+node:ekr.20040803072955.34:traceIds (Not used)
# Verbose tracing is much more useful than this because we can see the recent past.

def traceIds (self,full=False):

    tree = self

    for theDict,tag,flag in ((tree.ids,"ids",True),(tree.iconIds,"icon ids",False)):
        g.pr('=' * 60)
        g.pr("\n%s..." % tag)
        for key in sorted(theDict):
            p = tree.ids.get(key)
            if p is None: # For lines.
                g.pr("%3d None" % key)
            else:
                g.pr("%3d" % key,p.headString())
        if flag and full:
            g.pr('-' * 40)
            seenValues = {}
            for key in sorted(theDict):
                value = theDict.get(key)
                if value not in seenValues:
                    seenValues[value]=True
                    for item in theDict.items():
                        key,val = item
                        if val and val == value:
                            g.pr("%3d" % key,val.headString())
#@-node:ekr.20040803072955.34:traceIds (Not used)
#@-node:ekr.20040803072955.31:Debugging...
#@+node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20051216155728:tree.begin/endUpdate
def beginUpdate (self):

    self.updateCount += 1
    # g.trace('tree',id(self),self.updateCount,g.callers())

def endUpdate (self,flag,scroll=False):

    self.updateCount -= 1
    # g.trace(self.updateCount,'scroll',scroll,g.callers())

    if self.updateCount <= 0:
        if flag:
            self.redraw_now(scroll=scroll)
        if self.updateCount < 0:
            g.trace("Can't happen: negative updateCount",g.callers())
#@-node:ekr.20051216155728:tree.begin/endUpdate
#@+node:ekr.20040803072955.58:tree.redraw_now & helper
# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False,forceDraw=False):

    '''Redraw immediately: used by Find so a redraw doesn't mess up selections in headlines.'''

    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return

    c = self.c

    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary()
        if self.trace_redraw or self.trace_alloc:
            # g.trace(self.redrawCount,g.callers())
            # g.trace(c.rootPosition().headString(),'canvas:',id(self.canvas),g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()

    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    if self.idle_redraw:
        def idleRedrawCallback(event=None,self=self,scroll=scroll):
            self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
        self.canvas.after_idle(idleRedrawCallback)
    else:
        self.redrawHelper(scroll=scroll,forceDraw=forceDraw)
    if g.app.unitTesting:
        self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()

redraw = redraw_now # Compatibility
#@+node:ekr.20040803072955.59:redrawHelper
def redrawHelper (self,scroll=True,forceDraw=False):

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.frame not in g.app.windowList:
        return
    if self.drag_p and not forceDraw:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; trace = False
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):

        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        bbox = self.canvas.bbox('all')
        if trace: g.trace('bbox',bbox,g.callers())
        if bbox is None:
            x0,y0,x1,y1 = 0,0,100,100
        else:
            x0, y0, x1, y1 = bbox
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()

    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@-node:ekr.20040803072955.59:redrawHelper
#@-node:ekr.20040803072955.58:tree.redraw_now & helper
#@+node:ekr.20040803072955.61:idle_second_redraw
def idle_second_redraw (self):

    c = self.c

    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)

    if 0:
        self.canvas.delete("all")

    self.drawTopTree()

    if self.trace:
        g.trace(self.redrawCount)
#@-node:ekr.20040803072955.61:idle_second_redraw
#@+node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.36:drawBox
def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7

    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)

    if theId is None:
        # if self.trace_gc: g.printNewObjects(tag='box 1')
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        # if self.trace_gc: g.printNewObjects(tag='box 2')
        return theId
    else:
        return theId
#@-node:ekr.20040803072955.36:drawBox
#@+node:ekr.20040803072955.37:drawClickBox
def drawClickBox (self,p,y):

    h = self.line_height

    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
#@-node:ekr.20040803072955.37:drawClickBox
#@+node:ekr.20040803072955.39:drawIcon
def drawIcon(self,p,x=None,y=None):

    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    # if self.trace_gc: g.printNewObjects(tag='icon 1')

    c = self.c ; v = p.v
    << compute x,y and iconVal >>
    v.iconVal = val

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)

    return 0,self.icon_width # dummy icon height,width
#@+node:ekr.20040803072955.40:<< compute x,y and iconVal >>
if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.computeIcon()
assert(0 <= val <= 15)
# g.trace(v,val)
#@nonl
#@-node:ekr.20040803072955.40:<< compute x,y and iconVal >>
#@-node:ekr.20040803072955.39:drawIcon
#@+node:ekr.20040803072955.41:drawLine
def drawLine (self,p,x1,y1,x2,y2):

    theId = self.newLine(p,x1,y1,x2,y2)

    return theId
#@-node:ekr.20040803072955.41:drawLine
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

    c = self.c

    # g.trace(x,y,p,id(self.canvas))

    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0

    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)

    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.

    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2

    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)

    self.drawClickBox(p,y)

    return h,indent
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.44:drawText
def drawText(self,p,x,y):

    """draw text for position p at nominal coordinates x,y."""

    assert(p)

    c = self.c
    x += self.text_indent

    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data

    self.newText(p,x,y+self.lineyoffset)

    self.configureTextState(p)

    return self.line_height
#@-node:ekr.20040803072955.44:drawText
#@+node:ekr.20040803072955.46:drawUserIcons & helper
def drawUserIcons(self,p,where,x,y):

    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""

    h,w = 0,0 ; t = p.v.t

    com = self.c.editCommands
    iconsList = com.getIconList(p)
    if not iconsList:
        return h,w

    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()

    # g.trace(where,h,w)

    return h,w
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):

    c = self.c ; h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # if self.trace_gc: g.printNewObjects(tag='userIcon 1')

    # g.trace(where,x,y,theDict)

    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        ### not ready yet.
        # s = theDict.get("icon")
        pass
    elif theType == "file":
        theFile = theDict.get("file")
        relPath = theDict.get('relPath')
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>

    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    # if self.trace_gc: g.printNewObjects(tag='userIcon 2')

    return h,w
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
if relPath:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",relPath)
else:
    fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
fullname = g.os_path_normpath(fullname)

# Bug fix: the key must include distinguish nodes.
key = (fullname,p.v.t)
image = self.iconimages.get(key)

if not image:
    try:
        from PIL import Image, ImageTk
        image1 = Image.open(fullname)
        image = ImageTk.PhotoImage(image1)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if not image:
    try:
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[key] = image
    except Exception:
        #g.es_exception()
        image = None

if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image)

    tag='userIcon-%s' % theId
    self.canvas.itemconfigure(theId,tag=(tag,'userIcon')) #BJ
    self.ids[theId] = p.copy()

    def deleteButtonCallback(event=None,c=c,p=p,fullname=fullname,relPath=relPath):
        #g.trace()
        c.editCommands.deleteIconByName(p,fullname,relPath)
        self._block_canvas_menu = True
        return 'break'

    c.tag_bind(self.canvas,tag,'<3>',deleteButtonCallback)

    # assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad
#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@-node:ekr.20040803072955.46:drawUserIcons & helper
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):

    """Draws the top-level tree, taking into account the hoist state."""

    c = self.c ; canvas = self.canvas
    trace = False or self.trace or self.trace_redraw

    self.redrawing = True

    # Recycle all widgets and clear all widget lists.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.redrawCount += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if trace:
        g.trace('redrawCount',self.redrawCount,g.callers(5))
            # 'len(c.hoistStack)',len(c.hoistStack))
        if 0:
            delta = g.app.positions - self.prevPositions
            g.trace("**** gen: %-3d positions: %5d +%4d" % (
                self.generation,g.app.positions,delta),g.callers())

    self.prevPositions = g.app.positions
    if self.trace_gc: g.printNewObjects(tag='top 1')

    hoistFlag = c.hoistStack
    if c.hoistStack:
        bunch = c.hoistStack[-1] ; p = bunch.p
        h = p.headString()
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            hoistFlag = False
    else:
        p = c.rootPosition()

    self.drawTree(p,self.root_left,self.root_top,0,0,hoistFlag=hoistFlag)

    if self.trace_gc: g.printNewObjects(tag='top 2')
    if self.trace_stats: self.showStats()

    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.

    canvas.lift("clickBox")
    canvas.lift("clickExpandBox")
    canvas.lift("iconBox") # Higest. BJ:Not now
    canvas.lift("plusBox")
    canvas.lift("userIcon")
    self.redrawing = False
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y ; h1 = None
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data

    while p: # Do not use iterator.
        # This is the ONLY copy of p that needs to be made;
        # no other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h # Set h1 *after* calling drawNode.
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
    # Draw the vertical line.
    if h1 is None: h1 = h
    y2 = g.choose(level==0,yfirst+(h1-1)/2,yfirst-h1/2-1)
    self.drawLine(None,x,y2,x,ylast+self.hline_y-h)
    return y
#@-node:ekr.20040803072955.53:drawTree
#@-node:ekr.20051105073850:drawX...
#@+node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20040803072955.64:getIconImage
def getIconImage (self, name):

    # Return the image from the cache if possible.
    if name in self.iconimages:
        return self.iconimages[name]

    # g.trace(name)

    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("exception loading:",fullname)
        g.es_exception()
        return None
#@-node:ekr.20040803072955.64:getIconImage
#@+node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):

    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 >= vis1 and y1 <= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.

def inExpandedVisibleArea (self,y1):

    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 >= vis1 and y1 <= vis2
    else:
        return False
#@-node:ekr.20040803072955.63:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20040803072955.68:numberOfVisibleNodes
def numberOfVisibleNodes(self):

    c = self.c

    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext(c)
    return n
#@-node:ekr.20040803072955.68:numberOfVisibleNodes
#@+node:ekr.20040803072955.65:scrollTo
def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""

    # This can be called at idle time, so there are shutdown issues.
    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
    if not hasattr(self,'c'):
        return

    c = self.c ; frame = c.frame ; trace = False
    if not p or not c.positionExists(p):
        p = c.currentPosition()
        if trace: g.trace('*** current position',p,p.stack)
    if not p or not c.positionExists(p):
        if trace: g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not c.positionExists(p):
        if trace: g.trace('no position')
        return
    try:
        if trace: g.trace('***',p,p.stack,'exists',c.positionExists(p))
        h1 = self.yoffset(p)
        if self.center_selected_tree_node: # New in Leo 4.4.3.
            << compute frac0 >>
            delta = abs(self.prevMoveToFrac-frac0)
            if trace: g.trace('delta',delta)
            if delta > 0.0:
                self.prevMoveToFrac = frac0
                self.canvas.yview("moveto",frac0)
                if trace: g.trace("frac0 %1.2f h1 %3d htot %3d wtot %3d" % (
                    frac0,h1,htot,wtot),g.callers())
        else:
            last = c.lastVisible()
            nextToLast = last.visBack(c)
            h2 = self.yoffset(last)
            << compute approximate line height >>
            << Compute the fractions to scroll down/up >>
            if frac <= lo: # frac is for scrolling down.
                if self.prevMoveToFrac != frac:
                    self.prevMoveToFrac = frac
                    self.canvas.yview("moveto",frac)
                    if trace: g.trace("frac  %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac, h1,h2,lo,hi),g.callers())
            elif frac2 + (hi - lo) >= hi: # frac2 is for scrolling up.
                if self.prevMoveToFrac != frac2:
                    self.prevMoveToFrac = frac2
                    self.canvas.yview("moveto",frac2)
                    if trace: g.trace("frac2 %1.2f h1 %3d h2 %3d lo %1.2f hi %1.2f" % (
                        frac2,h1,h2,lo,hi),g.callers())

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)

        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.

    except:
        g.es_exception()

idle_scrollTo = scrollTo # For compatibility.
#@+node:ekr.20061030091926:<< compute frac0 >>
# frac0 attempt to put the 
scrollRegion = self.canvas.cget('scrollregion')
geom = self.canvas.winfo_geometry()

if scrollRegion and geom:
    scrollRegion = scrollRegion.split(' ')
    # if trace: g.trace('scrollRegion',repr(scrollRegion))
    htot = int(scrollRegion[3])
    wh,junk,junk = geom.split('+')
    junk,h = wh.split('x')
    if h: wtot = int(h)
    else: wtot = 500
    # if trace: g.trace('geom',geom,'wtot',wtot,'htot',htot)
    if htot > 0.1:
        frac0 = float(h1-wtot/2)/float(htot)
        frac0 = max(min(frac0,1.0),0.0)
    else:
        frac0 = 0.0
else:
    frac0 = 0.0 ; htot = wtot = 0
#@-node:ekr.20061030091926:<< compute frac0 >>
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.canvas.leo_treeBar.get() # Get the previous values of the scrollbar.
try: lo, hi = data
except: lo,hi = 0.0,1.0

# h1 and h2 are the y offsets of the present and last nodes.
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.

frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:scrollTo
#@+node:ekr.20040803072955.70:yoffset (tkTree)
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): g.pr("yoffset not visible:",p1)
    if not p1: return 0
    c = self.c
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        root = bunch.p.copy()
    else:
        root = self.c.rootPosition()
    if root:
        h,flag = self.yoffsetTree(root,p1,isTop=True)
        # flag can be False during initialization.
        # if not flag: g.pr("*** yoffset fails:",'root',root,'p1',p1,'returns',h)
        return h
    else:
        return 0

def yoffsetTree(self,p,p1,isTop):
    c = self.c ; h = 0 ; trace = False ; verbose = True
    if trace: g.trace('entry','root',p,p.stack,'target',p1,p1.stack)
    if not c.positionExists(p):
        if trace: g.trace('*** does not exist',p.headString())
        return h,False # An extra precaution.
    p = p.copy()
    if trace and verbose and isTop and c.hoistStack:
        g.trace('c.hoistStack',c.hoistStack[-1].p.headString())
    if isTop and c.hoistStack:
        if p.firstChild():  theIter = [p.firstChild()]
        else:               theIter = []
    else:
        theIter = p.self_and_siblings_iter() # Bug fix 10/27/07: was p.siblings_iter()

    for p2 in theIter:
        if trace and p1.headString() == p2.headString():
            g.trace('loop',p1,p2)
            g.trace(p1.stack,p2.stack)
        if p2 == p1:
            if trace and verbose: g.trace('returns',h,p1.headString())
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            if trace and verbose: g.trace('recursive call')
            h2, flag = self.yoffsetTree(child,p1,isTop=False)
            h += h2
            if flag:
                if trace and verbose: g.trace('returns',h,p1.headString())
                return h, True

    if trace: g.trace('not found',h,p1.headString())
    return h, False
#@-node:ekr.20040803072955.70:yoffset (tkTree)
#@-node:ekr.20040803072955.62:Helpers...
#@+node:ekr.20081020151805.8:tree.edraw_after methods (new)
# We now use the definitions in the base leoTree class.

# redraw_after_icons_changed  = redraw
# redraw_after_clone          = redraw
# redraw_after_contract       = redraw
# redraw_after_delete         = redraw
# redraw_after_expand         = redraw
# redraw_after_insert         = redraw
# redraw_after_move_down      = redraw
# redraw_after_move_left      = redraw
# redraw_after_move_right     = redraw
# redraw_after_move_up        = redraw
# redraw_after_select         = redraw
#@-node:ekr.20081020151805.8:tree.edraw_after methods (new)
#@-node:ekr.20040803072955.35:Drawing... (tkTree)
#@+node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.72:checkWidgetList
def checkWidgetList (self,tag):

    return True # This will fail when the headline actually changes!
#@-node:ekr.20040803072955.72:checkWidgetList
#@+node:ekr.20040803072955.73:dumpWidgetList
def dumpWidgetList (self,tag):

    g.pr("\ncheckWidgetList: %s" % tag)

    for w in self.visibleText:

        p = w.leo_position
        if p:
            s = w.getAllText().strip()
            h = p.headString().strip()

            addr = self.textAddr(w)
            g.pr("p:",addr,h)
            if h != s:
                g.pr("w:",'*' * len(addr),s)
        else:
            g.pr("w.leo_position == None",w)
#@-node:ekr.20040803072955.73:dumpWidgetList
#@+node:ekr.20040803072955.75:tree.edit_widget
def edit_widget (self,p):

    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
#@nonl
#@-node:ekr.20040803072955.75:tree.edit_widget
#@+node:ekr.20040803072955.74:eventToPosition
def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)

    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId:
            g.es_print('oops:','eventToPosition','failed')
            return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)

    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)

    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None
#@-node:ekr.20040803072955.74:eventToPosition
#@+node:ekr.20040803072955.76:findEditWidget (tkTree)
def findEditWidget (self,p):

    """Return the Tk.Text item corresponding to p."""

    c = self.c ; trace = False

    # if trace: g.trace(g.callers())

    if p and c:
        # if trace: g.trace('h',p.headString(),'key',p.key())
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            w,theId = aTuple
            # if trace: g.trace('id(p.v):',id(p.v),'%4d' % (theId),self.textAddr(w),p.headString())
            return w
        else:
            if trace: g.trace('oops: not found',p,g.callers())
            return None

    if trace: g.trace('not found',p and p.headString())
    return None
#@-node:ekr.20040803072955.76:findEditWidget (tkTree)
#@+node:ekr.20040803072955.109:findVnodeWithIconId
def findPositionWithIconId (self,theId):

    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
#@-node:ekr.20040803072955.109:findVnodeWithIconId
#@-node:ekr.20051105103233:Helpers
#@+node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event,p=None):

    c = self.c ; p1 = c.currentPosition()

    if not p: p = self.eventToPosition(event)
    if not p: return

    c.setLog()

    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        c.endEditing()
        if p == p1 or self.initialClickExpandsOrContractsNode:
            if p.isExpanded(): p.contract()
            else:              p.expand()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    c.redraw()

    c.outerUpdate()
#@-node:ekr.20040803072955.79:onClickBoxClick
#@+node:bobjack.20080401090801.2:onClickBoxRightClick
def onClickBoxRightClick(self, event, p=None):
    #g.trace()
    return 'break'
#@nonl
#@-node:bobjack.20080401090801.2:onClickBoxRightClick
#@+node:bobjack.20080401090801.4:onPlusBoxRightClick
def onPlusBoxRightClick (self,event,p=None):

    c = self.c

    self._block_canvas_menu = True

    if not p: p = self.eventToPosition(event)
    if not p: return

    self.OnActivateHeadline(p)
    self.endEditLabel()

    g.doHook('rclick-popup',c=c,p=p,event=event,context_menu='plusbox')

    c.outerUpdate()

    return 'break'
#@-node:bobjack.20080401090801.4:onPlusBoxRightClick
#@-node:ekr.20040803072955.78:Click Box...
#@+node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):

    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    << set vdrag, childFlag >>
    if self.allow_clone_drags:
        if not self.look_for_control_drag_on_mouse_down:
            self.controlDrag = c.frame.controlKeyIsDown

    redrawFlag = vdrag and vdrag.v.t != p.v.t
    if redrawFlag: # Disallow drag to joined node.
        << drag p to vdrag >>
    elif self.trace and self.verbose:
        g.trace("Cancel drag")

    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None

    # Must set self.drag_p = None first.
    if redrawFlag:
        c.redraw_now()
    c.recolor_now() # Dragging can affect coloring.

    # g.trace(redrawFlag)
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
# g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        p = c.dragToNthChildOf(p,vdrag,0)
    else:
        p = c.dragAfter(p,vdrag)
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event,p=None):

    """The official helper of the onDrag event handler."""

    c = self.c ; canvas = self.canvas

    if not p:
        assert(not self.drag_p)
        x = canvas.canvasx(event.x)
        y = canvas.canvasy(event.y)
        theId = canvas.find_closest(x,y)
        # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
        if theId is None: return
        try: theId = theId[0]
        except: pass
        p = self.ids.get(theId)
    if not p: return
    c.setLog()
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    # g.trace('self.controlDrag',self.controlDrag)
    if self.allow_clone_drags:
        self.controlDrag = c.frame.controlKeyIsDown
        if self.look_for_control_drag_on_mouse_down:
            if self.enable_drag_messages:
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):

    c = self.c ; p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.canvas.leo_treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    canvas.yview("moveto", frac)

    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.canvas.leo_treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):

    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()

    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)

    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):

    """Tree end-of-drag handler called from vnode event handler."""

    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()

    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging (tkTree)
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event,p=None):

    c = self.c ; tree = self

    if not p: p = self.eventToPosition(event)
    if not p:
        return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p,scroll=False)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)

    return "break" # disable expanded box handling.
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event,p=None):

    """Handle a right click in any outline widget."""

    #g.trace()

    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p:
        c.outerUpdate()
        return

    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            if not g.doHook('rclick-popup', c=c, p=p, event=event, context_menu='iconbox'):
                self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")

    self._block_canvas_menu = True

    c.outerUpdate()
    return 'break'
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event,p=None):

    c = self.c

    if not p: p = self.eventToPosition(event)
    if not p:
        c.outerUpdate()
        return

    c.setLog()

    if self.trace and self.verbose: g.trace()

    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")

    c.outerUpdate()
    return 'break'
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
def OnActivateHeadline (self,p,event=None):

    '''Handle common process when any part of a headline is clicked.'''

    # g.trace(p.headString())

    returnVal = 'break' # Default: do nothing more.
    trace = False

    try:
        c = self.c
        c.setLog()
        << activate this window >>
    except:
        g.es_event_exception("activate tree")

    return returnVal
#@+node:ekr.20040803072955.106:<< activate this window >>
if p == c.currentPosition():

    if trace: g.trace('current','active',self.active)
    self.editLabel(p) # sets focus.
    # If we are active, pass the event along so the click gets handled.
    # Otherwise, do *not* pass the event along so the focus stays the same.
    returnVal = g.choose(self.active,'continue','break')
    self.active = True
else:
    if trace: g.trace("not current")
    self.select(p,scroll=False)
    w  = c.frame.body.bodyCtrl
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        spot = p.v.t.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)
    # An important detail.
    # The *canvas* (not the headline) gets the focus so that
    # tree bindings take priority over text bindings.
    c.treeWantsFocusNow() # Now. New in Leo 4.5.
    c.outerUpdate()
    self.active = False
    returnVal = 'break'
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivateHeadline (tkTree)
#@+node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.85:configureTextState
def configureTextState (self,p):

    c = self.c

    if not p: return

    # g.trace(c.isCurrentPosition(p),self.c._currentPosition,p)

    if c.isCurrentPosition(p):
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected
#@-node:ekr.20040803072955.85:configureTextState
#@+node:ekr.20040803072955.86:onCtontrolT
# This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"
#@-node:ekr.20040803072955.86:onCtontrolT
#@+node:ekr.20040803072955.87:onHeadlineClick
def onHeadlineClick (self,event,p=None):

    # g.trace('p',p)
    c = self.c ; w = event.widget

    if not p:
        try:
            p = w.leo_position
        except AttributeError:
            g.trace('*'*20,'oops')
    if not p: return 'break'

    # g.trace(g.app.gui.widget_name(w),p and p.headString())

    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal
#@-node:ekr.20040803072955.87:onHeadlineClick
#@+node:ekr.20040803072955.83:onHeadlineRightClick
def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget

    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'

    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            if not g.doHook('rclick-popup', c=c, p=p, event=event, context_menu='headline'):
                self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")

    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.

    return 'continue'
#@-node:ekr.20040803072955.83:onHeadlineRightClick
#@-node:ekr.20040803072955.84:Text Box...
#@+node:ekr.20040803072955.108:tree.OnDeactivate
def OnDeactivate (self,event=None):

    """Deactivate the tree pane, dimming any headline being edited."""

    tree = self ; c = self.c

    tree.endEditLabel()
    tree.dimEditLabel()
    c.outerUpdate()
#@-node:ekr.20040803072955.108:tree.OnDeactivate
#@+node:ekr.20040803072955.110:tree.OnPopup & allies
def OnPopup (self,p,event):

    """Handle right-clicks in the outline.

    This is *not* an event handler: it is called from other event handlers."""

    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"
#@+node:ekr.20040803072955.111:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

    self.popupMenu.unpost()
#@-node:ekr.20040803072955.111:OnPopupFocusLost
#@+node:ekr.20040803072955.112:createPopupMenu
def createPopupMenu (self,event):

    c = self.c ; frame = c.frame


    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)

    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)

    << Create the menu table >>

    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)
#@+node:ekr.20040803072955.113:<< Create the menu table >>
table = (
    ("&Read @file Nodes",c.readAtFileNodes),
    ("&Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&Tangle",c.tangle),
    ("&Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&Paste Node",c.pasteOutline),
    ("&Delete Node",c.deleteOutline),
    ("-",None),
    ("&Insert Node",c.insertHeadline),
    ("&Clone Node",c.clone),
    ("Sort C&hildren",c.sortChildren),
    ("&Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)
#@-node:ekr.20040803072955.113:<< Create the menu table >>
#@-node:ekr.20040803072955.112:createPopupMenu
#@+node:ekr.20040803072955.114:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):

    """Enable and disable items in the popup menu."""

    c = self.c ; menu = self.popupMenu

    << set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)

    enable = self.frame.menu.enableMenu

    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())
#@+node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True

    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True
#@-node:ekr.20040803072955.115:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20040803072955.114:enablePopupMenuItems
#@+node:ekr.20040803072955.116:showPopupMenu
def showPopupMenu (self,event):

    """Show a popup menu."""

    c = self.c ; menu = self.popupMenu

    g.app.gui.postPopupMenu(c, menu, event.x_root, event.y_root)

    self.popupMenu = None

    # Set the focus immediately so we know when we lose it.
    #c.widgetWantsFocus(menu)
#@-node:ekr.20040803072955.116:showPopupMenu
#@-node:ekr.20040803072955.110:tree.OnPopup & allies
#@+node:ekr.20051022141020:onTreeClick
def onTreeClick (self,event=None):

    '''Handle an event in the tree canvas, outside of any tree widget.'''

    c = self.c

    # New in Leo 4.4.2: a kludge: disable later event handling after a double-click.
    # This allows focus to stick in newly-opened files opened by double-clicking an @url node.
    if c.doubleClickFlag:
        c.doubleClickFlag = False
    else:
        c.treeWantsFocusNow()

    g.app.gui.killPopupMenu()
    c.outerUpdate()

    return 'break'
#@-node:ekr.20051022141020:onTreeClick
#@+node:bobjack.20080401090801.3:onTreeRightClick
def onTreeRightClick (self,event=None):

    c = self.c

    if not c.exists: return

    if self._block_canvas_menu:
        self._block_canvas_menu = False
        return 'break'

    g.doHook('rclick-popup',c=c,event=event,context_menu='canvas')

    c.outerUpdate()
    return 'break'
#@-node:bobjack.20080401090801.3:onTreeRightClick
#@-node:ekr.20040803072955.71:Event handlers (tkTree)
#@+node:ekr.20040803072955.118:Incremental drawing...
#@+node:ekr.20040803072955.119:allocateNodes
def allocateNodes(self,where,lines):

    """Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""

    assert(where in ("above","below"))

    # g.pr("allocateNodes: %d lines %s visible area" % (lines,where))

    # Expand the visible area: a little extra delta is safer.
    delta = lines * (self.line_height + 4)
    y1,y2 = self.visibleArea

    if where == "below":
        y2 += delta
    else:
        y1 = max(0.0,y1-delta)

    self.expandedVisibleArea=y1,y2
    # g.pr("expandedArea:   %5.1f %5.1f" % (y1,y2))

    # Allocate all nodes in expanded visible area.
    self.updatedNodeCount = 0
    self.updateTree(self.c.rootPosition(),self.root_left,self.root_top,0,0)
    # if self.updatedNodeCount: g.pr("updatedNodeCount:", self.updatedNodeCount)
#@-node:ekr.20040803072955.119:allocateNodes
#@+node:ekr.20040803072955.120:allocateNodesBeforeScrolling
def allocateNodesBeforeScrolling (self, args):

    """Calculate the nodes that will become visible as the result of an upcoming scroll.

    args is the tuple passed to the Tk.Canvas.yview method"""

    if not self.allocateOnlyVisibleNodes: return

    # g.pr("allocateNodesBeforeScrolling:",self.redrawCount,args)

    assert(self.visibleArea)
    assert(len(args)==2 or len(args)==3)
    kind = args[0] ; n = args[1]
    lines = 2 # Update by 2 lines to account for rounding.
    if len(args) == 2:
        assert(kind=="moveto")
        frac1,frac2 = args
        if float(n) != frac1:
            where = g.choose(n<frac1,"above","below")
            self.allocateNodes(where=where,lines=lines)
    else:
        assert(kind=="scroll")
        linesPerPage = self.canvas.winfo_height()/self.line_height + 2
        n = int(n) ; assert(abs(n)==1)
        where = g.choose(n == 1,"below","above")
        lines = g.choose(args[2] == "pages",linesPerPage,lines)
        self.allocateNodes(where=where,lines=lines)
#@-node:ekr.20040803072955.120:allocateNodesBeforeScrolling
#@+node:ekr.20040803072955.121:updateNode
def updateNode (self,p,x,y):

    """Draw a node that may have become visible as a result of a scrolling operation"""

    c = self.c

    if self.inExpandedVisibleArea(y):
        # This check is a major optimization.
        if not c.edit_widget(p):
            return self.force_draw_node(p,x,y)
        else:
            return self.line_height

    return self.line_height
#@-node:ekr.20040803072955.121:updateNode
#@+node:ekr.20040803072955.122:setVisibleAreaToFullCanvas
def setVisibleAreaToFullCanvas(self):

    if self.visibleArea:
        y1,y2 = self.visibleArea
        y2 = max(y2,y1 + self.canvas.winfo_height())
        self.visibleArea = y1,y2
#@-node:ekr.20040803072955.122:setVisibleAreaToFullCanvas
#@+node:ekr.20040803072955.123:setVisibleArea
def setVisibleArea (self,args):

    r1,r2 = args
    r1,r2 = float(r1),float(r2)
    # g.pr("scroll ratios:",r1,r2)

    try:
        s = self.canvas.cget("scrollregion")
        x1,y1,x2,y2 = g.scanf(s,"%d %d %d %d")
        x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
    except:
        self.visibleArea = None
        return

    scroll_h = y2-y1
    # g.pr("height of scrollregion:", scroll_h)

    vy1 = y1 + (scroll_h*r1)
    vy2 = y1 + (scroll_h*r2)
    self.visibleArea = vy1,vy2
    # g.pr("setVisibleArea: %5.1f %5.1f" % (vy1,vy2))
#@-node:ekr.20040803072955.123:setVisibleArea
#@+node:ekr.20040803072955.124:tree.updateTree
def updateTree (self,v,x,y,h,level):

    yfirst = y
    if level==0: yfirst += 10
    while v:
        # g.trace(x,y,v)
        h,indent = self.updateNode(v,x,y)
        y += h
        if v.isExpanded() and v.firstChild():
            y = self.updateTree(v.firstChild(),x+indent,y,h,level+1)
        v = v.next()
    return y
#@-node:ekr.20040803072955.124:tree.updateTree
#@-node:ekr.20040803072955.118:Incremental drawing...
#@+node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@+node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)
#@-node:ekr.20040803072955.142:dimEditLabel, undimEditLabel
#@+node:ekr.20040803072955.127:tree.editLabel
def editLabel (self,p,selectAll=False):

    """Start editing p's headline."""

    c = self.c
    trace = (False or self.trace_edit)

    if p and p != self.editPosition():

        if trace:
            g.trace('leoTree',p.headString(),g.choose(c.edit_widget(p),'','no edit widget'))

        self.endEditLabel()
        # This redraw *is* required so the c.edit_widget(p) will exist.
        c.redraw()
        c.outerUpdate()

    self.setEditPosition(p) # That is, self._editPosition = p
    w = c.edit_widget(p)

    if trace: g.trace('1','w',w,'focus',g.app.gui.get_focus(c))

    if p and w:
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p,selectAll=selectAll) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.
        c.k.showStateAndMode(w)

    if trace: g.trace('w',w,'focus',g.app.gui.get_focus(c))
#@-node:ekr.20040803072955.127:tree.editLabel
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setEditLabelState
def setEditLabelState (self,p,selectAll=False): # selected, editing

    c = self.c ; w = c.edit_widget(p)

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        selectAll = selectAll or self.select_all_text_when_editing_headlines
        if selectAll:
            w.setSelectionRange(0,'end',insert='end')
        else:
            w.setInsertPoint('end') # Clears insert point.
    else:
        g.trace('no edit_widget')

setNormalLabelState = setEditLabelState # For compatibility.
#@-node:ekr.20040803072955.135:setEditLabelState
#@+node:ekr.20040803072955.136:setSelectedLabelState
trace_n = 0

def setSelectedLabelState (self,p): # selected, disabled

    c = self.c

    # g.trace(p,c.edit_widget(p))


    if p and c.edit_widget(p):

        if 0:
            g.trace(self.trace_n,c.edit_widget(p),p)
            # g.trace(g.callers(6))
            self.trace_n += 1

        self.setDisabledHeadlineColors(p)
#@-node:ekr.20040803072955.136:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    c = self.c

    if p and c.edit_widget(p):
        self.setUnselectedHeadlineColors(p)
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if False or (self.trace and self.verbose):
        g.trace("%10s %d %s" % ("disabled",id(w),p.headString()))
        # import traceback ; traceback.print_stack(limit=6)

    fg = self.headline_text_selected_foreground_color or 'black'
    bg = self.headline_text_selected_background_color or 'grey80'
    selfg = self.headline_text_editing_selection_foreground_color
    selbg = self.headline_text_editing_selection_background_color

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            g.pr("%10s %d %s" % ("edit",id(2),p.headString()))

    fg    = self.headline_text_editing_foreground_color or 'black'
    bg    = self.headline_text_editing_background_color or 'white'
    selfg = self.headline_text_editing_selection_foreground_color or 'white'
    selbg = self.headline_text_editing_selection_background_color or 'black'

    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):

    c = self.c ; w = c.edit_widget(p)

    if self.trace and self.verbose:
        if not self.redrawing:
            g.pr("%10s %d %s" % ("unselect",id(w),p.headString()))
            # import traceback ; traceback.print_stack(limit=6)

    fg = self.headline_text_unselected_foreground_color or 'black'
    bg = self.headline_text_unselected_background_color or 'white'

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20060207101443:tree.setHeadline (tkTree)
def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
#@-node:ekr.20060207101443:tree.setHeadline (tkTree)
#@-node:ekr.20040803072955.125:Selecting & editing... (tkTree)
#@-node:ekr.20040803072955:@@thin leoTkinterTree.py
#@-node:ekr.20031218072017.3821:Gui Tkinter classes
#@-node:ekr.20031218072017.434:Unused code
#@-all
#@nonl
#@-node:ekr.20031218072017.329:@thin ../doc/leoNotes.txt
#@-leo
