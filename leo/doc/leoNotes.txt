.. @+leo-ver=5-thin
.. @+node:ekr.20031218072017.329: * @file ../doc/leoNotes.txt
.. @@language rest
.. @@killbeautify
.. @+all
.. @+node:ekr.20090202064534.4: **  Your mission, should you choose to accept it
@language rest

.. @+node:ekr.20100223100750.5843: *3* Original post by Robin Dunn
Here are the emacs features that I use very often that any editor would
need to have in order for me to switch.  I've seen some editors with
some of these, but none with all unless it is an emacs clone.  I'll
leave out the obvious things like platform independence, good syntax
highlighting, calltips or auto-completion.  Also, these features are
just dealing with the code editor portion of the app, if it is more than
that (like a full IDE) then some of these things may or may not apply to
the non code editor parts:

* (done) Python should be just one of the languages that this editor supports,
not the primary target.  I spend as much time in C/C++ as I do Python,
and my editor of choice needs to help me with C/C++ coding just as much
as it does with Python.  So some sort of support for calltips and
auto-completion would be marvelous, and also being able to act as a
front-end for gdb since I currently use emacs for that most of the time.

* (done) Absolutely every feature or action must be able to be done with just
the keyboard.  Moving the hand back and forth to the mouse wastes time,
breaks concentration and contributes to RSI.  Multi-key sequences are
fine as long as they are grouped in a logical fashion.  For example in
emacs all of the version control features are accessible via the
Ctrl-x,v sequence plus one more letter.

* (done) Incremental search, both forward and reverse, and wrapping around
after you've reached the end or the beginning of the document.  I like
to have the same key to start the search and also do a search-next after
you've typed all the characters you are searching for, and also to have
backspace go back one search position and/or remove one character from
the search text.

* (done) Multiple top level windows, and able to show any buffer in any TLW,
including those that are already displayed in another TLW.  Of course
there should be key-bindings available for opening a new TLW, cycling
forward and backward through the buffer list, and a way to select a
buffer from a popup list of buffer/file names.

* (to be improved) The Kill-Ring.  For those of you that have never used an emacs-like
editor it works like this:  There is a collection of the N previous
blocks of text that have been cut or copied (in emacs 'cut' == 'kill'
more or less)  When I do a yank (paste) it uses the last thing put in
the kill-ring.  If I then immediately use another key-binding then it
replaces that pasted text with the next item in the kill ring, and so on
until I eventually wrap around get back to the first one in the ring, or
I do some other command or move the cursor somewhere else.

* (done) Registers.  A text snippet can be copied into a register, which is
like the kill ring except you refer to each one by name, where the names
are 'a' through 'z'.  You can also append to a register that already has
text in it, and you can paste the contents of a register into the
document at the current cursor location.

* (done) Able to have selections be either a stream of characters or a
rectangle.  A stream selection is like what you have in all text
editors, it starts from position a on line N and continues forward or
back to position b on line M and includes all the characters in between.

  A rectangle selection is all the characters between position a and b
on lines N to M.  In other words, it has width and height and it might
be something like positions 5 through 10 on lines 20 to 25.  Cutting or
deleting a rectangle removes the text in the rectangle and shifts any
text to the right of the rectangle over.  It does not remove any lines
although they may end up being empty.  Pasting a rectangle inserts the
new text with the upper-left of the rectangle at the current cursor
position, shifts existing text to the right if needed, and fills with
spaces on the left if a line affected by the paste is not long enough.
New lines are not added unless the file needs to be extended to
accommodate the rectangle paste.  Rectangles can also be put into registers.

* (to be improved) Good keystroke macro recording and the ability to save and load
keystroke macros, and the ability to assign a key-binding to a saved
recorded macro. Any time I need to make the same edits to a bunch of
lines or groups of lines I'll record doing it on the first one including
the keystrokes needed to reposition for the next line, and then stop
recording and then it's just one keystroke to replay the keystrokes for
every other line that needs it done.  I record, use and throw away up to
a dozen or so macros per day.

* (done, and better than asserted) If you must have a toolbar make it optional
and keep it simple. Toolbars require the mouse and the goal is to keep the hand
off the mouse as much as possible.

* (done) Similarly, avoid using popup dialogs whenever possible.  This includes
things like the file dialog.  I don't mind seeing the file dialog if I
select a menu item, because most likely my hand is already on the mouse,
but the rest of the time I just want to hit a key, type a path name
(with tab-completion to help find stuff, up/down keys to cycle through
past selections) and press enter.  So I would prefer this editor to have
something like emacs' minibuffer, or the QuickFind panel in Firefox.  In
other words, when there is something you would normally use a dialog for
just create a small panel that rolls up from the bottom of the frame,
put the keyboard focus there, perhaps do stuff in the main buffer as
they are typing if appropriate, and then when the user is done the panel
rolls out of sight again and keyboard focus is restored to their active
buffer.  This can be done for file open/saves, search & replace,
specifying build or grep commands (see next item) choosing to execute
some editor function by name that may not have some key-binding yet (see
item after next) etc.

* (done, with user @commands)

Flexible build/grep commands.  Emacs handles both of these in almost
the same way so I'll list them together here.  I hit a key and am
presented with either the default, or the most recently used compile or
grep command.  I can edit the command or use the up/down arrows to
select previous commands that I've used.  I then hit enter and emacs
runs the command putting the output in an editor buffer.  There is a key
I can hit to kill the compile if needed.  It then parses the output and
there is a key I can use to find the file listed in the compile or grep
output, load it, and position the cursor on the reported line.  (This
can even be done while the compile/grep is still running.)

* (done) For access to editor commands/functionality that may not be bound to a
keystroke it's real nice to have the ability to hit a key, type the
command name, press enter and then it's done.  This can also allow for
commands that might need to prompt for parameters, be interactive, etc.
  All editor commands should be named and can be bound to keys by name
or executed by name in this way.

* (done) def aproposFindCommands (self, event=None):

    '''Prints a discussion of of Leo's find commands.'''

    << define s >>

    self.c.putApropos(s)
 search.  Emacs has support for regular expression search modes
for all of the search types, incremental search, search/replace,
although I don't use it that much.

* (done, or not needed, depending on your point of view)
Multi-file search and replace.  Be able to select files interactively,
or by wildcard, or both.  Enter search string, or regex, and replace
text.  The editor loads each file and does the search, allowing you to
choose for each one whether to do the replacement, or replace all.

* If it is a full IDE it would be nice to have a way to start just the
code editor portion for quick edits.

Things that would be nice to have, but that I could live without:

(All of these things can be done easily with @command)

* Interactive diffs, merges and applying of patches.

* Able to be a front-end for gdb.

* Able to be a front-end for CVS, SVN, etc.

* (done) Be able to run shell commands, or the shell itself in an editor buffer.

* (easy) have a built-in psychotherapist or be able to play towers of hanoi.  ;-) 
.. @+node:ekr.20100223100750.5842: *3* Post to pyxides, 2010/02/23
http://groups.google.com/group/pyxides

Robin Dunn's post, reproduced at:
http://groups.google.com/group/leo-editor/browse_thread/thread/4f76a0f57759aba
continues to be one of the benchmarks for Leo.

Leo 4.7 went out the door today.  It contains many important
improvements, but few directly related to Robin's important post.
That doesn't mean Robin's post is irrelevant, but it does mean that
other considerations were more relevant :-)  In particular, Leo passes
all unit tests with Python 2.6 and Python 3.1.

Leo 4.8 will concentrate on better support for vim-like bindings.  As
a happy side effect, this will make Leo compliant with almost all
unfinished aspects of Robin's mission.

There are two major items from Robin's list that are incomplete in
Leo:

* The Kill-Ring.  Leo does have a kill ring.  The vim work will fix
discrepancies between how Leo, emacs and vim handle the kill ring.

* Good keystroke macro recording and the ability to save and load
keystroke macros.  This happen as part of support for vim's "dot"
command.  To some extent, Leo's execute-script command compensates for
wimpy macro support, but I'd like to do better.

The following could be done easily using Leo's @command or @button
features.  There doesn't seem to be much demand for them in Leo, but
I'll list them here for completeness.

- Flexible build/grep commands.
- Interactive diffs, merges and applying of patches.
- Able to be a front-end for gdb. (Leo has a plugin to do this).
- Able to be a front-end for CVS, SVN, etc.
- Have a built-in psychotherapist or be able to play towers of
hanoi.  ;-)

As always, I invite you all to try Leo, and to ask for features that
would be important to you.

======

P.S. Leo does have auto-completion.  It will be improved in Leo 4.9.

.. @+node:ekr.20110616084347.14800: *3* Post to pyxides, 2011/07/10
http://groups.google.com/group/pyxides

On 2010/02/23 I commented about Leo 4.7 as it relates to Robin Dunn's post,
http://groups.google.com/group/leo-editor/browse_thread/thread/4f76a0f57759aba

A few weeks ago Leo 4.9 went out the door. Imo, this version of Leo has
accomplished the mission. Leo has all the important features that Leo's users
have requested. Yes, wishlist items remain. See:
https://bugs.launchpad.net/leo-editor/+bugs

None of these wish-list items interferes in any way with Leo's day-to-day
operation. Furthermore, many of Leo's essential features moot the need for more
traditional features.

For example, Leo 4.9 adds full support for macros. Recording, saving, editing
and retrieving macros is easier in Leo than in other editors because Leo stores
macros in @macro nodes, not external files. But few, if any, of Leo's users are
likely to use macros because Leo's @button nodes make all of Python's scripting
abilities easily available on a node-by-node or outline-wide basis.

It may be that Leo could benefit from some Emacs-like or vim-like features, but
that doesn't seem so likely.  Leo has many users who also use Emacs and vim, and
they seem happy enough :-)

Finally, Leo offers features that have no counterpart at all in editors
like Emacs and vim. For example, the rst3 command converts an outline to
restructured text. See: rstplugin3.html Yes, one could imagine an org-mode
command that does this, but the fact is that Leo's outline orientation has
given it abilities possessed by no other editor or IDE.

I invite you to try Leo. If, after using Leo for
real work, you find you would like some new feature, then by all means ask.

Edward
.. @+node:ekr.20101004092958.6050: ** How to make codewise work
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e/a1558a10eb8537c0?lnk=gst&q=codewise#a1558a10eb8537c0

1. Make sure you have exuberant ctags (not just regular ctags)
installed.  It's an Ubuntu package, so easy if you're using Ubuntu.

2. Install Ville's python module "codewise".  This is a small module on
which the Leo plugin relies.

   bzr branch lp:codewise
   cd codewise
   sudo python setup.py install

3. You need a recent trunk version of leo to get the plugin which uses
the above module.

4. Enable the plugin by putting "codewisecompleter.py" on an
uncommented line in your @enabled-plugins @settings node.

5. On the command line:

if you have an existing ~/.ctags for some reason, and it's nothing you
need to keep:

  rm ~/.ctags

then

  codewise setup
  codewise init
  codewise parse .../path/to/leo/  # assuming you want completion on
                                   # leo code
  codewise parse .../some/other/project/

Then, after restarting leo if necessary, type

c.op<Alt-0> in the body editor to find all the c. methods starting
with 'op' etc.

Nice work Ville, thanks.

==================

Thanks for this, I hope others will take a stab at it as well, given
sane instructions (I burned my free cycles frantically coding this
thing and neglected the all-important HOWTO). This is important
because functional completion is the single most important thing still
missing from Leo. Or, well, was ;-).

Especially the presentation part (QCompleter) needs some care, so you
can operate it from your keyboard alone. It should probably be moved
to core (qtgui, perhaps leoQTextEditWIdget), so codewise completer can
just invoke w.complete(list_of_completions) that will bring up the
QCompleter popup.

> Then, after restarting leo if necessary, type

> c.op<Alt-0> in the body editor to find all the c. methods starting
> with 'op' etc.

Also, try the explicit declarations:

# w : SomeClass

w.<alt+0>

And self.<alt+0> 
.. @+node:ekr.20091217112515.6070: ** How to make the codewise completer work
http://groups.google.com/group/leo-editor/browse_thread/thread/ac3f8789010c882e

Ville's completer is working and very cool, here are instructions for
making it go.  They're like the instructions Ville gave, only usable ;-)

1. (done) Make sure you have exuberant ctags (not just regular ctags)
installed.  It's an Ubuntu package, so easy if you're using Ubuntu.

2. (done) Install Ville's python module "codewise".  This is a small module on
which the Leo plugin relies.

   bzr branch lp:codewise
   cd codewise
   sudo python setup.py install

3. (done) You need a recent trunk version of leo to get the plugin which uses
the above module.

4. (done) Enable the plugin by putting "codewisecompleter.py" on an
uncommented line in your @enabled-plugins @settings node.

5. On the command line:

if you have an existing ~/.ctags for some reason, and it's nothing you
need to keep:

  rm ~/.ctags

then

  codewise setup
  codewise init
  codewise parse .../path/to/leo/  # assuming you want completion on
                                   # leo code
  codewise parse .../some/other/project/

Then, after restarting leo if necessary, type

c.op<Alt-0> in the body editor to find all the c. methods starting
with 'op' etc.


===== Ville's response

Especially the presentation part (QCompleter) needs some care, so you
can operate it from your keyboard alone. It should probably be moved
to core (qtgui, perhaps leoQTextEditWIdget), so codewise completer can
just invoke w.complete(list_of_completions) that will bring up the
QCompleter popup.

> Then, after restarting leo if necessary, type

> c.op<Alt-0> in the body editor to find all the c. methods starting
> with 'op' etc.

Also, try the explicit declarations:

# w : SomeClass

w.<alt+0>

And self.<alt+0>
.. @+node:ekr.20091217112515.6069: *3* Others posts
1. codewisecompleter.py now completes by explicit type hints (as seen in
screenhots). p, c also work, as does 'self'.

self works by scanning for parent headlines looking for "class Foo"

Work remains for presentation part (it's mouse only now) but Edward
will probably do it :-).

2. > Would codewise work outside of leo, as stand-alone plugin for a text
> editor?

Yes, currently Leo uses it as an external program ("codewise m
MyClass" dumps the methods in MyClass to stdout).

Someone just has to write the vim integration plugin (or whatever they
call it). OTOH, vim already has "pysmell" and the likes that do the
same thing.

==============

The version of codewise completer that works with Tk is now on trunk.
.. @+node:ekr.20091217112515.6071: *3* plugin docs
- You need to create ctags file to ~/.leo/tags. Example::

    cd ~/.leo
    ctags -R /usr/lib/python2.5 ~/leo-editor ~/my-project

- Enter text you want to complete and press alt+0 to show completions
  (or bind/execute ctags-complete command yourself).

Attempting to complete 'foo->' is useless, but 'foo->ba' will work (provided you
don't have 2000 functions/methods starting with 'ba'. 'foo->' portion is ignored
in completion search.
.. @+node:ekr.20161022035203.1: ** Test code: do not delete
@language python
# This tree contains clones. None are contained in any external file.
.. @+node:ekr.20161006162035.1: *3* cff regex pattern to find section references
# This works
<<(\s*)(\w+)(\s+)(\w+)(.*)>>

# These don't work
<<(\s*)(?!(import|docstring|includes))(\w+)(\s*)>>
<< xyz >>
<< import >>
.. @+node:ekr.20180213054048.1: *3* clean recent files test
self = g.app.recentFilesManager
result = [z for z in self.recentFiles if g.os_path_exists(z)]
if result != self.recentFiles:
    for path in result:
        self.updateRecentFiles(path)
    self.writeRecentFilesFile(c, force=True)
.. @+node:ekr.20180125040406.1: *3* script: clear g.app.db['shown-tips']
g.app.db ['shown-tips'] = []
.. @+node:ekr.20170206165145.1: *3* script: test demo.py
g.cls()
# c.frame.log.clearLog()
if c.isChanged(): c.save()
import imp
from leo.core.leoQt import QtGui
import leo.plugins.demo as demo
imp.reload(demo)
table = [
'''\
demo.delete_widgets()
demo.callout('Callout 1 centered')
demo.subtitle('This is subtitle 1')
''',
'''\
demo.delete_widgets()
demo.callout('Callout 2 (700, 200)', position=[700, 200])
demo.subtitle('This is subtitle 2')
''',
'''\
demo.delete_widgets()
demo.callout('Callout 3 (200, 300)', position=[200, 300])
demo.subtitle('This is subtitle 3')
''',
'''\
demo.delete_widgets()
demo.callout('Callout 4 (center, 200)', position=['center', 200])
demo.subtitle('This is a much much longer subtitle 4')
''',
'''\
demo.delete_widgets()
demo.callout('Callout 5 (700, center)', position=[700, 'center'])
demo.subtitle('Short 5')
''',
'''\
demo.delete_widgets()
demo.next()
''',
]
color = QtGui.QColor('lightblue')
sub_color = QtGui.QColor('mistyrose')
demo = demo.Demo(c, color=color, subtitle_color=sub_color, trace=False)
demo.delete_widgets()
demo.start(script_list = table)
.. @+node:ekr.20170317101032.1: *3* test g.unCamel
g.cls()

table = (
    'abcXyz',
    'AbcXyz',
    'abcXyzW',
)
for s in table:
    print(s)
    g.printList(g.unCamel(s))
.. @+node:ekr.20170404102619.1: ** Unused code
@language python
.. @+node:ekr.20170203080350.1: *3* Abandoned #396: Show images in Leo's body pane
https://github.com/leo-editor/leo-editor/issues/396

.. @+node:ekr.20170302151109.1: *4* ** Notes
@language rest
@wrap

Unicode 'object replacement character': u+FFFC

QTextDocument may be helpful: http://doc.qt.io/qt-5/qtextdocument.html
See QTextDocument.MetaInformation: http://doc.qt.io/qt-5/qtextdocument.html#MetaInformation-enum

http://stackoverflow.com/questions/3254652/
several-ways-of-placing-an-image-in-a-qtextedit

http://doc.qt.io/qt-5/qtextdocument.html#resource

QVariant QTextDocument::resource(int type, const QUrl &name) const

Returns data of the specified type from the resource with the given name.

This function is called by the rich text engine to request data that isn't directly stored by QTextDocument, but still associated with it. For example, images are referenced indirectly by the name attribute of a QTextImageFormat object.

Resources are cached internally in the document. If a resource can not be found in the cache, loadResource is called to try to load the resource. loadResource should then use addResource to add the resource to the cache.
.. @+node:ekr.20170203105538.1: *4* Test inserting picture (new)
# https://github.com/leo-editor/leo-editor/issues/396
g.cls()
images = [i for i in range(len(p.b)) if ord(p.b[i]) > 128]
if images:
    print('images at', images)
else:
    table = (
        'application-x-leo-outline.png',
        'LeoDoc.ico',
    )    
    for image in table:
        path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', image)
        assert g.os_path_exists(path), repr(path)
        c.frame.body.wrapper.setInsertPoint(len(p.b))
        if 0:
            format = QtGui.QTextImageFormat()
            format.setName(path)
            cursor = cursor = body.widget.textCursor()
            cursor.insertImage(format)
        c.frame.body.widget.insertHtml('<img src="%s">' % path)
            # style="width:40px;height:80px;"
    for i, ch in enumerate(p.b):
        if ord(ch) > 128: print('new', i, ord(ch))
#
#￼￼
.. @+node:ekr.20170204110006.1: *4* test3 insert an image
g.cls()
from leo.core.leoQt import QtGui
body = c.frame.body
table = ('box01.bmp','box02.bmp','box03.bmp',)
d = g.app.permanentScriptDict
images = d.get('images', [])
for image in table:
    path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', image)
    assert g.os_path_exists(path), repr(path)
    image = QtGui.QImage(path)
    images.append(image)
    body.wrapper.setInsertPoint(len(p.b))
    cursor = body.widget.textCursor()
    cursor.insertImage(image)
for i, ch in enumerate(p.b):
    if ord(ch) > 128: print('new', i, ord(ch))
d ['images'] = images
#
#
.. @+node:ekr.20170204140521.1: *4* clear g.app.permanentScriptDict
g.printDict(g.app.permanentScriptDict)
g.app.permanentScriptDict = {}
.. @+node:ekr.20170204135338.1: *4* @@button show-images
from leo.core.leoQt import QtCore
d = g.app.permanentScriptDict
name_index = d.get('name_index', 0)
names = ['leo_image%s' % (i) for i in range(name_index)]
# print('image names', names)
widget = c.frame.body.widget
doc = widget.document()
for i, name in enumerate(names):
    image = doc.resource(doc.ImageResource, QtCore.QUrl(name))
    print(name, image)
.. @+node:ekr.20170204105958.1: *4* test2 insert an image
g.cls()
from leo.core.leoQt import QtGui
body = c.frame.body
table = (
    'application-x-leo-outline.png',
    'LeoDoc.ico',
)
g.app.permanentScriptDict = {}
d = g.app.permanentScriptDict
images = d.get('images', [])
cursors = d.get('cursors', [])
name_index = d.get('name_index', 0)
for image in table:
    path = g.os_path_finalize_join(g.app.loadDir, '..', 'Icons', image)
    assert g.os_path_exists(path), repr(path)
    image = QtGui.QImage(path)
    print(image.format().name())
    images.append(image)
    body.wrapper.setInsertPoint(len(p.b))
    cursor = body.widget.textCursor()
    #name = 'leo_image%s' % name_index
    #name_index += 1
    cursor.insertImage(image) ### , name)
    cursors.append(cursor)
for i, ch in enumerate(p.b):
    if ord(ch) > 128: print('new', i, ord(ch))
d ['images'] = images
d ['cursors'] = cursors
d ['name_index'] = name_index
g.app.permanentScriptDict = d
g.printDict(d)
#
#￼￼￼
#￼
.. @+node:ekr.20180328065332.1: *3* Check conventions stuff
.. @+node:ekr.20171208042251.1: *4* @@button check-conventions (no longer used)
g.cls()
if c.changed: c.save()

import imp
import leo.core.leoCheck as leoCheck
imp.reload(leoCheck)

do_all = True
do_string = True

fails = []
    # All of Leo's core files pass!
fn = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoTest.py')
<< define s >>
<< old tests >>
if do_all:
    utils = leoCheck.ProjectUtils()
    aList = utils.project_files('leo', force_all=False)
    # g.printList(aList)
    for fn in aList:
        sfn = g.shortFileName(fn)
        if sfn in fails:
            print('===== skipping', sfn)
        else:
            print('==== fn', sfn)
            leoCheck.ConventionChecker(c).check(fn=fn)
elif do_string: # Test string s.
    leoCheck.ConventionChecker(c).check(s=s)
else: # Test an actual file.
    leoCheck.ConventionChecker(c).check(fn=fn)
.. @+node:ekr.20171208105236.1: *5* << define s >>
s = '''\
class T:
    
    def __init__(self, tempNode):
        self.tempNode = tempNode.copy()
    
    def setUp(self):
        tempNode = self.tempNode
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()
'''

s_ok2 = '''
class Context(object):
    def __init__ (self, parent_context):
        self.parent_context = parent_context
        if parent_context:
            parent_context.inner_contexts_list.append(self)
'''

s_ok= '''
class TC:
    def __init__(self, c):
        c.tc = self
    def add_tag(self, p):
        print(p.v) # AttributeError if p is a vnode.

class Test:
    def __init__(self,c):
        self.c = c
        self.tc = self.c.tc
    def add_tag(self):
        p = self.c.p
        self.tc.add_tag(p.v) # WRONG: arg should be p.
'''

.. @+node:ekr.20171210062719.1: *5* << old tests >>
s_passes_1 = '''\
class C1:
        
    def f1(self, p):
        print(p.v)
        
    def f2(self, p):
        self.f1(p.v) # WRONG

'''


s_1 = '''\
class C1:

    def __init__(self, c):
        self.c = c
        c.theTagController = self
        
    def add_tag(self, p):
        pass

class C2:

    def oops(self, p):
        c.tagController.add_tag(p.v,tag)
            # WRONG: should be p.

'''


s_2 = '''\
class TagController:

    def __init__(self, c):
        self.c = c
        c.theTagController = self

    def add_tag(self, p, tag):
        # Will fail if p is a vnode
        tags = set(p.v.u.get('__node_tags', set([])))

class LeoTagWidget(QtWidgets.QWidget):

    def __init__(self,c,parent=None):
        self.c = c
        self.tc = self.c.theTagController

    def add_tag(self, event=None):
        p = self.c.p
        self.tc.add_tag(p.v,tag) # WRONG: should be p.

'''
.. @+node:ekr.20160109150703.1: *4* class Stats (old & stupid, from leoCheck.py)
class Stats(object):
    '''A class containing global statistics & other data'''
    @others
.. @+node:ekr.20160109150703.2: *5*  sd.ctor
def __init__ (self):

    # Files...
    # self.completed_files = [] # Files handled by do_files.
    # self.failed_files = [] # Files that could not be opened.
    # self.files_list = [] # Files given by user or by import statements.
    # self.module_names = [] # Module names corresponding to file names.

    # Contexts.
    # self.context_list = {}
        # Keys are fully qualified context names; values are contexts.
    # self.modules_dict = {}
        # Keys are full file names; values are ModuleContext's.

    # Statistics...
    # self.n_chains = 0
    self.n_contexts = 0
    # self.n_errors = 0
    self.n_lambdas = 0
    self.n_modules = 0
    # self.n_relinked_pointers = 0
    # self.n_resolvable_names = 0
    # self.n_resolved_contexts = 0
    # self.n_relinked_names = 0

    # Names...
    self.n_attributes = 0
    self.n_expressions = 0
    self.n_ivars = 0
    self.n_names = 0        # Number of symbol table entries.
    self.n_del_names = 0
    self.n_load_names = 0
    self.n_param_names = 0
    self.n_param_refs = 0
    self.n_store_names = 0

    # Statements...
    self.n_assignments = 0
    self.n_calls = 0
    self.n_classes = 0
    self.n_defs = 0
    self.n_fors = 0
    self.n_globals = 0
    self.n_imports = 0
    self.n_lambdas = 0
    self.n_list_comps = 0
    self.n_returns = 0
    self.n_withs = 0

    # Times...
    self.parse_time = 0.0
    self.pass1_time = 0.0
    self.pass2_time = 0.0
    self.total_time = 0.0
.. @+node:ekr.20160109150703.6: *5* sd.print_times
def print_times (self):

    sd = self
    times = (
        'parse_time',
        'pass1_time',
        # 'pass2_time', # the resolve_names pass is no longer used.
        'total_time',
    )
    max_n = 5
    for s in times:
        max_n = max(max_n,len(s))
    print('\nScan times...\n')
    for s in times:
        pad = ' ' * (max_n - len(s))
        print('%s%s: %2.2f' % (pad,s,getattr(sd,s)))
    print('')
.. @+node:ekr.20160109150703.7: *5* sd.print_stats
def print_stats (self):

    sd = self
    table = (
        '*', 'errors',

        '*Contexts',
        'classes','contexts','defs','modules',

        '*Statements',
        'assignments','calls','fors','globals','imports',
        'lambdas','list_comps','returns','withs',

        '*Names',
        'attributes','del_names','load_names','names',
        'param_names','param_refs','store_names',
        #'resolvable_names','relinked_names','relinked_pointers',
        # 'ivars',
        # 'resolved_contexts',
    )
    max_n = 5
    for s in table:
        max_n = max(max_n,len(s))
    print('\nStatistics...\n')
    for s in table:
        var = 'n_%s' % s
        pad = ' ' * (max_n - len(s))
        if s.startswith('*'):
            if s[1:].strip():
                print('\n%s\n' % s[1:])
            else:
                pass # print('')
        else:
            pad = ' ' * (max_n - len(s))
            print('%s%s: %s' % (pad,s,getattr(sd,var)))
    print('')
.. @+node:ekr.20171211054600.1: *4* OLD checkConventions (leoCheck.py)
def checkConventions(c):
    '''
    A stand-alone version of the @button node that tested the
    ConventionChecker class.
    
    The check-conventions command in checkerCommands.py saves c and reloads
    the leoCheck module before calling this function.
    '''
    g.cls()
    kind = 'all'
    project_name = 'leo'  # 'coverage', 'leo', 'lib2to3', 'pylint', 'rope'
    assert kind in ('all', 'file', 'production', 'string'), repr(kind)
    fn = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins', 'qt_tree.py')
    report_stats = True # and kind != 'production'
    trace_fn = True
    trace_skipped = False
    fails_dict = {
        'coverage': ['cmdline.py',],
        'lib2to3': ['fixer_util.py', 'fix_dict.py', 'patcomp.py', 'refactor.py'],
        'leo': [], # All of Leo's core files pass.
        'pylint': [
            'base.py', 'classes.py', 'format.py',
            'logging.py', 'python3.py', 'stdlib.py', 
            'docparams.py', 'lint.py',
        ],
        'rope': ['objectinfo.py', 'objectdb.py', 'runmod.py',],
    }
    fails = fails_dict.get(project_name, [])
    << define s >>
    s = g.adjustTripleString(s, c.tab_width)
    << old tests >>
    stats = Stats()
    if kind == 'production':
        for p in g.findRootsWithPredicate(c, c.p, predicate=None):
            x = ConventionChecker(c, stats)
            x.check(fn=g.fullPath(c, p), trace_fn=trace_fn)
    elif kind == 'all':
        utils = ProjectUtils()
        aList = utils.project_files(project_name, force_all=False)
        if aList:
            t1 = time.clock()
            for fn in aList:
                sfn = g.shortFileName(fn)
                if sfn in fails or fn in fails:
                    if trace_skipped: print('===== skipping', sfn)
                else:
                    ConventionChecker(c, stats).check(fn=fn, trace_fn=trace_fn)
            t2 = time.clock()
            print('%s files in %4.2f sec.' % (len(aList), (t2-t1)))
        else:
            print('no files for project: %s' % (project_name))
    elif kind == 'string':
        ConventionChecker(c, stats).check(s=s)
    else:
        assert kind == 'file', repr(kind)
        ConventionChecker(c, stats).check(fn=fn)
    if report_stats:
        stats.report()
.. @+node:ekr.20171211054736.2: *5* << define s >>
s = '''\
class T:
    
    def __init__(self, tempNode):
        self.tempNode = tempNode.copy()
    
    def setUp(self):
        tempNode = self.tempNode
        while tempNode.firstChild():
            tempNode.firstChild().doDelete()
'''

s_ok2 = '''
class Context(object):
    def __init__ (self, parent_context):
        self.parent_context = parent_context
        if parent_context:
            parent_context.inner_contexts_list.append(self)
'''
assert s_ok2

s_ok= '''
class TC:
    def __init__(self, c):
        c.tc = self
    def add_tag(self, p):
        print(p.v) # AttributeError if p is a vnode.

class Test:
    def __init__(self,c):
        self.c = c
        self.tc = self.c.tc
    def add_tag(self):
        p = self.c.p
        self.tc.add_tag(p.v) # WRONG: arg should be p.
'''
assert s_ok

.. @+node:ekr.20171211054736.3: *5* << old tests >>
s_passes_1 = '''\
class C1:
        
    def f1(self, p):
        print(p.v)
        
    def f2(self, p):
        self.f1(p.v) # WRONG

'''
assert s_passes_1

s_1 = '''\
class C1:

    def __init__(self, c):
        self.c = c
        c.theTagController = self
        
    def add_tag(self, p):
        pass

class C2:

    def oops(self, p):
        c.tagController.add_tag(p.v,tag)
            # WRONG: should be p.

'''
assert s_1


s_2 = '''\
class TagController:

    def __init__(self, c):
        self.c = c
        c.theTagController = self

    def add_tag(self, p, tag):
        # Will fail if p is a vnode
        tags = set(p.v.u.get('__node_tags', set([])))

class LeoTagWidget(QtWidgets.QWidget):

    def __init__(self,c,parent=None):
        self.c = c
        self.tc = self.c.theTagController

    def add_tag(self, event=None):
        p = self.c.p
        self.tc.add_tag(p.v,tag) # WRONG: should be p.

'''
assert s_2
.. @+node:ekr.20141012064706.18394: *3* d.extra_attributes & helpers (not used)
def extra_attributes(self, node):
    '''Return the tuple (field,repr(field)) for all extra fields.'''
    d = {
        # 'e': self.do_repr,
        # 'cache':self.do_cache_list,
        # 'reach':self.do_reaching_list,
        # 'typ':  self.do_types_list,
    }
    aList = []
    for attr in sorted(d.keys()):
        if hasattr(node, attr):
            val = getattr(node, attr)
            f = d.get(attr)
            s = f(attr, node, val)
            if s:
                aList.append((attr, s),)
    return aList
.. @+node:ekr.20141012064706.18395: *4* d.do_cache_list
def do_cache_list(self, attr, node, val):
    return self.node.dump_cache(node)
.. @+node:ekr.20141012064706.18396: *4* d.do_reaching_list
def do_reaching_list(self, attr, node, val):
    assert attr == 'reach'
    return '[%s]' % ','.join([repr(z) for z in getattr(node, attr)])
        # self.format(z).strip() or repr(z)
        # for z in getattr(node, attr)])
.. @+node:ekr.20141012064706.18397: *4* d.do_repr
def do_repr(self, attr, node, val):
    return repr(val)
.. @+node:ekr.20141012064706.18398: *4* d.do_types_list
def do_types_list(self, attr, node, val):
    assert attr == 'typ'
    return '[%s]' % ','.join(
        [repr(z) for z in getattr(node, attr)])
.. @+node:ekr.20180319073449.1: *3* Theme stuff (no longer used)
.. @+node:ekr.20180310092706.1: *4* LM.loadAllLoadedThemes (TO BE REMOVED)
def loadAllLoadedThemes(self, c, old_c):
    '''
    Load all previously-loaded themes.
    Do *not* load settings files again.
    '''
    # Called by the 'new' command.
    ssm = old_c.styleSheetManager
    for path in g.app.loadedThemes:
        g.trace('===== Reloading Theme', path)
        ssm.load_theme_file(c, path, old_c=old_c, reload_flag=True)
.. @+node:ekr.20180318131632.1: *4* LM.doThemes (no longer used)
def doThemes(self):
    '''
    Close the theme file unless it is the only file.
    Otherwise, handle @theme-name setting.
    '''
    trace = True
    lm = self
    aList = g.app.commanders()
    path = lm.options.get('theme_path')
    if path and len(aList) > 1:
        frame = aList[-1].frame
        if trace: g.trace('CLOSING --THEME FILE:', path)
        g.app.closeLeoWindow(frame, new_c=None, finish_quit=False)
        return
    # Get the setting directly from myLeoSettings.leo.
    # This can not be done in lm.scanOptions because settings have not been read.
    gs = lm.globalSettingsDict.get('themename')
    if not (gs and gs.val and g.isString(gs.val)):
        return
    path = g.toUnicode(gs.val)
    path = lm.computeThemeFilePath(path)
    # if trace: g.trace('@string theme-name: %s' % path)
    if path in lm.files:
        if trace: g.trace('THEME FILE IN FILES LIST: %s' % path)
        return
    # Apply the theme by loading the file, then immediately closing it.
    if trace: g.trace('APPLYING THEME FILE:', path)
    c = lm.loadLocalFile(path, gui=g.app.gui, old_c=None)
    g.app.closeLeoWindow(c.frame, new_c=None, finish_quit=False)
.. @+node:ekr.20180308102949.1: *4* ssm.load_theme_file & helpers (TO BE REMOVED)
def load_theme_file(self, c, path, old_c=None, reload_flag=False):
    '''Load a theme file, without setting any actual settings.'''
    path = self.find_theme_file(path)
    if not path: return
    if old_c:
        settings_d = old_c.config.settingsDict
    else:
        settings_d = self.read_theme_settings(path)
    # Compute the style-sheet.
    sheet = self.compute_style_sheet_from_settings_d(settings_d)
    # Update the global settings from the settings_d.
    c.config.settingsDict.update(settings_d)
    # Update g.app.gui ivars.  g.app.gui.reload_settings() doesn't work.
    if hasattr(g.app.gui, 'color_theme'):
        g.app.gui.color_theme = c.config.getString('color_theme')
        g.app.gui.iconimages = {} # Clear the icon cache.
    # Reload the stylesheet *after* updating settings.
    if sheet:
        self.reload_settings(sheet=sheet)
    # Remember the theme.
    if not reload_flag:
        g.app.loadedThemes.append(path)
.. @+node:ekr.20180308105850.1: *5* ssm.compute_style_sheet_from_settings_d
def compute_style_sheet_from_settings_d(self, settings_d):
    '''
    Compute and set the style sheet from settings_d,
    a TypedDict whose values are GeneralSetting objects.
    '''
    trace = False and not g.unitTesting
    trace_after = True
    trace_before = False
    trace_dict = False
    ssm = self
    d1 = settings_d.get('qtguipluginstylesheet')
    d2 = settings_d.get('qtguiuserstylesheet')
    if not d1 and not d2:
        # Do nothing if neither stylesheet exists.
        # This allows settings-only themes.
        if trace: g.trace('no stylesheets')
        return None
    # A little hack for ssm.replace_indicator_constants.
    # Update c.config.settingsDict here.
    for name in ('treeimageclosed', 'treeimageclosed'):
        val = settings_d.get(name)
        if val is not None:
            self.c.config.settingsDict[name] = val
    if trace and trace_dict:
        g.trace('settings_d')
        g.printObj(settings_d)
    # pylint: disable=consider-using-ternary
    aList1 = d1 and d1.val or []
    aList2 = d2 and d2.val or []
    if trace and trace_before:
        g.trace()
        g.printObj(aList1[:20])
        g.printObj(aList2[:20])
    sheet = ''.join(aList1 + aList2)
    sheet = ssm.expand_css_constants(sheet, settingsDict=settings_d)
    if trace and trace_after:
        g.trace('\n'+sheet)
    return sheet
.. @+node:ekr.20180310112320.1: *5* ssm.read_theme_settings
def read_theme_settings(self, path):
    '''Return the theme settings.'''
    lm = g.app.loadManager
    old_commanders = g.app.commanders()
    # Read the theme file into c2, a hidden commander.
    c2 = lm.openSettingsFile(path)
    # Get settings *without* application defaults.
    junk_shortcuts_d, settings_d = lm.createSettingsDicts(c2,
        localFlag=False, # doesn't matter: it affects only menus & shortcuts.
        theme=True, # Parse only the @theme True.
    )
    assert isinstance(settings_d, g.TypedDict), repr(settings_d)
    # Clear the cache entries for hidden commander.
    if c2 not in old_commanders:
        g.app.forgetOpenFile(c2.fileName())
    return settings_d
.. @+node:ekr.20140912110338.19365: *4* ssm.get_stylesheet & helpers (no longer used??)
def get_stylesheet(self):
    '''
    Scan for themes or @data qt-gui-plugin-style-sheet nodes.
    Return the text of the relevant node.
    '''
    themes, theme_name = self.find_themes()
    if themes:
        return self.get_last_theme(themes, theme_name)
    else:
        g.es("No theme found, assuming static stylesheet")
        return self.get_last_style_sheet()
.. @+node:ekr.20140912110338.19368: *5* ssm.find_themes (no longer used)
def find_themes(self):
    '''Find all theme-related nodes in the @settings tree.'''
    themes, theme_name = [], 'unknown'
    for p in self.settings_p.subtree_iter():
        if p.h.startswith('@string color_theme'):
            theme_name = p.h.split()[-1]
            themes.append((theme_name, p.copy()))
        elif p.h == 'stylesheet & source':
            theme_name = 'unknown'
            themes.append((theme_name, p.copy()))
    return themes, theme_name
.. @+node:ekr.20140912110338.19367: *5* ssm.get_last_style_sheet
def get_last_style_sheet(self):
    '''Return the body text of the *last* @data qt-gui-plugin-style-sheet node.'''
    sheets = [p.copy() for p in self.settings_p.subtree_iter()
        if p.h == '@data qt-gui-plugin-style-sheet']
    if sheets:
        if len(sheets) > 1:
            g.es("WARNING: found multiple\n'@data qt-gui-plugin-style-sheet' nodes")
            g.es("Using the *last* node found")
        else:
            g.es("Stylesheet found")
        data_p = sheets[-1]
        return data_p.b
    else:
        g.es("No '@data qt-gui-plugin-style-sheet' node")
        # g.es("Typically 'Reload Settings' is used in the Global or Personal "
             # "settings files, 'leoSettings.leo and 'myLeoSettings.leo'")
        return None
.. @+node:ekr.20140912110338.19366: *5* ssm.get_last_theme
def get_last_theme(self, themes, theme_name):
    '''Return the stylesheet of the last theme.'''
    g.es("Found theme(s):")
    for name, p in themes:
        g.es('found theme:', name)
    if len(themes) > 1:
        g.es("WARNING: using the *last* theme found")
    theme_p = themes[-1][1]
    unl = theme_p.get_UNL() + '-->'
    seen = 0
    for i in theme_p.subtree_iter():
        # Disable any @data qt-gui-plugin-style-sheet nodes in theme's tree.
        if i.h == '@data qt-gui-plugin-style-sheet':
            i.h = '@@data qt-gui-plugin-style-sheet'
            seen += 1
    if seen == 0:
        g.es("NOTE: Did not find compiled stylesheet for theme")
    elif seen > 1:
        g.es("NOTE: Found multiple compiled stylesheets for theme")
    text = [
        "/*\n  DON'T EDIT THIS, EDIT THE OTHER NODES UNDER "
        "('stylesheet & source')\n  AND RECREATE THIS BY "
        "Alt-X style-reload"
        "\n\n  AUTOMATICALLY GENERATED FROM:\n  %s\n  %s\n*/\n\n"
        % (
            theme_p.get_UNL(with_proto=True),
            datetime.datetime.now().strftime('%Y-%m-%d %H:%M'),
        )]
    for i in theme_p.subtree_iter():
        src = i.get_UNL().replace(unl, '')
        if i.h.startswith('@data '):
            i.h = '@' + i.h
        if ('@ignore' in src) or ('@data' in src):
            continue
        text.append("/*### %s %s*/\n%s\n\n" % (
            src, '#' * (70 - len(src)),
            i.b.strip()
        ))
    stylesheet = '\n'.join(text)
    if self.safe:
        g.trace('Stylesheet:\n' % stylesheet)
    else:
        data_p = theme_p.insertAsLastChild()
        data_p.h = '@data qt-gui-plugin-style-sheet'
        data_p.b = stylesheet
        g.es("Stylesheet compiled")
    return stylesheet
.. @+node:ekr.20180308103151.1: *4* ssm.find_theme_file
def find_theme_file(self, path):
    trace = False and not g.unitTesting
    for directory in self.compute_theme_directories():
        path2 = g.os_path_finalize_join(directory, path)
        if g.os_path_exists(path2):
            if trace: g.trace('found', path2)
            return path2
        elif trace:
            g.trace('not found', path2)
    g.es_print('Theme not found:', path)
    return None
.. @+node:ekr.20150514063305.213: *3* ec.evalExpression
@cmd('eval-expression')
def evalExpression(self, event):
    '''Evaluate a Python Expression entered in the minibuffer.'''
    k = self.c.k
    k.setLabelBlue('Eval: ')
    k.get1Arg(event, handler=self.evalExpression1)

def evalExpression1(self, event):
    k = self.c.k
    k.clearState()
    try:
        e = k.arg
        result = str(eval(e, {}, {}))
        k.setLabelGrey('Eval: %s -> %s' % (e, result))
    except Exception:
        k.setLabelGrey('Invalid Expression: %s' % e)
.. @-all
.. @@nosearch
.. @-leo
