.. @+leo-ver=5-thin
.. @+node:ekr.20100805165051.7146: * @file tutorial.txt
.. @@language rest
.. @@tabwidth -4

.. @+at @rst-options
..  call_docutils=False
..  code_mode=False
..  generate_rst=True
..  http_server_support = False
..  show_organizer_nodes=True
..  show_headlines=True
..  show_leo_directives=True
..  stylesheet_path=..\doc
..  write_intermediate_file = True
..  verbose=True
.. @@c

.. @+all
.. @+node:ekr.20091130111843.6788: ** @rst html\tutorial.html
##############
Leo's Tutorial
##############

.. index:: Leo's tutorial

.. _`Python`: http://www.python.org/
.. _`cheat sheet`: http://leoeditor.com/cheatsheet.html

Leo is a power tool for people who want to organize, study and work with
data, especially complex data like computer programs, books, web sites and
data bases. Leonistas say Leo is a revolutionary tool and that Leo is fun
to use--even addictive.

Leo looks like other outlining programs, but it is not. This tutorial
explains the difference.

There are four partsEach part will take about 30
minutes to read. The last part is optional, and assumes some familiarity
with programming in `Python`_.

This chapter concludes with a `cheat sheet`_ summarizing Leo's essential
features.

.. toctree::
   :maxdepth: 4
   :glob:
.. @+node:ekr.20131008041326.16067: *3* @rst-no-head links & markup
.. |br| raw:: html

   <br />

.. _Leo:    http://leoeditor.com/
.. _`ask for help`: https://groups.google.com/forum/#!forum/leo-editor
.. @+node:ekr.20131008041326.16077: *3* Creating and editing outlines
.. @+node:ekr.20131002211347.6456: *4* Command names
Every Leo command has a **command name**. In this document, keystrokes that
invoke a command will be followed by the command name in parentheses.

For example, Ctrl-S (save-file) saves a Leo file.

The full-command (Alt-X) command executes any other command by typing its
full name. For full details see `The minibuffer & completions`_.
.. @+node:ekr.20131002055813.15973: *4* Leo's main window
Here is a slightly reduced screenshot of Leo's main window:

.. image:: screen-shots/render-svg-sources.png
   :alt: Screenshot
   :scale: 80 %

Leo's main window consists of
an **outline pane** at the top left,
a **log pane** at the top right,
a **body pane** at the bottom left,
and an optional **viewrendered pane** at the bottom right.
The **minibuffer** and **status line** lie at the bottom of the main window.

The log pane contains several tabs. The **Log tab** shows messages from
Leo, the **Find Tab** shows the status of Leo's Find/Replace commands.
Other tabs may also appear in the log pane: The **Spell Tab** controls
Leo's spell-checking. The **Completion Tab** shows available typing
completions.

Leo stores all data in **nodes**. Nodes have **headlines**, shown in
the outline pane, and **body text**. The body pane shows the body text of
the **presently selected node**, the node whose headline is selected in the
outline pane.  Headlines have an **icon box** indicating a nodes status.
For example, the icon box has a black border when the node has been changed.
.. @+node:ekr.20131004191204.16079: *4* Operations on windows, panes & files
Alt-0 (vr-toggle) hides or shows the viewrendered pane.

<Return> puts focus in the body when it is in the outline pane. |br|
Alt-T (focus-to-tree) puts focus in the outline pane.  |br|
Ctrl-T (toggle-active-pane) toggles focus between the outline and body panes.

You may open multiple Leo outlines in different tabs within the same main
window. |br|
Ctrl-Tab (tab-cycle-next) switches between outline tabs.

Ctrl-N (new) creates a new outline in a new tab. |br|
Ctrl-O (open-outline) opens an existing .leo file. |br|
Ctrl-S (save-file) saves the outline. |br|
Ctrl-Q (exit-leo) exits Leo.  Leo will prompt you to save any unsaved outlines.
.. @+node:ekr.20131002055813.19835: *4* Operations on nodes
Ctrl-I or Insert (insert-node) inserts a new node into the outline.

Regardless of focus, Ctrl-H (edit-headline) begins editing the headline of
the selected node.  |br|
When editing a headline, <Return> (end-edit-headline) ends the editing,
leaving the focus in the body pane.

Ctrl-Shift-X (cut-node) cuts the outline and all its descendants, placing
the node on the clipboard. |br|
Ctrl-Shift-V (paste-node) pastes a node (and its descendants) from the
clipboard after the presently selected node.

Ctrl-{ (promote) makes all the children of a headline siblings of the
headline. |br|
Ctrl-} (demote) makes all following siblings of a headline children of the
headline. |br|
The demote and promote commands are useful for gathering nodes together before
moving or cutting them.

Ctrl-M (mark) toggles the mark on a node. |br|
Marked nodes have a vertical red bar in their icon area.

.. @+node:ekr.20131002055813.19036: *4* Selecting and moving outline nodes
You may select, expand and contract outline nodes with the mouse as usual,
but using arrow keys is *highly recommended*.

When focus is in the outline pane, *plain* arrows keys change the selected node:

- Right-arrow (expand-and-go-right) expands a node or selects its first child.
- Left-arrow (contract-or-go-left) contracts a node if its children are visible,
  and selects the node's parent otherwise. 
- Up-arrow (goto-prev-visible) selects the next *visible* outline node.
- Down-arrow (goto-next-visible) selects the previous *visible* outline node.
  
When focus is in the outline pane, Shift-arrow keys move the selected node
in the direction of the arrow, if possible.

Regardless of focus, Alt-arrow and Alt-Shift-arrow keys work on outline nodes:

- Alt-Home (goto-first-visible-node) selects the first outline node.
- Alt-End (goto-last-visible-node) selects the last *visible* outline node.
- Alt-arrow keys select the outline pane, and then act just like the plain
  arrow keys when the outline pane has focus.
- Alt-Shift-arrow keys select the outline pane and move the selected node.

The following commands work anywhere, regardless of focus:

- Ctrl-D (move-outline-down) moves the selected node down.
- Ctrl-L (move-outline-left) moves the selected node left.
- Ctrl-R (move-outline-right) moves the selected node right.
- Ctrl-U (move-outline-up) moves the selected node up.
.. @+node:ekr.20131002055813.19037: *4* Moving the cursor in text panes
When focus is in any of Leo's text panes (body pane, log pane, headlines),
Leo work like most text editors:

- Plain arrow keys move the cursor up, down, left or right.
- Ctrl-LeftArrow and Ctrl-RightArrow move the cursor by words.
- Home and End move the cursor to the beginning or end of a line.
- Ctrl-Home moves the cursor to the beginning of the body text.
- Ctrl-End moves the cursor to the end of the body text.
- PageDown and PageUp move the cursor up or down one page.

**Note**: As usual, adding the Shift key modifier to any of the keys above
moves the cursor and extends the selected text.
.. @+node:ekr.20131001100335.15946: *4* The minibuffer & completions
Leo’s minibuffer appears at the bottom of Leo’s main window. You use the
minibuffer to execute commands by name, and also to accumulate arguments to
commands.

Alt-X (full-command) puts the cursor in the minibuffer.

You could type the full command name in the minibuffer, followed by the
<Return> key to invoke the command, but that would be *way* too much work.
Instead, you can avoid most typing using **tab completion**. With tab
completion, there is no need to remember the exact names of Leo’s commands.

For example, suppose you want to print out the list of Leo’s commands. You
might remember only that there are several related commands and that they
all start with "print". Just type::

    <Alt-X>pri<Tab>

You will see "print-" in the minibuffer. This is the longest common prefix
of all the command names that start with "pri". The Completion tab in the log pane
shows all the commands that start with "print-".

Now just type "c<Tab>" and you will see the print-commands command in the
minibuffer.

Finally, <Return> executes the command.

The output of the print-commands command appears in the commands tab, and
focus returns to the body pane.

Summary:

- <Return> executes the command
- <Tab> shows all valid completions.
- <BackSpace> shows more alternatives.
- Ctrl-G exits the minibuffer and puts focus in the body pane.
.. @+node:ekr.20131001100335.15938: *4* Finding & replacing text
Ctrl-F (search-with-present-options) shows the Find Tab and puts the focus
in the minibuffer. |br|
**Important**: the Find tab just shows you the status of search and replace
operations. |br|
You control those operations from the minibuffer.

**Note**: You can toggle the radio buttons and check boxes in the Find Tab
with Ctrl-Alt keys. For example, Ctrl-Alt-X (toggle-find-regex-option)
toggles the Regexp checkbox.

After typing Ctrl-F, type the search string, say "def", in the minibuffer.

Start the find by typing <Return>.

But suppose you want to replace "def" with "foo", instead of just finding
"foo".

Before typing <Return> type Shift-Ctrl-R. The minibuffer prompts for the
replacement string. Notice that the status area now shows “def” as the Find
string.

Type "foo" and type <Return> to start the find-next command.

When Leo finds the next instance of "def", it will select it. |br|
You may type any command.  The following are most useful:

- Ctrl-minus (replace-then-find) replaces the selected text.
- F3 (find-next) continues searching without making a replacement.
- F2 (find-previous) continues the search in reverse.
- Ctrl-G (keyboard-quit) ends the search.
.. @+node:ekr.20131002055813.19837: *4* Undoing and redoing changes
Leo has unlimited undo--Leo remembers *all* changes you make to outline
structure or the contents of any node since you restarted Leo.

Ctrl-Z (undo) undoes the last change. Another Ctrl-Z undoes the
previous change, etc. 

Ctrl-Shift-Z (redo) undoes the effect of the last undo, etc.

The first two entries of the Edit menu show what the next undo or redo
operation will be.
.. @+node:ekr.20131001100335.15947: *4* Getting help
F1 (help) shows a help message appears in the viewrendered pane.
Alt-0 (vr-toggle) hides or shows this pane.

F11 (help-for-command) shows the documentation for any Leo command. F11
prompts for the name of a Leo command in the minibuffer. Use tab completion
to see the list of all commands that start with a given prefix.

F12 (help-for-python) shows the documentation from Python's help system.
Typing completion is not available: type the full name of any Python
module, class, function or statement.

These commands clarify which settings are in effect, and where they came
from::

    print-bindings
    print-settings

These commands discuss special topics::

    help-for-abbreviations
    help-for-autocompletion
    help-for-bindings
    help-for-debugging-commands
    help-for-dynamic-abbreviations
    help-for-find-commands
    help-for-minibuffer
    help-for-regular-expressions

Using Leo, especially for programming, requires some learning initially.
Please feel free to `ask for help`_ at any time.
.. @+node:ekr.20131004064408.16020: *4* Leo directives
.. .. index::
..    pair: Directive; Tutorial

**Directives** control Leo's operations.
Directives start with '@' in the leftmost column.

Directives may appear either in headlines or body text.

Directives apply until overridden by the same (or related) directive in a
descendant node.

Some commonly used general-purpose directives:

.. .. glossary::

..  .. index::
    ..  pair: @color; Tutorial
    ..  pair: @nocolor; Tutorial
    ..  pair: @killcolor; Tutorial

::

    @color
    @killcolor
    @nocolor

These control whether to syntax color text. 

Nodes may contain multiple color directives.

Nodes containing multiple color directives do not affect coloring of
descendant nodes.
    
..  .. index::
    ..  pair: @language; Tutorial

::

    @language python
    @language c
    @language rest # restructured text
    @language plain # plain text: no syntax coloring.
    
These control which language to use when syntax coloring text.
    

..  .. index::
    ..  pair: @pagewidth; Tutorial
    
::

    @pagewidth 100
    
Sets the page width used when formatting paragraphs.

..  .. index::
    ..  pair: @tabwidth; Tutorial
    ..  pair: Negative tab width; Tutorial

::

    @tabwidth -4
    @tabwidth 8
    
Sets the width of tabs.

Negative tab widths cause Leo to convert tabs to
spaces and are highly recommended for Python programming.

..  .. index::
    ..  pair: @wrap; Tutorial
    ..  pair: @nowrap; Tutorial
    
::

    @nowrap
    @wrap

These enable or disable line wrapping in the body pane.

.. @+node:ekr.20131001100335.15940: *4* Configuring Leo
Leo has a flexible (perhaps *too* flexible) configuration system. It's best
to use this flexibility in a restricted way as follows:

1. The file leo/config/leoSettings.leo contains Leo's default settings.
   Don't change this file unless you are one of Leo's developers.
   
2. The file ~/myLeoSettings.leo contains your personal settings. Leo will
   not create this file automatically: you should create it yourself.
   Settings in myLeoSettings.leo override (or add to) the default settings
   in leoSettings.leo.
   
3. Any other .leo file may also contain settings. Such settings apply only
   to that file and override all other settings. It's best to use such
   settings sparingly.
   
As a result, settings may vary from one Leo file to another. This can be
confusing. These two commands can help:

- print-settings shows each setting and where it came from.
  
- print-bindings shows each key binding and where it came from.

**Important**: within any file, settings take effect **only** if they are
contained in an **@settings tree**, that is, are descendants of a node
whose headline is @settings. Nodes outside @settings trees do not affect
settings in any way.

Within @settings trees, you specify boolean settings with @bool nodes,
string settings with @string nodes, menus with @menus and @menu nodes, etc.
For exact details, please do study leoSettings.leo. You can open either
leoSettings.leo or myLeoSettings.leo from the Help menu. Within
leoSettings.leo:

- The node "About this file" explains about settings.
- The node "Candidates for settings in myLeoSettings.leo" highlights the
  settings you are most likely to want to customize.

.. @+node:ekr.20131005214621.16090: *4* Summary
Here are the most important things to remember:

- Every command has a name.

- You may execute any command by name from the minibuffer.

- Many commands are bound to keystrokes.

- You may bind multiple keystrokes to a single command and change bindings to your taste.

- Leo has commands to create, change and reorganize outlines.

- Within the body pane, Leo uses standard key bindings to move the cursor.

- Ctrl-F starts the find command. Use the minibuffer to complete the command.

- Leo's configuration files specify all settings, including key bindings.

- Leo directives control how Leo works.

.. @+node:ekr.20131008041326.16074: *3* External files & clones
.. @+node:ekr.20131002055813.19697: *4* Creating external files
.. _`Intermediate Topics tutorial`: http://leoeditor.com/basics2.html
.. _`Using @auto and friends`: http://leoeditor.com/basics2.html#using-auto-nodes

Leo stores outline data on your file system in **.leo files**.

Rather than storing all your data in the .leo file, you may store parts of
your outline data in **external files**, files on your file system.

**@file nodes** create external files. @file nodes have headlines starting
with @file followed by a file name::

    @file leoNodes.py
    @file ../../notes.text

Leo reads external files automatically when you open Leo outline, and
writes all **dirty** (changed) external files when you save any Leo
outline.

When writing @file nodes, Leo adds **sentinel comments** to external files.
Sentinels embed Leo's outline structure into external files.

If you don't want sentinels in your sources, skip head to
`Using @auto and friends`_ in Leo's `Intermediate Topics tutorial`_.

.. @+node:ekr.20131003040744.18221: *5* Creating non-programming files with @all
Use the **@all** directive for non-programming files. @all tells Leo to
write the **@file tree** (the @file node and all its descendants) to the
external file in **outline order**, the order in which the nodes appear in
the outline pane when all nodes are expanded.
.. @+node:ekr.20131003040744.18222: *5* Creating programming source files with @others
Now we come to the programming features that distinguish Leo from all other
programming environments. Please study this section carefully if you intend
to use Leo for programming. If you get stuck, please `ask for help`_
immediately.

The @others directive, and markup called section references (see below),
tell Leo how to create external files.

**Essential Terms**:

- A **section name** is any text of the form: << any text >>.
  (>> must not appear in "any text".)
- A **section definition node** is any node whose headline starts with a
  section name.
- A **section reference** is a section name that appears in body text.

Leo creates external files containing @others directives by writing the
*expansion* of the @file node. |br|
The **expansion** of *any* node is
then ode's body text after making these text **substitutions**:

1. Leo replaces @others with the *expansion* of all descendant nodes
   **except** section definition nodes. That's how @others got its name.

2. Leo replaces section references by the *expansion* of the body text of
   the corresponding section definition node.
   
Whitespace is significant before @others and section references. Leo adds
the leading whitespace appearing before each @others directive or section
reference to every line of their expansion. As a result, Leo can generate
external files even for Python.  The following cute trick works::

    if 1:
        << a section >>
    if 0:
        @others

**Notes**:

- Any node may contain a single @others directive. No node may contain more
  than one @others directive.

- Nodes that *aren't* section definition nodes are included in the expansion
  of the *nearest* ancestor node containing an @others directive.

- An **orphan node** is a descendant of an @file node not included in any
  substitution. Leo refuses to write external files containing orphan
  nodes. Instead, Leo writes the @file tree to the .leo file itself,
  thereby preserving all data.

**Example 1**: The body of the @file node for a typical Python module will
look something like::

    '''A docstring.'''
    << imports >>
    @others
    if __name__ == '__main__':
        main()
        
**Example 2**:  Here is a typical Python class definition in Leo::

    class MyClass:
        '''A docstring.'''
        @others
.. @+node:ekr.20131008041326.16072: *4* Using @auto
.. @+node:ekr.20131004073415.16044: *4* Clones
..  .. index::
    ..  pair: Clone; Tutorial
    
A **clone** is a node that appears in more than one place in a Leo outline.
Clones are marked with a small red arrow in its icon box. 

All clones of a node are actually *the same node*, so any change to one
clone affects all clones. Inserting, moving or deleting any child of a
clone will change all other clones on the screen.
    
Clones are one of Leo's most powerful features.
Clones allow data to be stored in *arbitrarily many* places within an outline.

Please take a few moments to experiment with clones:

- Create a node whose headline is A.
- Ctrl-` (clone-node) clones node A.
- Type some text into the body of A.
- All clones of A now have the same body.
- Insert a node, say B, as a child of any of the A nodes.
- All the A nodes now have a B child.
- See what happens if you clone B.
- See what happens if you insert, delete or move nodes that are children of A.
- When you delete a node's penultimate clone,
  the last clone becomes a regular node again.

.. @+node:ekr.20131004073415.16045: *4* Views
..  .. index::
    ..  pair: Views; Tutorial

Using clones, you can create as many views of your data as you like.

Views gather data for bug fixes, design review or whatever.

To create a new view:

- Create an *ordinary* (non-cloned) node, to represent the view.
  Let's call this the **view node**.

- Clone the nodes from the outline that you want contained in the view.

- "Add" these clones to the view node by moving them so they become children
  of the view node.

- You can also add uncloned nodes to the view node.

It's particularly useful to create a new view for each programming task:

- Add clones of all nodes related to the task to the view node.

- Now you can work on nodes in a single place; the location of the original
  clones doesn't matter.
.. @+node:ekr.20131008041326.16066: *4* Summary
- Leo creates external files by replacing @others and section references
  with their expansions. 
.. @+node:ekr.20131008041326.16075: *3* Creating documents
.. @+node:ekr.20131005040354.16072: *4* Using abbreviations & templates
.. @+node:ekr.20131001100335.15939: *4* Creating documents with reStructuredText
.. _`docutils`: http://docutils.sourceforge.net
.. _`LaTeX`: http://www.latex-project.org/
.. _`reStructuredText`: http://docutils.sourceforge.net/rst.html
.. _`Sphinx`: http://sphinx.pocoo.org/
.. _`this chapter`: http://leoeditor.com/rstplugin3.html
.. _`Leo's Users Guide`: http://leoeditor.com/leo_toc.html

The rst3 command converts an @rst tree to `reStructuredText`_ (rST) and sends
the result to `docutils`_ or `Sphinx`_ for further processing.

With this tool chain, you can easily create HTML, PDF, LaTeX and other
kinds of documents. All of Leo's documentation is written in Sphinx and
processed with the rst3 command to produce HTML files.

In "plain" rST, you denote sections by underlining heading names.
Reorganizing an document is tedious: you have to change the underlining
characters by hand.

In contrast, the rst3 command automatically creates rST sections from
headlines. Reorganizing your document is easy--just reorganize your @rst
tree. You don't have to change rST markup!

The rst3 command provides *many* other capabilities for power users. For
full details, see `this chapter`_ in `Leo's Users Guide`_.
.. @+node:ekr.20131005214621.16128: *4* Summary
.. @+node:ekr.20131008041326.16076: *3* Programming with Leo
.. @+node:ekr.20131008041326.16051: *4* Scripting Leo
.. @+node:ekr.20131008041326.16052: *5* Leo scripts
Ctrl-B (execute-script) executes the body pane after expanding @others and
section references throughout the tree. The symbols 'c', 'g' and 'p'
are predefined as follows:

- c is the Commander of the outline in which the script is executing.
- g is the leo.core.leoGlobals module.
- p is c.p (the same as c.currentPosition())

These three predefined variables give any Leo script full access to
all methods defined in Leo's source code. Examples::

    c.redraw() # requests redraw of Leo's screen.
    g.es(s) # prints string s to the log window.
    g.app # the singleton instance of the leoApp class.
    g.app.gui # the the singleton instance of the leoGui class.
    g.app.windowList # the list of presently open frames.

    # Returns list of all open commanders
    commanders = [frame.c for frame in g.app.windowList]

For any position p, here are p's getters::

    p.b # p's body text.
    p.h # p's headline.
    p.u # p's uA, the same as p.unknownAttributes.
    p.v # the vnode corresponding to p.
    p2 = p.copy() # p2 is a copy of p.

    # Returning ints:
    
        p.childIndex()
        p.numberOfChildren()
        p.level()

    # Returning bools:
    
        p.hasChildren()
        p.isAncestorOf(v2) # True if v2 is a child, grandchild, etc. of p.
        p.isCloned()
        p.isDirty()
        p.isExpanded()
        p.isMarked()
        p.isVisible()
        p.isVisited()
        
Here are p's most important setters::

    p.b = s  # Sets the body text of p.
    p.h = s  # Sets the headline text of p.
    p.u = aDict # Sets p.u to the given dictionary.

Here is the list of Leo's iterators::

    c.all_nodes             # all vnodes in c.
    c.all_unique_nodes      # all unique vnodes in c.
    c.all_positions         # all positions in c.
    c.all_unique_positions  # all unique positions in c.

    p.children              # all children of p.
    p.following_siblings    # all siblings of p that follow p.
    p.nodes                 # all vnodes in p's subtree.
    p.parents               # all parents of p.
    p.self_and_parents      # p and all parents of p.
    p.siblings              # all siblings of p, including p.
    p.subtree               # all positions in p's subtree, excluding p.
    p.self_and_subtree      # all positions in p's subtree, including p.
    p.unique_nodes          # all unique vnodes in p's subtree.
    p.unique_subtree        # all unique positions in p's subtree.

.. @+node:ekr.20131008041326.16053: *5* Plugins
Scripting plugins is exactly like writing Leo scripts,
except that plugins must compute c, g and p as follows:

**g**::

    import leo.core.leoGlobals as g
    
**c**:

In the top-level init function::

    g.registerHandler(event_name,my_event_handler)

Define event_handler as follows::

    def my_event_handler (kind,keywords):
        c = keywords.get('c'):
        if c:
            ...
   
**p**::

    p = c.p
.. @+node:ekr.20131008041326.16054: *4* Using @first
..  .. index::
    ..  pair: @first; Tutorial

The @first directive forces a lines to appear before the first sentinel of a
external file. For example::

    @first #! /usr/bin/env python
    @first # -*- coding: utf-8 -*-
.. @+node:ekr.20131008041326.16055: *4* Using @path
..  .. index::
    ..  pair: @path; Tutorial

Rather than specifying long paths in @file nodes, you can specify a path in
an ancestor @path node.

For example, suppose three nodes have the following headlines::

    @path a
        @path b
            @file c/d.py

Because of the ancestor @path nodes, the @file node creates the file
a/b/c/d.py

Within @path and @<file> paths, {{exp}} gets evaluated with the following
symbols known: c, g, p, os and sys.  For example::

    @file {{os.path.abspath(os.curdir)}}/abc.py

refers to the file abc.py in (absolute path of) the current directory.
.. @+node:ekr.20131008041326.16056: *4* Using @auto nodes
.. @+node:ekr.20131008041326.16057: *4* Using @button nodes
.. @+node:ekr.20131008041326.16058: *4* Using @test nodes
.. @+node:ekr.20131004172324.16075: *4* Autocompletion
Start or stop autocompletions with Alt-1 (toggle-autocompleter)

Leo's autocompletion feature suggests **completions**, text may be valid in
a given point in source code. For example, suppose the cursor follows::

    os.path.os.st
    
The valid completions are all the members of Python's os.path module whose
names start with 'st'. The valid completions appear in a Tab in the Log
Pane.

Leo also shows completions. These completions assume that c is a commander,
g is the leoGlobals object and p is a position.
.. @-all
.. @-leo
