.. @+leo-ver=5-thin
.. @+node:ekr.20100805165051.7164: * @thin rstplugin3.txt
.. @@language rest
.. @@tabwidth -4

.. @+all
.. @+node:ekr.20050818163826: ** @rst html\rstplugin3.html
.. publish_argv_for_missing_stylesheets = --language=de,--documentclass=report,--use-latex-toc

@ @rst-options
call_docutils=False
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
show_options_doc_parts=False
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

######################################
Chapter 14: Leo and ReStructuredText
######################################

.. .. contents::
.. @+node:ekr.20050818163826.1: *3* @rst-no-head links
.. rST links used in this document...

.. External links...
.. _docutils:               http://docutils.sourceforge.net
.. _LaTeX:                  http://www.latex-project.org/
.. _reStructuredText:       http://docutils.sourceforge.net/rst.html
.. _SilverCity:             http://silvercity.sourceforge.net
.. _Sphinx:                 http://sphinx.pocoo.org/
.. _`Leo's Google Group`:   http://groups.google.com/group/leo-editor

.. Hard links to Leo's web site...
.. _ListManagerDocs.html: http://webpages.charter.net/edreamleo/ListManagerDocs.html
.. _wxListManager.leo:    http://webpages.charter.net/edreamleo/wxListManager.leo
.. @+node:ekr.20050818163826.2: *3* Overview
This chapter discusses Leo's rst3 command. The rst3 command creates HTML, PDF,
LaTeX and other kinds of documents from Leo outlines containing
`reStructuredText`_ (rST) or `Sphinx`_ markup.

**Note**: `docutils`_ is a document processing system using rST markup.
`Sphinx`_ extends docutils: sphinx markup is a superset of rST markup. All of
Leo's documentation is written in Sphinx and processed with the rst3 command to
produce HTML files.

Leo and rst3 make writing rST/Sphinx documents a *lot* easier:

1. Leo outlines organize writing in all the usual ways. You always see the
   structure of your writing clearly no matter how large it is. You can
   reorganize chapters, sections and paragraphs effortlessly. View nodes can
   show you many different views of your writing simultaneously. These
   features, all by themselves, would make Leo an excellent choice for
   editing rST documents.

2. But the rst3 command does more: it automatically creates rST sections from
   headlines. Without Leo, changing the level of a section is clumsy and error
   prone: you must carefully change the section's underlining character. Leo's
   rst3 command eliminates all this bother.

3. The rst3 command converts an \@rst tree to rST and then sends this text to
   docutils or Sphinx for further processing.

In addition to these basic features, the rst3 command provides *many* other
capabilities for power users. We'll discuss these features later.
.. @+node:ekr.20100809162244.4289: *3* Tutorial
This tutorial tells how to get started with Leo's rst3 command. The tutorial
covers only rst3's basic features. You can do a *lot* with these features--Leo's
documentation uses only the features described here!

Step-by-step, here is how to use the rst3 command:

1. Create an \@rst node. This node and its descendants will contain your
   document. The \@rst node itself is a good place to specify general
   information about your documentation, including its title, one or more
   external files created by the rst3 command, and global settings for the rst3
   command.

2. Write your documentation in the descendants of the \@rst node. Within the
   \@rst tree, **headlines represent section headings**. Body text contain your
   writing, including rST or Sphinx markup.

3. To create your documents, run the rst3 command on an outline containing one
   or more \@rst nodes. 

That's all there is to it! The organization of the \@rst tree *is* the organization
of your document. To reorganize your document, you just reorganize the nodes in
the \@rst tree!  When you are done writing, create your output using the rst3 command.

The next sections will discuss these three steps in more detail. As you will
see, after you set up the \@rst node, you can focus exclusively on writing and
organizing. Leo's rst3 command will take care of the rest.
.. @+node:ekr.20100809162244.4292: *4* Step 1: Create the @rst node
The headline of the \@rst node has the form::

        @rst <filename>

Depending on options to be discussed later, the rst3 command will write one or two files:
the **output file** (<filename>), and the **intermediate file** (<filename>.txt).

For example, the rst3 command applied to \@rst abc.html will write
abc.html or abc.html.txt or both.

**Important**: The rst3 command creates the intermediate file, and then passes
this file to docutils or Sphinx. The intermediate file *always* contains
rST/Sphinx markup *regardless* of the type of the final output files. When in
doubt about what the rst3 command does, you can examine the intermediate file to
find out what markup the rst3 command has generated.

Let's turn our attention to the the body of the \@rst node...
.. @+node:ekr.20100809162244.4298: *5* Global options in the @rst node
You may set rst3 options in the body text of any node. The \@rst3 node itself is
a good place for options that apply to the entire \@rst3 tree. Typically, you
will just set these options once and then completely forget about them.

In body parts, you set rst3 options like this::

    @ @rst-options
    rst3 options, one per line
    @c

This is a Leo doc part: the '@' must appear in the leftmost column. As usual,
the doc part ends with the \@c directive, or the end of the body text.
.. @+node:ekr.20100809162244.4299: *6* Recommended options for docutils
The following are the recommended options when using docutils::

    @ @rst-options
    call_docutils=True
    code_mode=False
    generate_rst=True
    http_server_support = False
    show_organizer_nodes=True
    show_headlines=True
    show_leo_directives=True
    show_options_doc_parts=False
    stylesheet_path=..\doc
    write_intermediate_file=True
    verbose=True
    @c

**Important**: You don't have to understand these options now!

**Important**: It is good style to specify all these options explicitly, even if
they are the same as the standard default values. This ensures that the rst3
command will produce the same results no matter where the \@rst node is located.
.. @+node:ekr.20100809162244.4300: *6* Recommended options for Sphinx
The following are the recommended options when using for Shinx::

    @ @rst-options
    call_docutils=False
    code_mode=False
    generate_rst=True
    http_server_support = False
    show_organizer_nodes=True
    show_headlines=True
    show_leo_directives=True
    show_options_doc_parts=False
    stylesheet_path=..\doc
    write_intermediate_file=True
    verbose=True
    @c

**Important**: You don't have to understand these options now!

**Important**: It is good style to specify all these options explicitly, even if
they are the same as the standard default values. This ensures that the rst3
command will produce the same results no matter where the \@rst node is located.

**Note**: The only differences between this set of options and the recommended
docutils options is the line::

    call_docutils=False

Generating the output file (call_docutils=True) would not be wrong, but it would
be a waste of time.
.. @+node:ekr.20100809162244.4297: *5* Setting your document's title
You must specify the title explicitly. A good place to do this is in the body of
the \@rst node, just after specifying global options.

The rst3 command reserves the '#' character for the setting titles. You set the
document's title like this::

    #############
    War and Peace
    #############

Sometimes I put the first words of a document in the \@rst node::

    Well, Prince, so Genoa and Lucca are now just family estates of the
    Buonapartes. But I warn you, if you don't tell me that this means war, if
    you still try to defend the infamies and horrors perpetrated by that
    Antichrist--I really believe he is Antichrist--I will have nothing more to
    do with you and you are no longer my friend, no longer my 'faithful slave,'
    as you call yourself! But how do you do? I see I have frightened you--sit
    down and tell me all the news.
.. @+node:ekr.20100809162244.4295: *4* Step 2: Write your document
Now comes the "interesting" part--actually writing your novel, short story,
documentation or whatever.

As always with Leo, you organize your work with outlines. By default, (that is,
with the recommended options discussed in Step 2) the rst3 command will produce
the following output:

1. Each node becomes an (rST/Sphinx) section.

   The level of each section corresponds to the level of the node in the
   headline. Children of the @rst node create level 1 sections. Grandchidren of
   the \@rst node create level 2 sections, and so on.

2. The headline of each node becomes the section heading.

3. The body text of each node becomes the contents of the node's section.

   **Note**: The body text of any node in an \@rst tree contains plain text,
   with optional rST or Sphinx markup. Sphinx markup is a superset of rST
   markup. For more details on markup, see the `Sphinx`_ or `reStructuredText`_
   documentation.

That's all there is to it!

Well almost. There is one other feature you should know about. Headlines that
start with \@rst- control the rst3 command.  The three most useful are: 

.. glossary::

\@rst-no-head

    Causes the rst3 command to copy just the body text of the node. In other
    words, the node's body text become part of the previous section. Leo's docs
    use such nodes for rST links and other "invisible" markup.

\@rst-ignore

    The rst3 command ignores any \@rst-ignore node. Neither the headline nor the
    body text becomes part of the output. You can use such nodes for notes that
    you do not want to become part of the actual document.

\@rst-ignore-tree

    The rst3 command ignores the \@rst-ignore-tree node and all its descendants.
.. @+node:ekr.20100809162244.4296: *4* Step 3: Run the @rst3 command
This step is easy. Select an outline containing one or more \@rst trees. Now do
<Alt-X>rst3<Return>. You can use <Ctrl-P> (repeat-complex-command) instead if
the last minibuffer command was the rst3 command.

The rst3 command writes its output to either the output file or the intermediate
file, or both:

- With the recommended settings for docutils, the rst3 command will run docutils
  automatically, producing the output file as the result.

- With the recommended settings for Sphinx, the rst3 command will generate the
  intermediate file. You must then run Sphinx's make utility to turn the
  intermediate file into the final output file.
.. @+node:ekr.20100809162244.4301: *4* Go forth and experiment
This tutorial has attempted to explain all that you need to know to start using
the rst3 command effectively. Some possible next steps are:

1. Look at Leo's own documentation in LeoDocs.leo. It's in the node "@rst
   html\rstplugin3.html". Discover how the nodes in this tree correspond to the
   documentation you see before you.

2. Create your own @rst nodes. Run the rst3 command on them and see what
   happens. If you get stuck, you please ask for help at
   `Leo's Google Group`_.
.. @+node:ekr.20100809162244.4302: *3* Advanced features
Most of the rest of this chapter discuss advanced features.

- You can edit existing rST files using @auto-rst nodes. The imported outline
   structure mirrors the level of the rST section headings.

- You can control how Leo formats @rst trees on a node-by-node basis.
   See the `Options`_ section below for full details.

- For those desiring the ultimate in flexible formatting, Leo scripts can
   convert any Leo outline into rST text. This chapter concludes by telling how
   to write such scripts.

Docutils can use the `SilverCity`_ syntax coloring package if desired.
.. @+node:ekr.20050818163826.4: *4* Options
.. @+node:ekr.20050818163826.3: *5* Overview of options
1. The rst3 command allows much more flexible control over its operations using
**rst options**. You can set options in @settings trees, in headlines and in
body text. Nodes inherit most rst3 options from ancestor nodes much like nodes
inherit Leo directives. See `Options`_.

The most important option is the code_mode option. This option specifies whether
to process the body text of a node as rst markup (rst mode) or source code that
is to be converted to rST markup (code mode). Any node can be processed in any mode.

2. Headlines can set any option. This turns out to be very convenient. See
`Headline commands`_ for details. Nodes whose headlines start with @rst-options
are treated specially. The body text of such **rst options nodes** should
contain nothing but lines of the form::

    <option>=<value>

3. You can set any rst options in the *body text* of any node using doc parts
of the form::

    @ @rst-options
    list of rst options, one per line
    @c

Such **option doc parts** allows you to specify rst options even with source code files.

4. You can embed rST markup in the body text of any node using doc parts of the
form::

    @ @rst-markup
    any rST markup
    @c

Such **markup doc parts** allow you to fine-tune the formatting of your source files.
See `Using doc parts`_ for full details.
.. @+node:ekr.20100809122216.4288: *5* Code mode and rst mode
To be written.
.. @+node:ekr.20100809122216.4286: *5* Options list (rename)
You can set any option in any node, so you have complete control over how the
rst3 command processes each node. The following is a list of options that
control how the rst3 command formats each particular node.

code_mode (default: False)
    True: process nodes in code mode.  False: process nodes in rst mode.
    In code mode, the rst3 command automatically creates rST markup to display the body text as an
    rst code-block. In rst mode the rst3 simply copies the body text of the node to the output. That
    is, the rst3 command assumes that body text is already valid rST markup.

doc_only_mode (default: False)
    True: process nodes in doc_only mode.
    False: process nodes in rst mode or code_mode, depending on options.
    In doc_only mode, the rst3 command outputs only regular doc parts and @ @rst-markup doc parts.
    Headlines create section in doc_only mode only if
    a\) the node contains a doc part or b\) the show_organizer_nodes option is in effect.
    As always can use @ @rst-options for per-node control of the process,
    especially node-by-node control of the show_organizer_nodes option.

default_path (default: '')
    The path to be prepended to filenames given in root nodes.

default_encoding (default: utf-8)
    The default encoding to be used for non-ascii (unicode characters).

encoding (default: the default_encoding setting)
    The encoding to be used for non-ascii (unicode) characters.
    **Important**: this option has effect only in @rst-options doc parts
    in root @rst nodes.

generate_rst (default: True)
    A master switch.
    True: generate rST markup for rST sections and rST code-blocks.
    False: don't generate rST markup and ignore @ @rst-markup doc parts.

generate_rst_header_comment (default: True)

    This option has effect only if the generate_rst and write_intermediate_file
    options are both True. When this option is in effect, Leo writes a comment
    line of the form::

        .. rst3: filename: <filename>

    at the start of intermediate files.

number_code_lines (default: True)
    Controls whether to number code lines in code mode.
    This option has no effect in rst mode.

publish-argv-for-missing-stylesheets (Default: '')
    The arguments to be passed to docutils.core.Publisher().publish()
    when no stylesheet is in effect.
    This is a string that represents a comma-separated list of strings:
    For example, the option::

        publish-argv-for-missing-stylesheets=--language=de,--documentclass=report,--use-latex-toc

    results in the call::

        publish(['--language=de','--documentclass=report','--use-latex-toc'])

show_doc_parts_as_paragraphs (default: False)
    True: Move doc parts outside of the code-block directive in code mode.
    This option has no effect in rst mode.
    **Cool**: Any rST markup in doc parts included as the result of this option will be rendered properly.

show_doc_parts_in_rst_mode (default: True)
    This option is most useful for rst documents which are not computer code.
    It allows you to use doc parts to make comments on the draft document
    which are either excluded from the output or formatted in a way that highlights
    their nature as comments rather than contet.  For example, you're writing a book, and
    you want to use a doc part at the top of a section to remind yourself "need
    to explain how Ted got to Sally's".    Note: you may need to add
    CSS to have them formatted differently.  The option can be `True`, `False`,
    or one or more class names.

    True: doc parts have no special significance in rst mode.
    That is, the entire doc part from the opening '@' to the closing '@c
    and everything in between are treated as normal rST markup.

    False: doc parts are removed from the output in rst mode

    class name(s):

      The contents of the doc part is processed as it if was in an rst `container`
      directive.  For example::

         @ @rst-options
         show_doc_parts_in_rst_mode = notes literal
         @c

      would wrap the doc part contents in the output in a div with classes
      "container notes literal".  Furthermore, if one of the class names is
      `literal`, then the doc part content will be output as a literal block
      wrapped in a container as described above.  This allows you to use text
      which is not valid rst as rough notes for annotating a draft document.

show_headlines (default: True)
    True: automatically generate rST sections from headlines.
    Applies to both code mode and rst mode.
    The level of the node in the outline determines the level of the section
    underling in the rST markup. Higher-level headlines in the outline
    correspond to higher-level section headings; lower-level headlines in the
    outline correspond to lower-level section headings.

show_leo_directives (default: True)
    True: include Leo directives in code mode.
    This option has no effect in rst mode.

show_markup_doc_parts (default: False)
    True: include markup doc parts in code mode.
    This option has no effect in rst mode.

show_options_doc_parts (default: False)
    True: include options doc parts in code mode.
    This option has no effect in rst mode.

show_options_nodes (default: False)
    True: show @rst-options nodes.

show_organizer_nodes (default: True)
    True: generate rST sections for nodes that do not contain body text.
    This option has no effect unless the rST section would otherwise be written.

show_sections (default: True)
    True: generate rST sections corresponding to headlines.
    False: don't generate sections.  Instead, generate lines of the form::

        **headline**

strip_at_file_prefixes (default: True)
    True: remove @auto, @file, @nosent and @thin from the start of headlines.

stylesheet_name (default: 'default.css')
    The name of the stylesheet passed to docutils.

stylesheet_path (default: '')
    The directory containing the stylesheet passed to docutils.

    :Note:
        If the stylesheet_embed option is True, specify a path relative
        to the location of the Leo file.  If the stylesheet_embed option is
        False, specify a path relative to the location of the HTML file.

stylesheet_embed (default: True)
    | True: The content of the stylesheet file will be embedded in the HTML file.
    | False: The HTML file will link to an external stylesheet file.

underline_characters (default: \'\'\'#=+*^~"'\`-:><\_\'\'\')
    The underlining characters to be used to specify rST sections.
    The first character is reserved so you can specify the top-level section explicitly.

verbose (default: True)
    True: write informational messages.

write_intermediate_file (default: False)
    True: writes intermediate files before sending them to docutils.
    This option only applies to .htm, .html and .tex files.
    The name of the intermediate file has the name of the output file with .txt appended.
    This option has effect only if the generate_rst option is True.
.. @+node:ekr.20050818163826.5: *5* Options supporting the http plugin
The following options are for the use of Bernhard Mulder's http plugin. The http
plugin creates an http server running on a local port, typically 8080. When the
http plugin is running you will see a purple message in the log window that
looks something like this::

    http serving enabled on port 8080, version 0.91

To use the http plugin, start a web browser and enter this url::

    http://localhost:8080/

You will see a a top level page containing one link for every open .leo file.  Clicking on link will cause the http server to pass a new page to the browser.  You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

**Important**: See the docstring for the http plugin for information on
configuring the plugin. Some of the following rst3 settings must match values of
settings for the http plugin. Here are the rst3 options that support the http
plugin:

http_server_support (default: False)
    A master switch: none of the following options have any effect unless this option is True.
    If True, the rst3 command does the following:

    - Writes **node markers** in the rst output for use by the http plugin. Node markers are rst named hyperlink targets.  By default they look like::

            .. _http-node-marker-N

      where N is a unique node number.

    - Adds additional information to all nodes of the tree being formatted using Leo's
      unknownAttributes mechanism.

http_attributename (default: 'rst_http_attribute')
    The name of the attribute name written to the unknownAttributes attribute of
    each each outline node in the rst root tree.
    The default is 'rst_http_attribute';
    it should match the following setting of the *http* plugin::

        @string rst_http_attributename = 'rst_http_attribute'

    This option has no effect unless the http_server_support option is True.

clear_http_attributes (default: False)
    If True the rst3 command initially clears the fields specified by `http_attributename`.  
    This option has no effect unless the http_server_support option is True.

node_begin_marker (default: 'http-node-marker-')
    The string used for node markers.
    This option has no effect unless the http_server_support option is True.
.. @+node:ekr.20050818163826.6: *5* Options that set command names
The following options specify the 'spelling' of headline commands. The
option_prefix and option_prefixes command also define the spelling of special
doc parts.

You can change these to make them shorter or to avoid conflicts with headlines
in your Leo files. The list below merely gives the default value for each
setting.

`code_prefix`: '\@rst-code'

`ignore_headline_prefix`: '\@rst-no-head'

`ignore_headlines_prefix`: '\@rst-no-headlines'

`ignore_prefix_tree`: '\@rst-ignore'

`ignore_node_prefix`: '\@rst-ignore-node'

`ignore_tree_prefix`: '\@rst-ignore-tree'

`option_prefix`: '\@rst-option'

`options_prefix`: '\@rst-options'

`preformat_prefix`: '\@rst-preformat'

`rst_prefix`: '\@rst'

`show_headline_prefix`: '\@rst-head'
.. @+node:ekr.20050818163826.7: *4* Headline Commands
It is often convenient to set options in headlines.  This is done with the following **headline commands**:

@rst TEXT
    Enter rst mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-code TEXT
    Enter code mode.  Create a section called TEXT provided the show_headlines option is set.

@rst-ignore-node TEXT
    Suppress all output from a single node. TEXT is ignored.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-ignore-tree TEXT and @rst-ignore TEXT
    Suppress all output from the node and its descendants.  TEXT is ignored.
    Does **not** change any rst3 formatting option.

@rst-no-head TEXT
    Suppress the generation of an rST section for this node only.  Does not affect descendant nodes.
    Has *no* effect on descendant nodes and does **not** change any rst3 option. 

@rst-no-headlines TEXT
    Set the show_headlines option to False.  As a result, TEXT is ignored.

@rst-option <option> = <value>
    Set a single option to the given value.  The default value is True.

@rst-options TEXT
    Set zero or more options from the body text of the node.  TEXT is ignored.
    The entire body text is treated as if it were in an @ @rst-options doc part.

@rst-preformat TEXT
    Format the entire body text of the node as if the entire text preformatted.
    TEXT is ignored. In effect, a line containing '::' is added to the start of
    the text, and all following lines of the text are indented. This option has
    no effect on descendant nodes.

**Notes**:

- Several of these commands affect only the node in which they appear.  Such commands set internal settings variables only: they have no effect on the visible rst3 options.

- If a headline generates an rST section, the section name does not include the headline command.  Furthermore, no rST section is generated if the TEXT is empty.
.. @+node:ekr.20050818163826.8: *4* Using doc parts
Recall that in Leo a doc part starts with the '@' directive and continues until the end of body text or until the '@c' directive is seen.  For example::

    @ This is a comment in a doc part.
    Doc parts can span multiple lines.
    The next line ends the doc part
    @c

Leo converts doc parts into comments using whatever comment delimiters are in effect.

**Option doc parts** are doc parts that start with @ @rst-options. All other
lines of such doc parts should be of the form name=value. (rST comments lines
starting with '..' are allowed). For example::

    @ @rst-options
    .. This comment line is ignored.
    show_headlines=False
    show_leo_directives=False
    verbose=True
    @c

The rst3 command sets options from option doc parts, even in code mode.

**Markup doc parts** are doc parts that start with @ @rst-markup.  For example::

    @ @rst-markup
    .. contents::

The rst3 command replaces markup doc parts by the markup they contain, even in
code mode.

Option and markup doc parts are especially useful in code mode. They allow you
to specify options or insert rST markup directly from with external files. This
makes your source files self contained: there is no need to add other nodes to
make the rst3 command happy.

A cool feature: In code mode, rST markup in *ordinary* doc parts will be
rendered properly when the show_doc_parts_as_paragraphs option is in effect.
*Important*: Regardless of the show_doc_parts_as_paragraphs option, doc parts
have no special significance in rst mode. That is, the entire `doc part` from
the opening '@' to the closing '@c and everything in between are treated as normal
rST markup.  *Update:* you can now use the `show_doc_parts_in_rst_mode` option
to change this behavior and control the processing of doc parts in rst mode.
.. @+node:ekr.20050818163826.9: *4* Setting defaults
You can set the defaults for any rst3 option in several ways:

1.  By setting options in the root node using @ @rst-options doc parts.
    For example, the root of the file that generated this documentation contains::

        @ @rst-options
        code_mode=False
        doc_mode_only=False
        generate_rst=True
        show_organizer_nodes=True
        show_headlines=True
        show_leo_directives=True
        verbose=True
        @c

2. By setting options in @settings trees. To do this, you must prefix the
   option name shown in this documentation with the prefix 'rst3\_'. For example::

        @settings
            @bool rst3_write_intermediate_file = True
.. @+node:ekr.20050818163826.10: *4* The code-block directive
The rst3 command defines a code-block rST directive. The primary purpose of this
directive is to show formatted source code.

In rst mode you can insert the code-block directive like any other rST markup.
The rst3 command generates code-block directives when handling nodes in code
mode.

This directive takes one argument, a language name.  Like this::

    .. code-block:: Python

        import leo.core.leoPlugins as leoPlugins
        import leo.core.leoGlobals as g

This directive syntax colors the code in the indented code block that follows the directive.
The result looks like this if the SilverCity syntax coloring module has been installed.

.. .. code-block:: Python

    .. import leo.core.leoPlugins as leoPlugins
    .. import leo.core.leoGlobals as g

.. Otherwise, the output looks like this::

    .. import leo.core.leoPlugins as leoPlugins
    .. import leo.core.leoGlobals as g

See the Scripting chapter in LeoDocs.leo for many examples of how to use
code-blocks.
.. @+node:ekr.20050818163826.11: *4* Required cascading style sheets
HTML files generated by the rst3 command assume that three .css (cascading style
sheet) files exist in the same directory. For the HTML output to look good the
following .css files should exist:

- default.css is the default style sheet that docutils expects to exist.

- leo_rst.css contains some style improvements based on Gunnar Schwant's DocFactory.

- silver_city.css is the style sheet that controls the syntax highlighting generated by SilverCity.

The latter two style sheets are imported at the end of the default.css.

**Important:** You can use cascading style sheets to do things that otherwise
wouldn't be possible with "plain" rST. For instance, the background color of
this page was specified in a body style.
.. @+node:ekr.20060527103630: *4* Controlling the rst3 command from scripts
A new method has been added to make it more easily to write rST code from scripts::

    c.rstCommands.writeNodeToString(p)

writeNodeToString scans p's tree (p defaults to presently selected node) looking for @rst nodes.
When the first @rst node is found, writeNodeToString processes the node as usual, with the following changes:

- @rst need not be followed by a filename; any filename and its extension are *ignored*.

- Only the ext argument to writeNodeToString determines the type of output produced.
  The valid values for the ext argument are None (for rst output), '.html', '.pdf', and '.tex'.

- Instead of writing the result to a file, writeNodeToString returns the tuple (p,s),
  where p is the node whose tree produced the output, and s is the output itself.

- writeNodeToString returns after processing at most one @rst node.

Scripts can easily use writeNodeToString to convert @rst trees into various kinds of output.
For example::

    p,s = c.rstCommands.writeNodeToString(p,ext='html')

Notes:

- This script scans the presently selected tree for @rst nodes.
  In particular, if the presently selected tree does not contain an @rst node the search continues in parent trees.
  When an @rst node is found, it converts the node (and descendants) to html and returns p,
  the found @rst node and s, the html itself.

- Valid values for the ext argument are ".html", ".tex" or None (specifies rst output)

- There is some support for ext=".pdf", but this is experimental code.  Expect crashes.
.. @+node:ekr.20050818163826.13: *3* Further study
The file `ListManagerDocs.html`_ is an impressive example of the kind of output
that can be generated relatively easily using the rst3 command.

The source for ListManagerDocs.html is `wxListManager.leo`_. **Important**:
wxListManager.leo was written for the old rst2 plugin; it could be greatly
simplified if adapted for the rst3 command.

This documentation was created using the rst3 command. The source code for this
documentation is in LeoFDocs.leo. The source code for the rst3 command is in
leoRst.py in leoPy.leo.
.. @+node:ekr.20050818163826.16: *3* Acknowledgements
Josef Dalcolmo wrote the initial rst plugin.
Timo Honkasalo, Bernhard Mulder, Paul Paterson, Kent Tenney and
Steve Zatz made contributions to the rst and rst2 plugins.
.. @+node:ekr.20050818163826.14: *3* Theory of operation
The code for the rst3 command is more complex than usual. Fortunately, the
overall organization is straightforward.

defaultOptionsDict
    This dictionary represents each rst3 option.
    To add another option, just add another entry to this dictionary.
    Keys are the option name, including the `rst3_` prefix.
    Values are the default value of the option.
    The hard values in the dictionary may be changed as the result of @settings entries.

processTree
    processTree is the top-level code that handles one rst root node.
    It calls preprocessTree to create the **tnodeOptionDict** ivar.
    processTree then calls either writeNormalTree or writeSpecialTree
    depending on whether text will be sent to docutils for further processing.
    These two methods handle mundane details of opening an closing files.
    Both writeNormalTree and writeSpecialTree call **writeTree** to do the actual work.

tnodeOptionDict
    The entries in this dictionary represents the options that are set in one particular node.
    The keys of tnodeOptionDict are tnodes, the values are anonymous dictionaries.
    These anonymous inner dictionaries contain the options that are explicitly set at each tnode
    (and thus each position).
    Preprocessing the tree this way ensures that each node (headline and body text) is parsed exactly once.

writeTree
    writeTree first calls **scanAllOptions**, which has the effect of
    initializing all options. writeTree then calls **writeNode** for each node
    that will be processed by the rst3 command. Options may cause the rst3 command to
    skip a node or an entire subtree.

writeNode
    writeNode first calls **scanAllOptions** to compute the options that are in
    effect for that *single* node. Once options have computed, processing the
    node is straightforward. writeNode calls writeBody and writeHeadline
    to do the real work. These methods generate or skip text based on various
    options.

scanAllOptions
    scanAllOptions recreates the optionsDict ivar to represent *all* the options
    in effect for *for the particular node being processed by writeNode*. Client
    code gets these options by calling the getOption method.

    scanAllOptions first inits all options from settings,
    then updates those options using the anonymous
    dictionaries contained in the tnodeOptionsDict.
    scanAllOptions works like g.scanAllDirectives, but the code is much simpler.
.. @-all
.. @-leo
