.. @+leo-ver=5-thin
.. @+node:ekr.20100805165051.7176: * @thin other_docs.txt
.. @@language rest
.. @@tabwidth -4
.. @+all
.. @+node:ekr.20090428101858.1: **  How to generate Leo's Sphinx docs
1. doc\html\conf.py contains settings,
including the name of the master toctree document, leo_toc.html.txt.

2. leo_toc.html.txt contains a list of all file to be included.

3. To create one or more docs:

    - From this file, run rst3 on desired tree.
    - cd leo\doc\html
    - make html

4. To create pdf (probably easiest on Linux, with necessary latex packages installed):

    - make latex
    - cd _build/latex
    - make all-pdf
.. @+node:EKR.20040524104904.380: ** OLD Glossary
@language rest
.. @+node:ekr.20050901071041: *3* @@rst html\glossary.html
############
Glossary
############
.. @+node:ekr.20050901071300: *4* @rst-no-head links
.. Links used in this document.

.. ----- External links.

.. _`CWEB language`:                    http://www-cs-faculty.stanford.edu/~knuth/cweb.html
.. _`literate programming web page`:    http://www.literateprogramming.com/
.. _`noweb language`:                   http://www.eecs.harvard.edu/~nr/noweb/
.. _`rST primer`:                       http://docutils.sourceforge.net/docs/user/rst/quickstart.html

.. ----- Relative links.

.. _`Chapter 8: Customizing Leo`:   customizing.html
.. _`Writing plugins and hooks`:    writingPlugins.html

.. _`programming reference`:    directives.html
.. _`@asis`:                    directives.html#asis-and-noref
.. _`@auto`:                    directives.html#auto
.. _`@file`:                    directives.html#file-and-thin
.. _`@nosent`:                  directives.html#nosent
.. _`@root`:                    directives.html#root
.. _`@thin`:                    directives.html#file-and-thin
.. _`@unit documentation`:      directives.html#root
.. _`tangling @root trees`:     directives.html#tangling-root-trees-with-the-tangle-commands
.. _`untangling @root trees`:   directives.html#untangling-root-trees-with-the-untangle-commands

.. ----- References to the tutorial.
.. _`clones & views`:               intro.html#clones-views
.. _`leo's tutorial`:               intro.html
.. _`external files section`:        intro.html#derived-files
.. _`directives for programming`:   intro.html#directives-for-programming
.. _`leo directives`:               intro.html#leo-directives
.. _`quick start for programmers`:  intro.html#quick-start-for-programmers
.. _`sentinels lines`:              intro.html#sentinel-lines
.. @+node:ekr.20050901073048: *4* @rst-no-head glossary
**Important**: We often refer to outline_ nodes_ by the directives_ they contain.
For example, an `@root node`_ is a node containing an @root directive_, etc.
**Exception**: An `@file node`_ is a node whose *headline* starts with @file.

.. _`@auto node`:
.. _`@file node`:
.. _`@thin node`:
.. _`@root node`:
.. _`@file nodes`:
.. _`@thin nodes`:
.. _`@root nodes`:

@file node
    An @file node_ is a node whose *headline* starts with @file.
    **Important**: Headlines_ that start with @file-asis, @file-noref, @file-nosent
    (and their abbreviations @asis, @nosent) are collectively called @file nodes.

.. _`@auto tree`:
.. _`@file tree`:
.. _`@thin tree`:
.. _`@root tree`:
.. _`@file trees`:
.. _`@shadow trees`:
.. _`@thin trees`:
.. _`@root trees`:

@file tree, @others tree, @root tree, etc.
    An @file tree_ is a tree whose root_ is an @file node, etc.

@asis, @auto, @file, @nosent, @thin
    Headlines_ that start with one of these create (correspond to) `external files`_.
    The following synonyms exist::

        @asis, @file-asis, @nosent, @file-nosent

    For more information, see the documentation for `@asis`_, `@auto`_, `@file`_, `@nosent`_ and `@thin`_
    in Leo's `programming reference`_ chapter.

    \@auto trees allow you to edit external files that contain no sentinels.
    Leo will import the @auto files when reading .leo files.  Be careful when first creating the @auto node.
    *Before* saving the .leo file containing the new @auto node,
    use the read-at-auto-nodes command to do the initial import.

.. _`@all`:
.. _`@all directive`:

@all
    A directive_ that copies the `body text`_ of all nodes_ in an `@thin` tree to the corresponding `external file`_.
    For more information, see `directives for programming`_ in `Leo's tutorial`_.

.. _`@others`:
.. _`@others directive`:

@others
    A directive_ that copies the `body text`_ of all nodes_ *except* `section definition nodes`_
    in an `@thin` tree to the corresponding `external file`_.
    For more information, see `directives for programming`_ in `Leo's tutorial`_.

.. _`@unit`:
.. _`@unit directive`:

@unit
    A directive_ that expands the scope_ of definitions in `@root` trees.
    For more information, see the `@unit documentation` in Leo's `programming reference`_.

.. _`body pane`:

Body pane
    The pane containing the `body text`_ of the currently selected headline_ in the `outline pane`_.

.. _`body text`:

Body text
    The text in the `body pane`_.  Body text is always associated with a particular node_.

.. _`body text box`:

Body text box
    A small blue box in the `icon box`_ indicating that the node_ contains `body text`_.

.. _`child`:
.. _`children`:

Child
    A node_ directly contained by a node.

.. _`chunk`:
.. _`chunks`:

Chunk
    A section_ (noweb_ terminology).

.. _`clone`:
.. _`clones`:
.. _`cloned`:

Clone
    A copy of a tree_ that changes whenever the original changes.
    The original and all clones are treated equally:
    no special status is given to the "original" node_.

.. _`clone arrow`:
.. _`clone arrows`:

Clone Arrow
    A small red arrow in the `icon box`_ indicating that the node_ is a clone_.

.. _`code part`:
.. _`code parts`:

Code part
    A part of a `section definition`_ that contains code. 
    Code parts start with @c or @code directives_ and continue until the next `doc part`_

.. _contract:
.. _contracts:
.. _contracted:

Contract:
    To hide all descendants_ of a node_.

.. _`cweb`:

CWEB
    A `literate programming`_ language invented by Donald Knuth and Silvio Levy.
    The `CWEB language`_ produces external files for the C language.

.. _`demote`:

Demote
    To move all siblings_ that follow a node_ so that they become children_ of the node.

.. _`external file`:
.. _`external files`:

external file
    The file created as the result of tangling_ a node containing an @root directive_.
    The file consists of the expansion of the text following the @root directive_.
    For more information, see the `external files section`_ of `Leo's tutorial`_.

.. _`descendant`:
.. _`descendants`:

Descendant
    An offspring_ of a node_.  That is, a child_, grandchild_, etc. of a node.

.. _`directive`:
.. _`directives`:

Directive
    A keyword, preceded by an '@' sign, in `body text`_ that controls Leo's operation.
    The keyword is empty for the @ directive.
    For more information, set the `Leo directives`_ section of `Leo's tutorial`_.

.. _`doc part`:
.. _`doc parts`:

Doc part, @doc part, document part, etc.
    A part_ of a `section definition`_ that contains comments.
    Doc parts start with @ and continue until the @c directive_ or the end of the `body text`_.
    In `@root trees`_, doc parts are associated with the immediately following `code part`_, if any.

.. _`escape convention`:
.. _`escape conventions`:

Escape convention
    A convention for representing sequences of characters that would otherwise have special meaning.
    Leo has only one such convention:
    in `@root trees`_, @@ in the leftmost column of a `code part`_ stands for a single @ character.
    **Important**:
    Leo does not support `noweb's`_ @<< and @>> escape conventions.
    Any line containing matched << and >> is a `section reference`_, regardless of context.
    To use << and >> as ordinary characters, place them on separate lines.

.. _expand:
.. _expands:
.. _expanded:

expand
    To make the children_ of a node_ visible.

.. _`grandchild`:
.. _`grandchildren`:

Grandchild
    The child_ of a child of a node_.

.. _`headline`:
.. _`headlines`:
.. _`headline text`:

Headline
    The headline text of a node_.  The part of the node visible in the `outline pane`_

.. _`hoist`:
.. _`hoisted`:
.. _`dehoist`:

Hoist & dehoist
    Hoisting a node_ redraws the screen that node and its descendants_ becomes the only visible part of the outline_.
    Leo prevents the you from moving nodes outside the hoisted outline.  Dehoisting a node restores the outline.
    Multiple hoists may be in effect: each dehoist undoes the effect of the immediately preceding hoist.

.. _`icon box`:
.. _`icon boxes`:

.. _`LaTex`:

LaTex
    A markup language often used in `literate programming` environments.
    See: http://www.latex-project.org/

Icon box
    An icon just to the left of `headline text`_ of a node_ indicating whether the node is cloned, marked or dirty,
    and indicating whether the node contains `body text`_.

.. _`Leo1`:
.. _`Leo2`:

Leo1 and Leo2
    **Leo1** denotes all versions of Leo that write version 1 .leo files, that is,
    all Windows version of Leo prior to version 2.0.
    The last version of Leo1, version 1.15, understands enough about Leo2 to issue a warning when opening version 2 files.

    **Leo2** denotes all versions of Leo that write version 2 .leo files, that is,
    all versions of leo.py and all Windows versions with version number 2.0 and above.
    Only Leo2 can generate `external files`_ from `@file trees`_.

.. _`literate programming`:

Literate programming
    A style of programming that aims at producing the highest quality program listings.
    Literate programming languages apply two fundamental operations to text: weaving_ and tangling_.
    Leo supports two literate programming languages, `CWEB`_ and `noweb`_.
    For more links see the `literate programming web page`_.

.. _`mark`:
.. _`marks`:

Mark
    A red vertical line in the `icon box`_ of a node_.

.. _node:
.. _nodes:

Node
    The organizational unit of an outline_. The combination of `headline text`_ and `body text`_.
    Sometimes used as a synonym for tree_.

.. _`noweb`:
.. _`noweb's`:

noweb
    A literate programming language invented by Norman Ramsey.
    The `noweb language`_ can produce `external files`_ for any text-based programming language.

.. _`offspring`:

Offspring
    The children_, grandchildren_, etc. of a node_.

.. _`organizing node`:
.. _`organizing nodes`:
.. _`organizer node`:
.. _`organizer nodes`:

Organizing node, organizer node
    A node_ containing no `body text`_.
    Organizing nodes may appear anywhere in an `@file tree`_; they do not affect the external file in any way.
    In particular, organizing nodes do not affect indentation in `external files`_.

.. _`orphan`:
.. _`orphan node`:
.. _`orphan nodes`:

Orphan node
    A node_ that would not be copied to a `external file`_.
    Orphan nodes can arise because an `@thin tree`_ has no @others or @all directives_.
    Sections_ that are defined but not used also create orphan nodes.

    Leo issues a warning when attempting to write an `@thin tree`_ containing orphan nodes,
    and does not save the `external file`_.
    No information is lost; Leo saves the information in the `@thin tree`_ in the .leo file.
    Leo will load the `@thin tree`_ from the .leo file the next time Leo opens the .leo file.

.. _`outline`:
.. _`outliner`:
.. _`outlines`:

Outline
    - A node_ and its descendants_.
    - A tree_
    - All the nodes_ of a .leo file.

.. _`outline order`:

Outline Order
    The order that nodes_ appear on the screen when all nodes_ are expanded.

.. _`outline pane`:

Outline pane
    The pane containing a visual representation of the entire outline_, or a part of the outline_ if the outline is hoisted_.

.. _parent:
.. _parents:

Parent
    The node_ that directly contains a node.

.. _`part`:
.. _`parts`:

Part
    A synonym for section_.  See also `code part`_ and `doc part`_.

.. _`pdf file`:
.. _`.pdf file`:

pdf file
    A file that can be read by Adobe Acrobat.

.. _`plugin`:
.. _`plugins`:

Plugin
    - A Python file in Leo's plugins folder.
    - A way to modify and extend Leo without changing Leo's core code.
      leoPlugins.leo contains all of Leo's official plugins.

    See `Writing plugins and hooks`.

.. _`promote`:

Promote
    To move all children_ of a node_ in an outline so that they become siblings_ of the node.

.. _reStructuredText:
.. _rST:

reStructuredText (rST)
    A simple, yet powerful markup language for creating .html, or LaTeX output files.
    See the `rST primer`_.

.. _`root`:
.. _`root node`:

Root
    - The first node_ of a .leo file.
    - The first node of an `@root`_ tree or `@file`_ tree.

.. _`rst3 plugin`:

rST plugin
    A plugin_ that supports reStructuredText_.
    Unlike previous rst plugins, the rst3 plugin supports per-node options.

.. _`scope`:

Scope
    The portion of the outline_ in which a `section definition`_ is known.

.. _`section`:
.. _`sections`:

Section
    A fragment of text that can be incorporated into `external files`_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section definition`:
.. _`section definitions`:

Section definition:
    The `body text`_ of a `section definition node`_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section definition node`:
.. _`section definition nodes`:

Section definition node
    A node_ whose headline_ starts with a `section name`_ and whose body text defines a section_.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section name`:
.. _`section names`:

Section name
    A name enclosed in << and >>.
    Section names may contain any characters except newlines and ">>".
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`section reference`:
.. _`section references`:
.. _`reference`:
.. _`references`:
.. _`referenced`:

Section reference
    A `section name`_ appearing in a `code part`_.
    Tangling_ replaces all references by their definitions.
    See the `Quick start for programmers`_ in `Leo's tutorial`_ for more details.

.. _`sentinel`:
.. _`sentinels`:
.. _`sentinel lines`:

Sentinels, sentinel lines
    Comment lines in files derived from `@file nodes`_.
    Such lines start with an @ following the opening comment delimiter.
    Sentinels embed outline structure into `external files`_.
    **Do not alter sentinel lines**.  Doing so can corrupt the outline structure.
    For more information see `Sentinel lines`_ in `Leo's tutorial`_.

.. _`@settings`:
.. _`setting`:
.. _`settings`:

Setting:
    Plugins_ and other parts of Leo can get options from @settings trees,
    outlines_ whose headline_ is @settings. When opening a .leo file, Leo looks
    for @settings trees in the outline being opened and also in various
    leoSettings.leo files. @settings trees allow plugins_ to get options without
    any further support from Leo's core code. For a full discussion of
    @settings trees, see `Chapter 8: Customizing Leo`_.

.. _`sibling`:
.. _`siblings`:

Sibling
    Two nodes_ are siblings if they have the same parent_.  Siblings of the root_ have no parent.

.. _`tangle`:
.. _`tangles`:
.. _`tangling`:

Tangling
    The process of creating `external files`_ from `@root trees`_ or `@file trees`_.
    Leo tangles `@file trees`_ automatically when writing a .leo file.
    You must explicitly tangle_ `@root trees`_ using the Tangle command.
    Tangling expands all `section references` in an `@root node`_ or `@file node`_.
    For more information, see `Tangling @root trees`_ in Leo's `programming reference`_.

.. _`target language`:

Target language
    The language used to syntax color text.
    This determines the default comment delimiters used during tangling_ and untangling_.

.. _`tree`:
.. _`trees`:

Tree
    An outline_.
    A node_ and its descendants_.

.. _`untangle`:
.. _`untangles`:
.. _`untangling`:

Untangling
    Updating an outline_ based on changes to `external files`_.
    Untangling allows changes to be propagated from external files back to the outline.
    Especially useful when fixing syntax errors outside Leo.
    For more information, see `Untangling @root trees`_ in Leo's `programming reference`_.

.. _`weave`:
.. _`weaves`:
.. _`weaving`:

.. _`view node`:
.. _`view nodes`:

View node
    A `node`_ that represents a view of an `outline`_.
    View nodes are typically ordinary, non-`cloned`_ nodes that contain cloned `descendant`_ nodes.
    The cloned descendant nodes comprise most of the data of the view.
    Other non-cloned nodes may add additional information to the view.
    See `clones & views`_ in the `Leo's tutorial`_ for more information.

Weaving
    The process of creating typeset documentation from a noweb_ or CWEB_ source file.
    Weaving creates documentation. Tangling_ creates `external files`_.
    Leo does not support weaving directly.
    To weave a file you can create noweb_ or CWEB_ files using Leo's Export commands,
    then use the noweb_ or CWEB_ systems to weave those files.
.. @+node:ekr.20080301071818: ** Home page
.. @+node:ekr.20080306071848: *3* << download ref >> (contains version number)
<a href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106">
    Download Leo[4.7.1 final]</a>
.. @+node:ekr.20080301071818.1: *3* @thin html/front.html
@first <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

@language html
@tabwidth -4

<!-- Last Modified: July 31, 2008 -->
<!-- Author: Edward K. Ream, edreamleo@gmail.com -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<<head>>
</head>

<body bgcolor="#fffbdc">
<< main table >>
</body>
</html>

.. @+node:ekr.20080301075734.1: *4* <<head>>
<title>Leo's Home Page</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

<meta name="description" content="This page describes Leo, a programmer's outliner." />

<meta name="keywords" content="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE" />

<!-- for GeoUrl -->
<meta name="ICBM" content="43.0713768, -89.4188004" />
<meta name="DC.title" content="Leo's Home Page" />
.. @+node:ekr.20080301075734.4: *4* << main table >>
<table border="0" bgcolor="#FFFBDC">
    <tr>
        <td width="22%" height="21" align="center" bgcolor="#FFFBDC" valign="middle">
            <b><font size="4">Leo's Home</font></b>
        </td>

        <td bgcolor="#F0E68C" width="78%" height="21" align="center">
            << upper table >>
        </td>
    </tr>

    <tr>
        <td bgcolor="#F0E68C" width="22%" height="143" valign="top">
            << left table >>
        </td>

        <td width="78%" height="143" bgcolor="#FFFBDC">
            << center area >>
        </td>
    </tr>
</table>
.. @+node:ekr.20080301080758: *5* << upper table>>
<table border="0" width="100%">
    <tr>
        <td width="25%" align="center">
            <a href="http://www.python.org/">
                <img border="0" src="PythonPowered.gif" width="110" height="44" /></a>
        </td>

        <td width="50%" align="center">
            <a href="http://groups.google.com/group/leo-editor">Leo at Google Groups</a>
        </td>

        <td width="25%" align="center">
            <a href="http://www.mind-mapping.org/">mind-mapping.org</a>
        </td>
    </tr>
</table>
.. @+node:ekr.20080301075734.6: *5* << left table >>
<table border="0" width="100%">
    <tr><td width="50%" bgcolor="#DAA520"><b>Documentation</b></td></tr>
    <tr><td width="50%">
            <!--
            <a href="http://sourceforge.net/project/screenshots.php?group_id=3458">Screen Shots</a>
            -->
            <a href="http:screen-shots.html">Screen Shots</a>
    </td></tr>
    <tr><td width="50%"><a href="install.html">Installing Leo</a></td></tr>
    <tr><td width="50%"><a href="intro.html">Beginners Guide</a></td></tr>
    <tr><td width="50%"><a href="leo_toc.html">Users Guide</a></td></tr>
    <tr><td width="50%"><a href="FAQ.html">FAQ</a></td></tr>
    <tr><td width="50%">
        <a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm">Online tutorial</a>
    </td></tr>
    <tr><td width="50%"><a href="testimonials.html">Quotes</a></td></tr>
    <tr><td width="50%" bgcolor="#DAA520"><b>Links</b></td></tr>
    <tr><td width="50%">
        << download ref >>
    </td></tr>
    <tr><td width="50%"><a href="http://sourceforge.net/project/?group_id=3458"> Leo at SourceForge</a></td></tr>
    <tr><td width="50%"><a href="http://groups.google.com/group/leo-editor">Leo at Google Groups</a></td></tr>
    <tr><td width="50%"><a href="http://groups.google.com/group/leo-editor-users">Leo's help forum</a></td></tr>
    <tr><td width="50%"><a href="http://launchpad.net/leo-editor">Leo at launchpad</a></td></tr>
    <!-- <tr><td width="50%"><a href="http://leo.tigris.org/source/browse/leo/">Leo's cvs repository</a></td></tr> -->
    <tr><td width="50%">Leo's <a href="http://leo.zwiki.org">Wiki</a></td></tr>
    <tr><td width="50%">Leo's <a href="http://www.greygreen.org/leo/">Daily snapshots</a></td></tr>
    <tr><td width="50%"><a href="leoLinks.html">More links</a></td></tr>
    <tr><td width="50%" bgcolor="#DAA520"><b>Edward K. Ream</b></td></tr>
    <tr><td width="50%"><a href="ekr.html">Home</a></td></tr>
    <tr><td width="50%"><a href="mailto:edreamleo@gmail.com">Contact</a></td></tr>
</table>
.. @+node:ekr.20080306071848: *6* << download ref >> (contains version number)
<a href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;package_id=29106">
    Download Leo[4.7.1 final]</a>
.. @+node:ekr.20080301082848: *5* << center area >>
<h2> Leo is...</h2>

<ul>
<< what is Leo list >>
</ul>

<p>
Leo has an active community of helpful users and developers.<br>
Please use the <a href="http://groups.google.com/group/leo-editor">leo-editor</a>
group to ask questions and make suggestions.
</p>

<p>
Leo's author is <a HREF="ekr.html">Edward K. Ream</a>
</p>
.. @+node:ekr.20080301083325: *6* << what is Leo list >>
<li>
    An outline-oriented <i>browser</i> and <i>project manager</i> that organizes<br>
    programs, web sites, URL's, pictures, movies or any other kind of data.<br>
    You can organize your data in as many ways as you like within a <i>single</i> outline.</li>
<li>
    A <i>programmer's editor</i> that supports optional
    <a HREF="http://www.eecs.harvard.edu/~nr/noweb/">noweb</a> and
    <a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html">CWEB</a> markup.</li>
<li>
    <i>Fully scriptable</i> using <a HREF="http://www.python.org/">Python</a>.
    Leo's core is 100% pure Python.</li>
<li>
    <i>Portable</i>. Leo runs on Windows, Linux and MacOS X.<br>
    Leo requires either the
    <a HREF="http://docs.python.org/library/tkinter.html">Tkinter</a> or
    <a HREF="http://www.riverbankcomputing.co.uk/software/pyqt/intro">PyQt</a> widget set.<br>
    Leo's outline files are <a HREF="http://www.w3.org/XML/">XML</a> format.</li>
<li>
    <a href="http://www.opensource.org/"><i>Open Software</i></a>,
    distributed under the
    <a href="http://www.opensource.org/licenses/mit-license.php/">MIT License</a>.</li>
.. @+node:ekr.20090711120622.10446: ** Screen shots page
@language rest
.. @+node:ekr.20090711120622.10447: *3* @rst html/screen-shots.html
################
Leo screen shots
################

.. @+node:ekr.20090811090022.14451: *4* @rst-no-head links
.. Links used in this document...

.. |leoQtMainWindow| image:: screen-shots/leo-qt-main-window.JPG

.. |leoTkMainWindow| image:: screen-shots/leo-tk-main-window.jpg

.. |leoQtMainWindowLinux| image:: screen-shots/leo-qt-main-window-linux.png
.. .. |findTab| image:: screen-shots/find-tab.jpg

.. |leoQtFindTab| image:: screen-shots/leo-qt-find-tab.JPG
.. @+node:ekr.20090811090022.14452: *4* Windows screen shots
Here is Leo's main window rendered with the Qt gui.
Top-left: the outline pane.
Top-right: the log pane.
Bottom: the body pane.
Below the body pane is the minibuffer.

|leoQtMainWindow|

Here is Leo's main window rendered with the Tk gui.
Just as with the Qt gui, you may adjust font sizes, colors, et.

|leoTkMainWindow|

Here is Leo's find tab, rendered with the Tk gui.
All parts of the find tab can be controlled from the keyboard.

|leoQtFindTab|
.. @+node:ekr.20090811090022.14453: *4* Linux screen shots
Here is Leo's main window as it appears on Linux:

|leoQtMainWindowLinux|
.. @+node:ekr.20090526102407.10028: ** Important notes about Leo's code
.. @+node:ekr.20090526102407.10029: *3* How to profile Leo
To gather statistics, do the following in a console window, not idle::

    > python
    >>> import leo
    >>> import leo.core.runLeo as r
    >>> r.prof()  (this runs leo)
    load any .leo file from Leo
    quit Leo

Intermediate data is written to cwd.leoProfile.txt.
The statistics are written to stdout.
.. @+node:ekr.20090526102407.10030: *3* High-level code notes
I've often said that I don't remember many details about Leo. This documentation
describes what I *do* remember about Leo's various modules. I hope this will be
useful to potential readers, users and modifiers of Leo's code.

In general, if you want to understand the code, read through it quickly, looking
for pieces of code that are unexpected complex, or unexpectedly simple. Forget
the details; remember the shape. Once you have the general shape in mind, you
are ready to modify the code. No kidding. Besides, more reading won't help :-)
.. @+node:ekr.20090526102407.10031: *4* leoFileCommands.py and leoAtFile.py
In general, write code is much simpler than read code,
because reading requires parsing. There are a few exceptions below.

leoFileCommands.py contains the code that reads and writes .leo files.

- This file uses the sax parser to parse the xml in .leo files.
- Complex code, driven by sax, turns sax nodes into Leo nodes.
- The putVnode method is "interesting".  Take a look.
  In the past, there have been significant, surprising bottlenecks in
  putVnode and maybe putTnode as well.  No longer.

leoAtFileCommands.py contains the code that reads and writes external files.

- There are options to read and write strings.
  These are useful for performance and for unit testing.
- atFile.replaceTargetFileIfDifferent is an important optimization.
- There are a lot of read/write commands for external files,
  and this results in lots of options being passed around.

Initing is tricky for both leoFileCommands.py and leoAtFileCommands.py.

- The bizarre call to initReadIvars() at the end of getLeoFile is one
  symptom of the difficulties.
- Never change init code without careful thought and unit testing.
.. @+node:ekr.20090526102407.10032: *4* Leo's MVC architecture
I. Background

Leo has had a robust MVC (Model,View,Controller) architecture from day one.

Leo's model are the classes in leoNodes.py. They are completely independent from
the rest of Leo. Many parts of Leo *use* these classes, but not vice versa!

Leo's controller is everything else in 'Code-->Core classes'. This code has *no*
direct dependencies on Leo's gui code, as will be explained next.

Leo's view has two parts:

1. The classes in the tree 'Code-->Gui Base classes'.
   These are part of Leo's core.

2. The classes in the tree 'Code-->Gui Tkinter classes'.
   These are essentailly a gui plugin.

Leo's core consists of the Model, Controller and the gui base classes.


II. Why Leo's core is gui-independent

Leo uses a completely standard way of separating gui-dependent code from
gui-independent code. Base gui classes (part 1 of the view) define an interface
used by Leo's core. Subclasses (part 2 of the view) implement the interface for
a particular gui.

** Subclasses can change without affecting Leo's code in any way.**

The essential design rule is: if gui-related code can be made gui- independent,
it should be part of a base class. Otherwise it must be part of a subclass of a
base gui class.

The gui base classes are far more than do-nothing interfaces. Examples of
complex code that reside in base classes:

A. tree.select. I am proud that this method is gui-independent. Switching nodes
is a very tricky business. Making it gui-independent is a big win.

B. leoFind.py. Finds the next/previous matches, and dealing with an "idealized"
find tab. Adapter classes exist in leoEditCommands.py.

C. Autocompletion and minibuffer code in leoKeys.py. For comparison, look how
simple leoTkinterKeys.py is.

D. A generalized, gui-independent interface to Leo's body pane. The commands in
leoEditCommands.py (part of the controller) use this interface (baseTextWidget)
rather than calling Tk directly.

**If you want to understand Leo's design, study Leo's base gui classes.**
.. @+node:ekr.20090401113141.1: ** How to generate odt/rtf/pdf files
To generate .odt or .rtf or .pdf files, you create an intermediate file and
ignore the the "official" output file, in this case test.html. The intermediate
file contains the rST text corresponding to the @rst tree.

To tell the rst3 plugin to generate an intermediate file, do::

    write_intermediate_file = True

After you create the intermediate file, in this case, test.html.txt,
You can create an odt file as follows::

    python <path-to-python>/scripts/rst2odt.py test.html.txt test.odt

I a batch file, rst2odt.bat, like this:

    rst2odt test

Note that rst3odt.py is in the tools directory of the DocUtils distribution.

To generate .rtf, you can use PanDoc to convert test.html.txt to RTF.

To generate .pdf files, you would first convert test.html.txt to LaTeX::

    python rst2newlatex.py test.html.txt test.tex

    -- OR --

    cd leo\docs\html
    make latex

You can then use one of the LaTeX to .pdf converters to create the final .pdf
file. See http://docutils.sourceforge.net/docs/user/latex.html#pdf-generation
for details.
.. @+node:ekr.20090620131445.5595: *3* Post from ville
I just tweaked conf.py a bit to enable pdf generation.

Howto:

QQQ

4. To create pdf (probably easiest on Linux, with necessary latex
packages installed):

- make latex
- cd _build/latex
- make all-pdf

QQQ

There were several errors in the pdf generation process. Notably,
there are probably lots of unicode errors (and toc doesn't appear).
Nevertheless, you can steal a peek at the doc here:

http://vvtools.googlecode.com/files/Leodocumentation.pdf 
.. @+node:ekr.20090401113141.2: *3* @rst c:\prog\test\test.html
@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

====
Test
====

This is a test.
.. @+node:ekr.20090401113141.4: *4* section 1
This is section 1
.. @+node:ekr.20091107093823.6790: ** Leo Tech report
This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.

@nocolor
@tabwidth -4
.. @+node:ekr.20091107093823.6791: *3* @rst html\techReport.html
@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. contents::
.. @+node:ekr.20091107093823.6792: *4* Old
.. @+node:ekr.20091107093823.6793: *5* Leo’s window, outlines & clones
Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leo’s main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.
.. @+node:ekr.20091107093823.6794: *5* Relations: organizer nodes, views, tasks and metadata
Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
.. @+node:ekr.20091107093823.6795: *5* Plugins
Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.
.. @+node:ekr.20091107093823.6796: *5* Derived files and special nodes
Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘@’ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.
.. @+node:ekr.20091107093823.6797: *5* Markup for scripts
Leo’s Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendents looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendent nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        <<section name>>

    The << and >> must appear on the same line. Conversely, any line
    containing << and >> is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between << and >>.

    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the section’s definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with ‘@’ in the leftmost column of body text. Directives
    specify options and control Leo’s operation. The @others directive is the
    minimal markup needed to organize scripts. @others tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the @others directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the @others directive to the indentation of all
    preprocessed text.

    Using @others is more convenient than using section references. Use @others when
    the order of included text does not matter::

        class myClass:
	        @others # Include the methods of the class. Order doesn’t matter.

    Use section references when the order of included text does matter. In the following script, for example,
    << imports >> ensures that imports come first. The @others directive then includes the body text of all other
    descendant nodes::

        @language python
        << imports>>
        @others # Define classes & functions in child nodes.
        main()

    Here is a list of all of Leo’s standard directives::

        @whitespace (or @doc)   Starts a doc part & ends code part.
        @all                    Like @others, but includes all descendent nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendents except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @root filename          Marks the root of a tree that creates an external file.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.

3.  Doc parts start with the ‘@’ directive and continue until the end of the body text or until the ‘@c’ directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The @pagewidth directive controls the length of these comment lines.
    The @language and @comment directives specify the comment delimiters used in doc parts.
.. @+node:ekr.20091107093823.6798: *5* Scripting Leo
The Execute Script command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called Markup for Scripts for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...
.. @+node:ekr.20091107093823.6799: *5* Leo’s modules and classes
Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See LeoPy.leo (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leo’s code g is always the leoGlobals module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leo’s global variables.

3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leo’s code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leo’s windows and panes.
    The **leoTkinterFrame** and **leoTkinterTree** modules contain subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frame’s commander, **f.body** is the frame’s body pane,
    **f.tree** is the frame’s outline pane, and **f.log** is the frame’s log pane.

5.  The leoNodes module defines several classes that implement Leo’s fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.
.. @+node:ekr.20091107093823.6800: *5* Predefined symbols in scripts
When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in c’s outline, i.e., c.currentPosition().
.. @+node:ekr.20091107093823.6801: *5* Accessing data
Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters::

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.
.. @+node:ekr.20091107093823.6802: *5* Traversing outlines
Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()
.. @+node:ekr.20091107093823.6803: *5* Executing commands from scripts
Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see Chapter 7: Scripting Leo with Python, in Leo’s Users Guide.
.. @+node:ekr.20091107093823.6804: *5* Bringing scripts to data
The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The Run Script button executes the script in the selected node just
like the Execute Script command. The Script Button button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
c.currentPosition() at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
.. @+node:ekr.20091107093823.6805: *5* Unit Testing with @test and @suite nodes
test.leo contains all of Leo’s unit tests. An @button node in test.leo
creates a blue Unit Test button in the icon area. This button is an
excellent example of bringing scripts to data. The Unit Test button executes
all the unit tests specified by @test and @suite nodes in the selected
outline. **Important**: @button, @test and @suite nodes require the
scripting plugin to be enabled.

@test nodes greatly simplify unit testing. The Unit Test button creates
a unit test from the body text of each @test node. In effect, the Unit
Test button automatically creates an instance of unittest.TestCase whose
run method is the body text of the @test node. There is no need to create
TestCase objects explicitly!

@suite nodes support legacy unit tests. When the Unit Test script button
finds an @suite node it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The Unit Test button then runs that
created suite of unit tests.
.. @+node:ekr.20091107093823.6806: *5* Plugins and hooks
Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating pluginsManager.txt by hand.

Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see Chapter 8: Customizing Leo, in
Leo’s Users Guide. The file leoPlugins.leo contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.
.. @+node:ekr.20091107093823.6807: *5* Contacts
- Leo’s home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@charter.net, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766
.. @-all
.. @-leo
