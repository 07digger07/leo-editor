.. @+leo-ver=5-thin
.. @+node:ekr.20100805165051.7176: * @thin other_docs.txt
.. @@language rest
.. @@tabwidth -4
.. @+all
.. @+node:ekr.20090711120622.10446: ** Screen shots page
@language rest
.. @+node:ekr.20090711120622.10447: *3* @rst html/screen-shots.html
################
Leo screen shots
################

.. contents::
    :depth: 2
.. @+node:ekr.20090811090022.14451: *4* @rst-no-head links
.. Links used in this document...

.. |leoQtMainWindow| image:: screen-shots/leo-qt-main-window.JPG

.. |leoTkMainWindow| image:: screen-shots/leo-tk-main-window.jpg

.. |leoQtMainWindowLinux| image:: screen-shots/leo-qt-main-window-linux.png
.. .. |findTab| image:: screen-shots/find-tab.jpg

.. |leoQtFindTab| image:: screen-shots/leo-qt-find-tab.JPG
.. @+node:ekr.20090811090022.14452: *4* Windows screen shots
Here is Leo's main window rendered with the Qt gui.
Top-left: the outline pane.
Top-right: the log pane.
Bottom: the body pane.
Below the body pane is the minibuffer.

|leoQtMainWindow|

Here is Leo's main window rendered with the Tk gui.
Just as with the Qt gui, you may adjust font sizes, colors, et.

|leoTkMainWindow|

Here is Leo's find tab, rendered with the Tk gui.
All parts of the find tab can be controlled from the keyboard.

|leoQtFindTab|
.. @+node:ekr.20090811090022.14453: *4* Linux screen shots
Here is Leo's main window as it appears on Linux:

|leoQtMainWindowLinux|
.. @+node:ekr.20090526102407.10028: ** Important notes about Leo's code
.. @+node:ekr.20090526102407.10029: *3* How to profile Leo
To gather statistics, do the following in a console window, not idle::

    > python
    >>> import leo
    >>> import leo.core.runLeo as r
    >>> r.prof()  (this runs leo)
    load any .leo file from Leo
    quit Leo

Intermediate data is written to cwd.leoProfile.txt.
The statistics are written to stdout.
.. @+node:ekr.20090526102407.10030: *3* High-level code notes
I've often said that I don't remember many details about Leo. This documentation
describes what I *do* remember about Leo's various modules. I hope this will be
useful to potential readers, users and modifiers of Leo's code.

In general, if you want to understand the code, read through it quickly, looking
for pieces of code that are unexpected complex, or unexpectedly simple. Forget
the details; remember the shape. Once you have the general shape in mind, you
are ready to modify the code. No kidding. Besides, more reading won't help :-)
.. @+node:ekr.20090526102407.10031: *4* leoFileCommands.py and leoAtFile.py
In general, write code is much simpler than read code,
because reading requires parsing. There are a few exceptions below.

leoFileCommands.py contains the code that reads and writes .leo files.

- This file uses the sax parser to parse the xml in .leo files.
- Complex code, driven by sax, turns sax nodes into Leo nodes.
- The putVnode method is "interesting".  Take a look.
  In the past, there have been significant, surprising bottlenecks in
  putVnode and maybe putTnode as well.  No longer.

leoAtFileCommands.py contains the code that reads and writes external files.

- There are options to read and write strings.
  These are useful for performance and for unit testing.
- atFile.replaceTargetFileIfDifferent is an important optimization.
- There are a lot of read/write commands for external files,
  and this results in lots of options being passed around.

Initing is tricky for both leoFileCommands.py and leoAtFileCommands.py.

- The bizarre call to initReadIvars() at the end of getLeoFile is one
  symptom of the difficulties.
- Never change init code without careful thought and unit testing.
.. @+node:ekr.20090526102407.10032: *4* Leo's MVC architecture
I. Background

Leo has had a robust MVC (Model,View,Controller) architecture from day one.

Leo's model are the classes in leoNodes.py. They are completely independent from
the rest of Leo. Many parts of Leo *use* these classes, but not vice versa!

Leo's controller is everything else in 'Code-->Core classes'. This code has *no*
direct dependencies on Leo's gui code, as will be explained next.

Leo's view has two parts:

1. The classes in the tree 'Code-->Gui Base classes'.
   These are part of Leo's core.

2. The classes in the tree 'Code-->Gui Tkinter classes'.
   These are essentailly a gui plugin.

Leo's core consists of the Model, Controller and the gui base classes.


II. Why Leo's core is gui-independent

Leo uses a completely standard way of separating gui-dependent code from
gui-independent code. Base gui classes (part 1 of the view) define an interface
used by Leo's core. Subclasses (part 2 of the view) implement the interface for
a particular gui.

** Subclasses can change without affecting Leo's code in any way.**

The essential design rule is: if gui-related code can be made gui- independent,
it should be part of a base class. Otherwise it must be part of a subclass of a
base gui class.

The gui base classes are far more than do-nothing interfaces. Examples of
complex code that reside in base classes:

A. tree.select. I am proud that this method is gui-independent. Switching nodes
is a very tricky business. Making it gui-independent is a big win.

B. leoFind.py. Finds the next/previous matches, and dealing with an "idealized"
find tab. Adapter classes exist in leoEditCommands.py.

C. Autocompletion and minibuffer code in leoKeys.py. For comparison, look how
simple leoTkinterKeys.py is.

D. A generalized, gui-independent interface to Leo's body pane. The commands in
leoEditCommands.py (part of the controller) use this interface (baseTextWidget)
rather than calling Tk directly.

**If you want to understand Leo's design, study Leo's base gui classes.**
.. @+node:ekr.20090401113141.1: ** How to generate odt/rtf/pdf files
To generate .odt or .rtf or .pdf files, you create an intermediate file and
ignore the the "official" output file, in this case test.html. The intermediate
file contains the rST text corresponding to the @rst tree.

To tell the rst3 plugin to generate an intermediate file, do::

    write_intermediate_file = True

After you create the intermediate file, in this case, test.html.txt,
You can create an odt file as follows::

    python <path-to-python>/scripts/rst2odt.py test.html.txt test.odt

I a batch file, rst2odt.bat, like this:

    rst2odt test

Note that rst3odt.py is in the tools directory of the DocUtils distribution.

To generate .rtf, you can use PanDoc to convert test.html.txt to RTF.

To generate .pdf files, you would first convert test.html.txt to LaTeX::

    python rst2newlatex.py test.html.txt test.tex

    -- OR --

    cd leo\docs\html
    make latex

You can then use one of the LaTeX to .pdf converters to create the final .pdf
file. See http://docutils.sourceforge.net/docs/user/latex.html#pdf-generation
for details.
.. @+node:ekr.20090620131445.5595: *3* Post from ville
I just tweaked conf.py a bit to enable pdf generation.

Howto:

QQQ

4. To create pdf (probably easiest on Linux, with necessary latex
packages installed):

- make latex
- cd _build/latex
- make all-pdf

QQQ

There were several errors in the pdf generation process. Notably,
there are probably lots of unicode errors (and toc doesn't appear).
Nevertheless, you can steal a peek at the doc here:

http://vvtools.googlecode.com/files/Leodocumentation.pdf 
.. @+node:ekr.20090401113141.2: *3* @rst c:\prog\test\test.html
@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = True
verbose=True
@c

====
Test
====

This is a test.
.. @+node:ekr.20090401113141.4: *4* section 1
This is section 1
.. @+node:ekr.20091107093823.6790: ** Leo Tech report
This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.

@nocolor
@tabwidth -4
.. @+node:ekr.20091107093823.6791: *3* @rst html\techReport.html
@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

##########################################
The Essentials of Leo
##########################################

.. contents::
.. @+node:ekr.20091107093823.6792: *4* Old
.. @+node:ekr.20091107093823.6793: *5* Leo’s window, outlines & clones
Leo organizes all data into nodes containing a **headline**, an expandable page of
**body text** and a (possibly empty) subtree of **descendant nodes**. The **contents** of a
node are its headline and body text. Leo’s main window contains an **outline** pane
at the top left, a **log pane** at the top right, and a **body pane** at the bottom. The
outline pane shows headlines; the body pane shows the body text of the selected
headline. The log pane displays messages from Leo.

Small red arrows mark **cloned nodes** (clones). Clones share the same content and
descendants. All clones of the same node are equivalent, so changing the
contents of one node (call it node N) changes the contents of all clones of N.
Furthermore, inserting, deleting or changing any descendant of node N causes the
corresponding insertion, deletion or change in all other clones of N.
.. @+node:ekr.20091107093823.6794: *5* Relations: organizer nodes, views, tasks and metadata
Clones allow you to organize data in multiple ways within the same outline. You
do not have to choose a single ‘correct’ organization: you can organize your
data in as many ways as you like.

You can use **organizer nodes** to create explicit relations (relationships) among
the data in your outline. The headline of the organizer node is the
relationship’s name. Now make clones of nodes from other parts of the outline
that participate in the relation. Drag the newly created clones so they become
children of the organizer node. You may want to create other (non-cloned)
children of the organizer node that contain data found nowhere else in the
outline. Voilà: you have just created the set of all nodes that pertain to the
relationship. The organizer node is the relation; the terms relation,
relationship and organizer node are interchangeable.

Three kinds of relations deserve special mention. A **view** is a relation (an
organizer node) containing all nodes related to a desired view (or slice) of the
data in the outline. Similarly, a **task** is an organizer node containing all nodes
related to a task. Relations are not limited to tasks or views: the notion of
relationship is completely general. Headlines naturally describe the data in
body text. That is, nodes relate **metadata** (descriptions of data) to data.
Separating data from metadata is useful for humans. It is even more valuable for
scripts: scripts can access data and metadata without complex parsing.
.. @+node:ekr.20091107093823.6795: *5* Plugins
Plugins are Python (.py) files contained in Leo’s plugins folder. Users can
write plugins to change how Leo works and to add new features without changing
Leo’s core code. We’ll discuss plugins in more detail later.
.. @+node:ekr.20091107093823.6796: *5* Derived files and special nodes
Leo can generate many external files called **derived files** from an outline. Leo
outlines can organize files throughout your computer’s file system. Nodes whose
headlines start with ‘@’ are special nodes. Several **special nodes** indicate the
root of a tree that generates a derived file::

    @asis filename    Creates a derived file. Ignores all markup in body text.
    @file filename    Creates a derived file. Duplicates outline structure in .leo file.
    @nosent filename  Creates a derived file without sentinels.
    @thin filename    (Recommended) Like @file, but thin derived files contain all outline structure.

Leo recognizes several other special nodes::

    @settings   Defines settings local to the .leo file.
    @url url    Double-clicking the node’s icon opens the url in Leo or in a browser.

The scripting plugin scans for the following nodes when opening an outline::

    @button         Creates a button in the **icon area** at the top of the Leo window.
    @plugin plugin  Enables a plugin if the plugin has not already been enabled.
    @script         Executes a script when opening the outline. This is a security risk: it is disabled by default.

Plugins, @button nodes and @script nodes can create other kinds of special nodes::

    @suite       Creates a suite of unit tests from script in body. Requires scripting plugin.
    @test        Creates a unit text from script in body. Requires scripting plugin.
    @rst         Outputs a tree containing markup for reStructuredText. Requires rst2 plugin.
    @run command Double clicking the node’s icon executes the command.  Requires run_nodes plugin.
.. @+node:ekr.20091107093823.6797: *5* Markup for scripts
Leo’s Execute Script command **preprocesses** the script to be executed by scanning
a node N and its descendents looking for markup. **Markup** is special syntax that
controls this preprocessing. If node N contains no markup, the resulting script
is just N’s body text. Otherwise, the preprocessed script will include text from
descendent nodes as described below. The main kinds of markup are **section
references**, **directives** and **doc parts**.

1.  **Section references** have the form::

        <<section name>>

    The << and >> must appear on the same line. Conversely, any line
    containing << and >> is a section reference, regardless of context. However,
    section references are not recognized in doc parts. Any characters may appear
    between << and >>.

    Section references are functional pseudo-code: while preprocessing a script, Leo
    replaces section references by the actual text of the section’s definition.
    Sections are defined in **section definition nodes**, whose headlines start with a
    section reference and whose body text defines the section. Each section
    definition node must descend from the node containing the section reference.

2.  **Directives** start with ‘@’ in the leftmost column of body text. Directives
    specify options and control Leo’s operation. The @others directive is the
    minimal markup needed to organize scripts. @others tells Leo to insert the
    preprocessed text of all descendant nodes (except section definition nodes) at
    the spot at which the @others directive occurs. Nodes are inserted in **outline
    order**, the order in which nodes appear in the outline. **Important**: Leo adds the
    whitespace preceding the @others directive to the indentation of all
    preprocessed text.

    Using @others is more convenient than using section references. Use @others when
    the order of included text does not matter::

        class myClass:
	        @others # Include the methods of the class. Order doesn’t matter.

    Use section references when the order of included text does matter. In the following script, for example,
    << imports >> ensures that imports come first. The @others directive then includes the body text of all other
    descendant nodes::

        @language python
        << imports>>
        @others # Define classes & functions in child nodes.
        main()

    Here is a list of all of Leo’s standard directives::

        @whitespace (or @doc)   Starts a doc part & ends code part.
        @all                    Like @others, but includes all descendent nodes.
        @c, @code               Starts a code part and ends a doc part.
        @color                  Enables syntax coloring.
        @delims                 Temporarily changes comment delims.
        @nocolor, @killcolor    Disables syntax coloring.
        @comment                Sets comment delimiters in external (derived) files.
        @language languagename  Sets language for syntax coloring and comments.
        @lineending lineending  Sets ending of lines in derived files.
        @others                 Inserts body text of all descendents except definition nodes. 
        @pagewidth n            Sets page width for justifying comments in doc parts.
        @path path              Sets prefix to use in relative file names in @file nodes, etc.
        @root filename          Marks the root of a tree that creates an external file.
        @raw, @end_raw          Inhibits sections references in a range of text. (@file only.)
        @tabwidth n             Sets width of tabs (negative widths convert tabs to spaces.)
        @wrap, @nowrap          Controls wrapping of text in body pane.

3.  Doc parts start with the ‘@’ directive and continue until the end of the body text or until the ‘@c’ directive.
    Body text not in a doc part is in a code part. Here is an example of a doc part::

        @ This is a doc part. Doc parts may span many lines. Leo converts doc parts to comments.
        Leo reformats the doc part by justifying lines so they are no longer than the page width.
        @c

    Leo reformats doc parts by justifying the text into comment lines.
    The @pagewidth directive controls the length of these comment lines.
    The @language and @comment directives specify the comment delimiters used in doc parts.
.. @+node:ekr.20091107093823.6798: *5* Scripting Leo
The Execute Script command preprocesses the selected text of the presently
selected outline node, or the entire text of the node if there is no selected
text. See the section called Markup for Scripts for a discussion of how Leo
preprocesses scripts. That section also discusses how Leo organizes scripts
using outlines. Conversely, scripts can use outlines to organize their data. To
write such scripts you must understand at least the basics of Leo’s modules and
classes...
.. @+node:ekr.20091107093823.6799: *5* Leo’s modules and classes
Leo’s source code is organized as a collection of modules. The following
paragraphs describe five of the most important modules. See LeoPy.leo (Leo’s
full source code) for more details: scripts have full access to all of Leo’s
classes and data.

1.  The **leoGlobals** module contains utility functions.
    By convention, in Leo’s code g is always the leoGlobals module.

2.  The **leoApp** module defines a class representing the entire Leo application.
    **g.app** is the singleton object of this class: the application object.
    The instance variables (ivars) of the application object are Leo’s global variables.

3.  The leoCommands module defines the Commands class.
    A commander is an instance of this class.
    Commanders contain the operations that can be performed on a particular outline.
    Each open Leo outline has its own commander.
    By convention, in Leo’s code **c** is always a commander.

4.  The leoFrame module defines the base leoFrame class for objects that create and manage
    the visual appearance of Leo’s windows and panes.
    The **leoTkinterFrame** and **leoTkinterTree** modules contain subclasses of the base classes in the leoFrame module.
    A frame (an instance of the leoFrame class, or a subclass)
    contains all the internal data needed to manage a Leo window.
    **c.frame** is the frame associated with commander c.
    If **f** is a frame, **f.c** is the frame’s commander, **f.body** is the frame’s body pane,
    **f.tree** is the frame’s outline pane, and **f.log** is the frame’s log pane.

5.  The leoNodes module defines several classes that implement Leo’s fundamental data structures.
    These classes are complex.
    Happily, scripts can and should ignore these complications by accessing nodes using
    high-level methods of the position class.

A **position** (an instance of the position class) is the state of some traversal of an outline. Equivalently, a position is a particular visual place in an outline. Cloned nodes may appear many times in an outline. Non-cloned nodes may also appear in many places: consider a non-cloned descendant of a cloned node. By convention, in Leo’s source code p is a position.
.. @+node:ekr.20091107093823.6800: *5* Predefined symbols in scripts
When executing scripts Leo predefines the following three symbols:
**c** is the commander of the outline in which the script is defined,
**g** is the leoGlobals module and
**p** is the position of the selected node in c’s outline, i.e., c.currentPosition().
.. @+node:ekr.20091107093823.6801: *5* Accessing data
Scripts should get and set data using high-level access methods. Here are some important getters::

    g.app                The application object. Its ivars are Leo’s global variables.
    g.app.windowList     The list of all open frames.
    c.currentPosition()  The position of the selected node.
    c.rootPosition()     The position of the first node in the outline.
    p.headString()       The headline of position p.
    p.bodyString()       The body text of position p.
    p.childIndex()       The number of siblings that precede p.
    p.numberOfChildren() The number of p’s children.
    p.level()            The number of p’s ancestors.
    p.hasChildren()      True if p has children.
    p.isAncestorOf(p2)   True if p2 is a child, grandchild, etc. of p.
    p.isCloned()         True if p is a clone.
    p.isDirty()          True if p’s contents have been changed.
    p.isExpanded()       True if p has children and p’s outline is expanded.
    p.isMarked()         True if p’s headline is marked.
    p.isVisible()        True if all of p’s ancestors are expanded.

And here are some important setters::

    p.setBodyStringOrPane(s) Set body text of p to s.
    p.setHeadString(s)       Set headline of p to s.
.. @+node:ekr.20091107093823.6802: *5* Traversing outlines
Scripts can visit some or all of the nodes of a Leo outline using the following iterators::

    c.allNodes_iter             # All positions in the outline, in outline order.
    p.children_iter()           # All children of p.
    p.parents_iter()            # All parents of p.
    p.siblings_iter()           # All siblings of p, including p.
    p.following_siblings_iter() # All siblings following p, not including p.

For example, the following prints all the nodes of an outline, properly indented::

    for p in c.allNodes_iter():
        print ' '*p.level(), p.headString()
.. @+node:ekr.20091107093823.6803: *5* Executing commands from scripts
Scripts may open other Leo outlines, or execute any of Leo’s commands.  Here are some examples::

    ok,frame = g.openWithFileName(path,c)	# Opens the .leo file found at path.
    c.deleteOutline()   # Deletes the selected node.
    c.insertHeadline()  # Inserts a new node after present position.

For more examples, see Scripting Leo with Python, in Leo’s Users Guide.
.. @+node:ekr.20091107093823.6804: *5* Bringing scripts to data
The scripting plugin creates two buttons in the icon area at the top of the Leo
window. The Run Script button executes the script in the selected node just
like the Execute Script command. The Script Button button creates a new
button whose headline is the headline of the presently selected node, call it
node N. Pressing this button executes the script in node N with p predefined as
c.currentPosition() at the time the script is executed. This clever trick
brings the script to the data in the selected outline.
.. @+node:ekr.20091107093823.6805: *5* Unit Testing with @test and @suite nodes
test.leo contains all of Leo’s unit tests. An @button node in test.leo
creates a blue Unit Test button in the icon area. This button is an
excellent example of bringing scripts to data. The Unit Test button executes
all the unit tests specified by @test and @suite nodes in the selected
outline. **Important**: @button, @test and @suite nodes require the
scripting plugin to be enabled.

@test nodes greatly simplify unit testing. The Unit Test button creates
a unit test from the body text of each @test node. In effect, the Unit
Test button automatically creates an instance of unittest.TestCase whose
run method is the body text of the @test node. There is no need to create
TestCase objects explicitly!

@suite nodes support legacy unit tests. When the Unit Test script button
finds an @suite node it executes the script in its body text. This script
should create a suite of unit tests and set::

    g.app.scriptDict['suite'] = suite

where suite is the created suite. The Unit Test button then runs that
created suite of unit tests.
.. @+node:ekr.20091107093823.6806: *5* Plugins and hooks
Plugins are Python (.py) files in Leo’s plugin subdirectory. It is easy to
create new plugins: Leo’s users have contributed dozens of plugins that extend
Leo’s capabilities in new ways. Leo imports all enabled plugins during startup.
The file pluginsManager.txt lists all enabled plugins. You can use the plugin
manager plugin to control plugins without updating pluginsManager.txt by hand.

Plugins can override any class, method or function in Leo’s core, the files in
Leo’s src subdirectory (the files derived from LeoPy.leo). Besides altering
Leo’s core, plugins can register functions called hooks that Leo calls at
various times during Leo’s execution. Events that trigger hooks include key
pressed events, screen drawing events, node selection events and many others.
When importing a plugin, Leo will call the top-level init() function if it
exists. This function should register the plugin’s hooks by calling
leoPlugins.registerHandler.

For full details about hooks and events see Customizing Leo, in
Leo’s Users Guide. The file leoPlugins.leo contains all plugins that are
presently distributed with Leo; studying these plugins is a good way of learning
to write your own plugins.
.. @+node:ekr.20091107093823.6807: *5* Contacts
- Leo’s home page:  google edreamleo or http://webpages.charter.net/edreamleo/front.html

- Edward K. Ream:  edreamleo@charter.net, 166 N. Prospect Ave., Madison WI 53726, (608) 231-0766
.. @-all
.. @-leo
