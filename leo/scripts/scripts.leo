<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954"><vh>Startup</vh>
<v t="ekr.20070427110751"><vh>@chapters</vh></v>
<v t="ekr.20111017085134.16069"><vh>Disabled buttons</vh>
<v t="ekr.20111017085134.16070"><vh>@@button jython</vh></v>
<v t="ekr.20111017085134.16071"><vh>@@button pydoc</vh></v>
<v t="ekr.20111017085134.16072"><vh>@@button check-dirty</vh></v>
<v t="ekr.20111017085134.16073"><vh>@@button Ipython</vh></v>
<v t="ekr.20111017085134.16074"><vh>@@button Lines Down</vh>
<v t="ekr.20111017085134.16075"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20111017085134.16076"><vh>@@button Lines Up</vh>
<v t="ekr.20111017085134.16077"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20111017085134.16078"><vh>@@button lispCall @key=alt+6</vh>
<v t="ekr.20111017085134.16079"><vh>ctor</vh></v>
<v t="ekr.20111017085134.16080"><vh>run &amp; helpers</vh>
<v t="ekr.20111017085134.16081"><vh>findCalls</vh></v>
<v t="ekr.20111017085134.16082"><vh>findDefs</vh></v>
<v t="ekr.20111017085134.16083"><vh>stripComments</vh></v>
<v t="ekr.20111017085134.16084"><vh>stripLispIds</vh></v>
<v t="ekr.20111017085134.16085"><vh>stripStrings</vh></v>
</v>
<v t="ekr.20111017085134.16086"><vh>class token</vh></v>
<v t="ekr.20111017085134.16087"><vh>choose</vh></v>
<v t="ekr.20111017085134.16088"><vh>dumpList</vh></v>
<v t="ekr.20111017085134.16089"><vh>Parsing...</vh>
<v t="ekr.20111017085134.16090"><vh>parse</vh></v>
<v t="ekr.20111017085134.16091"><vh>scan &amp; helpers</vh>
<v t="ekr.20111017085134.16092"><vh>skipComment</vh></v>
<v t="ekr.20111017085134.16093"><vh>skipId</vh></v>
<v t="ekr.20111017085134.16094"><vh>skipString</vh></v>
</v>
<v t="ekr.20111017085134.16095"><vh>scanForest</vh></v>
</v>
<v t="ekr.20111017085134.16096"><vh>Code generators...</vh>
<v t="ekr.20111017085134.16097"><vh>gen</vh></v>
<v t="ekr.20111017085134.16098"><vh>gen_token</vh></v>
<v t="ekr.20111017085134.16099"><vh>gen_block &amp; helper</vh>
<v t="ekr.20111017085134.16100"><vh>gen_block_id</vh></v>
</v>
<v t="ekr.20111017085134.16101"><vh>gen_call &amp; helper</vh>
<v t="ekr.20111017085134.16102"><vh>gen_arg</vh></v>
</v>
<v t="ekr.20111017085134.16103"><vh>gen_def</vh></v>
<v t="ekr.20111017085134.16104"><vh>gen_if &amp; helpers</vh>
<v t="ekr.20111017085134.16105"><vh>gen_then</vh></v>
</v>
<v t="ekr.20111017085134.16106"><vh>gen_expr</vh></v>
<v t="ekr.20111017085134.16107"><vh>gen_let &amp; helper</vh>
<v t="ekr.20111017085134.16108"><vh>gen_let_bindings</vh></v>
</v>
<v t="ekr.20111017085134.16109"><vh>put...</vh>
<v t="ekr.20111017085134.16110"><vh>put </vh></v>
<v t="ekr.20111017085134.16111"><vh>put_token</vh></v>
<v t="ekr.20111017085134.16112"><vh>put_code &amp; put_code_line</vh></v>
<v t="ekr.20111017085134.16113"><vh>put_code_token</vh></v>
</v>
</v>
</v>
<v t="ekr.20111017085134.16114"><vh>@@button outlineToClipboard</vh></v>
</v>
</v>
<v t="ekr.20061008055616"><vh>Scripts</vh>
<v t="ekr.20051110111150"><vh>@thin leoScripts.txt</vh></v>
<v t="ekr.20110914030246.2405"><vh>@file gen_blender_docs.py</vh></v>
<v t="maphew.20130612230051.2793"><vh>Windows</vh>
<v t="maphew.20130613230258.2801"><vh>@file elevate.py</vh></v>
<v t="maphew.20130611235500.2658"><vh>@file register-leo.leox</vh></v>
<v t="maphew.20130611235500.2665"><vh>@file unregister-leo.leox</vh></v>
</v>
</v>
<v t="ekr.20121220111212.13257"><vh>@button write-unit-tests</vh>
<v t="ekr.20121220111212.13258"><vh>&lt;&lt; about this script &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13259"><vh>class TestWriter</vh>
<v t="ekr.20121220111212.13260"><vh>&lt;&lt; define file_template &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13261"><vh>&lt;&lt; define test_template &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13262"><vh> ctor</vh></v>
<v t="ekr.20121220111212.13263"><vh>clean</vh></v>
<v t="ekr.20121220111212.13264"><vh>get_body</vh></v>
<v t="ekr.20121220111212.13265"><vh>run</vh></v>
<v t="ekr.20121220111212.13266"><vh>test</vh></v>
<v t="ekr.20121220111212.13267"><vh>write_file</vh></v>
</v>
</v>
<v t="ekr.20121013084734.16370"><vh>Recursive import script (with cleanups)</vh>
<v t="ekr.20121013084734.16371"><vh>class ImportController</vh>
<v t="ekr.20121013084734.16372"><vh>Pass 1: import_dir</vh></v>
<v t="ekr.20121013084734.16373"><vh>Pass 2: clean_all &amp; helpers</vh>
<v t="ekr.20121013084734.16374"><vh>clean</vh></v>
<v t="ekr.20121013084734.16375"><vh>clean_blank_lines</vh></v>
<v t="ekr.20121013084734.16376"><vh>merge_comment_nodes</vh></v>
<v t="ekr.20121013084734.16377"><vh>merge_extra_nodes</vh></v>
<v t="ekr.20121013084734.16378"><vh>move_decorator_lines</vh></v>
<v t="ekr.20121013084734.16379"><vh>move_doc_string</vh></v>
<v t="ekr.20121013084734.16380"><vh>move_shebang_line</vh></v>
<v t="ekr.20121013084734.16381"><vh>rename_decls</vh></v>
</v>
<v t="ekr.20121013084734.16382"><vh>Pass 3: post_process &amp; helpers</vh>
<v t="ekr.20121013084734.16383"><vh>clear_dirty_bits</vh></v>
<v t="ekr.20121013084734.16384"><vh>dump_headlines</vh></v>
<v t="ekr.20121013084734.16385"><vh>fix_back_slashes</vh></v>
<v t="ekr.20121013084734.16386"><vh>minimize_headlines</vh></v>
<v t="ekr.20121013084734.16387"><vh>remove_empty_nodes</vh></v>
</v>
<v t="ekr.20121013084734.16388"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20130803163703.3086"><vh>clojure example</vh></v>
<v t="ekr.20130803173509.2906"><vh>small example</vh></v>
<v t="ekr.20130803173509.2908"><vh>small example</vh></v>
<v t="ekr.20130803180319.2910"><vh>small example</vh></v>
<v t="ekr.20060824111500.108"><vh>@button jEdit2Py</vh>
<v t="ekr.20060824111500.109"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20060824111500.110"><vh>&lt;&lt; to do &gt;&gt;</vh></v>
<v t="ekr.20060824111500.111"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20060824111500.112"><vh>&lt;&lt; set files to convert &gt;&gt;</vh></v>
<v t="ekr.20060824111500.113"><vh>top-level</vh>
<v t="ekr.20060824111500.114"><vh>convert</vh></v>
<v t="ekr.20060824111500.115"><vh>parse_jEdit_file</vh></v>
<v t="ekr.20060824111500.116"><vh>munge</vh></v>
</v>
<v t="ekr.20060824111500.117"><vh>class modeClass</vh>
<v t="ekr.20060824111500.118"><vh> mode.__init__</vh></v>
<v t="ekr.20060824111500.119"><vh> mode.__str__ &amp; __repr__</vh></v>
<v t="ekr.20060824111500.120"><vh> Output...</vh>
<v t="ekr.20060827162343"><vh>fullDelegate</vh></v>
<v t="ekr.20060824111500.121"><vh>escapeString &amp; quoteString</vh></v>
<v t="ekr.20060824111500.122"><vh>put, putTripleString</vh></v>
<v t="ekr.20060824111500.123"><vh>putAttributes</vh></v>
<v t="ekr.20060824111500.124"><vh>putDict &amp; putDictOfLists</vh></v>
<v t="ekr.20060824111500.125"><vh>putImportDict</vh></v>
<v t="ekr.20060824111500.126"><vh>putKeywordsData</vh></v>
<v t="ekr.20060824111500.127"><vh>putList</vh></v>
<v t="ekr.20060824111500.128"><vh>putModeProperties</vh></v>
<v t="ekr.20060824111500.129"><vh>putRule &amp; rule creators</vh>
<v t="ekr.20060824111500.130"><vh>putBadRule</vh></v>
<v t="ekr.20060824111500.131"><vh>putEolSpan</vh></v>
<v t="ekr.20060824111500.132"><vh>putEolSpanRegexp</vh></v>
<v t="ekr.20060824111500.133"><vh>putImport</vh></v>
<v t="ekr.20060824111500.134"><vh>putKeywords</vh></v>
<v t="ekr.20060824111500.135"><vh>putMarkFollowing</vh></v>
<v t="ekr.20060824111500.136"><vh>putMarkPrevious</vh></v>
<v t="ekr.20060824111500.137"><vh>putSeq</vh></v>
<v t="ekr.20060824111500.138"><vh>putSeqRegexp</vh></v>
<v t="ekr.20060824111500.139"><vh>putSpan</vh></v>
<v t="ekr.20060824111500.140"><vh>putSpanRegexp</vh></v>
<v t="ekr.20060824111500.141"><vh>putTerminate</vh></v>
</v>
<v t="ekr.20060824111500.142"><vh>putRules</vh></v>
<v t="ekr.20060824111500.143"><vh>write</vh></v>
</v>
<v t="ekr.20060824111500.144"><vh> Printing...</vh>
<v t="ekr.20060824111500.145"><vh>printModeAttributes, printRulesetAttributes &amp; printAttributesHelper</vh></v>
<v t="ekr.20060824111500.146"><vh>printProperty</vh></v>
<v t="ekr.20060824111500.147"><vh>printRule</vh></v>
<v t="ekr.20060824111500.148"><vh>printRuleset</vh></v>
<v t="ekr.20060824111500.149"><vh>printSummary</vh></v>
</v>
<v t="ekr.20060824111500.150"><vh>doAttribute</vh></v>
<v t="ekr.20060824111500.151"><vh>doContent</vh></v>
<v t="ekr.20060824111500.152"><vh>endElement</vh></v>
<v t="ekr.20060824111500.153"><vh>error</vh></v>
<v t="ekr.20060824111500.154"><vh>getters</vh></v>
<v t="ekr.20060824111500.155"><vh>inRule</vh></v>
<v t="ekr.20060824111500.156"><vh>startElement</vh></v>
</v>
<v t="ekr.20060824111500.157"><vh>class rulesetClass</vh>
<v t="ekr.20060824111500.158"><vh>ctor &amp; __str__</vh></v>
</v>
<v t="ekr.20060824111500.159"><vh>class ruleClass</vh>
<v t="ekr.20060824111500.160"><vh>ctor &amp; __str__</vh></v>
<v t="ekr.20060824111500.161"><vh>rule.getters</vh></v>
</v>
<v t="ekr.20060824111500.162"><vh>class contentHandler (xml.sax.saxutils.XMLGenerator)</vh>
<v t="ekr.20060824111500.163"><vh> __init__ &amp; helpers</vh></v>
<v t="ekr.20060824111500.164"><vh>helpers</vh>
<v t="ekr.20060824111500.165"><vh>attrsToList</vh></v>
<v t="ekr.20060824111500.166"><vh>attrsToString</vh></v>
<v t="ekr.20060824111500.167"><vh>clean</vh></v>
<v t="ekr.20060824111500.168"><vh>error</vh></v>
<v t="ekr.20060824111500.169"><vh>printStartElement</vh></v>
<v t="ekr.20060824111500.170"><vh>printSummary</vh></v>
</v>
<v t="ekr.20060824111500.171"><vh>sax over-rides</vh>
<v t="ekr.20060824111500.172"><vh> Do nothing...</vh>
<v t="ekr.20060824111500.173"><vh>other methods</vh></v>
<v t="ekr.20060824111500.174"><vh>endDocument</vh></v>
<v t="ekr.20060824111500.175"><vh>startDocument</vh></v>
</v>
<v t="ekr.20060824111500.176"><vh>characters</vh></v>
<v t="ekr.20060824111500.177"><vh>endElement</vh></v>
<v t="ekr.20060824111500.178"><vh>startElement</vh></v>
</v>
<v t="ekr.20060824111500.179"><vh>doStartElement</vh></v>
<v t="ekr.20060824111500.180"><vh>doEndElement</vh></v>
<v t="ekr.20060824111500.181"><vh>getMode</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20060824111500.108">'''Convert jEdit language description file to an equivalent .py file.'''

@language python
@tabwidth -4
@pagewidth 80

&lt;&lt; imports &gt;&gt;
&lt;&lt; to do &gt;&gt;
&lt;&lt; version history &gt;&gt;
&lt;&lt; set files to convert &gt;&gt;
opt_print_summary = False # True: print summary in doEndElement.
opt_print_elements = False
@others
g.cls()
# print('-'*40)
for path1 in files:
    if path1 in errors:
        print('skipping %s' % path1)
    else:
        path2 = path1[:-3] + 'py'
        try:
            convert (c,path1,path2)
        except Exception:
            print('Exception creating', path2)
            g.es_exception()
g.es_print('done')
</t>
<t tx="ekr.20060824111500.109">import glob
import string
import xml.sax
import xml.sax.saxutils
</t>
<t tx="ekr.20060824111500.110">@nocolor
@

AT_LINE_START, AT_WHITESPACE_END and AT_WORD_START attributes can also be used
on the BEGIN and END elements. Setting these attributes to the same value on
both elements has the same effect as setting them on the SPAN element.
</t>
<t tx="ekr.20060824111500.111">@nocolor
@

7/23/06 EKR: Ignore keywords containing whitespace.
7/30/06 EKR: Compute keywordChars properly.  This fixes erlang bug, e.g.
8/24/06 EKR: Lowercase all keywords if ignore_case is true.
8/25/06 EKR: Prefixed all rule names with fileName (w/o extension) so I can makes sense of imported rules.
8/26/06 EKR: No need for hash_char in pattern matchers, because they are called only if the hash_char matches.
9/4/06  EKR: Added support for ESCAPE attribute of RULES element.
             This is required so the new colorizer plugin can support the no_escape argument to pattern matchers.
</t>
<t tx="ekr.20060824111500.112"># theDir = r'c:\prog\tigris-cvs\leo\modes'
theDir = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','modes'))
fixed = ['antlr','applescript','apacheconf','bibtex','cil','pl1','shell','shellscript','ssharp','text']
errors = [] # 'cil',] # End keyword not matched by start.
errors = [r'%s\%s.xml' % (theDir,s) for s in errors]
# for s in errors: print(s)
if 1: # A a list of files.
    files = [r'%s\%s.xml' % (theDir,s) for s in ('clojure',)] # 'rest','perl','scala',
elif 1: # translate all files.
    files = glob.glob(g.os_path_abspath(g.os_path_join(theDir,'*.xml')))
elif 1: # error files
    files = [g.os_path_abspath(g.os_path_join(theDir,s)) for s in errors]
else: # translate two representative files.
    files = [g.os_path_abspath(g.os_path_join(theDir,s)) for s in ('python','php')]
# for s in files: print(s)
</t>
<t tx="ekr.20060824111500.113"></t>
<t tx="ekr.20060824111500.114">def convert (c,inputFileName,outputFileName):

    junk, fn = g.os_path_split(inputFileName)
    language, junk = g.os_path_splitext(fn)
    g.es_print('convert: %s' % (language))
    mode = parse_jEdit_file(inputFileName,language)
    if mode:
        try:
            f = open(outputFileName,'w')
        except IOError:
            g.trace('can not create %s' % outputFileName)
            return
        try:
            mode.write(f,language)
        finally:
            f.close()
</t>
<t tx="ekr.20060824111500.115">def parse_jEdit_file(inputFileName,language):

    if not inputFileName:
        return None
    if not inputFileName.endswith('.xml'):
        inputFileName = inputFileName + '.xml'
    path = g.os_path_join(g.app.loadDir,'../','modes',inputFileName)
    path = g.os_path_normpath(path)
    try: f = open(path)
    except IOError:
        g.trace('can not open %s'%path)
        return None
    try:
        try:
            mode = None
            parser = xml.sax.make_parser()
            # Do not include external general entities.
            # The actual feature name is "http://xml.org/sax/features/external-general-entities"
            parser.setFeature(xml.sax.handler.feature_external_ges,0)
            handler = contentHandler(c,inputFileName,language)
            parser.setContentHandler(handler)
            parser.parse(f)
            mode = handler.getMode()
        except:
            g.es('unexpected exception parsing %s' % (inputFileName),color='red')
            g.es_exception()
    finally:
        f.close()
        return mode
</t>
<t tx="ekr.20060824111500.116">def munge(s):

    '''Munge a mode name so that it is a valid python id.'''

    valid = string.ascii_letters + string.digits + '_'
    return ''.join([g.choose(ch in valid,ch.lower(),'_') for ch in s])
</t>
<t tx="ekr.20060824111500.117">class modeClass:

    '''A class representing one jEdit language-description mode.

    Use getters to access the attributes, properties and rules of this mode.'''

    @others
</t>
<t tx="ekr.20060824111500.118">def __init__ (self,contentHandler,fileName):

    # g.trace('mode',fileName)

    self.contentHandler = contentHandler
    self.c = contentHandler.c
    self.fileName = g.shortFileName(fileName) # The file from which the mode was imported.
    modeName, junk = g.os_path_splitext(self.fileName)
    self.fileModeName = modeName
    self.modeName = munge(modeName).lower()
    self.outputFile = None # The open output file to which Python statements get written.
    self.tab_width = c.scanAllDirectives().get('tab_width')

    # Mode statistics...
    self.numberOfAttributes = 0
    self.numberOfElements = 0
    self.numberOfErrors = 0
    self.numberOfPropertyAttributes = 0
    self.numberOfRuleAttributes = 0

    # List of boolean attributes.
    self.boolAttrs = [
        'at_line_start','at_whitespace_end','at_word_start',
        'exclude_match','highlight_digits','ignore_case',
        'no_escape','no_line_break','no_word_break',]

    # List of elements that start a rule.
    self.ruleElements = [
        'eol_span','eol_span_regexp','import','keywords',
        'mark_following','mark_previous','seq','seq_regexp',
        'span','span_regexp','terminate',]

    if 0: # Not used at present.
        self.seqSpanElements = [
            'eol_span','eol_span_regexp','seq','seq_regexp',
            'span','span_regexp',]

    # Mode semantics.
    self.attributes = {}
    self.handlerCount = 0
    self.importedRules = [] # A bunch describing the imported ruleset.
    self.inProps = False
    self.inRules = False
    self.keywords = None
    self.modeProperties = []
    self.presentProperty = None # A bunch to be assigned to modeProperties or rulesetProperties.
    self.rule = None
    self.rulesets = []
    self.rules = [] # The rules of the present rules element.
    self.rulesetProperties = []
    self.rulesetAttributes = {} # The attributes of the present rules element.
</t>
<t tx="ekr.20060824111500.119">def __str__ (self):

    return '&lt;modeClass for %s&gt;' % self.fileName

__repr__ = __str__
</t>
<t tx="ekr.20060824111500.120"># Similar to printing, but generates the output file.
</t>
<t tx="ekr.20060824111500.121">def escapeString (self,s):

    '''Return string s enclosed in double quotes.'''

    if type(s) == type([]):
        s = ''.join(s)
        
    s = g.toUnicode(s)

    # Order is important: escape backspaces first.
    return '"%s"' % s.replace('\\','\\\\').replace('"','\\"').replace('\t','\\t')

quoteString = escapeString
</t>
<t tx="ekr.20060824111500.122">def put (self,s):

    self.outputFile.write(s)

def putTripleString(self,s):

    self.put(g.adjustTripleString(s,self.tab_width))
</t>
<t tx="ekr.20060824111500.123">def putAttributes (self):

    dd = {}
    data = (
        ('default','null'),
        ('digit_re',''),
        ('escape',''),
        ('highlight_digits',True),
        ('ignore_case',True),
        ('no_word_sep',None), # could be false or ''.
    )

    for ruleset in self.rulesets:
        d = {}
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        self.put('# Attributes dict for %s ruleset.\n' % (prefix))
        for key,default in data:
            val = ruleset.attributes.get(key,default)
            if default == True: val = g.choose(val,'true','false')
            elif default == None:
                if val and val.lower() == 'false': val = ''
                else: val = g.choose(val,val,'')
            # if val: g.trace(key,repr(val))
            d [key] = val


        self.putDict('%s_attributes_dict' % (prefix),d)
        dd [ prefix ] = '%s_attributes_dict' % (prefix)

    self.put('# Dictionary of attributes dictionaries for %s mode.\n' % (self.modeName))
    self.putDict('attributesDictDict',dd,escape=False)
</t>
<t tx="ekr.20060824111500.124">def putDict (self,name,theDict,escape=True):

    esc = self.escapeString
    esc2 = g.choose(escape,self.escapeString,lambda a: a)
    keys = list(theDict.keys())
    keys = [g.toUnicode(z) for z in keys]
    keys.sort()
    s = ''.join(['\t%s: %s,\n' % (esc(key),esc2(theDict.get(key))) for key in keys])
    if s: s = '\n' + s
    self.put('%s = {%s}\n\n' % (name,s))

def putDictOfLists (self,name,theDict,strings=False):

    esc = self.escapeString
    keys = list(theDict.keys())
    keys = [g.toUnicode(z) for z in keys]
    keys.sort()
    theList = []
    for key in keys:
        if strings:
            # Not completely general, but it works for the import dict, and that's good enough.
            s = ''.join(['"%s",' % (item) for item in theDict.get(key)])
        else:
             s = ''.join(['%s,' % (item) for item in theDict.get(key)])
        theList.append('\t%s: [%s],\n' % (esc(key),s))
    s = ''.join(theList)
    if s: s = '\n' + s
    self.put('%s = {%s}\n\n' % (name,s))
</t>
<t tx="ekr.20060824111500.125">def putImportDict (self):

    d = {}
    for ruleset in self.rulesets:
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        for rule in ruleset.rules:
            if rule.name == 'import':
                delegate = rule.getStrAttrib('delegate').lower()
                if delegate:
                    i = delegate.find('::')
                    delegate_name = g.choose(i==-1,
                        '%s::%s' % (prefix,delegate), # Can indeed happen.
                        '%s' % (delegate))
                    theList = d.get(prefix,[])
                    if delegate_name not in theList:
                        theList.append(delegate_name)
                        d [prefix] = theList

    self.put('# Import dict for %s mode.\n' % (self.modeName))
    self.putDictOfLists('importDict',d,strings=True)
</t>
<t tx="ekr.20060824111500.126">def putKeywordsData (self):

    dd = {}
    for ruleset in self.rulesets:
        prefix = '%s_%s' % (self.modeName,ruleset.name)
        prefix = g.toUnicode(prefix)
        ignore_case = ruleset.attributes.get('ignore_case','false')
        if type(ignore_case) != type(True): # Bug fix: 2013/08/03.
            ignore_case = ignore_case.lower() == 'false'
        self.put('# Keywords dict for %s ruleset.\n' % (prefix))
        for rule in ruleset.rules:
            if rule.name == 'keywords':
                d = rule.keywordsDict
                # g.trace([z for z in d.keys() if not g.isString(z)])
                for key in list(d.keys()):
                    key = g.toUnicode(key)
                    if not key.strip():
                        if key in d:
                            del d [key]
                    elif key.find(' ') != -1 or key.find('\t') != -1:
                        del d [key]
                        g.es_print('Warning: ignoring keyword containing whitespace: %s' % (
                            repr(key)))
                    elif ignore_case: # New in 4.4.1 final.
                        # Downcase all keys.
                        val = d.get(key)
                        val = g.toUnicode(val)
                        key2 = key.lower()
                        if key2 != key:
                            if key in d: del d[key]
                        d[key2] = val
                break
        else:
            d = {}
        self.putDict('%s_keywords_dict' % (prefix),d)
        dd [ prefix ] = '%s_keywords_dict' % (prefix)
    self.put('# Dictionary of keywords dictionaries for %s mode.\n' % (self.modeName))
    self.putDict('keywordsDictDict',dd,escape=False)
</t>
<t tx="ekr.20060824111500.127">def putList (self,name,theList,escape=True,lineCount=0):

    def comma(i):
        return ',' # return g.choose(i==len(theList)-1,'',',')
    def nl(i):
        return g.choose(lineCount == 0 or ((i%lineCount)==lineCount-1),'\n',' ')
    def tab(i,n):
        # return g.choose(i == 0 or nl(i-1) != ' ','\t','')
        return g.choose(i &gt; 0 and nl(i-1) != ' ','\t','')
    esc = g.choose(escape,self.escapeString,lambda a:a)

    result = []
    n = len(theList)
    for i in xrange(n):
        result.append('%s%s%s%s' % (tab(i,n),esc(theList[i]),comma(i),nl(i)))

    vals = ''.join(result)
    # if n &gt; 1: vals = '\n' + vals
    self.put('%s = [%s]\n\n' % (name,vals))
</t>
<t tx="ekr.20060824111500.128">def putModeProperties (self,language):

    d = {}

    self.put('# Properties for %s mode.\n' % (language))

    for prop in self.modeProperties:
        d2 = prop.attributes
        name = d2.get('name')
        d [name] = d2.get('value')

    self.putDict('properties', d)
</t>
<t tx="ekr.20060824111500.129">def putRule (self, rule):

    '''Call the rule creator for the given rule.'''

    d = {
        'eol_span':         self.putEolSpan,
        'eol_span_regexp':  self.putEolSpanRegexp,
        'import':           self.putImport,
        'keywords':         self.putKeywords,
        'mark_following':   self.putMarkFollowing,
        'mark_previous':    self.putMarkPrevious,
        'seq':              self.putSeq,
        'seq_regexp':       self.putSeqRegexp,
        'span':             self.putSpan,
        'span_regexp':      self.putSpanRegexp,
        'terminate':        self.putTerminate,
    }

    # Call the rule creator.
    f = d.get(rule.name,self.putBadRule)
    val = f (rule)
    self.handlerCount += 1

    return val
</t>
<t tx="ekr.20060824111500.130">def putBadRule (self,rule):

    self.put('\n\n# *****no output creator for %s*****' % rule.name)
</t>
<t tx="ekr.20060824111500.131">def putEolSpan (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_eol_span(s, i, kind=%s, seq=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]
</t>
<t tx="ekr.20060824111500.132">def putEolSpanRegexp (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)
    hash_char = rule.getStrAttrib('hash_char') or seq[0]
    # g.trace('hash_char',hash_char)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_eol_span_regexp(s, i, kind=%s, regexp=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return hash_char  # Bug fix: was seq[0]
</t>
<t tx="ekr.20060824111500.133"># Do nothing here: putImportDict creates x.importDict.

def putImport (self,rule):

    # Decrement the count to indicate that this method did not generate a rule.
    self.handlerCount -= 1
    return ''
</t>
<t tx="ekr.20060824111500.134">def putKeywords (self,rule):

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_keywords(s, i)''' % (
    self.fileModeName,
    self.handlerCount)

    self.putTripleString(s)
    return 'keywords'
</t>
<t tx="ekr.20060824111500.135">def putMarkFollowing (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_mark_following(s, i, kind=%s, pattern=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]
</t>
<t tx="ekr.20060824111500.136">def putMarkPrevious (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_mark_previous(s, i, kind=%s, pattern=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, exclude_match=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        rule.getBoolAttrib('exclude_match'),
    )

    self.putTripleString(s)
    return seq[0]
</t>
<t tx="ekr.20060824111500.137">def putSeq (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_seq(s, i, kind=%s, seq=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, delegate=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
    )

    self.putTripleString(s)
    return seq[0]
</t>
<t tx="ekr.20060824111500.138">def putSeqRegexp (self,rule):

    quote = self.quoteString
    seq = rule.getSeq(rule.name)
    hash_char = rule.getStrAttrib('hash_char') or seq[0]
    # g.trace('hash_char',hash_char)

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_seq_regexp(s, i, kind=%s, regexp=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s, delegate=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(seq),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
    )

    self.putTripleString(s)
    return hash_char # Bug fix: was seq[0]
</t>
<t tx="ekr.20060824111500.139">def putSpan (self,rule):

    quote = self.quoteString
    begin,end = rule.getSpan()

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_span(s, i, kind=%s, begin=%s, end=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s,exclude_match=%s,
        no_escape=%s, no_line_break=%s, no_word_break=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(begin),quote(end),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
        rule.getBoolAttrib('no_escape'),
        rule.getBoolAttrib('no_line_break'),
        rule.getBoolAttrib('no_word_break'),
    )

    self.putTripleString(s)
    return begin[0]
</t>
<t tx="ekr.20060824111500.140">def putSpanRegexp (self,rule):

    quote = self.quoteString
    begin,end = rule.getSpan()
    hash_char = rule.getStrAttrib('hash_char') or begin[0]

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_span_regexp(s, i, kind=%s, begin=%s, end=%s,
        at_line_start=%s, at_whitespace_end=%s, at_word_start=%s,
        delegate=%s,exclude_match=%s,
        no_escape=%s, no_line_break=%s, no_word_break=%s)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        quote(begin),quote(end),
        # quote(rule.getStrAttrib('hash_char')),
        rule.getBoolAttrib('at_line_start'),
        rule.getBoolAttrib('at_whitespace_end'),
        rule.getBoolAttrib('at_word_end'),
        quote(self.fullDelegate(rule.getStrAttrib('delegate'))),
        rule.getBoolAttrib('exclude_match'),
        rule.getBoolAttrib('no_escape'),
        rule.getBoolAttrib('no_line_break'),
        rule.getBoolAttrib('no_word_break'),
    )

    self.putTripleString(s)
    return hash_char # Bug fix: was begin[0]
</t>
<t tx="ekr.20060824111500.141">def putTerminate (self,rule):

    quote = self.quoteString

    n = rule.getIntAttrib('at_char')
    if n == None: return

    s = '''\n\
def %s_rule%d(colorer, s, i):
    return colorer.match_terminate(s, i, kind=%s, at_char=%d)''' % (
        self.fileModeName,
        self.handlerCount,
        quote(rule.getStrAttrib('type').lower()),
        n)

    self.putTripleString(s)
</t>
<t tx="ekr.20060824111500.142">def putRules (self):

    '''Create all rule matchers, a rules dict for each ruleset and x.rulesDictDict.'''

    d = {} ; d2Count = 0
    for ruleset in self.rulesets:
        d2 = {}
        start_count = self.handlerCount
        # prefix = '%s::%s' % (self.modeName,ruleset.name)
        prefix2 = '%s_%s_rules' % (self.modeName,ruleset.name)
        prefix3 = '%s_%s'% (self.modeName,ruleset.name)
        self.put('# Rules for %s ruleset.\n' % (prefix3))
        for rule in ruleset.rules:
            ch = self.putRule(rule)
            self.put('\n')
            if ch == 'keywords':
                for ch in self.keywordChars:
                    theList = d2.get(ch,[])
                    theList.append('%s_rule%d' % (self.fileModeName,self.handlerCount-1))
                    d2 [ch] = theList
            elif ch:
                theList = d2.get(ch,[])
                theList.append('%s_rule%d' % (self.fileModeName,self.handlerCount-1))
                d2 [ch] = theList
        # Create the rules dict for the ruleset.
        self.put('\n# Rules dict for %s ruleset.\n' % (prefix3))
        d2Count += 1 ; name = 'rulesDict%d' % d2Count
        self.putDictOfLists(name,d2)
        d [prefix3] = name
    # Create rulesDictDict.
    self.put('# x.rulesDictDict for %s mode.\n' % (self.modeName))
    self.putDict('rulesDictDict',d,escape=False)
</t>
<t tx="ekr.20060824111500.143">def write (self,theFile,language):

    # Compute all the letters that can occur in a keyword.
    self.keywordChars = [ch for ch in string.ascii_letters + string.digits + '@']
    for ruleset in self.rulesets:
        for rule in ruleset.rules:
            d = rule.keywordsDict
            for key in list(d.keys()):
                key = g.toUnicode(key)
                for ch in key:
                    if ch not in self.keywordChars and ch not in (' ','\t','\n'):
                        self.keywordChars.append(ch)
        
    # g.trace('keywordChars',repr(self.keywordChars))
    self.keywordChars = ''.join(self.keywordChars)
    

    self.outputFile = theFile
    self.put('# Leo colorizer control file for %s mode.\n' % language)
    self.put('# This file is in the public domain.\n\n')
    self.putModeProperties(language)
    self.putAttributes()
    self.putKeywordsData()
    self.putRules()
    self.putImportDict()
</t>
<t tx="ekr.20060824111500.144"></t>
<t tx="ekr.20060824111500.145">def printModeAttributes (self):

    self.printAttributesHelper('mode attributes',self.attributes)

def printRulesetAttributes (self,ruleset,tag=None):

    if not tag: tag = 'main ruleset'

    self.printAttributesHelper(tag,ruleset.attributes)

def printAttributesHelper (self,kind,attrs):

    print('%-15s' % (kind),'attrs:',attrs)
</t>
<t tx="ekr.20060824111500.146">def printProperty (self,theProperty):

    # A property is a bunch.
    d = theProperty.attributes
    if d:
        self.printAttributesHelper('property',d)
</t>
<t tx="ekr.20060824111500.147">def printRule (self,rule):

    # A rule is a g.Bunch.
    if rule.name == 'keywords':
        print('%-15s' % ('rule:keywords')) ## ,
        d = rule.keywordsDict
        d2 = {}
        for key in d:
            val = d.get(key)
            d2 [val] = d2.get(val,0) + 1
        keys = list(d2.keys())
        keys.sort()
        for key in keys:
            print('%s: %d' % (key,d2.get(key))) ## ,
        print()
    else:
        d = rule.attributes
        d2 = rule.contents
        if d or d2:
            print('%-15s' % ('rule:'+rule.name)) ## ,
            if d:  print('attrs:',d) ## ,
            if d2: print('contents:',d2) ## ,
            print()
</t>
<t tx="ekr.20060824111500.148">def printRuleset (self,ruleset,tag):

    self.printRulesetAttributes(ruleset,tag)

    for rule in self.rulesets[0].rules:
        self.printRule(rule)
</t>
<t tx="ekr.20060824111500.149">def printSummary (self,printStats=True):

    if printStats:
        print('-' * 10, 'mode statistics')
        print('elements',self.numberOfElements)
        print('errors',self.numberOfErrors)
        print('mode attributes',self.numberOfAttributes)
        print('property attributes',self.numberOfPropertyAttributes)
        print('rule attributes',self.numberOfRuleAttributes)

    self.printModeAttributes()

    for bunch in self.modeProperties:
        self.printProperty(bunch)

    self.printRuleset(self.rulesets[0],tag='main ruleset')
</t>
<t tx="ekr.20060824111500.150">def doAttribute (self,name,val):

    name = str(name.lower())

    if name in self.boolAttrs:
        val = g.choose(val.lower()=='true',True,False)
    else:
        val = str(val) # Do NOT lower this value!

    if self.rule:
        d = self.rule.attributes
        d [name] = val
        self.numberOfRuleAttributes += 1
    elif self.presentProperty:
        d = self.presentProperty.get('attributes')
        d [name] = val
        self.numberOfPropertyAttributes += 1
    elif self.inRules:
        self.rulesetAttributes[name] = val
        self.numberOfAttributes += 1
    else:
        self.attributes[name] = val
        self.numberOfAttributes += 1
</t>
<t tx="ekr.20060824111500.151">def doContent (self,elementName,content):

    if not content:
        return

    name = str(elementName.lower())

    if self.inRule('keywords'):
        # g.trace('in keywords',name,content)
        d = self.rule.keywordsDict
        d [ content ] = name

    elif self.rule:
        d = self.rule.contents
        s = d.get(name,'')
        d [name] = s + g.toUnicode(content)
        self.contents = d
</t>
<t tx="ekr.20060824111500.152">def endElement (self,elementName):

    name = elementName.lower()

    if name == 'props':
        self.inProps = True
    if name == 'rules':
        self.inRules = False
        ruleset = rulesetClass(self.rulesetAttributes,self.keywords,self.rulesetProperties,self.rules)
        self.rulesets.append(ruleset)
        #g.trace('rules...\n',g.listToString(self.rules))
        #g.trace('ruleset attributes...\n',g.dictToString(self.rulesetAttributes))
    if name == 'property':
        bunch = self.presentProperty
        if bunch:
            if self.inRules:
                self.rulesetProperties.append(bunch)
            else:
                self.modeProperties.append(bunch)
        else:
            self.error('end %s not matched by start %s' % (name,name))
        self.presentProperty = None
    if name in self.ruleElements:
        if self.inRule(name):
            self.rules.append(self.rule)
            self.rule = None
        else:
            self.error('end %s not matched by start %s' % (name,name))
</t>
<t tx="ekr.20060824111500.153">def error (self,message):

    self.numberOfErrors += 1

    self.contentHandler.error(message)
</t>
<t tx="ekr.20060824111500.154">def getAttributes (self):
    return self.attributes

def getAttributesForRuleset (self,ruleset):
    bunch = ruleset
    return bunch.attributes

def getFileName (self):
    return self.fileName

def getKeywords (self,n,ruleset):
    bunch = ruleset
    keywords = bunch.keywords
    if keywords:
        return keywords.get('keyword%d'%(n),[])
    return []

def getLanguage (self):
    path,name = g.os_path_split(self.fileName)
    language,ext = g.os_path_splitext(name)
    return language

def getPropertiesForMode (self):
    return self.props

def getPropertiesForRuleset (self,name=''):
    bunch = self.getRuleset(name)
    if bunch:
        return bunch.properties
    else:
        return []

def getRuleset(self,name=''):
    if not name:
        return self.rulesets[0] # Return the main ruleset.
    for ruleset in self.rulesets:
        if ruleset.name.lower()==name.lower():
            return ruleset
    else: return None

def getRulesets(self):
    return self.rulesets

def getRulesForRuleset (self,name=''):
    bunch = self.getRuleset(name)
    if bunch:
        return bunch.rules
    else:
        return []
</t>
<t tx="ekr.20060824111500.155">def inRule (self,elementName):

    return self.rule and self.rule.name == elementName
</t>
<t tx="ekr.20060824111500.156">def startElement (self,elementName):

    name = elementName.lower()

    if name == 'props':
        self.inProps = True
    if name == 'rules':
        self.inRules = True
        self.attributes=[]
        self.keywords=[]
        self.rulesetProperties=[]
        self.rules=[]
    if name == 'property':
        if self.inProps:
            self.presentProperty = g.bunch(name=name,attributes={})
        else:
            self.error('property not in props element')
    if name in self.ruleElements:
        if self.inRules:
            self.rule = ruleClass(name=name)
            if name == 'keywords':
                self.keywords = self.rule
        else:
            self.error('%s not in rules element' % name)
</t>
<t tx="ekr.20060824111500.157">class rulesetClass:

    @others
</t>
<t tx="ekr.20060824111500.158">def __init__ (self,attributes,keywords,properties,rules):

    self.name=munge(attributes.get('set','main'))
    self.attributes=attributes.copy() # A dict.
    self.properties=properties[:] # A list.
    self.keywords=keywords # A bunch.
    self.rules=rules[:] # A list.

    # g.trace('ruleset',self.name or 'main')

    self.defaultColor = self.attributes.get('default')

def __str__ (self):

    return '&lt;ruleset %s&gt;' % self.name

__repr__ = __str__
</t>
<t tx="ekr.20060824111500.159">class ruleClass:

    '''A class to represent one xml rule.'''

    @others
</t>
<t tx="ekr.20060824111500.160">def __init__ (self,name):

    self.attributes = {}
    self.contents = {}
    self.keywordsDict = {}
    self.name = name

def __str__ (self):

    return '&lt;rule %s\nattr: %s\ncontents: %s&gt;' % (
        self.name,g.dictToString(self.attributes),g.dictToString(self.contents))

__repr__ = __str__
</t>
<t tx="ekr.20060824111500.161">def getBoolAttrib(self,name):
    d = self.attributes
    val = d.get(name)
    return g.choose(val,'True','False')

def getIntAttrib(self,name):
    d = self.attributes
    val = d.get(name)
    if val is not None:
        try:
            val = int(val)
        except ValueError:
            g.trace('bad int argument: %s = %s' % (name,val))
            val = None
    return val

def getSpan (self):
    d = self.contents
    begin = d.get('begin','')
    end   = d.get('end','')
    return begin,end

def getStrAttrib(self,name):
    d = self.attributes
    val = d.get(name,'')
    return str(val)

def getSeq(self,kind):
    # g.trace(repr(self.contents))
    d = self.contents
    return d.get(kind,'')
</t>
<t tx="ekr.20060824111500.162">class contentHandler (xml.sax.saxutils.XMLGenerator):

    '''A sax content handler class that handles jEdit language-description files.

    Creates mode that can be retrieved using the getMode method.'''

    @others
</t>
<t tx="ekr.20060824111500.163">def __init__ (self,c,inputFileName,language):

    self.c = c
    self.inputFileName = inputFileName
    self.language = language

    # Init the base class.
    xml.sax.saxutils.XMLGenerator.__init__(self)

    # Non-mode statistics.
    self.numberOfAttributes = 0
    self.numberOfElements = 0

    # Options...
    self.ignoreWs = True # True: don't print contents with only ws.
    self.newLineAfterStartElement = [
        'keywords','mode','props','property','rules','span','eol_span',
        # 'seq',
    ]

    # Printing options
    if opt_print_elements:
        self.printAllElements = True
        self.printCharacters = False or self.printAllElements
        self.printAttributes = False and not self.printAllElements
        self.printElements = [
            #'begin','end',
            #'eol_span',
            #'keyword1','keyword2','keyword3','keyword4',
            #'mark_previous',
            #'mode',
            #'props',
            #'property',
            #'rules',
            #'span',
            #'seq',
        ]

        if self.printAllElements:
            self.suppressContent = []
        else:
            self.suppressContent = ['keyword1','keyword2','keyword3','keyword4']
    else:
        self.printAllElements = False
        self.printCharacters = False
        self.printAttributes = False
        self.printElements = []

    # Semantics: most of these should be mode ivars.
    self.elementStack = []
    self.errors = 0
    self.mode = None # The present mode, or None if outside all modes.
    self.modes = [] # All modes defined here or by imports.
</t>
<t tx="ekr.20060824111500.164"></t>
<t tx="ekr.20060824111500.165">def attrsToList (self,attrs):

    '''Convert the attributes to a list of g.Bunches.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    return [
        g.Bunch(name=name,val=attrs.getValue(name))
        for name in attrs.getNames()
    ]
</t>
<t tx="ekr.20060824111500.166">def attrsToString (self,attrs,sep='\n'):

    '''Convert the attributes to a string.

    attrs: an Attributes item passed to startElement.

    sep: the separator charater between attributes.'''

    result = [
        '%s="%s"' % (bunch.name,bunch.val)
        for bunch in self.attrsToList(attrs)
    ]

    return sep.join(result)
</t>
<t tx="ekr.20060824111500.167">def clean(self,s):

    return g.toEncodedString(s,"ascii")
</t>
<t tx="ekr.20060824111500.168">def error (self, message):

    print()
    print()
    print('XML error: %s' % (message))
    print()

    self.errors += 1
</t>
<t tx="ekr.20060824111500.169">def printStartElement(self,name,attrs):

    if attrs.getLength() &gt; 0:
        print('&lt;%s %s&gt;' % (
            self.clean(name).strip(),
            self.attrsToString(attrs,sep=' '))) ## ,
    else:
        print('&lt;%s&gt;' % (self.clean(name).strip())) ## ,

    if name.lower() in self.newLineAfterStartElement:
        print()
</t>
<t tx="ekr.20060824111500.170">def printSummary (self):

    print('Summary...')
    print('-' * 10, 'non- mode statistics')
    print('modes',len(self.modes))
    print('elements', self.numberOfElements)
</t>
<t tx="ekr.20060824111500.171"></t>
<t tx="ekr.20060824111500.172"></t>
<t tx="ekr.20060824111500.173">def ignorableWhitespace(self):
    g.trace()

def processingInstruction (self,target,data):
    g.trace()

def skippedEntity(self,name):
    g.trace(name)

def startElementNS(self,name,qname,attrs):
    g.trace(name)

def endElementNS(self,name,qname):
    g.trace(name)
</t>
<t tx="ekr.20060824111500.174">def endDocument(self):

    pass


</t>
<t tx="ekr.20060824111500.175">def startDocument(self):

    pass
</t>
<t tx="ekr.20060824111500.176">def characters(self,content):

    # content = content.replace('\r','').strip()
    content = content.replace('\r','')
    if content.strip(): content = content.strip()
    content = self.clean(content)

    elementName = self.elementStack and self.elementStack[-1].lower() or '&lt;no element name&gt;'

    if self.printAllElements:
        print(content) ## ,
    elif self.printCharacters and content and elementName not in self.suppressContent:
        print('content:',elementName,repr(content))

    if self.mode:
        self.mode.doContent(elementName,content)
    else:
        self.error('characters outside of mode')
</t>
<t tx="ekr.20060824111500.177">def endElement(self,name):

    self.doEndElement(name)

    name2 = self.elementStack.pop()
    assert name == name2
</t>
<t tx="ekr.20060824111500.178">def startElement(self,name,attrs):

    if self.mode:
        self.mode.numberOfElements += 1
    else:
        self.numberOfElements += 1

    self.elementStack.append(name)
    self.doStartElement(name,attrs)
</t>
<t tx="ekr.20060824111500.179">def doStartElement (self,elementName,attrs):

    if self.printAllElements or elementName.lower() in self.printElements:
        self.printStartElement(elementName,attrs)

    elementName = elementName.lower()

    if elementName == 'mode':
        if self.mode:
            self.error('Multiple modes')
        else:
            self.mode = modeClass(self,self.inputFileName)
    elif self.mode:
        self.mode.startElement(elementName)
        for bunch in self.attrsToList(attrs):
            if self.printAttributes:
                print('attr:',elementName,bunch.name,'=',bunch.val)
            self.mode.doAttribute(bunch.name,bunch.val)
    else:
        self.error('Start element appears outside of Mode:%s' % elementName)
        for bunch in self.attrsToList(attrs):
            self.error('Attribute appears outside of Mode:%s' % bunch.name)
</t>
<t tx="ekr.20060824111500.180">def doEndElement (self,elementName):

    if self.printAllElements or elementName.lower() in self.printElements:
        print('&lt;/' + self.clean(elementName).strip() + '&gt;')

    if elementName.lower() == 'mode':
        if opt_print_summary: self.mode.printSummary()
    elif self.mode:
        self.mode.endElement(elementName)
    else:
        self.error('End element appears outside of Mode:%s' % elementName)
        for bunch in self.attrsToList(attrs):
            self.error('Attribute appears outside of Mode:%s' %bunch.name)
</t>
<t tx="ekr.20060824111500.181">def getMode (self):

    if self.errors:
        return None
    else:
        return self.mode
</t>
<t tx="ekr.20060827162343">def fullDelegate (self,delegate):

    if delegate:
        delegate = delegate.lower()
        i = delegate.find('::')
        if i == -1:
            return '%s::%s' % (self.fileModeName.lower(),delegate)
        else:
            return delegate
    else:
        return ''
</t>
<t tx="ekr.20061008055616"></t>
<t tx="ekr.20070427110751"></t>
<t tx="ekr.20070615131954"></t>
<t tx="ekr.20111017085134.16069"></t>
<t tx="ekr.20111017085134.16070"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.h
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20111017085134.16071">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20111017085134.16072"># This works, but is too slow to be really useful.

count = 0
for p in c.all_unique_positions():
    if p.isDirty():
        c.checkPythonNode (p,suppressErrors=False)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20111017085134.16073">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20111017085134.16074"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20111017085134.16075">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16076"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20111017085134.16077">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16078">'''Analyze external calls in lisp files.'''

import glob
class lispAnalyzer:
    @others

base = '/media/disk/XEmacs/XEmacs-21.4.13/lisp/*.el'
paths = glob.glob(base)
# g.es(g.listToString(paths))
paths = [paths[0]]

x = lispAnalyzer(c,paths)
x.run()</t>
<t tx="ekr.20111017085134.16079">def __init__ (self,c,paths):

    self.c = c
    self.paths = paths

    # Debugging.
    self.debug = True
    self.trace = False

    # Semantic info.
    self.def_keywords = ('defun','defvar',)
    self.indent_keywords = ('if','prog','prog1','progn','set',)
    self.expr_keywords = ('and','not','or',)

    self.indent = 0 # Indentation of production output.

    # Dispatch dictionary.
    self.dispatchDict = {}</t>
<t tx="ekr.20111017085134.16080">def run(self):

    fn = self.paths[0]
    f = open(fn)
    s = f.read()
    g.es_print(fn)
    # g.trace(s)
    s = self.stripStrings(s)
    s = self.stripComments(s)
    defs = self.findDefs(s)
    calls = self.findCalls(s,defs)
    calls = self.stripLispIds(calls)
    defs.sort()
    calls.sort()
    g.trace('defs...\n',g.listToString(defs))
    g.trace('calls...\n',g.listToString(calls))
</t>
<t tx="ekr.20111017085134.16081">def findCalls (self,s,defs):

    calls = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            theId = s[i:j].strip()
            if theId not in defs and theId not in calls:
                calls.append(theId)
            i = j
        else: i += 1
        assert progress &lt; i

    return calls       
</t>
<t tx="ekr.20111017085134.16082">def findDefs (self,s):

    defs = [] ; tag = '(defun'
    i = 0
    while True:
        progress = i
        j = s.find(tag,i)
        if j == -1:
            return defs
        i = j + len(tag)
        j = g.skip_ws(s,i)
        if j &gt; i:
            k = self.skipId(s,j)
            if k &gt; j:
                defs.append(s[j:k])
            i = k
        assert progress &lt; i 
</t>
<t tx="ekr.20111017085134.16083">def stripComments(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == ';':
            i = self.skipComment(s,i)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16084">def stripLispIds (self,aList):

    lispIds = [
        't','f',
        'apply',
        'boundp',
        'car','cons','cdr','consp',
        'eq','equal','eval',
        'lamda','lambda',
        'macro',
        'nil','not','null','numberp',
        'or',
        'unless',
        'vector','vectorp',
        # special forms
        'and',
        'catch',
        'cond',
        'condition-case',
        'defconst',
        'defmacro',
        'defun',
        'defvar',
        'function',
        'if',
        'interactive',
        'let',
        'let*',
        'or',
        'prog1',
        'prog2',
        'progn',
        'quote',
        'save-current-buffer',
        'save-excursion',
        'save-restriction',
        'save-window-excursion',
        'setq',
        'setq-default',
        'track-mouse',
        'unwind-protect',
        'while',
        'with-output-to-temp-buffer',
    ]

    return [z for z in aList if z not in lispIds]</t>
<t tx="ekr.20111017085134.16085">def stripStrings(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == '"':
            i = self.skipString(s,i)
        elif ch == "'":
            i = self.skipId(s,i+1)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16086">class token:

    '''Representing one elisp syntactic entity,
    with a list of preceding comments.'''

    def __init__ (self,comments,kind,val):
        self.comments = comments[:]
        self.kind = kind
        self.val = val
            # For blocks, a list of tokens.
            # For all other tokens, the spelling of the token.

    def __repr__ (self):
        return '&lt;token kind: %s, val: %s&gt;' % (self.kind,self.val)

    def __str__ (self):
        if self.kind == 'block:':
            return 'block: [snip]'
        elif self.kind == 'string:':
            return '%s%s' % (self.kind,self.val[:20])
        else:
            return '%s%s' % (self.kind,self.val)
</t>
<t tx="ekr.20111017085134.16087">def choose(self,cond,a,b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20111017085134.16088">def dumpList(self,aList):

    if type(aList) == type([]):
        result = self.dumpListHelper(aList,indent=0)
        return '\n'.join(result)
    else:
        return repr(aList)

def dumpListHelper(self,aList,indent):

    result = []
    leading = ' ' * (4 * indent)

    for z in aList:
        if z is None:
            result.append('%s%s' % (leading,'None'))
        elif z == []:
            result.append('%s%s' % (leading,'[]'))
        elif type(z) == type([]):
            result.append('%s%s' % (leading,'['))
            result.extend(self.dumpListHelper(z,indent+1))
            result.append('%s%s' % (leading,']'))
        elif isinstance(z,self.token):
            if z.kind=='block:':
                result.append('%s%s' % (leading,'block:'))
                result.extend(self.dumpListHelper(z.val,indent+1))
                # result.append('%s%s' % (leading,'block:]'))
            else:
                result.append('%s%s' % (leading,str(z)))
        else:
            result.append('%s%s' % (leading,str(z)))

    return result

listToString = dumpList</t>
<t tx="ekr.20111017085134.16089"></t>
<t tx="ekr.20111017085134.16090">def parse(self,s):

    # Generate the nodes, including directive and section references.
    return self.scanForest(s)
</t>
<t tx="ekr.20111017085134.16091">def scan(self,s,i):

    '''Scan an elisp expression.'''

    start = i ; end = len(s) ; result = []
    comments = [] ; token = self.token
    # A hack. ignore initial @language lisp
    tag = '@language lisp'
    if i == 0 and s[i:i+len(tag)]==tag:
        i += len(tag)
    while i &lt; end:
        progress = i
        ch = s[i]
        if ch == ';':
            j = self.skipComment(s,i)
            start = i = j
        elif ch == '"':
            j = self.skipString(s,i)
            start = i = j
        elif ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            result.append(token(comments,'id:',s[i:j]))
            start = i = j
        elif ch =='(':
            i += 1
            j,aList = self.scan(s,i)
            result.append(token(comments,'block:',aList))
            start = i = j
        elif ch == ')':
            i += 1
            return i,result
        else:
            # if ch == "'": ch = 'quote'
            # if ch not in (' ','\t','\n','\r'):
                # result.append(token(comments,'op:',ch))
            i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if start &lt; end:
        tail = s[start:end].strip()
        if tail:
            result.append(token(comments,'tail:',tail))
            comment = []
    if comments:
        result.append(token(comments,'trailing-comment:',''))

    return i,result
</t>
<t tx="ekr.20111017085134.16092">def skipComment (self,s,i):

    '''Skip a comment.'''

    while i &lt; len(s):
        if s[i] == '\n':
            break
        i += 1
    return i
</t>
<t tx="ekr.20111017085134.16093">def skipId (self,s,i):

    while i &lt; len(s):
        ch = s[i]
        if ch.isalnum() or ch in ('_','-'):
            i += 1
        else:
            break
    return i
</t>
<t tx="ekr.20111017085134.16094">def skipString(self,s,i):

    """Skip a string literal."""

    assert(s[i] == '"')
    i += 1
    while i &lt; len(s):
        ch = s[i]
        if ch == '\\' : i += 2
        elif ch == '"':
            i += 1 ; break
        else: i += 1

    return i</t>
<t tx="ekr.20111017085134.16095">def scanForest (self,s):

    i = 0 ; result = []

    while i &lt; len(s):
        progress = i
        i,aList = self.scan(s,i)
        aList and result.extend(aList)
        assert i &gt; progress

    return result


</t>
<t tx="ekr.20111017085134.16096">@ From Richard Deibenkorn:

1. Attempt what is not certain. Certainty may or may not come later. It may then
be a valuable delusion.

2. The pretty, initial position which falls short of completeness is not to be
valued--except as stimulus for further moves.

3. Do search.  But in order to find other than what is looked for.

4. Use and respond to the initial fresh qualities but consider them absolutely
expendable.
</t>
<t tx="ekr.20111017085134.16097">def gen(self,tokens,indent,init=False):

    result = []

    if init: result.append('='*40)

    for token in tokens:
        aList = self.gen_token(token,indent)
        result.extend(aList)

    if init: result.append('-'*40)

    return result

</t>
<t tx="ekr.20111017085134.16098">def gen_token(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            self.gen_block(token,indent)
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16099">def gen_block (self,token,indent):

    if not (token and token.val):
        return []

    blockList = token.val
    token2 = blockList[0]
    result = []

    if token2.kind.startswith('id'):
        aList = self.gen_block_id(token2.val,blockList,indent)
    else:
        if self.debug:
            self.put('block...',[],indent,result)
        aList = self.gen(token.val,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16100">def gen_block_id (self,theId,tokens,indent):

    result = []

    # Eventually there will be a lookup of the dispatch dict here.
    if theId == 'let':
        aList = self.gen_let(tokens,indent)
    elif theId == 'if':
        aList = self.gen_if(tokens,indent)
    elif theId in self.def_keywords:
        aList = self.gen_def(theId,tokens,indent)
    elif theId in self.indent_keywords:
        self.put('%s...' % (theId),[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
    elif theId in self.expr_keywords:
        aList = self.gen_expr(theId,tokens[1:],indent+1)
    else:
        aList = self.gen_call(theId,tokens[1:],indent)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16101">def gen_call (self,funcId,tokens,indent):

    result = []

    if self.debug:
        self.put('call: %s' % (funcId),[],indent,result)
        for token in tokens:
            aList = self.gen_arg(token,indent+1)
            result.extend(aList)
    else:
        self.put_code_line('%s(' % (funcId))
        for token in tokens:
            self.gen_arg(token,indent+1)
        self.put_code(')')

    return result

</t>
<t tx="ekr.20111017085134.16102">def gen_arg(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            self.put('arg block:...',[],indent,result)
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            self.put_code(''.join(aList))
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16103">def gen_def(self,theId,tokens,indent):

    result = []

    if not tokens or len(tokens) &lt; 3:
        result.append('*** bad def tokens')
        return result

    defToken,idToken = tokens[0:2]
    if idToken.kind != 'id:':
        result.append('*** bad def id')
        return result

    if self.debug:
        self.put(theId,idToken.val,indent,result)
        aList = self.gen(tokens[2:],indent+1)
        result.extend(aList)
    else:
        self.put_code('def %s (' % idToken.val)
        self.gen_token(tokens[2],indent)
        self.put_code('): # end def\n')
        self.indent += 1
        self.gen(tokens[3:],indent+1)
        self.indent -= 1

    return result
</t>
<t tx="ekr.20111017085134.16104">@ if condition then-form else-forms.

If the evaluated condition is non-nil, then-form is evaluated and the result
returned. Otherwise, the else-forms are evaluated in textual order, and the
value of the last one is returned. If condition has the value nil, and no
else-forms are given, if returns nil.
@c

def gen_if (self,tokens,indent):

    # tokens[0]: id:if
    # tokens[1] cond

    for i in xrange(len(tokens)):
        g.trace('tokens[%d]: %s' % (i,self.dumpList(tokens[i])))

    # g.trace(self.dumpList(tokens))

    result = []

    if self.debug:
        self.put('if...',[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
        result.extend(aList)
    else:
        self.put_code('if ')
        self.gen(tokens[1:],indent+1)
        self.put_code(': # end if\n')

    return result
</t>
<t tx="ekr.20111017085134.16105">def gen_then (self,token):

    pass
</t>
<t tx="ekr.20111017085134.16106">def gen_expr (self,theId,aList,indent):

    binops = ('and','or',)
    result = []

    self.put(theId,[],indent,result)
    aList = self.gen(aList,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16107">@
(let ((variable value)
      (variable value)
      ...)
  body...)
@c

def gen_let (self,tokens,indent):

    if not tokens: return []
    if len(tokens) != 3:
        g.trace('unusual let')
        result = self.gen(tokens,indent+1)
        return result

    if 0:
        for i in xrange(len(tokens)):
            g.trace('token',i,tokens[i])

    letToken,bindingToken,bodyToken = tokens
    result = []
    self.put('let...',[],indent,result)
    self.put('let-bindings...',[],indent+1,result)
    aList = self.gen_let_bindings(bindingToken,indent+2)
    result.extend(aList)
    self.put('let-block...',[],indent+1,result)
    aList = self.gen_block(bodyToken,indent+2)
    result.extend(aList)
    return result</t>
<t tx="ekr.20111017085134.16108">def gen_let_bindings (self,token,indent):

    result = []

    if token.kind != 'block:':
        g.trace('unexpected let')
        return result

    for z in token.val:
        if z.kind == 'block:': # one (id,val) pair
            if z.val and len(z.val) == 2:
                token1 = z.val[0]
                token2 = z.val[1]
                self.put('let-id',token1,indent,result)
                self.put('let-val...',[],indent,result)
                if token2.kind == 'block:':
                    aList = self.gen_block(token2,indent+1)
                    result.extend(aList)
                else:
                    #g.trace('no let list')
                    self.put_token(token2,indent+1,result)
            else:
                g.trace('unexpected let 2')

    return result
</t>
<t tx="ekr.20111017085134.16109"></t>
<t tx="ekr.20111017085134.16110">def put (self,kind,val,indent,result):

    '''Append one or more lines of output to result.'''

    leading = '%2d: %s' % (indent,' ' * indent)

    if kind == 'string:':
        val = self.choose(len(val)&gt;20,val[:20]+'..."',val)

    if val:
        s = '%s%s %s' % (leading,str(kind),str(val))
    else:
        s = '%s%s' % (leading,str(kind))

    result.append(s)
</t>
<t tx="ekr.20111017085134.16111">def put_token (self,token,indent,result):

    for z in token.comments:
        self.put('comment:',z,indent,result)

    self.put(token.kind,token.val,indent,result)
</t>
<t tx="ekr.20111017085134.16112">def put_code_line (self,s):

    s2 = '%s%s' % (' '*self.indent,s)
    print s2,

def put_code (self,s):

    print s,
</t>
<t tx="ekr.20111017085134.16113">def put_code_token (self,token):

    if token.kind == 'block:':
        self.put_code('&lt;block&gt;')
    else:
        self.put_code(token.val)

</t>
<t tx="ekr.20111017085134.16114">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20121013084734.16370">'''Recursively import all python files in a directory and clean the result.'''

# Latest change: do some fixups for languages other than python.

import os
import time

use_at_edit = False # True: create @edit nodes
safe_at_file = True # True: create @@file nodes instead of @file nodes.
oneFile = False # True: only import one file.

if 1:
    theTypes = ('.ts',)
    dir_ = r'C:\prog\typescript-fe3bc0bfce1f\src\compiler'
else:
    theTypes = ('.py',)
    dir_ = r'C:\Python26\Lib\site-packages\rope'

@others

# g.cls()

if g.os_path_exists(dir_):
    # Import all files in dir_ after c.p.
    try:
        ImportController().run(c,p,dir_,theTypes,
            oneFile=oneFile,recursive=not oneFile)
    finally:
        c.redraw()
else:
    print('Does not exist: %s' % (dir_))
</t>
<t tx="ekr.20121013084734.16371">class ImportController():
    
    # There is no ctor.

    @others
</t>
<t tx="ekr.20121013084734.16372">def import_dir(self,c,root,dir_,theTypes,oneFile=False,recursive=True):

    g.es("dir: " + dir_,color="blue")
    dirs,files,files2 = [],os.listdir(dir_),[]
    for f in files:
        path = g.os_path_join(dir_,f)
        if g.os_path_isfile(path):
            name, ext = g.os_path_splitext(f)
            if not theTypes or ext in theTypes:
                files2.append(path)
        elif recursive:
            dirs.append(path)
    if files2 or dirs:
        child = root.insertAsLastChild()
        child.h = dir_
        c.selectPosition(child,enableRedrawFlag=False)
    if files2:
        if oneFile: files2 = [files2[0]]
        if use_at_edit:
            for fn in files2:
                parent = child or root
                p = parent.insertAsLastChild()
                p.h = fn.replace('\\','/')
                s,e = g.readFileIntoString(fn,encoding='utf-8',kind='@edit')
                p.b = s
        else:
            c.importCommands.importFilesCommand(files2,'@file',redrawFlag=False)
                # '@auto' causes problems.
    if dirs:
        for dir_ in sorted(dirs):
            prefix = dir_
            self.import_dir(c,child,dir_,theTypes)
</t>
<t tx="ekr.20121013084734.16373">def clean_all (self,c,p):
    
    for p in p.self_and_subtree():
        h = p.h
        if h.startswith('@file') or h.startswith('@@file'):
            i = 6 if h[1] == '@' else 5
            path = h[i:].strip()
            junk,ext = g.os_path_splitext(path)
            self.clean(c,p,ext)
</t>
<t tx="ekr.20121013084734.16374">def clean(self,c,p,ext):
    
    '''
    - Move a shebang line from the first child to the root.
    - Move a leading docstring in the first child to the root.
    - Use a section reference for declarations.
    - Remove leading and trailing blank lines from all nodes.
    - Merge a node containing nothing but comments with the next node.
    - Merge a node containing no class or def lines with the previous node.
    '''

    root = p.copy()
    for tag in ('@@file','@file'):
        if p.h.startswith(tag):
            p.h = p.h[len(tag):].strip()
            break
            
    self.move_shebang_line(c,root)
    self.move_doc_string(c,root)
    self.rename_decls(c,root)

    for p in root.self_and_subtree():
        self.clean_blank_lines(c,p)
        
    # Get the single-line comment delim.
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        delim,junk,junk = g.set_delims_from_language(language)
    else:
        delim = None
        
    # g.trace('ext: %s language: %s delim: %s' % (ext,language,delim))
        
    if delim:
        # Do general language-dependent cleanups.
        for p in root.subtree():
            self.merge_comment_nodes(c,p,delim)
    if ext == 'py':
        # Do python only cleanups.
        for p in root.subtree():
            self.merge_extra_nodes(c,p)
        for p in root.subtree():
            self.move_decorator_lines(c,p)
</t>
<t tx="ekr.20121013084734.16375">def clean_blank_lines(self,c,p):
    
    '''Remove leading and trailing blank lines from all nodes.
    '''
    
    s = p.b
    if not s.strip():
        return
    
    result = g.splitLines(s)
    for i in 0,-1:
        while result:
            if result[i].strip():
                break
            else:
                del result[i]
        
    s = ''.join(result)
    if not s.endswith('\n'): s = s + '\n'
    if s != p.b:
        p.b = s
</t>
<t tx="ekr.20121013084734.16376">def merge_comment_nodes(self,c,p,delim):
    
    '''Merge a node containing nothing but comments with the next node.'''
    
    if not p.hasChildren() and p.hasNext() and p.h.strip().startswith(delim):
        p2 = p.next()
        b = p.b.lstrip()
        b = b + ('\n' if b.endswith('\n') else '\n\n')
        p2.b = b + p2.b
        p.doDelete(p2)
        # g.trace(p2.h)
</t>
<t tx="ekr.20121013084734.16377">def merge_extra_nodes(self,c,p):
    
    '''Merge a node containing no class or def lines with the previous node'''
    
    s = p.b
    if p.hasChildren() or p.h.strip().startswith('&lt;&lt;') or not s.strip():
        return
        
    for s2 in g.splitLines(s):
        if s2.strip().startswith('class') or s2.strip().startswith('def'):
            return

    p2 = p.back()
    if p2:
        nl = '\n' if s.endswith('\n') else '\n\n'
        p2.b = p2.b + nl + s
        h = p.h
        p.doDelete(p2)
</t>
<t tx="ekr.20121013084734.16378">def move_decorator_lines (self,c,p):
    
    '''Move trailing decorator lines to the next node.'''
    
    trace = False
    p2 = p.next()
    if not p2: return False
    
    lines = g.splitLines(p.b)
    n = len(lines) -1
    while n &gt;= 0:
        s = lines[n]
        if s.startswith('@'):
            i = g.skip_id(s,1,chars='-')
            word = s[1:i]
            if word in g.globalDirectiveList:
                break
            else:
                n -= 1
        else:
            break
        
    head = ''.join(lines[:n+1])
    tail = ''.join(lines[n+1:])
    if not tail: return False

    assert head.endswith('\n')
    assert p.b == head+tail
    
    if trace:
        if tail not in seen:
            seen.append(tail)
            g.trace(tail.strip())
    
    if 1:
        nl = '' if tail.endswith('\n') else '\n'
        p.b = head
        p2.b = tail+nl+p2.b
        
    return True
</t>
<t tx="ekr.20121013084734.16379">def move_doc_string(self,c,root):

    '''Move a leading docstring in the first child to the root node.'''
    
    # To do: copy comments before docstring
    
    p = root.firstChild()
    s = p and p.b or ''
    if not s: return
    
    # if root.h.endswith('pgen.py'):
        # g.pdb()

    result = []
    for s2 in g.splitLines(s):
        delim = None
        s3 = s2.strip()
        if not s3:
            result.append(s2)
        elif s3.startswith('#'):
            result.append(s2)
        elif s3.startswith('"""'):
            delim = '"""'
            break
        elif s3.startswith("'''"):
            delim = "'''"
            break
        else:
            break
       
    if not delim:
        comments = ''.join(result)
        if comments:
            nl = '\n\n' if root.b.strip() else ''
            if root.b.startswith('@first #!'):
                lines = g.splitLines(root.b)
                root.b = lines[0] + '\n' + comments + nl + ''.join(lines[1:])
            else:
                root.b = comments + nl + root.b
            p.b = s[len(comments):]
        return

    i = s.find(delim)
    assert i &gt; -1
    i = s.find(delim,i+3)
    if i == -1:
        return
        
    doc = s[:i+3]
    p.b = s[i+3:].lstrip()
    
    # Move docstring to front of root.b, but after any shebang line.
    nl = '\n\n' if root.b.strip() else ''
    if root.b.startswith('@first #!'):
        lines = g.splitLines(root.b)
        root.b = lines[0] + '\n' + doc + nl + ''.join(lines[1:])
    else:
        root.b = doc + nl + root.b
</t>
<t tx="ekr.20121013084734.16380">def move_shebang_line (self,c,root):
    
    '''Move a shebang line from the first child to the root.'''
    
    p = root.firstChild()
    s = p and p.b or ''
    if s.startswith('#!'):
        lines = g.splitLines(s)
        nl = '\n\n' if root.b.strip() else ''
        root.b = '@first ' + lines[0] + nl + root.b
        p.b = ''.join(lines[1:])
</t>
<t tx="ekr.20121013084734.16381">def rename_decls (self,c,root):
    
    '''Use a section reference for declarations.'''
    
    p = root.firstChild()
    h = p and p.h or ''
    
    tag = 'declarations'
    if not h.endswith(tag):
        return
        
    if not p.b.strip():
        return # The blank node will be deleted.

    name = h[:-len(tag)].strip()
    decls = g.angleBrackets(tag)
    p.h = '%s (%s)' % (decls,name)
    
    i = root.b.find('@others')
    if i == -1:
        g.trace('can not happen')
        return
    else:
        nl = '' if i == 0 else '\n'
        root.b = root.b[:i] + nl + decls + '\n' + root.b[i:]

    # p.setDirty()
    # root.setDirty()
    # root.setMarked()
    # c.setChanged(True)

    # self.changed += 1
    #g.trace('%s --&gt; %s' % (p.h,root.h))
</t>
<t tx="ekr.20121013084734.16382">def post_process (self,c,p,prefix,theTypes):
    
    '''Traverse p's tree, replacing all nodes that start with prefix
       by the smallest equivalent @path or @file node.
    '''

    assert p
    root = p.copy()
    self.fix_back_slashes(root.copy())
    prefix = prefix.replace('\\','/')
    
    # self.dump_headlines(root.copy())
    if not use_at_edit:
        self.remove_empty_nodes(c,root.copy())
    self.minimize_headlines(c,root.copy().firstChild(),prefix,theTypes)
    self.clear_dirty_bits(c,root.copy())
    
    ## self.munge_at_file(c,root.copy().firstChild())
</t>
<t tx="ekr.20121013084734.16383">def clear_dirty_bits (self,c,p):
    
    c.setChanged(False)
    for p in p.self_and_subtree():
        p.clearDirty()
</t>
<t tx="ekr.20121013084734.16384">def dump_headlines (self,p):
    
    # show all headlines.
    for p in p.self_and_subtree():
        print(p.h)
</t>
<t tx="ekr.20121013084734.16385">def fix_back_slashes (self,p):
    
    '''Convert backslash to slash in all headlines.'''

    for p in p.self_and_subtree():
        s = p.h.replace('\\','/')
        if s != p.h:
            p.h = s
</t>
<t tx="ekr.20121013084734.16386">def minimize_headlines (self,c,p,prefix,theTypes):
    
    '''Create @path nodes to minimize the paths required in descendant nodes.'''

    trace = False
    
    # This could only happen during testing.
    if p.h.startswith('@'):
        g.trace('** skipping: %s' % (p.h))
        return
        
    h2 = p.h[len(prefix):].strip()
    
    ends_with_ext = any([h2.endswith(z) for z in theTypes])
    
    if p.h == prefix:
        if trace: g.trace('@path %s' % (p.h))
        p.h = '@path %s' % (p.h)
        for p in p.children():
            self.minimize_headlines(c,p,prefix,theTypes)
    elif h2.find('/') &lt;= 0 and ends_with_ext:
            if h2.startswith('/'): h2 = h2[1:]
            if use_at_edit:
                p.h = '@edit %s' % (h2)
            elif safe_at_file:
                if trace: g.trace('@@file %s' % (h2))
                p.h = '@@file %s' % (h2)
            else:
                if trace: g.trace('@file %s' % (h2))
                p.h = '@file %s' % (h2)
            # We never scan the children of @file nodes.
    else:
        if h2.startswith('/'): h2 = h2[1:]
        if trace:
            print('')
            g.trace('@path [%s/]%s' % (prefix,h2))
        p.h = '@path %s' % (h2)
        prefix2 = prefix if prefix.endswith('/') else prefix + '/'
        prefix2 = prefix2 + h2
        for p in p.children():
            self.minimize_headlines(c,p,prefix2,theTypes)
</t>
<t tx="ekr.20121013084734.16387">def remove_empty_nodes (self,c,p):
    
    root = p.copy()
    
    # Restart the scan once a node is deleted.
    changed = True
    while changed:
        changed = False
        for p in root.self_and_subtree():
            if not p.b and not p.hasChildren():
                # g.trace('** deleting',p.h)
                p.doDelete()
                c.selectPosition(root)
                changed = True
                break
                
</t>
<t tx="ekr.20121013084734.16388">def run (self,c,p,dir_,theTypes,oneFile=False,recursive=True):
    
    '''Import all the .py files in dir_.'''

    try:
        t1 = time.time()
        p1 = p.copy()
        g.app.disable_redraw = True
        bunch = c.undoer.beforeChangeTree(p1)
        assert p == c.p
        root = p.insertAfter()
        # root.h = '@path %s' % (dir_)
        root.h = 'imported files'
        prefix = dir_
        self.import_dir(c,root.copy(),dir_,theTypes,oneFile=oneFile,recursive=recursive)
        n = 0
        for p in root.self_and_subtree():
            n += 1
        if not use_at_edit:
            self.clean_all(c,root.copy())
        self.post_process(c,root.copy(),dir_,theTypes)
        c.undoer.afterChangeTree(p1,'recursive-import',bunch)
    finally:
        g.app.disable_redraw = False
        root.contract()
        c.redraw(root)
    
    t2 = time.time()
    g.trace('imported %s nodes in %2.2f sec' % (n,t2-t1))
</t>
<t tx="ekr.20121220111212.13257">'''
&lt;&lt; about this script &gt;&gt;
'''

@others

# Change test_dir as desired: it must already exist.
test_dir = g.os_path_finalize_join(g.app.loadDir,'..','test')

if 1:
    # Writes each test to a separate file in the test directory.
    TestWriter(c,path=test_dir).run(fn=None)    
else:
    # Writes all tests to a single file: test/unit_tests.py
    TestWriter(c,path=test_dir).run(fn='unit_tests.py')
</t>
<t tx="ekr.20121220111212.13258">@language rest

This script transliterates @test nodes into .py file. The two main ways of
using this script are as follows::

    TestWriter(c,path='test').run(fn='unit_tests.py') # writes one file
    TestWriter(c,path='test').run(fn=None)            # writes separate files.
     
The first writes all tests to test/unit_tests.py; the second writes each
unit test to a separate .py file in the test directory.

The script imports each written file and reports any syntax errors.

This is a straightforward script; it should be easy to modify it to suit
individual needs.

The &lt;\&lt; file_template &gt;&gt; and &lt;\&lt; test_template &gt;&gt; sections in the TestWriter
class determines exactly what this script writes.</t>
<t tx="ekr.20121220111212.13259">class TestWriter:
    
    &lt;&lt; define file_template &gt;&gt;
    &lt;&lt; define test_template &gt;&gt;

    @others
</t>
<t tx="ekr.20121220111212.13260"># Add any other common imports here.

file_template = '''\
import unittest
'''

file_template = g.adjustTripleString(file_template,c.tab_width)</t>
<t tx="ekr.20121220111212.13261">test_template = '''
class %s (unittest.TestCase):
    def runTest(self):
%s
'''

test_template = g.adjustTripleString(test_template,c.tab_width)
</t>
<t tx="ekr.20121220111212.13262">def __init__(self,c,path=''):
    
    self.c = c
    load_dir = g.os_path_dirname(c.fileName())
    self.path = g.os_path_finalize_join(load_dir,path)
    self.nodes = []
    assert g.os_path_exists(self.path),self.path
</t>
<t tx="ekr.20121220111212.13263">def clean(self,s):
    
    '''Munge s so that it can be used as a file name.'''
    
    result,tag = [],'@test'
    if s.startswith(tag):
        s = s[len(tag):]
    for ch in s.strip():
        if ch.isalnum():
            result.append(ch)
        elif ch.isspace():
            result.append('_')
    s = ''.join(result)
    if s.endswith('.py'):
        s = s[:-3]
    return s.strip()
</t>
<t tx="ekr.20121220111212.13264">def get_body(self,p):
    
    '''Convert p.b to a valid script.'''
    
    s = g.getScript(c,p,
        useSelectedText=False,forcePythonSentinels=True,useSentinels=False)

    s = ''.join([' '*8+z for z in g.splitLines(s) if z.strip()])
    
    return s.rstrip()
</t>
<t tx="ekr.20121220111212.13265">def run(self,fn=None):
    n,p = 1,c.rootPosition()
    while p:
        if p.h.startswith('@ignore '):
            p.moveToNodeAfterTree()
        elif p.h.startswith('@test '):
            self.nodes.append(p.copy())
            if not fn:
                fn2 = self.clean(p.h)+'.py'
                self.write_file(fn2)
                self.test(fn2)
                self.nodes=[]
            n += 1
            p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if fn:
        self.write_file(fn)
        self.test(fn)
    dest = g.os_path_join(self.path,fn) if fn else self.path
    print('wrote %s tests to %s' % (n,dest))
</t>
<t tx="ekr.20121220111212.13266">def test(self,fn):
    
    '''Test the newly created file.'''
    
    import imp
    import sys

    if self.path not in sys.path:
        sys.path.append(self.path)

    assert fn.endswith('.py')
    name = fn[:-3]
    try:
        f,path,desc = imp.find_module(name,[self.path])
        imp.load_module(name,f,path,desc)
        # print('imported %s' % (name))
    except Exception:
        print('can not import: %s' % (name))
        g.es_print_exception()
</t>
<t tx="ekr.20121220111212.13267">def write_file(self,fn):

    assert g.os_path_exists(self.path),self.path
    fn = g.os_path_finalize_join(self.path,fn)
    f = open(fn,'w')
    f.write(self.file_template)
    for p in self.nodes:
        f.write(self.test_template % (self.clean(p.h),self.get_body(p)))
    f.close()
</t>
<t tx="ekr.20130803163703.3086">@language clojure

(ns compojure.core
  "A concise syntax for generating Ring handlers."
  (:require [clojure.string :as str])
  (:use clout.core
        compojure.response
        [clojure.core.incubator :only (-?&gt;)]
        [clojure.tools.macro :only (name-with-attributes)]))

(defn- method-matches?
  "True if this request matches the supplied request method."
  [method request]
  (let [request-method (request :request-method)
        form-method (get-in request [:form-params "_method"])]
    (if (and form-method (= request-method :post))
      (= (str/upper-case (name method))
         (str/upper-case form-method))
      (= method request-method))))

(defn- if-method
  "Evaluate the handler if the request method matches."
  [method handler]
  (fn [request]
    (cond
      (or (nil? method) (method-matches? method request))
        (handler request)
      (and (= :get method) (= :head (:request-method request)))
        (-?&gt; (handler request)
             (assoc :body nil)))))

(defn- assoc-route-params
  "Associate route parameters with the request map."
  [request params]
  (merge-with merge request {:route-params params, :params params}))

(defn- if-route
  "Evaluate the handler if the route matches the request."
  [route handler]
  (fn [request]
    (if-let [params (route-matches route request)]
      (handler (assoc-route-params request params)))))

(defn- prepare-route
  "Pre-compile the route."
  [route]
  (cond
    (string? route)
      `(route-compile ~route)
    (vector? route)
      `(route-compile
        ~(first route)
        ~(apply hash-map (rest route)))
    :else
      `(if (string? ~route)
         (route-compile ~route)
         ~route)))

(defn- assoc-&amp;-binding [binds req sym]
  (assoc binds sym `(dissoc (:params ~req)
                            ~@(map keyword (keys binds))
                            ~@(map str (keys binds)))))

(defn- assoc-symbol-binding [binds req sym]
  (assoc binds sym `(get-in ~req [:params ~(keyword sym)]
                      (get-in ~req [:params ~(str sym)]))))

(defn- vector-bindings
  "Create the bindings for a vector of parameters."
  [args req]
  (loop [args args, binds {}]
    (if-let [sym (first args)]
      (cond
        (= '&amp; sym)
          (recur (nnext args) (assoc-&amp;-binding binds req (second args)))
        (= :as sym)
          (recur (nnext args) (assoc binds (second args) req))
        (symbol? sym)
          (recur (next args) (assoc-symbol-binding binds req sym))
        :else
          (throw (Exception. (str "Unexpected binding: " sym))))
      (mapcat identity binds))))

(defmacro let-request [[bindings request] &amp; body]
  (if (vector? bindings)
    `(let [~@(vector-bindings bindings request)] ~@body)
    `(let [~bindings ~request] ~@body)))

(defn make-route
  "Returns a function that will only call the handler if the method and Clout
route match the request."
  [method route handler]
  (if-method method
    (if-route route
      (fn [request]
        (render (handler request) request)))))

(defn- compile-route
  "Compile a route in the form (method path &amp; body) into a function."
  [method route bindings body]
  `(make-route
    ~method ~(prepare-route route)
    (fn [request#]
      (let-request [~bindings request#] ~@body))))

(defn routing
  "Apply a list of routes to a Ring request map."
  [request &amp; handlers]
  (some #(% request) handlers))

(defn routes
  "Create a Ring handler by combining several handlers into one."
  [&amp; handlers]
  #(apply routing % handlers))

(defmacro defroutes
  "Define a Ring handler function from a sequence of routes. The name may
optionally be followed by a doc-string and metadata map."
  [name &amp; routes]
  (let [[name routes] (name-with-attributes name routes)]
   `(def ~name (routes ~@routes))))

(defmacro GET "Generate a GET route."
  [path args &amp; body]
  (compile-route :get path args body))

(defmacro POST "Generate a POST route."
  [path args &amp; body]
  (compile-route :post path args body))

(defmacro PUT "Generate a PUT route."
  [path args &amp; body]
  (compile-route :put path args body))

(defmacro DELETE "Generate a DELETE route."
  [path args &amp; body]
  (compile-route :delete path args body))

(defmacro HEAD "Generate a HEAD route."
  [path args &amp; body]
  (compile-route :head path args body))

(defmacro OPTIONS "Generate an OPTIONS route."
  [path args &amp; body]
  (compile-route :options path args body))

(defmacro PATCH "Generate a PATCH route."
  [path args &amp; body]
  (compile-route :patch path args body))

(defmacro ANY "Generate a route that matches any method."
  [path args &amp; body]
  (compile-route nil path args body))

(defn- remove-suffix [path suffix]
  (subs path 0 (- (count path) (count suffix))))

(defn- wrap-context [handler]
  (fn [request]
    (let [uri (:uri request)
          path (:path-info request uri)
          context (or (:context request) "")
          subpath (-&gt; request :route-params :__path-info)]
      (handler
       (-&gt; request
           (assoc :path-info (if (= subpath "") "/" subpath))
           (assoc :context (remove-suffix uri subpath))
           (update-in [:params] dissoc :__path-info)
           (update-in [:route-params] dissoc :__path-info))))))

(defn- context-route [route]
  (let [re-context {:__path-info #"|/.*"}]
    (cond
      (string? route)
       `(route-compile ~(str route ":__path-info") ~re-context)
      (vector? route)
       `(route-compile
         ~(str (first route) ":__path-info")
         ~(merge (apply hash-map (rest route)) re-context))
      :else
       `(route-compile (str ~route ":__path-info") ~re-context))))

(defmacro context
  "Give all routes in the form a common path prefix and set of bindings.

The following example demonstrates defining two routes with a common
path prefix ('/user/:id') and a common binding ('id'):

(context \"/user/:id\" [id]
(GET \"/profile\" [] ...)
(GET \"/settings\" [] ...))"
  [path args &amp; routes]
  `(#'if-route ~(context-route path)
     (#'wrap-context
       (fn [request#]
         (let-request [~args request#]
           (routing request# ~@routes))))))

(defmacro let-routes
  "Takes a vector of bindings and a body of routes. Equivalent to:
(let [...] (routes ...))"
  [bindings &amp; body]
  `(let ~bindings (routes ~@body)))</t>
<t tx="ekr.20130803173509.2906">@language clojure

(defmacro let-request [[bindings request] &amp; body]
  (if (vector? bindings)
    `(let [~@(vector-bindings bindings request)] ~@body)
    `(let [~bindings ~request] ~@body)))

(defn make-route
  "Returns a function that will only call the handler if the method and Clout
route match the request."
  [method route handler]
  (if-method method
    (if-route route
      (fn [request]
        (render (handler request) request)))))
</t>
<t tx="ekr.20130803173509.2908">@language clojure

(defn make-route
  "Returns a function that will only call the handler if the method and Clout
route match the request."
)</t>
<t tx="ekr.20130803180319.2910">@language clojure

(defmacro context
  "Give all routes in the form a common path prefix and set of bindings.

The following example demonstrates defining two routes with a common
path prefix ('/user/:id') and a common binding ('id'):

(context \"/user/:id\" [id]
(GET \"/profile\" [] ...)
(GET \"/settings\" [] ...))"

  [path args &amp; routes]
  `(#'if-route ~(context-route path)
     (#'wrap-context
       (fn [request#]
         (let-request [~args request#]
           (routing request# ~@routes))))))</t>
<t tx="maphew.20130612230051.2793">Scripts only of interest when on Microsoft Windows platform.</t>
</tnodes>
</leo_file>
