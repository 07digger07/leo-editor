<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954"><vh>Startup</vh>
<v t="ekr.20070427110751"><vh>@chapters</vh></v>
<v t="ekr.20111017085134.16069"><vh>Disabled buttons</vh>
<v t="ekr.20111017085134.16070"><vh>@@button jython</vh></v>
<v t="ekr.20111017085134.16071"><vh>@@button pydoc</vh></v>
<v t="ekr.20111017085134.16072"><vh>@@button check-dirty</vh></v>
<v t="ekr.20111017085134.16073"><vh>@@button Ipython</vh></v>
<v t="ekr.20111017085134.16074"><vh>@@button Lines Down</vh>
<v t="ekr.20111017085134.16075"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20111017085134.16076"><vh>@@button Lines Up</vh>
<v t="ekr.20111017085134.16077"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20111017085134.16078"><vh>@@button lispCall @key=alt+6</vh>
<v t="ekr.20111017085134.16079"><vh>ctor</vh></v>
<v t="ekr.20111017085134.16080"><vh>run &amp; helpers</vh>
<v t="ekr.20111017085134.16081"><vh>findCalls</vh></v>
<v t="ekr.20111017085134.16082"><vh>findDefs</vh></v>
<v t="ekr.20111017085134.16083"><vh>stripComments</vh></v>
<v t="ekr.20111017085134.16084"><vh>stripLispIds</vh></v>
<v t="ekr.20111017085134.16085"><vh>stripStrings</vh></v>
</v>
<v t="ekr.20111017085134.16086"><vh>class token</vh></v>
<v t="ekr.20111017085134.16087"><vh>choose</vh></v>
<v t="ekr.20111017085134.16088"><vh>dumpList</vh></v>
<v t="ekr.20111017085134.16089"><vh>Parsing...</vh>
<v t="ekr.20111017085134.16090"><vh>parse</vh></v>
<v t="ekr.20111017085134.16091"><vh>scan &amp; helpers</vh>
<v t="ekr.20111017085134.16092"><vh>skipComment</vh></v>
<v t="ekr.20111017085134.16093"><vh>skipId</vh></v>
<v t="ekr.20111017085134.16094"><vh>skipString</vh></v>
</v>
<v t="ekr.20111017085134.16095"><vh>scanForest</vh></v>
</v>
<v t="ekr.20111017085134.16096"><vh>Code generators...</vh>
<v t="ekr.20111017085134.16097"><vh>gen</vh></v>
<v t="ekr.20111017085134.16098"><vh>gen_token</vh></v>
<v t="ekr.20111017085134.16099"><vh>gen_block &amp; helper</vh>
<v t="ekr.20111017085134.16100"><vh>gen_block_id</vh></v>
</v>
<v t="ekr.20111017085134.16101"><vh>gen_call &amp; helper</vh>
<v t="ekr.20111017085134.16102"><vh>gen_arg</vh></v>
</v>
<v t="ekr.20111017085134.16103"><vh>gen_def</vh></v>
<v t="ekr.20111017085134.16104"><vh>gen_if &amp; helpers</vh>
<v t="ekr.20111017085134.16105"><vh>gen_then</vh></v>
</v>
<v t="ekr.20111017085134.16106"><vh>gen_expr</vh></v>
<v t="ekr.20111017085134.16107"><vh>gen_let &amp; helper</vh>
<v t="ekr.20111017085134.16108"><vh>gen_let_bindings</vh></v>
</v>
<v t="ekr.20111017085134.16109"><vh>put...</vh>
<v t="ekr.20111017085134.16110"><vh>put </vh></v>
<v t="ekr.20111017085134.16111"><vh>put_token</vh></v>
<v t="ekr.20111017085134.16112"><vh>put_code &amp; put_code_line</vh></v>
<v t="ekr.20111017085134.16113"><vh>put_code_token</vh></v>
</v>
</v>
</v>
<v t="ekr.20111017085134.16114"><vh>@@button outlineToClipboard</vh></v>
</v>
</v>
<v t="ekr.20061008055616"><vh>Scripts</vh>
<v t="ekr.20051110111150"><vh>@thin leoScripts.txt</vh></v>
<v t="ekr.20110914030246.2405"><vh>@file gen_blender_docs.py</vh></v>
<v t="maphew.20130612230051.2793"><vh>Windows</vh>
<v t="maphew.20130809155103.2862"><vh>@auto create-leobat.bat</vh></v>
<v t="maphew.20130809155103.2863"><vh>@file build-leo.bat</vh></v>
<v t="maphew.20130613230258.2801"><vh>@file elevate.py</vh></v>
<v t="maphew.20130611235500.2658"><vh>@file register-leo.leox</vh></v>
<v t="maphew.20130611235500.2665"><vh>@file unregister-leo.leox</vh></v>
</v>
</v>
<v t="ekr.20121220111212.13257"><vh>@button write-unit-tests</vh>
<v t="ekr.20121220111212.13258"><vh>&lt;&lt; about this script &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13259"><vh>class TestWriter</vh>
<v t="ekr.20121220111212.13260"><vh>&lt;&lt; define file_template &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13261"><vh>&lt;&lt; define test_template &gt;&gt;</vh></v>
<v t="ekr.20121220111212.13262"><vh> ctor</vh></v>
<v t="ekr.20121220111212.13263"><vh>clean</vh></v>
<v t="ekr.20121220111212.13264"><vh>get_body</vh></v>
<v t="ekr.20121220111212.13265"><vh>run</vh></v>
<v t="ekr.20121220111212.13266"><vh>test</vh></v>
<v t="ekr.20121220111212.13267"><vh>write_file</vh></v>
</v>
</v>
<v t="ekr.20130810093044.16933"><vh>Recently contributed scripts</vh>
<v t="ekr.20130810093044.16934"><vh>By Terry Brown</vh>
<v t="ekr.20130810093044.16935"><vh>add @script node</vh></v>
<v t="ekr.20130810093044.16936"><vh>Cross-outline node editing</vh>
<v t="ekr.20130810093044.16937"><vh>Re: Cross-outline node editing</vh></v>
<v t="ekr.20130810093044.16938"><vh>Re: Cross-outline node editing</vh></v>
<v t="ekr.20130810093044.16939"><vh>Re: Cross-outline node editing</vh></v>
</v>
<v t="ekr.20130810093044.16940"><vh>export full contents</vh>
<v t="ekr.20130810093044.16941"><vh>script</vh></v>
</v>
<v t="ekr.20130816100419.23046"><vh>Full tree preview script</vh>
<v t="ekr.20130816100419.23047"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20130810093044.16942"><vh>Indexing files for full text search</vh>
<v t="ekr.20130810093044.16943"><vh>Re: Idea/needed: system command queue</vh></v>
<v t="ekr.20130810093044.16944"><vh>Re: Idea/needed: system command queue</vh></v>
</v>
<v t="ekr.20130810093044.16945"><vh>persistent state with json as a leo abbreviation</vh>
<v t="ekr.20130810093044.16946"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
<v t="ekr.20130810093044.16947"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
<v t="ekr.20130810093044.16948"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
</v>
<v t="ekr.20130810093044.16949"><vh>Tool for diffing Leo files</vh>
<v t="ekr.20130810093044.16950"><vh>Re: Tool for diffing Leo files</vh></v>
</v>
</v>
<v t="ekr.20130810093044.16951"><vh>By EKR</vh>
<v t="ekr.20130810093044.16952"><vh>cleanup-imported-nodes</vh>
<v t="ekr.20130810093044.16953"><vh>Rev 5378: cleanup-imported-nodes script in scripts.leo &amp; an Aha</vh></v>
</v>
<v t="ekr.20130810093044.16954"><vh>Create global data structures from in modes/*.py files</vh></v>
<v t="ekr.20130810093044.16955"><vh>get all comments from modes (slow)</vh>
<v t="ekr.20130810093044.16956"><vh>get_paths</vh></v>
<v t="ekr.20130810093044.16957"><vh>import_module</vh></v>
</v>
<v t="ekr.20130810093044.16958"><vh>import-org-mode</vh>
<v t="ekr.20130810093044.16959"><vh>import-org-mode (command, not used)</vh>
<v t="ekr.20130810093044.16960"><vh>ctor</vh></v>
<v t="ekr.20130810093044.16961"><vh>go</vh></v>
<v t="ekr.20130810093044.16962"><vh>scan</vh></v>
<v t="ekr.20130810093044.16963"><vh>test</vh></v>
</v>
<v t="ekr.20130810093044.16964"><vh>@@button import-org-mode</vh>
<v t="ekr.20130810093044.16965"><vh>scan</vh></v>
</v>
<v t="ekr.20130810093044.16966"><vh>test-import-org-mode</vh></v>
</v>
<v t="ekr.20130810093044.16967"><vh>jinja2 templating script</vh></v>
<v t="ekr.20130810093044.16968"><vh>recursive import script (revised)</vh></v>
<v t="ekr.20121013084734.16370"><vh>Recursive import script (with cleanups)</vh>
<v t="ekr.20121013084734.16371"><vh>class ImportController</vh>
<v t="ekr.20121013084734.16372"><vh>Pass 1: import_dir</vh></v>
<v t="ekr.20121013084734.16373"><vh>Pass 2: clean_all &amp; helpers</vh>
<v t="ekr.20121013084734.16374"><vh>clean</vh></v>
<v t="ekr.20121013084734.16375"><vh>clean_blank_lines</vh></v>
<v t="ekr.20121013084734.16376"><vh>merge_comment_nodes</vh></v>
<v t="ekr.20121013084734.16377"><vh>merge_extra_nodes</vh></v>
<v t="ekr.20121013084734.16378"><vh>move_decorator_lines</vh></v>
<v t="ekr.20121013084734.16379"><vh>move_doc_string</vh></v>
<v t="ekr.20121013084734.16380"><vh>move_shebang_line</vh></v>
<v t="ekr.20121013084734.16381"><vh>rename_decls</vh></v>
</v>
<v t="ekr.20121013084734.16382"><vh>Pass 3: post_process &amp; helpers</vh>
<v t="ekr.20121013084734.16383"><vh>clear_dirty_bits</vh></v>
<v t="ekr.20121013084734.16384"><vh>dump_headlines</vh></v>
<v t="ekr.20121013084734.16385"><vh>fix_back_slashes</vh></v>
<v t="ekr.20121013084734.16386"><vh>minimize_headlines</vh></v>
<v t="ekr.20121013084734.16387"><vh>remove_empty_nodes</vh></v>
</v>
<v t="ekr.20121013084734.16388"><vh>run</vh></v>
</v>
</v>
</v>
<v t="ekr.20130810093044.16969"><vh>By Brian Theado</vh>
<v t="ekr.20130810093044.16970"><vh>Display function call hierarchy in Leo</vh>
<v t="ekr.20130810093044.16971"><vh>call tree</vh>
<v t="ekr.20130810093044.16972"><vh>displayCalltree</vh></v>
<v t="ekr.20130810093044.16973"><vh>trace session</vh></v>
</v>
</v>
</v>
<v t="ekr.20130812034101.12556"><vh>By Matt Wilkie</vh>
<v t="ekr.20130812034101.12558"><vh>Script: Add docutils to python3 </vh></v>
<v t="ekr.20130812034101.12566"><vh>Leo script to register .leo files with Windows</vh>
<v t="ekr.20130812034101.12567"><vh>Re: Leo script to register .leo files with Windows</vh></v>
</v>
<v t="ekr.20130812034101.12568"><vh>Leo script to set .leo association (Windows)</vh>
<v t="ekr.20130812034101.12569"><vh>Re: Leo script to set .leo association (Windows)</vh></v>
</v>
<v t="ekr.20130812034101.12570"><vh>Leo script to (almost) set .leo filetype icon</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20061008055616"></t>
<t tx="ekr.20070427110751"></t>
<t tx="ekr.20070615131954"></t>
<t tx="ekr.20111017085134.16069"></t>
<t tx="ekr.20111017085134.16070"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.h
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20111017085134.16071">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20111017085134.16072"># This works, but is too slow to be really useful.

count = 0
for p in c.all_unique_positions():
    if p.isDirty():
        c.checkPythonNode (p,suppressErrors=False)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20111017085134.16073">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20111017085134.16074"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20111017085134.16075">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16076"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20111017085134.16077">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16078">'''Analyze external calls in lisp files.'''

import glob
class lispAnalyzer:
    @others

base = '/media/disk/XEmacs/XEmacs-21.4.13/lisp/*.el'
paths = glob.glob(base)
# g.es(g.listToString(paths))
paths = [paths[0]]

x = lispAnalyzer(c,paths)
x.run()</t>
<t tx="ekr.20111017085134.16079">def __init__ (self,c,paths):

    self.c = c
    self.paths = paths

    # Debugging.
    self.debug = True
    self.trace = False

    # Semantic info.
    self.def_keywords = ('defun','defvar',)
    self.indent_keywords = ('if','prog','prog1','progn','set',)
    self.expr_keywords = ('and','not','or',)

    self.indent = 0 # Indentation of production output.

    # Dispatch dictionary.
    self.dispatchDict = {}</t>
<t tx="ekr.20111017085134.16080">def run(self):

    fn = self.paths[0]
    f = open(fn)
    s = f.read()
    g.es_print(fn)
    # g.trace(s)
    s = self.stripStrings(s)
    s = self.stripComments(s)
    defs = self.findDefs(s)
    calls = self.findCalls(s,defs)
    calls = self.stripLispIds(calls)
    defs.sort()
    calls.sort()
    g.trace('defs...\n',g.listToString(defs))
    g.trace('calls...\n',g.listToString(calls))
</t>
<t tx="ekr.20111017085134.16081">def findCalls (self,s,defs):

    calls = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            theId = s[i:j].strip()
            if theId not in defs and theId not in calls:
                calls.append(theId)
            i = j
        else: i += 1
        assert progress &lt; i

    return calls       
</t>
<t tx="ekr.20111017085134.16082">def findDefs (self,s):

    defs = [] ; tag = '(defun'
    i = 0
    while True:
        progress = i
        j = s.find(tag,i)
        if j == -1:
            return defs
        i = j + len(tag)
        j = g.skip_ws(s,i)
        if j &gt; i:
            k = self.skipId(s,j)
            if k &gt; j:
                defs.append(s[j:k])
            i = k
        assert progress &lt; i 
</t>
<t tx="ekr.20111017085134.16083">def stripComments(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == ';':
            i = self.skipComment(s,i)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16084">def stripLispIds (self,aList):

    lispIds = [
        't','f',
        'apply',
        'boundp',
        'car','cons','cdr','consp',
        'eq','equal','eval',
        'lamda','lambda',
        'macro',
        'nil','not','null','numberp',
        'or',
        'unless',
        'vector','vectorp',
        # special forms
        'and',
        'catch',
        'cond',
        'condition-case',
        'defconst',
        'defmacro',
        'defun',
        'defvar',
        'function',
        'if',
        'interactive',
        'let',
        'let*',
        'or',
        'prog1',
        'prog2',
        'progn',
        'quote',
        'save-current-buffer',
        'save-excursion',
        'save-restriction',
        'save-window-excursion',
        'setq',
        'setq-default',
        'track-mouse',
        'unwind-protect',
        'while',
        'with-output-to-temp-buffer',
    ]

    return [z for z in aList if z not in lispIds]</t>
<t tx="ekr.20111017085134.16085">def stripStrings(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == '"':
            i = self.skipString(s,i)
        elif ch == "'":
            i = self.skipId(s,i+1)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16086">class token:

    '''Representing one elisp syntactic entity,
    with a list of preceding comments.'''

    def __init__ (self,comments,kind,val):
        self.comments = comments[:]
        self.kind = kind
        self.val = val
            # For blocks, a list of tokens.
            # For all other tokens, the spelling of the token.

    def __repr__ (self):
        return '&lt;token kind: %s, val: %s&gt;' % (self.kind,self.val)

    def __str__ (self):
        if self.kind == 'block:':
            return 'block: [snip]'
        elif self.kind == 'string:':
            return '%s%s' % (self.kind,self.val[:20])
        else:
            return '%s%s' % (self.kind,self.val)
</t>
<t tx="ekr.20111017085134.16087">def choose(self,cond,a,b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20111017085134.16088">def dumpList(self,aList):

    if type(aList) == type([]):
        result = self.dumpListHelper(aList,indent=0)
        return '\n'.join(result)
    else:
        return repr(aList)

def dumpListHelper(self,aList,indent):

    result = []
    leading = ' ' * (4 * indent)

    for z in aList:
        if z is None:
            result.append('%s%s' % (leading,'None'))
        elif z == []:
            result.append('%s%s' % (leading,'[]'))
        elif type(z) == type([]):
            result.append('%s%s' % (leading,'['))
            result.extend(self.dumpListHelper(z,indent+1))
            result.append('%s%s' % (leading,']'))
        elif isinstance(z,self.token):
            if z.kind=='block:':
                result.append('%s%s' % (leading,'block:'))
                result.extend(self.dumpListHelper(z.val,indent+1))
                # result.append('%s%s' % (leading,'block:]'))
            else:
                result.append('%s%s' % (leading,str(z)))
        else:
            result.append('%s%s' % (leading,str(z)))

    return result

listToString = dumpList</t>
<t tx="ekr.20111017085134.16089"></t>
<t tx="ekr.20111017085134.16090">def parse(self,s):

    # Generate the nodes, including directive and section references.
    return self.scanForest(s)
</t>
<t tx="ekr.20111017085134.16091">def scan(self,s,i):

    '''Scan an elisp expression.'''

    start = i ; end = len(s) ; result = []
    comments = [] ; token = self.token
    # A hack. ignore initial @language lisp
    tag = '@language lisp'
    if i == 0 and s[i:i+len(tag)]==tag:
        i += len(tag)
    while i &lt; end:
        progress = i
        ch = s[i]
        if ch == ';':
            j = self.skipComment(s,i)
            start = i = j
        elif ch == '"':
            j = self.skipString(s,i)
            start = i = j
        elif ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            result.append(token(comments,'id:',s[i:j]))
            start = i = j
        elif ch =='(':
            i += 1
            j,aList = self.scan(s,i)
            result.append(token(comments,'block:',aList))
            start = i = j
        elif ch == ')':
            i += 1
            return i,result
        else:
            # if ch == "'": ch = 'quote'
            # if ch not in (' ','\t','\n','\r'):
                # result.append(token(comments,'op:',ch))
            i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if start &lt; end:
        tail = s[start:end].strip()
        if tail:
            result.append(token(comments,'tail:',tail))
            comment = []
    if comments:
        result.append(token(comments,'trailing-comment:',''))

    return i,result
</t>
<t tx="ekr.20111017085134.16092">def skipComment (self,s,i):

    '''Skip a comment.'''

    while i &lt; len(s):
        if s[i] == '\n':
            break
        i += 1
    return i
</t>
<t tx="ekr.20111017085134.16093">def skipId (self,s,i):

    while i &lt; len(s):
        ch = s[i]
        if ch.isalnum() or ch in ('_','-'):
            i += 1
        else:
            break
    return i
</t>
<t tx="ekr.20111017085134.16094">def skipString(self,s,i):

    """Skip a string literal."""

    assert(s[i] == '"')
    i += 1
    while i &lt; len(s):
        ch = s[i]
        if ch == '\\' : i += 2
        elif ch == '"':
            i += 1 ; break
        else: i += 1

    return i</t>
<t tx="ekr.20111017085134.16095">def scanForest (self,s):

    i = 0 ; result = []

    while i &lt; len(s):
        progress = i
        i,aList = self.scan(s,i)
        aList and result.extend(aList)
        assert i &gt; progress

    return result


</t>
<t tx="ekr.20111017085134.16096">@ From Richard Deibenkorn:

1. Attempt what is not certain. Certainty may or may not come later. It may then
be a valuable delusion.

2. The pretty, initial position which falls short of completeness is not to be
valued--except as stimulus for further moves.

3. Do search.  But in order to find other than what is looked for.

4. Use and respond to the initial fresh qualities but consider them absolutely
expendable.
</t>
<t tx="ekr.20111017085134.16097">def gen(self,tokens,indent,init=False):

    result = []

    if init: result.append('='*40)

    for token in tokens:
        aList = self.gen_token(token,indent)
        result.extend(aList)

    if init: result.append('-'*40)

    return result

</t>
<t tx="ekr.20111017085134.16098">def gen_token(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            self.gen_block(token,indent)
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16099">def gen_block (self,token,indent):

    if not (token and token.val):
        return []

    blockList = token.val
    token2 = blockList[0]
    result = []

    if token2.kind.startswith('id'):
        aList = self.gen_block_id(token2.val,blockList,indent)
    else:
        if self.debug:
            self.put('block...',[],indent,result)
        aList = self.gen(token.val,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16100">def gen_block_id (self,theId,tokens,indent):

    result = []

    # Eventually there will be a lookup of the dispatch dict here.
    if theId == 'let':
        aList = self.gen_let(tokens,indent)
    elif theId == 'if':
        aList = self.gen_if(tokens,indent)
    elif theId in self.def_keywords:
        aList = self.gen_def(theId,tokens,indent)
    elif theId in self.indent_keywords:
        self.put('%s...' % (theId),[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
    elif theId in self.expr_keywords:
        aList = self.gen_expr(theId,tokens[1:],indent+1)
    else:
        aList = self.gen_call(theId,tokens[1:],indent)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16101">def gen_call (self,funcId,tokens,indent):

    result = []

    if self.debug:
        self.put('call: %s' % (funcId),[],indent,result)
        for token in tokens:
            aList = self.gen_arg(token,indent+1)
            result.extend(aList)
    else:
        self.put_code_line('%s(' % (funcId))
        for token in tokens:
            self.gen_arg(token,indent+1)
        self.put_code(')')

    return result

</t>
<t tx="ekr.20111017085134.16102">def gen_arg(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            self.put('arg block:...',[],indent,result)
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            self.put_code(''.join(aList))
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16103">def gen_def(self,theId,tokens,indent):

    result = []

    if not tokens or len(tokens) &lt; 3:
        result.append('*** bad def tokens')
        return result

    defToken,idToken = tokens[0:2]
    if idToken.kind != 'id:':
        result.append('*** bad def id')
        return result

    if self.debug:
        self.put(theId,idToken.val,indent,result)
        aList = self.gen(tokens[2:],indent+1)
        result.extend(aList)
    else:
        self.put_code('def %s (' % idToken.val)
        self.gen_token(tokens[2],indent)
        self.put_code('): # end def\n')
        self.indent += 1
        self.gen(tokens[3:],indent+1)
        self.indent -= 1

    return result
</t>
<t tx="ekr.20111017085134.16104">@ if condition then-form else-forms.

If the evaluated condition is non-nil, then-form is evaluated and the result
returned. Otherwise, the else-forms are evaluated in textual order, and the
value of the last one is returned. If condition has the value nil, and no
else-forms are given, if returns nil.
@c

def gen_if (self,tokens,indent):

    # tokens[0]: id:if
    # tokens[1] cond

    for i in xrange(len(tokens)):
        g.trace('tokens[%d]: %s' % (i,self.dumpList(tokens[i])))

    # g.trace(self.dumpList(tokens))

    result = []

    if self.debug:
        self.put('if...',[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
        result.extend(aList)
    else:
        self.put_code('if ')
        self.gen(tokens[1:],indent+1)
        self.put_code(': # end if\n')

    return result
</t>
<t tx="ekr.20111017085134.16105">def gen_then (self,token):

    pass
</t>
<t tx="ekr.20111017085134.16106">def gen_expr (self,theId,aList,indent):

    binops = ('and','or',)
    result = []

    self.put(theId,[],indent,result)
    aList = self.gen(aList,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16107">@
(let ((variable value)
      (variable value)
      ...)
  body...)
@c

def gen_let (self,tokens,indent):

    if not tokens: return []
    if len(tokens) != 3:
        g.trace('unusual let')
        result = self.gen(tokens,indent+1)
        return result

    if 0:
        for i in xrange(len(tokens)):
            g.trace('token',i,tokens[i])

    letToken,bindingToken,bodyToken = tokens
    result = []
    self.put('let...',[],indent,result)
    self.put('let-bindings...',[],indent+1,result)
    aList = self.gen_let_bindings(bindingToken,indent+2)
    result.extend(aList)
    self.put('let-block...',[],indent+1,result)
    aList = self.gen_block(bodyToken,indent+2)
    result.extend(aList)
    return result</t>
<t tx="ekr.20111017085134.16108">def gen_let_bindings (self,token,indent):

    result = []

    if token.kind != 'block:':
        g.trace('unexpected let')
        return result

    for z in token.val:
        if z.kind == 'block:': # one (id,val) pair
            if z.val and len(z.val) == 2:
                token1 = z.val[0]
                token2 = z.val[1]
                self.put('let-id',token1,indent,result)
                self.put('let-val...',[],indent,result)
                if token2.kind == 'block:':
                    aList = self.gen_block(token2,indent+1)
                    result.extend(aList)
                else:
                    #g.trace('no let list')
                    self.put_token(token2,indent+1,result)
            else:
                g.trace('unexpected let 2')

    return result
</t>
<t tx="ekr.20111017085134.16109"></t>
<t tx="ekr.20111017085134.16110">def put (self,kind,val,indent,result):

    '''Append one or more lines of output to result.'''

    leading = '%2d: %s' % (indent,' ' * indent)

    if kind == 'string:':
        val = self.choose(len(val)&gt;20,val[:20]+'..."',val)

    if val:
        s = '%s%s %s' % (leading,str(kind),str(val))
    else:
        s = '%s%s' % (leading,str(kind))

    result.append(s)
</t>
<t tx="ekr.20111017085134.16111">def put_token (self,token,indent,result):

    for z in token.comments:
        self.put('comment:',z,indent,result)

    self.put(token.kind,token.val,indent,result)
</t>
<t tx="ekr.20111017085134.16112">def put_code_line (self,s):

    s2 = '%s%s' % (' '*self.indent,s)
    print s2,

def put_code (self,s):

    print s,
</t>
<t tx="ekr.20111017085134.16113">def put_code_token (self,token):

    if token.kind == 'block:':
        self.put_code('&lt;block&gt;')
    else:
        self.put_code(token.val)

</t>
<t tx="ekr.20111017085134.16114">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20121013084734.16370">'''Recursively import all python files in a directory and clean the result.'''

# Latest change: do some fixups for languages other than python.

import os
import time

use_at_edit = False # True: create @edit nodes
safe_at_file = True # True: create @@file nodes instead of @file nodes.
oneFile = False # True: only import one file.

if 1:
    theTypes = ('.ts',)
    dir_ = r'C:\prog\typescript-fe3bc0bfce1f\src\compiler'
else:
    theTypes = ('.py',)
    dir_ = r'C:\Python26\Lib\site-packages\rope'

@others

# g.cls()

if g.os_path_exists(dir_):
    # Import all files in dir_ after c.p.
    try:
        ImportController().run(c,p,dir_,theTypes,
            oneFile=oneFile,recursive=not oneFile)
    finally:
        c.redraw()
else:
    print('Does not exist: %s' % (dir_))
</t>
<t tx="ekr.20121013084734.16371">class ImportController():
    
    # There is no ctor.

    @others
</t>
<t tx="ekr.20121013084734.16372">def import_dir(self,c,root,dir_,theTypes,oneFile=False,recursive=True):

    g.es("dir: " + dir_,color="blue")
    dirs,files,files2 = [],os.listdir(dir_),[]
    for f in files:
        path = g.os_path_join(dir_,f)
        if g.os_path_isfile(path):
            name, ext = g.os_path_splitext(f)
            if not theTypes or ext in theTypes:
                files2.append(path)
        elif recursive:
            dirs.append(path)
    if files2 or dirs:
        child = root.insertAsLastChild()
        child.h = dir_
        c.selectPosition(child,enableRedrawFlag=False)
    if files2:
        if oneFile: files2 = [files2[0]]
        if use_at_edit:
            for fn in files2:
                parent = child or root
                p = parent.insertAsLastChild()
                p.h = fn.replace('\\','/')
                s,e = g.readFileIntoString(fn,encoding='utf-8',kind='@edit')
                p.b = s
        else:
            c.importCommands.importFilesCommand(files2,'@file',redrawFlag=False)
                # '@auto' causes problems.
    if dirs:
        for dir_ in sorted(dirs):
            prefix = dir_
            self.import_dir(c,child,dir_,theTypes)
</t>
<t tx="ekr.20121013084734.16373">def clean_all (self,c,p):
    
    for p in p.self_and_subtree():
        h = p.h
        if h.startswith('@file') or h.startswith('@@file'):
            i = 6 if h[1] == '@' else 5
            path = h[i:].strip()
            junk,ext = g.os_path_splitext(path)
            self.clean(c,p,ext)
</t>
<t tx="ekr.20121013084734.16374">def clean(self,c,p,ext):
    
    '''
    - Move a shebang line from the first child to the root.
    - Move a leading docstring in the first child to the root.
    - Use a section reference for declarations.
    - Remove leading and trailing blank lines from all nodes.
    - Merge a node containing nothing but comments with the next node.
    - Merge a node containing no class or def lines with the previous node.
    '''

    root = p.copy()
    for tag in ('@@file','@file'):
        if p.h.startswith(tag):
            p.h = p.h[len(tag):].strip()
            break
            
    self.move_shebang_line(c,root)
    self.move_doc_string(c,root)
    self.rename_decls(c,root)

    for p in root.self_and_subtree():
        self.clean_blank_lines(c,p)
        
    # Get the single-line comment delim.
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        delim,junk,junk = g.set_delims_from_language(language)
    else:
        delim = None
        
    # g.trace('ext: %s language: %s delim: %s' % (ext,language,delim))
        
    if delim:
        # Do general language-dependent cleanups.
        for p in root.subtree():
            self.merge_comment_nodes(c,p,delim)
    if ext == 'py':
        # Do python only cleanups.
        for p in root.subtree():
            self.merge_extra_nodes(c,p)
        for p in root.subtree():
            self.move_decorator_lines(c,p)
</t>
<t tx="ekr.20121013084734.16375">def clean_blank_lines(self,c,p):
    
    '''Remove leading and trailing blank lines from all nodes.
    '''
    
    s = p.b
    if not s.strip():
        return
    
    result = g.splitLines(s)
    for i in 0,-1:
        while result:
            if result[i].strip():
                break
            else:
                del result[i]
        
    s = ''.join(result)
    if not s.endswith('\n'): s = s + '\n'
    if s != p.b:
        p.b = s
</t>
<t tx="ekr.20121013084734.16376">def merge_comment_nodes(self,c,p,delim):
    
    '''Merge a node containing nothing but comments with the next node.'''
    
    if not p.hasChildren() and p.hasNext() and p.h.strip().startswith(delim):
        p2 = p.next()
        b = p.b.lstrip()
        b = b + ('\n' if b.endswith('\n') else '\n\n')
        p2.b = b + p2.b
        p.doDelete(p2)
        # g.trace(p2.h)
</t>
<t tx="ekr.20121013084734.16377">def merge_extra_nodes(self,c,p):
    
    '''Merge a node containing no class or def lines with the previous node'''
    
    s = p.b
    if p.hasChildren() or p.h.strip().startswith('&lt;&lt;') or not s.strip():
        return
        
    for s2 in g.splitLines(s):
        if s2.strip().startswith('class') or s2.strip().startswith('def'):
            return

    p2 = p.back()
    if p2:
        nl = '\n' if s.endswith('\n') else '\n\n'
        p2.b = p2.b + nl + s
        h = p.h
        p.doDelete(p2)
</t>
<t tx="ekr.20121013084734.16378">def move_decorator_lines (self,c,p):
    
    '''Move trailing decorator lines to the next node.'''
    
    trace = False
    p2 = p.next()
    if not p2: return False
    
    lines = g.splitLines(p.b)
    n = len(lines) -1
    while n &gt;= 0:
        s = lines[n]
        if s.startswith('@'):
            i = g.skip_id(s,1,chars='-')
            word = s[1:i]
            if word in g.globalDirectiveList:
                break
            else:
                n -= 1
        else:
            break
        
    head = ''.join(lines[:n+1])
    tail = ''.join(lines[n+1:])
    if not tail: return False

    assert head.endswith('\n')
    assert p.b == head+tail
    
    if trace:
        if tail not in seen:
            seen.append(tail)
            g.trace(tail.strip())
    
    if 1:
        nl = '' if tail.endswith('\n') else '\n'
        p.b = head
        p2.b = tail+nl+p2.b
        
    return True
</t>
<t tx="ekr.20121013084734.16379">def move_doc_string(self,c,root):

    '''Move a leading docstring in the first child to the root node.'''
    
    # To do: copy comments before docstring
    
    p = root.firstChild()
    s = p and p.b or ''
    if not s: return
    
    # if root.h.endswith('pgen.py'):
        # g.pdb()

    result = []
    for s2 in g.splitLines(s):
        delim = None
        s3 = s2.strip()
        if not s3:
            result.append(s2)
        elif s3.startswith('#'):
            result.append(s2)
        elif s3.startswith('"""'):
            delim = '"""'
            break
        elif s3.startswith("'''"):
            delim = "'''"
            break
        else:
            break
       
    if not delim:
        comments = ''.join(result)
        if comments:
            nl = '\n\n' if root.b.strip() else ''
            if root.b.startswith('@first #!'):
                lines = g.splitLines(root.b)
                root.b = lines[0] + '\n' + comments + nl + ''.join(lines[1:])
            else:
                root.b = comments + nl + root.b
            p.b = s[len(comments):]
        return

    i = s.find(delim)
    assert i &gt; -1
    i = s.find(delim,i+3)
    if i == -1:
        return
        
    doc = s[:i+3]
    p.b = s[i+3:].lstrip()
    
    # Move docstring to front of root.b, but after any shebang line.
    nl = '\n\n' if root.b.strip() else ''
    if root.b.startswith('@first #!'):
        lines = g.splitLines(root.b)
        root.b = lines[0] + '\n' + doc + nl + ''.join(lines[1:])
    else:
        root.b = doc + nl + root.b
</t>
<t tx="ekr.20121013084734.16380">def move_shebang_line (self,c,root):
    
    '''Move a shebang line from the first child to the root.'''
    
    p = root.firstChild()
    s = p and p.b or ''
    if s.startswith('#!'):
        lines = g.splitLines(s)
        nl = '\n\n' if root.b.strip() else ''
        root.b = '@first ' + lines[0] + nl + root.b
        p.b = ''.join(lines[1:])
</t>
<t tx="ekr.20121013084734.16381">def rename_decls (self,c,root):
    
    '''Use a section reference for declarations.'''
    
    p = root.firstChild()
    h = p and p.h or ''
    
    tag = 'declarations'
    if not h.endswith(tag):
        return
        
    if not p.b.strip():
        return # The blank node will be deleted.

    name = h[:-len(tag)].strip()
    decls = g.angleBrackets(tag)
    p.h = '%s (%s)' % (decls,name)
    
    i = root.b.find('@others')
    if i == -1:
        g.trace('can not happen')
        return
    else:
        nl = '' if i == 0 else '\n'
        root.b = root.b[:i] + nl + decls + '\n' + root.b[i:]

    # p.setDirty()
    # root.setDirty()
    # root.setMarked()
    # c.setChanged(True)

    # self.changed += 1
    #g.trace('%s --&gt; %s' % (p.h,root.h))
</t>
<t tx="ekr.20121013084734.16382">def post_process (self,c,p,prefix,theTypes):
    
    '''Traverse p's tree, replacing all nodes that start with prefix
       by the smallest equivalent @path or @file node.
    '''

    assert p
    root = p.copy()
    self.fix_back_slashes(root.copy())
    prefix = prefix.replace('\\','/')
    
    # self.dump_headlines(root.copy())
    if not use_at_edit:
        self.remove_empty_nodes(c,root.copy())
    self.minimize_headlines(c,root.copy().firstChild(),prefix,theTypes)
    self.clear_dirty_bits(c,root.copy())
    
    ## self.munge_at_file(c,root.copy().firstChild())
</t>
<t tx="ekr.20121013084734.16383">def clear_dirty_bits (self,c,p):
    
    c.setChanged(False)
    for p in p.self_and_subtree():
        p.clearDirty()
</t>
<t tx="ekr.20121013084734.16384">def dump_headlines (self,p):
    
    # show all headlines.
    for p in p.self_and_subtree():
        print(p.h)
</t>
<t tx="ekr.20121013084734.16385">def fix_back_slashes (self,p):
    
    '''Convert backslash to slash in all headlines.'''

    for p in p.self_and_subtree():
        s = p.h.replace('\\','/')
        if s != p.h:
            p.h = s
</t>
<t tx="ekr.20121013084734.16386">def minimize_headlines (self,c,p,prefix,theTypes):
    
    '''Create @path nodes to minimize the paths required in descendant nodes.'''

    trace = False
    
    # This could only happen during testing.
    if p.h.startswith('@'):
        g.trace('** skipping: %s' % (p.h))
        return
        
    h2 = p.h[len(prefix):].strip()
    
    ends_with_ext = any([h2.endswith(z) for z in theTypes])
    
    if p.h == prefix:
        if trace: g.trace('@path %s' % (p.h))
        p.h = '@path %s' % (p.h)
        for p in p.children():
            self.minimize_headlines(c,p,prefix,theTypes)
    elif h2.find('/') &lt;= 0 and ends_with_ext:
            if h2.startswith('/'): h2 = h2[1:]
            if use_at_edit:
                p.h = '@edit %s' % (h2)
            elif safe_at_file:
                if trace: g.trace('@@file %s' % (h2))
                p.h = '@@file %s' % (h2)
            else:
                if trace: g.trace('@file %s' % (h2))
                p.h = '@file %s' % (h2)
            # We never scan the children of @file nodes.
    else:
        if h2.startswith('/'): h2 = h2[1:]
        if trace:
            print('')
            g.trace('@path [%s/]%s' % (prefix,h2))
        p.h = '@path %s' % (h2)
        prefix2 = prefix if prefix.endswith('/') else prefix + '/'
        prefix2 = prefix2 + h2
        for p in p.children():
            self.minimize_headlines(c,p,prefix2,theTypes)
</t>
<t tx="ekr.20121013084734.16387">def remove_empty_nodes (self,c,p):
    
    root = p.copy()
    
    # Restart the scan once a node is deleted.
    changed = True
    while changed:
        changed = False
        for p in root.self_and_subtree():
            if not p.b and not p.hasChildren():
                # g.trace('** deleting',p.h)
                p.doDelete()
                c.selectPosition(root)
                changed = True
                break
                
</t>
<t tx="ekr.20121013084734.16388">def run (self,c,p,dir_,theTypes,oneFile=False,recursive=True):
    
    '''Import all the .py files in dir_.'''

    try:
        t1 = time.time()
        p1 = p.copy()
        g.app.disable_redraw = True
        bunch = c.undoer.beforeChangeTree(p1)
        assert p == c.p
        root = p.insertAfter()
        # root.h = '@path %s' % (dir_)
        root.h = 'imported files'
        prefix = dir_
        self.import_dir(c,root.copy(),dir_,theTypes,oneFile=oneFile,recursive=recursive)
        n = 0
        for p in root.self_and_subtree():
            n += 1
        if not use_at_edit:
            self.clean_all(c,root.copy())
        self.post_process(c,root.copy(),dir_,theTypes)
        c.undoer.afterChangeTree(p1,'recursive-import',bunch)
    finally:
        g.app.disable_redraw = False
        root.contract()
        c.redraw(root)
    
    t2 = time.time()
    g.trace('imported %s nodes in %2.2f sec' % (n,t2-t1))
</t>
<t tx="ekr.20121220111212.13257">'''
&lt;&lt; about this script &gt;&gt;
'''

@others

# Change test_dir as desired: it must already exist.
test_dir = g.os_path_finalize_join(g.app.loadDir,'..','test')

if 1:
    # Writes each test to a separate file in the test directory.
    TestWriter(c,path=test_dir).run(fn=None)    
else:
    # Writes all tests to a single file: test/unit_tests.py
    TestWriter(c,path=test_dir).run(fn='unit_tests.py')
</t>
<t tx="ekr.20121220111212.13258">@language rest

This script transliterates @test nodes into .py file. The two main ways of
using this script are as follows::

    TestWriter(c,path='test').run(fn='unit_tests.py') # writes one file
    TestWriter(c,path='test').run(fn=None)            # writes separate files.
     
The first writes all tests to test/unit_tests.py; the second writes each
unit test to a separate .py file in the test directory.

The script imports each written file and reports any syntax errors.

This is a straightforward script; it should be easy to modify it to suit
individual needs.

The &lt;\&lt; file_template &gt;&gt; and &lt;\&lt; test_template &gt;&gt; sections in the TestWriter
class determines exactly what this script writes.</t>
<t tx="ekr.20121220111212.13259">class TestWriter:
    
    &lt;&lt; define file_template &gt;&gt;
    &lt;&lt; define test_template &gt;&gt;

    @others
</t>
<t tx="ekr.20121220111212.13260"># Add any other common imports here.

file_template = '''\
import unittest
'''

file_template = g.adjustTripleString(file_template,c.tab_width)</t>
<t tx="ekr.20121220111212.13261">test_template = '''
class %s (unittest.TestCase):
    def runTest(self):
%s
'''

test_template = g.adjustTripleString(test_template,c.tab_width)
</t>
<t tx="ekr.20121220111212.13262">def __init__(self,c,path=''):
    
    self.c = c
    load_dir = g.os_path_dirname(c.fileName())
    self.path = g.os_path_finalize_join(load_dir,path)
    self.nodes = []
    assert g.os_path_exists(self.path),self.path
</t>
<t tx="ekr.20121220111212.13263">def clean(self,s):
    
    '''Munge s so that it can be used as a file name.'''
    
    result,tag = [],'@test'
    if s.startswith(tag):
        s = s[len(tag):]
    for ch in s.strip():
        if ch.isalnum():
            result.append(ch)
        elif ch.isspace():
            result.append('_')
    s = ''.join(result)
    if s.endswith('.py'):
        s = s[:-3]
    return s.strip()
</t>
<t tx="ekr.20121220111212.13264">def get_body(self,p):
    
    '''Convert p.b to a valid script.'''
    
    s = g.getScript(c,p,
        useSelectedText=False,forcePythonSentinels=True,useSentinels=False)

    s = ''.join([' '*8+z for z in g.splitLines(s) if z.strip()])
    
    return s.rstrip()
</t>
<t tx="ekr.20121220111212.13265">def run(self,fn=None):
    n,p = 1,c.rootPosition()
    while p:
        if p.h.startswith('@ignore '):
            p.moveToNodeAfterTree()
        elif p.h.startswith('@test '):
            self.nodes.append(p.copy())
            if not fn:
                fn2 = self.clean(p.h)+'.py'
                self.write_file(fn2)
                self.test(fn2)
                self.nodes=[]
            n += 1
            p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if fn:
        self.write_file(fn)
        self.test(fn)
    dest = g.os_path_join(self.path,fn) if fn else self.path
    print('wrote %s tests to %s' % (n,dest))
</t>
<t tx="ekr.20121220111212.13266">def test(self,fn):
    
    '''Test the newly created file.'''
    
    import imp
    import sys

    if self.path not in sys.path:
        sys.path.append(self.path)

    assert fn.endswith('.py')
    name = fn[:-3]
    try:
        f,path,desc = imp.find_module(name,[self.path])
        imp.load_module(name,f,path,desc)
        # print('imported %s' % (name))
    except Exception:
        print('can not import: %s' % (name))
        g.es_print_exception()
</t>
<t tx="ekr.20121220111212.13267">def write_file(self,fn):

    assert g.os_path_exists(self.path),self.path
    fn = g.os_path_finalize_join(self.path,fn)
    f = open(fn,'w')
    f.write(self.file_template)
    for p in self.nodes:
        f.write(self.test_template % (self.clean(p.h),self.get_body(p)))
    f.close()
</t>
<t tx="ekr.20130810093044.16933"></t>
<t tx="ekr.20130810093044.16934"></t>
<t tx="ekr.20130810093044.16935">&gt; Moreover, support for session tracking and restoring becomes an instant
&gt; addition since just by oppening all the @path leo nodes under a "session"
&gt; node we can restore our session!

There was a thread about saving sessions some time ago.  Here's a
script from that thread which adds a @script node to your outline which
reloads the other outlines currently loaded when this outline is next
loaded.

tablist = g.findNodeAnywhere(c, '@script load tabs')
if not tablist:
    from leo.core.leoNodes import vnode
    v = vnode(c)
    v.h = '@script load tabs'
    v._linkAsNthChild(c.hiddenRootNode,
         len(c.hiddenRootNode.children))
tablist = g.findNodeAnywhere(c, '@script load tabs')
assert tablist
import time
b = ["# Generated %s\n"%time.strftime('%c')]
for oc in g.app.commanders():
    b.append("g.openWithFileName('%s', c)" % oc.fileName())
b.append("c.frame.bringToFront()")
b.append("c.setLog()")
tablist.b = '\n'.join(b)
</t>
<t tx="ekr.20130810093044.16936">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I've found that having edits on a node in one outline simultaneously
reflected in another node in another outline works surprisingly well.

I do a lot of to-do item project managing with Leo, with lists of todo
items (managed with the todo plugin) in each projects outline.

A script rapidly assembles a global list of todo items using
the .../external/leosax.py parser to scan all the project files without
leo having to fully load them.  The script builds a tree of todo items
which uses the UNLs to make them into bookmarks which can jump to the
corresponding node in the project's outline, opening it if necessary.

Which works fine for general "what should I work on next" use, but is
still clumsy if you want to edit a lot of todo items at once, adjusting
due date or priority etc.  You have to double-click the item in the
global view to jump to its source in its project's outline, edit it
there, switch back to the main outline, etc.

So now the script which generates the global view tags the items with a
marker which, when seen by the todo plugin, causes it to apply todo
item edits in the global view to the corresponding node in the
project's file as well.  This means the first time you edit a todo item
there may be a pause while that project's outline is loaded, but
everything carries on as it should afterwards, and on-going todo item
editing is quick once the outlines are loaded.

I'll push the updated todo.py code which checks for a
v.u['annotate']['src_unl'] marker to know if a todo item is a proxy for
one in another file and propagate the edits, but unless you have a
script which assembles todo items from diverse files and tags them as
proxies it doesn't really do anything.

Really I just wanted to highlight how this approach, edits on a proxy
node causing the opening and editing of a node in another outline,
really can work in a usable way - I'm sure there are all sorts of
possible applications.
</t>
<t tx="ekr.20130810093044.16937">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Kent, I echo your thoughts :)

as I was reading Terry's post I kept thinking I'd like to watch him work
sometime. A few times I've tried setting up a Todo system in Leo for
myself, but I've thus far always abandoned the project as it turned into
more work than a simpe pad and pen kept close at hand. (Albeit with
drawbacks. There's a pad at work, another at home, a 3rd in my jacket
sometimes, and content intermixed between them "on the wrong one").
</t>
<t tx="ekr.20130810093044.16938">From: "F.S." &lt;speech.free@gmail.com&gt;

It appears that the F-35 program could have benefited from your approach:
http://www.nytimes.com/2012/11/29/us/in-federal-budget-cutting-f-35-fighter-jet-is-at-risk.html?ref=us

They are still pasting paper on a wall to manage the project. Imagine if 
the project manager learned to use Leo.
</t>
<t tx="ekr.20130810093044.16939">From: Kent Tenney &lt;ktenney@gmail.com&gt;

That flow would sure make a great webcast!
</t>
<t tx="ekr.20130810093044.16940">From: Terry &lt;webtourist@gmail.com&gt;

I need to present to people who don't have leo installation, in easily 
readable format, the full content of a .leo file, not just the outline, but 
all nodes and all contents.

What do I need to do ?

===== Terry

You could run this script (below):

It only exports selected nodes, so if you want to export everything,
you have to select all the top level nodes, i.e. collapse all the nodes
so only the top level is visible, click the first one, and shift-click
the last one.

It exports to plain text... although you might be able to use the
template to describe HTML, not sure.

&gt; Terry, how do i run it ?  I'm guessing it's not at the cmdline like "python 
&gt; this_script.py" 

Right.  Paste the content into a node, then click the script-button
button to create a new button for running this script.  The button's
name will be the node's name, what it is doesn't matter but 'export'
would be an obvious choice.  Then select the node(s) you want exported
- presumably not including the node containing the script :)

Then it will ask for a file name and whether to include unexpanded
nodes.\

</t>
<t tx="ekr.20130810093044.16941">@language python

# template is everything between r""" and second """
# placeholders are H heading B body C children
# use \\n in B and C lines for conditional blank lines

template = r"""H
    B
  * C"""

lines=[]
exp_only = g.app.gui.runAskYesNoCancelDialog(
    c, 'Expanded nodes only?', 'Expanded nodes only?')
if exp_only == 'no':
    exp_only = False
    
def export_text(p, indent=''):
    
    spaces = ' '*(len(indent) - len(indent.lstrip(' ')))
    
    for line in template.split('\\n'):
        
        if 'H' in line:
            lines.append(indent + line.replace('H', p.h))
        elif 'B' in line and p.b.strip():
            prefix = line[:line.find('B')].replace('\\\\n', '\\n')
            for i in p.b.strip().split('\\n'):
                lines.append(spaces + prefix + i)
                prefix = line[:line.find('B')].replace('\\\\n', '')
            if line.endswith('\\\\n'):
                lines.append('')
        elif 'C' in line and (not exp_only or p.isExpanded()):
            prefix = line[:line.find('C')].replace('\\\\n', '\\n')
            for child in p.children():
                export_text(child, indent=spaces + prefix)
            if line.endswith('\\\\n'):
                lines.append('')
        elif 'C' not in line and 'B' not in line:
            lines.append(line)

if exp_only != 'cancel':
    for i in c.getSelectedPositions():
        export_text(i)
    
    filename = g.app.gui.runSaveFileDialog('Save to file')
    # filename = '/home/tbrown/del.txt'
    
    if filename is not None:
        open(filename,'w').write('\\n'.join(lines))
</t>
<t tx="ekr.20130810093044.16942">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Just pushed leo/external/leoftsindex.py:

Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

.. note::
    
    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::
        
        python leoftsindex.py "workbook.leo#Links"

</t>
<t tx="ekr.20130810093044.16943">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Now I have basic functionality pushed to trunk.

If you want to "spawn" (posibbly several) system commands to background,
use g.procs.add(), like this ctrl+b script:

def L(*args):
    g.es("callback", args)

g.procs.add(['sleep', '4'], "que1")
g.procs.add(['sleep', '3'], "que1", L)
g.procs.add(['sleep', '2'], "que1")
g.procs.add(['sleep', '2'], "que2")

Note how que2 completes first. Idea is that commands in same queue depend
on each other, and thus need to run in sequential order.

This should make waiting for long lasting operations easier as the whole
Leo won't freeze until they are over (but you can still use the stdout /
stderr output from these calls, thanks to the optional callback)

API may change once I start using it (soon).



On Wed, Apr 17, 2013 at 2:48 PM, Ville M. Vainio &lt;vivainio@gmail.com&gt; wrote:

&gt; Often, I find myself wanting to execute system commands in serial fashion
&gt; (first in, first out), capture their output, and allow browsing it, BUT not
&gt; blocking Leo or ipython terminal.
&gt;
&gt; I'd like to show stderr and stdout in g.es, or separate log page, and
&gt; provide callback after task has been completed.
&gt;
&gt; Unless anyone has something like this already, I plan to create it "later"
&gt; with QProcess.
&gt;

</t>
<t tx="ekr.20130810093044.16944">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 17 Apr 2013 14:48:59 +0300
"Ville M. Vainio" &lt;vivainio@gmail.com&gt; wrote:

&gt; Often, I find myself wanting to execute system commands in serial fashion
&gt; (first in, first out), capture their output, and allow browsing it, BUT not
&gt; blocking Leo or ipython terminal.
&gt; 
&gt; I'd like to show stderr and stdout in g.es, or separate log page, and
&gt; provide callback after task has been completed.

There's the leoscreen stuff for integration with the GNU `screen`
terminal switcher / manager.  Push lines from the body to the terminal,
pull lines back the other way.  But more for interactive interaction
with terminal programs than batch oriented work.  Leo doesn't block.

Cheers -Terry

&gt; Unless anyone has something like this already, I plan to create it "later"
&gt; with QProcess.
&gt; 

</t>
<t tx="ekr.20130810093044.16945">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I've added an abbreviation to my myLeoSettings.leo abbreviations:
https://gist.github.com/tbnorth/5530059

It's the abbreviation "persist;;" and when you type that you get:

---cut here---
import json

json_state_file = "cache_info_file.json"
if not os.path.exists(json_state_file):
    json.dump({'cache_items':{}}, open(json_state_file, 'w'))
cache_info = json.load(open(json_state_file))

def main():

    # do stuff with cache_info...

if __name__ == '__main__':

    try:
        main()
    except:
        json.dump(cache_info, open(json_state_file, 'w'))
---cut here---

with appropriate interaction to customize all the parts which, in the
above example, include "cache_", i.e. the filename and the variable
name.

The point is it seems silly to create a module and hence a dependency
for what is barely 4 lines of actual code, but those 4 lines give you
very handy robust persistence, so something like an editor abbreviation
is the obvious way to make the available - nothing Leo specific here,
except that only serious editors have abbreviation like that ;-).
</t>
<t tx="ekr.20130810093044.16946">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, May 23, 2013 at 2:41 PM, Terry Brown &lt;terry_n_brown@yahoo.com&gt;wrote:

&gt; I've added [an abbreviation] "persist;;"

[snip]

How do you use the code inserted by the abbreviation?  I suspect I'm not
the only one who doesn't understand what you are trying to do...
</t>
<t tx="ekr.20130810093044.16947">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

p.s. the 'except:' in the code below should have been 'finally:', fixed
on the gist now.

On Thu, 23 May 2013 14:41:31 -0500
Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; I've added an abbreviation to my myLeoSettings.leo abbreviations:
&gt; https://gist.github.com/tbnorth/5530059
&gt; 
&gt; It's the abbreviation "persist;;" and when you type that you get:
&gt; 
&gt; ---cut here---
&gt; import json
&gt; 
&gt; json_state_file = "cache_info_file.json"
&gt; if not os.path.exists(json_state_file):
&gt;     json.dump({'cache_items':{}}, open(json_state_file, 'w'))
&gt; cache_info = json.load(open(json_state_file))
&gt; 
&gt; def main():
&gt; 
&gt;     # do stuff with cache_info...
&gt; 
&gt; if __name__ == '__main__':
&gt; 
&gt;     try:
&gt;         main()
&gt;     except:
&gt;         json.dump(cache_info, open(json_state_file, 'w'))
&gt; ---cut here---
&gt; 
&gt; with appropriate interaction to customize all the parts which, in the
&gt; above example, include "cache_", i.e. the filename and the variable
&gt; name.
&gt; 
&gt; The point is it seems silly to create a module and hence a dependency
&gt; for what is barely 4 lines of actual code, but those 4 lines give you
&gt; very handy robust persistence, so something like an editor abbreviation
&gt; is the obvious way to make the available - nothing Leo specific here,
&gt; except that only serious editors have abbreviation like that ;-).
&gt; 
&gt; Cheers -Terry
&gt; 

</t>
<t tx="ekr.20130810093044.16948">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Fri, 24 May 2013 16:35:59 -0500
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; On Thu, May 23, 2013 at 2:41 PM, Terry Brown &lt;terry_n_brown@yahoo.com&gt;wrote:
&gt; 
&gt; &gt; I've added [an abbreviation] "persist;;"
&gt; 
&gt; 
&gt; [snip]
&gt; 
&gt; How do you use the code inserted by the abbreviation?  I suspect I'm not

The corrected version is below for reference - I had `except` instead
of `finally` in the first version, so you data was only saved if
something went wrong :-)

It's just a framework for providing a dictionary the contents of which
persist between runs of the program.  I've used it for code that's
making lots of small url requests against a server, to cache the
results so that during development the crash / debug / re-run cycle is
faster because each piece of data is requested only once, ever, not once
every run.  More recently I was using it to store key value pairs of
filenames and a comment on the issue in the file, knowing that
completing the analysis of the issues in the files would take more than
one run of the program which was identifying the issues.

So in the example below, the content of the cache_info dictionary is
persistent, whatever main() does with it is seen next time the
program's run.  Nothing Leo specific except that it's really just an
import statement plus 5 lines of code and doesn't seem worth its own
file, but is more than you want to re-type all the time either, so
ideal for an abbreviation in your favorite editor.

I've added a couple of comments in the version below.

Cheers -Terry

---cut here---
import json

# name for persistent data store
json_state_file = "cache_info_file.json"   
if not os.path.exists(json_state_file):
    # create persistent data store if it doesn't exist
    json.dump({'cache_items':{}}, open(json_state_file, 'w'))
# load persistent data
cache_info = json.load(open(json_state_file))

def main():

    # do stuff with cache_info...

if __name__ == '__main__':

    try:
        main()
    finally:
        # save altered persistent data
        json.dump(cache_info, open(json_state_file, 'w'), indent=4)
---cut here---

&gt; the only one who doesn't understand what you are trying to do...
&gt; 
&gt; Edward
&gt; 

</t>
<t tx="ekr.20130810093044.16949">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

The script below is a tool for diffing two Leo files. The attached
screenshot illustrates the output for two different revisions of
LeoPyRef.leo.

``- nodename``
    indicates a node which disappeared
``+ nodename``
    a node which is new,
``!v nodename`` followed by ``!^ nodename``
    a node with an unchanged heading but changed content, the first
    linking to the old version, the second linking to the new version

If you have the bookmarks.py plugin active, you can double click nodes
to jump to the original(s).



from leo.core.leoNodes import vnode
if not hasattr(vnode, 'insertAsLastChild'):
    # add insertAsLastChild method to vnodes
    def ialc(self):
        vnode(self.context)._linkAsNthChild(self, len(self.children))
        return self.children[-1]
    vnode.insertAsLastChild = ialc

from_filename = g.app.gui.runOpenFileDialog('From (old) file', [('Leo', '*.leo')])
to_filename = g.app.gui.runOpenFileDialog('To (new) file', [('Leo', '*.leo')])

# from_filename = "/mnt/shuttle/bkup/usr1/2012-07-13/home/tbrown/.leo/.todo.leo"
# to_filename = "/mnt/shuttle/bkup/usr1/2012-07-15/home/tbrown/.leo/.todo.leo"

from_c = g.openWithFileName(from_filename, c)
to_c = g.openWithFileName(to_filename, c)

vf = from_c.hiddenRootNode
vt = to_c.hiddenRootNode

assert from_c != c
assert to_c != c
assert from_c != to_c

nd = c.rootPosition().insertAfter()
nd.copy().back().moveAfter(nd)
nd.h = 'diff @bookmarks'

def text_match(a, b):
    return (a.h == b.h, 
            a.h == b.h and a.b == b.b)
def gnx_match(a, b):
    return (a.h == b.h and a.gnx == b.gnx, 
            a.h == b.h and a.b == b.b and a.gnx == b.gnx)

def diff_trees(vf, vt, path):

    fonly = []  # nodes only in from tree
    tonly = []  # nodes only in to tree
    diffs = []  # nodes which occur in both but have different descendants

    # count number of times each headline occurs as a child of
    # each node being compared
    count_f = {}
    for cf in vf.children:
        count_f[cf.h] = count_f.get(cf.h, 0) + 1
    count_t = {}
    for ct in vt.children:
        count_t[ct.h] = count_t.get(ct.h, 0) + 1

    for cf in vf.children:
        
        for ct in vt.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            
            if body_eq:
                diffs.append(diff_trees(cf, ct, path+[vf.h]))
                
                break
            elif head_eq:
                d = diff_trees(cf, ct, path+[vf.h])
                if d:
                    d.h = '!v '+d.h
                else:
                    d = vnode(nd.v.context)
                    d.h = '!v '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    from_filename, 
                    '--&gt;'.join((path+[vf.h]+[cf.h])[1:]),
                    cf.b
                )
                diffs.append(d)
                d = vnode(nd.v.context)
                d.h = '!^ '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    to_filename, 
                    '--&gt;'.join((path+[vt.h]+[ct.h])[1:]),
                    ct.b
                )
                diffs.append(d)
                break
        else:
            fonly.append(cf)
            
    for ct in vt.children:
        
        for cf in vf.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            if head_eq or body_eq:
                # no need to recurse matches again
                break

        else:
            tonly.append(ct)

    if not any(diffs) and not fonly and not tonly:
        return None
        
    vd = vnode(nd.v.context)
    vd.h = vf.h
    for d in diffs:
        if d:
            vd.children.append(d)
    for f in fonly:
        n = vd.insertAsLastChild()
        n.h = '- '+f.h
        n.b = "file://%s/#%s" % (from_filename, '--&gt;'.join((path+[vf.h]+[f.h])[1:]))
    for t in tonly:
        n = vd.insertAsLastChild()
        n.h = '+ '+t.h
        n.b = "file://%s/#%s" % (to_filename, '--&gt;'.join((path+[vf.h]+[t.h])[1:]))
        
    return vd

v = diff_trees(vf, vt, [])
if v:
    nd.v.children.extend(v.children)  # snip off &lt;hidden root node&gt;

c.bringToFront()
c.redraw()

</t>
<t tx="ekr.20130810093044.16950">From: resi147 &lt;scalet@yebu.de&gt;

I tried this one and it seems to be very useful. What I would also like to 
have is a similar (or the same) script,
that does the same on two different nodes of a leo file. I admit, the 
changes should be minimal to be done by
myself, but as I'm not familiar with the internal leo api, I wanted to ask 
for how to best do this changes.

Probably somewhere here
"""
...
vf = from_c.hiddenRootNode 
vt = to_c.hiddenRootNode
...
"""
just to feed in the 2 nodes, Any quick idea how this can be done the best 
way?

Cheers,
Karl.

</t>
<t tx="ekr.20130810093044.16951"></t>
<t tx="ekr.20130810093044.16952">The script itself is in scripts.leo: cleanup-imported-nodes

- Put docstring in root node.
- Use section reference for declarations.
- Remove leading and trailing blank lines from all nodes, leaving only a trailing newline.
- If a new contains nothing but comments, merge it with the next node.
- If a node contains nothing but a property, merge it with the previous node.

The holy grail would be to do all this in the Python importer, but a post-processing script suffices.

Workflow:
    
1. bzr checkin of all *unchanged* file.
2. Import all files and save.
3. bzr commit all changed files.
4. Run cleanup script.
5. bzr qdiff then shows all cleanups.
6. bzr commit if all goes well.
</t>
<t tx="ekr.20130810093044.16953">Edward K. Ream &lt;edreamleo@gmail.com&gt;

A new script, now in scripts.leo, cleans up imported @file nodes as follows:

- Moves a shebang line from the first child to the root.
- Moves a leading docstring in the first child to the root.
- Uses a section reference for declarations.
- Removes leading and trailing blank lines from all nodes.
- Merges a node containing nothing but comments with the next node.
- Merges a node containing no class or def lines with the previous node.

The Aha: dealing with trees *after* they have been created is much
easier than creating the tree in the first place.

It would be impossible to conceive of this script in any other environment.
Leo's node structure drastically simplifies the patterns to be discovered.
</t>
<t tx="ekr.20130810093044.16954">@language python

'''Script to create global data structures from modes/*.py files.'''

import glob
import imp

g.cls()

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

# print('-'*40)
known_keys = list(g.app.language_delims_dict.keys())
new_languages = {}

for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2 in known_keys or name2.startswith('__'):
        if 0: print('ignore: %s' % (name2))
    else:
        try:
            theFile, pathname, description = imp.find_module(name2,[theDir])
            m = imp.load_module(name2, theFile, pathname, description)
            if hasattr(m,'properties'):
                # new_languages.append(name2)
                new_languages[name2] = m
            else:
                print('no properties: %s %s' % (name2,m))
        except Exception:
            g.es_exception()
            
print('%s new languages\n' % (len(list(new_languages.keys()))))
    
for key in sorted(new_languages.keys()):
    m = new_languages.get(key)
    aList2 = [m.properties.get(z)
        for z in ('lineComment','commentStart','commentEnd')
            if m.properties.get(z)]
    print('%-20s : "%s",' % (
        '"%s"' % (key),
        ' '.join(aList2)))
    # computed[name2] = ' '.join(aList2)
       
if 0:
    mismatches = 0
    print()
    for z in known_keys:
        val = g.app.language_delims_dict.get(z)
        val2 = computed.get(z)
        if not val:
            print('no val',z)
        elif not val2:
            print('no val2',z)
        elif val != val2:
            mismatches += 1
            print('mismatch for %s. expected %s got %s' % (z,repr(val),repr(val2)))
            print(repr(val))
            print(repr(val2))
    print('%s mismatches' % mismatches)
</t>
<t tx="ekr.20130810093044.16955">@language python

'''Slow script.'''

import glob
import imp

@others

if 0: # The other script is much faster.
    
    keys = ("lineComment","commentStart","commentEnd",)
    d = {}
        # Keys are language names.
        # Values are a list of comment delims, in keys order.
    
    paths,modes_path = get_paths()
    for path in paths:
        module_name = g.shortFileName(path)[:-3]
        module = import_module(module_name,modes_path)
        aList = []
        for key in keys:
            val = module.properties.get(key)
            if val: aList.append(val)
        d[module_name] = aList
    
    print('-'* 20)
    print('language_delims_dict')
    for key in sorted(d):
        print('%16s: "%s"' % ('"%s"' % (key),' '.join(d.get(key))))
</t>
<t tx="ekr.20130810093044.16956">def get_paths():
    
    modes_path = g.os_path_finalize_join(g.app.loadDir,'..','modes')
    pattern = g.os_path_finalize_join(modes_path,'*.py')
    paths = glob.glob(pattern)
    paths = [z for z in paths if not z.endswith('__init__.py')]
    return paths,modes_path
</t>
<t tx="ekr.20130810093044.16957">def import_module(module_name,modes_path):
    
    data = imp.find_module(module_name,[modes_path])
        # This can open the file.
    theFile,pathname,description = data
    module = imp.load_module(module_name,theFile,pathname,description)
    return module
</t>
<t tx="ekr.20130810093044.16958"></t>
<t tx="ekr.20130810093044.16959">class ImportOrgMode:
    @others

def importOrgMode (self,event):
    c = self.c
    self.ImportOrgMode(c).go(c.p)
    c.bodyWantsFocus()

if False and g.app.inScript:
    print('='*40)
    ImportOrgMode(c).test()
    print('done')
</t>
<t tx="ekr.20130810093044.16960">def __init__ (self,c):
    
    self.c = c
</t>
<t tx="ekr.20130810093044.16961">def go (self,p):
    
    '''Prompt for a file and pass the contents to scan().'''
</t>
<t tx="ekr.20130810093044.16962">def scan (self,fn,p,s):

    self.c = c
    root = p.insertAsLastChild()
    root.h = fn
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        g.trace(repr(s))
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1
                level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
                last = None
            elif level == len(stack):
                last = stack[-1]
                last.b = ''.join(body)
            else:
                last = stack[-1]
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            p = parent.insertAsLastChild()
            p.h = s.strip()
            stack.append(p)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        parent = stack[-1]
        parent.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20130810093044.16963">def test (self):
    
    s = '''
* A1
    a1.1
    a1.2
** B11
** B12
b12.1
*** C121
c121.1
    c121.2
c121.3
* A2
a2.1
** B21
*** C211
c211.1
*** C212
** B22
    b22.1
b22.1
* A3
* A4
a4.1
* A5
** B51
*** C511
**** D5111
***** E51111
** B52
*** C521
c521.1
'''

    tag = 'test-import-org-mode'
    p = g.findNodeAnywhere(c,tag)
    s = g.adjustTripleString(s,-4)
    if p:
        try:
            self.scan('test-file',p,s)
        except Exception:
            c.redraw(p)
    else:
        print('not found: %s' % tag)
</t>
<t tx="ekr.20130810093044.16964">'''Import each file in the files list after the presently selected node.'''


files = (
    r'c:\Users\edreamleo\test\import-org-mode.txt',
    r'c:\Users\edreamleo\test\import-org-mode.txt',
)

@others

for fn in files:
    try:
        root = c.p.copy()
        f = open(fn)
        s = f.read()
        scan(c,fn,s)
        c.selectPosition(root)
    except IOError:
        print('can not open %s' % fn)
</t>
<t tx="ekr.20130810093044.16965">def scan (c,fn,s):

    last = root = c.p.insertAsLastChild()
    last.h = g.shortFileName(fn)
    level,stack = 0,[root]
    body = ['@others\n']
    
    for s in g.splitLines(s):
        if s.startswith('*'):
            i,level = 0,0
            while s[i] == '*':
                i += 1 ; level += 1
            if level &gt; len(stack):
                g.trace('bad level',repr(s))
            elif level == len(stack):
                last.b = ''.join(body)
            else:
                last.b = ''.join(body)
                stack = stack[:level]
            parent = stack[-1]
            last = parent.insertAsLastChild()
            last.h = s.strip()
            stack.append(last)
            body = []
        else:
            body.append(s)
            
    # Finish any trailing lines.
    if body:
        last.b = ''.join(body)
        
    root.contract()
    c.redraw(root)
</t>
<t tx="ekr.20130810093044.16966"></t>
<t tx="ekr.20130810093044.16967">Should Leo support a standard template tool?
http://groups.google.com/group/leo-editor/browse_thread/thread/dd629473f4b3c4fc

Added a jinja2 templating example.  See:
    
file://../scripts/scripts.leo#Scripts--&gt;@thin%20leoScripts.txt--&gt;Important--&gt;Prototype%20of%20jinja%20@command%20nodes
</t>
<t tx="ekr.20130810093044.16968">6/2/12

The recursive import script now contains a suite of post-processing fixes:

- Replacing backslashes with forward slashes in headlines.
- Removing empty nodes.
- Adding @path directives that reduce the needed path specifiers in descendant nodes.
- Adding @file to nodes or replacing @file with @@file.


No matter how good Leo's importers are, (and they are now quite good),
there will *always* be cases where thoughtful human intervention will be
required.

Some import mistakes can *only* be found by running tests.  For
complex programs like 2to3, the only truly safe way to check imports
is by running the 2to3 test suite.
</t>
<t tx="ekr.20130810093044.16969"></t>
<t tx="ekr.20130810093044.16970">From Brian Theado

The other day I stumbled across Ville's code in scripts.leo which displays the
output of python's trace module in a leo outline. The output of the trace module
is not very friendly and I didn't find the result very usable. I was inspired to
write some code to translate the output so the tree of function calls is
displayed via Leo headlines. Thanks to Ville for sharing that code. I never
would have figure this out without that starting point.

Just copy (Ctrl-Shift-V) the child outline into a leo outline and hit ctrl-b on
the "call tree" node. The execution tree of the 'scroll-outline-up-line'
minibuffer command will be displayed to stdout and also as a tree of leo
headlines.
</t>
<t tx="ekr.20130810093044.16971">import trace

@language python
@others

# http://docs.python.org/library/trace.html for documentation
# on the trace module
tracer = trace.Trace(countcallers=1)

# Trace a minibuffer command.

# Any function call will work. Leo's minibuffer commands are easily discoverable
# via tab completion and the 'print-commands' command.

#tracer.runfunc(c.executeMinibufferCommand, 'goto-prev-node')
tracer.runfunc(c.executeMinibufferCommand, 'scroll-outline-up-line')

top = p.insertAsLastChild().copy()
top.h = 'trace session'
displayCalltree(top, tracer.results().callers.keys())
c.redraw()
</t>
<t tx="ekr.20130810093044.16972">def displayCalltree(p, callinfo):
   '''
   Converts the function call hierarchy in 'callinfo' into a tree of function
   calls.  The function call tree is displayed to stdout as indented text
   and is inserted as a tree of leo nodes rooted at the given position 'p'
   '''
   callers = [k[0] for k in callinfo]
   callees = [k[1] for k in callinfo]

   # The first set of children will be those that don't have any callers
   # listed in callinfo
   toplevels = list(set(callers) - set(callees))
   positions = {}
   path = []

   # Depth-first traversal of the call hierarchy represented by 'callinfo'
   # 'levels' is a stack which grows during descend and shrinks
   # during ascend.  Each element of 'levels' is a list of unprocessed
   # siblings of each other
   levels = [toplevels]
   while len(levels) &gt; 0:
       while len(levels[-1]) &gt; 0:
           # Process the first element in the 'deepest' (i.e. last) list of siblings
           cur = levels[-1][0]
           levels[-1] = levels[-1][1:]
           indent = " " * 4 * (len(levels)-1)
           if cur not in path:
               if cur in positions.keys():
                   # Function already seen, so make a clone
                   clone = positions[cur].clone()
                   clone.moveToLastChildOf(p)
                   print (indent + "%s %s ..." % cur[1:])
               else:
                   # Haven't seen this function, so insert a new headline
                   p = p.insertAsLastChild().copy()
                   p.h = "%s %s" % cur[1:]
                   print (indent + p.h)

                   # Remember the position so it can be cloned if seen again
                   positions[cur] = p

                   # Find all callees of this function and descend
                   levels.append([c[1] for c in callinfo if c[0] == cur])
                   path.append(cur)
           else:
               r = p.insertAsLastChild().copy()
               r.h = "(recursive call) %s %s" % (cur[1], cur[2])
               print(indent + r.h + "...")

       # Ascend back up one level
       path = path[0:-1]
       p = p.parent()
       levels = levels[0:-1]
</t>
<t tx="ekr.20130810093044.16973"></t>
<t tx="ekr.20130812034101.12556"></t>
<t tx="ekr.20130812034101.12558">@language python

@ Matt Wilkie &lt;maphew@gmail.com&gt;

Here is a recipe using the pip python installer, that adds docutils to
python 3 in about 5 minutes. Ideally the same template/process would be
extended for all of Leo, and wrapped up in a nice package.

Depends on win32 `curl.exe` being available,
http://curl.haxx.se/dlwiz/?type=bin&amp;os=Win32&amp;flav=-&amp;ver=-

There are lots of scary looking warnings and messages emitted to the
console, mostly about unicode and files looked for and not found. A couple
of places I needed to tap [enter] (with no prompt saying that was
necessary). At the "install docutils" stage there was a long pause with
nothing apparent happening, perhaps 3 minutes.

The command shell was a generic windows cmd.exe shell with no python
variables set (e.g. PYTHONPATH, PYTHONHOME, etc.)

Recipe adapted from http://trac.osgeo.org/osgeo4w/wiki/ExternalPythonPackages
@c

pushd c:\\python32

:: test for docutils
python -c "import docutils; dir(docutils)"

::Traceback (most recent call last):
::  File "&lt;string&gt;", line 1, in &lt;module&gt;
::ImportError: No module named docutils

:: install python `distribute`
curl http://python-distribute.org/distribute_setup.py | python

:: install pip
curl --insecure https://raw.github.com/pypa/pip/master/contrib/get-pip.py |
python

::install docutils
.\\scripts\\pip.exe install docutils

:: test that docutils is available
python -c "import docutils; help(docutils)"

::Help on package docutils:
::
::NAME
::    docutils - This is the Docutils (Python Documentation Utilities)
package.
::
::DESCRIPTION
::    Package Structure
::    =================
::: ...snip...
</t>
<t tx="ekr.20130812034101.12566">From: Matt Wilkie &lt;maphew@gmail.com&gt;

http://bazaar.launchpad.net/~maphew/leo-editor/pypi-packaging/view/head:/register-leo.leos

QQQQ
Tell Windows how to handle .leo files, enables double clicking on them to
open.

To run: in Leo make this the active node and press [Ctrl-B] (execute-script)

Requires elevated User Account Control (UAC) privileges.
QQQQ

It is only lightly tested (one machine), but it seems to work. If
successful, it takes over the need for the assoc and ftype commands and
batch files which have been bobbing about lately (mostly be myself
admittedly).

It's stored in an @file instead of .leo in order to make it easier to track
in bazaar. Is there a naming convention for leo script files? I used .leos
for "leo script", but it occurs to me that .leox might be better (leo
executable) as it sidesteps the inadvertent pluralizing association.
</t>
<t tx="ekr.20130812034101.12567">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

--001a11c1a67459191904dc5b8b8c


On Fri, May 10, 2013 at 4:03 AM, Matt Wilkie &lt;maphew@gmail.com&gt; wrote:

It's stored in an @file instead of .leo in order to make it easier to track
&gt; in bazaar.
&gt;

which .leo file?

Edward

--001a11c1a67459191904dc5b8b8c


&lt;div dir="ltr"&gt;On Fri, May 10, 2013 at 4:03 AM, Matt Wilkie &lt;span dir="ltr"&gt;&amp;lt;&lt;a href="mailto:maphew@gmail.com" target="_blank"&gt;maphew@gmail.com&lt;/a&gt;&amp;gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;br&gt;&lt;div class="gmail_extra"&gt;&lt;div class="gmail_quote"&gt;
&lt;blockquote class="gmail_quote" style="margin:0 0 0 .8ex;border-left:1px #ccc solid;padding-left:1ex"&gt;&lt;div dir="ltr"&gt;&lt;div&gt;It&amp;#39;s stored in an @file instead of .leo in order to make it easier to track in bazaar. &lt;/div&gt;&lt;/div&gt;
&lt;/blockquote&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;which .leo file?&lt;br&gt;&lt;br&gt;Edward&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

--001a11c1a67459191904dc5b8b8c--
</t>
<t tx="ekr.20130812034101.12568">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Here is a Leo script which attempts to tell Windows how to handle .leo
files, enabling 2x-click "some-workbook.leo" to start. On win7+ it requires
Leo be started with elevated admin privileges.


{{{
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;
&lt;leo_header file_format="2"/&gt;
&lt;vnodes&gt;
&lt;v t="maphew.20130429234409.2286"&gt;&lt;vh&gt;assoc leo&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="maphew.20130429234409.2286"&gt;pyexe = g.sys.executable
tmp = g.os.environ['TEMP']

assoc_cmd = 'assoc .leo=Leo.File'
ftype_cmd = 'ftype Leo.File="{0}" "%1" %*'.format(pyexe)

#g.es(pyexe)
#g.es(tmp)
g.es(assoc_cmd)
g.es(ftype_cmd)

from subprocess import Popen
Popen('start "Shell from Leo" cmd.exe /k %s &amp;amp;&amp;amp; %s' % (assoc_cmd,
ftype_cmd),
    cwd=tmp, shell=True)
&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
}}}

</t>
<t tx="ekr.20130812034101.12569">From: Matt Wilkie &lt;maphew@gmail.com&gt;

whups, sent before ready!

to use select and copy text between braces, {{{  }}}, into a Leo outline,
select the new node and press Ctrl-B.

adapted from
http://stackoverflow.com/questions/8985925/how-to-control-what-version-of-python-is-run-when-double-clicking-a-file/

-matt

</t>
<t tx="ekr.20130812034101.12570">From: Matt Wilkie &lt;maphew@gmail.com&gt;

The leo script below _almost_ adds an icon to .leo files in Windows. I say
almost in that on my system it runs without error, the associated registry
key is created and contains the right path, but Windows still doesn't know
what to do with the file.

It's intended to be run after "create-leobat" has been run and the Leo.File
filetype is already present.

Anyone else have some ideas how to improve it?

thanks!

-matt


{{{
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" &gt;
&lt;leo_header file_format="2"/&gt;
&lt;vnodes&gt;
&lt;v t="maphew.20130509185752.1607"&gt;&lt;vh&gt;Set icon for .leo files&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="maphew.20130509185752.1607"&gt;from _winreg import *
def register_leo_icon():
    '''Tell Windows what icon to use for the  Leo.File filetype (.leo)

    Resources:

http://stackoverflow.com/questions/2331690/how-to-set-a-icon-file-while-creating-file

http://stackoverflow.com/questions/771689/how-can-i-set-an-icon-for-my-own-file-extension
    '''

    icon = "%s\\Icons\\LeoDoc.ico" % g.computeLeoDir()

    g.es("\\nAttempting to register leo icon with .leo files...")

    if g.os_path_exists(icon):
        g.es("Found:", icon)
        myTestKey = OpenKey(HKEY_CLASSES_ROOT, "Leo.File")
        iconKey= CreateKey(myTestKey, "DefaultIcon")
        CloseKey(myTestKey)

        SetValue(iconKey, None, REG_SZ, icon)
        CloseKey(iconKey)
        g.es("Registered!")
    else:
        g.es("LeoDoc.ico not in expected location, can't continue.")
&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
}}}
</t>
<t tx="ekr.20130816100419.23046">@language python

&lt;&lt; docstring &gt;&gt;

from PyQt4 import QtGui, QtCore
from xml.sax.saxutils import escape

def add_html(html, nd):
    """recursively add to an html list with links to nodes"""
    
    unl = nd.get_UNL()
    html.append("&lt;div class='level'&gt;"
        "&lt;div&gt;&lt;a href='%s' title='%s'&gt;%s&lt;/a&gt;&lt;/div&gt;" %
        (unl, unl, escape(nd.h)))
    html.append("&lt;pre&gt;%s&lt;/pre&gt;"%escape(nd.b))
    for child in nd.children():
        add_html(html, child)
    html.append("&lt;/div&gt;")

def make_overview(c):
    """build the overview widget"""

    te = QtGui.QTextBrowser()
    te.setReadOnly(True)
    te.setOpenLinks(False)
    
    def anchorClicked(url, c=c, te=te):
        
        url = str(url.toString())
        g.handleUrl(url,c=c,p=c.p)
        
        if te.ctrl_click:
            te.deleteLater()
        
    te.anchorClicked.connect(anchorClicked)
    
    def mousePressEvent(event, te=te, original=te.mousePressEvent):
        te.ctrl_click = bool(event.modifiers() &amp; QtCore.Qt.ControlModifier)
        original(event)
    
    te.mousePressEvent = mousePressEvent
    
    html = ["""&lt;html&gt;&lt;head&gt;&lt;style&gt;
    .level .level {margin-left: 1.5em}
    a {text-decoration: none; font-size: 120%}
    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;"""]
    
    for nd in c.getSelectedPositions():
        add_html(html, nd)

    html.append("&lt;/body&gt;&lt;/html&gt;") 
    
    html = '\\n'.join(html)
    
    te.setHtml(html)
    
    return te

class OverviewPaneProvider:
    def __init__(self, c):
        self.c = c
        # Careful: we may be unit testing.
        if hasattr(c, 'free_layout'):
            splitter = c.free_layout.get_top_splitter()
            if splitter:
                splitter.register_provider(self)
    def ns_provides(self):
        return[('Overview', '_add_overview_pane')]
    def ns_provide(self, id_):
        if id_ == '_add_overview_pane':
            w = make_overview(c)
            return w
    def ns_title(self, id_):
        if id_ == '_add_overview_pane':
            return "Leo Outline Overview"
    def ns_provider_id(self):
        # used by register_provider() to unregister previously registered
        # providers of the same service
        return "outline overview window"

OverviewPaneProvider(c)
</t>
<t tx="ekr.20130816100419.23047">''' The script sets up Leo to display all the parts of the tree (all bodies
and subheadings) as continuous text, much like a word processor outline.

By Terry Brown

1) Paste the code below into a node, then hit the "run-script" button.

2) Then select a node with some hierarchy, not too much.

3) Then right click on the panel dividers between the tree / body / log
   panes, you should see a context menu with an "Open Window" sub-menu,
   which should contain an "Overview" item.

You should get a continuous view of the hierarchy with clickable
headlines which take you to the node.

You can select multiple nodes in step 2 above, with normal list Ctrl-
or Shift- click operations.  Nodes are shown in the overview in the
order selected.  This is how you'd generate the overview for a whole
outline - i.e. contract the whole outline, click the first top level
node, shift click the last top level node, and then step 3.

You can also embed the overview in a pane in the Leo window by select
"Insert" rather than "Open window" in step 3, click the action button
and select Overview.

This was the low hanging fruit, based on code used in bookmarks.py.  A
refresh button for the outline wouldn't be too hard, but right now
you need to close the window / pane and open it again to refresh.
'''
</t>
<t tx="maphew.20130612230051.2793">Scripts only of interest when on Microsoft Windows platform.</t>
</tnodes>
</leo_file>
