<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954"><vh>Startup</vh>
<v t="ekr.20150302053516.3"><vh>@settings</vh></v>
<v t="ekr.20070427110751"><vh>@chapters</vh></v>
<v t="ekr.20111017085134.16069"><vh>Disabled buttons</vh>
<v t="ekr.20111017085134.16070"><vh>@@button jython</vh></v>
<v t="ekr.20111017085134.16071"><vh>@@button pydoc</vh></v>
<v t="ekr.20111017085134.16072"><vh>@@button check-dirty</vh></v>
<v t="ekr.20111017085134.16073"><vh>@@button Ipython</vh></v>
<v t="ekr.20111017085134.16074"><vh>@@button Lines Down</vh>
<v t="ekr.20111017085134.16075"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20111017085134.16076"><vh>@@button Lines Up</vh>
<v t="ekr.20111017085134.16077"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20111017085134.16078"><vh>@@button lispCall @key=alt+6</vh>
<v t="ekr.20111017085134.16079"><vh>ctor</vh></v>
<v t="ekr.20111017085134.16080"><vh>run &amp; helpers</vh>
<v t="ekr.20111017085134.16081"><vh>findCalls</vh></v>
<v t="ekr.20111017085134.16082"><vh>findDefs</vh></v>
<v t="ekr.20111017085134.16083"><vh>stripComments</vh></v>
<v t="ekr.20111017085134.16084"><vh>stripLispIds</vh></v>
<v t="ekr.20111017085134.16085"><vh>stripStrings</vh></v>
</v>
<v t="ekr.20111017085134.16086"><vh>class token</vh></v>
<v t="ekr.20111017085134.16087"><vh>choose</vh></v>
<v t="ekr.20111017085134.16088"><vh>dumpList</vh></v>
<v t="ekr.20111017085134.16089"><vh>Parsing...</vh>
<v t="ekr.20111017085134.16090"><vh>parse</vh></v>
<v t="ekr.20111017085134.16091"><vh>scan &amp; helpers</vh>
<v t="ekr.20111017085134.16092"><vh>skipComment</vh></v>
<v t="ekr.20111017085134.16093"><vh>skipId</vh></v>
<v t="ekr.20111017085134.16094"><vh>skipString</vh></v>
</v>
<v t="ekr.20111017085134.16095"><vh>scanForest</vh></v>
</v>
<v t="ekr.20111017085134.16096"><vh>Code generators...</vh>
<v t="ekr.20111017085134.16097"><vh>gen</vh></v>
<v t="ekr.20111017085134.16098"><vh>gen_token</vh></v>
<v t="ekr.20111017085134.16099"><vh>gen_block &amp; helper</vh>
<v t="ekr.20111017085134.16100"><vh>gen_block_id</vh></v>
</v>
<v t="ekr.20111017085134.16101"><vh>gen_call &amp; helper</vh>
<v t="ekr.20111017085134.16102"><vh>gen_arg</vh></v>
</v>
<v t="ekr.20111017085134.16103"><vh>gen_def</vh></v>
<v t="ekr.20111017085134.16104"><vh>gen_if &amp; helpers</vh>
<v t="ekr.20111017085134.16105"><vh>gen_then</vh></v>
</v>
<v t="ekr.20111017085134.16106"><vh>gen_expr</vh></v>
<v t="ekr.20111017085134.16107"><vh>gen_let &amp; helper</vh>
<v t="ekr.20111017085134.16108"><vh>gen_let_bindings</vh></v>
</v>
<v t="ekr.20111017085134.16109"><vh>put...</vh>
<v t="ekr.20111017085134.16110"><vh>put </vh></v>
<v t="ekr.20111017085134.16111"><vh>put_token</vh></v>
<v t="ekr.20111017085134.16112"><vh>put_code &amp; put_code_line</vh></v>
<v t="ekr.20111017085134.16113"><vh>put_code_token</vh></v>
</v>
</v>
</v>
<v t="ekr.20111017085134.16114"><vh>@@button outlineToClipboard</vh></v>
</v>
<v t="ekr.20141116105945.2"><vh>@persistence</vh>
<v t="ekr.20141116105945.3"><vh>@data:@auto create-leobat.bat</vh>
<v t="ekr.20141116105945.4"><vh>@gnxs</vh></v>
</v>
</v>
</v>
<v t="ekr.20061008055616"><vh>Scripts</vh>
<v t="ekr.20110914030246.2405"><vh>@file gen_blender_docs.py</vh></v>
<v t="ekr.20051110111150" descendentVnodeUnknownAttributes="7d71005506302e352e323371017d710258120000007273745f687474705f61747472696275746571035d71042858460000003c6120636c6173733d22746172676574222069643d22687474702d6e6f64652d6d61726b65722d333922206e616d653d22687474702d6e6f64652d6d61726b65722d3339223e710558040000003c2f613e71065d71072858340000003c64697620636c6173733d2273656374696f6e222069643d2272756e6e696e672d6c656f2d696e2d62617463682d6d6f6465223e710858060000003c2f6469763e71095d710a28583f0000003c64697620636c6173733d22646f63756d656e74222069643d22636861707465722d372d736372697074696e672d6c656f2d776974682d707974686f6e223e710b58060000003c2f6469763e710c5d710d2858060000003c626f64793e710e58070000003c2f626f64793e710f5d71102858430000003c68746d6c20786d6c6e733d22687474703a2f2f7777772e77332e6f72672f313939392f7868746d6c2220786d6c3a6c616e673d22656e22206c616e673d22656e223e711158070000003c2f68746d6c3e71124e6565656558070000003c2f6469763e0a7113583e0000003c64697620636c6173733d2273656374696f6e222069643d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e0a7114587e0000003c68313e3c6120636c6173733d22746f632d6261636b7265662220687265663d22236964323022206e616d653d2266756e6374696f6e732d646566696e65642d696e2d6c656f676c6f62616c732d7079223e46756e6374696f6e7320646566696e656420696e206c656f476c6f62616c732e70793c2f613e3c2f68313e0a71156573732e"><vh>@file leoScripts.txt</vh></v>
<v t="ekr.20160123185231.1"><vh>@clean make_stub_files.py</vh>
<v t="ekr.20160124120818.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20160123185312.8"><vh>class AstFormatter</vh>
<v t="ekr.20160123185312.9"><vh> f.Entries</vh>
<v t="ekr.20160123185312.10"><vh>f.format</vh></v>
<v t="ekr.20160123185312.11"><vh>f.visit</vh></v>
</v>
<v t="ekr.20160123185312.12"><vh>f.Contexts</vh>
<v t="ekr.20160123185312.13"><vh>f.ClassDef</vh></v>
<v t="ekr.20160123185312.14"><vh>f.FunctionDef</vh></v>
<v t="ekr.20160123185312.15"><vh>f.Interactive</vh></v>
<v t="ekr.20160123185312.16"><vh>f.Module</vh></v>
<v t="ekr.20160123185312.17"><vh>f.Lambda</vh></v>
</v>
<v t="ekr.20160123185312.18"><vh>f.Expressions</vh>
<v t="ekr.20160123185312.19"><vh>f.Expr</vh></v>
<v t="ekr.20160123185312.20"><vh>f.Expression</vh></v>
<v t="ekr.20160123185312.21"><vh>f.GeneratorExp</vh></v>
<v t="ekr.20160123185312.22"><vh>f.ctx nodes</vh></v>
</v>
<v t="ekr.20160123185312.23"><vh>f.Operands</vh>
<v t="ekr.20160123185312.24"><vh>f.arguments</vh></v>
<v t="ekr.20160123185312.25"><vh>f.arg (Python3 only)</vh></v>
<v t="ekr.20160123185312.26"><vh>f.Attribute</vh></v>
<v t="ekr.20160123185312.27"><vh>f.Bytes</vh></v>
<v t="ekr.20160123185312.28"><vh>f.Call &amp; f.keyword</vh>
<v t="ekr.20160123185312.29"><vh>f.keyword</vh></v>
</v>
<v t="ekr.20160123185312.30"><vh>f.comprehension</vh></v>
<v t="ekr.20160123185312.31"><vh>f.Dict</vh></v>
<v t="ekr.20160123185312.32"><vh>f.Ellipsis</vh></v>
<v t="ekr.20160123185312.33"><vh>f.ExtSlice</vh></v>
<v t="ekr.20160123185312.34"><vh>f.Index</vh></v>
<v t="ekr.20160123185312.35"><vh>f.List</vh></v>
<v t="ekr.20160123185312.36"><vh>f.ListComp</vh></v>
<v t="ekr.20160123185312.37"><vh>f.Name</vh></v>
<v t="ekr.20160123185312.38"><vh>f.Num</vh></v>
<v t="ekr.20160123185312.39"><vh>f.Repr</vh></v>
<v t="ekr.20160123185312.40"><vh>f.Slice</vh></v>
<v t="ekr.20160123185312.41"><vh>f.Str</vh></v>
<v t="ekr.20160123185312.42"><vh>f.Subscript</vh></v>
<v t="ekr.20160123185312.43"><vh>f.Tuple</vh></v>
</v>
<v t="ekr.20160123185312.44"><vh>f.Operators</vh>
<v t="ekr.20160123185312.45"><vh>f.BinOp</vh></v>
<v t="ekr.20160123185312.46"><vh>f.BoolOp</vh></v>
<v t="ekr.20160123185312.47"><vh>f.Compare</vh></v>
<v t="ekr.20160123185312.48"><vh>f.UnaryOp</vh></v>
<v t="ekr.20160123185312.49"><vh>f.ifExp (ternary operator)</vh></v>
</v>
<v t="ekr.20160123185312.50"><vh>f.Statements</vh>
<v t="ekr.20160123185312.51"><vh>f.Assert</vh></v>
<v t="ekr.20160123185312.52"><vh>f.Assign</vh></v>
<v t="ekr.20160123185312.53"><vh>f.AugAssign</vh></v>
<v t="ekr.20160123185312.54"><vh>f.Break</vh></v>
<v t="ekr.20160123185312.55"><vh>f.Continue</vh></v>
<v t="ekr.20160123185312.56"><vh>f.Delete</vh></v>
<v t="ekr.20160123185312.57"><vh>f.ExceptHandler</vh></v>
<v t="ekr.20160123185312.58"><vh>f.Exec</vh></v>
<v t="ekr.20160123185312.59"><vh>f.For</vh></v>
<v t="ekr.20160123185312.60"><vh>f.Global</vh></v>
<v t="ekr.20160123185312.61"><vh>f.If</vh></v>
<v t="ekr.20160123185312.62"><vh>f.Import &amp; helper</vh>
<v t="ekr.20160123185312.63"><vh>f.get_import_names</vh></v>
</v>
<v t="ekr.20160123185312.64"><vh>f.ImportFrom</vh></v>
<v t="ekr.20160123185312.65"><vh>f.Pass</vh></v>
<v t="ekr.20160123185312.66"><vh>f.Print</vh></v>
<v t="ekr.20160123185312.67"><vh>f.Raise</vh></v>
<v t="ekr.20160123185312.68"><vh>f.Return</vh></v>
<v t="ekr.20160123185312.70"><vh>f.TryExcept</vh></v>
<v t="ekr.20160123185312.71"><vh>f.TryFinally</vh></v>
<v t="ekr.20160123185312.72"><vh>f.While</vh></v>
<v t="ekr.20160123185312.73"><vh>f.With</vh></v>
<v t="ekr.20160123185312.74"><vh>f.Yield</vh></v>
</v>
<v t="ekr.20160123185312.75"><vh>f.Utils</vh>
<v t="ekr.20160123185312.76"><vh>f.kind</vh></v>
<v t="ekr.20160123185312.77"><vh>f.indent</vh></v>
<v t="ekr.20160123185312.78"><vh>f.op_name</vh></v>
</v>
</v>
<v t="ekr.20160123185312.2"><vh>class StandAloneMakeStubFile</vh>
<v t="ekr.20160123193846.1"><vh>msf.ctor</vh></v>
<v t="ekr.20160123185312.6"><vh>msf.make_stub_file</vh></v>
<v t="ekr.20160123185312.7"><vh>msf.run</vh></v>
<v t="ekr.20160123185719.1"><vh>msf.scan_options &amp; helper</vh>
<v t="ekr.20160125141406.1"><vh>msf.scan_types</vh></v>
</v>
</v>
<v t="ekr.20160123185312.79"><vh>class StubFormatter (AstFormatter)</vh>
<v t="ekr.20160123185312.80"><vh>sf.Constants &amp; Name</vh></v>
</v>
<v t="ekr.20160123185312.81"><vh>class StubTraverser (ast.NodeVisitor)</vh>
<v t="ekr.20160123193632.1"><vh>st.ctor</vh></v>
<v t="ekr.20160123185312.82"><vh>st.indent &amp; out</vh></v>
<v t="ekr.20160123185312.83"><vh>st.run</vh></v>
<v t="ekr.20160123185312.85"><vh>st.Visitors</vh>
<v t="ekr.20160123185312.86"><vh>st.ClassDef</vh></v>
<v t="ekr.20160123185312.87"><vh>st.FunctionDef &amp; helpers</vh>
<v t="ekr.20160123185312.88"><vh>format_arguments</vh></v>
<v t="ekr.20160123185312.90"><vh>format_returns</vh></v>
<v t="ekr.20160125130205.1"><vh>munge_arg</vh></v>
<v t="ekr.20160125132131.1"><vh>munge_ret &amp; helpers</vh>
<v t="ekr.20160126035753.1"><vh>match_args</vh></v>
<v t="ekr.20160126040138.1"><vh>match_simple_patterns &amp; helpers</vh>
<v t="ekr.20160125195414.1"><vh>match_return_patterns</vh></v>
<v t="ekr.20160125202035.1"><vh>match_return_pattern</vh></v>
<v t="ekr.20160125204058.1"><vh>match_balanced</vh></v>
</v>
<v t="ekr.20160126041450.1"><vh>match_regex_patterns</vh></v>
</v>
</v>
<v t="ekr.20160123185312.91"><vh>st.Return</vh></v>
</v>
</v>
<v t="ekr.20160123185348.1"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20150508132430.1"><vh>Recent</vh>
<v t="ekr.20150508132423.1"><vh>Found: getPublicCommands</vh>
<v t="ekr.20150508132423.2"><vh>abbrev.getPublicCommands &amp; getStateCommands</vh></v>
<v t="ekr.20150508132423.3"><vh>baseEditCommands.getPublicCommands &amp; getStateCommands</vh></v>
<v t="ekr.20150508132423.4"><vh>buffer.getPublicCommands</vh></v>
<v t="ekr.20150508132423.5"><vh>c.createCommandNames &amp; helper</vh>
<v t="ekr.20150508132423.6"><vh>c.createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20150508132423.7"><vh>chapter.getPublicCommands</vh></v>
<v t="ekr.20150508132423.8"><vh>control.getPublicCommands</vh></v>
<v t="ekr.20150508132423.9"><vh>db.getPublicCommands</vh></v>
<v t="ekr.20150508132423.10"><vh>ec.getPublicCommands</vh></v>
<v t="ekr.20150508132423.11"><vh>ecm.getPublicCommands</vh></v>
<v t="ekr.20150508132423.12"><vh>ef.getPublicCommands</vh></v>
<v t="ekr.20150508132423.13"><vh>getPublicCommands (KeyHandlerCommandsClass)</vh></v>
<v t="ekr.20150508132423.14"><vh>getPublicCommands (SearchCommandsClass)</vh></v>
<v t="ekr.20150508132423.15"><vh>getPublicCommands (SpellCommandsClass)</vh></v>
<v t="ekr.20150508132423.16"><vh>help.getPublicCommands</vh></v>
<v t="ekr.20150508132423.17"><vh>kill.getPublicCommands</vh></v>
<v t="ekr.20150508132423.18"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20150508132423.19"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20150508132423.20"><vh>macro.getPublicCommands</vh></v>
<v t="ekr.20150508132423.21"><vh>pr.getPublicCommands</vh></v>
<v t="ekr.20150508132423.22"><vh>rectangle.getPublicCommands</vh></v>
<v t="ekr.20150508132423.23"><vh>register.getPublicCommands</vh></v>
<v t="ekr.20150508132423.24"><vh>rst.getPublicCommands</vh></v>
<v t="ekr.20150508132423.25"><vh>vc.getPublicCommands</vh></v>
</v>
<v t="ekr.20150508132450.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508132450.2"><vh>create_d</vh></v>
<v t="ekr.20150508132450.3"><vh>create_decorator</vh></v>
<v t="ekr.20150508132450.4"><vh>create_decorators</vh></v>
<v t="ekr.20150508132450.5"><vh>create_fixups</vh></v>
<v t="ekr.20150508132450.6"><vh>find_class</vh></v>
<v t="ekr.20150508132450.7"><vh>find_next_clone</vh></v>
<v t="ekr.20150508132450.8"><vh>munge_lines</vh></v>
<v t="ekr.20150508132450.9"><vh>run</vh></v>
</v>
<v t="ekr.20150525161132.1"><vh>@@button tokens2tree</vh>
<v t="ekr.20150525161132.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20160123185308.1"><vh>@button make_stub_files script</vh>
<v t="ekr.20160123185308.2"><vh>class MakeStubFile</vh>
<v t="ekr.20160123185308.3"><vh>msf.ctors &amp; helpers</vh>
<v t="ekr.20160123185308.4"><vh>msf.make_types_dict</vh></v>
<v t="ekr.20160123185308.5"><vh>msf.scan_types_data</vh></v>
</v>
<v t="ekr.20160123185308.6"><vh>msf.make_stub_file</vh></v>
<v t="ekr.20160123185308.7"><vh>msf.run</vh></v>
</v>
<v t="ekr.20160123185308.8"><vh>class AstFormatter</vh>
<v t="ekr.20160123185308.9"><vh> f.Entries</vh>
<v t="ekr.20160123185308.10"><vh>f.format</vh></v>
<v t="ekr.20160123185308.11"><vh>f.visit</vh></v>
</v>
<v t="ekr.20160123185308.12"><vh>f.Contexts</vh>
<v t="ekr.20160123185308.13"><vh>f.ClassDef</vh></v>
<v t="ekr.20160123185308.14"><vh>f.FunctionDef</vh></v>
<v t="ekr.20160123185308.15"><vh>f.Interactive</vh></v>
<v t="ekr.20160123185308.16"><vh>f.Module</vh></v>
<v t="ekr.20160123185308.17"><vh>f.Lambda</vh></v>
</v>
<v t="ekr.20160123185308.18"><vh>f.Expressions</vh>
<v t="ekr.20160123185308.19"><vh>f.Expr</vh></v>
<v t="ekr.20160123185308.20"><vh>f.Expression</vh></v>
<v t="ekr.20160123185308.21"><vh>f.GeneratorExp</vh></v>
<v t="ekr.20160123185308.22"><vh>f.ctx nodes</vh></v>
</v>
<v t="ekr.20160123185308.23"><vh>f.Operands</vh>
<v t="ekr.20160123185308.24"><vh>f.arguments</vh></v>
<v t="ekr.20160123185308.25"><vh>f.arg (Python3 only)</vh></v>
<v t="ekr.20160123185308.26"><vh>f.Attribute</vh></v>
<v t="ekr.20160123185308.27"><vh>f.Bytes</vh></v>
<v t="ekr.20160123185308.28"><vh>f.Call &amp; f.keyword</vh>
<v t="ekr.20160123185308.29"><vh>f.keyword</vh></v>
</v>
<v t="ekr.20160123185308.30"><vh>f.comprehension</vh></v>
<v t="ekr.20160123185308.31"><vh>f.Dict</vh></v>
<v t="ekr.20160123185308.32"><vh>f.Ellipsis</vh></v>
<v t="ekr.20160123185308.33"><vh>f.ExtSlice</vh></v>
<v t="ekr.20160123185308.34"><vh>f.Index</vh></v>
<v t="ekr.20160123185308.35"><vh>f.List</vh></v>
<v t="ekr.20160123185308.36"><vh>f.ListComp</vh></v>
<v t="ekr.20160123185308.37"><vh>f.Name</vh></v>
<v t="ekr.20160123185308.38"><vh>f.Num</vh></v>
<v t="ekr.20160123185308.39"><vh>f.Repr</vh></v>
<v t="ekr.20160123185308.40"><vh>f.Slice</vh></v>
<v t="ekr.20160123185308.41"><vh>f.Str</vh></v>
<v t="ekr.20160123185308.42"><vh>f.Subscript</vh></v>
<v t="ekr.20160123185308.43"><vh>f.Tuple</vh></v>
</v>
<v t="ekr.20160123185308.44"><vh>f.Operators</vh>
<v t="ekr.20160123185308.45"><vh>f.BinOp</vh></v>
<v t="ekr.20160123185308.46"><vh>f.BoolOp</vh></v>
<v t="ekr.20160123185308.47"><vh>f.Compare</vh></v>
<v t="ekr.20160123185308.48"><vh>f.UnaryOp</vh></v>
<v t="ekr.20160123185308.49"><vh>f.ifExp (ternary operator)</vh></v>
</v>
<v t="ekr.20160123185308.50"><vh>f.Statements</vh>
<v t="ekr.20160123185308.51"><vh>f.Assert</vh></v>
<v t="ekr.20160123185308.52"><vh>f.Assign</vh></v>
<v t="ekr.20160123185308.53"><vh>f.AugAssign</vh></v>
<v t="ekr.20160123185308.54"><vh>f.Break</vh></v>
<v t="ekr.20160123185308.55"><vh>f.Continue</vh></v>
<v t="ekr.20160123185308.56"><vh>f.Delete</vh></v>
<v t="ekr.20160123185308.57"><vh>f.ExceptHandler</vh></v>
<v t="ekr.20160123185308.58"><vh>f.Exec</vh></v>
<v t="ekr.20160123185308.59"><vh>f.For</vh></v>
<v t="ekr.20160123185308.60"><vh>f.Global</vh></v>
<v t="ekr.20160123185308.61"><vh>f.If</vh></v>
<v t="ekr.20160123185308.62"><vh>f.Import &amp; helper</vh>
<v t="ekr.20160123185308.63"><vh>f.get_import_names</vh></v>
</v>
<v t="ekr.20160123185308.64"><vh>f.ImportFrom</vh></v>
<v t="ekr.20160123185308.65"><vh>f.Pass</vh></v>
<v t="ekr.20160123185308.66"><vh>f.Print</vh></v>
<v t="ekr.20160123185308.67"><vh>f.Raise</vh></v>
<v t="ekr.20160123185308.68"><vh>f.Return</vh></v>
<v t="ekr.20160123185308.69"><vh>f.Suite</vh></v>
<v t="ekr.20160123185308.70"><vh>f.TryExcept</vh></v>
<v t="ekr.20160123185308.71"><vh>f.TryFinally</vh></v>
<v t="ekr.20160123185308.72"><vh>f.While</vh></v>
<v t="ekr.20160123185308.73"><vh>f.With</vh></v>
<v t="ekr.20160123185308.74"><vh>f.Yield</vh></v>
</v>
<v t="ekr.20160123185308.75"><vh>f.Utils</vh>
<v t="ekr.20160123185308.76"><vh>f.kind</vh></v>
<v t="ekr.20160123185308.77"><vh>f.indent</vh></v>
<v t="ekr.20160123185308.78"><vh>f.op_name</vh></v>
</v>
</v>
<v t="ekr.20160123185308.79"><vh>class StubFormatter (AstFormatter)</vh>
<v t="ekr.20160123185308.80"><vh>sf.Constants &amp; Name</vh></v>
</v>
<v t="ekr.20160123185308.81"><vh>class StubTraverser (ast.NodeVisitor)</vh>
<v t="ekr.20160123185308.82"><vh>st.indent &amp; out</vh></v>
<v t="ekr.20160123185308.83"><vh>st.run</vh></v>
<v t="ekr.20160123185308.84"><vh>st.visit (not used)</vh></v>
<v t="ekr.20160123185308.85"><vh>st.Visitors</vh>
<v t="ekr.20160123185308.86"><vh>st.ClassDef</vh></v>
<v t="ekr.20160123185308.87"><vh>st.FunctionDef &amp; helpers</vh>
<v t="ekr.20160123185308.88"><vh>format_arguments &amp; helper</vh>
<v t="ekr.20160123185308.89"><vh>munge_arg</vh></v>
</v>
<v t="ekr.20160123185308.90"><vh>format_returns</vh></v>
</v>
<v t="ekr.20160123185308.91"><vh>st.Return</vh></v>
</v>
</v>
</v>
<v t="ekr.20160123185231.1"></v>
<v t="ekr.20160123185719.1"></v>
<v t="ekr.20160123185312.87"></v>
<v t="ekr.20160125183341.1"><vh>** add command-line args</vh></v>
<v t="ekr.20160124163833.1"><vh>@clean c:\users\edreamleo\stubs\make_stub_files.cfg</vh></v>
<v t="ekr.20160123193846.1"></v>
<v t="ekr.20160123193632.1"></v>
<v t="ekr.20160125132131.1"></v>
<v t="ekr.20160125125845.1" a="M"><vh>test munge_ret</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20061008055616"></t>
<t tx="ekr.20070427110751"></t>
<t tx="ekr.20070615131954"></t>
<t tx="ekr.20111017085134.16069"></t>
<t tx="ekr.20111017085134.16070"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.h
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20111017085134.16071">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20111017085134.16072"># This works, but is too slow to be really useful.

count = 0
for p in c.all_unique_positions():
    if p.isDirty():
        c.checkPythonNode (p,suppressErrors=False)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20111017085134.16073">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20111017085134.16074"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20111017085134.16075">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16076"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20111017085134.16077">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20111017085134.16078">'''Analyze external calls in lisp files.'''

import glob
class lispAnalyzer:
    @others

base = '/media/disk/XEmacs/XEmacs-21.4.13/lisp/*.el'
paths = glob.glob(base)
# g.es(g.listToString(paths))
paths = [paths[0]]

x = lispAnalyzer(c,paths)
x.run()</t>
<t tx="ekr.20111017085134.16079">def __init__ (self,c,paths):

    self.c = c
    self.paths = paths

    # Debugging.
    self.debug = True
    self.trace = False

    # Semantic info.
    self.def_keywords = ('defun','defvar',)
    self.indent_keywords = ('if','prog','prog1','progn','set',)
    self.expr_keywords = ('and','not','or',)

    self.indent = 0 # Indentation of production output.

    # Dispatch dictionary.
    self.dispatchDict = {}</t>
<t tx="ekr.20111017085134.16080">def run(self):

    fn = self.paths[0]
    f = open(fn)
    s = f.read()
    g.es_print(fn)
    # g.trace(s)
    s = self.stripStrings(s)
    s = self.stripComments(s)
    defs = self.findDefs(s)
    calls = self.findCalls(s,defs)
    calls = self.stripLispIds(calls)
    defs.sort()
    calls.sort()
    g.trace('defs...\n',g.listToString(defs))
    g.trace('calls...\n',g.listToString(calls))
</t>
<t tx="ekr.20111017085134.16081">def findCalls (self,s,defs):

    calls = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            theId = s[i:j].strip()
            if theId not in defs and theId not in calls:
                calls.append(theId)
            i = j
        else: i += 1
        assert progress &lt; i

    return calls       
</t>
<t tx="ekr.20111017085134.16082">def findDefs (self,s):

    defs = [] ; tag = '(defun'
    i = 0
    while True:
        progress = i
        j = s.find(tag,i)
        if j == -1:
            return defs
        i = j + len(tag)
        j = g.skip_ws(s,i)
        if j &gt; i:
            k = self.skipId(s,j)
            if k &gt; j:
                defs.append(s[j:k])
            i = k
        assert progress &lt; i 
</t>
<t tx="ekr.20111017085134.16083">def stripComments(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == ';':
            i = self.skipComment(s,i)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16084">def stripLispIds (self,aList):

    lispIds = [
        't','f',
        'apply',
        'boundp',
        'car','cons','cdr','consp',
        'eq','equal','eval',
        'lamda','lambda',
        'macro',
        'nil','not','null','numberp',
        'or',
        'unless',
        'vector','vectorp',
        # special forms
        'and',
        'catch',
        'cond',
        'condition-case',
        'defconst',
        'defmacro',
        'defun',
        'defvar',
        'function',
        'if',
        'interactive',
        'let',
        'let*',
        'or',
        'prog1',
        'prog2',
        'progn',
        'quote',
        'save-current-buffer',
        'save-excursion',
        'save-restriction',
        'save-window-excursion',
        'setq',
        'setq-default',
        'track-mouse',
        'unwind-protect',
        'while',
        'with-output-to-temp-buffer',
    ]

    return [z for z in aList if z not in lispIds]</t>
<t tx="ekr.20111017085134.16085">def stripStrings(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == '"':
            i = self.skipString(s,i)
        elif ch == "'":
            i = self.skipId(s,i+1)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="ekr.20111017085134.16086">class token:

    '''Representing one elisp syntactic entity,
    with a list of preceding comments.'''

    def __init__ (self,comments,kind,val):
        self.comments = comments[:]
        self.kind = kind
        self.val = val
            # For blocks, a list of tokens.
            # For all other tokens, the spelling of the token.

    def __repr__ (self):
        return '&lt;token kind: %s, val: %s&gt;' % (self.kind,self.val)

    def __str__ (self):
        if self.kind == 'block:':
            return 'block: [snip]'
        elif self.kind == 'string:':
            return '%s%s' % (self.kind,self.val[:20])
        else:
            return '%s%s' % (self.kind,self.val)
</t>
<t tx="ekr.20111017085134.16087">def choose(self,cond,a,b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="ekr.20111017085134.16088">def dumpList(self,aList):

    if type(aList) == type([]):
        result = self.dumpListHelper(aList,indent=0)
        return '\n'.join(result)
    else:
        return repr(aList)

def dumpListHelper(self,aList,indent):

    result = []
    leading = ' ' * (4 * indent)

    for z in aList:
        if z is None:
            result.append('%s%s' % (leading,'None'))
        elif z == []:
            result.append('%s%s' % (leading,'[]'))
        elif type(z) == type([]):
            result.append('%s%s' % (leading,'['))
            result.extend(self.dumpListHelper(z,indent+1))
            result.append('%s%s' % (leading,']'))
        elif isinstance(z,self.token):
            if z.kind=='block:':
                result.append('%s%s' % (leading,'block:'))
                result.extend(self.dumpListHelper(z.val,indent+1))
                # result.append('%s%s' % (leading,'block:]'))
            else:
                result.append('%s%s' % (leading,str(z)))
        else:
            result.append('%s%s' % (leading,str(z)))

    return result

listToString = dumpList</t>
<t tx="ekr.20111017085134.16089"></t>
<t tx="ekr.20111017085134.16090">def parse(self,s):

    # Generate the nodes, including directive and section references.
    return self.scanForest(s)
</t>
<t tx="ekr.20111017085134.16091">def scan(self,s,i):

    '''Scan an elisp expression.'''

    start = i ; end = len(s) ; result = []
    comments = [] ; token = self.token
    # A hack. ignore initial @language lisp
    tag = '@language lisp'
    if i == 0 and s[i:i+len(tag)]==tag:
        i += len(tag)
    while i &lt; end:
        progress = i
        ch = s[i]
        if ch == ';':
            j = self.skipComment(s,i)
            start = i = j
        elif ch == '"':
            j = self.skipString(s,i)
            start = i = j
        elif ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            result.append(token(comments,'id:',s[i:j]))
            start = i = j
        elif ch =='(':
            i += 1
            j,aList = self.scan(s,i)
            result.append(token(comments,'block:',aList))
            start = i = j
        elif ch == ')':
            i += 1
            return i,result
        else:
            # if ch == "'": ch = 'quote'
            # if ch not in (' ','\t','\n','\r'):
                # result.append(token(comments,'op:',ch))
            i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if start &lt; end:
        tail = s[start:end].strip()
        if tail:
            result.append(token(comments,'tail:',tail))
            comment = []
    if comments:
        result.append(token(comments,'trailing-comment:',''))

    return i,result
</t>
<t tx="ekr.20111017085134.16092">def skipComment (self,s,i):

    '''Skip a comment.'''

    while i &lt; len(s):
        if s[i] == '\n':
            break
        i += 1
    return i
</t>
<t tx="ekr.20111017085134.16093">def skipId (self,s,i):

    while i &lt; len(s):
        ch = s[i]
        if ch.isalnum() or ch in ('_','-'):
            i += 1
        else:
            break
    return i
</t>
<t tx="ekr.20111017085134.16094">def skipString(self,s,i):

    """Skip a string literal."""

    assert(s[i] == '"')
    i += 1
    while i &lt; len(s):
        ch = s[i]
        if ch == '\\' : i += 2
        elif ch == '"':
            i += 1 ; break
        else: i += 1

    return i</t>
<t tx="ekr.20111017085134.16095">def scanForest (self,s):

    i = 0 ; result = []

    while i &lt; len(s):
        progress = i
        i,aList = self.scan(s,i)
        aList and result.extend(aList)
        assert i &gt; progress

    return result


</t>
<t tx="ekr.20111017085134.16096">@ From Richard Deibenkorn:

1. Attempt what is not certain. Certainty may or may not come later. It may then
be a valuable delusion.

2. The pretty, initial position which falls short of completeness is not to be
valued--except as stimulus for further moves.

3. Do search.  But in order to find other than what is looked for.

4. Use and respond to the initial fresh qualities but consider them absolutely
expendable.
</t>
<t tx="ekr.20111017085134.16097">def gen(self,tokens,indent,init=False):

    result = []

    if init: result.append('='*40)

    for token in tokens:
        aList = self.gen_token(token,indent)
        result.extend(aList)

    if init: result.append('-'*40)

    return result

</t>
<t tx="ekr.20111017085134.16098">def gen_token(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            self.gen_block(token,indent)
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16099">def gen_block (self,token,indent):

    if not (token and token.val):
        return []

    blockList = token.val
    token2 = blockList[0]
    result = []

    if token2.kind.startswith('id'):
        aList = self.gen_block_id(token2.val,blockList,indent)
    else:
        if self.debug:
            self.put('block...',[],indent,result)
        aList = self.gen(token.val,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16100">def gen_block_id (self,theId,tokens,indent):

    result = []

    # Eventually there will be a lookup of the dispatch dict here.
    if theId == 'let':
        aList = self.gen_let(tokens,indent)
    elif theId == 'if':
        aList = self.gen_if(tokens,indent)
    elif theId in self.def_keywords:
        aList = self.gen_def(theId,tokens,indent)
    elif theId in self.indent_keywords:
        self.put('%s...' % (theId),[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
    elif theId in self.expr_keywords:
        aList = self.gen_expr(theId,tokens[1:],indent+1)
    else:
        aList = self.gen_call(theId,tokens[1:],indent)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16101">def gen_call (self,funcId,tokens,indent):

    result = []

    if self.debug:
        self.put('call: %s' % (funcId),[],indent,result)
        for token in tokens:
            aList = self.gen_arg(token,indent+1)
            result.extend(aList)
    else:
        self.put_code_line('%s(' % (funcId))
        for token in tokens:
            self.gen_arg(token,indent+1)
        self.put_code(')')

    return result

</t>
<t tx="ekr.20111017085134.16102">def gen_arg(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            self.put('arg block:...',[],indent,result)
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            self.put_code(''.join(aList))
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="ekr.20111017085134.16103">def gen_def(self,theId,tokens,indent):

    result = []

    if not tokens or len(tokens) &lt; 3:
        result.append('*** bad def tokens')
        return result

    defToken,idToken = tokens[0:2]
    if idToken.kind != 'id:':
        result.append('*** bad def id')
        return result

    if self.debug:
        self.put(theId,idToken.val,indent,result)
        aList = self.gen(tokens[2:],indent+1)
        result.extend(aList)
    else:
        self.put_code('def %s (' % idToken.val)
        self.gen_token(tokens[2],indent)
        self.put_code('): # end def\n')
        self.indent += 1
        self.gen(tokens[3:],indent+1)
        self.indent -= 1

    return result
</t>
<t tx="ekr.20111017085134.16104">@ if condition then-form else-forms.

If the evaluated condition is non-nil, then-form is evaluated and the result
returned. Otherwise, the else-forms are evaluated in textual order, and the
value of the last one is returned. If condition has the value nil, and no
else-forms are given, if returns nil.
@c

def gen_if (self,tokens,indent):

    # tokens[0]: id:if
    # tokens[1] cond

    for i in xrange(len(tokens)):
        g.trace('tokens[%d]: %s' % (i,self.dumpList(tokens[i])))

    # g.trace(self.dumpList(tokens))

    result = []

    if self.debug:
        self.put('if...',[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
        result.extend(aList)
    else:
        self.put_code('if ')
        self.gen(tokens[1:],indent+1)
        self.put_code(': # end if\n')

    return result
</t>
<t tx="ekr.20111017085134.16105">def gen_then (self,token):

    pass
</t>
<t tx="ekr.20111017085134.16106">def gen_expr (self,theId,aList,indent):

    binops = ('and','or',)
    result = []

    self.put(theId,[],indent,result)
    aList = self.gen(aList,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="ekr.20111017085134.16107">@
(let ((variable value)
      (variable value)
      ...)
  body...)
@c

def gen_let (self,tokens,indent):

    if not tokens: return []
    if len(tokens) != 3:
        g.trace('unusual let')
        result = self.gen(tokens,indent+1)
        return result

    if 0:
        for i in xrange(len(tokens)):
            g.trace('token',i,tokens[i])

    letToken,bindingToken,bodyToken = tokens
    result = []
    self.put('let...',[],indent,result)
    self.put('let-bindings...',[],indent+1,result)
    aList = self.gen_let_bindings(bindingToken,indent+2)
    result.extend(aList)
    self.put('let-block...',[],indent+1,result)
    aList = self.gen_block(bodyToken,indent+2)
    result.extend(aList)
    return result</t>
<t tx="ekr.20111017085134.16108">def gen_let_bindings (self,token,indent):

    result = []

    if token.kind != 'block:':
        g.trace('unexpected let')
        return result

    for z in token.val:
        if z.kind == 'block:': # one (id,val) pair
            if z.val and len(z.val) == 2:
                token1 = z.val[0]
                token2 = z.val[1]
                self.put('let-id',token1,indent,result)
                self.put('let-val...',[],indent,result)
                if token2.kind == 'block:':
                    aList = self.gen_block(token2,indent+1)
                    result.extend(aList)
                else:
                    #g.trace('no let list')
                    self.put_token(token2,indent+1,result)
            else:
                g.trace('unexpected let 2')

    return result
</t>
<t tx="ekr.20111017085134.16109"></t>
<t tx="ekr.20111017085134.16110">def put (self,kind,val,indent,result):

    '''Append one or more lines of output to result.'''

    leading = '%2d: %s' % (indent,' ' * indent)

    if kind == 'string:':
        val = self.choose(len(val)&gt;20,val[:20]+'..."',val)

    if val:
        s = '%s%s %s' % (leading,str(kind),str(val))
    else:
        s = '%s%s' % (leading,str(kind))

    result.append(s)
</t>
<t tx="ekr.20111017085134.16111">def put_token (self,token,indent,result):

    for z in token.comments:
        self.put('comment:',z,indent,result)

    self.put(token.kind,token.val,indent,result)
</t>
<t tx="ekr.20111017085134.16112">def put_code_line (self,s):

    s2 = '%s%s' % (' '*self.indent,s)
    print s2,

def put_code (self,s):

    print s,
</t>
<t tx="ekr.20111017085134.16113">def put_code_token (self,token):

    if token.kind == 'block:':
        self.put_code('&lt;block&gt;')
    else:
        self.put_code(token.val)

</t>
<t tx="ekr.20111017085134.16114">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20141116105945.2"></t>
<t tx="ekr.20141116105945.3">gnx: maphew.20130809155103.2862
</t>
<t tx="ekr.20141116105945.4"></t>
<t tx="ekr.20150302053516.3"></t>
<t tx="ekr.20150508132423.1"></t>
<t tx="ekr.20150508132423.10">def getPublicCommands (self):        

    c = self.c

    return {
        'activate-cmds-menu':                   self.activateCmdsMenu,
        'activate-edit-menu':                   self.activateEditMenu,
        'activate-file-menu':                   self.activateFileMenu,
        'activate-help-menu':                   self.activateHelpMenu,
        'activate-outline-menu':                self.activateOutlineMenu,
        'activate-plugins-menu':                self.activatePluginsMenu,
        'activate-window-menu':                 self.activateWindowMenu,
        'add-editor':                           c.frame.body and c.frame.body.addEditor,
        'add-space-to-lines':                   self.addSpaceToLines,
        'add-tab-to-lines':                     self.addTabToLines, 
        'back-to-indentation':                  self.backToIndentation,
        'back-to-home':                         self.backToHome,
        'back-to-home-extend-selection':        self.backToHomeExtendSelection,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-page':                            self.backPage,
        'back-page-extend-selection':           self.backPageExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'back-word-smart':                      self.backwardWordSmart,
        'back-word-smart-extend-selection':     self.backwardWordSmartExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-delete-word':                 self.backwardDeleteWord,
        'backward-delete-word-smart':           self.backwardDeleteWordSmart,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'backward-find-character':              self.backwardFindCharacter,
        'backward-find-character-extend-selection': self.backwardFindCharacterExtendSelection,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'c-to-python':                          self.cToPy,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clean-all-lines':                      self.cleanAllLines,
        'clean-lines':                          self.cleanLines,
        'clear-all-caches':                     self.clearAllCaches,
        'clear-all-uas':                        self.clearAllUas,
        'clear-cache':                          self.clearCache,
        'clear-extend-mode':                    self.clearExtendMode,
        'clear-node-uas':                       self.clearNodeUas,
        'clear-selected-text':                  self.clearSelectedText,
        'click-click-box':                      self.clickClickBox,
        'click-headline':                       self.clickHeadline,
        'click-icon-box':                       self.clickIconBox,
        'clone-marked-nodes':                   c.cloneMarked,
        'cls':                                  g.cls,
        'contract-body-pane':                   c.frame.contractBodyPane,
        'contract-log-pane':                    c.frame.contractLogPane,
        'contract-outline-pane':                c.frame.contractOutlinePane,
        'contract-pane':                        c.frame.contractPane,
        'count-region':                         self.countRegion,
        'ctrl-click-icon':                      self.ctrlClickIconBox,
        'cycle-focus':                          self.cycleFocus,
        # 'cycle-all-focus':                    self.cycleAllFocus,
            # Replaced by focus-to-x commands.
        'cycle-editor-focus':                   c.frame.body.cycleEditorFocus,
        'cycle-log-focus':                      c.frame.log.cycleTabFocus,
        # 'delete-all-icons':                   self.deleteAllIcons,
        'delete-char':                          self.deleteNextChar,
        'delete-editor':                        c.frame.body.deleteEditor,
        'delete-first-icon':                    self.deleteFirstIcon,
        'delete-indentation':                   self.deleteIndentation,
        'delete-last-icon':                     self.deleteLastIcon,
        'delete-marked-nodes':                  c.deleteMarked,
        'delete-node-icons':                    self.deleteNodeIcons,
        'delete-spaces':                        self.deleteSpaces,
        'delete-word':                          self.deleteWord,
        'delete-word-smart':                    self.deleteWordSmart,
        'do-nothing':                           self.doNothing,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'double-click-headline':                self.doubleClickHeadline,
        'double-click-icon-box':                self.doubleClickIconBox,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'expand-body-pane':                     c.frame.expandBodyPane,
        'expand-log-pane':                      c.frame.expandLogPane,
        'expand-outline-pane':                  c.frame.expandOutlinePane,
        'expand-pane':                          c.frame.expandPane,
        'extend-to-line':                       self.extendToLine,
        'extend-to-paragraph':                  self.extendToParagraph,
        'extend-to-sentence':                   self.extendToSentence,
        'extend-to-word':                       self.extendToWord,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'find-character':                       self.findCharacter,
        'find-character-extend-selection':      self.findCharacterExtendSelection,
        'find-word':                            self.findWord,
        'find-word-in-line':                    self.findWordInLine,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-page':                         self.forwardPage,
        'forward-page-extend-selection':        self.forwardPageExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-end-word':                     self.forwardEndWord, # New in Leo 4.4.2.
        'forward-end-word-extend-selection':    self.forwardEndWordExtendSelection, # New in Leo 4.4.2.
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'forward-word-smart':                   self.forwardWordSmart,
        'forward-word-smart-extend-selection':  self.forwardWordSmartExtendSelection,
        'fully-expand-body-pane':               c.frame.fullyExpandBodyPane,
        'fully-expand-log-pane':                c.frame.fullyExpandLogPane,
        'fully-expand-pane':                    c.frame.fullyExpandPane,
        'fully-expand-outline-pane':            c.frame.fullyExpandOutlinePane,
        'goto-char':                            self.gotoCharacter,
        'goto-global-line':                     self.gotoGlobalLine,
        'goto-line':                            self.gotoLine,
        'hide-body-pane':                       c.frame.hideBodyPane,
        'hide-log-pane':                        c.frame.hideLogPane,
        'hide-pane':                            c.frame.hidePane,
        'hide-outline-pane':                    c.frame.hideOutlinePane,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-hard-tab':                      self.insertHardTab,
        'insert-icon':                          self.insertIcon,
        'insert-file-name':                     self.insertFileName,
        'insert-headline-time':                 self.insertHeadlineTime,
        'insert-newline':                       self.insertNewLine,
        'insert-parentheses':                   self.insertParentheses,
        'insert-soft-tab':                      self.insertSoftTab,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-lines-down':                      self.moveLinesDown,
        'move-lines-up':                        self.moveLinesUp,
        'move-marked-nodes':                    c.moveMarked,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'print-all-uas':                        self.printAllUas,
        'print-node-uas':                       self.printUas,
        'remove-blank-lines':                   self.removeBlankLines,
        'remove-space-from-lines':              self.removeSpaceFromLines,
        'remove-tab-from-lines':                self.removeTabFromLines,
        'replace-current-character':            self.replaceCurrentCharacter,
        'reverse-region':                       self.reverseRegion,
        'reverse-sort-lines':                   self.reverseSortLines,
        'reverse-sort-lines-ignoring-case':     self.reverseSortLinesIgnoringCase,
        'scroll-down-half-page':                self.scrollDownHalfPage,
        'right-click-icon':                     self.rightClickIconBox,
        'right-click-headline':                 self.rightClickHeadline,
        'scroll-down-line':                     self.scrollDownLine,
        'scroll-down-page':                     self.scrollDownPage,
        'scroll-outline-down-line':             self.scrollOutlineDownLine,
        'scroll-outline-down-page':             self.scrollOutlineDownPage,
        'scroll-outline-left':                  self.scrollOutlineLeft,
        'scroll-outline-right':                 self.scrollOutlineRight,
        'scroll-outline-up-line':               self.scrollOutlineUpLine,
        'scroll-outline-up-page':               self.scrollOutlineUpPage,
        'scroll-up-half-page':                  self.scrollUpHalfPage,                        
        'scroll-up-line':                       self.scrollUpLine,
        'scroll-up-page':                       self.scrollUpPage,
        'select-all':                           self.selectAllText,
        'select-to-matching-bracket':           self.selectToMatchingBracket,
        # Exists, but can not be executed via the minibuffer.
        'self-insert-command':                  self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        #'set-mark-command':                    self.setRegion,
        'set-ua':                               self.setUa,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        'simulate-begin-drag':                  self.simulateBeginDrag,
        'simulate-end-drag':                    self.simulateEndDrag,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'sort-lines-ignoring-case':             self.sortLinesIgnoringCase,
        'split-line':                           self.splitLine,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'toggle-case-region':                   self.toggleCaseRegion,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'typescript-to-py':                     self.tsToPy,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20150508132423.11">def getPublicCommands (self):
    '''Add the names of commands defined in this file to c.commandsDict.'''
    c,d = self.c,{}
    for name, theClass in self.classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                g.pr('----- %s' % name)
                for key in sorted(d2): g.pr(key)
    c.commandsDict.update(d)
</t>
<t tx="ekr.20150508132423.12">def getPublicCommands (self):

    return {
        'directory-make':           self.makeDirectory,
        'directory-remove':         self.removeDirectory,
        'file-compare-leo-files':   self.compareAnyTwoFiles,
        'file-delete':              self.deleteFile,
        'file-diff-files':          self.diff, 
        'file-insert':              self.insertFile,
        'file-open-by-name':        self.openOutlineByName,
        'file-save':                self.saveFile
    }
</t>
<t tx="ekr.20150508132423.13">def getPublicCommands (self):

    k = self.k

    if k:
        return {
            'auto-complete':            k.autoCompleter.autoComplete,
            'auto-complete-force':      k.autoCompleter.autoCompleteForce,
            'digit-argument':           k.digitArgument,
            'disable-autocompleter':    k.autoCompleter.disableAutocompleter,
            'disable-calltips':         k.autoCompleter.disableCalltips,
            'enable-autocompleter':     k.autoCompleter.enableAutocompleter,
            'enable-calltips':          k.autoCompleter.enableCalltips,
            'exit-named-mode':          k.exitNamedMode,
            'full-command':             k.fullCommand, # For menu.
            # 'hide-mini-buffer':         k.hideMinibuffer,
            'menu-shortcut':            self.menuShortcutPlaceHolder,
            'mode-help':                k.modeHelp,
            'negative-argument':        k.negativeArgument,
            'number-command':           k.numberCommand,
            'number-command-0':         k.numberCommand0,
            'number-command-1':         k.numberCommand1,
            'number-command-2':         k.numberCommand2,
            'number-command-3':         k.numberCommand3,
            'number-command-4':         k.numberCommand4,
            'number-command-5':         k.numberCommand5,
            'number-command-6':         k.numberCommand6,
            'number-command-7':         k.numberCommand7,
            'number-command-8':         k.numberCommand8,
            'number-command-9':         k.numberCommand9,
            'print-bindings':           k.printBindings,
            'print-buttons':            k.printButtons,
            'print-commands':           k.printCommands,
            'repeat-complex-command':   k.repeatComplexCommand,
            # 'scan-for-autocompleter':   k.autoCompleter.scan,
            'set-command-state':        k.setCommandState,
            'set-insert-state':         k.setInsertState,
            'set-overwrite-state':      k.setOverwriteState,
            'show-calltips':            k.autoCompleter.showCalltips,
            'show-calltips-force':      k.autoCompleter.showCalltipsForce,
            # 'show-mini-buffer':         k.showMinibuffer,
            'toggle-autocompleter':     k.autoCompleter.toggleAutocompleter,
            'toggle-calltips':          k.autoCompleter.toggleCalltips,
            #'toggle-mini-buffer':       k.toggleMinibuffer,
            'toggle-input-state':       k.toggleInputState,
            'universal-argument':       k.universalArgument,
        }
    else:
        return {}
</t>
<t tx="ekr.20150508132423.14">def getPublicCommands (self):
    
    find = self.c.findCommands
    return {
    'clone-find-all':                 find.minibufferCloneFindAll,
    'clone-find-all-flattened':       find.minibufferCloneFindAllFlattened,
    'clone-find-parents':             self.c.cloneFindParents,
    'find-all':                       find.minibufferFindAll,
    'find-clone-all':                 find.minibufferCloneFindAll,
    'find-clone-all-flattened':       find.minibufferCloneFindAllFlattened,
    'find-next':                      find.findNextCommand,
    'find-prev':                      find.findPrevCommand,
    'find-tab-hide':                  find.hideFindTab,
    'find-tab-open':                  find.openFindTab,
    'focus-to-find':                  find.focusToFind,
    'isearch-forward':                find.isearchForward,
    'isearch-backward':               find.isearchBackward,
    'isearch-forward-regexp':         find.isearchForwardRegexp,
    'isearch-backward-regexp':        find.isearchBackwardRegexp,
    'isearch-with-present-options':   find.isearchWithPresentOptions,
    'replace':                        find.change,
    'replace-all':                    find.minibufferReplaceAll,
    # 'replace-string':               find.setReplaceString,
    'replace-then-find':              find.changeThenFindCommand,
    're-search-forward':              find.reSearchForward,
    're-search-backward':             find.reSearchBackward,
    'search-forward':                 find.searchForward,
    'search-backward':                find.searchBackward,
    'search-with-present-options':    find.searchWithPresentOptions,
    'set-search-string':              find.searchWithPresentOptions,
    'set-replace-string':             find.setReplaceString,
    'set-find-everywhere':            find.setFindScopeEveryWhere,
    'set-find-node-only':             find.setFindScopeNodeOnly,
    'set-find-suboutline-only':       find.setFindScopeSuboutlineOnly,
    'show-find-options':              find.showFindOptions,
    'start-search':                   find.startSearch, # 4.11.1.
    'toggle-find-collapses-nodes':    find.toggleFindCollapesNodes,
    'toggle-find-ignore-case-option': find.toggleIgnoreCaseOption,
    'toggle-find-in-body-option':     find.toggleSearchBodyOption,
    'toggle-find-in-headline-option': find.toggleSearchHeadlineOption,
    'toggle-find-mark-changes-option':find.toggleMarkChangesOption,
    'toggle-find-mark-finds-option':  find.toggleMarkFindsOption,
    'toggle-find-regex-option':       find.toggleRegexOption,
    'toggle-find-word-option':        find.toggleWholeWordOption,
    'toggle-find-wrap-around-option': find.toggleWrapSearchOption,
    'word-search-forward':            find.wordSearchForward,
    'word-search-backward':           find.wordSearchBackward,
    }
</t>
<t tx="ekr.20150508132423.15">def getPublicCommands (self):

    return {
        'focus-to-spell-tab':       self.focusToSpell,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-find':               self.find,
        'spell-ignore':             self.ignore,
        'spell-tab-hide':           self.hide,
        'spell-tab-open':           self.openSpellTab,
        
        # these are for spell as you type, not the spell tab
        'spell-as-you-type-toggle': self.as_you_type_toggle,
        'spell-as-you-type-wrap':   self.as_you_type_wrap,
        'spell-as-you-type-next':   self.as_you_type_next,
        'spell-as-you-type-undo':   self.as_you_type_undo,        
    }
</t>
<t tx="ekr.20150508132423.16">def getPublicCommands (self):

    d = {
    'help':                             self.help,
    'help-for-abbreviations':           self.helpForAbbreviations,
    'help-for-autocompletion':          self.helpForAutocompletion,
    'help-for-bindings':                self.helpForBindings,
    'help-for-command':                 self.helpForCommand,
    'help-for-creating-external-files': self.helpForCreatingExternalFiles,
    'help-for-debugging-commands':      self.helpForDebuggingCommands,
    'help-for-drag-and-drop':           self.helpForDragAndDrop,
    'help-for-dynamic-abbreviations':   self.helpForDynamicAbbreviations,
    'help-for-find-commands':           self.helpForFindCommands,
    'help-for-minibuffer':              self.helpForMinibuffer,
    # 'help-for-python':                  self.pythonHelp,
    'help-for-regular-expressions':     self.helpForRegularExpressions,
    'help-for-scripting':               self.helpForScripting,
    'print-settings':                   self.printSettings,
    }
    if g.new_dispatch:
        pass
    else:
        d['help-for-python'] = self.pythonHelp
    return d
</t>
<t tx="ekr.20150508132423.17">def getPublicCommands (self):

    return {
        'backward-kill-sentence':   self.backwardKillSentence,
        'backward-kill-word':       self.backwardKillWord,
        'clear-kill-ring':          self.clearKillRing,
        'kill-line':                self.killLine,
        'kill-to-end-of-line':      self.killToEndOfLine,
        'kill-word':                self.killWord,
        'kill-sentence':            self.killSentence,
        'kill-region':              self.killRegion,
        'kill-region-save':         self.killRegionSave,
        'kill-ws':                  self.killWs,
        'yank':                     self.yank,
        'yank-pop':                 self.yankPop,
        'zap-to-character':         self.zapToCharacter,
    }
</t>
<t tx="ekr.20150508132423.18">def getPublicCommands (self):
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.'''
    c,k = self.c,self.k
    d2 = {}
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    # Create a callback for each item in d.
    for name in sorted(d):
        f = d.get(name)
        d2 [name] = f
        c.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
    return d2
</t>
<t tx="ekr.20150508132423.19">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'beautify':                     c.beautifyPythonCode,
    'beautify-c':                   c.beautifyCCode,
    'beautify-all':                 c.beautifyAllPythonCode,
    'beautify-tree':                c.beautifyPythonTree,
    'cascade-windows':              f.cascade,
    # 'check-all-python-code':      c.checkAllPythonCode,
    'check-derived-file':           c.atFileCommands.checkDerivedFile,
    'check-leo-file':               c.fileCommands.checkLeoFile,
    'check-outline':                c.fullCheckOutline,
    # 'check-python-code':          c.checkPythonCode,
    'clean-recent-files':           c.cleanRecentFiles,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'clone-node-to-last-node':      c.cloneToLastNode,
    'close-window':                 c.close,
    'contract-all':                 c.contractAllHeadlines,
    'contract-all-other-nodes':     c.contractAllOtherNodes,
    'contract-node':                c.contractNode,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-all-subheads':          c.expandAllSubheads,
        # Fixes bug 604037 Status of expandAllSubheads
    'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    # 'extract-python-method':        c.extractPythonMethod,
    # 'extract-section':              c.extractSection,
    'find-next-clone':              c.findNextClone,
    'flatten-outline':              c.flattenOutline,
    'flatten-outline-to-node':      c.flattenOutlineToNode,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-first-visible-node':      c.goToFirstVisibleNode,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible-node':       c.goToLastVisibleNode,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-history-node':       c.goToNextHistory,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-history-node':       c.goToPrevHistory,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hide-invisibles':              c.hideInvisibles,
    'hoist':                        c.hoist,
    'import-file':                  c.importAnyFile,
    # 'import-at-file':               c.importAtFile,
    # 'import-at-root':               c.importAtRoot,
    # 'import-cweb-files':            c.importCWEBFiles,
    # 'import-derived-file':          c.importDerivedFile,
    # 'import-flattened-outline':     c.importFlattenedOutline,
    # 'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-body-time':             c.insertBodyTime,
    'insert-child':                 c.insertChild,
    'insert-node':                  c.insertHeadline,
    'insert-node-before':            c.insertHeadlineBefore,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    # 'mark-changed-roots':           c.markChangedRoots,
    # 'mark-clones':                c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-brackets':               c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    # 'open-compare-window':        c.openCompareWindow,
    'open-cheat-sheet-leo':         c.openCheatSheet,
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-local-settings':          c.selectAtSettingsNode,
    'open-myLeoSettings-leo':       c.openMyLeoSettings,
    'open-offline-tutorial':        f.leoHelp,
    'open-online-home':             c.leoHome,
    'open-online-toc':              c.openLeoTOC,
    'open-online-tutorials':        c.openLeoTutorials,
    'open-online-videos':           c.openLeoVideos,
    # 'open-online-tutorial':       c.leoTutorial,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-quickstart-leo':          c.leoQuickStart,
    'open-scripts-leo':             c.openLeoScripts,
    'open-users-guide':             c.openLeoUsersGuide,
    'open-with':                    c.openWith,
    'outline-to-cweb':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-auto-nodes':           c.readAtAutoNodes,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-at-shadow-nodes':         c.readAtShadowNodes,
    'read-file-into-node':          c.readFileIntoNode,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    # 'reformat-body':              c.reformatBody, # 2013/10/02.
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'resize-to-screen':             f.resizeToScreen,
    'refresh-from-disk':            c.refreshFromDisk,
    'revert':                       c.revert,
    'save-all':                     c.saveAll,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-as-unzipped':        c.saveAsUnzipped,
    'save-file-as-zipped':          c.saveAsZipped,
    'save-file-to':                 c.saveTo,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'settings':                     c.preferences,
    'show-invisibles':              c.showInvisibles,
    'sort-children':                c.sortChildren,
    'sort-recent-files':            c.sortRecentFiles,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-invisibles':            c.toggleShowInvisibles,
    'toggle-sparse-move':           c.toggleSparseMove,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unformat-paragraph':           c.unformatParagraph,
    'unindent-region':              c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
    'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
    'write-file-from-node':         c.writeFileFromNode,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}
</t>
<t tx="ekr.20150508132423.2">def getPublicCommands (self):
    '''Return a dict: keys are command names and whose values are methods.'''
    return {
        # Reload.
        # 'reload-abbreviations': self.reloadAbbreviations,
        # Non-prefixed commands.
        'toggle-abbrev-mode':   self.toggleAbbrevMode,
        # Dynamic...
        'dabbrev-completion':   self.dynamicCompletion,
        'dabbrev-expands':      self.dynamicExpansion,
        # Static...
        'abbrev-add-global':        self.addAbbreviation,
        # 'abbrev-expand-region':   self.regionalExpandAbbrev,
        'abbrev-inverse-add-global':self.addInverseAbbreviation,
        'abbrev-kill-all':          self.killAllAbbrevs,
        'abbrev-list':              self.listAbbrevs,
        'abbrev-read':              self.readAbbreviations,
        'abbrev-write':             self.writeAbbreviations,
    }
</t>
<t tx="ekr.20150508132423.20">def getPublicCommands (self):

    return {
        'macro-call':           self.callNamedMacro,
        'macro-call-last':      self.callLastMacro,
        'macro-end-recording':  self.endMacro,
        'macro-load-all':       self.loadMacros,
        'macro-name-last':      self.nameLastMacro,
        'macro-print-all':      self.printMacros,
        'macro-print-last':     self.printLastMacro,
        'macro-save-all':       self.saveMacros,
        'macro-start-recording':self.startRecordingMacro,
    }
</t>
<t tx="ekr.20150508132423.21">def getPublicCommands (self):
    '''Add this class's commands to c.commandsDict.'''
    if not printsupport:
        return # A null-gui, without print support.
    self.c.commandsDict.update({
    # Preview.
    'preview-body':         self.preview_body,
    'preview-html':         self.preview_html,
    'preview-node':         self.preview_node,
    'preview-expanded-body': self.preview_expanded_body,
    'preview-expanded-html': self.preview_expanded_html,
    'preview-tree-bodies':  self.preview_tree_bodies,
    'preview-tree-html':    self.preview_tree_html,
    'preview-tree-nodes':   self.preview_tree_nodes,
    # Preview marked.
    'preview-marked-bodies':self.preview_marked_bodies,
    'preview-marked-html':  self.preview_marked_html,
    'preview-marked-nodes': self.preview_marked_nodes,
    # Selected node/tree.
    'print-body':           self.print_body,
    'print-html':           self.print_html,
    'print-node':           self.print_node,
    'print-expanded-body':  self.print_expanded_body,
    'print-expanded-html':  self.print_expanded_html,
    'print-tree-bodies':    self.print_tree_bodies,
    'print-tree-html':      self.print_tree_html,
    'print-tree-nodes':     self.print_tree_nodes,
    # Marked nodes.
    'print-marked-bodies':  self.print_marked_bodies,
    'print-marked-html':    self.print_marked_html,
    'print-marked-nodes':   self.print_marked_nodes,
})
</t>
<t tx="ekr.20150508132423.22">def getPublicCommands (self):

    return {
        'rectangle-clear':  self.clearRectangle,
        'rectangle-close':  self.closeRectangle,
        'rectangle-delete': self.deleteRectangle,
        'rectangle-kill':   self.killRectangle,
        'rectangle-open':   self.openRectangle,
        'rectangle-string': self.stringRectangle,
        'rectangle-yank':   self.yankRectangle,
    }
</t>
<t tx="ekr.20150508132423.23">def getPublicCommands (self):

    return {
        'register-append-to':           self.appendToRegister,
        'register-copy-rectangle-to':   self.copyRectangleToRegister,
        'register-copy-to':             self.copyToRegister,
        'register-increment':           self.incrementRegister,
        'register-insert':              self.insertRegister,
        'register-jump-to':             self.jumpToRegister,
        # 'register-number-to':         self.numberToRegister,
        'register-point-to':            self.pointToRegister,
        'register-prepend-to':          self.prependToRegister,
        'register-view':                self.viewRegister,
    }
</t>
<t tx="ekr.20150508132423.24">def getPublicCommands(self):
    '''Add the names of commands defined in this file to c.commandsDict'''
    self.c.commandsDict.update({
        'rst3': self.rst3, # Formerly write-restructured-text.
        'code-to-rst': self.code_to_rst_command,
    })
</t>
<t tx="ekr.20150508132423.25">def getPublicCommands(vc):
    '''Add the names of commands defined in this file to c.commandsDict'''
    vc.c.commandsDict.update({
        ':!':   vc.shell_command,
        ':%s':  vc.Substitution(vc,all_lines=True),
        ':e':   vc.Tabnew(vc),
        ':e!':  vc.revert,
        ':gT':  vc.cycle_all_focus,
        ':gt':  vc.cycle_focus,
        ':q!':  vc.quit_now,
        ':q':   vc.q_command,
        ':qa':  vc.qa_command,
        ':r':   vc.LoadFileAtCursor(vc),
        ':s':   vc.Substitution(vc,all_lines=False),
        ':w':   vc.w_command,
        ':wq':  vc.wq_command,
        ':xa':  vc.xa_command,
        # Longer names...
        ':print-dot':               vc.print_dot,
        ':tabnew':                  vc.Tabnew(vc),
        ':toggle-vim-mode':         vc.toggle_vim_mode,
        ':toggle-vim-trace':        vc.toggle_vim_trace,
        ':toggle-vim-trainer-mode': vc.toggle_vim_trainer_mode,
    })
</t>
<t tx="ekr.20150508132423.3">def getPublicCommands (self):

    '''Return a dict describing public commands implemented in the subclass.
    Keys are untranslated command names.  Values are methods of the subclass.'''

    return {}
</t>
<t tx="ekr.20150508132423.4">def getPublicCommands (self):

    return {

        # These do not seem useful.
            # 'copy-to-buffer':     self.copyToBuffer,
            # 'insert-to-buffer':   self.insertToBuffer,

        'buffer-append-to':             self.appendToBuffer,
        'buffer-kill':                  self.killBuffer,
        'buffer-prepend-to':            self.prependToBuffer,
        # 'buffer-rename':              self.renameBuffer,
        'buffer-switch-to':             self.switchToBuffer,
        'buffers-list':                 self.listBuffers,
        'buffers-list-alphabetically':  self.listBuffersAlphabetically,
    }
</t>
<t tx="ekr.20150508132423.5">def createCommandNames(self):
    '''Create all entries in c.commandsDict and c.inverseCommandsDict.'''
    c,k = self,self.k
    c.commandsDict = {}
    # A list of all subcommanders with a getPublicCommands method.
    #   c.editCommandsManager.getPublicCommands handles all
    #   subcommanders in leoEditCommands.py.
    for o in (c.editCommandsManager,c.rstCommands,c.printingController,c.vimCommands):
        if o: o.getPublicCommands()
    # copy global commands to this controller    
    for name,f in g.app.global_commands_dict.items():
        k.registerCommand(name,shortcut=None,func=f,pane='all',verbose=False)
    # Create the inverse dict last.
    c.createInverseCommandsDict()
</t>
<t tx="ekr.20150508132423.6">def createInverseCommandsDict (self):
    '''Add entries to k.inverseCommandsDict using c.commandsDict.

    c.commandsDict:        keys are command names, values are funcions f.
    c.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''
    c = self
    for name in c.commandsDict:
        f = c.commandsDict.get(name)
        try:
            c.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
        except Exception:
            # g.es_exception()
            g.trace(repr(name),repr(f))
</t>
<t tx="ekr.20150508132423.7">def getPublicCommands (self):

    c = self.c ; cc = c.chapterController

    if cc:
        return {
            'chapter-clone-node-to':    cc.cloneNodeToChapter,
            'chapter-convert-node-to':  cc.convertNodeToChapter,
            'chapter-copy-node-to':     cc.copyNodeToChapter,
            'chapter-create':           cc.createChapter,
            'chapter-create-from-node': cc.createChapterFromNode,
            'chapter-move-node-to':     cc.moveNodeToChapter,
            'chapter-remove':           cc.removeChapter,
            'chapter-rename':           cc.renameChapter,
            'chapter-select':           cc.selectChapter,
        }
    else:
        return {}
</t>
<t tx="ekr.20150508132423.8">def getPublicCommands (self):

    k = self.c.k

    return {

        # Miscellaneous.
        'advertised-undo':          self.advertizedUndo,
        'iconify-frame':            self.iconifyFrame, # Same as suspend.
        'keyboard-quit':            k and k.keyboardQuit,
        'save-buffers-kill-leo':    self.saveBuffersKillLeo,
        'set-silent-mode':          self.setSilentMode,
        'suspend':                  self.suspend,
        'act-on-node':              self.actOnNode,

        # Plugin info.
        'print-plugin-handlers':    self.printPluginHandlers,
        'print-plugins-info':       self.printPluginsInfo,

        # Shell commands.
        'shell-command':            self.shellCommand,
        'shell-command-on-region':  self.shellCommandOnRegion,
    }
</t>
<t tx="ekr.20150508132423.9">def getPublicCommands (self):

    return {

        # debugging.
        'debug':        self.invoke_debugger,
        'pdb':          self.pdb,
        'print-focus':  self.printFocus,

        # Tracing of garbase collecor.
        'gc-collect-garbage':       self.collectGarbage,
        'gc-dump-all-objects':      self.dumpAllObjects,
        'gc-dump-new-objects':      self.dumpNewObjects,
        'gc-dump-objects-verbose':  self.verboseDumpObjects,
        'gc-print-summary':         self.printGcSummary,
        'gc-trace-disable':         self.disableGcTrace,
        'gc-trace-enable':          self.enableGcTrace,

        # Unit tests run externally: deprecated.
        'run-all-unit-tests-externally':        self.runAllUnitTestsExternally,
            # was 'run-all-unit-tests.
        'run-marked-unit-tests-externally':     self.runMarkedUnitTestsExternally,
            # 2011/10/31: new.
        'run-selected-unit-tests-externally':   self.runSelectedUnitTestsExternally,
            # was 'run-unit-tests.

        # Unit tests run locally.
        'run-all-unit-tests-locally':       self.runAllUnitTestsLocally,
        'run-marked-unit-tests-locally':    self.runMarkedUnitTestsLocally,
            # 2011/10/31: new.
        'run-selected-unit-tests-locally':  self.runSelectedUnitTestsLocally,
    }
</t>
<t tx="ekr.20150508132430.1"></t>
<t tx="ekr.20150508132450.1">g.cls()

class CreateDecorators:
    '''
    A class to create decorators from tables in getPublicCommands.
    This class uses a node called "Found: getPublicCommands".
    
    This @button node must be executed in LeoPy.leo.
    '''
    def __init__(self,c):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
    @others

CreateDecorators(c).run()
</t>
<t tx="ekr.20150508132450.2">def create_d(self,lines,publicCommands):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    if trace:
        print('')
        g.trace(publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508132450.3">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    # g.trace('%45s %s' % (c_name,f_name))
    found = False
    for p in root.self_and_subtree():
        result = []
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    g.trace('duplicate def',f_name)
                else:
                    found = True
                    decorator = '@cmd(%s)\n' % (c_name)
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
    return found
</t>
<t tx="ekr.20150508132450.4">def create_decorators(self,d,root):
    '''Create decorators for all items in d in root's tree.'''
    print('\n%s\n' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found:
            g.trace('not found',f_name)
            self.n_fail += 1
</t>
<t tx="ekr.20150508132450.5">def create_fixups(self):
    '''
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    '''
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150508132450.6">def find_class(self,p):
    '''Return the position of the class enclosing p.'''
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508132450.7">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150508132450.8">def munge_lines(self,root,publicCommands):
    '''Return munged lines of '''
    # print('')
    # g.trace(root.h)
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    # print(s)
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    # print('\n'.join(lines))
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508132450.9">def run(self):
    '''Top-level code.'''
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150525161132.1">r'''The script to test AddTokensToTree class.'''
g.cls()
if c.isChanged():
    c.save()
&lt;&lt; imports &gt;&gt;
project = False
if project:
    aList = leoBeautify.ProjectUtils().project_files('leo')
    aList = ['@file %s' % (g.shortFileName(z).rstrip()) for z in aList]
    aList = aList
    settings_d = {}
else:
    aList = [
        'unit test: leoBeautify.py',
        # '@file leoFileCommands.py',
        # '@file leoBeautify.py',
    ]
    settings_d = {
        'ast_tokens_d': False,
        'stats': True,
        'input_string': True,
        'input_lines': False,
        'input_tokens': False,
        'token_list': False,
        'code_list': False,
        'output_string': True,
    }
assert aList,'no input in %s' % (p.h)
t1 = time.clock()
for h in aList:
    p2 = g.findNodeAnywhere(c,h)
    if p2:
        try:
            leoBeautify.test_LeoTidy(c,h,p2,settings_d)
        except Exception:
            g.es_exception()
if project:
    print('done: %4.2f sec.' % (time.clock()-t1))
</t>
<t tx="ekr.20150525161132.2"># import leo.external.PythonTidy as PythonTidy
import leo.core.leoAst as leoAst
import leo.core.leoBeautify as leoBeautify
import imp
import time
imp.reload(leoAst)
imp.reload(leoBeautify)
# imp.reload(PythonTidy)</t>
<t tx="ekr.20160123185231.1">#!/usr/bin/env python
&lt;&lt; docstring &gt;&gt;

import ast
try:
    import ConfigParser as configparser # Python 2
except ImportError:
    import configparser # Python 3
import glob
import os
import re
@others

if __name__ == "__main__":
    main()
</t>
<t tx="ekr.20160123185308.1">'''
Make a stub file in the ~/home directory for every @&lt;file&gt; node in the
selected tree.
'''
import ast
import os
import textwrap
import leo.core.leoGlobals as g
@others
MakeStubFile(c).run(c.p)
</t>
<t tx="ekr.20160123185308.10">def format(self, node):
    '''Format the node (or list of nodes) and its descendants.'''
    self.level = 0
    val = self.visit(node)
    return val and val.strip() or ''
</t>
<t tx="ekr.20160123185308.11">def visit(self, node):
    '''Return the formatted version of an Ast node, or list of Ast nodes.'''
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    elif node is None:
        return 'None'
    else:
        assert isinstance(node, ast.AST), node.__class__.__name__
        method_name = 'do_' + node.__class__.__name__
        method = getattr(self, method_name)
        s = method(node)
        # pylint: disable=unidiomatic-typecheck
        assert type(s) == type('abc'), type(s)
        return s
</t>
<t tx="ekr.20160123185308.12"></t>
<t tx="ekr.20160123185308.13"># ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef(self, node):
    result = []
    name = node.name # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if bases:
        result.append(self.indent('class %s(%s):\n' % (name, ','.join(bases))))
    else:
        result.append(self.indent('class %s:\n' % name))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.14"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef(self, node):
    '''Format a FunctionDef node.'''
    result = []
    if node.decorator_list:
        for z in node.decorator_list:
            result.append('@%s\n' % self.visit(z))
    name = node.name # Only a plain string is valid.
    args = self.visit(node.args) if node.args else ''
    result.append(self.indent('def %s(%s):\n' % (name, args)))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.15">def do_Interactive(self, node):
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160123185308.16">def do_Module(self, node):
    assert 'body' in node._fields
    result = ''.join([self.visit(z) for z in node.body])
    return result # 'module:\n%s' % (result)
</t>
<t tx="ekr.20160123185308.17">def do_Lambda(self, node):
    return self.indent('lambda %s: %s' % (
        self.visit(node.args),
        self.visit(node.body)))
</t>
<t tx="ekr.20160123185308.18"></t>
<t tx="ekr.20160123185308.19">def do_Expr(self, node):
    '''An outer expression: must be indented.'''
    return self.indent('%s\n' % self.visit(node.value))
</t>
<t tx="ekr.20160123185308.2">class MakeStubFile:
    '''A class to make Python stub (.pyi) files.'''
    @others
</t>
<t tx="ekr.20160123185308.20">def do_Expression(self, node):
    '''An inner expression: do not indent.'''
    return '%s\n' % self.visit(node.body)
</t>
<t tx="ekr.20160123185308.21">def do_GeneratorExp(self, node):
    elt = self.visit(node.elt) or ''
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] ### Kludge: probable bug.
    return '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
</t>
<t tx="ekr.20160123185308.22">def do_AugLoad(self, node):
    return 'AugLoad'

def do_Del(self, node):
    return 'Del'

def do_Load(self, node):
    return 'Load'

def do_Param(self, node):
    return 'Param'

def do_Store(self, node):
    return 'Store'
</t>
<t tx="ekr.20160123185308.23"></t>
<t tx="ekr.20160123185308.24"># arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def do_arguments(self, node):
    '''Format the arguments node.'''
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    # Assign default values to the last args.
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    # Now add the vararg and kwarg args.
    name = getattr(node, 'vararg', None)
    if name: args2.append('*' + name)
    name = getattr(node, 'kwarg', None)
    if name: args2.append('**' + name)
    return ','.join(args2)
</t>
<t tx="ekr.20160123185308.25"># Python 3:
# arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if node.annotation:
        return self.visit(node.annotation)
    else:
        return ''
</t>
<t tx="ekr.20160123185308.26"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    return '%s.%s' % (
        self.visit(node.value),
        node.attr) # Don't visit node.attr: it is always a string.
</t>
<t tx="ekr.20160123185308.27">def do_Bytes(self, node): # Python 3.x only.
    assert g.isPython3
    return str(node.s)
</t>
<t tx="ekr.20160123185308.28"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    # g.trace(node,Utils().dump_ast(node))
    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    if getattr(node, 'starargs', None):
        args.append('*%s' % (self.visit(node.starargs)))
    if getattr(node, 'kwargs', None):
        args.append('**%s' % (self.visit(node.kwargs)))
    args = [z for z in args if z] # Kludge: Defensive coding.
    return '%s(%s)' % (func, ','.join(args))
</t>
<t tx="ekr.20160123185308.29"># keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    value = self.visit(node.value)
    # This is a keyword *arg*, not a Python keyword!
    return '%s=%s' % (node.arg, value)
</t>
<t tx="ekr.20160123185308.3">def __init__(self, c):
    self.c = c
    self.d = self.scan_types_data(c) or self.make_types_dict(c)
        # Keys are strings, values are Type objects.
</t>
<t tx="ekr.20160123185308.30">def do_comprehension(self, node):
    result = []
    name = self.visit(node.target) # A name.
    it = self.visit(node.iter) # An attribute.
    result.append('%s in %s' % (name, it))
    ifs = [self.visit(z) for z in node.ifs]
    if ifs:
        result.append(' if %s' % (''.join(ifs)))
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.31">def do_Dict(self, node):
    result = []
    keys = [self.visit(z) for z in node.keys]
    values = [self.visit(z) for z in node.values]
    if len(keys) == len(values):
        result.append('{\n' if keys else '{')
        items = []
        for i in range(len(keys)):
            items.append('  %s:%s' % (keys[i], values[i]))
        result.append(',\n'.join(items))
        result.append('\n}' if keys else '}')
    else:
        print('Error: f.Dict: len(keys) != len(values)\nkeys: %s\nvals: %s' % (
            repr(keys), repr(values)))
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.32">def do_Ellipsis(self, node):
    return '...'
</t>
<t tx="ekr.20160123185308.33">def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
</t>
<t tx="ekr.20160123185308.34">def do_Index(self, node):
    return self.visit(node.value)
</t>
<t tx="ekr.20160123185308.35">def do_List(self, node):
    # Not used: list context.
    # self.visit(node.ctx)
    elts = [self.visit(z) for z in node.elts]
    elst = [z for z in elts if z] # Defensive.
    return '[%s]' % ','.join(elts)
</t>
<t tx="ekr.20160123185308.36">def do_ListComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] ### Kludge: probable bug.
    return '%s for %s' % (elt, ''.join(gens))
</t>
<t tx="ekr.20160123185308.37">def do_Name(self, node):
    return node.id
</t>
<t tx="ekr.20160123185308.38">def do_Num(self, node):
    return repr(node.n)
</t>
<t tx="ekr.20160123185308.39"># Python 2.x only

def do_Repr(self, node):
    return 'repr(%s)' % self.visit(node.value)
</t>
<t tx="ekr.20160123185308.4">def make_types_dict(self, c):
    '''Return a dict whose keys are names and values are type specs.'''
    return {
        'aList': 'Sequence',
        'aList2': 'Sequence',
        'c': 'Commander',
        'i': 'int',
        'j': 'int',
        'k': 'int',
        'node': 'ast.Ast',
        'p': 'Position',
        's': 'str',
        's2': 'str',
        'v': 'VNode',
    }
</t>
<t tx="ekr.20160123185308.40">def do_Slice(self, node):
    lower, upper, step = '', '', ''
    if getattr(node, 'lower', None) is not None:
        lower = self.visit(node.lower)
    if getattr(node, 'upper', None) is not None:
        upper = self.visit(node.upper)
    if getattr(node, 'step', None) is not None:
        step = self.visit(node.step)
    if step:
        return '%s:%s:%s' % (lower, upper, step)
    else:
        return '%s:%s' % (lower, upper)
</t>
<t tx="ekr.20160123185308.41">def do_Str(self, node):
    '''This represents a string constant.'''
    return repr(node.s)
</t>
<t tx="ekr.20160123185308.42"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    value = self.visit(node.value)
    the_slice = self.visit(node.slice)
    return '%s[%s]' % (value, the_slice)
</t>
<t tx="ekr.20160123185308.43">def do_Tuple(self, node):
    elts = [self.visit(z) for z in node.elts]
    return '(%s)' % ','.join(elts)
</t>
<t tx="ekr.20160123185308.44"></t>
<t tx="ekr.20160123185308.45">def do_BinOp(self, node):
    return '%s%s%s' % (
        self.visit(node.left),
        self.op_name(node.op),
        self.visit(node.right))
</t>
<t tx="ekr.20160123185308.46">def do_BoolOp(self, node):
    op_name = self.op_name(node.op)
    values = [self.visit(z) for z in node.values]
    return op_name.join(values)
</t>
<t tx="ekr.20160123185308.47">def do_Compare(self, node):
    result = []
    lt = self.visit(node.left)
    # ops   = [self.visit(z) for z in node.ops]
    ops = [self.op_name(z) for z in node.ops]
    comps = [self.visit(z) for z in node.comparators]
    result.append(lt)
    if len(ops) == len(comps):
        for i in range(len(ops)):
            result.append('%s%s' % (ops[i], comps[i]))
    else:
        g.trace('ops', repr(ops), 'comparators', repr(comps))
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.48">def do_UnaryOp(self, node):
    return '%s%s' % (
        self.op_name(node.op),
        self.visit(node.operand))
</t>
<t tx="ekr.20160123185308.49">def do_IfExp(self, node):
    return '%s if %s else %s ' % (
        self.visit(node.body),
        self.visit(node.test),
        self.visit(node.orelse))
</t>
<t tx="ekr.20160123185308.5">def scan_types_data(self, c):
    '''Create self.d from @data stub-types nodes.'''
    aList = c.config.getData(
        'stub-types',
        strip_comments=True,
        strip_data=True)
    d = {}
    for s in aList:
        name, value = s.split(None,1)
        d[name.strip()] = value.strip()
    if False:
        for key in sorted(d.keys()):
            g.trace(key, d.get(key))
    return d
</t>
<t tx="ekr.20160123185308.50"></t>
<t tx="ekr.20160123185308.51">def do_Assert(self, node):
    test = self.visit(node.test)
    if getattr(node, 'msg', None):
        message = self.visit(node.msg)
        return self.indent('assert %s, %s' % (test, message))
    else:
        return self.indent('assert %s' % test)
</t>
<t tx="ekr.20160123185308.52">def do_Assign(self, node):
    return self.indent('%s=%s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
</t>
<t tx="ekr.20160123185308.53">def do_AugAssign(self, node):
    return self.indent('%s%s=%s\n' % (
        self.visit(node.target),
        self.op_name(node.op), # Bug fix: 2013/03/08.
        self.visit(node.value)))
</t>
<t tx="ekr.20160123185308.54">def do_Break(self, node):
    return self.indent('break\n')
</t>
<t tx="ekr.20160123185308.55">def do_Continue(self, node):
    return self.indent('continue\n')
</t>
<t tx="ekr.20160123185308.56">def do_Delete(self, node):
    targets = [self.visit(z) for z in node.targets]
    return self.indent('del %s\n' % ','.join(targets))
</t>
<t tx="ekr.20160123185308.57">def do_ExceptHandler(self, node):
    result = []
    result.append(self.indent('except'))
    if getattr(node, 'type', None):
        result.append(' %s' % self.visit(node.type))
    if getattr(node, 'name', None):
        if isinstance(node.name, ast.AST):
            result.append(' as %s' % self.visit(node.name))
        else:
            result.append(' as %s' % node.name) # Python 3.x.
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.58"># Python 2.x only

def do_Exec(self, node):
    body = self.visit(node.body)
    args = [] # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent('exec %s in %s\n' % (
            body, ','.join(args)))
    else:
        return self.indent('exec %s\n' % (body))
</t>
<t tx="ekr.20160123185308.59">def do_For(self, node):
    result = []
    result.append(self.indent('for %s in %s:\n' % (
        self.visit(node.target),
        self.visit(node.iter))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.6">def make_stub_file(self, p):
    '''Make a stub file in ~/stubs for the @&lt;file&gt; node at p.'''
    import ast
    import leo.core.leoAst as leoAst
    assert p.isAnyAtFileNode()
    c = self.c
    fn = p.anyAtFileNodeName()
    if not fn.endswith('.py'):
        g.es_print('not a python file', fn)
        return
    ### abs_fn = g.os_path_finalize_join(g.app.loadDir, fn)
    abs_fn = g.fullPath(c, p)
    if not g.os_path_exists(abs_fn):
        g.es_print('not found', abs_fn)
        return
    stubs = g.os_path_finalize(g.os_path_expanduser('~/stubs'))
    if g.os_path_exists(stubs):
        base_fn = g.os_path_basename(fn)
        out_fn = g.os_path_finalize_join(stubs,base_fn)
    else:
        g.es_print('not found', stubs)
        return
        # out_fn = g.os_path_finalize_join(g.app.loadDir, fn)
    out_fn = out_fn[:-3] + '.pyi'
    s = open(abs_fn).read()
    node = ast.parse(s,filename=fn,mode='exec')
    leoAst.StubTraverser(self.c, self.d, out_fn).run(node)
</t>
<t tx="ekr.20160123185308.60">def do_Global(self, node):
    return self.indent('global %s\n' % (
        ','.join(node.names)))
</t>
<t tx="ekr.20160123185308.61">def do_If(self, node):
    result = []
    result.append(self.indent('if %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.62">def do_Import(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('import %s\n' % (
        ','.join(names)))
</t>
<t tx="ekr.20160123185308.63">def get_import_names(self, node):
    '''Return a list of the the full file names in the import statement.'''
    result = []
    for ast2 in node.names:
        if self.kind(ast2) == 'alias':
            data = ast2.name, ast2.asname
            result.append(data)
        else:
            g.trace('unsupported kind in Import.names list', self.kind(ast2))
    return result
</t>
<t tx="ekr.20160123185308.64">def do_ImportFrom(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('from %s import %s\n' % (
        node.module,
        ','.join(names)))
</t>
<t tx="ekr.20160123185308.65">def do_Pass(self, node):
    return self.indent('pass\n')
</t>
<t tx="ekr.20160123185308.66"># Python 2.x only

def do_Print(self, node):
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append('dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        # vals.append('nl=%s' % self.visit(node.nl))
        vals.append('nl=%s' % node.nl)
    return self.indent('print(%s)\n' % (
        ','.join(vals)))
</t>
<t tx="ekr.20160123185308.67">def do_Raise(self, node):
    args = []
    for attr in ('type', 'inst', 'tback'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent('raise %s\n' % (
            ','.join(args)))
    else:
        return self.indent('raise\n')
</t>
<t tx="ekr.20160123185308.68">def do_Return(self, node):
    if node.value:
        return self.indent('return %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('return\n')
</t>
<t tx="ekr.20160123185308.69"># def do_Suite(self,node):
    # for z in node.body:
        # s = self.visit(z)
</t>
<t tx="ekr.20160123185308.7">def run(self, p):
    '''Make stub files for all files in p's tree.'''
    if p.isAnyAtFileNode():
        self.make_stub_file(p)
        return
    # First, look down tree.
    after, p2 = p.nodeAfterTree(), p.firstChild()
    found = False
    while p2 and p != after:
        if p2.isAnyAtFileNode():
            self.make_stub_file(p2)
            p2.moveToNext()
            found = True
        else:
            p2.moveToThreadNext()
    if not found:
        # Look up the tree.
        for p2 in p.parents():
            if p2.isAnyAtFileNode():
                self.make_stub_file(p2)
                break
        else:
            g.es('no files found in tree:', p.h)
</t>
<t tx="ekr.20160123185308.70">def do_TryExcept(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.71">def do_TryFinally(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.72">def do_While(self, node):
    result = []
    result.append(self.indent('while %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.73">def do_With(self, node):
    result = []
    result.append(self.indent('with '))
    if hasattr(node, 'context_expression'):
        result.append(self.visit(node.context_expresssion))
    vars_list = []
    if hasattr(node, 'optional_vars'):
        try:
            for z in node.optional_vars:
                vars_list.append(self.visit(z))
        except TypeError: # Not iterable.
            vars_list.append(self.visit(node.optional_vars))
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append('\n')
    return ''.join(result)
</t>
<t tx="ekr.20160123185308.74">def do_Yield(self, node):
    if getattr(node, 'value', None):
        return self.indent('yield %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('yield\n')
</t>
<t tx="ekr.20160123185308.75"></t>
<t tx="ekr.20160123185308.76">def kind(self, node):
    '''Return the name of node's class.'''
    return node.__class__.__name__
</t>
<t tx="ekr.20160123185308.77">def indent(self, s):
    return '%s%s' % (' ' * 4 * self.level, s)
</t>
<t tx="ekr.20160123185308.78">@nobeautify

def op_name (self,node,strict=True):
    '''Return the print name of an operator node.'''
    d = {
        # Binary operators. 
        'Add':       '+',
        'BitAnd':    '&amp;',
        'BitOr':     '|',
        'BitXor':    '^',
        'Div':       '/',
        'FloorDiv':  '//',
        'LShift':    '&lt;&lt;',
        'Mod':       '%',
        'Mult':      '*',
        'Pow':       '**',
        'RShift':    '&gt;&gt;',
        'Sub':       '-',
        # Boolean operators.
        'And':   ' and ',
        'Or':    ' or ',
        # Comparison operators
        'Eq':    '==',
        'Gt':    '&gt;',
        'GtE':   '&gt;=',
        'In':    ' in ',
        'Is':    ' is ',
        'IsNot': ' is not ',
        'Lt':    '&lt;',
        'LtE':   '&lt;=',
        'NotEq': '!=',
        'NotIn': ' not in ',
        # Context operators.
        'AugLoad':  '&lt;AugLoad&gt;',
        'AugStore': '&lt;AugStore&gt;',
        'Del':      '&lt;Del&gt;',
        'Load':     '&lt;Load&gt;',
        'Param':    '&lt;Param&gt;',
        'Store':    '&lt;Store&gt;',
        # Unary operators.
        'Invert':   '~',
        'Not':      ' not ',
        'UAdd':     '+',
        'USub':     '-',
    }
    name = d.get(self.kind(node),'&lt;%s&gt;' % node.__class__.__name__)
    if strict: assert name,self.kind(node)
    return name
</t>
<t tx="ekr.20160123185308.79">class StubFormatter (AstFormatter):
    @others
</t>
<t tx="ekr.20160123185308.8">class AstFormatter:
    '''
    A class to recreate source code from an AST.
    
    This does not have to be perfect, but it should be close.
    
    Also supports optional annotations such as line numbers, file names, etc.
    '''
    # No ctor.
    # pylint: disable=consider-using-enumerate
    @others
</t>
<t tx="ekr.20160123185308.80"># Return generic markers allow better pattern matches.

def do_BoolOp(self, node): # Python 2.x only.
    return 'bool'

def do_Bytes(self, node): # Python 3.x only.
    return 'bytes' # return str(node.s)

def do_Name(self, node):
    return 'bool' if node.id in ('True', 'False') else node.id

def do_Num(self, node):
    return 'number' # return repr(node.n)

def do_Str(self, node):
    '''This represents a string constant.'''
    return 'str' # return repr(node.s)
</t>
<t tx="ekr.20160123185308.81">class StubTraverser (ast.NodeVisitor):
    
    def __init__(self, c, d, output_fn):
        '''Ctor for StubTraverser class.'''
        self.c = c
        self.d = d
        self.format = StubFormatter().format
        self.in_function = False
        self.level = 0
        self.output_file = None
        self.output_fn = output_fn
        self.returns = set()

    @others
</t>
<t tx="ekr.20160123185308.82">def indent(self, s):
    '''Return s, properly indented.'''
    return '%s%s' % (' ' * 4 * self.level, s)

def out(self, s):
    '''Output the string to the console or the file.'''
    if self.output_file:
        self.output_file.write(self.indent(s)+'\n')
    else:
        print(self.indent(s))
</t>
<t tx="ekr.20160123185308.83">def run(self, node):
    '''StubTraverser.run: write the stubs in node's tree to self.output_fn.'''
    c = self.c
    dir_ = g.os_path_dirname(self.output_fn)
    if g.os_path_exists(dir_):
        self.output_file = open(self.output_fn, 'w')
        aList = c.config.getData('stub-prefix')
        if aList:
            for z in aList:
                self.out(z.strip())
        self.visit(node)
        self.output_file.close()
        self.output_file = None
        g.es_print('wrote', self.output_fn)
    else:
        g.es_print('not found:', dir_)

</t>
<t tx="ekr.20160123185308.84"># This is needed only when subclassing from the leoAst.AstFullTraverser class.

# def visit(self, node):
    # '''Visit a *single* ast node.  Visitors are responsible for visiting children!'''
    # assert isinstance(node, ast.AST), node.__class__.__name__
    # method = getattr(self, 'do_' + node.__class__.__name__)
    # method(node)
</t>
<t tx="ekr.20160123185308.85"></t>
<t tx="ekr.20160123185308.86"># ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def visit_ClassDef(self, node):

    # Format...
    if not node.name.startswith('_'):
        if node.bases:
            s = '(%s)' % ','.join([self.format(z) for z in node.bases])
        else:
            s = ''
        self.out('class %s%s:' % (node.name, s))
    # Visit...
    self.level += 1
    old_in_function = self.in_function
    self.in_function = False
    for z in node.body:
        self.visit(z)
    self.level -= 1
    self.in_function = old_in_function
</t>
<t tx="ekr.20160123185308.87"># FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def visit_FunctionDef(self, node):
    
    # Do nothing if we are already in a function.
    # We do not generate stubs for inner defs.
    if self.in_function or node.name.startswith('_'):
        return
    # First, visit the function body.
    self.returns = set()
    self.in_function = True
    self.level += 1
    for z in node.body:
        self.visit(z)
    self.level -= 1
    self.in_function = False
    # Format *after* traversing
    self.out('def %s(%s) -&gt; %s: ...' % (
        node.name,
        self.format_arguments(node.args),
        self.format_returns(node)))
</t>
<t tx="ekr.20160123185308.88"># arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def format_arguments(self, node):
    '''
    Format the arguments node.
    Similar to AstFormat.do_arguments, but it is not a visitor!
    '''
    assert isinstance(node,ast.arguments), node
    args = [self.format(z) for z in node.args]
    defaults = [self.format(z) for z in node.defaults]
    # Assign default values to the last args.
    result = []
    n_plain = len(args) - len(defaults)
    # pylint: disable=consider-using-enumerate
    for i in range(len(args)):
        s = self.munge_arg(args[i])
        if i &lt; n_plain:
            result.append(s)
        else:
            result.append('%s=%s' % (s, defaults[i - n_plain]))
    # Now add the vararg and kwarg args.
    name = getattr(node, 'vararg', None)
    if name: result.append('*' + name)
    name = getattr(node, 'kwarg', None)
    if name: result.append('**' + name)
    return ', '.join(result)
</t>
<t tx="ekr.20160123185308.89">def munge_arg(self, s):
    '''Add an annotation for s if possible.'''
    a = self.d.get(s)
    return '%s: %s' % (s, a) if a else s
</t>
<t tx="ekr.20160123185308.9"></t>
<t tx="ekr.20160123185308.90">def format_returns(self, node):
    '''Calculate the return type.'''
    def split(s):
        return '\n     ' + self.indent(s) if len(s) &gt; 30 else s
        
    r = list(self.returns)
    r = [self.format(z) for z in r]
    # if r: g.trace(r)
    if len(r) == 0:
        return 'None'
    if len(r) == 1:
        return split(r[0])
    elif 'None' in r:
        r.remove('None')
        return split('Optional[%s]' % ', '.join(r))
    else:
        # return 'Any'
        s = ', '.join(r)
        if len(s) &gt; 30:
            return ', '.join(['\n    ' + self.indent(z) for z in r])
        else:
            return split(', '.join(r))
</t>
<t tx="ekr.20160123185308.91">def visit_Return(self, node):

    self.returns.add(node.value)
</t>
<t tx="ekr.20160123185312.10">
def format(self, node):
    '''Format the node (or list of nodes) and its descendants.'''
    self.level = 0
    val = self.visit(node)
    return val and val.strip() or ''
</t>
<t tx="ekr.20160123185312.11">
def visit(self, node):
    '''Return the formatted version of an Ast node, or list of Ast nodes.'''
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    elif node is None:
        return 'None'
    else:
        assert isinstance(node, ast.AST), node.__class__.__name__
        method_name = 'do_' + node.__class__.__name__
        method = getattr(self, method_name)
        s = method(node)
        # pylint: disable=unidiomatic-typecheck
        assert type(s) == type('abc'), type(s)
        return s
</t>
<t tx="ekr.20160123185312.12">
# Contexts...
</t>
<t tx="ekr.20160123185312.13">
# ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def do_ClassDef(self, node):
    result = []
    name = node.name # Only a plain string is valid.
    bases = [self.visit(z) for z in node.bases] if node.bases else []
    if bases:
        result.append(self.indent('class %s(%s):\n' % (name, ','.join(bases))))
    else:
        result.append(self.indent('class %s:\n' % name))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.14">
# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def do_FunctionDef(self, node):
    '''Format a FunctionDef node.'''
    result = []
    if node.decorator_list:
        for z in node.decorator_list:
            result.append('@%s\n' % self.visit(z))
    name = node.name # Only a plain string is valid.
    args = self.visit(node.args) if node.args else ''
    result.append(self.indent('def %s(%s):\n' % (name, args)))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.15">
def do_Interactive(self, node):
    for z in node.body:
        self.visit(z)
</t>
<t tx="ekr.20160123185312.16">
def do_Module(self, node):
    assert 'body' in node._fields
    result = ''.join([self.visit(z) for z in node.body])
    return result # 'module:\n%s' % (result)
</t>
<t tx="ekr.20160123185312.17">
def do_Lambda(self, node):
    return self.indent('lambda %s: %s' % (
        self.visit(node.args),
        self.visit(node.body)))
</t>
<t tx="ekr.20160123185312.18">
# Expressions...
</t>
<t tx="ekr.20160123185312.19">
def do_Expr(self, node):
    '''An outer expression: must be indented.'''
    return self.indent('%s\n' % self.visit(node.value))
</t>
<t tx="ekr.20160123185312.2">

class StandAloneMakeStubFile:
    '''
    A class to make Python stub (.pyi) files in the ~/stubs directory for
    every file mentioned in the [Source Files] section of
    ~/stubs/make_stub_files.cfg.
    '''
    @others
</t>
<t tx="ekr.20160123185312.20">
def do_Expression(self, node):
    '''An inner expression: do not indent.'''
    return '%s\n' % self.visit(node.body)
</t>
<t tx="ekr.20160123185312.21">
def do_GeneratorExp(self, node):
    elt = self.visit(node.elt) or ''
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] ### Kludge: probable bug.
    return '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
</t>
<t tx="ekr.20160123185312.22">
def do_AugLoad(self, node):
    return 'AugLoad'

def do_Del(self, node):
    return 'Del'

def do_Load(self, node):
    return 'Load'

def do_Param(self, node):
    return 'Param'

def do_Store(self, node):
    return 'Store'
</t>
<t tx="ekr.20160123185312.23">
# Operands...
</t>
<t tx="ekr.20160123185312.24">
# arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def do_arguments(self, node):
    '''Format the arguments node.'''
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    # Assign default values to the last args.
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    # Now add the vararg and kwarg args.
    name = getattr(node, 'vararg', None)
    if name: args2.append('*' + name)
    name = getattr(node, 'kwarg', None)
    if name: args2.append('**' + name)
    return ','.join(args2)
</t>
<t tx="ekr.20160123185312.25">
# Python 3:
# arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if node.annotation:
        return self.visit(node.annotation)
    else:
        return ''
</t>
<t tx="ekr.20160123185312.26">
# Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):
    return '%s.%s' % (
        self.visit(node.value),
        node.attr) # Don't visit node.attr: it is always a string.
</t>
<t tx="ekr.20160123185312.27">
def do_Bytes(self, node): # Python 3.x only.
    return str(node.s)
</t>
<t tx="ekr.20160123185312.28">
# Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def do_Call(self, node):
    func = self.visit(node.func)
    args = [self.visit(z) for z in node.args]
    for z in node.keywords:
        # Calls f.do_keyword.
        args.append(self.visit(z))
    if getattr(node, 'starargs', None):
        args.append('*%s' % (self.visit(node.starargs)))
    if getattr(node, 'kwargs', None):
        args.append('**%s' % (self.visit(node.kwargs)))
    args = [z for z in args if z] # Kludge: Defensive coding.
    return '%s(%s)' % (func, ','.join(args))
</t>
<t tx="ekr.20160123185312.29">
# keyword = (identifier arg, expr value)

def do_keyword(self, node):
    # node.arg is a string.
    value = self.visit(node.value)
    # This is a keyword *arg*, not a Python keyword!
    return '%s=%s' % (node.arg, value)
</t>
<t tx="ekr.20160123185312.30">
def do_comprehension(self, node):
    result = []
    name = self.visit(node.target) # A name.
    it = self.visit(node.iter) # An attribute.
    result.append('%s in %s' % (name, it))
    ifs = [self.visit(z) for z in node.ifs]
    if ifs:
        result.append(' if %s' % (''.join(ifs)))
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.31">
def do_Dict(self, node):
    result = []
    keys = [self.visit(z) for z in node.keys]
    values = [self.visit(z) for z in node.values]
    if len(keys) == len(values):
        result.append('{\n' if keys else '{')
        items = []
        for i in range(len(keys)):
            items.append('  %s:%s' % (keys[i], values[i]))
        result.append(',\n'.join(items))
        result.append('\n}' if keys else '}')
    else:
        print('Error: f.Dict: len(keys) != len(values)\nkeys: %s\nvals: %s' % (
            repr(keys), repr(values)))
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.32">
def do_Ellipsis(self, node):
    return '...'
</t>
<t tx="ekr.20160123185312.33">
def do_ExtSlice(self, node):
    return ':'.join([self.visit(z) for z in node.dims])
</t>
<t tx="ekr.20160123185312.34">
def do_Index(self, node):
    return self.visit(node.value)
</t>
<t tx="ekr.20160123185312.35">
def do_List(self, node):
    # Not used: list context.
    # self.visit(node.ctx)
    elts = [self.visit(z) for z in node.elts]
    elst = [z for z in elts if z] # Defensive.
    return '[%s]' % ','.join(elts)
</t>
<t tx="ekr.20160123185312.36">
def do_ListComp(self, node):
    elt = self.visit(node.elt)
    gens = [self.visit(z) for z in node.generators]
    gens = [z if z else '&lt;**None**&gt;' for z in gens] ### Kludge: probable bug.
    return '%s for %s' % (elt, ''.join(gens))
</t>
<t tx="ekr.20160123185312.37">
def do_Name(self, node):
    return node.id
</t>
<t tx="ekr.20160123185312.38">
def do_Num(self, node):
    return repr(node.n)
</t>
<t tx="ekr.20160123185312.39">
# Python 2.x only

def do_Repr(self, node):
    return 'repr(%s)' % self.visit(node.value)
</t>
<t tx="ekr.20160123185312.40">
def do_Slice(self, node):
    lower, upper, step = '', '', ''
    if getattr(node, 'lower', None) is not None:
        lower = self.visit(node.lower)
    if getattr(node, 'upper', None) is not None:
        upper = self.visit(node.upper)
    if getattr(node, 'step', None) is not None:
        step = self.visit(node.step)
    if step:
        return '%s:%s:%s' % (lower, upper, step)
    else:
        return '%s:%s' % (lower, upper)
</t>
<t tx="ekr.20160123185312.41">
def do_Str(self, node):
    '''This represents a string constant.'''
    return repr(node.s)
</t>
<t tx="ekr.20160123185312.42">
# Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):
    value = self.visit(node.value)
    the_slice = self.visit(node.slice)
    return '%s[%s]' % (value, the_slice)
</t>
<t tx="ekr.20160123185312.43">
def do_Tuple(self, node):
    elts = [self.visit(z) for z in node.elts]
    return '(%s)' % ','.join(elts)
</t>
<t tx="ekr.20160123185312.44">
# Operators...
</t>
<t tx="ekr.20160123185312.45">
def do_BinOp(self, node):
    return '%s%s%s' % (
        self.visit(node.left),
        self.op_name(node.op),
        self.visit(node.right))
</t>
<t tx="ekr.20160123185312.46">
def do_BoolOp(self, node):
    op_name = self.op_name(node.op)
    values = [self.visit(z) for z in node.values]
    return op_name.join(values)
</t>
<t tx="ekr.20160123185312.47">
def do_Compare(self, node):
    result = []
    lt = self.visit(node.left)
    ops = [self.op_name(z) for z in node.ops]
    comps = [self.visit(z) for z in node.comparators]
    result.append(lt)
    if len(ops) == len(comps):
        for i in range(len(ops)):
            result.append('%s%s' % (ops[i], comps[i]))
    else:
        print('can not happen: ops', repr(ops), 'comparators', repr(comps))
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.48">
def do_UnaryOp(self, node):
    return '%s%s' % (
        self.op_name(node.op),
        self.visit(node.operand))
</t>
<t tx="ekr.20160123185312.49">
def do_IfExp(self, node):
    return '%s if %s else %s ' % (
        self.visit(node.body),
        self.visit(node.test),
        self.visit(node.orelse))
</t>
<t tx="ekr.20160123185312.50">
# Statements...
</t>
<t tx="ekr.20160123185312.51">
def do_Assert(self, node):
    test = self.visit(node.test)
    if getattr(node, 'msg', None):
        message = self.visit(node.msg)
        return self.indent('assert %s, %s' % (test, message))
    else:
        return self.indent('assert %s' % test)
</t>
<t tx="ekr.20160123185312.52">
def do_Assign(self, node):
    return self.indent('%s=%s\n' % (
        '='.join([self.visit(z) for z in node.targets]),
        self.visit(node.value)))
</t>
<t tx="ekr.20160123185312.53">
def do_AugAssign(self, node):
    return self.indent('%s%s=%s\n' % (
        self.visit(node.target),
        self.op_name(node.op), # Bug fix: 2013/03/08.
        self.visit(node.value)))
</t>
<t tx="ekr.20160123185312.54">
def do_Break(self, node):
    return self.indent('break\n')
</t>
<t tx="ekr.20160123185312.55">
def do_Continue(self, node):
    return self.indent('continue\n')
</t>
<t tx="ekr.20160123185312.56">
def do_Delete(self, node):
    targets = [self.visit(z) for z in node.targets]
    return self.indent('del %s\n' % ','.join(targets))
</t>
<t tx="ekr.20160123185312.57">
def do_ExceptHandler(self, node):
    result = []
    result.append(self.indent('except'))
    if getattr(node, 'type', None):
        result.append(' %s' % self.visit(node.type))
    if getattr(node, 'name', None):
        if isinstance(node.name, ast.AST):
            result.append(' as %s' % self.visit(node.name))
        else:
            result.append(' as %s' % node.name) # Python 3.x.
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.58">
# Python 2.x only

def do_Exec(self, node):
    body = self.visit(node.body)
    args = [] # Globals before locals.
    if getattr(node, 'globals', None):
        args.append(self.visit(node.globals))
    if getattr(node, 'locals', None):
        args.append(self.visit(node.locals))
    if args:
        return self.indent('exec %s in %s\n' % (
            body, ','.join(args)))
    else:
        return self.indent('exec %s\n' % (body))
</t>
<t tx="ekr.20160123185312.59">
def do_For(self, node):
    result = []
    result.append(self.indent('for %s in %s:\n' % (
        self.visit(node.target),
        self.visit(node.iter))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.6">
def make_stub_file(self, fn):
    '''
    Make a stub file in ~/stubs for all source files mentioned in the
    [Source Files] section of ~/stubs/make_stub_files.cfg
    '''
    if not fn.endswith('.py'):
        print('not a python file', fn)
        return
    if not os.path.exists(fn):
        print('not found', fn)
        return
    base_fn = os.path.basename(fn)
    out_fn = os.path.join(self.output_directory,base_fn)
    out_fn = out_fn[:-3] + '.pyi'
    self.output_fn = os.path.normpath(out_fn)
    s = open(fn).read()
    node = ast.parse(s,filename=fn,mode='exec')
    dicts = (self.args_d, self.def_pattern_d, self.return_pattern_d)
    StubTraverser(controller=self).run(node)
</t>
<t tx="ekr.20160123185312.60">
def do_Global(self, node):
    return self.indent('global %s\n' % (
        ','.join(node.names)))
</t>
<t tx="ekr.20160123185312.61">
def do_If(self, node):
    result = []
    result.append(self.indent('if %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append(self.indent('else:\n'))
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.62">
def do_Import(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('import %s\n' % (
        ','.join(names)))
</t>
<t tx="ekr.20160123185312.63">
def get_import_names(self, node):
    '''Return a list of the the full file names in the import statement.'''
    result = []
    for ast2 in node.names:
        if self.kind(ast2) == 'alias':
            data = ast2.name, ast2.asname
            result.append(data)
        else:
            print('unsupported kind in Import.names list', self.kind(ast2))
    return result
</t>
<t tx="ekr.20160123185312.64">
def do_ImportFrom(self, node):
    names = []
    for fn, asname in self.get_import_names(node):
        if asname:
            names.append('%s as %s' % (fn, asname))
        else:
            names.append(fn)
    return self.indent('from %s import %s\n' % (
        node.module,
        ','.join(names)))
</t>
<t tx="ekr.20160123185312.65">
def do_Pass(self, node):
    return self.indent('pass\n')
</t>
<t tx="ekr.20160123185312.66">
# Python 2.x only

def do_Print(self, node):
    vals = []
    for z in node.values:
        vals.append(self.visit(z))
    if getattr(node, 'dest', None):
        vals.append('dest=%s' % self.visit(node.dest))
    if getattr(node, 'nl', None):
        vals.append('nl=%s' % node.nl)
    return self.indent('print(%s)\n' % (
        ','.join(vals)))
</t>
<t tx="ekr.20160123185312.67">
def do_Raise(self, node):
    args = []
    for attr in ('type', 'inst', 'tback'):
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent('raise %s\n' % (
            ','.join(args)))
    else:
        return self.indent('raise\n')
</t>
<t tx="ekr.20160123185312.68">
def do_Return(self, node):
    if node.value:
        return self.indent('return %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('return\n')
</t>
<t tx="ekr.20160123185312.7">
def run(self):
    '''Make stub files for all files.'''
    if os.path.exists(self.output_directory):
        for fn in self.files:
            self.make_stub_file(fn)
</t>
<t tx="ekr.20160123185312.70">
def do_TryExcept(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.handlers:
        for z in node.handlers:
            result.append(self.visit(z))
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.71">
def do_TryFinally(self, node):
    result = []
    result.append(self.indent('try:\n'))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append(self.indent('finally:\n'))
    for z in node.finalbody:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.72">
def do_While(self, node):
    result = []
    result.append(self.indent('while %s:\n' % (
        self.visit(node.test))))
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    if node.orelse:
        result.append('else:\n')
        for z in node.orelse:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.73">
def do_With(self, node):
    result = []
    result.append(self.indent('with '))
    if hasattr(node, 'context_expression'):
        result.append(self.visit(node.context_expresssion))
    vars_list = []
    if hasattr(node, 'optional_vars'):
        try:
            for z in node.optional_vars:
                vars_list.append(self.visit(z))
        except TypeError: # Not iterable.
            vars_list.append(self.visit(node.optional_vars))
    result.append(','.join(vars_list))
    result.append(':\n')
    for z in node.body:
        self.level += 1
        result.append(self.visit(z))
        self.level -= 1
    result.append('\n')
    return ''.join(result)
</t>
<t tx="ekr.20160123185312.74">
def do_Yield(self, node):
    if getattr(node, 'value', None):
        return self.indent('yield %s\n' % (
            self.visit(node.value)))
    else:
        return self.indent('yield\n')
</t>
<t tx="ekr.20160123185312.75">
# Utils...
</t>
<t tx="ekr.20160123185312.76">
def kind(self, node):
    '''Return the name of node's class.'''
    return node.__class__.__name__
</t>
<t tx="ekr.20160123185312.77">
def indent(self, s):
    return '%s%s' % (' ' * 4 * self.level, s)
</t>
<t tx="ekr.20160123185312.78">
def op_name (self,node,strict=True):
    '''Return the print name of an operator node.'''
    d = {
        # Binary operators. 
        'Add':       '+',
        'BitAnd':    '&amp;',
        'BitOr':     '|',
        'BitXor':    '^',
        'Div':       '/',
        'FloorDiv':  '//',
        'LShift':    '&lt;&lt;',
        'Mod':       '%',
        'Mult':      '*',
        'Pow':       '**',
        'RShift':    '&gt;&gt;',
        'Sub':       '-',
        # Boolean operators.
        'And':   ' and ',
        'Or':    ' or ',
        # Comparison operators
        'Eq':    '==',
        'Gt':    '&gt;',
        'GtE':   '&gt;=',
        'In':    ' in ',
        'Is':    ' is ',
        'IsNot': ' is not ',
        'Lt':    '&lt;',
        'LtE':   '&lt;=',
        'NotEq': '!=',
        'NotIn': ' not in ',
        # Context operators.
        'AugLoad':  '&lt;AugLoad&gt;',
        'AugStore': '&lt;AugStore&gt;',
        'Del':      '&lt;Del&gt;',
        'Load':     '&lt;Load&gt;',
        'Param':    '&lt;Param&gt;',
        'Store':    '&lt;Store&gt;',
        # Unary operators.
        'Invert':   '~',
        'Not':      ' not ',
        'UAdd':     '+',
        'USub':     '-',
    }
    name = d.get(self.kind(node),'&lt;%s&gt;' % node.__class__.__name__)
    if strict: assert name,self.kind(node)
    return name
</t>
<t tx="ekr.20160123185312.79">

class StubFormatter (AstFormatter):
    '''
    Just like the AstFormatter class, except it prints the class
    names of constants instead of actual values.
    '''
    @others
</t>
<t tx="ekr.20160123185312.8">

class AstFormatter:
    '''
    A class to recreate source code from an AST.
    
    This does not have to be perfect, but it should be close.
    '''
    # pylint: disable=consider-using-enumerate
    @others
</t>
<t tx="ekr.20160123185312.80">
# Return generic markers allow better pattern matches.

def do_BoolOp(self, node): # Python 2.x only.
    return 'bool'

def do_Bytes(self, node): # Python 3.x only.
    return 'bytes' # return str(node.s)

def do_Name(self, node):
    return 'bool' if node.id in ('True', 'False') else node.id

def do_Num(self, node):
    return 'number' # return repr(node.n)

def do_Str(self, node):
    '''This represents a string constant.'''
    return 'str' # return repr(node.s)
</t>
<t tx="ekr.20160123185312.81">

class StubTraverser (ast.NodeVisitor):
    '''An ast.Node traverser class that outputs a stub for each class or def.'''
    @others
</t>
<t tx="ekr.20160123185312.82">
def indent(self, s):
    '''Return s, properly indented.'''
    return '%s%s' % (' ' * 4 * self.level, s)

def out(self, s):
    '''Output the string to the console or the file.'''
    if self.output_file:
        self.output_file.write(self.indent(s)+'\n')
    else:
        print(self.indent(s))
</t>
<t tx="ekr.20160123185312.83">
def run(self, node):
    '''StubTraverser.run: write the stubs in node's tree to self.output_fn.'''
    fn = self.output_fn
    dir_ = os.path.dirname(fn)
    if os.path.exists(fn):
        print('file exists: %s' % fn)
    elif os.path.exists(dir_):
        self.output_file = open(fn, 'w')
        for z in self.prefix_lines or []:
            self.out(z.strip())
        self.visit(node)
        self.output_file.close()
        self.output_file = None
        print('wrote: %s' % fn)
    else:
        print('not found: %s' % dir_)

</t>
<t tx="ekr.20160123185312.85">
# Visitors...
</t>
<t tx="ekr.20160123185312.86">
# ClassDef(identifier name, expr* bases, stmt* body, expr* decorator_list)

def visit_ClassDef(self, node):

    # Format...
    if not node.name.startswith('_'):
        if node.bases:
            s = '(%s)' % ','.join([self.format(z) for z in node.bases])
        else:
            s = ''
        self.out('class %s%s:' % (node.name, s))
    # Visit...
    self.level += 1
    old_in_function = self.in_function
    self.in_function = False
    self.class_name_stack.append(node.name)
    for z in node.body:
        self.visit(z)
    self.class_name_stack.pop()
    self.level -= 1
    self.in_function = old_in_function
</t>
<t tx="ekr.20160123185312.87">
# FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)

def visit_FunctionDef(self, node):
    
    # Do nothing if we are already in a function.
    # We do not generate stubs for inner defs.
    if self.in_function or node.name.startswith('_'):
        return
    # First, visit the function body.
    self.returns = []
    self.in_function = True
    self.level += 1
    for z in node.body:
        self.visit(z)
    self.level -= 1
    self.in_function = False
    # Format *after* traversing
    self.out('def %s(%s) -&gt; %s: ...' % (
        node.name,
        self.format_arguments(node.args),
        self.format_returns(node)))
</t>
<t tx="ekr.20160123185312.88">
# arguments = (expr* args, identifier? vararg, identifier? kwarg, expr* defaults)

def format_arguments(self, node):
    '''
    Format the arguments node.
    Similar to AstFormat.do_arguments, but it is not a visitor!
    '''
    assert isinstance(node,ast.arguments), node
    args = [self.format(z) for z in node.args]
    defaults = [self.format(z) for z in node.defaults]
    # Assign default values to the last args.
    result = []
    n_plain = len(args) - len(defaults)
    # pylint: disable=consider-using-enumerate
    for i in range(len(args)):
        s = self.munge_arg(args[i])
        if i &lt; n_plain:
            result.append(s)
        else:
            result.append('%s=%s' % (s, defaults[i - n_plain]))
    # Now add the vararg and kwarg args.
    name = getattr(node, 'vararg', None)
    if name: result.append('*' + name)
    name = getattr(node, 'kwarg', None)
    if name: result.append('**' + name)
    return ', '.join(result)
</t>
<t tx="ekr.20160123185312.9">
# Entries...
</t>
<t tx="ekr.20160123185312.90">
def format_returns(self, node):
    '''Calculate the return type.'''
    
    def split(s):
        return '\n     ' + self.indent(s) if len(s) &gt; 30 else s
        
    # Shortcut everything if node.name matches any
    # pattern in self.def_pattern_d.
    d = self.def_pattern_d
    if self.class_name_stack:
        name = '%s.%s' % (self.class_name_stack[-1], node.name)
    else:
        name = node.name
    for pattern in d.keys():
        match = re.search(pattern, name)
        if match and match.group(0) == name:
            t = d.get(pattern)
            print('*name pattern %s: %s -&gt; %s' % (pattern, name, t))
            return t

    r = [self.format(z) for z in self.returns]
    # if r: print(r)
    r = [self.munge_ret(name, z) for z in r]
        # Make type substitutions.
    r = sorted(set(r))
        # Remove duplicates
    if len(r) == 0:
        return 'None'
    if len(r) == 1:
        return r[0] # Never split a single value.
    elif 'None' in r:
        r.remove('None')
        return split('Optional[%s]' % ', '.join(r))
    else:
        # return 'Any'
        s = ', '.join(r)
        if len(s) &gt; 30:
            return ', '.join(['\n    ' + self.indent(z) for z in r])
        else:
            return split(', '.join(r))
</t>
<t tx="ekr.20160123185312.91">
def visit_Return(self, node):

    self.returns.append(node.value)
</t>
<t tx="ekr.20160123185348.1">
def main():
    '''
    The driver for the stand-alone version of make-stub-files.
    All options come from ~/stubs/make_stub_files.cfg.
    '''
    controller = StandAloneMakeStubFile()
    controller.scan_options()
    controller.run()
    print('done')
</t>
<t tx="ekr.20160123185719.1">
def scan_options(self):
    '''Set all configuration-related ivars.'''
    parser = configparser.ConfigParser()
    parser.optionxform=str
    fn = '~/stubs/make_stub_files.cfg'
    fn = os.path.expanduser('~/stubs/make_stub_files.cfg')
    if not os.path.exists(fn):
        print('not found: %s' % fn)
        return
    parser.read(fn)
    files = parser.get('Global', 'files')
    files = [z.strip() for z in files.split('\n') if z.strip()]
    files2 = []
    for z in files:
        files2.extend(glob.glob(os.path.expanduser(z)))
    self.files = [z for z in files2 if os.path.exists(z)]
    # print('Files...\n%s' % '\n'.join(self.files))
    if 'output_directory' in parser.options('Global'):
        s = parser.get('Global', 'output_directory')
        output_dir = os.path.expanduser(s)
        if os.path.exists(output_dir):
            self.output_directory = output_dir
            print('output_dir: %s\n' % self.output_directory)
        else:
            print('output_dir not found: %s\n' % self.output_directory)
            self.output_directory = None # inhibit run().
    if 'prefix_lines' in parser.options('Global'):
        prefix = parser.get('Global','prefix_lines')
        self.prefix_lines = [z.strip() for z in prefix.split('\n') if z.strip()]
        print('Prefix lines...')
        for z in self.prefix_lines:
            print(z)
        print('')
    self.args_d = self.scan_types(
        parser, 'Arg Types')
    self.def_pattern_d = self.scan_types(
        parser, 'Def Name Patterns', )
    self.return_pattern_d = self.scan_types(
        parser, 'Return Simple Patterns')
    self.return_regex_d = self.scan_types(
        parser, 'Return Regex Patterns')
    </t>
<t tx="ekr.20160123193632.1">
def __init__(self, controller):
    '''Ctor for StubTraverser class.'''
    self.controller = c = controller
        # A StandAloneMakeStubFile instance.
    # Internal state ivars...
    self.class_name_stack = []
    self.format = StubFormatter().format
    self.in_function = False
    self.level = 0
    self.output_file = None
    self.returns = []
    # Copies of controller ivars...
    self.debug = c.debug
    self.output_fn = c.output_fn
    self.prefix_lines = c.prefix_lines
    self.trace = c.trace
    self.verbose = c.verbose
    # Copies of controller dicts...
    self.args_d = c.args_d # [Arg Types]
    self.def_pattern_d = c.def_pattern_d # [Def Name Patterns]
    self.return_regex_d = c.return_regex_d # [Return Regex Patterns]
    self.return_pattern_d = c.return_pattern_d # [Return Simple Patterns]
</t>
<t tx="ekr.20160123193846.1">
def __init__ (self):
    '''Ctor for StandAloneMakeStubFile class.'''
    self.options = {}
    # Ivars set on the command line...
    self.debug = False
    self.files = [] # May also be set in the config file.
    self.trace = True
    self.verbose = False
    # Ivars set in the config file...
    self.output_fn = None
    self.output_directory = os.path.expanduser('~/stubs')
    self.prefix_lines = []
    # Type substitution dicts, set by config sections...
    self.args_d = {} # [Arg Types]
    self.def_pattern_d = {} # [Def Name Patterns]
    self.return_regex_d = {} # [Return Regex Patterns]
    self.return_pattern_d = {} # [Return Simple Patterns]
   </t>
<t tx="ekr.20160124120818.1">@language rest
@nowrap

'''
The stand-alone version of Leo's make-stub-files command.

This file is in the public domain.

**In brief**

This script makes a stub file in the ~/stubs directory for every file
mentioned in the [Files] section of ~/stubs/make_stub_files.cfg. The
[Global] section specifies output directory, prefix lines and annotation
pairs.

**In detail**

This docstring documents the make_stub_files.py script, explaining what it
does, how it works and why it is important.

Executive summary
=================

The make_stub_files script eliminates much of the drudgery of creating
python stub (.pyi) files https://www.python.org/dev/peps/pep-0484/#stub-files
from python source files. 

From GvR::

    "We actually do have a stub generator as part of mypy now (most of the
    code is in https://github.com/JukkaL/mypy/blob/master/mypy/stubgen.py;
    it has a few options) but yours has the advantage of providing a way to
    tune the generated signatures based on argument conventions. This
    allows for a nice iterative way of developing stubs."

The script does no type inference. Instead, it creates function annotations
using user-supplied **type conventions**, pairs of strings of the form
"name: type-annotation".

A **configuration file**, ~/stubs/make_stub_files.cfg, specifies the
**source list**, (a list files to be processed), the type conventions, and
a list of **prefix lines** to be inserted verbatim at the start of each
stub file.

This script should encourage more people to use mypy. Stub files can be
used by people using Python 2.x code bases. As discussed below, stub files
can be thought of as design documents or as executable and checkable design
tools.

What the script does
====================

For each file in source list (file names may contain wildcards), the script
creates a corresponding stub file in the ~/stubs directory. This is the
default directory for mypy stubs. For each source file, the script does the
following:

1. The script writes the prefix lines verbatim. This makes it easy to add
   common code to the start of stub files. For example::

    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)
    
2. The script walks the parse (ast) tree for the source file, generating
   stub lines for each function, class or method. The script generates no
   stub lines for defs nested within other defs.

For example, given the naming conventions::

    aList: Sequence
    i: int
    c: Commander
    s: str
    
and a function::

    def scan(s, i, x):
        whatever
        
the script will generate::

    def scan(s: str, i:int, x): --&gt; (see below):
    
Handling function returns
=========================
    
The script handles function returns pragmatically. The tree walker simply
writes a list of return expressions for each def. For example, here is the
output at the start of leoAst.pyi::

    class AstDumper:
        def dump(self, node: ast.Ast, level=number) -&gt; 
            repr(node), 
            str%(name,sep,sep1.join(aList)), 
            str%(name,str.join(aList)), 
            str%str.join(str%(sep,self.dump(z,level+number)) for z in node): ...
        def get_fields(self, node: ast.Ast) -&gt; result: ...
        def extra_attributes(self, node: ast.Ast) -&gt; Sequence: ...

The stub for the dump function is not syntactically correct because there
are 4 returns listed. You must edit stubs to specify a proper return type.
For the dump method, all the returns are obviously strings, so its stub
should be::

    def dump(self, node: ast.Ast, level=number) -&gt; str: ...

Not all types are obvious from naming conventions. In that case, the human
will have to update the stub using the actual source code as a guide. For
example, the type of "result" in get_fields could be just about anything.
In fact, it is a list of strings.

The configuration file
======================

As mentioned above, the configuration file, make_stub_files.cfg, is located
in the ~/stubs directory. This is mypy's default directory for stubs.

The configuration file uses the .ini format. It has two sections:

- The [Global] section specifies the files list, prefix lines and output directory:

- The [Types] section specifies naming conventions. For example::

    [Global]
    files:
        ~/leo-editor/leo/core/*.py
        
    output_directory: ~/stubs
        
    prefix:
        from typing import TypeVar, Iterable, Tuple
        T = TypeVar('T', int, float, complex)

    [Types]
    aList: Sequence
    c: Commander
    i: int
    j: int
    k: int
    n: int
    node: ast.Ast
    p: Position
    result: str
    s: str
    v: VNode

Why this script is important
===========================

The script eliminates most of the drudgery from creating stub files.
Creating a syntactically correct stub file from the output of the script is
straightforward.

Stub files are real data. mypy will check the syntax for us. More
importantly, mypy will do its type inference on the stub files. That means
that mypy will discover both errors in the stubs and actual type errors in
the program under test. There is now a simple way to use mypy!

Stubs express design intentions and intuitions as well as types. We
programmers think we *do* know most of the types of arguments passed into
and out of functions and methods. Up until now, there has been no practical
way of expressing and *testing* these assumptions. Using mypy, we can be as
specific as we like about types. For example, we can simply say that d is a
dict, or we can say that d is a dict whose keys are strings and whose
values are executables with a union of possible signatures. In short, stubs
are the easy way to play with type inference.

Most importantly, from my point of view, stub files clarify issues that I
have been struggling with for many years. To what extent *do* we understand
types? mypy will tell us. How dynamic (RPython-like) *are* our programs?
mypy will tell us. Could we use type annotation to convert our programs to
C. Heh, not likely, but the data in the stubs will tell where things get
sticky.

Finally, stubs can simplify the general type inference problem. Without
type hints or annotations, the type of everything depends on the type of
everything else. Stubs could allow robust, maybe even complete, type
inference to be done locally. We might expect stubs to make mypy work
faster.

Summary
=======

The make-stub-files script does for type/design analysis what Leo's c2py
command did for converting C sources to python. It eliminates much of the
drudgery associated with creating stub files, leaving the programmer to
make non-trivial inferences.

Stub files allow us to explore type checking using mypy as a guide and
helper. Stub files are both a design document and an executable, checkable,
type specification. Stub files allow those with a Python 2 code base to use
mypy.

The make-stub-files script is useful as is. All contributions are
gratefully accepted.

One could imagine a similar insert_annotations script that would inject
function annotations into source files using stub files as data. This
"reverse" script should be about as straightfoward as the make-stub-files
script.

Edward K. Ream
January, 2016
'''
</t>
<t tx="ekr.20160124163833.1"># An example configuration file for make_stub_files.py.
# This should be placed in your ~/stubs directory.

[Global]
files:
    c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py
    
output_directory: ~/stubs
    
prefix_lines:
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Arg Types]

aList: Sequence
aList2: Sequence
c: Commander
i: int
j: int
k: int
node: ast.Ast
p: Position
s: str
s2: str
v: VNode

[Def Name Patterns]

# Regular expression specifying def names.
# Methods names have the form class_name.method_name.
# These  patterns are matched *before* any return patterns.

AstFormatter.do_.*: str
StubTraverser.format_returns: str
StubTraverser.indent: str

[Return Simple Patterns]

# Patterns to be applied to return expressions.
# The patterns are **not** regular expression.
# All characters match verbatim, except that the patterns
# (*), [*] and {*} only match *balanced* parens, square and curly brackets.
# If the patten matches, the matched string is replaced by the given type.

repr(*): str
str.join(*): str
str.replace(*): str
str%(*): str
str%str: str

[Return Regex Patterns]

# Regex patterns
.*__name__: str
</t>
<t tx="ekr.20160125125845.1">g.cls()
import imp
import os
import make_stub_files
imp.reload(make_stub_files)
fn = 'c:/users/edreamleo/stubs/leoAst.pyi'
if 1:
    if os.path.exists(fn):
        os.remove(fn)
    make_stub_files.main()
else:
    x = make_stub_files.StandAloneMakeStubFile()
    x.scan_options()
</t>
<t tx="ekr.20160125130205.1">
def munge_arg(self, s):
    '''Add an annotation for s if possible.'''
    a = self.args_d.get(s)
    return '%s: %s' % (s, a) if a else s
</t>
<t tx="ekr.20160125132131.1">
def munge_ret(self, name, s):
    '''replace a return value by a type if possible.'''
    trace = self.trace
    if trace: print('munge_ret ==== %s' % name)
    s = self.match_args(name, s)
        # Do matches in [Arg Types]
    s = self.match_simple_patterns(name, s)
        # Repeatedly do all matches in [Return Simple Patterns]
    s = self.match_regex_patterns(name, s)
        # Repeatedly do all matches in [Return Regex Patterns]
    if trace: print('munge_reg -----: %s' % s)
    return s
</t>
<t tx="ekr.20160125141406.1">def scan_types(self, parser, section_name):
    
    d = {}
    if section_name in parser.sections():
        print('%s...' % section_name)
        for key in sorted(parser.options(section_name)):
            value = parser.get(section_name, key)
            d [key] = value
            print('%s: %s' % (key, value))
    else:
        print('no section: %s' % section_name)
        print(parser.sections())
    print('')
    return d</t>
<t tx="ekr.20160125183341.1"># --trace
# allow files on command line.
# --config=
# --alphabetize (alphabetize methods in classes)
</t>
<t tx="ekr.20160125195414.1">
def match_return_patterns(self, name, s, i):
    '''
    Make all possible pattern matches at s[i:]. Return the new s.
    '''
    trace = self.trace
    d = self.return_pattern_d
    s1 = s
    for pattern in d.keys():
        found_s = self.match_return_pattern(pattern, s, i)
        if found_s:
            replace_s = d.get(pattern)
            s = s[:i] + replace_s + s[i+len(found_s):]
            if trace:
                print('match_return_patterns found: %s replace: %s' % (
                    found_s, replace_s))
                print('match_return_patterns old: %s' % s1)
                print('match_return_patterns new: %s' % s)
            break # must rescan the entire string.
    return s
</t>
<t tx="ekr.20160125202035.1">
def match_return_pattern(self, pattern, s, i):
    '''Return the actual string matching the pattern at s[i:] or None.'''
    i1 = i
    j = 0 # index into pattern
    while i &lt; len(s) and j &lt; len(pattern) and s[i] == pattern[j]:
        if pattern[j:j+3] in ('(*)', '[*]', '{*}'):
            delim = pattern[j]
            i = self.match_balanced(delim, s, i)
            j += 3
        else:
            i += 1
            j += 1
    if i &lt;= len(s) and j == len(pattern):
        print('match_return_pattern: match %s -&gt; %s' % (pattern, s[i1:i]))
    return s[i1:i] if i &lt;= len(s) and j == len(pattern) else None
</t>
<t tx="ekr.20160125204058.1">
def match_balanced(self, delim, s, i):
    '''
    Scan over the python expression at s[i:] that starts with '(', '[' or '{'.
    Return the index into s of the end of the expression, or len(s)+1 on errors.
    '''
    trace = True
    assert s[i] == delim, s[i]
    assert delim in '([{'
    delim2 = ')]}'['([{'.index(delim)]
    assert delim2 in ')]}'
    i1, level = i, 0
    while i &lt; len(s):
        ch = s[i]
        i += 1
        if ch == delim:
            level += 1
        elif ch == delim2:
            level -= 1
            if level == 0:
                if trace: print('match_balanced: found: %s' % s[i1:i])
                return i
    # Unmatched
    print('***** unmatched %s in %s' % (delim, s))
    return len(s) + 1
</t>
<t tx="ekr.20160126035753.1">
def match_args(self, name, s):
    '''In s, make substitutions (word only) given in [Arg Types].'''
    trace = self.trace
    d = self.args_d
    count = 0 # prevent any possibility of endless loops
    found = True
    while found and count &lt; 40:
        found = False
        for arg in d.keys():
            match = re.search(r'\b'+arg+r'\b', s)
            if match:
                i = match.start(0)
                t = d.get(arg)
                s2 = s[:i] + t + s[i + len(arg):]
                if trace:
                    print('arg:  %s %s ==&gt; %s' % (arg, s, s2))
                s = s2
                count += 1
                found = True
    return s
</t>
<t tx="ekr.20160126040138.1">
def match_simple_patterns(self, name, s):
    '''
    In s, do *all* subsitutions given in [Return Simple Patterns].
    
    All characters match verbatim, except that the patterns:
        (*), [*] and {*}
    match only *balanced* parens, square and curly brackets.
    
    Note: No special cases are needed for strings or comments.
    Comments do not appear, and strings have been converted to "str".
    '''
    trace = self.trace
    if trace: print('----- %s' % s)
    count, found = 0, True
    while found and count &lt; 40:
        count += 1
        found, i, s1 = False, 0, s
        while i &lt; len(s) and not found:
            s = self.match_return_patterns(name, s, i)
            found = s1 != s
            i += 1
    if trace: print('*after simple patterns: %s' % s)
    return s</t>
<t tx="ekr.20160126041450.1">
def match_regex_patterns(self, name, s):
    '''
    In s, repeatedly match regex patterns in [Return Regex Patterns].
    '''
    trace = self.trace
    d, prev_s = self.return_regex_d, set()
    while True:
        found = False
        for pattern in d.keys():
            match = re.search(pattern, s)
            if match:
                t = d.get(pattern)
                s2 = s.replace(match.group(0), t)
                if trace:
                    print('match: %s=%s-&gt;%s: %s ==&gt; %s' % (
                        pattern, match.group(0), t, s, s2))
                if s2 in prev_s:
                    # A strange loop. return s2.
                    if trace: print('seen: %s' % (s2))
                    s = s2
                    found = False
                    break
                else:
                    found = True
                    prev_s.add(s2)
                    s = s2
        if not found:
            break
    return s
</t>
</tnodes>
</leo_file>
