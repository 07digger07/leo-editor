<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954"><vh>Startup</vh>
<v t="ekr.20070427110751"><vh>@chapters</vh></v>
</v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20110916103731.2451"><vh>@button create @auto nodes</vh>
<v t="ekr.20110916103731.2452"><vh>importFiles (top-level)</vh></v>
<v t="ekr.20110916103731.2453"><vh>importDir</vh></v>
<v t="ekr.20110916103731.2454"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20111008064811.15674"><vh>@button join-below</vh></v>
<v t="ekr.20111008064811.15676"><vh>@button join-above</vh></v>
<v t="ekr.20051020124457"><vh>Disabled buttons</vh>
<v t="ekr.20050210180937"><vh>@@ button jython</vh></v>
<v t="ekr.20041230121429"><vh>@@ button pydoc</vh></v>
<v t="ekr.20051025070722"><vh>@@button Beautify</vh></v>
<v t="ekr.20051023104813"><vh>@@button check-dirty</vh></v>
<v t="ekr.20050704170739"><vh>@@button Ipython</vh></v>
<v t="ekr.20050821081021"><vh>@@button Lines Down</vh>
<v t="ekr.20050821081021.1"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20050821072028"><vh>@@button Lines Up</vh>
<v t="ekr.20050821072028.1"><vh>moveLinesUp</vh></v>
</v>
<v t="edward.20081226095234.1"><vh>@@button lispCall @key=alt+6</vh>
<v t="edward.20081226095234.2"><vh>ctor</vh></v>
<v t="edward.20081226101808.1"><vh>run &amp; helpers</vh>
<v t="edward.20081227122708.3"><vh>findCalls</vh></v>
<v t="edward.20081227122708.2"><vh>findDefs</vh></v>
<v t="edward.20081227122708.1"><vh>stripComments</vh></v>
<v t="edward.20081227130537.1"><vh>stripLispIds</vh></v>
<v t="edward.20081227122708.4"><vh>stripStrings</vh></v>
</v>
<v t="edward.20081226101808.4"><vh>class token</vh></v>
<v t="edward.20081226101808.5"><vh>choose</vh></v>
<v t="edward.20081226101808.6"><vh>dumpList</vh></v>
<v t="edward.20081226101808.7"><vh>Parsing...</vh>
<v t="edward.20081226101808.8"><vh>parse</vh></v>
<v t="edward.20081226101808.9"><vh>scan &amp; helpers</vh>
<v t="edward.20081226101808.10"><vh>skipComment</vh></v>
<v t="edward.20081226101808.11"><vh>skipId</vh></v>
<v t="edward.20081226101808.12"><vh>skipString</vh></v>
</v>
<v t="edward.20081226101808.13"><vh>scanForest</vh></v>
</v>
<v t="edward.20081226101808.14"><vh>Code generators...</vh>
<v t="edward.20081226101808.15"><vh>gen</vh></v>
<v t="edward.20081226101808.16"><vh>gen_token</vh></v>
<v t="edward.20081226101808.17"><vh>gen_block &amp; helper</vh>
<v t="edward.20081226101808.18"><vh>gen_block_id</vh></v>
</v>
<v t="edward.20081226101808.19"><vh>gen_call &amp; helper</vh>
<v t="edward.20081226101808.20"><vh>gen_arg</vh></v>
</v>
<v t="edward.20081226101808.21"><vh>gen_def</vh></v>
<v t="edward.20081226101808.22"><vh>gen_if &amp; helpers</vh>
<v t="edward.20081226101808.23"><vh>gen_then</vh></v>
</v>
<v t="edward.20081226101808.24"><vh>gen_expr</vh></v>
<v t="edward.20081226101808.25"><vh>gen_let &amp; helper</vh>
<v t="edward.20081226101808.26"><vh>gen_let_bindings</vh></v>
</v>
<v t="edward.20081226101808.27"><vh>put...</vh>
<v t="edward.20081226101808.28"><vh>put </vh></v>
<v t="edward.20081226101808.29"><vh>put_token</vh></v>
<v t="edward.20081226101808.30"><vh>put_code &amp; put_code_line</vh></v>
<v t="edward.20081226101808.31"><vh>put_code_token</vh></v>
</v>
</v>
</v>
<v t="ekr.20050930124917"><vh>@@button outlineToClipboard</vh></v>
<v t="ekr.20050805150320"><vh>@@button rst3</vh></v>
<v t="ekr.20051025091355"><vh>@@button Spell</vh></v>
<v t="ekr.20041001194357"><vh>@@button unit test</vh></v>
</v>
<v t="ekr.20110328173745.3249"><vh>@button print g.es</vh>
<v t="ekr.20110328173745.3250"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20110328173745.3251"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20110328173745.3252"><vh> ctor</vh></v>
<v t="ekr.20110328173745.3253"><vh>error &amp; trace</vh></v>
<v t="ekr.20110328173745.3254"><vh>main</vh></v>
<v t="ekr.20110328173745.3255"><vh>munging...</vh>
<v t="ekr.20110328173745.3256"><vh>mungeString</vh></v>
<v t="ekr.20110328173745.3257"><vh>mungeHeadline</vh></v>
<v t="ekr.20110328173745.3258"><vh>mungeStatements</vh></v>
<v t="ekr.20110328173745.3259"><vh>stringize</vh></v>
</v>
<v t="ekr.20110328173745.3260"><vh>scan &amp; helpers</vh>
<v t="ekr.20110328173745.3261"><vh>scanIdChain</vh></v>
<v t="ekr.20110328173745.3262"><vh>scanNode</vh>
<v t="ekr.20110328173745.3263"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20110328173745.3264"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20110328173745.3265"><vh>scanParens</vh></v>
<v t="ekr.20110328173745.3266"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20110328173745.3267"><vh>setDecl</vh></v>
<v t="ekr.20110328173745.3268"><vh>setToBeTranslated</vh></v>
</v>
</v>
<v t="ekr.20061008055616"><vh>Scripts</vh>
<v t="ekr.20051110111150"
expanded="ekr.20051104082026,ekr.20111004182631.15511,"><vh>@thin leoScripts.txt</vh></v>
<v t="ekr.20110914030246.2405"
expanded="ekr.20110914030403.2417,ekr.20110914030403.2446,ekr.20110914030403.2421,"><vh>@file gen_blender_docs.py</vh></v>
</v>
<v t="ekr.20111004214045.2482"><vh>@path C:\Users\edreamleo\Latex</vh>
<v t="ekr.20111004185540.15541"><vh>@@auto sample.tex</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="edward.20081226095234.1">'''Analyze external calls in lisp files.'''

import glob
class lispAnalyzer:
    @others

base = '/media/disk/XEmacs/XEmacs-21.4.13/lisp/*.el'
paths = glob.glob(base)
# g.es(g.listToString(paths))
paths = [paths[0]]

x = lispAnalyzer(c,paths)
x.run()</t>
<t tx="edward.20081226095234.2">def __init__ (self,c,paths):

    self.c = c
    self.paths = paths

    # Debugging.
    self.debug = True
    self.trace = False

    # Semantic info.
    self.def_keywords = ('defun','defvar',)
    self.indent_keywords = ('if','prog','prog1','progn','set',)
    self.expr_keywords = ('and','not','or',)

    self.indent = 0 # Indentation of production output.

    # Dispatch dictionary.
    self.dispatchDict = {}</t>
<t tx="edward.20081226101808.1">def run(self):

    fn = self.paths[0]
    f = open(fn)
    s = f.read()
    g.es_print(fn)
    # g.trace(s)
    s = self.stripStrings(s)
    s = self.stripComments(s)
    defs = self.findDefs(s)
    calls = self.findCalls(s,defs)
    calls = self.stripLispIds(calls)
    defs.sort()
    calls.sort()
    g.trace('defs...\n',g.listToString(defs))
    g.trace('calls...\n',g.listToString(calls))
</t>
<t tx="edward.20081226101808.10">def skipComment (self,s,i):

    '''Skip a comment.'''

    while i &lt; len(s):
        if s[i] == '\n':
            break
        i += 1
    return i
</t>
<t tx="edward.20081226101808.11">def skipId (self,s,i):

    while i &lt; len(s):
        ch = s[i]
        if ch.isalnum() or ch in ('_','-'):
            i += 1
        else:
            break
    return i
</t>
<t tx="edward.20081226101808.12">def skipString(self,s,i):

    """Skip a string literal."""

    assert(s[i] == '"')
    i += 1
    while i &lt; len(s):
        ch = s[i]
        if ch == '\\' : i += 2
        elif ch == '"':
            i += 1 ; break
        else: i += 1

    return i</t>
<t tx="edward.20081226101808.13">def scanForest (self,s):

    i = 0 ; result = []

    while i &lt; len(s):
        progress = i
        i,aList = self.scan(s,i)
        aList and result.extend(aList)
        assert i &gt; progress

    return result


</t>
<t tx="edward.20081226101808.14">@ From Richard Deibenkorn:

1. Attempt what is not certain. Certainty may or may not come later. It may then
be a valuable delusion.

2. The pretty, initial position which falls short of completeness is not to be
valued--except as stimulus for further moves.

3. Do search.  But in order to find other than what is looked for.

4. Use and respond to the initial fresh qualities but consider them absolutely
expendable.
</t>
<t tx="edward.20081226101808.15">def gen(self,tokens,indent,init=False):

    result = []

    if init: result.append('='*40)

    for token in tokens:
        aList = self.gen_token(token,indent)
        result.extend(aList)

    if init: result.append('-'*40)

    return result

</t>
<t tx="edward.20081226101808.16">def gen_token(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            self.gen_block(token,indent)
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="edward.20081226101808.17">def gen_block (self,token,indent):

    if not (token and token.val):
        return []

    blockList = token.val
    token2 = blockList[0]
    result = []

    if token2.kind.startswith('id'):
        aList = self.gen_block_id(token2.val,blockList,indent)
    else:
        if self.debug:
            self.put('block...',[],indent,result)
        aList = self.gen(token.val,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="edward.20081226101808.18">def gen_block_id (self,theId,tokens,indent):

    result = []

    # Eventually there will be a lookup of the dispatch dict here.
    if theId == 'let':
        aList = self.gen_let(tokens,indent)
    elif theId == 'if':
        aList = self.gen_if(tokens,indent)
    elif theId in self.def_keywords:
        aList = self.gen_def(theId,tokens,indent)
    elif theId in self.indent_keywords:
        self.put('%s...' % (theId),[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
    elif theId in self.expr_keywords:
        aList = self.gen_expr(theId,tokens[1:],indent+1)
    else:
        aList = self.gen_call(theId,tokens[1:],indent)

    result.extend(aList)
    return result
</t>
<t tx="edward.20081226101808.19">def gen_call (self,funcId,tokens,indent):

    result = []

    if self.debug:
        self.put('call: %s' % (funcId),[],indent,result)
        for token in tokens:
            aList = self.gen_arg(token,indent+1)
            result.extend(aList)
    else:
        self.put_code_line('%s(' % (funcId))
        for token in tokens:
            self.gen_arg(token,indent+1)
        self.put_code(')')

    return result

</t>
<t tx="edward.20081226101808.20">def gen_arg(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            self.put('arg block:...',[],indent,result)
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            self.put_code(''.join(aList))
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="edward.20081226101808.21">def gen_def(self,theId,tokens,indent):

    result = []

    if not tokens or len(tokens) &lt; 3:
        result.append('*** bad def tokens')
        return result

    defToken,idToken = tokens[0:2]
    if idToken.kind != 'id:':
        result.append('*** bad def id')
        return result

    if self.debug:
        self.put(theId,idToken.val,indent,result)
        aList = self.gen(tokens[2:],indent+1)
        result.extend(aList)
    else:
        self.put_code('def %s (' % idToken.val)
        self.gen_token(tokens[2],indent)
        self.put_code('): # end def\n')
        self.indent += 1
        self.gen(tokens[3:],indent+1)
        self.indent -= 1

    return result
</t>
<t tx="edward.20081226101808.22">@ if condition then-form else-forms.

If the evaluated condition is non-nil, then-form is evaluated and the result
returned. Otherwise, the else-forms are evaluated in textual order, and the
value of the last one is returned. If condition has the value nil, and no
else-forms are given, if returns nil.
@c

def gen_if (self,tokens,indent):

    # tokens[0]: id:if
    # tokens[1] cond

    for i in xrange(len(tokens)):
        g.trace('tokens[%d]: %s' % (i,self.dumpList(tokens[i])))

    # g.trace(self.dumpList(tokens))

    result = []

    if self.debug:
        self.put('if...',[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
        result.extend(aList)
    else:
        self.put_code('if ')
        self.gen(tokens[1:],indent+1)
        self.put_code(': # end if\n')

    return result
</t>
<t tx="edward.20081226101808.23">def gen_then (self,token):

    pass
</t>
<t tx="edward.20081226101808.24">def gen_expr (self,theId,aList,indent):

    binops = ('and','or',)
    result = []

    self.put(theId,[],indent,result)
    aList = self.gen(aList,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="edward.20081226101808.25">@
(let ((variable value)
      (variable value)
      ...)
  body...)
@c

def gen_let (self,tokens,indent):

    if not tokens: return []
    if len(tokens) != 3:
        g.trace('unusual let')
        result = self.gen(tokens,indent+1)
        return result

    if 0:
        for i in xrange(len(tokens)):
            g.trace('token',i,tokens[i])

    letToken,bindingToken,bodyToken = tokens
    result = []
    self.put('let...',[],indent,result)
    self.put('let-bindings...',[],indent+1,result)
    aList = self.gen_let_bindings(bindingToken,indent+2)
    result.extend(aList)
    self.put('let-block...',[],indent+1,result)
    aList = self.gen_block(bodyToken,indent+2)
    result.extend(aList)
    return result</t>
<t tx="edward.20081226101808.26">def gen_let_bindings (self,token,indent):

    result = []

    if token.kind != 'block:':
        g.trace('unexpected let')
        return result

    for z in token.val:
        if z.kind == 'block:': # one (id,val) pair
            if z.val and len(z.val) == 2:
                token1 = z.val[0]
                token2 = z.val[1]
                self.put('let-id',token1,indent,result)
                self.put('let-val...',[],indent,result)
                if token2.kind == 'block:':
                    aList = self.gen_block(token2,indent+1)
                    result.extend(aList)
                else:
                    #g.trace('no let list')
                    self.put_token(token2,indent+1,result)
            else:
                g.trace('unexpected let 2')

    return result
</t>
<t tx="edward.20081226101808.27"></t>
<t tx="edward.20081226101808.28">def put (self,kind,val,indent,result):

    '''Append one or more lines of output to result.'''

    leading = '%2d: %s' % (indent,' ' * indent)

    if kind == 'string:':
        val = self.choose(len(val)&gt;20,val[:20]+'..."',val)

    if val:
        s = '%s%s %s' % (leading,str(kind),str(val))
    else:
        s = '%s%s' % (leading,str(kind))

    result.append(s)
</t>
<t tx="edward.20081226101808.29">def put_token (self,token,indent,result):

    for z in token.comments:
        self.put('comment:',z,indent,result)

    self.put(token.kind,token.val,indent,result)
</t>
<t tx="edward.20081226101808.30">def put_code_line (self,s):

    s2 = '%s%s' % (' '*self.indent,s)
    print s2,

def put_code (self,s):

    print s,
</t>
<t tx="edward.20081226101808.31">def put_code_token (self,token):

    if token.kind == 'block:':
        self.put_code('&lt;block&gt;')
    else:
        self.put_code(token.val)

</t>
<t tx="edward.20081226101808.4">class token:

    '''Representing one elisp syntactic entity,
    with a list of preceding comments.'''

    def __init__ (self,comments,kind,val):
        self.comments = comments[:]
        self.kind = kind
        self.val = val
            # For blocks, a list of tokens.
            # For all other tokens, the spelling of the token.

    def __repr__ (self):
        return '&lt;token kind: %s, val: %s&gt;' % (self.kind,self.val)

    def __str__ (self):
        if self.kind == 'block:':
            return 'block: [snip]'
        elif self.kind == 'string:':
            return '%s%s' % (self.kind,self.val[:20])
        else:
            return '%s%s' % (self.kind,self.val)
</t>
<t tx="edward.20081226101808.5">def choose(self,cond,a,b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="edward.20081226101808.6">def dumpList(self,aList):

    if type(aList) == type([]):
        result = self.dumpListHelper(aList,indent=0)
        return '\n'.join(result)
    else:
        return repr(aList)

def dumpListHelper(self,aList,indent):

    result = []
    leading = ' ' * (4 * indent)

    for z in aList:
        if z is None:
            result.append('%s%s' % (leading,'None'))
        elif z == []:
            result.append('%s%s' % (leading,'[]'))
        elif type(z) == type([]):
            result.append('%s%s' % (leading,'['))
            result.extend(self.dumpListHelper(z,indent+1))
            result.append('%s%s' % (leading,']'))
        elif isinstance(z,self.token):
            if z.kind=='block:':
                result.append('%s%s' % (leading,'block:'))
                result.extend(self.dumpListHelper(z.val,indent+1))
                # result.append('%s%s' % (leading,'block:]'))
            else:
                result.append('%s%s' % (leading,str(z)))
        else:
            result.append('%s%s' % (leading,str(z)))

    return result

listToString = dumpList</t>
<t tx="edward.20081226101808.7"></t>
<t tx="edward.20081226101808.8">def parse(self,s):

    # Generate the nodes, including directive and section references.
    return self.scanForest(s)
</t>
<t tx="edward.20081226101808.9">def scan(self,s,i):

    '''Scan an elisp expression.'''

    start = i ; end = len(s) ; result = []
    comments = [] ; token = self.token
    # A hack. ignore initial @language lisp
    tag = '@language lisp'
    if i == 0 and s[i:i+len(tag)]==tag:
        i += len(tag)
    while i &lt; end:
        progress = i
        ch = s[i]
        if ch == ';':
            j = self.skipComment(s,i)
            start = i = j
        elif ch == '"':
            j = self.skipString(s,i)
            start = i = j
        elif ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            result.append(token(comments,'id:',s[i:j]))
            start = i = j
        elif ch =='(':
            i += 1
            j,aList = self.scan(s,i)
            result.append(token(comments,'block:',aList))
            start = i = j
        elif ch == ')':
            i += 1
            return i,result
        else:
            # if ch == "'": ch = 'quote'
            # if ch not in (' ','\t','\n','\r'):
                # result.append(token(comments,'op:',ch))
            i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if start &lt; end:
        tail = s[start:end].strip()
        if tail:
            result.append(token(comments,'tail:',tail))
            comment = []
    if comments:
        result.append(token(comments,'trailing-comment:',''))

    return i,result
</t>
<t tx="edward.20081227122708.1">def stripComments(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == ';':
            i = self.skipComment(s,i)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="edward.20081227122708.2">def findDefs (self,s):

    defs = [] ; tag = '(defun'
    i = 0
    while True:
        progress = i
        j = s.find(tag,i)
        if j == -1:
            return defs
        i = j + len(tag)
        j = g.skip_ws(s,i)
        if j &gt; i:
            k = self.skipId(s,j)
            if k &gt; j:
                defs.append(s[j:k])
            i = k
        assert progress &lt; i 
</t>
<t tx="edward.20081227122708.3">def findCalls (self,s,defs):

    calls = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            theId = s[i:j].strip()
            if theId not in defs and theId not in calls:
                calls.append(theId)
            i = j
        else: i += 1
        assert progress &lt; i

    return calls       
</t>
<t tx="edward.20081227122708.4">def stripStrings(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == '"':
            i = self.skipString(s,i)
        elif ch == "'":
            i = self.skipId(s,i+1)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="edward.20081227130537.1">def stripLispIds (self,aList):

    lispIds = [
        't','f',
        'apply',
        'boundp',
        'car','cons','cdr','consp',
        'eq','equal','eval',
        'lamda','lambda',
        'macro',
        'nil','not','null','numberp',
        'or',
        'unless',
        'vector','vectorp',
        # special forms
        'and',
        'catch',
        'cond',
        'condition-case',
        'defconst',
        'defmacro',
        'defun',
        'defvar',
        'function',
        'if',
        'interactive',
        'let',
        'let*',
        'or',
        'prog1',
        'prog2',
        'progn',
        'quote',
        'save-current-buffer',
        'save-excursion',
        'save-restriction',
        'save-window-excursion',
        'setq',
        'setq-default',
        'track-mouse',
        'unwind-protect',
        'while',
        'with-output-to-temp-buffer',
    ]

    return [z for z in aList if z not in lispIds]</t>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041230121429">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20050210180937"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.h
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20050704170739">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20050805150320">import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    rst3.controller.processTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050821072028"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20050821072028.1">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050821081021"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20050821081021.1">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050930124917">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20051020124457"></t>
<t tx="ekr.20051023104813"># This works, but is too slow to be really useful.

count = 0
for p in c.all_unique_positions():
    if p.isDirty():
        c.checkPythonNode (p,suppressErrors=False)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20051025070722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025091355">c.spellCommands.openSpellTab()
</t>
<t tx="ekr.20061008055616"></t>
<t tx="ekr.20070427110751"></t>
<t tx="ekr.20070615131954"></t>
<t tx="ekr.20110328173745.3249">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20110328173745.3250">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the
@scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the
@scan_g.es_results node. In particular, assuming that g.translateString converts
all translated text to upper case, it is easy to tell which strings have been
translated. '''
</t>
<t tx="ekr.20110328173745.3251">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.
</t>
<t tx="ekr.20110328173745.3252">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','newline','tabName',)
    self.rootName = '@scan_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.rootName)
</t>
<t tx="ekr.20110328173745.3253">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20110328173745.3254">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    keys = list(self.decls.keys())
    keys.sort()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'")) for z in keys]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.selectPosition(self.root)
        c.redraw()
    else:
        g.error('node not found',self.rootName)
        g.print(results)

    g.es('done',color='blue')
</t>
<t tx="ekr.20110328173745.3255"></t>
<t tx="ekr.20110328173745.3256">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20110328173745.3257">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20110328173745.3258">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls.keys()
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20110328173745.3259">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20110328173745.3260">def scan(self):

    for p in self.p.self_and_subtree():

        self.scanNode(p)
</t>
<t tx="ekr.20110328173745.3261">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20110328173745.3262">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20110328173745.3263">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))
</t>
<t tx="ekr.20110328173745.3264">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))
</t>
<t tx="ekr.20110328173745.3265">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20110328173745.3266">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20110328173745.3267">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20110328173745.3268">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20110916103731.2451">import os

@others

types = ('.py','.c',)

theDir = r'C:\apps\swigwin-2.0.4\Source'
importFiles(theDir,types,recursive=True)
c.redraw()

g.es("done",color="blue")
</t>
<t tx="ekr.20110916103731.2452">def importFiles (theDir,type=None,recursive=False):

    v = c.currentVnode()

    if not g.os_path_exists(theDir):
        g.es("directory does not exist: " + theDir)
        return

    root = createLastChildOf(v,"imported files")
    try:
        importDir (theDir,type,recursive,root)
        root.contract()
    except:
        g.es_exception()
    c.redraw()
</t>
<t tx="ekr.20110916103731.2453">def importDir (theDir,types,recursive,root,level=0):

    g.es("theDir: " + theDir,color="blue")

    try:
        files = os.listdir(theDir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(theDir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            path_part = g.choose(level==0,theDir,g.os_path_basename(theDir))
            import_root = createLastChildOf(root,'@path %s' % (path_part))
        else:
            import_root = root
        
        c.selectVnode(import_root)
        
        if len(files2) &gt; 0:
            for fn in files2:
                p2 = createLastChildOf(import_root,'@auto %s' % (
                    g.shortFileName(fn)))
                
        if len(dirs) &gt; 0:
            dirs.sort()
            for theDir in dirs:
                importDir(theDir,types,recursive,import_root,level+1)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20110916103731.2454">def createLastChildOf (v,headline):

    child = v.insertAsLastChild()
    child.initHeadString(headline.replace('\\','/'))
    return child
</t>
<t tx="ekr.20111004185540.15541">@language tex
\documentclass[12pt]{article}

\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs

% don't need the following. simply use defaults
\setlength{\baselineskip}{16.0pt}    % 16 pt usual spacing between lines

\setlength{\parskip}{3pt plus 2pt}
\setlength{\parindent}{20pt}
\setlength{\oddsidemargin}{0.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\marginparsep}{0.75cm}
\setlength{\marginparwidth}{2.5cm}
\setlength{\marginparpush}{1.0cm}
\setlength{\textwidth}{150mm}

\begin{comment}
\pagestyle{empty} % use if page numbers not wanted
\end{comment}

% above is the preamble

\begin{document}

\begin{center}
{\large Introduction to \LaTeX} \\ % \\ = new line
\copyright 2006 by Harvey Gould \\
December 5, 2006
\end{center}

\section{Introduction}
\TeX\ looks more difficult than it is. It is
almost as easy as $\pi$. See how easy it is to make special
symbols such as $\alpha$,
$\beta$, $\gamma$,
$\delta$, $\sin x$, $\hbar$, $\lambda$, $\ldots$ We also can make
subscripts
$A_{x}$, $A_{xy}$ and superscripts, $e^x$, $e^{x^2}$, and
$e^{a^b}$. We will use \LaTeX, which is based on \TeX\ and has
many higher-level commands (macros) for formatting, making
tables, etc. More information can be found in Ref.~\cite{latex}.

We just made a new paragraph. Extra lines and spaces make no
difference. Note that all formulas are enclosed by
\$ and occur in \textit{math mode}.

The default font is Computer Modern. It includes \textit{italics},
\textbf{boldface},
\textsl{slanted}, and \texttt{monospaced} fonts.

\section{Equations}
Let us see how easy it is to write equations.
\begin{equation}
\Delta =\sum_{i=1}^N w_i (x_i - \bar{x})^2 .
\end{equation}
It is a good idea to number equations, but we can have a
equation without a number by writing
\begin{equation}
P(x) = \frac{x - a}{b - a} , \nonumber
\end{equation}
and
\begin{equation}
g = \frac{1}{2} \sqrt{2\pi} . \nonumber
\end{equation}

We can give an equation a label so that we can refer to it later.
\begin{equation}
\label{eq:ising}
E = -J \sum_{i=1}^N s_i s_{i+1} ,
\end{equation}
Equation~\eqref{eq:ising} expresses the energy of a configuration
of spins in the Ising model.\footnote{It is necessary to process (typeset) a
file twice to get the counters correct.}

We can define our own macros to save typing. For example, suppose
that we introduce the macros:
\begin{verbatim}
 \newcommand{\lb}{{\langle}}
 \newcommand{\rb}{{\rangle}}
\end{verbatim}
\newcommand{\lb}{{\langle}}
\newcommand{\rb}{{\rangle}}
Then we can write the average value of $x$ as
\begin{verbatim}
\begin{equation}
\lb x \rb = 3
\end{equation}
\end{verbatim}
The result is
\begin{equation}
\lb x \rb = 3 .
\end{equation}

Examples of more complicated equations:
\begin{equation}
I = \! \int_{-\infty}^\infty f(x)\,dx \label{eq:fine}.
\end{equation}
We can do some fine tuning by adding small amounts of horizontal
spacing:
\begin{verbatim}
 \, small space       \! negative space
\end{verbatim}
as is done in Eq.~\eqref{eq:fine}.

We also can align several equations:
\begin{align}
a &amp; = b \\
c &amp;= d ,
\end{align}
or number them as subequations:
\begin{subequations}
\begin{align}
a &amp; = b \\
c &amp;= d .
\end{align}
\end{subequations}

We can also have different cases:
\begin{equation}
\label{eq:mdiv}
m(T) =
\begin{cases}
0 &amp; \text{$T &gt; T_c$} \\
\bigl(1 - [\sinh 2 \beta J]^{-4} \bigr)^{\! 1/8} &amp; \text{$T &lt; T_c$}
\end{cases}
\end{equation}
write matrices
\begin{align}
\textbf{T} &amp;=
\begin{pmatrix}
T_{++} \hfill &amp; T_{+-} \\
T_{-+} &amp; T_{--} \hfill 
\end{pmatrix} , \nonumber \\
&amp; =
\begin{pmatrix}
e^{\beta (J + B)} \hfill &amp; e^{-\beta J} \hfill \\
e^{-\beta J} \hfill &amp; e^{\beta (J - B)} \hfill
\end{pmatrix}.
\end{align}
and 
\newcommand{\rv}{\textbf{r}}
\begin{equation}
\sum_i \vec A \cdot \vec B = -P\!\int\! \rv \cdot
\hat{\mathbf{n}}\, dA = P\!\int \! {\vec \nabla} \cdot \rv\, dV.
\end{equation}

\section{Tables}
Tables are a little more difficult. TeX
automatically calculates the width of the columns.

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|r|l|}
\hline
lattice &amp; $d$ &amp; $q$ &amp; $T_{\rm mf}/T_c$ \\
\hline
square &amp; 2 &amp; 4 &amp; 1.763 \\
\hline
triangular &amp; 2 &amp; 6 &amp; 1.648 \\
\hline
diamond &amp; 3 &amp; 4 &amp; 1.479 \\
\hline
simple cubic &amp; 3 &amp; 6 &amp; 1.330 \\
\hline
bcc &amp; 3 &amp; 8 &amp; 1.260 \\
\hline
fcc &amp; 3 &amp; 12 &amp; 1.225 \\
\hline
\end{tabular}
\caption{\label{tab:5/tc}Comparison of the mean-field predictions
for the critical temperature of the Ising model with exact results
and the best known estimates for different spatial dimensions $d$
and lattice symmetries.}
\end{center}
\end{table}

\section{Lists}

Some example of formatted lists include the
following:

\begin{enumerate}

\item bread

\item cheese

\end{enumerate}

\begin{itemize}

\item Tom

\item Dick

\end{itemize}

\section{Figures}

We can make figures bigger or smaller by scaling them. Figure~\ref{fig:lj}
has been scaled by 60\%.

\begin{figure}[h]
\begin{center}
\includegraphics{figures/sine}
\caption{\label{fig:typical}Show me a sine.}
\end{center}
\end{figure}

\begin{figure}[h]
\begin{center}
\scalebox{0.6}{\includegraphics{figures/lj}}
\caption{\label{fig:lj}Plot of the
Lennard-Jones potential
$u(r)$. The potential is characterized by a length
$\sigma$ and an energy
$\epsilon$.}
\end{center}
\end{figure}

\section{Literal text}
It is desirable to print program code exactly as it is typed in a
monospaced font. Use \verb \begin{verbatim} and
\verb \end{verbatim} as in the following example:
\begin{verbatim}
double y0 = 10; // example of declaration and assignment statement
double v0 = 0;  // initial velocity
double t = 0;   // time
double dt = 0.01; // time step
double y = y0;
\end{verbatim}
The command \verb \verbatiminput{programs/Square.java}\ allows
you to list the file \texttt{Square.java} in the directory
programs.

\section{Special Symbols}

\subsection{Common Greek letters}

These commands may be used only in math mode. Only the most common
letters are included here.

$\alpha, 
\beta, \gamma, \Gamma,
\delta,\Delta,
\epsilon, \zeta, \eta, \theta, \Theta, \kappa,
\lambda, \Lambda, \mu, \nu,
\xi, \Xi,
\pi, \Pi,
\rho,
\sigma, 
\tau,
\phi, \Phi,
\chi,
\psi, \Psi,
\omega, \Omega$

\subsection{Special symbols}

The derivative is defined as
\begin{equation}
\frac{dy}{dx} = \lim_{\Delta x \to 0} \frac{\Delta y}
{\Delta x}
\end{equation}
\begin{equation}
f(x) \to y \quad \mbox{as} \quad x \to
x_{0}
\end{equation}
\begin{equation}
f(x) \mathop {\longrightarrow}
\limits_{x \to x_0} y
\end{equation}

\noindent Order of magnitude:
\begin{equation}
\log_{10}f \simeq n
\end{equation}
\begin{equation}
f(x)\sim 10^{n}
\end{equation}
Approximate equality:
\begin{equation}
f(x)\simeq g(x)
\end{equation}
\LaTeX\ is simple if we keep everything in proportion:
\begin{equation}
f(x) \propto x^3 .
\end{equation}

Finally we can skip some space by using commands such as
\begin{verbatim}
\bigskip    \medskip    \smallskip    \vspace{1pc}
\end{verbatim}
The space can be negative.

\section{\color{red}Use of Color}

{\color{blue}{We can change colors for emphasis}},
{\color{green}{but}} {\color{cyan}{who is going pay for the ink?}}

\section{\label{morefig}Subfigures}

As soon as many students start becoming comfortable using \LaTeX, they want
to use some of its advanced features. So we now show how to place two
figures side by side.

\begin{figure}[h!]
\begin{center}
\subfigure[Real and imaginary.]{
\includegraphics[scale=0.5]{figures/reim}}
\subfigure[Amplitude and phase.]{
\includegraphics[scale=0.5]{figures/phase}}
\caption{\label{fig:qm/complexfunctions} Two representations of complex
wave functions.}
\end{center}
\end{figure}

We first have to include the necessary package,
\verb+\usepackage{subfigure}+, which has to go in the preamble (before
\verb+\begin{document}+). It sometimes can be difficult to place a figure in
the desired place.

Your LaTeX document can be easily modified to make a poster or a screen
presentation similar to (and better than) PowerPoint. Conversion to HTML is
straightforward. Comments on this tutorial are appreciated.

\begin{thebibliography}{5}

\bibitem{latex}Helmut Kopka and Patrick W. Daly, \textsl{A Guide to
\LaTeX: Document Preparation for Beginners and Advanced Users},
fourth edition, Addison-Wesley (2004).

\bibitem{website}Some useful links are
given at \url{}.

\end{thebibliography}

{\small \noindent Updated 5 December 2006.}
\end{document}
</t>
<t tx="ekr.20111004214045.2482"></t>
<t tx="ekr.20111008064811.15674">'''Prepend p.b to p.next().b. and delete node p.'''

u = c.undoer
p2 = p.next()
if p2:
    b = p.b.lstrip()
    if not b.endswith('\n'):
        b = b + '\n'
    # undoData = u.beforeChangeGroup(p)
    p2.b = b + p2.b
    p.doDelete(p2)
    # u.afterChangeGroup(p,'join-below',undoData)
    c.redraw(p2)
</t>
<t tx="ekr.20111008064811.15676">'''Append p.b to p.back().b. and delete node p.'''

u = c.undoer
p2 = p.back()
if p2:
    b = p.b.lstrip()
    if not b.startswith('\n'):
        b = '\n' + b
    # undoData = u.beforeChangeGroup(p)
    p2.b = p2.b + b
    p.doDelete(p2)
    # u.afterChangeGroup(p,'join-below',undoData)
    c.redraw(p2)
</t>
</tnodes>
</leo_file>
