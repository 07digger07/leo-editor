<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.50" body_secondary_ratio="0.50">
	<global_window_position top="57" left="311" height="887" width="1568"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070615131954"><vh>Startup</vh>
<v t="ekr.20070427110751"><vh>@chapters</vh></v>
<v t="ekr.20041001211817"><vh>Buttons</vh>
<v t="ekr.20051020124457"><vh>Disabled buttons</vh>
<v t="ekr.20041230121429"><vh>@@ button pydoc</vh></v>
<v t="ekr.20050210180937"><vh>@@ button jython</vh></v>
<v t="ekr.20050704170739"><vh>@@button Ipython</vh></v>
<v t="ekr.20050821072028"><vh>@@button Lines Up</vh>
<v t="ekr.20050821072028.1"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20050821081021"><vh>@@button Lines Down</vh>
<v t="ekr.20050821081021.1"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20050930124917"><vh>@@button outlineToClipboard</vh></v>
<v t="ekr.20051023104813"><vh>@@button check-dirty</vh></v>
</v>
<v t="ekr.20050805150320"><vh>@@button rst3</vh></v>
<v t="ekr.20041001194357"><vh>@@button unit test</vh></v>
<v t="ekr.20051025091355"><vh>@@button Spell</vh></v>
<v t="ekr.20051025070722"><vh>@@button Beautify</vh></v>
</v>
</v>
<v t="ekr.20061008055616"><vh>Scripts</vh>
<v t="ekr.20051110111150"
expanded="ekr.20040713123617.1,ekr.20050220091046,ekr.20051110105027.3,"><vh>@thin leoScripts.txt</vh></v>
</v>
<v t="edward.20081226095234.1"><vh>@button lispCall @key=alt+6</vh>
<v t="edward.20081226095234.2"><vh>ctor</vh></v>
<v t="edward.20081226101808.1"><vh>run &amp; helpers</vh>
<v t="edward.20081227122708.3"><vh>findCalls</vh></v>
<v t="edward.20081227122708.2"><vh>findDefs</vh></v>
<v t="edward.20081227122708.1"><vh>stripComments</vh></v>
<v t="edward.20081227130537.1"><vh>stripLispIds</vh></v>
<v t="edward.20081227122708.4"><vh>stripStrings</vh></v>
</v>
<v t="edward.20081226101808.4"><vh>class token</vh></v>
<v t="edward.20081226101808.5"><vh>choose</vh></v>
<v t="edward.20081226101808.6"><vh>dumpList</vh></v>
<v t="edward.20081226101808.7"><vh>Parsing...</vh>
<v t="edward.20081226101808.8"><vh>parse</vh></v>
<v t="edward.20081226101808.9"><vh>scan &amp; helpers</vh>
<v t="edward.20081226101808.10"><vh>skipComment</vh></v>
<v t="edward.20081226101808.11"><vh>skipId</vh></v>
<v t="edward.20081226101808.12"><vh>skipString</vh></v>
</v>
<v t="edward.20081226101808.13"><vh>scanForest</vh></v>
</v>
<v t="edward.20081226101808.14"><vh>Code generators...</vh>
<v t="edward.20081226101808.15"><vh>gen</vh></v>
<v t="edward.20081226101808.16"><vh>gen_token</vh></v>
<v t="edward.20081226101808.17"><vh>gen_block &amp; helper</vh>
<v t="edward.20081226101808.18"><vh>gen_block_id</vh></v>
</v>
<v t="edward.20081226101808.19"><vh>gen_call &amp; helper</vh>
<v t="edward.20081226101808.20"><vh>gen_arg</vh></v>
</v>
<v t="edward.20081226101808.21"><vh>gen_def</vh></v>
<v t="edward.20081226101808.22"><vh>gen_if &amp; helpers</vh>
<v t="edward.20081226101808.23"><vh>gen_then</vh></v>
</v>
<v t="edward.20081226101808.24"><vh>gen_expr</vh></v>
<v t="edward.20081226101808.25"><vh>gen_let &amp; helper</vh>
<v t="edward.20081226101808.26"><vh>gen_let_bindings</vh></v>
</v>
<v t="edward.20081226101808.27"><vh>put...</vh>
<v t="edward.20081226101808.28"><vh>put </vh></v>
<v t="edward.20081226101808.29"><vh>put_token</vh></v>
<v t="edward.20081226101808.30"><vh>put_code &amp; put_code_line</vh></v>
<v t="edward.20081226101808.31"><vh>put_code_token</vh></v>
</v>
</v>
</v>
<v t="ville.20090508224531.9799"><vh>@@button git-dump</vh></v>
<v t="ekr.20110328173745.3269"><vh>@scan_results</vh></v>
<v t="ekr.20110328173745.3249"><vh>@button print g.es</vh>
<v t="ekr.20110328173745.3250"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20110328173745.3251"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20110328173745.3252"><vh> ctor</vh></v>
<v t="ekr.20110328173745.3253"><vh>error &amp; trace</vh></v>
<v t="ekr.20110328173745.3254"><vh>main</vh></v>
<v t="ekr.20110328173745.3255"><vh>munging...</vh>
<v t="ekr.20110328173745.3256"><vh>mungeString</vh></v>
<v t="ekr.20110328173745.3257"><vh>mungeHeadline</vh></v>
<v t="ekr.20110328173745.3258"><vh>mungeStatements</vh></v>
<v t="ekr.20110328173745.3259"><vh>stringize</vh></v>
</v>
<v t="ekr.20110328173745.3260"><vh>scan &amp; helpers</vh>
<v t="ekr.20110328173745.3261"><vh>scanIdChain</vh></v>
<v t="ekr.20110328173745.3262"><vh>scanNode</vh>
<v t="ekr.20110328173745.3263"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20110328173745.3264"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20110328173745.3265"><vh>scanParens</vh></v>
<v t="ekr.20110328173745.3266"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20110328173745.3267"><vh>setDecl</vh></v>
<v t="ekr.20110328173745.3268"><vh>setToBeTranslated</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="edward.20081226095234.1">'''Analyze external calls in lisp files.'''

import glob
class lispAnalyzer:
    @others

base = '/media/disk/XEmacs/XEmacs-21.4.13/lisp/*.el'
paths = glob.glob(base)
# g.es(g.listToString(paths))
paths = [paths[0]]

x = lispAnalyzer(c,paths)
x.run()</t>
<t tx="edward.20081226095234.2">def __init__ (self,c,paths):

    self.c = c
    self.paths = paths

    # Debugging.
    self.debug = True
    self.trace = False

    # Semantic info.
    self.def_keywords = ('defun','defvar',)
    self.indent_keywords = ('if','prog','prog1','progn','set',)
    self.expr_keywords = ('and','not','or',)

    self.indent = 0 # Indentation of production output.

    # Dispatch dictionary.
    self.dispatchDict = {}</t>
<t tx="edward.20081226101808.1">def run(self):

    fn = self.paths[0]
    f = open(fn)
    s = f.read()
    g.es_print(fn)
    # g.trace(s)
    s = self.stripStrings(s)
    s = self.stripComments(s)
    defs = self.findDefs(s)
    calls = self.findCalls(s,defs)
    calls = self.stripLispIds(calls)
    defs.sort()
    calls.sort()
    g.trace('defs...\n',g.listToString(defs))
    g.trace('calls...\n',g.listToString(calls))
</t>
<t tx="edward.20081226101808.10">def skipComment (self,s,i):

    '''Skip a comment.'''

    while i &lt; len(s):
        if s[i] == '\n':
            break
        i += 1
    return i
</t>
<t tx="edward.20081226101808.11">def skipId (self,s,i):

    while i &lt; len(s):
        ch = s[i]
        if ch.isalnum() or ch in ('_','-'):
            i += 1
        else:
            break
    return i
</t>
<t tx="edward.20081226101808.12">def skipString(self,s,i):

    """Skip a string literal."""

    assert(s[i] == '"')
    i += 1
    while i &lt; len(s):
        ch = s[i]
        if ch == '\\' : i += 2
        elif ch == '"':
            i += 1 ; break
        else: i += 1

    return i</t>
<t tx="edward.20081226101808.13">def scanForest (self,s):

    i = 0 ; result = []

    while i &lt; len(s):
        progress = i
        i,aList = self.scan(s,i)
        aList and result.extend(aList)
        assert i &gt; progress

    return result


</t>
<t tx="edward.20081226101808.14">@ From Richard Deibenkorn:

1. Attempt what is not certain. Certainty may or may not come later. It may then
be a valuable delusion.

2. The pretty, initial position which falls short of completeness is not to be
valued--except as stimulus for further moves.

3. Do search.  But in order to find other than what is looked for.

4. Use and respond to the initial fresh qualities but consider them absolutely
expendable.
</t>
<t tx="edward.20081226101808.15">def gen(self,tokens,indent,init=False):

    result = []

    if init: result.append('='*40)

    for token in tokens:
        aList = self.gen_token(token,indent)
        result.extend(aList)

    if init: result.append('-'*40)

    return result

</t>
<t tx="edward.20081226101808.16">def gen_token(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            self.gen_block(token,indent)
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="edward.20081226101808.17">def gen_block (self,token,indent):

    if not (token and token.val):
        return []

    blockList = token.val
    token2 = blockList[0]
    result = []

    if token2.kind.startswith('id'):
        aList = self.gen_block_id(token2.val,blockList,indent)
    else:
        if self.debug:
            self.put('block...',[],indent,result)
        aList = self.gen(token.val,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="edward.20081226101808.18">def gen_block_id (self,theId,tokens,indent):

    result = []

    # Eventually there will be a lookup of the dispatch dict here.
    if theId == 'let':
        aList = self.gen_let(tokens,indent)
    elif theId == 'if':
        aList = self.gen_if(tokens,indent)
    elif theId in self.def_keywords:
        aList = self.gen_def(theId,tokens,indent)
    elif theId in self.indent_keywords:
        self.put('%s...' % (theId),[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
    elif theId in self.expr_keywords:
        aList = self.gen_expr(theId,tokens[1:],indent+1)
    else:
        aList = self.gen_call(theId,tokens[1:],indent)

    result.extend(aList)
    return result
</t>
<t tx="edward.20081226101808.19">def gen_call (self,funcId,tokens,indent):

    result = []

    if self.debug:
        self.put('call: %s' % (funcId),[],indent,result)
        for token in tokens:
            aList = self.gen_arg(token,indent+1)
            result.extend(aList)
    else:
        self.put_code_line('%s(' % (funcId))
        for token in tokens:
            self.gen_arg(token,indent+1)
        self.put_code(')')

    return result

</t>
<t tx="edward.20081226101808.20">def gen_arg(self,token,indent):

    result = []

    if self.debug:
        if token.kind == 'block:':
            self.put('arg block:...',[],indent,result)
            aList = self.gen_block(token,indent)
            result.extend(aList)
        else:
            self.put_token(token,indent,result)
    else:
        if token.kind == 'block:':
            aList = self.gen_block(token,indent)
            self.put_code(''.join(aList))
        else:
            self.put_code_token(token)

    return result
</t>
<t tx="edward.20081226101808.21">def gen_def(self,theId,tokens,indent):

    result = []

    if not tokens or len(tokens) &lt; 3:
        result.append('*** bad def tokens')
        return result

    defToken,idToken = tokens[0:2]
    if idToken.kind != 'id:':
        result.append('*** bad def id')
        return result

    if self.debug:
        self.put(theId,idToken.val,indent,result)
        aList = self.gen(tokens[2:],indent+1)
        result.extend(aList)
    else:
        self.put_code('def %s (' % idToken.val)
        self.gen_token(tokens[2],indent)
        self.put_code('): # end def\n')
        self.indent += 1
        self.gen(tokens[3:],indent+1)
        self.indent -= 1

    return result
</t>
<t tx="edward.20081226101808.22">@ if condition then-form else-forms.

If the evaluated condition is non-nil, then-form is evaluated and the result
returned. Otherwise, the else-forms are evaluated in textual order, and the
value of the last one is returned. If condition has the value nil, and no
else-forms are given, if returns nil.
@c

def gen_if (self,tokens,indent):

    # tokens[0]: id:if
    # tokens[1] cond

    for i in xrange(len(tokens)):
        g.trace('tokens[%d]: %s' % (i,self.dumpList(tokens[i])))

    # g.trace(self.dumpList(tokens))

    result = []

    if self.debug:
        self.put('if...',[],indent,result)
        aList = self.gen(tokens[1:],indent+1)
        result.extend(aList)
    else:
        self.put_code('if ')
        self.gen(tokens[1:],indent+1)
        self.put_code(': # end if\n')

    return result
</t>
<t tx="edward.20081226101808.23">def gen_then (self,token):

    pass
</t>
<t tx="edward.20081226101808.24">def gen_expr (self,theId,aList,indent):

    binops = ('and','or',)
    result = []

    self.put(theId,[],indent,result)
    aList = self.gen(aList,indent+1)

    result.extend(aList)
    return result
</t>
<t tx="edward.20081226101808.25">@
(let ((variable value)
      (variable value)
      ...)
  body...)
@c

def gen_let (self,tokens,indent):

    if not tokens: return []
    if len(tokens) != 3:
        g.trace('unusual let')
        result = self.gen(tokens,indent+1)
        return result

    if 0:
        for i in xrange(len(tokens)):
            g.trace('token',i,tokens[i])

    letToken,bindingToken,bodyToken = tokens
    result = []
    self.put('let...',[],indent,result)
    self.put('let-bindings...',[],indent+1,result)
    aList = self.gen_let_bindings(bindingToken,indent+2)
    result.extend(aList)
    self.put('let-block...',[],indent+1,result)
    aList = self.gen_block(bodyToken,indent+2)
    result.extend(aList)
    return result</t>
<t tx="edward.20081226101808.26">def gen_let_bindings (self,token,indent):

    result = []

    if token.kind != 'block:':
        g.trace('unexpected let')
        return result

    for z in token.val:
        if z.kind == 'block:': # one (id,val) pair
            if z.val and len(z.val) == 2:
                token1 = z.val[0]
                token2 = z.val[1]
                self.put('let-id',token1,indent,result)
                self.put('let-val...',[],indent,result)
                if token2.kind == 'block:':
                    aList = self.gen_block(token2,indent+1)
                    result.extend(aList)
                else:
                    #g.trace('no let list')
                    self.put_token(token2,indent+1,result)
            else:
                g.trace('unexpected let 2')

    return result
</t>
<t tx="edward.20081226101808.27"></t>
<t tx="edward.20081226101808.28">def put (self,kind,val,indent,result):

    '''Append one or more lines of output to result.'''

    leading = '%2d: %s' % (indent,' ' * indent)

    if kind == 'string:':
        val = self.choose(len(val)&gt;20,val[:20]+'..."',val)

    if val:
        s = '%s%s %s' % (leading,str(kind),str(val))
    else:
        s = '%s%s' % (leading,str(kind))

    result.append(s)
</t>
<t tx="edward.20081226101808.29">def put_token (self,token,indent,result):

    for z in token.comments:
        self.put('comment:',z,indent,result)

    self.put(token.kind,token.val,indent,result)
</t>
<t tx="edward.20081226101808.30">def put_code_line (self,s):

    s2 = '%s%s' % (' '*self.indent,s)
    print s2,

def put_code (self,s):

    print s,
</t>
<t tx="edward.20081226101808.31">def put_code_token (self,token):

    if token.kind == 'block:':
        self.put_code('&lt;block&gt;')
    else:
        self.put_code(token.val)

</t>
<t tx="edward.20081226101808.4">class token:

    '''Representing one elisp syntactic entity,
    with a list of preceding comments.'''

    def __init__ (self,comments,kind,val):
        self.comments = comments[:]
        self.kind = kind
        self.val = val
            # For blocks, a list of tokens.
            # For all other tokens, the spelling of the token.

    def __repr__ (self):
        return '&lt;token kind: %s, val: %s&gt;' % (self.kind,self.val)

    def __str__ (self):
        if self.kind == 'block:':
            return 'block: [snip]'
        elif self.kind == 'string:':
            return '%s%s' % (self.kind,self.val[:20])
        else:
            return '%s%s' % (self.kind,self.val)
</t>
<t tx="edward.20081226101808.5">def choose(self,cond,a,b): # warning: evaluates all arguments

    if cond: return a
    else: return b
</t>
<t tx="edward.20081226101808.6">def dumpList(self,aList):

    if type(aList) == type([]):
        result = self.dumpListHelper(aList,indent=0)
        return '\n'.join(result)
    else:
        return repr(aList)

def dumpListHelper(self,aList,indent):

    result = []
    leading = ' ' * (4 * indent)

    for z in aList:
        if z is None:
            result.append('%s%s' % (leading,'None'))
        elif z == []:
            result.append('%s%s' % (leading,'[]'))
        elif type(z) == type([]):
            result.append('%s%s' % (leading,'['))
            result.extend(self.dumpListHelper(z,indent+1))
            result.append('%s%s' % (leading,']'))
        elif isinstance(z,self.token):
            if z.kind=='block:':
                result.append('%s%s' % (leading,'block:'))
                result.extend(self.dumpListHelper(z.val,indent+1))
                # result.append('%s%s' % (leading,'block:]'))
            else:
                result.append('%s%s' % (leading,str(z)))
        else:
            result.append('%s%s' % (leading,str(z)))

    return result

listToString = dumpList</t>
<t tx="edward.20081226101808.7"></t>
<t tx="edward.20081226101808.8">def parse(self,s):

    # Generate the nodes, including directive and section references.
    return self.scanForest(s)
</t>
<t tx="edward.20081226101808.9">def scan(self,s,i):

    '''Scan an elisp expression.'''

    start = i ; end = len(s) ; result = []
    comments = [] ; token = self.token
    # A hack. ignore initial @language lisp
    tag = '@language lisp'
    if i == 0 and s[i:i+len(tag)]==tag:
        i += len(tag)
    while i &lt; end:
        progress = i
        ch = s[i]
        if ch == ';':
            j = self.skipComment(s,i)
            start = i = j
        elif ch == '"':
            j = self.skipString(s,i)
            start = i = j
        elif ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            result.append(token(comments,'id:',s[i:j]))
            start = i = j
        elif ch =='(':
            i += 1
            j,aList = self.scan(s,i)
            result.append(token(comments,'block:',aList))
            start = i = j
        elif ch == ')':
            i += 1
            return i,result
        else:
            # if ch == "'": ch = 'quote'
            # if ch not in (' ','\t','\n','\r'):
                # result.append(token(comments,'op:',ch))
            i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    if start &lt; end:
        tail = s[start:end].strip()
        if tail:
            result.append(token(comments,'tail:',tail))
            comment = []
    if comments:
        result.append(token(comments,'trailing-comment:',''))

    return i,result
</t>
<t tx="edward.20081227122708.1">def stripComments(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == ';':
            i = self.skipComment(s,i)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="edward.20081227122708.2">def findDefs (self,s):

    defs = [] ; tag = '(defun'
    i = 0
    while True:
        progress = i
        j = s.find(tag,i)
        if j == -1:
            return defs
        i = j + len(tag)
        j = g.skip_ws(s,i)
        if j &gt; i:
            k = self.skipId(s,j)
            if k &gt; j:
                defs.append(s[j:k])
            i = k
        assert progress &lt; i 
</t>
<t tx="edward.20081227122708.3">def findCalls (self,s,defs):

    calls = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch.isalnum() or ch == u'_':
            j = self.skipId(s,i)
            theId = s[i:j].strip()
            if theId not in defs and theId not in calls:
                calls.append(theId)
            i = j
        else: i += 1
        assert progress &lt; i

    return calls       
</t>
<t tx="edward.20081227122708.4">def stripStrings(self,s):

    result = []
    i = 0
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if ch == '"':
            i = self.skipString(s,i)
        elif ch == "'":
            i = self.skipId(s,i+1)
        else:
            result.append(ch)
            i += 1
        assert progress &lt; i

    return ''.join(result)
</t>
<t tx="edward.20081227130537.1">def stripLispIds (self,aList):

    lispIds = [
        't','f',
        'apply',
        'boundp',
        'car','cons','cdr','consp',
        'eq','equal','eval',
        'lamda','lambda',
        'macro',
        'nil','not','null','numberp',
        'or',
        'unless',
        'vector','vectorp',
        # special forms
        'and',
        'catch',
        'cond',
        'condition-case',
        'defconst',
        'defmacro',
        'defun',
        'defvar',
        'function',
        'if',
        'interactive',
        'let',
        'let*',
        'or',
        'prog1',
        'prog2',
        'progn',
        'quote',
        'save-current-buffer',
        'save-excursion',
        'save-restriction',
        'save-window-excursion',
        'setq',
        'setq-default',
        'track-mouse',
        'unwind-protect',
        'while',
        'with-output-to-temp-buffer',
    ]

    return [z for z in aList if z not in lispIds]</t>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041230121429">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20050210180937"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.h
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20050704170739">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20050805150320">import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    rst3.controller.processTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050821072028"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20050821072028.1">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050821081021"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20050821081021.1">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050930124917">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20051020124457"></t>
<t tx="ekr.20051023104813"># This works, but is too slow to be really useful.

count = 0
for p in c.all_unique_positions():
    if p.isDirty():
        c.checkPythonNode (p,suppressErrors=False)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20051025070722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025091355">c.spellCommands.openSpellTab()
</t>
<t tx="ekr.20061008055616"></t>
<t tx="ekr.20070427110751"></t>
<t tx="ekr.20070615131954" str_leo_pos="5,4"></t>
<t tx="ekr.20110328173745.3249">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20110328173745.3250">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the
@scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the
@scan_g.es_results node. In particular, assuming that g.translateString converts
all translated text to upper case, it is easy to tell which strings have been
translated. '''
</t>
<t tx="ekr.20110328173745.3251">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.
</t>
<t tx="ekr.20110328173745.3252">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','newline','tabName',)
    self.rootName = '@scan_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.rootName)
</t>
<t tx="ekr.20110328173745.3253">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20110328173745.3254">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    keys = list(self.decls.keys())
    keys.sort()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'")) for z in keys]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.selectPosition(self.root)
        c.redraw()
    else:
        g.error('node not found',self.rootName)
        g.print(results)

    g.es('done',color='blue')
</t>
<t tx="ekr.20110328173745.3255"></t>
<t tx="ekr.20110328173745.3256">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20110328173745.3257">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20110328173745.3258">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls.keys()
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20110328173745.3259">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20110328173745.3260">def scan(self):

    for p in self.p.self_and_subtree():

        self.scanNode(p)
</t>
<t tx="ekr.20110328173745.3261">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20110328173745.3262">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20110328173745.3263">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))
</t>
<t tx="ekr.20110328173745.3264">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))
</t>
<t tx="ekr.20110328173745.3265">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20110328173745.3266">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20110328173745.3267">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20110328173745.3268">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20110328173745.3269">@ To be translated...

%20s (%s)
%3d %s
%s %s
'%s',
***** Creating %s
***** Wrote %s
,
-
.
=
Can not open
Exception loading:
Expecting @test, @suite or any @file node
File %s is now shadowed
Leo -&gt; HTML completed.
Leo -&gt; RTF completed.
Leo -&gt; RTF started...
Outline in
Output from test...
Test done
Warning: ignoring keyword containing whitespace: %s
Wrote to file
all timestamps cleared
blanks precede leading tab:
can not write
cant find source2html install silvercity
clean directory does not exist
committed
committing to
convert: %s
deleting tnodeList for
dir:
directory does not exist:
do-after: not in @test tree
do-before: not in a proper @test tree
done
equal (raw mode)
equal (text mode)
exception executing change script
exception executing find script
exception in importFiles script
exception setting outline line height
found
found %d nodes
found node with whitespace to clean
get-node %s failed.
get-node %s: %s
get-tree failed: %s
get-tree: %s
head:
htmlize malfunction?
kind must be @file or @root:
log:
no @doc part found
no @path set, unsupported lang or empty script
no headline matches '%s'
no selected text &amp; clipboard empty
not found
output
pass 1: %d nodes converted
pass 2: %d @file/@thin nodes set dirty
put-node %s :%s
renaming %s to %s
running silvercity \n
searched %s
selection should be in @doc part
test
unexpected exception parsing %s
writing tmpname
wrote
@c
# Decls...
color='red'
newline=True
tabName='Log'
False = 'False'
args = 'args'
body2 = 'body2'
cmd = 'cmd'
count = 'count'
dest = 'dest'
dir = 'dir'
f1_DOT_read_PARENS_ = 'f1.read()'
f2_DOT_read_PARENS_ = 'f2.read()'
fileName = 'fileName'
filename = 'filename'
flatroot = 'flatroot'
fullname = 'fullname'
g_DOT_app_DOT_root_DOT_tk_DOT_eval_LP_s_RP_ = 'g.app.root.tk.eval(s)'
inputFileName = 'inputFileName'
key = 'key'
kind = 'kind'
lang = 'lang'
language = 'language'
line_DOT_rstrip_PARENS_ = 'line.rstrip()'
m = 'm'
name = 'name'
newname = 'newname'
os_DOT_path_DOT_abspath_LP_titlename_RP_ = 'os.path.abspath(titlename)'
out = 'out'
outputName = 'outputName'
p_DOT_h = 'p.h'
p1_DOT_h = 'p1.h'
params = 'params'
path = 'path'
po = 'po'
po_DOT_gnx = 'po.gnx'
py = 'py'
repr_LP_key_RP_ = 'repr(key)'
repr_LP_v_RP_ = 'repr(v)'
s = 's'
s1 = 's1'
size = 'size'
slant = 'slant'
str_LP_shell_DOT_prefilter_LP_line_COMMA_None_RP__RP_ = 'str(shell.prefilter(line,None))'
tmpfile = 'tmpfile'
v = 'v'
v_DOT_h = 'v.h'
weight = 'weight'
g.app.translateToUpperCase=True
# ---- @thin leoScripts.txt
g.es_print('','-------------------- @thin leoScripts.txt',color='red')
# -- node Clean unused tnodeLists
g.es("deleting tnodeList for " + `v`,color="blue")
g.es(s)
# -- node Clear all timestamps
g.es("all timestamps cleared")
# -- node @@button LeoToHtml
g.es(" Leo -&gt; HTML completed.",color="turquoise4")
# -- node @@button LeoToRtf
g.es(" Leo -&gt; RTF started...",color="turquoise4")
g.es(" Leo -&gt; RTF completed.",color="turquoise4")
# -- node @@button shadow
g.es( "renaming %s to %s" % (filename, newname))
g.es("File %s is now shadowed" % filename)
# -- node @@button git-dump
g.es("committing to " + flatroot)
g.es("committed")
g.es(out)
# g.es('Outline in ' + os.path.abspath(titlename))
g.es('Outline in ' + os_DOT_path_DOT_abspath_LP_titlename_RP_)
# -- node Find and replace all functions in leoGlobals.py
g.es("'%s'," % name)
g.es_print(s)
g.es_print(s)
# -- node prependNamesInTree
# g.es("%3d %s" % (count,p.h))
g.es("%3d %s" % (count,p_DOT_h))
# -- node &lt; &lt; look for name followed by '(' &gt; &gt;
g.es('.',newline=False)
# -- node headfind
g.es("found " + s)
g.es(body2,color="orange")
g.es("no headline matches '%s'" % (s),color="blue")
g.es("no selected text &amp; clipboard empty",color="blue")
# -- node find w.xxx
# g.es('searched %s' % p1.h)
g.es('searched %s' % p1_DOT_h)
# -- node main
g.es('done')
# -- node &lt; &lt; insert statements highlighting the @thin node &gt; &gt;
g.es_print('','%s %s',color='red')
# -- node Check Changes
g.es_print('='*40)
g.es_print('%s %s' % ('-'*20,'must have a c arg'))
g.es_print('%s %s' % ('-'*20,'these methods should not exist'))
g.es_print('%s %s' % ('-'*20,'p methods should have no c arg'))
g.es_print('%s %s' % ('-'*20,'v methods should have no c arg'))
g.es_print('%s %s' % ('-'*20,'c methods should start with a position arg'))
g.es_print('done')
# -- node findFunctionCalls
g.es_print('%20s (%s)' % (s1,args))
# -- node Export to treepad
g.es("Wrote to file " + fileName,color="blue")
g.es("Can not open " + fileName,color="blue")
# -- node htmlize
# g.es('output', lang, p.h)
g.es('output', lang, p_DOT_h)
g.es('no @path set, unsupported lang or empty script',color='tomato')
# g.es(lang, p.h)
g.es(lang, p_DOT_h)
g.es('htmlize malfunction?', color='tomato')
# -- node &lt; &lt; colorize with silvercity &gt; &gt;
g.es('writing tmpname', tmpfile )
g.es('cant find source2html install silvercity')
g.es('running silvercity \n', py + cmd + params )
# -- node @@button jEdit2Py
g.es_print('done')
# -- node convert
g.es_print('convert: %s' % (language))
# -- node parse_jEdit_file
g.es('unexpected exception parsing %s' % (inputFileName),color='red')
# -- node putKeywordsData
# g.es_print('Warning: ignoring keyword containing whitespace: %s' % (
#                             repr(key)))
g.es_print('Warning: ignoring keyword containing whitespace: %s' % (
                            repr_LP_key_RP_))
# -- node Recursive import script
g.es("done",color="blue")
# -- node importFiles
g.es("kind must be @file or @root: " + kind)
g.es("directory does not exist: " + dir)
# -- node importDir
g.es("dir: " + dir,color="blue")
g.es("exception in importFiles script")
# -- node run tcl
# g.es(g.app.root.tk.eval(s))
g.es(g_DOT_app_DOT_root_DOT_tk_DOT_eval_LP_s_RP_)
# -- node @command do-before
g.es_print('do-before: not in a proper @test tree')
# -- node @command do-after
g.es_print('do-after: not in @test tree')
# -- node clean_file
g.es('clean directory does not exist',path)
g.es_print('wrote',fileName)
g.es_print('can not write',fileName,color='red')
# -- node @@button zodb-get-tree
# g.es_print('get-tree: %s' % repr(v))
g.es_print('get-tree: %s' % repr_LP_v_RP_)
g.es_print('get-tree failed: %s' % fileName)
# -- node @@button zodb-get-node
# g.es_print('get-node %s: %s' % (key,repr(v)))
g.es_print('get-node %s: %s' % (key,repr_LP_v_RP_))
g.es_print('get-node %s failed.' % key)
# -- node @@button zodb-put-node
# g.es_print('put-node %s :%s' % (v.h,repr(v)))
g.es_print('put-node %s :%s' % (v_DOT_h,repr_LP_v_RP_))
# -- node Compare ignoring newlines
# g.es("equal (raw mode)",f1.read()==f2.read())
g.es("equal (raw mode)",f1_DOT_read_PARENS_==f2_DOT_read_PARENS_)
# g.es("equal (text mode)",f1.read()==f2.read())
g.es("equal (text mode)",f1_DOT_read_PARENS_==f2_DOT_read_PARENS_)
# -- node Script to backup Outlook Express files
g.es_print('***** Creating %s' % dest)
g.es_print('***** Wrote %s' % outputName)
# -- node doatest
g.es('Expecting @test, @suite or any @file node',color='blue')
g.es('Output from test...',color='blue')
# g.es(line.rstrip())
g.es(line_DOT_rstrip_PARENS_)
g.es('Test done',color='blue')
# -- node getImage
g.es("Exception loading: " + fullname)
# -- node getLineHeight
g.es("exception setting outline line height")
# -- node Ipython Shell
g.es_print('-'*40)
# g.es(str(shell.prefilter(line,None)))
g.es(str_LP_shell_DOT_prefilter_LP_line_COMMA_None_RP__RP_)
# -- node Setting Tk config values safely
g.es(s,color='blue')
g.es(s,color='blue')
# -- node pos_to_archive, archive_to_pos
# g.es('test' , po, po.gnx)
g.es('test' , po, po_DOT_gnx)
# -- node Count pages
g.es(s)
# -- node Count separate nodes
g.es_print(s)
g.es_print(s)
# -- node Report newlines
g.es(m)
# -- node Show settings
g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
g.es("head:" + name + "," + `size` + "," + slant + "," + weight)
# ---- @thin tangle_done.py
g.es_print('','-------------------- @thin tangle_done.py',color='red')
# ---- @thin untangle_done.py
g.es_print('','-------------------- @thin untangle_done.py',color='red')
# -- node doFind...Script
g.es("exception executing find script")
# -- node doChange...Script
g.es("exception executing change script")
# -- node Find script
# g.es("blanks precede leading tab: " + v.h)
g.es("blanks precede leading tab: " + v_DOT_h)
g.es("done",color="blue")
# -- node Find script
# g.es(v.h)
g.es(v_DOT_h)
g.es("found node with whitespace to clean")
g.es("found %d nodes" % (count), color="blue")
g.es("not found")
# -- node Change script
# g.es(v.h)
g.es(v_DOT_h)
g.es("found %d nodes" % (count), color="blue")
g.es("done")
# -- node Find script
g.es("no @doc part found",color="blue")
# -- node Change script
g.es("selection should be in @doc part")
# -- node Remove blank trailing lines
# g.es(p.h)
g.es(p_DOT_h)
# -- node Set trailing ws script
g.es_print('done')
# -- node pass1
g.es_print("pass 1: %d nodes converted" % count)
# -- node pass2
g.es_print("pass 2: %d @file/@thin nodes set dirty" % count)
g.app.translateToUpperCase=False</t>
<t tx="ville.20090508224531.9799">""" Dump nodes to ~/.leo/dump git repository.

Before using this, you need to:
    mkdir ~/.leo/dump; cd ~/.leo/dump; git init

"""

import os, codecs, hashlib
flatroot = os.path.expanduser('~/.leo/dump')
assert os.path.isdir(flatroot)

hl = []

def dump_nodes():
    for p in c.all_unique_positions():
        name, date, num = p.v.fileIndex
        gnx = '%s%s%s' % (name, date, num)
        hl.append('&lt;a href="%s"&gt;%s%s&lt;/a&gt;&lt;br/&gt;' % (gnx, '-' * p.level(), p.h))
        fname = gnx
        codecs.open(fname,'w', encoding='utf-8').write(p.b)
        print "wrote", fname

os.chdir(flatroot)

dump_nodes()
lis = "\n".join(hl)

html = "&lt;body&gt;\n&lt;tt&gt;\n" + lis + "\n&lt;/tt&gt;&lt;/body&gt;"

#titlename = c.frame.getTitle() + '.html'
pth, bname = os.path.split(c.mFileName)

if pth and bname:
    dbdirname = bname + "_" + hashlib.md5(c.mFileName).hexdigest()    

titlename = dbdirname + '.html'
codecs.open(titlename,'w', encoding='utf-8').write(html)

g.es("committing to " + flatroot)

os.system('git add *')
out = os.popen('git commit -m "Leo autocommit"').read()
g.es("committed")
g.es(out)
g.es('Outline in ' + os.path.abspath(titlename))
</t>
</tnodes>
</leo_file>
