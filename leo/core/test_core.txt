#@+leo-ver=4-thin
#@+node:ekr.20090113083258.1:@thin test_core.txt
# Contains all test code for Leo's core.

#@+all
#@+node:ekr.20090121163905.2:Doctests
# Only run with windows--there are problems on Linux.
#@nonl
#@+node:ekr.20090121163905.3:@suite run all doctests (windows only)
import unittest
import leo.core.leoTest as leoTest

import sys

# DocTestSuite exists in Python 2.3 and above.

if sys.platform.lower().startswith('win'):

    version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
    if g.CheckVersion(version, "2.3"):

        path = g.os_path_join(g.app.loadDir,"..","core")
        modules = leoTest.importAllModulesInPath(path)
        suite = leoTest.createUnitTestsFromDoctests(modules)

        if suite:
            g.app.scriptDict['suite'] = suite

    else:
        # Create an empty suite to suppress a warning.
        g.app.scriptDict['suite'] = unittest.TestSuite()
        print("\nCan't create unit tests from doctests")
        print("doctest.DocTestSuite requires Python 2.3 or above.\n")

else:
    pass # There are problems on Linux.
#@nonl
#@-node:ekr.20090121163905.3:@suite run all doctests (windows only)
#@-node:ekr.20090121163905.2:Doctests
#@+node:ekr.20090121163905.4:General
#@+node:ekr.20090121163905.5:Check base classes & ivars
#@+node:ekr.20090121163905.6:@test leoBody is subset of leoTkBody
if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect,sys

    baseClass = leoFrame.leoBody
    subClasses  = (tkGui.leoTkinterBody,leoFrame.nullBody)
    baseObject = c.frame.body

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        try:
            assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)
        except AssertionError:
            exctype, value = sys.exc_info()[:2]
            print(value)
            raise

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                #raise
                exctype, value = sys.exc_info()[:2]
                print(value)
#@nonl
#@-node:ekr.20090121163905.6:@test leoBody is subset of leoTkBody
#@+node:ekr.20090121163905.7:@test leoFrame is subset of leoTkFrame
if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoFrame
    subClasses  = (tkGui.leoTkinterFrame,leoFrame.nullFrame)
    baseObject = c.frame

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
#@-node:ekr.20090121163905.7:@test leoFrame is subset of leoTkFrame
#@+node:ekr.20090121163905.8:@test leoGui is subset of leoTkGui
if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoGui as leoGui
    import inspect

    baseClass = leoGui.leoGui
    subClasses  = (tkGui.tkinterGui,) # nullGui can inherit almost all leoGui dummy methods.
    baseObject = g.app.gui

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            try:
                if name in baseObject.mustBeDefinedOnlyInBaseClass:
                    assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
                if name in baseObject.mustBeDefinedInSubclasses:
                    assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
            except AssertionError:
                raise
#@-node:ekr.20090121163905.8:@test leoGui is subset of leoTkGui
#@+node:ekr.20090121163905.9:@test leoTree is subset of leoTkTree
if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)

    import leo.core.leoFrame as leoFrame
    import inspect

    baseClass = leoFrame.leoTree
    subClasses  = (tkGui.leoTkinterTree,leoFrame.nullTree)
    baseObject = c.frame.tree

    methods = inspect.getmembers(baseClass,inspect.ismethod)
    methodNames = [z[0] for z in methods]

    for name in baseObject.mustBeDefinedOnlyInBaseClass:
        assert name in methodNames, 'not defined in base class %s.%s' % (baseClass.__name__,name)

    for subClass in subClasses:
        subclassName = subClass.__name__
        for name in methodNames:
            base_func = getattr(baseClass,name)
            sub_func =  getattr(subClass,name)
            if name in baseObject.mustBeDefinedOnlyInBaseClass:
                assert base_func.im_func == sub_func.im_func, 'defined in subclass %s.%s' % (subclassName,name)
            if name in baseObject.mustBeDefinedInSubclasses:
                assert base_func.im_func != sub_func.im_func, 'not defined in subclass %s.%s' % (subclassName,name)
#@-node:ekr.20090121163905.9:@test leoTree is subset of leoTkTree
#@+node:ekr.20090121163905.10:@test official commander ivars
f = c.frame
assert(f.c==c)
assert(c.frame==f)

ivars = (
    # Subcommanders...
    'atFileCommands','fileCommands','importCommands','tangleCommands','undoer',
    # Positions...
    '_currentPosition','_rootPosition','_topPosition',
    # Data structures...
    'hoistStack','recentFiles',
    # Args...
    'output_doc_flag','page_width','tab_width',
    'tangle_directory','tangle_errors','tangle_batch_flag','target_language',
    'untangle_batch_flag','use_header_flag',
    # Others...
    'mFileName',
)

for ivar in ivars:
    assert hasattr(c,ivar), 'missing commander ivar: %s' % ivar
    val = getattr(c,ivar)
    assert val is not None,'null commander ivar: %s'% ivar
#@nonl
#@-node:ekr.20090121163905.10:@test official commander ivars
#@+node:ekr.20090121163905.11:@test official frame ivars
f = c.frame
assert(f.c==c)
assert(c.frame==f)

if g.app.gui.guiName() == 'tkinter':
    ivars = (
        'bar1','bar2',
        'body',
        #'bodyBar','bodyXBar', # 2007: 10/31: There are now injected in c.frame.body.bodyCtrl.
        #'bodyCtrl', # 2007/10/27: this ivar is evil and has been removed.
        'canvas',
        'f1','f2',
        'iconBar','iconFrame',
        'log','outerFrame',
        'statusLine','statusFrame','statusLabel','statusText',
        'title','top','tree',
        #'treeBar', # leo_treeBar is now injected into frame.canvas.
    )
else: ivars = ()

for ivar in ivars:
    assert hasattr(f,ivar), 'missing frame ivar: %s' % ivar
    val = getattr(f,ivar)
    assert val is not None,'null frame ivar: %s'% ivar

# These do not have to be initied.
for ivar in ('findPanel',):
    assert hasattr(f,ivar), 'missing frame ivar: %s' % ivar
#@nonl
#@-node:ekr.20090121163905.11:@test official frame ivars
#@+node:ekr.20090121163905.12:@test official g.app directories
ivars = ('extensionsDir','globalConfigDir','loadDir','testDir')

for ivar in ivars:
    assert hasattr(g.app,ivar), 'missing g.app directory: %s' % ivar
    val = getattr(g.app,ivar)
    assert val is not None, 'null g.app directory: %s'% ivar
    assert g.os_path_exists(g.os_path_abspath(val)), 'non-existent g.app directory: %s' % ivar

assert hasattr(g.app,'homeDir') # May well be None.
#@nonl
#@-node:ekr.20090121163905.12:@test official g.app directories
#@+node:ekr.20090121163905.13:@test official g.app ivars

ivars = (
    # These are non-official and might be removed...
        # 'afterHandler','count','positions',
        # 'menuWarningsGiven','unicodeErrorGiven',
    'batchMode','config',
    'debug','debugSwitch','disableSave',
    'gui','hasOpenWithMenu','hookError','hookFunction',
    'idle_imported','idleTimeDelay','idleTimeHook','initing','killed',
    'leoID','loadedPlugins','log','logIsLocked','logWaiting',
    'nodeIndices','numberOfWindows',
    'quitting','realMenuNameDict','searchDict','scriptDict',
    'trace','tracePositions','trace_list','tkEncoding',
    'unitTestDict','unitTesting','use_psyco','windowList',
)

for ivar in ivars:
    assert hasattr(g.app,ivar), 'missing app ivar: %s' % ivar
    val = getattr(g.app,ivar)
    assert val is not None, 'null app ivar: %s'% ivar

# These do not have to be initied.
for ivar in (
    'commandName',
    'openWithFiles','openWithFileNum','openWithTable',
    'root',
):
    assert hasattr(g.app,ivar), 'missing app ivar: %s' % ivar
#@nonl
#@-node:ekr.20090121163905.13:@test official g.app ivars
#@-node:ekr.20090121163905.5:Check base classes & ivars
#@+node:ekr.20090121163905.14:@test batch mode
import os
import sys

verbose = False

python_interp = sys.executable
test_path = g.os_path_join(g.app.loadDir,"..","test","unittest")
src_path  = g.os_path_join(g.app.loadDir,"..","..")

leo_file   = g.os_path_join(src_path,"launchLeo.py")
batch_file = g.os_path_join(test_path,"batchTest.py")
test_file  = g.os_path_join(test_path,"createdFile.txt")

# Execute this command: python leo.py -script test\unittest\batchTest.py

if 1:
    command = r"%s %s --silent --script %s" % (python_interp,leo_file,batch_file)
else:
    command = r"%s %s --script %s" % (python_interp,leo_file,batch_file)

@others

removeFile(test_file,verbose)
os.system(command)

try:
    g.redirectStdout()
    removeFile(test_file,verbose)
    os.system(command)
finally:
    g.restoreStdout()

assert(g.os_path_exists(test_file))
#@nonl
#@+node:ekr.20090121163905.15:removeFile
def removeFile(path,verbose):

    if os.path.exists(test_file):
        if verbose:
            print("@test batch mode: deleting",test_file)
        os.remove(test_file)
    else:
        if verbose:
            print("@test batch mode: not found:",test_file)
#@-node:ekr.20090121163905.15:removeFile
#@-node:ekr.20090121163905.14:@test batch mode
#@+node:ekr.20090121163905.16:@@test checkAllPythonCode
result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result
#@nonl
#@-node:ekr.20090121163905.16:@@test checkAllPythonCode
#@+node:ekr.20090121163905.17:@test all commands have an event arg
import inspect

d = c.commandsDict ; keys = d.keys() ; keys.sort()

for key in keys:
    f = d.get(key) ; name = f and f.__name__
    args, varargs, varkw, defaults = data = inspect.getargspec(f)
    # print('%-28s' % (name),data)
    arg0 = len(args) > 0 and args[0]
    arg1 = len(args) > 1 and args[1]
    assert arg0 == 'self' and arg1 == 'event' or arg0 == 'event',\
       'no event arg for %s, args: %s' % (name,data)
#@nonl
#@-node:ekr.20090121163905.17:@test all commands have an event arg
#@+node:ekr.20090121163905.18:@test that all @test nodes in derived files start with if g.unitTesting
# print('-' * 30)
ok = True
p = c.rootPosition()
while p:
    if p.isAnyAtFileNode():
        h = p.h
        if h.endswith('.py'):
            # print('checking',p.h)
            # Check all the descendant nodes.
            for p2 in p.subtree_iter():
                h = p2.h
                for tag in ('@test','@suite'):
                    if h.startswith(tag):
                        s = p2.b
                        lines = g.splitLines(s)
                        for line in lines:
                            # print('line',line)
                            if not line.strip() or line.startswith('#'):
                                continue
                            elif line.startswith('if g.unitTesting:'):
                                break
                            else:
                                print('in',p.h)
                                print('missing "if g.unitTesting:"',h)
                                ok = False ; break
        p.moveToNodeAfterTree()
    else:
        p.moveToThreadNext()
assert ok
#@nonl
#@-node:ekr.20090121163905.18:@test that all @test nodes in derived files start with if g.unitTesting
#@+node:ekr.20090121163905.19:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of general unit tests')
#@nonl
#@-node:ekr.20090121163905.19:@test zz restore the screen
#@-node:ekr.20090121163905.4:General
#@+node:ekr.20090121163905.20:Plugins
#@+node:ekr.20090121163905.21:@ignore
#@+node:ekr.20090121163905.22:print all loaded plugins
import leo.core.leoPlugins as leoPlugins

print('\nloaded plugins...')

for p in g.app.loadedPlugins:
    print(p)

leoPlugins.printHandlers()
#@nonl
#@-node:ekr.20090121163905.22:print all loaded plugins
#@+node:ekr.20090121163905.23:@suite run all plugin test routines
import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.currentPosition()
<< class testRoutineTestCase >>
@others

plugins = getAllPlugins()

# g.printList(plugins)

print('@suite run all plugin test routines')

if 1:
    g.app.unitTestDict["fail"] = False
    suite = unittest.makeSuite(unittest.TestCase)
    for plugin in plugins:
        n = addTestRoutinesInPluginToSuite(c,g,plugin,suite)
        if n:
            plural = g.choose(n==1,'','s')
            s = 'found %2d test routine%s for %s' % (n,plural,plugin)
            g.es_print(s)
    if 1: # For @suite nodes.  Better for unit testing.
        g.app.scriptDict['suite'] = suite
    else: # For script button nodes.  Good for testing.
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=1).run(suite)
        c.setChanged(changed) # Restore changed state.
        c.selectVnode(p1) # N.B. Restore the selected node.
#@nonl
#@+node:ekr.20090121163905.24:<< class testRoutineTestCase >>
class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
#@nonl
#@+node:ekr.20090121163905.25:__init__
def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.currentPosition().copy()
    self.verbose = verbose
#@-node:ekr.20090121163905.25:__init__
#@+node:ekr.20090121163905.26: fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
#@nonl
#@-node:ekr.20090121163905.26: fail
#@+node:ekr.20090121163905.27:runTest
def runTest (self):

    f = self.f ; name = f.__name__ ; theClass = self.theClass

    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)

        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec s in d # Execute s in a environment containing c, g and p.

    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)
#@nonl
#@-node:ekr.20090121163905.27:runTest
#@+node:ekr.20090121163905.28:shortDescription
def shortDescription (self):

    return 'test function',repr(self.f)
#@nonl
#@-node:ekr.20090121163905.28:shortDescription
#@-node:ekr.20090121163905.24:<< class testRoutineTestCase >>
#@+node:ekr.20090121163905.29:addTestRoutinesInPluginToSuite
def addTestRoutinesInPluginToSuite (c,g,pluginName,suite):

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))

    plugin = g.importFromPath(pluginName,path,verbose=True)
    if not plugin:
        return len([])

    tests = findTestsInModule(plugin,pluginName)

    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,pluginName,theClass,f,code,verbose=False)
        suite.addTest(testCase)

    return len(tests)
#@-node:ekr.20090121163905.29:addTestRoutinesInPluginToSuite
#@+node:ekr.20090121163905.30:findTestsInModule
def findTestsInModule (module,moduleName):

    # g.trace(moduleName)

    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]

    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            # This looks like a bug in inspect: The zodb classes have no methods.
            # g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print('\nmethods of class %s...\n\n%s' % (theClass,toString(methods)))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    # Hack: remove duplicate tests from leoGlobals.py.
    functions = [(None,f) for name,f in functions
        if name.startswith('test_') and not name.startswith('test_g_')]

    if 0:
        << print classes, methods & functions >>

    result = functions
    result.extend(allMethods)
    return result
#@nonl
#@+node:ekr.20090121163905.31:<< print classes, methods & functions >>
print('=' * 40)

if classes:
    print('classes in %s...\n%s' % (moduleName,toString(classes)))
else:
    print('no classes in %s' % (moduleName))
if allMethods:
    print('test methods in %s...\n%s'   % (moduleName,toString(allMethods)))
else:
    print('no test methods in %s' % (moduleName))
if functions:
    print('test functions in %s...\n%s' % (moduleName,toString(functions)))
else:
    print('no test functions in %s' % (moduleName))
#@nonl
#@-node:ekr.20090121163905.31:<< print classes, methods & functions >>
#@-node:ekr.20090121163905.30:findTestsInModule
#@+node:ekr.20090121163905.32:getAllPlugins
def getAllPlugins ():

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    # g.trace(path)

    files = glob.glob(g.os_path_join(path,"*.py"))
    files = [g.os_path_abspath(f) for f in files]
    files = [str(g.shortFileName(f)) for f in files]
    files = [f for f in files if f.find('syntax_error_plugin') == -1]
    files.sort()
    plugins = [g.os_path_splitext(f)[0] for f in files]

    # g.trace(g.listToString(plugins))
    return plugins
#@nonl
#@-node:ekr.20090121163905.32:getAllPlugins
#@+node:ekr.20090121163905.33:removeLeadingWs
def removeLeadingWs (code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        elif not line.strip() and line.endswith('\n'):
            result.append('\n')
        else:
            print('unitTest.leo:underindented line:%s' % repr(line))
            result.append(line)

    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result
#@-node:ekr.20090121163905.33:removeLeadingWs
#@-node:ekr.20090121163905.23:@suite run all plugin test routines
#@+node:ekr.20090121163905.34:@suite plugins tests
# Create unit tests in g.app.scriptDict["suite"]
import leo.core.leoPlugins as leoPlugins
import leo.core.leoTest as leoTest
import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

g.app.scriptDict['suite'] = suite
#@nonl
#@+node:ekr.20090121163905.35:makePluginsTestSuite
def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
    plugins = g.os_path_abspath(plugins)
    files = glob.glob(plugins)
    files = [g.os_path_abspath(f) for f in files]
    files.sort()

    for f in files:
        test = pluginTestCase(c,f)
        # g.trace(test.shortDescription())
        suite.addTest(test)

    if 1:
        # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite
#@nonl
#@-node:ekr.20090121163905.35:makePluginsTestSuite
#@+node:ekr.20090121163905.36:class pluginTestCase
class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others
#@nonl
#@+node:ekr.20090121163905.37:__init__
def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
#@nonl
#@-node:ekr.20090121163905.37:__init__
#@+node:ekr.20090121163905.38:fail
def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)
#@nonl
#@-node:ekr.20090121163905.38:fail
#@+node:ekr.20090121163905.39:runTest
def runTest(self):

    c = self.c ; path = self.path

    path,file = g.os_path_split(path)
    moduleName,ext  = g.os_path_splitext(file)
    module = sys.modules.get(moduleName)

    if not module:
        module = leoPlugins.loadOnePlugin(moduleName,verbose=False)
        assert module, 'can not import %s' % moduleName
#@nonl
#@-node:ekr.20090121163905.39:runTest
#@+node:ekr.20090121163905.40:setUp
def setUp(self):

    g.app.unitTestDict = {}
#@nonl
#@-node:ekr.20090121163905.40:setUp
#@+node:ekr.20090121163905.41:shortDescription
def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)
#@nonl
#@-node:ekr.20090121163905.41:shortDescription
#@-node:ekr.20090121163905.36:class pluginTestCase
#@+node:ekr.20090121163905.42:class lastTestCase
class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''

    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print('\n%s a new window to test more plugin logic\n' % g.choose()
            self.openFlag,'opening','open')
        if self.openFlag:
            self.new_c = new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")

    if 0: # Doesn't work
        def shutDown(self):
            c = self.new_c
            c.close()
#@nonl
#@-node:ekr.20090121163905.42:class lastTestCase
#@-node:ekr.20090121163905.34:@suite plugins tests
#@+node:ekr.20090121163905.43:@test print All plugins tests complete
print('\nAll plugins tests complete.')
#@nonl
#@-node:ekr.20090121163905.43:@test print All plugins tests complete
#@+node:ekr.20090121163905.44:Tests of threading_colorizer code
if 0:
    @others

#@+node:ekr.20090121163905.45:quickConvertRowColToPythonIndex
def quickConvertRowColToPythonIndex(row,col):
    return lineIndices[row-1] + col

s = p.b
lines = g.splitLines(s)
lineIndices = [0]
for i in xrange(1,len(lines)):
    lineIndices.append(lineIndices[i-1] + len(lines[i-1]))

n = 0
for row in xrange(len(lines)):
    line = lines[row]
    for col in xrange(len(line)):
        assert quickConvertRowColToPythonIndex(row+1,col) == n
        n += 1
print('pass')

#@-node:ekr.20090121163905.45:quickConvertRowColToPythonIndex
#@+node:ekr.20090121163905.46:quickConvertPythonIndexToRowCol
# aaaaaaaaaaaaaaaaaa add some more characters.

total_count_chars = total_rfind_chars = 0

def quickConvertPythonIndexToRowCol(i,last_row,last_col,last_i):
    global total_count_chars, total_rfind_chars
    trace = False
    if trace: g.trace('i',i,'last_row',last_row,'last_col',last_col,'last_i',last_i)
    row = s.count('\n',last_i,i) # Don't include i
    total_count_chars += i-last_i
    if trace: g.trace('row',row)
    if row == 0:
        if trace: g.trace('returns',last_row,last_col+i-last_i)
        return last_row,last_col+i-last_i
    else:
        prevNL = s.rfind('\n',last_i,i) # Don't include i
        total_rfind_chars += i-last_i
        if trace: g.trace('prevNL',prevNL)
        if trace: g.trace('returns',last_row+row,i-prevNL-1)
        return last_row+row,i-prevNL-1

def fail(kind,expected,got):
    return 'n: %d, expected %s %d, got %s %d last_row %d last_col %d' % (
        n,kind,expected,kind,got,last_row,last_col)

# This is fast because we never look at characters more than once.
s = p.b
print('-'*40)
last_col = 0 ; last_row = 0 ; last_i = 0 ; n = 0
while n < len(s):
    expected_row, expected_col = g.convertPythonIndexToRowCol(s,n)
    row,col = quickConvertPythonIndexToRowCol(n,last_row,last_col,last_i=last_i)
    assert row == expected_row,fail('row',expected_row,row)
    assert col == expected_col,fail('col',expected_col,col)
    last_row = row ; last_col = col ; last_i = n
    n += 20
n = len(s)
expected_row, expected_col = g.convertPythonIndexToRowCol(s,n)
row,col = quickConvertPythonIndexToRowCol(n,last_row,last_col,last_i=last_i)
assert row == expected_row,fail('row',expected_row,row)
assert col == expected_col,fail('col',expected_col,col)
print('pass','len(s)',len(s),'total_count_chars',total_count_chars,'total_rfind_chars',total_rfind_chars)
#@-node:ekr.20090121163905.46:quickConvertPythonIndexToRowCol
#@-node:ekr.20090121163905.44:Tests of threading_colorizer code
#@-node:ekr.20090121163905.21:@ignore
#@+node:ekr.20090121163905.47:@suite test syntax of all plugins
# N.B.  We don't import the files: multiple imports might cause problems.
import unittest
import leo.core.leoTest as leoTest
import sys

@others

if sys.platform.lower().startswith('win'):

    print('@suite test syntax of all plugins')

    suite = unittest.makeSuite(unittest.TestCase)

    for path in leoTest.getAllPluginFilenames():

        f = file(path)
        assert f, "File not found: %s" % path
        # Do not test the syntax_error_plugin.
        if path.find('syntax_error_plugin') == -1:
            s = f.read() ; f.close()
            test = parseFileTestCase(c,path,checkCompile=True,checkTabs=True)
            suite.addTest(test)

    if suite:
        g.app.scriptDict['suite'] = suite

else:

    pass # Only test these on Windows.
#@nonl
#@+node:ekr.20090121163905.48:class parseFileTestCase
class parseFileTestCase (unittest.TestCase):

    @others
#@nonl
#@+node:ekr.20090121163905.49:__init__
def __init__ (self,c,path,checkCompile,checkTabs):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.checkCompile = checkCompile
    self.checkTabs = checkTabs
    assert self.checkCompile or self.checkTabs, "not checking anything"
#@nonl
#@-node:ekr.20090121163905.49:__init__
#@+node:ekr.20090121163905.50:runTest
def runTest(self):

    c = self.c ; path = self.path

    s = file(path).read()

    if self.checkCompile:
        leoTest.checkFileSyntax(path,s)

    if self.checkTabs:
        leoTest.checkFileTabs(path,s)
#@nonl
#@-node:ekr.20090121163905.50:runTest
#@+node:ekr.20090121163905.51:shortDescription
def shortDescription (self):

    fn = str(g.shortFileName(self.path))

    if self.checkCompile and self.checkTabs:
        return "Test syntax and tabbing of %s plugin" % fn
    elif self.checkCompile:
        return "Test syntax of %s plugin" % fn
    else:
        return "Test tabbing of %s plugin" % fn
#@nonl
#@-node:ekr.20090121163905.51:shortDescription
#@-node:ekr.20090121163905.48:class parseFileTestCase
#@-node:ekr.20090121163905.47:@suite test syntax of all plugins
#@+node:ekr.20090121163905.52:@test rClick.py
if g.app.gui.guiName() == 'tkinter':

    import rClick
    rClick.init()
#@-node:ekr.20090121163905.52:@test rClick.py
#@+node:ekr.20090121163905.53:detect_urls.py
#@+node:ekr.20090121163905.54:@test openURL
import detect_urls

w = c.frame.body.bodyCtrl
s = w.getAllText()
w.setInsertPoint(len(s))
url = detect_urls.openURL(tag='test',keywords={'c':c})
assert url == 'http://webpages.charter.net/edreamleo/front.html','Got:%s' % repr(url)

@ The last line is the url
http://webpages.charter.net/edreamleo/front.html
#@nonl
#@-node:ekr.20090121163905.54:@test openURL
#@+node:ekr.20090121163905.55:@test colorizerURLs
# Only tk gui colorizers with tag_ranges.

if g.app.gui.guiName() == 'tkinter':

    import detect_urls
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    detect_urls.colorizeURLs(tag='test',keywords={'c':c})
    assert w.tag_ranges('URL'),'no URL tags'

@ The last line is the url
http://webpages.charter.net/edreamleo/front.html
#@nonl
#@-node:ekr.20090121163905.55:@test colorizerURLs
#@-node:ekr.20090121163905.53:detect_urls.py
#@+node:ekr.20090121163905.56:@test mnplugins.insertBodystamp
import mnplugins

w = c.frame.body.bodyCtrl
s = w.getAllText()

try:
    w.setInsertPoint(len(s))
    mnplugins.insertBodystamp(c,p)
    s2 = w.getAllText()
    assert s2.startswith(s)
    assert len(s2) > len(s) + 15
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# end:
#@nonl
#@-node:ekr.20090121163905.56:@test mnplugins.insertBodystamp
#@+node:ekr.20090121163905.57:@test macros.parameterize
import macros

controller = macros.paramClass(c)
controller.parameterize()
    # Not much will happen because there are no children.
    # However, this does test recent changes.
#@nonl
#@-node:ekr.20090121163905.57:@test macros.parameterize
#@+node:ekr.20090121163905.58:@test restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.
import leo.core.leoTest as leoTest
u = leoTest.testUtils(c) # This *is* used

c.contractAllHeadlines()
h = 'All unit tests'
p = u.findNodeAnywhere(h)
if p:
    p.expand()
    g.app.unitTestDict['restoreSelectedNode']=False
    c.selectPosition(p)
    c.redraw()

print('\nEnd of plugins unit tests')
#@nonl
#@-node:ekr.20090121163905.58:@test restore the screen
#@-node:ekr.20090121163905.20:Plugins
#@+node:ekr.20090121163905.59:Organized by file
#@+node:ekr.20090121163905.60:leoAtFile
#@+node:ekr.20090121163905.61:@@test bogus tnodeList doesn't corrupt @thin nodes
import leo.core.leoTest as leoTest

u = leoTest.testUtils(c)
h = "@thin ../src/leoTest.py"
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h

p.v.t.tnodeList = ["bogus tnodeList"]

if 0: # This causes p to be written, thereby clearing the tnodeList.
    p.setDirty()

if 0: # This actually saves this file, so it is a bit dangerous.
    g.app.unitTestDict = {}
    ### c.save()
    ok = g.app.unitTestDict.get("warning")
    assert ok, "putVnode failed to give warning"
#@nonl
#@-node:ekr.20090121163905.61:@@test bogus tnodeList doesn't corrupt @thin nodes
#@+node:ekr.20090121163905.62:@test @asis
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.63:#@asis
# Test that @nosent generates no sentinels

<< section >>

@others

last line
#@nonl
#@+node:ekr.20090121163905.64:<< section >>
section line 1
#@nonl
#@-node:ekr.20090121163905.64:<< section >>
#@+node:ekr.20090121163905.65:unnamed node
unnamed node line 1
#@nonl
#@-node:ekr.20090121163905.65:unnamed node
#@-node:ekr.20090121163905.63:#@asis
#@+node:ekr.20090121163905.66:Output
# Test that @nosent generates no sentinels

<< section >>

@others

last linesection line 1unnamed node line 1
#@nonl
#@-node:ekr.20090121163905.66:Output
#@-node:ekr.20090121163905.62:@test @asis
#@+node:ekr.20090121163905.67:@test @file no newline
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.68:#@file
Line 1

@last last line 1: no newline
#@nonl
#@-node:ekr.20090121163905.68:#@file
#@+node:ekr.20090121163905.69:Output
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+leo-ver=4
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:#@file
Line 1

@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@@last
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@nonl
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:#@file
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-leo
last line 1: no newline
#@nonl
#@-node:ekr.20090121163905.69:Output
#@-node:ekr.20090121163905.67:@test @file no newline
#@+node:ekr.20090121163905.70:@test @file one newline
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.71:#@file
Line 1

@last last line 1: newline
#@-node:ekr.20090121163905.71:#@file
#@+node:ekr.20090121163905.72:Output
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+leo-ver=4
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:#@file
Line 1

@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@@last
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:#@file
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-leo
last line 1: newline
#@-node:ekr.20090121163905.72:Output
#@-node:ekr.20090121163905.70:@test @file one newline
#@+node:ekr.20090121163905.73:@test @file two newlines
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.74:#@file
Line 1

@last last line 1: two trailing newlines
#@-node:ekr.20090121163905.74:#@file
#@+node:ekr.20090121163905.75:Output
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+leo-ver=4
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:#@file
Line 1

@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@@last
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:#@file
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-leo
last line 1: two trailing newlines
#@-node:ekr.20090121163905.75:Output
#@-node:ekr.20090121163905.73:@test @file two newlines
#@+node:ekr.20090121163905.76:@test @noref
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.77:#@noref
# Test that @nosent generates no sentinels

<< section >>

@others

last line
#@nonl
#@+node:ekr.20090121163905.78:<< section >>
section line 1
#@nonl
#@-node:ekr.20090121163905.78:<< section >>
#@+node:ekr.20090121163905.79:unnamed node
unnamed node line 1
#@nonl
#@-node:ekr.20090121163905.79:unnamed node
#@-node:ekr.20090121163905.77:#@noref
#@+node:ekr.20090121163905.80:Output
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+leo-ver=4
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:#@noref
# Test that @nosent generates no sentinels

<< section >>

@others

last line
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@nonl
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:#@noref
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:<< section >>
section line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@nonl
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:<< section >>
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:unnamed node
unnamed node line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@nonl
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:unnamed node
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-leo
#@-node:ekr.20090121163905.80:Output
#@-node:ekr.20090121163905.76:@test @noref
#@+node:ekr.20090121163905.81:@test @nosent
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.82:#@nosent
# Test that @nosent generates no sentinels
<< section >>
@others
last line
#@nonl
#@+node:ekr.20090121163905.83:<< section >>
section line 1
#@nonl
#@-node:ekr.20090121163905.83:<< section >>
#@+node:ekr.20090121163905.84:unnamed node
unnamed node line 1
#@nonl
#@-node:ekr.20090121163905.84:unnamed node
#@-node:ekr.20090121163905.82:#@nosent
#@+node:ekr.20090121163905.85:Output
# Test that @nosent generates no sentinels
section line 1
unnamed node line 1
last line
#@-node:ekr.20090121163905.85:Output
#@-node:ekr.20090121163905.81:@test @nosent
#@+node:ekr.20090121163905.86:@test @thin
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.87:#@thin
Line 1

@last last line 1: no newline
#@nonl
#@-node:ekr.20090121163905.87:#@thin
#@+node:ekr.20090121163905.88:Output
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+leo-ver=4-thin
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@+node:ekr.20040707141957.13:#@thin
Line 1

@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@@last
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@nonl
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-node:ekr.20040707141957.13:#@thin
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@-leo
last line 1: no newline
#@nonl
#@-node:ekr.20090121163905.88:Output
#@-node:ekr.20090121163905.86:@test @thin
#@+node:ekr.20090121163905.89:@test at.scanAllDirectives
# This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)

assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
#@-node:ekr.20090121163905.89:@test at.scanAllDirectives
#@+node:ekr.20090121163905.90:@test atFile.directiveKind4
at=c.atFileCommands
table = [
    ('@=',0,at.noDirective),
    ('@',0,at.atDirective),
    ('@ ',0,at.atDirective),
    ('@\t',0,at.atDirective),
    ('@\n',0,at.atDirective),
    ('@all',0,at.allDirective),
    ('    @all',4,at.allDirective),
    ("@c",0,at.cDirective),
    ("@code",0,at.codeDirective),
    ("@doc",0,at.docDirective),
    ("@end_raw",0,at.endRawDirective),
    ('@others',0,at.othersDirective),
    ('    @others',4,at.othersDirective),
    ("@raw",0,at.rawDirective),
]
for name in g.globalDirectiveList:
    # Note: entries in g.globalDirectiveList do not start with '@'
    if name not in ('all','c','code','doc','end_raw','others','raw',):
        table.append(('@' + name,0,at.miscDirective),)

for s,i,expected in table:
    result = at.directiveKind4(s,i)
    assert result == expected, '%d %s result: %s expected: %s' % (
        i,repr(s),at.sentinelName(result),at.sentinelName(expected))
#@-node:ekr.20090121163905.90:@test atFile.directiveKind4
#@+node:ekr.20090121163905.91:@test atFile.isSignificantTree
assert c.atFileCommands.isSignificantTree(p)

#@-node:ekr.20090121163905.91:@test atFile.isSignificantTree
#@+node:ekr.20090121163905.92:@test atFile.remove
import os

at = c.atFileCommands
exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)

assert not exists(path)
assert not at.remove(path,verbose=False)

f = file(path,'w')
f.write('test')
f.close()

assert exists(path)
assert at.remove(path)
assert not exists(path)
#@nonl
#@-node:ekr.20090121163905.92:@test atFile.remove
#@+node:ekr.20090121163905.93:@test atFile.rename
import os

at = c.atFileCommands
exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert at.rename(path,path2,verbose=True)
assert exists(path2)
f = file(path2)
s = f.read()
f.close()
# print('Contents of %s: %s' % (path2,s))
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)
#@nonl
#@-node:ekr.20090121163905.93:@test atFile.rename
#@+node:ekr.20090121163905.94:@test atFile.replaceTargetFileIfDifferent (different)
import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths (different contents)
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    s = 'test %s' % p
    # print(repr(p),repr(s))
    f.write(s)
    f.close()
    assert exists(p) # , '%s does not exist' % repr(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
root = at.root
assert at.replaceTargetFileIfDifferent(root), 'replaceTargetFileIfDifferent returns False'
if 0:
    print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
    print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = file(at.targetFileName)
s = f.read()
f.close()
# print('Contents of %s: %s' % (at.targetFileName,s))
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)
#@nonl
#@-node:ekr.20090121163905.94:@test atFile.replaceTargetFileIfDifferent (different)
#@+node:ekr.20090121163905.95:@test atFile.replaceTargetFileIfDifferent (identical)
import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths (identical contents)
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    s = 'test %s' % at.outputFileName
    # print(repr(p),repr(s))
    f.write(s)
    f.close()
    assert exists(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
root = at.root
assert not at.replaceTargetFileIfDifferent(root), 'replaceTargetFileIfDifferent returns True'
if 0:
    print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
    print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = file(at.targetFileName)
s = f.read()
f.close()
# print('Contents of %s: %s' % (at.targetFileName,s))
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)
#@nonl
#@-node:ekr.20090121163905.95:@test atFile.replaceTargetFileIfDifferent (identical)
#@+node:ekr.20090121163905.96:@test atFile.replaceTargetFileIfDifferent (no target file)
import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Remove both files, then create only the output file
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)

for p in (at.outputFileName,):
    assert not exists(p)
    f = file(p,'w')
    s = 'test %s' % at.outputFileName
    # print(repr(p),repr(s))
    f.write(s)
    f.close()
    assert exists(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
root = at.root
assert not at.replaceTargetFileIfDifferent(root), 'replaceTargetFileIfDifferent returns True'
if 0:
    print('%s exists %s' % (at.outputFileName,exists(at.outputFileName)))
    print('%s exists %s' % (at.targetFileName,exists(at.targetFileName)))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = file(at.targetFileName)
s = f.read()
f.close()
# print('Contents of %s: %s' % (at.targetFileName,s))
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)
#@nonl
#@-node:ekr.20090121163905.96:@test atFile.replaceTargetFileIfDifferent (no target file)
#@+node:ekr.20090121163905.97:@test parseLeoSentinel
s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.

at=c.atFileCommands # Self is a dummy argument.

for s in (s1,s2):
    valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    # g.trace('start',start,'end',repr(end),'len(s)',len(s))
    assert valid, 'not valid'
    assert new_df, 'not new_df'
    assert isThinDerivedFile, 'not thin'
    assert end == '', 'invalid end: %s' % repr(end)
    assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
#@-node:ekr.20090121163905.97:@test parseLeoSentinel
#@+node:ekr.20090121163905.98:@test reads/write using @comment
at = c.atFileCommands
child = p.firstChild()
child2 = child.next()
result = str(child2.b)
at.write(child,nosentinels=False,thinFile=False,scriptWrite=False,toString=True)
s = str(at.stringOutput)

if s != result:
    print('-' * 30)
    print(s)
    print('-' * 30)
    print(result)

assert s == result
#@nonl
#@+node:ekr.20090121163905.99:root
@language c
#ifdef COMMENT
@comment /* */ 
#endif
@tabwidth 4
@lineending crlf

@others

<< Get LRR Task >>
<< Start LRR >>
#@nonl
#@+node:ekr.20090121163905.100:<< Get LRR Task >>
#@-node:ekr.20090121163905.100:<< Get LRR Task >>
#@+node:ekr.20090121163905.101:<< Start LRR >>
#@-node:ekr.20090121163905.101:<< Start LRR >>
#@-node:ekr.20090121163905.99:root
#@+node:ekr.20090121163905.102:Result
/*@+leo-ver=4*/
/*@+node:root*/
/*@@language c*/
#ifdef COMMENT
/*@@comment /* */ */
#endif
/*@@tabwidth 4*/
/*@@lineending crlf*/

/*@+others*/
/*@-others*/

/*@<< Get LRR Task >>*/
/*@+node:<< Get LRR Task >>*/
/*@-node:<< Get LRR Task >>*/
/*@nl*/
/*@<< Start LRR >>*/
/*@+node:<< Start LRR >>*/
/*@-node:<< Start LRR >>*/
/*@nl*/
/*@nonl*/
/*@-node:root*/
/*@-leo*/
#@-node:ekr.20090121163905.102:Result
#@-node:ekr.20090121163905.98:@test reads/write using @comment
#@+node:ekr.20090121163905.103:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoAtFile tests')
#@nonl
#@-node:ekr.20090121163905.103:@test zz restore the screen
#@-node:ekr.20090121163905.60:leoAtFile
#@+node:ekr.20090121163905.104:leoBridge
#@+node:ekr.20090121163905.105:@test leoBridge init logic
import leo.core.leoBridge as leoBridge

if 0: # This can not be run locally: it contains another Tk event loop.
    controller = leoBridge.controller(gui='nullGui',verbose=False)
    g = controller.globals()
#@-node:ekr.20090121163905.105:@test leoBridge init logic
#@-node:ekr.20090121163905.104:leoBridge
#@+node:ekr.20090121163905.106:leoColor
#@+node:ekr.20090121163905.107:@test @comment after @language plain
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.108:Test
@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.
#@nonl
#@-node:ekr.20090121163905.108:Test
#@-node:ekr.20090121163905.107:@test @comment after @language plain
#@+node:ekr.20090121163905.109:@test colorizer Actionscript
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.110:Actionscript
@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket
#@nonl
#@-node:ekr.20090121163905.110:Actionscript
#@-node:ekr.20090121163905.109:@test colorizer Actionscript
#@+node:ekr.20090121163905.111:@test colorizer C
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.112:C
@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number & flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include <hpc_ram.h>
#include <rlydef.h>
#@nonl
#@-node:ekr.20090121163905.112:C
#@-node:ekr.20090121163905.111:@test colorizer C
#@+node:ekr.20090121163905.113:@test colorizer C#
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.114:C#
@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield
#@nonl
#@-node:ekr.20090121163905.114:C#
#@-node:ekr.20090121163905.113:@test colorizer C#
#@+node:ekr.20090121163905.115:@test colorizer css
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.116:css
@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside
#@nonl
#@-node:ekr.20090121163905.116:css
#@-node:ekr.20090121163905.115:@test colorizer css
#@+node:ekr.20090121163905.117:@test colorizer CWEB
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.118:CWEB
@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
<< section ref >>
<< missing ref >>
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
<< section ref >>
<< missing ref >>

\LaTeX and \c should not be colored.
if else, while, do // C keywords.
#@nonl
#@+node:ekr.20090121163905.119:<< section ref >>
<< section def >>=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */
#@nonl
#@-node:ekr.20090121163905.119:<< section ref >>
#@-node:ekr.20090121163905.118:CWEB
#@-node:ekr.20090121163905.117:@test colorizer CWEB
#@+node:ekr.20090121163905.120:@test colorizer elisp
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.121:elisp
@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while
#@nonl
#@-node:ekr.20090121163905.121:elisp
#@-node:ekr.20090121163905.120:@test colorizer elisp
#@+node:ekr.20090121163905.122:@test colorizer erlang
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.123:erlang
@language erlang

halt()

-module()
#@nonl
#@-node:ekr.20090121163905.123:erlang
#@-node:ekr.20090121163905.122:@test colorizer erlang
#@+node:ekr.20090121163905.124:@test colorizer forth
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.125:forth
@language forth

\ tiny demo of Leo forth syntax colouring

: some-forth-word ( x1 x2 -- x3 ) \ blue :, black/bold some-forth-word
   label: y  \ blue label:
   asm[ s" some string" type ]asm cr
   asm[ abc ]asm
   a
   s" abc "
   s" abc"
   a
   tty" abc "
   lcd2" abc "
   until

@ test
@c

{ abc }

a b @ c

asm[ abc ]asm

.( ab ) \ a string

: foo [ .s ] ;

   [ a b c
   x y z]
;
#@nonl
#@-node:ekr.20090121163905.125:forth
#@-node:ekr.20090121163905.124:@test colorizer forth
#@+node:ekr.20090121163905.126:@test colorizer HTML string bug
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.127:String bug in html
@language html

b = "cd"
d
#@-node:ekr.20090121163905.127:String bug in html
#@-node:ekr.20090121163905.126:@test colorizer HTML string bug
#@+node:ekr.20090121163905.128:@test colorizer HTML1
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.129:HTML1
@language html

<HTML>
<!-- Author: Edward K. Ream, edream@tds.net -->
<HEAD>
  <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
  <TITLE> Leo's Home Page </TITLE>
  <META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages.">
  <META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE">
</HEAD>
<!-- Last Modified: May 12, 2002 -->
<BODY BGCOLOR="#fffbdc">

<H1 ALIGN=CENTER><a NAME="top"></a><IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"><IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"><a href="leo_TOC.html#top"><IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"></a> &nbsp;</H1>

<H1 ALIGN=CENTER> Leo's Home Page</H1>

<p align="center"><a href="http://www.python.org/"><img border="0" src="PythonPowered.gif" width="110" height="44"> </a> <A HREF="http://sourceforge.net/"><IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"></A>&nbsp;&nbsp;&nbsp;
<A HREF="http://sourceforge.net/project/?group_id=3458">Leo at SourceForge</A>&nbsp;&nbsp;
<a href="icons.html"><img border="0" src="LeoCodeGray.gif" width="77" height="42"></a>&nbsp;&nbsp;
<a href="icons.html"><img border="0" src="LeoProse.gif" width="81" height="42"></a>&nbsp;&nbsp;&nbsp;&nbsp;

<H3><A NAME="anchor127554"></A>Summary</H3>

<UL>
  <LI>Leo is a <i> programmer's editor</i>  and a flexible <i>browser</i> for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  <LI>Leo is an <i>outlining editor</i>. Outlines clarify the big picture while
    providing unlimited space for details.
  <LI>Leo
    is a <a HREF="http://www.literateprogramming.com/"><i>literate
    programming</i></a> tool, compatible with <A HREF="http://www.eecs.harvard.edu/~nr/noweb/">noweb</A>
    and <a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html">CWEB</a>.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  <LI>Leo is also a <i>data organizer</i>. A single Leo outline can generate complex
    data spanning many different files.&nbsp; Leo has been used to manage web sites.
  <LI>Leo is a <i> project manager</i>. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  <LI>Leo is fully <i> scriptable</i> using <A HREF="http://www.python.org/">Python</A>
  and saves its files in <A HREF="http://www.w3.org/XML/">XML</A> format.
  <LI>Leo is <i>portable</i>.&nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting <A HREF="http://www.python.org/">Python</A>
    and <a href="http://tcl.activestate.com/">Tk/tcl</a>, including Windows,
    Linux and MacOS X.&nbsp; Leo.exe runs on any Windows platform.
  <LI>Leo is <a href="http://www.opensource.org/"> <i> Open Software</i></a>, distributed under
    the <a href="http://www.python.org/doc/Copyright.html"> Python License</a>.
</UL>

<H3>More Information and downloads</H3>

<ul>
  <LI>An excellent <a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm">online
    tutorial</a> and <A HREF="http://www.jserv.com/jk_orr/xml/leo.htm">Leo resource
  page</A>, both written by <a href="http://www.jserv.com/jk_orr">Joe Orr</a>.
  <LI>My brother's <a href="SpeedReam.html">slashdot
    article about Leo</a>, the best description about why Leo is special.
  <LI><A HREF="testimonials.html#anchor104391">What people are saying about Leo</A>
  <LI><A HREF="leo_TOC.html#anchor964914">Complete users guide</A>
    and
    <A HREF="intro.html#anchor887874">tutorial introduction</A>  with
  screen shots.
  <li><a href="FAQ.html">FAQ</a> and <a href="http://sourceforge.net/forum/?group_id=3458">help and discussion
    forums</a>, preferable to <A HREF="mailto:edream@tds.net">email</A> so others may join
    in.</li>
  <li><a href="icons.html">Icons</a> for bragging about Leo.</li>
</ul>

<a href="http://sourceforge.net/project/showfiles.php?group_id=3458">Download
    Leo</a> from <A HREF="http://sourceforge.net/project/?group_id=3458">Leo's SourceForge
site</A>.

<P ALIGN=left>Leo's author is <A HREF="http://personalpages.tds.net/~edream/index.html">Edward
  K. Ream</A> email: <A HREF="mailto:edream@tds.net">edream@tds.net</A> voice: (608) 231-0766

<HR ALIGN=LEFT>

<p align="center">

<IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"><IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"><a HREF="leo_TOC.html"><IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3">

</BODY>
</HTML>
#@nonl
#@-node:ekr.20090121163905.129:HTML1
#@-node:ekr.20090121163905.128:@test colorizer HTML1
#@+node:ekr.20090121163905.130:@test colorizer HTML2
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.131:HTML2
@language html

<? xml version="1.0">
<!-- test -->
<project name="Converter" default="dist">
</project>"""
#@nonl
#@-node:ekr.20090121163905.131:HTML2
#@-node:ekr.20090121163905.130:@test colorizer HTML2
#@+node:ekr.20090121163905.132:@test colorizer Java
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.133:Java
@ doc part
@c

@language java /* Colored by match_leo_keyword: tag = leoKeyword. */

@whatever /* Colored by java match_following rule: tag = keyword4. */

/** A javadoc: tag = comment3 */

/** <!-- comment --> tag = comment1. */

/** @see tag = label */
#@nonl
#@-node:ekr.20090121163905.133:Java
#@-node:ekr.20090121163905.132:@test colorizer Java
#@+node:ekr.20090121163905.134:@test colorizer LaTex
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.135:LaTex
@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}

The following should be colored:

\documentclass{report}

The following 2-letter words should be colored, regardless of what follows:

\(\)\{\}\@
\(abc\)abc\{abc\}abc\@abc
#@nonl
#@-node:ekr.20090121163905.135:LaTex
#@-node:ekr.20090121163905.134:@test colorizer LaTex
#@+node:ekr.20090121163905.136:@test colorizer lisp
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.137:lisp
@language lisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while
#@nonl
#@-node:ekr.20090121163905.137:lisp
#@-node:ekr.20090121163905.136:@test colorizer lisp
#@+node:ekr.20090121163905.138:@test colorizer perl
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.139:perl
@language perl

# From a perl tutorial.

print 'Hello world.';		# Print a message

$a = $b;	# Assign $b to $a

@food  = ("apples", "pears", "eels");

$grub = pop(@food);	# Now $grub = "eels"

$#food

@lines = <INFO>;

#!/usr/local/bin/perl
print "Password? ";		# Ask for input
$a = <STDIN>;			# Get input
chop $a;			# Remove the newline at end
while ($a ne "fred")		# While input is wrong...
{
    print "sorry. Again? ";	# Ask again
    $a = <STDIN>;		# Get input again
    chop $a;			# Chop off newline again
}

if ($sentence =~ /under/)
{
	print "We're talking about rugby\\n";
}

$sentence =~ s/london/London/

$_ = "Capes:Geoff::Shot putter:::Big Avenue";
@personal = split(/:/);

foreach $age (values %ages)
{
	print "Somebody is $age\\n";
}

&mysubroutine;		# Call the subroutine
&mysubroutine($_);	# Call it with a parameter
&mysubroutine(1+2, $_);	# Call it with two parameters

sub inside
{
	local($a, $b);			# Make local variables
	($a, $b) = ($_[0], $_[1]);	# Assign values
	$a =~ s/ //g;			# Strip spaces from
	$b =~ s/ //g;			#   local variables
	($a =~ /$b/ || $b =~ /$a/);	# Is $b inside $a
					#   or $a inside $b?
}
#@nonl
#@-node:ekr.20090121163905.139:perl
#@-node:ekr.20090121163905.138:@test colorizer perl
#@+node:ekr.20090121163905.140:@test colorizer PHP
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.141:PHP
@language php
@ doc
This is a doc part.
@c

and or
array
array()
/* Multi-line comment
*/
this is a test.
__CLASS__
<?php and or array() ?>
<?PHP and or array() ?>
#@nonl
#@-node:ekr.20090121163905.141:PHP
#@-node:ekr.20090121163905.140:@test colorizer PHP
#@+node:ekr.20090121163905.142:@test colorizer plsql
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.143:plsql
@language plsql

"a string"
-- reserved keywords
ABORT,
abort,
ACceSS,
access,
add,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor
#@nonl
#@-node:ekr.20090121163905.143:plsql
#@-node:ekr.20090121163905.142:@test colorizer plsql
#@+node:ekr.20090121163905.144:@test colorizer python.xml (jEdit)
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.145:python.xml
@language html

<?xml version="1.0"?>

<!DOCTYPE MODE SYSTEM "xmode.dtd">
<< remarks >>

<MODE>
    <PROPS>
        <PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" />
        <PROPERTY NAME="lineComment" VALUE="#" />
    </PROPS>
    <RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE">
        << comments >>
        << literals >>
        << operators >>
        <MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE">(</MARK_PREVIOUS>
        << keywords >>
    </RULES>
</MODE>
#@nonl
#@+node:ekr.20090121163905.146:<< remarks >>
<!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by -->
<!-- Jonathan Revusky -->

<!-- Modified 19-Jul-00 by Ivan Frohne to: -->
<!--  (a) implement 'indentOnEnter'; -->
<!--  (b) indent next line automatically after control structures followed -->
<!--	  by ':'; -->
<!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; -->
<!--  (d) add TYPE FUNCTION identified by a following '(' -->
<!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); -->
<!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and -->
<!--  (g) add all builtin functions, builtin exceptions, -->
<!--	  builtin type methods, File object methods, and special type -->
<!--	  attributes as TYPE KEYWORD3. -->
#@nonl
#@-node:ekr.20090121163905.146:<< remarks >>
#@+node:ekr.20090121163905.147:<< comments >>
<!-- Comment -->
<EOL_SPAN TYPE="COMMENT1">#</EOL_SPAN>

<!-- Triple-quotes -->
<SPAN TYPE="LITERAL2">
    <BEGIN>"""</BEGIN>
    <END>"""</END>
</SPAN>

<SPAN TYPE="LITERAL2">
    <BEGIN>'''</BEGIN>
    <END>'''</END>
</SPAN>
#@nonl
#@-node:ekr.20090121163905.147:<< comments >>
#@+node:ekr.20090121163905.148:<< literals >>
<!-- Standard literals -->
<SPAN TYPE="LITERAL1">
    <BEGIN>"</BEGIN>
    <END>"</END>
</SPAN>

<SPAN TYPE="LITERAL1">
    <BEGIN>'</BEGIN>
    <END>'</END>
</SPAN>
#@-node:ekr.20090121163905.148:<< literals >>
#@+node:ekr.20090121163905.149:<< operators >>
<SEQ TYPE="OPERATOR">=</SEQ>
<SEQ TYPE="OPERATOR">!</SEQ>
<SEQ TYPE="OPERATOR">&gt;=</SEQ>
<SEQ TYPE="OPERATOR">&lt;=</SEQ>
<SEQ TYPE="OPERATOR">+</SEQ>
<SEQ TYPE="OPERATOR">-</SEQ>
<SEQ TYPE="OPERATOR">/</SEQ>
<SEQ TYPE="OPERATOR">*</SEQ>
<SEQ TYPE="OPERATOR">&gt;</SEQ>
<SEQ TYPE="OPERATOR">&lt;</SEQ>
<SEQ TYPE="OPERATOR">%</SEQ>
<SEQ TYPE="OPERATOR">&amp;</SEQ>
<SEQ TYPE="OPERATOR">|</SEQ>
<SEQ TYPE="OPERATOR">^</SEQ>
<SEQ TYPE="OPERATOR">~</SEQ>
#@nonl
#@-node:ekr.20090121163905.149:<< operators >>
#@+node:ekr.20090121163905.150:<< keywords >>
<KEYWORDS>
    << reserved words >>
    << builtins >>
    << exceptions >>
    << types >>
</KEYWORDS>
#@nonl
#@+node:ekr.20090121163905.151:<< reserved words >>
<!--  Reserved Words  -->
<KEYWORD1>and</KEYWORD1>
<KEYWORD1>as</KEYWORD1>
<KEYWORD1>assert</KEYWORD1>
<KEYWORD1>break</KEYWORD1>
<KEYWORD1>class</KEYWORD1>
<KEYWORD1>continue</KEYWORD1>
<KEYWORD1>def</KEYWORD1>
<KEYWORD1>del</KEYWORD1>
<KEYWORD1>elif</KEYWORD1>
<KEYWORD1>else</KEYWORD1>
<KEYWORD1>except</KEYWORD1>
<KEYWORD1>exec</KEYWORD1>
<KEYWORD1>finally</KEYWORD1>
<KEYWORD1>for</KEYWORD1>
<KEYWORD1>from</KEYWORD1>
<KEYWORD1>global</KEYWORD1>
<KEYWORD1>if</KEYWORD1>
<KEYWORD1>import</KEYWORD1>
<KEYWORD1>in</KEYWORD1>
<KEYWORD1>is</KEYWORD1>
<KEYWORD1>lambda</KEYWORD1>
<KEYWORD1>not</KEYWORD1>
<KEYWORD1>or</KEYWORD1>
<KEYWORD1>pass</KEYWORD1>
<KEYWORD1>print</KEYWORD1>
<KEYWORD1>raise</KEYWORD1>
<KEYWORD1>return</KEYWORD1>
<KEYWORD1>try</KEYWORD1>
<KEYWORD1>while</KEYWORD1>
<KEYWORD1>yield</KEYWORD1>
#@nonl
#@-node:ekr.20090121163905.151:<< reserved words >>
#@+node:ekr.20090121163905.152:<< builtins >>
<!-- builtins -->
<KEYWORD2>abs</KEYWORD2>
<KEYWORD2>apply</KEYWORD2>
<KEYWORD2>bool</KEYWORD2>
<KEYWORD2>buffer</KEYWORD2>
<KEYWORD2>callable</KEYWORD2>
<KEYWORD2>chr</KEYWORD2>
<KEYWORD2>classmethod</KEYWORD2>
<KEYWORD2>cmp</KEYWORD2>
<KEYWORD2>coerce</KEYWORD2>
<KEYWORD2>compile</KEYWORD2>
<KEYWORD2>complex</KEYWORD2>
<KEYWORD2>delattr</KEYWORD2>
<KEYWORD2>dict</KEYWORD2>
<KEYWORD2>dir</KEYWORD2>
<KEYWORD2>divmod</KEYWORD2>
<KEYWORD2>eval</KEYWORD2>
<KEYWORD2>execfile</KEYWORD2>
<KEYWORD2>file</KEYWORD2>
<KEYWORD2>filter</KEYWORD2>
<KEYWORD2>float</KEYWORD2>
<KEYWORD2>getattr</KEYWORD2>
<KEYWORD2>globals</KEYWORD2>
<KEYWORD2>hasattr</KEYWORD2>
<KEYWORD2>hash</KEYWORD2>
<KEYWORD2>hex</KEYWORD2>
<KEYWORD2>id</KEYWORD2>
<KEYWORD2>input</KEYWORD2>
<KEYWORD2>int</KEYWORD2>
<KEYWORD2>intern</KEYWORD2>
<KEYWORD2>isinstance</KEYWORD2>
<KEYWORD2>issubclass</KEYWORD2>
<KEYWORD2>iter</KEYWORD2>
<KEYWORD2>len</KEYWORD2>
<KEYWORD2>list</KEYWORD2>
<KEYWORD2>locals</KEYWORD2>
<KEYWORD2>long</KEYWORD2>
<KEYWORD2>map</KEYWORD2>
<KEYWORD2>max</KEYWORD2>
<KEYWORD2>min</KEYWORD2>
<KEYWORD2>object</KEYWORD2>
<KEYWORD2>oct</KEYWORD2>
<KEYWORD2>open</KEYWORD2>
<KEYWORD2>ord</KEYWORD2>
<KEYWORD2>pow</KEYWORD2>
<KEYWORD2>property</KEYWORD2>
<KEYWORD2>range</KEYWORD2>
<KEYWORD2>raw_input</KEYWORD2>
<KEYWORD2>reduce</KEYWORD2>
<KEYWORD2>reload</KEYWORD2>
<KEYWORD2>repr</KEYWORD2>
<KEYWORD2>round</KEYWORD2>
<KEYWORD2>setattr</KEYWORD2>
<KEYWORD2>slice</KEYWORD2>
<KEYWORD2>staticmethod</KEYWORD2>
<KEYWORD2>str</KEYWORD2>
<KEYWORD2>super</KEYWORD2>
<KEYWORD2>tuple</KEYWORD2>
<KEYWORD2>type</KEYWORD2>
<KEYWORD2>unichr</KEYWORD2>
<KEYWORD2>unicode</KEYWORD2>
<KEYWORD2>vars</KEYWORD2>
<KEYWORD2>xrange</KEYWORD2>
<KEYWORD2>zip</KEYWORD2>
#@nonl
#@-node:ekr.20090121163905.152:<< builtins >>
#@+node:ekr.20090121163905.153:<< exceptions >>
<!-- exceptions -->
<KEYWORD3>ArithmeticError</KEYWORD3>
<KEYWORD3>AssertionError</KEYWORD3>
<KEYWORD3>AttributeError</KEYWORD3>
<KEYWORD3>DeprecationWarning</KEYWORD3>
<KEYWORD3>EOFError</KEYWORD3>
<KEYWORD3>EnvironmentError</KEYWORD3>
<KEYWORD3>Exception</KEYWORD3>
<KEYWORD3>FloatingPointError</KEYWORD3>
<KEYWORD3>IOError</KEYWORD3>
<KEYWORD3>ImportError</KEYWORD3>
<KEYWORD3>IndentationError</KEYWORD3>
<KEYWORD3>IndexError</KEYWORD3>
<KEYWORD3>KeyError</KEYWORD3>
<KEYWORD3>KeyboardInterrupt</KEYWORD3>
<KEYWORD3>LookupError</KEYWORD3>
<KEYWORD3>MemoryError</KEYWORD3>
<KEYWORD3>NameError</KEYWORD3>
<KEYWORD3>NotImplemented</KEYWORD3>
<KEYWORD3>NotImplementedError</KEYWORD3>
<KEYWORD3>OSError</KEYWORD3>
<KEYWORD3>OverflowError</KEYWORD3>
<KEYWORD3>OverflowWarning</KEYWORD3>
<KEYWORD3>ReferenceError</KEYWORD3>
<KEYWORD3>RuntimeError</KEYWORD3>
<KEYWORD3>RuntimeWarning</KEYWORD3>
<KEYWORD3>StandardError</KEYWORD3>
<KEYWORD3>StopIteration</KEYWORD3>
<KEYWORD3>SyntaxError</KEYWORD3>
<KEYWORD3>SyntaxWarning</KEYWORD3>
<KEYWORD3>SystemError</KEYWORD3>
<KEYWORD3>SystemExit</KEYWORD3>
<KEYWORD3>TabError</KEYWORD3>
<KEYWORD3>TypeError</KEYWORD3>
<KEYWORD3>UnboundLocalError</KEYWORD3>
<KEYWORD3>UnicodeError</KEYWORD3>
<KEYWORD3>UserWarning</KEYWORD3>
<KEYWORD3>ValueError</KEYWORD3>
<KEYWORD3>Warning</KEYWORD3>
<KEYWORD3>WindowsError</KEYWORD3>
<KEYWORD3>ZeroDivisionError</KEYWORD3>
#@nonl
#@-node:ekr.20090121163905.153:<< exceptions >>
#@+node:ekr.20090121163905.154:<< types >>
<!-- types (from types module) -->
<KEYWORD3>BufferType</KEYWORD3>
<KEYWORD3>BuiltinFunctionType</KEYWORD3>
<KEYWORD3>BuiltinMethodType</KEYWORD3>
<KEYWORD3>ClassType</KEYWORD3>
<KEYWORD3>CodeType</KEYWORD3>
<KEYWORD3>ComplexType</KEYWORD3>
<KEYWORD3>DictProxyType</KEYWORD3>
<KEYWORD3>DictType</KEYWORD3>
<KEYWORD3>DictionaryType</KEYWORD3>
<KEYWORD3>EllipsisType</KEYWORD3>
<KEYWORD3>FileType</KEYWORD3>
<KEYWORD3>FloatType</KEYWORD3>
<KEYWORD3>FrameType</KEYWORD3>
<KEYWORD3>FunctionType</KEYWORD3>
<KEYWORD3>GeneratorType</KEYWORD3>
<KEYWORD3>InstanceType</KEYWORD3>
<KEYWORD3>IntType</KEYWORD3>
<KEYWORD3>LambdaType</KEYWORD3>
<KEYWORD3>ListType</KEYWORD3>
<KEYWORD3>LongType</KEYWORD3>
<KEYWORD3>MethodType</KEYWORD3>
<KEYWORD3>ModuleType</KEYWORD3>
<KEYWORD3>NoneType</KEYWORD3>
<KEYWORD3>ObjectType</KEYWORD3>
<KEYWORD3>SliceType</KEYWORD3>
<KEYWORD3>StringType</KEYWORD3>
<KEYWORD3>StringTypes</KEYWORD3>
<KEYWORD3>TracebackType</KEYWORD3>
<KEYWORD3>TupleType</KEYWORD3>
<KEYWORD3>TypeType</KEYWORD3>
<KEYWORD3>UnboundMethodType</KEYWORD3>
<KEYWORD3>UnicodeType</KEYWORD3>
<KEYWORD3>XRangeType</KEYWORD3>

<KEYWORD3>False</KEYWORD3>
<KEYWORD3>None</KEYWORD3>
<KEYWORD3>True</KEYWORD3>

<KEYWORD3>__abs__</KEYWORD3>
<KEYWORD3>__add__</KEYWORD3>
<KEYWORD3>__all__</KEYWORD3>
<KEYWORD3>__author__</KEYWORD3>
<KEYWORD3>__bases__</KEYWORD3>
<KEYWORD3>__builtins__</KEYWORD3>
<KEYWORD3>__call__</KEYWORD3>
<KEYWORD3>__class__</KEYWORD3>
<KEYWORD3>__cmp__</KEYWORD3>
<KEYWORD3>__coerce__</KEYWORD3>
<KEYWORD3>__contains__</KEYWORD3>
<KEYWORD3>__debug__</KEYWORD3>
<KEYWORD3>__del__</KEYWORD3>
<KEYWORD3>__delattr__</KEYWORD3>
<KEYWORD3>__delitem__</KEYWORD3>
<KEYWORD3>__delslice__</KEYWORD3>
<KEYWORD3>__dict__</KEYWORD3>
<KEYWORD3>__div__</KEYWORD3>
<KEYWORD3>__divmod__</KEYWORD3>
<KEYWORD3>__doc__</KEYWORD3>
<KEYWORD3>__eq__</KEYWORD3>
<KEYWORD3>__file__</KEYWORD3>
<KEYWORD3>__float__</KEYWORD3>
<KEYWORD3>__floordiv__</KEYWORD3>
<KEYWORD3>__future__</KEYWORD3>
<KEYWORD3>__ge__</KEYWORD3>
<KEYWORD3>__getattr__</KEYWORD3>
<KEYWORD3>__getattribute__</KEYWORD3>
<KEYWORD3>__getitem__</KEYWORD3>
<KEYWORD3>__getslice__</KEYWORD3>
<KEYWORD3>__gt__</KEYWORD3>
<KEYWORD3>__hash__</KEYWORD3>
<KEYWORD3>__hex__</KEYWORD3>
<KEYWORD3>__iadd__</KEYWORD3>
<KEYWORD3>__import__</KEYWORD3>
<KEYWORD3>__imul__</KEYWORD3>
<KEYWORD3>__init__</KEYWORD3>
<KEYWORD3>__int__</KEYWORD3>
<KEYWORD3>__invert__</KEYWORD3>
<KEYWORD3>__iter__</KEYWORD3>
<KEYWORD3>__le__</KEYWORD3>
<KEYWORD3>__len__</KEYWORD3>
<KEYWORD3>__long__</KEYWORD3>
<KEYWORD3>__lshift__</KEYWORD3>
<KEYWORD3>__lt__</KEYWORD3>
<KEYWORD3>__members__</KEYWORD3>
<KEYWORD3>__metaclass__</KEYWORD3>
<KEYWORD3>__mod__</KEYWORD3>
<KEYWORD3>__mro__</KEYWORD3>
<KEYWORD3>__mul__</KEYWORD3>
<KEYWORD3>__name__</KEYWORD3>
<KEYWORD3>__ne__</KEYWORD3>
<KEYWORD3>__neg__</KEYWORD3>
<KEYWORD3>__new__</KEYWORD3>
<KEYWORD3>__nonzero__</KEYWORD3>
<KEYWORD3>__oct__</KEYWORD3>
<KEYWORD3>__or__</KEYWORD3>
<KEYWORD3>__path__</KEYWORD3>
<KEYWORD3>__pos__</KEYWORD3>
<KEYWORD3>__pow__</KEYWORD3>
<KEYWORD3>__radd__</KEYWORD3>
<KEYWORD3>__rdiv__</KEYWORD3>
<KEYWORD3>__rdivmod__</KEYWORD3>
<KEYWORD3>__reduce__</KEYWORD3>
<KEYWORD3>__repr__</KEYWORD3>
<KEYWORD3>__rfloordiv__</KEYWORD3>
<KEYWORD3>__rlshift__</KEYWORD3>
<KEYWORD3>__rmod__</KEYWORD3>
<KEYWORD3>__rmul__</KEYWORD3>
<KEYWORD3>__ror__</KEYWORD3>
<KEYWORD3>__rpow__</KEYWORD3>
<KEYWORD3>__rrshift__</KEYWORD3>
<KEYWORD3>__rsub__</KEYWORD3>
<KEYWORD3>__rtruediv__</KEYWORD3>
<KEYWORD3>__rxor__</KEYWORD3>
<KEYWORD3>__setattr__</KEYWORD3>
<KEYWORD3>__setitem__</KEYWORD3>
<KEYWORD3>__setslice__</KEYWORD3>
<KEYWORD3>__self__</KEYWORD3>
<KEYWORD3>__slots__</KEYWORD3>
<KEYWORD3>__str__</KEYWORD3>
<KEYWORD3>__sub__</KEYWORD3>
<KEYWORD3>__truediv__</KEYWORD3>
<KEYWORD3>__version__</KEYWORD3>
<KEYWORD3>__xor__</KEYWORD3>
#@nonl
#@-node:ekr.20090121163905.154:<< types >>
#@-node:ekr.20090121163905.150:<< keywords >>
#@-node:ekr.20090121163905.145:python.xml
#@-node:ekr.20090121163905.144:@test colorizer python.xml (jEdit)
#@+node:ekr.20090121163905.155:@test colorizer Python1
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.156:Python1
@language plsql

"a string"
-- reserved keywords
abort
accept,
access,
add,
admin,
after,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor
#@nonl
#@-node:ekr.20090121163905.156:Python1
#@-node:ekr.20090121163905.155:@test colorizer Python1
#@+node:ekr.20090121163905.157:@test colorizer Python2
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.158:Python2
"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.b)
        v = v.threadNext()
    return result
#@nonl
#@-node:ekr.20090121163905.158:Python2
#@-node:ekr.20090121163905.157:@test colorizer Python2
#@+node:ekr.20090121163905.159:@test colorizer r
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.160:r
@language r

x <- rnorm(10) 

vv <- function(z) return(z) 

def python_funct(uu): 
return uu
#@nonl
#@-node:ekr.20090121163905.160:r
#@-node:ekr.20090121163905.159:@test colorizer r
#@+node:ekr.20090121163905.161:@test colorizer rapidq
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.162:rapidq
' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR
#@nonl
#@-node:ekr.20090121163905.162:rapidq
#@-node:ekr.20090121163905.161:@test colorizer rapidq
#@+node:ekr.20090121163905.163:@test colorizer Rebol
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.164:Rebol
@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?
#@nonl
#@-node:ekr.20090121163905.164:Rebol
#@-node:ekr.20090121163905.163:@test colorizer Rebol
#@+node:ekr.20090121163905.165:@test colorizer rest
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.166:rest
@language rest

@ @rst-options
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=..\doc
write_intermediate_file = False
verbose=True
@c

. Links used in this document...

.. _`Pmw`:                  http://pmw.sourceforge.net/
.. _run:                    `Running Leo`_

.. WARNING: image targets may not have upper case letters!

.. |back| image:: arrow_lt.gif
    :target: FAQ.html

.. |leo| image:: leo.gif
    :target: front.html

.. |next| image:: arrow_rt.gif
    :target: intro.html

|back| |leo| |next|

###########################
Chapter 1: Installing Leo
###########################

This chapter tells how to install and run Leo.

**Important**:

If you have *any* problems installing Leo,
please ask for help on Leo's help forum:

.. contents::

**Windows**
    If you have `associated .leo files with Leo`_ you may run Leo by double-clicking any .leo file.
    You can also use a batch file.
    Put the following .bat file in c:\\Windows::

        cd c:\prog\LeoCVS\leo
        c:\python22\python c:\prog\LeoCVS\leo\leo.py %1

-   Download the latest version of Leo from `Leo's download page`_.

-   In Windows 2K or XP, go to ``Start->Settings->Control panel``, open the ``Folder Options`` tab.

    **Warning**: When building Tcl on Linux, do **not** specify
    "--enable-threads".
    Only use Tcl with the default "threads not enabled" case.

-------------

|back| |leo| |next|
#@nonl
#@-node:ekr.20090121163905.166:rest
#@-node:ekr.20090121163905.165:@test colorizer rest
#@+node:ekr.20090121163905.167:@test colorizer shell
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.168:shell
# New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait
#@nonl
#@-node:ekr.20090121163905.168:shell
#@-node:ekr.20090121163905.167:@test colorizer shell
#@+node:ekr.20090121163905.169:@test colorizer shellscript
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.170:shellscript
@language shellscript

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait
#@nonl
#@-node:ekr.20090121163905.170:shellscript
#@-node:ekr.20090121163905.169:@test colorizer shellscript
#@+node:ekr.20090121163905.171:@test colorizer tex.xml (jEdit)
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.172:tex.xml
@language html

<!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ -->

<?xml version="1.0"?>

<!DOCTYPE MODE SYSTEM "xmode.dtd">

<MODE>
    <PROPS>
        <PROPERTY NAME="lineComment" VALUE="%" />
    </PROPS>

    <RULES>
        << general rules >>
    </RULES>

    <RULES SET="MATH" DEFAULT="MARKUP">
        << math rules >>
    </RULES>
</MODE>
#@nonl
#@+node:ekr.20090121163905.173:<< general rules >>
<!-- $$...$$ -->
<SPAN TYPE="MARKUP" DELEGATE="MATH">
    <BEGIN>$$</BEGIN>
    <END>$$</END>
</SPAN>

<!-- $...$ -->
<SPAN TYPE="MARKUP" DELEGATE="MATH">
    <BEGIN>$</BEGIN>
    <END>$</END>
</SPAN>

<!-- \[...\] (LaTeX math mode) -->
<SPAN TYPE="MARKUP" DELEGATE="MATH">
    <BEGIN>\[</BEGIN>
    <END>\]</END>
</SPAN>

<!-- some commands must be handled specially -->
<SEQ TYPE="KEYWORD1">\$</SEQ>
<SEQ TYPE="KEYWORD1">\\</SEQ>
<SEQ TYPE="KEYWORD1">\%</SEQ>

<!-- \... commands -->
<MARK_FOLLOWING TYPE="KEYWORD1">\</MARK_FOLLOWING>

<!-- comments -->
<EOL_SPAN TYPE="COMMENT1">%</EOL_SPAN>

<!-- word separators -->
<SEQ TYPE="OPERATOR">{</SEQ>
<SEQ TYPE="OPERATOR">}</SEQ>
<SEQ TYPE="OPERATOR">[</SEQ>
<SEQ TYPE="OPERATOR">]</SEQ>
#@nonl
#@-node:ekr.20090121163905.173:<< general rules >>
#@+node:ekr.20090121163905.174:<< math rules >>
<!-- some commands must be handled specially -->
<SEQ TYPE="KEYWORD3">\$</SEQ>
<SEQ TYPE="KEYWORD3">\\</SEQ>
<SEQ TYPE="KEYWORD3">\%</SEQ>

<!-- \... commands -->
<MARK_FOLLOWING TYPE="KEYWORD3">\</MARK_FOLLOWING>

<!-- word separators -->
<SEQ TYPE="KEYWORD2">)</SEQ>
<SEQ TYPE="KEYWORD2">(</SEQ>
<SEQ TYPE="KEYWORD2">{</SEQ>
<SEQ TYPE="KEYWORD2">}</SEQ>
<SEQ TYPE="KEYWORD2">[</SEQ>
<SEQ TYPE="KEYWORD2">]</SEQ>
<SEQ TYPE="KEYWORD2">=</SEQ>
<SEQ TYPE="KEYWORD2">!</SEQ>
<SEQ TYPE="KEYWORD2">+</SEQ>
<SEQ TYPE="KEYWORD2">-</SEQ>
<SEQ TYPE="KEYWORD2">/</SEQ>
<SEQ TYPE="KEYWORD2">*</SEQ>
<SEQ TYPE="KEYWORD2">&gt;</SEQ>
<SEQ TYPE="KEYWORD2">&lt;</SEQ>
<SEQ TYPE="KEYWORD2">&amp;</SEQ>
<SEQ TYPE="KEYWORD2">|</SEQ>
<SEQ TYPE="KEYWORD2">^</SEQ>
<SEQ TYPE="KEYWORD2">~</SEQ>
<SEQ TYPE="KEYWORD2">.</SEQ>
<SEQ TYPE="KEYWORD2">,</SEQ>
<SEQ TYPE="KEYWORD2">;</SEQ>
<SEQ TYPE="KEYWORD2">?</SEQ>
<SEQ TYPE="KEYWORD2">:</SEQ>
<SEQ TYPE="KEYWORD2">'</SEQ>
<SEQ TYPE="KEYWORD2">"</SEQ>
<SEQ TYPE="KEYWORD2">`</SEQ>

<!-- comments -->
<EOL_SPAN TYPE="COMMENT1">%</EOL_SPAN>
#@nonl
#@-node:ekr.20090121163905.174:<< math rules >>
#@-node:ekr.20090121163905.172:tex.xml
#@-node:ekr.20090121163905.171:@test colorizer tex.xml (jEdit)
#@+node:ekr.20090121163905.175:@test colorizer wikiTest1
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.176:wikiTest1
# both color_markup & add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

print g.app().loadDir
#@nonl
#@-node:ekr.20090121163905.176:wikiTest1
#@-node:ekr.20090121163905.175:@test colorizer wikiTest1
#@+node:ekr.20090121163905.177:@test colorizer wikiTest2
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.178:wikiTest2
# both color_markup & add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

print g.app().loadDir
#@-node:ekr.20090121163905.178:wikiTest2
#@-node:ekr.20090121163905.177:@test colorizer wikiTest2
#@+node:ekr.20090121163905.179:@test colorizer wikiTest3
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.180:wikiTest3
# both color_markup & add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass
#@nonl
#@-node:ekr.20090121163905.180:wikiTest3
#@-node:ekr.20090121163905.179:@test colorizer wikiTest3
#@+node:ekr.20090121163905.181:@test leoColor.doNowebSecRef
<< test defined >>
#@nonl
#@+node:ekr.20090121163905.182:<< test defined >>
pass
#@nonl
#@-node:ekr.20090121163905.182:<< test defined >>
#@-node:ekr.20090121163905.181:@test leoColor.doNowebSecRef
#@+node:ekr.20090121163905.183:@test python keywords (new colorizer)
try:
    mode = c.frame.body.colorizer.modes.get('python')
    mode.keywords['as'] = 1 # append the keyword, colorize with 'keyword1' tag.
except AttributeError:
    pass # modes only exists for new colorizer.
#@nonl
#@-node:ekr.20090121163905.183:@test python keywords (new colorizer)
#@+node:ekr.20090121163905.184:@test scanColorDirectives
# This will work regardless of where this method is.
@language python

# print 'c.frame.body.colorizer',c.frame.body.colorizer
language = c.frame.body.colorizer.scanColorDirectives(p)
assert language == 'python','got:%s' % language
#@-node:ekr.20090121163905.184:@test scanColorDirectives
#@+node:ekr.20090121163905.185:@test vbscript
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)
assert val=="ok", "colorizer test failed: %s" % p.h
#@+node:ekr.20090121163905.186:vbscript
@language vbscript

if
IF
#@-node:ekr.20090121163905.186:vbscript
#@-node:ekr.20090121163905.185:@test vbscript
#@+node:ekr.20090121163905.187:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoColor tests')
#@nonl
#@-node:ekr.20090121163905.187:@test zz restore the screen
#@-node:ekr.20090121163905.106:leoColor
#@+node:ekr.20090121163905.188:leoCommands
#@+node:ekr.20090121163905.189: Check outline
#@+node:ekr.20090121163905.190:@test CheckOutline
errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.

assert errors == 0, "Check Outline reported %d errors" % errors
#@nonl
#@-node:ekr.20090121163905.190:@test CheckOutline
#@+node:ekr.20090121163905.191:@test pretty printing a docstring
test1 = p.firstChild()
test2 = p.firstChild().next()

c.prettyPrintPythonCode(p=test2,dump=False)

assert(test2.b==test1.b)
#@nonl
#@+node:ekr.20090121163905.192:Original
"""
line 1
line 2
line 3
"""
#@nonl
#@-node:ekr.20090121163905.192:Original
#@+node:ekr.20090121163905.193:Test
"""
line 1
line 2
line 3
"""
#@nonl
#@-node:ekr.20090121163905.193:Test
#@-node:ekr.20090121163905.191:@test pretty printing a docstring
#@+node:ekr.20090121163905.194:@test Pretty Print command
@language python 

import leo.core.leoTest as leoTest

u = leoTest.testUtils(c)
dump = False 
all = False 

if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = u.findNodeInTree(p,"tempNode")
    c.setBodyString(temp,"")
    before = u.findNodeInTree(p,"before")
    after = u.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.b)
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.b == after.b,"Pretty Print Test failed"
#@nonl
#@+node:ekr.20090121163905.195:tempNode
@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("Ä á Û")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
#@nonl
#@-node:ekr.20090121163905.195:tempNode
#@+node:ekr.20090121163905.196:before
@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a==3:
        g.pr("Ä á Û")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
#@nonl
#@-node:ekr.20090121163905.196:before
#@+node:ekr.20090121163905.197:after
@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        g.pr("Ä á Û")

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others
#@nonl
#@-node:ekr.20090121163905.197:after
#@-node:ekr.20090121163905.194:@test Pretty Print command
#@-node:ekr.20090121163905.189: Check outline
#@+node:ekr.20090121163905.198: Mark commands
#@+node:ekr.20090121163905.199:@test markAllAtFileNodesDirty
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markAllAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.199:@test markAllAtFileNodesDirty
#@+node:ekr.20090121163905.200:@test markAtFileNodesDirty
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.200:@test markAtFileNodesDirty
#@+node:ekr.20090121163905.201:@test markChangedHeadlines
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markChangedHeadlines()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.201:@test markChangedHeadlines
#@+node:ekr.20090121163905.202:@test markChangedRoots
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markChangedRoots()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.202:@test markChangedRoots
#@clone 2
#@+node:ekr.20090121163905.203:@test markClones
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markClones()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.203:@test markClones
#@+node:ekr.20090121163905.204:@test markHeadline
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markHeadline()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.204:@test markHeadline
#@+node:ekr.20090121163905.205:@test markSubheads
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markSubheads()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@+node:ekr.20090121163905.206:child 1
pass
#@nonl
#@-node:ekr.20090121163905.206:child 1
#@+node:ekr.20090121163905.207:child 2
pass
#@nonl
#@-node:ekr.20090121163905.207:child 2
#@-node:ekr.20090121163905.205:@test markSubheads
#@+node:ekr.20090121163905.208:@test unmarkAll
marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.unmarkAll()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                c.setMarked(p)
        else:
            if p.isMarked():
                c.clearMarked(p)

if not ok: raise
#@nonl
#@-node:ekr.20090121163905.208:@test unmarkAll
#@-node:ekr.20090121163905.198: Mark commands
#@+node:ekr.20090121163905.209: Reformat Paragraph tests
@ Rewritten by EKR.  April 17, 2005.

Each data node must have three children:

- a "before" node
- an "after" node
- a "tempNode" node

A parent to before and after nodes will contain pagewidth and language formatting directives.
#@nonl
#@+node:ekr.20090121163905.210:@test noTrailingNewline (pass)
# Wrap a long line, no trailing newline.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,2,24)
#@nonl
#@+node:ekr.20090121163905.211:data
@language plain
@pagewidth 40
@tabwidth 8

#@+node:ekr.20090121163905.212:tempNode
#@-node:ekr.20090121163905.212:tempNode
#@+node:ekr.20090121163905.213:before
This line is over forty characters long, at least it seems to be.
#@nonl
#@-node:ekr.20090121163905.213:before
#@+node:ekr.20090121163905.214:after
This line is over forty characters long,
at least it seems to be.
#@nonl
#@-node:ekr.20090121163905.214:after
#@-node:ekr.20090121163905.211:data
#@-node:ekr.20090121163905.210:@test noTrailingNewline (pass)
#@+node:ekr.20090121163905.215:@test trailingNewline (pass)
# Wrap a long line, with trailing newline.

import leo.core.leoTest as leoTest

# Wrap a long line, no trailing newline.
leoTest.singleParagraphTest(c,p,3,0)
#@nonl
#@+node:ekr.20090121163905.216:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.217:tempNode
#@-node:ekr.20090121163905.217:tempNode
#@+node:ekr.20090121163905.218:before
This line is over forty characters long, at least it seems to be.
#@-node:ekr.20090121163905.218:before
#@+node:ekr.20090121163905.219:after
This line is over forty characters long,
at least it seems to be.
#@-node:ekr.20090121163905.219:after
#@-node:ekr.20090121163905.216:data
#@-node:ekr.20090121163905.215:@test trailingNewline (pass)
#@+node:ekr.20090121163905.220:@test mixedLineLengths
# Wrap a long line and some short ones.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,4,10)
#@nonl
#@+node:ekr.20090121163905.221:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.222:tempNode
#@-node:ekr.20090121163905.222:tempNode
#@+node:ekr.20090121163905.223:before
This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.
#@nonl
#@-node:ekr.20090121163905.223:before
#@+node:ekr.20090121163905.224:after
This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.
#@nonl
#@-node:ekr.20090121163905.224:after
#@-node:ekr.20090121163905.221:data
#@-node:ekr.20090121163905.220:@test mixedLineLengths
#@+node:ekr.20090121163905.225:@test mixedLinesWithLeadingWS
# Wrap a paragraph with interior lines that have leading white space.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,4,12)
#@nonl
#@+node:ekr.20090121163905.226:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.227:tempNode
#@-node:ekr.20090121163905.227:tempNode
#@+node:ekr.20090121163905.228:before
This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.
#@nonl
#@-node:ekr.20090121163905.228:before
#@+node:ekr.20090121163905.229:after
This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.
#@nonl
#@-node:ekr.20090121163905.229:after
#@-node:ekr.20090121163905.226:data
#@-node:ekr.20090121163905.225:@test mixedLinesWithLeadingWS
#@+node:ekr.20090121163905.230:@test noChangeRequired
# No wrapping required, so don't change a thing.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,1,28)
#@+node:ekr.20090121163905.231:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.232:tempNode
#@-node:ekr.20090121163905.232:tempNode
#@+node:ekr.20090121163905.233:before
This line is under 40 chars.
#@nonl
#@-node:ekr.20090121163905.233:before
#@+node:ekr.20090121163905.234:after
This line is under 40 chars.
#@nonl
#@-node:ekr.20090121163905.234:after
#@-node:ekr.20090121163905.231:data
#@-node:ekr.20090121163905.230:@test noChangeRequired
#@+node:ekr.20090121163905.235:@test honorLeadingWS
# Honor the first line's leading whitespace.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,16)
#@+node:ekr.20090121163905.236:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.237:tempNode
#@-node:ekr.20090121163905.237:tempNode
#@+node:ekr.20090121163905.238:before
   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.
#@nonl
#@-node:ekr.20090121163905.238:before
#@+node:ekr.20090121163905.239:after
   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.
#@nonl
#@-node:ekr.20090121163905.239:after
#@-node:ekr.20090121163905.236:data
#@-node:ekr.20090121163905.235:@test honorLeadingWS
#@+node:ekr.20090121163905.240:@test honorLeadingWSVar1
# Honor the first and second line's leading whitespace.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,16)
#@+node:ekr.20090121163905.241:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.242:tempNode
#@-node:ekr.20090121163905.242:tempNode
#@+node:ekr.20090121163905.243:before
   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.
#@nonl
#@-node:ekr.20090121163905.243:before
#@+node:ekr.20090121163905.244:after
   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.
#@nonl
#@-node:ekr.20090121163905.244:after
#@-node:ekr.20090121163905.241:data
#@-node:ekr.20090121163905.240:@test honorLeadingWSVar1
#@+node:ekr.20090121163905.245:@test simpleHangingIndent
# Single paragraph, hanging indentation.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,8)
#@+node:ekr.20090121163905.246:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.247:tempNode
#@-node:ekr.20090121163905.247:tempNode
#@+node:ekr.20090121163905.248:before
Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.
#@nonl
#@-node:ekr.20090121163905.248:before
#@+node:ekr.20090121163905.249:after
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.
#@nonl
#@-node:ekr.20090121163905.249:after
#@-node:ekr.20090121163905.246:data
#@-node:ekr.20090121163905.245:@test simpleHangingIndent
#@+node:ekr.20090121163905.250:@test testSimpleHangingIndentVar1
# Single paragraph, hanging indentation with other indentation beyond line 2.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,8)
#@nonl
#@+node:ekr.20090121163905.251:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.252:tempNode
#@-node:ekr.20090121163905.252:tempNode
#@+node:ekr.20090121163905.253:before
Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.
#@nonl
#@-node:ekr.20090121163905.253:before
#@+node:ekr.20090121163905.254:after
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.
#@nonl
#@-node:ekr.20090121163905.254:after
#@-node:ekr.20090121163905.251:data
#@-node:ekr.20090121163905.250:@test testSimpleHangingIndentVar1
#@+node:ekr.20090121163905.255:@test simpleHangingIndentVar2
# Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.

import leo.core.leoTest as leoTest

leoTest.singleParagraphTest(c,p,5,8)
#@nonl
#@+node:ekr.20090121163905.256:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.257:tempNode
#@-node:ekr.20090121163905.257:tempNode
#@+node:ekr.20090121163905.258:before
Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.
#@nonl
#@-node:ekr.20090121163905.258:before
#@+node:ekr.20090121163905.259:after
Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.
#@nonl
#@-node:ekr.20090121163905.259:after
#@-node:ekr.20090121163905.256:data
#@-node:ekr.20090121163905.255:@test simpleHangingIndentVar2
#@+node:ekr.20090121163905.260:@test multiParagraphTest
# Multiple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.

import leo.core.leoTest as leoTest

leoTest.multiParagraphTest(c,p)
#@nonl
#@+node:ekr.20090121163905.261:data
@language plain
@pagewidth 40
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.262:tempNode
#@-node:ekr.20090121163905.262:tempNode
#@+node:ekr.20090121163905.263:before
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.263:before
#@+node:ekr.20090121163905.264:after
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?
#@nonl
#@-node:ekr.20090121163905.264:after
#@-node:ekr.20090121163905.261:data
#@-node:ekr.20090121163905.260:@test multiParagraphTest
#@+node:ekr.20090121163905.265:@test multiParagraphWithListTest
# A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.
# Cursor should move to next paragraph after formatting a paragraph.

import leo.core.leoTest as leoTest

leoTest.multiParagraphWithListTest(c,p)
#@nonl
#@+node:ekr.20090121163905.266:data
@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

#@+node:ekr.20090121163905.267:tempNode
#@-node:ekr.20090121163905.267:tempNode
#@+node:ekr.20090121163905.268:before
This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
#@nonl
#@-node:ekr.20090121163905.268:before
#@+node:ekr.20090121163905.269:after
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
#@nonl
#@-node:ekr.20090121163905.269:after
#@-node:ekr.20090121163905.266:data
#@-node:ekr.20090121163905.265:@test multiParagraphWithListTest
#@+node:ekr.20090121163905.270:@test leadingWSOnEmptyLinesTest
@
Ran into a problem with the wrapping eating blank lines that delimit paragraphs
if those blank lines have any leading whitespace. This test is to make sure that
still works.

If you "show invisibles" you'll see the leading whitespace in the blank lines --
which is different from the "testMultiParagraphWithList" test.
@c

import leo.core.leoTest as leoTest

leoTest.leadingWSOnEmptyLinesTest(c,p)
#@nonl
#@+node:ekr.20090121163905.271:data
@language plain
@pagewidth 40
@tabwidth 8

#@+node:ekr.20090121163905.272:tempNode
#@-node:ekr.20090121163905.272:tempNode
#@+node:ekr.20090121163905.273:before
This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.
#@nonl
#@-node:ekr.20090121163905.273:before
#@+node:ekr.20090121163905.274:after
This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.
#@nonl
#@-node:ekr.20090121163905.274:after
#@-node:ekr.20090121163905.271:data
#@-node:ekr.20090121163905.270:@test leadingWSOnEmptyLinesTest
#@+node:ekr.20090121163905.275:@test directiveBreaksParagraphTest
import leo.core.leoTest as leoTest

leoTest.directiveBreaksParagraphTest(c,p)
#@nonl
#@+node:ekr.20090121163905.276:data
@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
#@+node:ekr.20090121163905.277:tempNode
#@-node:ekr.20090121163905.277:tempNode
#@+node:ekr.20090121163905.278:before
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.278:before
#@+node:ekr.20090121163905.279:after
Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?
#@nonl
#@-node:ekr.20090121163905.279:after
#@-node:ekr.20090121163905.276:data
#@-node:ekr.20090121163905.275:@test directiveBreaksParagraphTest
#@-node:ekr.20090121163905.209: Reformat Paragraph tests
#@+node:ekr.20090121163905.281:@@test c.checkFileTimeStamp & c.setFileTimeStamp
# Disabled because modifying errorTest.py creates annoying bzr conflicts.
import os

path = g.os_path_finalize_join(g.app.testDir,'unittest','errorTest.py')
assert g.os_path_exists(path),path
timeStamp = c.timeStampDict.get(path)
val = c.checkFileTimeStamp(path)
assert val == True

f = open(path)
s = f.read()
lines = g.splitLines(s)
result = [] ; found = False
tag = '# timestamp:'
for line in lines:
    if line.startswith(tag):
        timeStamp = os.path.getmtime(path)
        result.append('%s %s\n' % (tag,timeStamp))
        found = True
    else:
        result.append(line)
f.close()

assert found,' no line starts with "%s"' % tag

f = open(path,'w')
f.write(''.join(result))
f.close()

timeStamp2 = os.path.getmtime(path)
assert timeStamp != timeStamp2
val = c.checkFileTimeStamp(path)
assert not val,repr(val)
c.setFileTimeStamp(path)
val = c.checkFileTimeStamp(path)
assert val,repr(val)
#@-node:ekr.20090121163905.281:@@test c.checkFileTimeStamp & c.setFileTimeStamp
#@+node:ekr.20090121163905.280:@test c.contractAllHeadlines
c.contractAllHeadlines()
p = c.rootPosition()
while p.hasNext():
    p.moveToNext()
c.selectPosition(p)
#@-node:ekr.20090121163905.280:@test c.contractAllHeadlines
#@+node:ekr.20090121163905.282:@test c.findMatchingBracket
w = c.frame.body.bodyCtrl
s = w.getAllText()

try:
    pattern = '(abc)'
    for index,result in (
        (len(s)+len(pattern),'('),
        (len(s)+len(pattern)-4,')'),
    ):
        w.setAllText(s)
        p.setBodyString(s)
        w.setInsertPoint('end')
        w.insert('end',pattern)
        w.setInsertPoint(index)
        c.findMatchingBracket()
        ins = w.getInsertPoint()
        s2 = w.getAllText()
        ins = min(ins,len(s2)-1)
        assert s2[ins] == result,'Expected: %s, got: %s' % (repr(result),repr(s2[ins]))
finally:
    w.setAllText(s)
    p.setBodyString = s
    c.recolor()


# end:
#@nonl
#@-node:ekr.20090121163905.282:@test c.findMatchingBracket
#@+node:ekr.20090121163905.283:@test c.getTime
assert type(c.getTime()) == type('')
#@nonl
#@-node:ekr.20090121163905.283:@test c.getTime
#@+node:ekr.20090121163905.284:@test c.insertBodyTime
w = c.frame.body.bodyCtrl
s = w.getAllText()

try:
    w.setInsertPoint(len(s))
    c.insertBodyTime()
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # c.recolor()

# end:
#@nonl
#@-node:ekr.20090121163905.284:@test c.insertBodyTime
#@+node:ekr.20090113083258.2:@test c.vnode2position
trace = True ; verbose = False
if trace and verbose: print '=' * 20

count = 0
for p in c.allNodes_iter():

    count += 1
    p2 = c.vnode2position(p.v)

    if trace and verbose: print p2.level(), p2.h

    # We can *not* assert that p == p2.
    assert p2.v == p.v,'p2.v: %s, p.v: %s' % (p2.v,v)
    assert c.positionExists(p2),p2

if trace: print 'pass. tested %s positions' % count
#@-node:ekr.20090113083258.2:@test c.vnode2position
#@+node:ekr.20090121163905.285:@test changing headline marks descendent @thin nodes dirty
# Make sure that changing this headline marks descendant @thin nodes dirty.
h = p.h

try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.h == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    c.setHeadString(p,"changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    try:
        c.setHeadString(p,h)
        c.setHeadString(child,"bogus")
        p.clearDirty()
        child.clearDirty()
    finally: pass

c.redraw()
#@+node:ekr.20090121163905.286:bogus
test
#@nonl
#@-node:ekr.20090121163905.286:bogus
#@-node:ekr.20090121163905.285:@test changing headline marks descendent @thin nodes dirty
#@+node:ekr.20090121163905.287:@test contract all
c.contractAllHeadlines()
#@nonl
#@-node:ekr.20090121163905.287:@test contract all
#@+node:ekr.20090121163905.288:@test hoist with no children
c.hoist()
c.dehoist()
#@nonl
#@-node:ekr.20090121163905.288:@test hoist with no children
#@+node:ekr.20090121163905.289:@test illegal clone demote LOOPS
# Remove any previous children.
while p.hasChildren():
    p.firstChild().doDelete()
# Create two cloned children.
c.selectPosition(p)
c.insertHeadline()
p2 = c.currentPosition()
p2.moveToFirstChildOf(p)
p2.setHeadString('aClone')
c.selectPosition(p2)
c.clone()
assert 2 == p.numberOfChildren()

if 1:
    try:
        # Select the first clone and demote (it should be illegal)
        c.selectPosition(p2)
        c.demote() # This should do nothing.
        assert g.app.unitTestDict.get('checkMoveWithParentWithWarning'),'fail 1'
        assert 0 == c.checkOutline(event=None,verbose=False,unittest=True,full=True), 'fail 2'
        assert 2 == p.numberOfChildren(), 'fail 3'
        # Delete the children, but only if there are no errors.
        while p.hasChildren():
            p.firstChild().doDelete()
    finally:
        c.redraw()
#@-node:ekr.20090121163905.289:@test illegal clone demote LOOPS
#@+node:ekr.20090121163905.290:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoCommands tests')
#@nonl
#@-node:ekr.20090121163905.290:@test zz restore the screen
#@-node:ekr.20090121163905.188:leoCommands
#@+node:ekr.20090121163905.291:leoConfig
#@+node:ekr.20090121163905.292:@@test ifgui
guiname = g.app.gui.guiName()

tkinter = c.config.getBool('test_tkinter_setting')
wx      = c.config.getBool('test_wxWindows_setting')

print(guiname)

if guiname == 'tkinter':
    assert(tkinter)
    assert(not wx)

if guiname == 'wxWindows':
    assert(not tkinter)
    assert(wx)
#@nonl
#@-node:ekr.20090121163905.292:@@test ifgui
#@+node:ekr.20090121163905.293:@test global settings
w = g.app.config.get(None,'global_setting_for_unit_tests','int')

assert w == 132
#@nonl
#@-node:ekr.20090121163905.293:@test global settings
#@+node:ekr.20090121163905.294:@test ifplatform
import sys

win32  = c.config.getBool('test_win32_setting')
darwin = c.config.getBool('test_darwin_setting')

if sys.platform == 'win32':
    assert(win32)
    assert(not darwin)

elif sys.platform== 'darwin':
    assert(win32)
    assert(not darwin)
#@-node:ekr.20090121163905.294:@test ifplatform
#@+node:ekr.20090121163905.295:@test local settings (c.page_width)
# g.es(c.page_width)

assert c.page_width == 80
#@nonl
#@-node:ekr.20090121163905.295:@test local settings (c.page_width)
#@+node:ekr.20090121163905.296:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoConfig tests')
#@nonl
#@-node:ekr.20090121163905.296:@test zz restore the screen
#@-node:ekr.20090121163905.291:leoConfig
#@+node:ekr.20090121163905.297:leoDialogs
#@+node:ekr.20090121163905.298:@test ctors for all dialogs
# For some reason these don't select the dialog properly when run as a script.
# However, the main reason for the tests is to make sure the ctors don't crash.
# Also, for unit testing the value of c doesn't matter.

oldGui = g.app.gui ; guis = [g.app.gui]

import leo.core.leoGui as leoGui
guis.append(leoGui.unitTestGui())

for gui in guis:
    gui.runAboutLeoDialog(c,'version','copyright','url','email')
    gui.runAskLeoIDDialog()
    gui.runAskOkDialog(c,'title','message')
    gui.runAskOkCancelNumberDialog(c,'title','message')
    gui.runAskOkCancelStringDialog(c,'title','message')
    gui.runAskYesNoDialog(c,'title','message')
    gui.runAskYesNoCancelDialog(c,'title','message')
    # gui.runCompareDialog(c) # Removed.

g.app.gui = oldGui
#@nonl
#@-node:ekr.20090121163905.298:@test ctors for all dialogs
#@-node:ekr.20090121163905.297:leoDialogs
#@+node:ekr.20090121163905.299:leoEditCommands
#@+node:ekr.20090121163905.300:goto-line-number tests
@ Notes

1. I removed the old goto-line-number command.  It's too awful too use a dialog to get the line number.

2. c.gotoLineNumber is called in just two ways:

- from goto-global-line with root=None,lines=None and scriptFile = False.
- from c.goToScriptLineNumber with valid root and lines and scriptFile = True.
#@+node:ekr.20090121164439.16359:@unit-tests
# The run-unit-tests commands copy all descendants
# of this node to dynamicUnitTest.leo.
#@nonl
#@+node:ekr.20090121164439.16379:goto-line-number tests: original files
#@+node:ekr.20090121164439.16380:@auto ../test/unittest/at-auto-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20090121164439.16381:at_auto_child
# The name of this node comes from the name of this function!
def at_auto_child():
    pass
#@-node:ekr.20090121164439.16381:at_auto_child
#@-node:ekr.20090121164439.16380:@auto ../test/unittest/at-auto-line-number-test.py
#@+node:ekr.20090121164439.16382:@file ../test/unittest/at-file-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20090121164439.16383:at-file-child
def child():
    pass
#@-node:ekr.20090121164439.16383:at-file-child
#@-node:ekr.20090121164439.16382:@file ../test/unittest/at-file-line-number-test.py
#@+node:ekr.20090121164439.16384:@thin ../test/unittest/at-thin-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20090121164439.16385:at-thin-child
def child():
    pass
#@-node:ekr.20090121164439.16385:at-thin-child
#@-node:ekr.20090121164439.16384:@thin ../test/unittest/at-thin-line-number-test.py
#@+node:ekr.20090121164439.16386:@shadow ../test/unittest/at-shadow-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20090121164439.16387:child
def child():
    pass
#@-node:ekr.20090121164439.16387:child
#@-node:ekr.20090121164439.16386:@shadow ../test/unittest/at-shadow-line-number-test.py
#@+node:ekr.20090121164439.16388:@nosent ../test/unittest/at-nosent-line-number-test.py
@language python
@tabwidth -4
@others
#@+node:ekr.20090121164439.16389:at-nosent-child
def child():
    pass

#
#
#
#
#
#
#@nonl
#@-node:ekr.20090121164439.16389:at-nosent-child
#@-node:ekr.20090121164439.16388:@nosent ../test/unittest/at-nosent-line-number-test.py
#@-node:ekr.20090121164439.16379:goto-line-number tests: original files
#@+node:ekr.20090121163905.313:goto-line-number tests: clones
# Can not clone @auto children!
#@nonl
#@+node:ekr.20090121164439.16389:at-nosent-child
def child():
    pass

#
#
#
#
#
#
#@nonl
#@-node:ekr.20090121164439.16389:at-nosent-child
#@+node:ekr.20090121164439.16385:at-thin-child
def child():
    pass
#@-node:ekr.20090121164439.16385:at-thin-child
#@+node:ekr.20090121164439.16383:at-file-child
def child():
    pass
#@-node:ekr.20090121164439.16383:at-file-child
#@-node:ekr.20090121163905.313:goto-line-number tests: clones
#@-node:ekr.20090121164439.16359:@unit-tests
#@+node:ekr.20090121163905.314:Tests with @auto as the root
#@+node:ekr.20090121163905.315:@test goto_countlines n = 3
h = '@auto ../test/unittest/at-auto-line-number-test.py'
target = g.findNodeAnywhere(c,h)
assert target,'not found: %s' % h

p,n,found = c.goto_countLines (target,3)
assert found,found
assert n == 3,n
assert p.h == 'at_auto_child',p.h
#@-node:ekr.20090121163905.315:@test goto_countlines n = 3
#@+node:ekr.20090121163905.316:@test goto_countlines n = 20
h = '@auto ../test/unittest/at-auto-line-number-test.py'
root = g.findNodeAnywhere(c,h)
assert root,'not found: %s' % h

p,n,found = c.goto_countLines (root,20)
assert not found
assert p.h == 'at_auto_child'
# print ('p:%s, n:%s, found: %s' % (p,n,found))
#@nonl
#@-node:ekr.20090121163905.316:@test goto_countlines n = 20
#@+node:ekr.20090121163905.317:@test goto_setup n = 3
h = '@auto ../test/unittest/at-auto-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1,'not found: %s' % h
assert root1.isAnyAtFileNode()

fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=3,p=root1)
assert isRaw,isRaw
assert fileName == h[6:],fileName
assert root == root1

if 0:
    print ('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
        root and root.h,isRaw,n,len(lines)))
#@nonl
#@-node:ekr.20090121163905.317:@test goto_setup n = 3
#@+node:ekr.20090121163905.318:@test goto_setup with scriptData
h = '@auto ../test/unittest/at-auto-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1,'not found: %s' % h
assert root1.isAnyAtFileNode()

scriptData = {'p':root1.copy(),'lines':['a','b','c']}
fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=2,scriptData=scriptData)

assert isRaw,isRaw
assert fileName == h[6:],fileName
assert root == root1,root
assert n == 2,n

if 0:
    print ('root:%s, n:%s, len(lines): %s' % (
        root and root.h,n,len(lines)))
#@nonl
#@-node:ekr.20090121163905.318:@test goto_setup with scriptData
#@-node:ekr.20090121163905.314:Tests with @auto as the root
#@+node:ekr.20090121163905.319:Tests with @file as the root
#@+node:ekr.20090121163905.320:@test goto_findGnx
h = '@file ../test/unittest/at-file-line-number-test.py'
target = g.findNodeAnywhere(c,h)
assert target,'not found: %s' % h

gnx = g.app.nodeIndices.toString(target.v.t.fileIndex)
assert gnx,'no gnx'

p,found = c.goto_findGnx(target,gnx,h)
assert found,found
assert p == target,'\np:     %s\ntarget:%s' % (p,target)
#@-node:ekr.20090121163905.320:@test goto_findGnx
#@+node:ekr.20090121163905.321:@test goto_findVnode
h = '@file ../test/unittest/at-file-line-number-test.py'
target = g.findNodeAnywhere(c,h)
assert target,'not found: %s' % h

n = 2
fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p=target)
assert fileName == h[6:]
# print('lines\n%s' % g.listToString(lines))
assert root == target

vnodeName,gnx,offset,delim = c.goto_findVnode (root,lines,n,ignoreSentinels)

assert lines,'no lines'
assert not gnx,repr(gnx)
assert offset is not None,repr(offset)
assert vnodeName,repr(vnodeName)

# print('vnodeName',vnodeName,'gnx',gnx,'offset',offset,'delim',delim)

#@-node:ekr.20090121163905.321:@test goto_findVnode
#@-node:ekr.20090121163905.319:Tests with @file as the root
#@+node:ekr.20090121163905.322:Tests with @shadow as the root
#@+node:ekr.20090121163905.323:@test goto_setup n = 3 (@shadow)
h = '@shadow ../test/unittest/at-shadow-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1,'not found: %s' % h
assert root1.isAnyAtFileNode()

fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=6,p=root1)
assert not isRaw,isRaw
assert fileName == h[8:],fileName
assert root == root1

if 0:
    print ('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
        root and root.h,isRaw,n,len(lines)))
#@nonl
#@-node:ekr.20090121163905.323:@test goto_setup n = 3 (@shadow)
#@-node:ekr.20090121163905.322:Tests with @shadow as the root
#@+node:ekr.20090121163905.324:Tests with @nosent as the root
#@+node:ekr.20090121163905.325:@test goto_setup n = 3 (@nosent)
h = '@nosent ../test/unittest/at-nosent-line-number-test.py'
root1 = g.findNodeAnywhere(c,h)
assert root1,'not found: %s' % h
assert root1.isAnyAtFileNode()

fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n=6,p=root1)
assert isRaw,isRaw
assert ignoreSentinels,ignoreSentinels
assert fileName == h[8:],fileName
assert root == root1

if 0:
    print ('root:%s, isRaw:%s, n:%s, len(lines): %s' % (
        root and root.h,isRaw,n,len(lines)))
#@nonl
#@-node:ekr.20090121163905.325:@test goto_setup n = 3 (@nosent)
#@-node:ekr.20090121163905.324:Tests with @nosent as the root
#@+node:ekr.20090121163905.326:General tests
#@+node:ekr.20090121163905.327:@test goto_findRoot (root in ancestors)
h = '@auto ..test/unittest/at-auto-line-number-test.py'
target = g.findNodeAnywhere(c,h)
assert target,'not found: %s' % h

child = target.firstChild()
assert child.h == 'at_auto_child'
p,found = c.goto_findRoot(child)

assert p == target,p and p.h
assert found,found
#@-node:ekr.20090121163905.327:@test goto_findRoot (root in ancestors)
#@+node:ekr.20090121163905.328:@test goto_findRoot (root not in ancestors)
# Find the cloned nodes that doesn't have an @file node for a parent.
h = 'goto-line-number tests: clones'
clones = g.findNodeAnywhere(c,h)
assert clones,'not found: %s' % h
child = g.findNodeInTree(c,clones,'at-file-child')
assert child and child.h == 'at-file-child',child

h = '@file unittest/at-file-line-number-test.py'
p,found = c.goto_findRoot(child)

assert p and p.h==h,p and p.h
assert found,found
#@-node:ekr.20090121163905.328:@test goto_findRoot (root not in ancestors)
#@+node:ekr.20090121163905.329:@test goto_showResults found
c.goto_showResults(found=True,p=p,n=3,n2=3,lines=3)
#@nonl
#@-node:ekr.20090121163905.329:@test goto_showResults found
#@+node:ekr.20090121163905.330:@test goto_showResults not found
c.goto_showResults(found=False,p=p,n=3,n2=3,lines=['a','b'])
#@-node:ekr.20090121163905.330:@test goto_showResults not found
#@-node:ekr.20090121163905.326:General tests
#@+node:ekr.20090121163905.331:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
#@-node:ekr.20090121163905.331:@test zz restore the screen
#@-node:ekr.20090121163905.300:goto-line-number tests
#@+node:ekr.20090121163905.332: Commands A-B
#@+node:ekr.20090121163905.333:@test add-space-to-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.334:work
first line
 line 1
     line a
 line b
last line
#@nonl
#@-node:ekr.20090121163905.334:work
#@+node:ekr.20090121163905.335:before sel=2.0,4.6
first line
line 1
    line a
line b
last line
#@nonl
#@-node:ekr.20090121163905.335:before sel=2.0,4.6
#@+node:ekr.20090121163905.336:after sel=2.0,4.7
first line
 line 1
     line a
 line b
last line
#@nonl
#@-node:ekr.20090121163905.336:after sel=2.0,4.7
#@-node:ekr.20090121163905.333:@test add-space-to-lines
#@+node:ekr.20090121163905.337:@test add-tab-to-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.338:work
first line
    line 1
        line a
            line b
    line c
last line
#@nonl
#@-node:ekr.20090121163905.338:work
#@+node:ekr.20090121163905.339:before sel=2.0,5.6
first line
line 1
    line a
        line b
line c
last line
#@nonl
#@-node:ekr.20090121163905.339:before sel=2.0,5.6
#@+node:ekr.20090121163905.340:after sel=2.0,5.10
first line
    line 1
        line a
            line b
    line c
last line
#@nonl
#@-node:ekr.20090121163905.340:after sel=2.0,5.10
#@-node:ekr.20090121163905.337:@test add-tab-to-lines
#@+node:ekr.20090121163905.341:@test apropos_bindings
c.helpCommands.aproposBindings()
#@-node:ekr.20090121163905.341:@test apropos_bindings
#@+node:ekr.20090121163905.342:@test apropos_find_commands
c.helpCommands.aproposFindCommands()
#@-node:ekr.20090121163905.342:@test apropos_find_commands
#@+node:ekr.20090121163905.343:@test back-char
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.344:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.344:work
#@+node:ekr.20090121163905.345:before sel=3.8,3.8
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.345:before sel=3.8,3.8
#@+node:ekr.20090121163905.346:after sel=3.7,3.7
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.346:after sel=3.7,3.7
#@-node:ekr.20090121163905.343:@test back-char
#@+node:ekr.20090121163905.347:@test back-char-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.348:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.348:work
#@+node:ekr.20090121163905.349:before sel=4.12,4.12
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.349:before sel=4.12,4.12
#@+node:ekr.20090121163905.350:after sel=4.11,4.12
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.350:after sel=4.11,4.12
#@-node:ekr.20090121163905.347:@test back-char-extend-selection
#@+node:ekr.20090121163905.351:@test back-paragraph
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.352:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.352:work
#@+node:ekr.20090121163905.353:before sel=9.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.353:before sel=9.0,9.0
#@+node:ekr.20090121163905.354:after sel=6.7,6.7
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.354:after sel=6.7,6.7
#@-node:ekr.20090121163905.351:@test back-paragraph
#@+node:ekr.20090121163905.355:@test back-paragraph-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.356:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.356:work
#@+node:ekr.20090121163905.357:before sel=9.0,9.5
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.357:before sel=9.0,9.5
#@+node:ekr.20090121163905.358:after sel=6.7,9.5
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.358:after sel=6.7,9.5
#@-node:ekr.20090121163905.355:@test back-paragraph-extend-selection
#@+node:ekr.20090121163905.359:@test back-sentence
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.360:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.360:work
#@+node:ekr.20090121163905.361:before sel=3.169,3.169
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.361:before sel=3.169,3.169
#@+node:ekr.20090121163905.362:after sel=3.0,3.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.362:after sel=3.0,3.0
#@-node:ekr.20090121163905.359:@test back-sentence
#@+node:ekr.20090121163905.363:@test back-sentence-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.364:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.364:work
#@+node:ekr.20090121163905.365:before sel=3.208,3.208
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.365:before sel=3.208,3.208
#@+node:ekr.20090121163905.366:after sel=3.0,3.208
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.366:after sel=3.0,3.208
#@-node:ekr.20090121163905.363:@test back-sentence-extend-selection
#@+node:ekr.20090121163905.367:@test back-to-indentation
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.368:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.368:work
#@+node:ekr.20090121163905.369:before sel=4.13,4.13
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.369:before sel=4.13,4.13
#@+node:ekr.20090121163905.370:after sel=4.8,4.8
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.370:after sel=4.8,4.8
#@-node:ekr.20090121163905.367:@test back-to-indentation
#@+node:ekr.20090121163905.371:@test back-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.372:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.372:work
#@+node:ekr.20090121163905.373:before sel=1.183,1.183
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.373:before sel=1.183,1.183
#@+node:ekr.20090121163905.374:after sel=1.178,1.178
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.374:after sel=1.178,1.178
#@-node:ekr.20090121163905.371:@test back-word
#@+node:ekr.20090121163905.375:@test back-word-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.376:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.376:work
#@+node:ekr.20090121163905.377:before sel=3.342,3.342
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.377:before sel=3.342,3.342
#@+node:ekr.20090121163905.378:after sel=3.332,3.342
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.378:after sel=3.332,3.342
#@-node:ekr.20090121163905.375:@test back-word-extend-selection
#@+node:ekr.20090121163905.379:@test backward-delete-char
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.380:work
first lie
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.380:work
#@+node:ekr.20090121163905.381:before sel=1.9,1.9
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.381:before sel=1.9,1.9
#@+node:ekr.20090121163905.382:after sel=1.8,1.8
first lie
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.382:after sel=1.8,1.8
#@-node:ekr.20090121163905.379:@test backward-delete-char
#@+node:ekr.20090121163905.383:@test backward-delete-char  (middle of line)
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.384:work
firstline
last line
#@nonl
#@-node:ekr.20090121163905.384:work
#@+node:ekr.20090121163905.385:before sel=1.6,1.6
first line
last line
#@nonl
#@-node:ekr.20090121163905.385:before sel=1.6,1.6
#@+node:ekr.20090121163905.386:after sel=1.5,1.5
firstline
last line
#@nonl
#@-node:ekr.20090121163905.386:after sel=1.5,1.5
#@-node:ekr.20090121163905.383:@test backward-delete-char  (middle of line)
#@+node:ekr.20090121163905.387:@test backward-delete-char (last char)
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.388:work
first line
last lin
#@nonl
#@-node:ekr.20090121163905.388:work
#@+node:ekr.20090121163905.389:before sel=2.9,2.9
first line
last line
#@nonl
#@-node:ekr.20090121163905.389:before sel=2.9,2.9
#@+node:ekr.20090121163905.390:after sel=2.8,2.8
first line
last lin
#@nonl
#@-node:ekr.20090121163905.390:after sel=2.8,2.8
#@-node:ekr.20090121163905.387:@test backward-delete-char (last char)
#@+node:ekr.20090121163905.391:@test backward-kill-paragraph
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.392:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.392:work
#@+node:ekr.20090121163905.393:before sel=9.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.393:before sel=9.0,9.0
#@+node:ekr.20090121163905.394:after sel=7.0,7.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.394:after sel=7.0,7.0
#@-node:ekr.20090121163905.391:@test backward-kill-paragraph
#@+node:ekr.20090121163905.395:@test backward-kill-sentence
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.396:work
This is the first sentence.  This
is the second sentence.
#@-node:ekr.20090121163905.396:work
#@+node:ekr.20090121163905.397:before sel=3.2,3.2
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.397:before sel=3.2,3.2
#@+node:ekr.20090121163905.398:after sel=2.23,2.23
This is the first sentence.  This
is the second sentence.
#@-node:ekr.20090121163905.398:after sel=2.23,2.23
#@-node:ekr.20090121163905.395:@test backward-kill-sentence
#@+node:ekr.20090121163905.399:@test backward-kill-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.400:work
This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
#@-node:ekr.20090121163905.400:work
#@+node:ekr.20090121163905.401:before sel=3.7,3.7
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.401:before sel=3.7,3.7
#@+node:ekr.20090121163905.402:after sel=3.5,3.5
This is the first sentence.  This
is the second sentence.  And
this  the last sentence.
#@-node:ekr.20090121163905.402:after sel=3.5,3.5
#@-node:ekr.20090121163905.399:@test backward-kill-word
#@+node:ekr.20090121163905.403:@test beginning-of-buffer
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.404:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.404:work
#@+node:ekr.20090121163905.405:before sel=5.56,5.56
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.405:before sel=5.56,5.56
#@+node:ekr.20090121163905.406:after sel=1.0,1.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.406:after sel=1.0,1.0
#@-node:ekr.20090121163905.403:@test beginning-of-buffer
#@+node:ekr.20090121163905.407:@test beginning-of-buffer-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.408:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.408:work
#@+node:ekr.20090121163905.409:before sel=3.423,3.423
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.409:before sel=3.423,3.423
#@+node:ekr.20090121163905.410:after sel=1.0,3.423
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.410:after sel=1.0,3.423
#@-node:ekr.20090121163905.407:@test beginning-of-buffer-extend-selection
#@+node:ekr.20090121163905.411:@test beginning-of-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.412:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.412:work
#@+node:ekr.20090121163905.413:before sel=3.10,3.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.413:before sel=3.10,3.10
#@+node:ekr.20090121163905.414:after sel=3.0,3.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.414:after sel=3.0,3.0
#@-node:ekr.20090121163905.411:@test beginning-of-line
#@+node:ekr.20090121163905.415:@test beginning-of-line-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.416:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.416:work
#@+node:ekr.20090121163905.417:before sel=4.10,4.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.417:before sel=4.10,4.10
#@+node:ekr.20090121163905.418:after sel=4.0,4.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.418:after sel=4.0,4.10
#@-node:ekr.20090121163905.415:@test beginning-of-line-extend-selection
#@+node:ekr.20090121163905.419:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
#@-node:ekr.20090121163905.419:@test zz restore the screen
#@-node:ekr.20090121163905.332: Commands A-B
#@+node:ekr.20090121163905.420: Commands C-E
#@+node:ekr.20090121163905.421:@test capitalize-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.422:work
first line
line 1
    Line a
        line b
line c
last line
#@-node:ekr.20090121163905.422:work
#@+node:ekr.20090121163905.423:before sel=3.6,3.6
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.423:before sel=3.6,3.6
#@+node:ekr.20090121163905.424:after sel=3.6,3.6
first line
line 1
    Line a
        line b
line c
last line
#@-node:ekr.20090121163905.424:after sel=3.6,3.6
#@-node:ekr.20090121163905.421:@test capitalize-word
#@+node:ekr.20090121163905.425:@test center-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.426:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.426:work
#@+node:ekr.20090121163905.427:before sel=3.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.427:before sel=3.0,9.0
#@+node:ekr.20090121163905.428:after sel=3.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.428:after sel=3.0,9.0
#@-node:ekr.20090121163905.425:@test center-line
#@+node:ekr.20090121163905.429:@test center-region
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.430:work
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
#@-node:ekr.20090121163905.430:work
#@+node:ekr.20090121163905.431:before sel=1.0,7.0
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
#@-node:ekr.20090121163905.431:before sel=1.0,7.0
#@+node:ekr.20090121163905.432:after sel=1.0,7.0
Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly $14 billion in damage.
         StormReady, a program started in 1999 in Tulsa, OK,
  helps arm America's communities with the communication and safety
skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.
#@-node:ekr.20090121163905.432:after sel=1.0,7.0
#@-node:ekr.20090121163905.429:@test center-region
#@+node:ekr.20090121163905.433:@test clear-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.434:work
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
#@nonl
#@-node:ekr.20090121163905.434:work
#@+node:ekr.20090121163905.435:before sel=2.3,5.6
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
#@nonl
#@-node:ekr.20090121163905.435:before sel=2.3,5.6
#@+node:ekr.20090121163905.436:after sel=2.3,5.6
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
#@nonl
#@-node:ekr.20090121163905.436:after sel=2.3,5.6
#@-node:ekr.20090121163905.433:@test clear-rectangle
#@+node:ekr.20090121163905.437:@test clear-selected-text
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.438:work
first line
line    line b
line c
last line
#@-node:ekr.20090121163905.438:work
#@+node:ekr.20090121163905.439:before sel=2.4,4.4
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.439:before sel=2.4,4.4
#@+node:ekr.20090121163905.440:after sel=2.4,2.4
first line
line    line b
line c
last line
#@-node:ekr.20090121163905.440:after sel=2.4,2.4
#@-node:ekr.20090121163905.437:@test clear-selected-text
#@+node:ekr.20090121163905.441:@test close-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.442:work
before
aaabbb
aaabbb
aaabbb
aaabbb
after
#@nonl
#@-node:ekr.20090121163905.442:work
#@+node:ekr.20090121163905.443:before sel=2.3,5.6
before
aaa   bbb
aaa   bbb
aaa   bbb
aaa   bbb
after
#@nonl
#@-node:ekr.20090121163905.443:before sel=2.3,5.6
#@+node:ekr.20090121163905.444:after sel=2.3,5.3
before
aaabbb
aaabbb
aaabbb
aaabbb
after
#@nonl
#@-node:ekr.20090121163905.444:after sel=2.3,5.3
#@-node:ekr.20090121163905.441:@test close-rectangle
#@+node:ekr.20090121163905.445:@test count-region
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.446:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.446:work
#@+node:ekr.20090121163905.447:before sel=2.4,4.8
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.447:before sel=2.4,4.8
#@+node:ekr.20090121163905.448:after sel=2.4,4.8
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.448:after sel=2.4,4.8
#@-node:ekr.20090121163905.445:@test count-region
#@+node:ekr.20090121163905.449:@test delete-char
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.450:work
firstline
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.450:work
#@+node:ekr.20090121163905.451:before sel=1.5,1.5
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.451:before sel=1.5,1.5
#@+node:ekr.20090121163905.452:after sel=1.5,1.5
firstline
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.452:after sel=1.5,1.5
#@-node:ekr.20090121163905.449:@test delete-char
#@+node:ekr.20090121163905.453:@test delete-indentation
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.454:work
first line
line 1
last line
#@nonl
#@-node:ekr.20090121163905.454:work
#@+node:ekr.20090121163905.455:before sel=2.8,2.8
first line
    line 1
last line
#@nonl
#@-node:ekr.20090121163905.455:before sel=2.8,2.8
#@+node:ekr.20090121163905.456:after sel=2.4,2.4
first line
line 1
last line
#@nonl
#@-node:ekr.20090121163905.456:after sel=2.4,2.4
#@-node:ekr.20090121163905.453:@test delete-indentation
#@+node:ekr.20090121163905.457:@test delete-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.458:work
before
aaabbb
aaabbb
aaabbb
aaabbb
after
#@nonl
#@-node:ekr.20090121163905.458:work
#@+node:ekr.20090121163905.459:before sel=2.3,5.6
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
#@nonl
#@-node:ekr.20090121163905.459:before sel=2.3,5.6
#@+node:ekr.20090121163905.460:after sel=2.3,5.3
before
aaabbb
aaabbb
aaabbb
aaabbb
after
#@nonl
#@-node:ekr.20090121163905.460:after sel=2.3,5.3
#@-node:ekr.20090121163905.457:@test delete-rectangle
#@+node:ekr.20090121163905.461:@test delete-spaces
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.462:work
first line
line 1
line a
        line b
line c
last line
#@-node:ekr.20090121163905.462:work
#@+node:ekr.20090121163905.463:before sel=3.2,3.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.463:before sel=3.2,3.2
#@+node:ekr.20090121163905.464:after sel=3.0,3.0
first line
line 1
line a
        line b
line c
last line
#@-node:ekr.20090121163905.464:after sel=3.0,3.0
#@-node:ekr.20090121163905.461:@test delete-spaces
#@+node:ekr.20090121163905.465:@test do-nothing
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.466:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.466:work
#@+node:ekr.20090121163905.467:before sel=1.0,1.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.467:before sel=1.0,1.0
#@+node:ekr.20090121163905.468:after sel=1.0,1.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.468:after sel=1.0,1.0
#@-node:ekr.20090121163905.465:@test do-nothing
#@+node:ekr.20090121163905.469:@test downcase-region
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')
#@+node:ekr.20090121163905.470:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.470:work
#@+node:ekr.20090121163905.471:before sel=3.0,4.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.471:before sel=3.0,4.0
#@+node:ekr.20090121163905.472:after sel=3.0,4.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. stormready, a program started in 1999 in tulsa, ok, helps arm america's communities with the communication and safety skills needed to save lives and property– before and during the event. stormready helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.472:after sel=3.0,4.0
#@-node:ekr.20090121163905.469:@test downcase-region
#@+node:ekr.20090121163905.473:@test downcase-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')
#@nonl
#@+node:ekr.20090121163905.474:work
xyzzy line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.474:work
#@+node:ekr.20090121163905.475:before sel=1.4,1.4
XYZZY line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.475:before sel=1.4,1.4
#@+node:ekr.20090121163905.476:after sel=1.4,1.4
xyzzy line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.476:after sel=1.4,1.4
#@-node:ekr.20090121163905.473:@test downcase-word
#@+node:ekr.20090121163905.477:@test end-of-buffer
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.478:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.478:work
#@+node:ekr.20090121163905.479:before sel=1.3,1.3
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.479:before sel=1.3,1.3
#@+node:ekr.20090121163905.480:after sel=7.0,7.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.480:after sel=7.0,7.0
#@-node:ekr.20090121163905.477:@test end-of-buffer
#@+node:ekr.20090121163905.481:@test end-of-buffer-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.482:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.482:work
#@+node:ekr.20090121163905.483:before sel=1.0,1.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.483:before sel=1.0,1.0
#@+node:ekr.20090121163905.484:after sel=1.0,7.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.484:after sel=1.0,7.0
#@-node:ekr.20090121163905.481:@test end-of-buffer-extend-selection
#@+node:ekr.20090121163905.485:@test end-of-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.486:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.486:work
#@+node:ekr.20090121163905.487:before sel=1.0,1.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.487:before sel=1.0,1.0
#@+node:ekr.20090121163905.488:after sel=1.10,1.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.488:after sel=1.10,1.10
#@-node:ekr.20090121163905.485:@test end-of-line
#@+node:ekr.20090121163905.489:@test end-of-line 2
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.490:work
first line
line 1
    line a
        line b
line c
last line
#@nonl
#@-node:ekr.20090121163905.490:work
#@+node:ekr.20090121163905.491:before sel=6.0,6.0
first line
line 1
    line a
        line b
line c
last line
#@nonl
#@-node:ekr.20090121163905.491:before sel=6.0,6.0
#@+node:ekr.20090121163905.492:after sel=6.9,6.9
first line
line 1
    line a
        line b
line c
last line
#@nonl
#@-node:ekr.20090121163905.492:after sel=6.9,6.9
#@-node:ekr.20090121163905.489:@test end-of-line 2
#@+node:ekr.20090121163905.493:@test end-of-line-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.494:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.494:work
#@+node:ekr.20090121163905.495:before sel=3.0,3.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.495:before sel=3.0,3.0
#@+node:ekr.20090121163905.496:after sel=3.0,3.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.496:after sel=3.0,3.10
#@-node:ekr.20090121163905.493:@test end-of-line-extend-selection
#@+node:ekr.20090121163905.497:@test exchange-point-mark
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.498:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.498:work
#@+node:ekr.20090121163905.499:before sel=1.0,1.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.499:before sel=1.0,1.10
#@+node:ekr.20090121163905.500:after sel=1.0,1.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.500:after sel=1.0,1.10
#@-node:ekr.20090121163905.497:@test exchange-point-mark
#@+node:ekr.20090121163905.501:@test extend-to-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.502:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.502:work
#@+node:ekr.20090121163905.503:before sel=3.3,3.3
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.503:before sel=3.3,3.3
#@+node:ekr.20090121163905.504:after sel=3.0,3.10
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.504:after sel=3.0,3.10
#@-node:ekr.20090121163905.501:@test extend-to-line
#@+node:ekr.20090121163905.505:@test extend-to-paragraph
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.506:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@-node:ekr.20090121163905.506:work
#@+node:ekr.20090121163905.507:before sel=9.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@-node:ekr.20090121163905.507:before sel=9.0,9.0
#@+node:ekr.20090121163905.508:after sel=8.0,13.33
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@-node:ekr.20090121163905.508:after sel=8.0,13.33
#@-node:ekr.20090121163905.505:@test extend-to-paragraph
#@+node:ekr.20090121163905.509:@test extend-to-sentence
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.510:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.510:work
#@+node:ekr.20090121163905.511:before sel=3.5,3.5
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.511:before sel=3.5,3.5
#@+node:ekr.20090121163905.512:after sel=1.395,3.142
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.512:after sel=1.395,3.142
#@-node:ekr.20090121163905.509:@test extend-to-sentence
#@+node:ekr.20090121163905.513:@test extend-to-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.514:work
first line
line 1
    line_24a a
        line b
line c
last line
#@-node:ekr.20090121163905.514:work
#@+node:ekr.20090121163905.515:before sel=3.10,3.10
first line
line 1
    line_24a a
        line b
line c
last line
#@-node:ekr.20090121163905.515:before sel=3.10,3.10
#@+node:ekr.20090121163905.516:after sel=3.4,3.12
first line
line 1
    line_24a a
        line b
line c
last line
#@-node:ekr.20090121163905.516:after sel=3.4,3.12
#@-node:ekr.20090121163905.513:@test extend-to-word
#@+node:ekr.20090121163905.517:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
#@-node:ekr.20090121163905.517:@test zz restore the screen
#@-node:ekr.20090121163905.420: Commands C-E
#@+node:ekr.20090121163905.518: Commands F-L
#@+node:ekr.20090121163905.519:@test fill-paragraph
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.520:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.520:work
#@+node:ekr.20090121163905.521:before sel=3.0,3.7
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage.
StormReady, a program started in 1999 in Tulsa, OK,
helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event.
StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.521:before sel=3.0,3.7
#@+node:ekr.20090121163905.522:after sel=10.0,10.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.522:after sel=10.0,10.0
#@-node:ekr.20090121163905.519:@test fill-paragraph
#@+node:ekr.20090121163905.523:@test fill-region (one paragraph)
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.524:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property– before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.524:work
#@+node:ekr.20090121163905.525:before sel=1.0,9.7
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property– before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.525:before sel=1.0,9.7
#@+node:ekr.20090121163905.526:after sel=8.0,8.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property– before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.526:after sel=8.0,8.0
#@-node:ekr.20090121163905.523:@test fill-region (one paragraph)
#@+node:ekr.20090121163905.527:@test fill-region (three paragraphs)
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.528:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.528:work
#@+node:ekr.20090121163905.529:before sel=1.0,24.78
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms,
2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes.
Potentially deadly
weather impacts every American.
Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related,
leading to around 500 deaths per year and nearly
$14 billion in damage.
StormReady, a program started in 1999 in Tulsa,
OK, helps arm America's communities with the communication
and safety skills needed to save lives and property– before and during the event.
StormReady helps community leaders
and emergency managers strengthen local safety programs.

StormReady communities are better prepared
to save lives from the onslaught of severe
weather through better planning, education, and awareness.
No community is storm proof,
but
StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.529:before sel=1.0,24.78
#@+node:ekr.20090121163905.530:after sel=18.18,18.18
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.530:after sel=18.18,18.18
#@-node:ekr.20090121163905.527:@test fill-region (three paragraphs)
#@+node:ekr.20090121163905.531:@test forward-char
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.532:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.532:work
#@+node:ekr.20090121163905.533:before sel=1.2,1.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.533:before sel=1.2,1.2
#@+node:ekr.20090121163905.534:after sel=1.3,1.3
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.534:after sel=1.3,1.3
#@-node:ekr.20090121163905.531:@test forward-char
#@+node:ekr.20090121163905.535:@test forward-char-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.536:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.536:work
#@+node:ekr.20090121163905.537:before sel=1.1,1.1
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.537:before sel=1.1,1.1
#@+node:ekr.20090121163905.538:after sel=1.1,1.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.538:after sel=1.1,1.2
#@-node:ekr.20090121163905.535:@test forward-char-extend-selection
#@+node:ekr.20090121163905.539:@test forward-end-word (end of line)
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.540:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.540:work
#@+node:ekr.20090121163905.541:before sel=1.395,1.395
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.541:before sel=1.395,1.395
#@+node:ekr.20090121163905.542:after sel=3.4,3.4
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.542:after sel=3.4,3.4
#@-node:ekr.20090121163905.539:@test forward-end-word (end of line)
#@+node:ekr.20090121163905.543:@test forward-end-word (start of word)
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.544:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.544:work
#@+node:ekr.20090121163905.545:before sel=1.310,1.310
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.545:before sel=1.310,1.310
#@+node:ekr.20090121163905.546:after sel=1.317,1.317
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.546:after sel=1.317,1.317
#@-node:ekr.20090121163905.543:@test forward-end-word (start of word)
#@+node:ekr.20090121163905.547:@test forward-end-word-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.548:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.548:work
#@+node:ekr.20090121163905.549:before sel=3.20,3.20
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.549:before sel=3.20,3.20
#@+node:ekr.20090121163905.550:after sel=3.20,3.30
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.550:after sel=3.20,3.30
#@-node:ekr.20090121163905.547:@test forward-end-word-extend-selection
#@+node:ekr.20090121163905.551:@test forward-paragraph
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.552:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.552:work
#@+node:ekr.20090121163905.553:before sel=9.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.553:before sel=9.0,9.0
#@+node:ekr.20090121163905.554:after sel=15.0,15.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.554:after sel=15.0,15.0
#@-node:ekr.20090121163905.551:@test forward-paragraph
#@+node:ekr.20090121163905.555:@test forward-paragraph-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.556:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.556:work
#@+node:ekr.20090121163905.557:before sel=10.0,10.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.557:before sel=10.0,10.0
#@+node:ekr.20090121163905.558:after sel=10.0,15.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@nonl
#@-node:ekr.20090121163905.558:after sel=10.0,15.0
#@-node:ekr.20090121163905.555:@test forward-paragraph-extend-selection
#@+node:ekr.20090121163905.559:@test forward-sentence
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.560:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.560:work
#@+node:ekr.20090121163905.561:before sel=3.17,3.17
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.561:before sel=3.17,3.17
#@+node:ekr.20090121163905.562:after sel=3.142,3.142
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.562:after sel=3.142,3.142
#@-node:ekr.20090121163905.559:@test forward-sentence
#@+node:ekr.20090121163905.563:@test forward-sentence-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.564:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.564:work
#@+node:ekr.20090121163905.565:before sel=1.264,1.264
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.565:before sel=1.264,1.264
#@+node:ekr.20090121163905.566:after sel=1.264,1.395
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.566:after sel=1.264,1.395
#@-node:ekr.20090121163905.563:@test forward-sentence-extend-selection
#@+node:ekr.20090121163905.567:@test forward-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.568:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.568:work
#@+node:ekr.20090121163905.569:before sel=1.261,1.261
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.569:before sel=1.261,1.261
#@+node:ekr.20090121163905.570:after sel=1.273,1.273
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.570:after sel=1.273,1.273
#@-node:ekr.20090121163905.567:@test forward-word
#@+node:ekr.20090121163905.571:@test forward-word-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.572:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.572:work
#@+node:ekr.20090121163905.573:before sel=1.395,1.395
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.573:before sel=1.395,1.395
#@+node:ekr.20090121163905.574:after sel=1.395,3.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@nonl
#@-node:ekr.20090121163905.574:after sel=1.395,3.0
#@-node:ekr.20090121163905.571:@test forward-word-extend-selection
#@+node:ekr.20090121163905.575:@test goNext/PrevVisitedNode
p = c.currentPosition().copy()
c.selectPosition(p.threadBack())
p1 = c.currentPosition()
# print(p1)
c.goPrevVisitedNode()
p2 = c.currentPosition()
# print(p2)
c.goNextVisitedNode()
p3 = c.currentPosition()
# print(p3)
# assert p == p3
#@-node:ekr.20090121163905.575:@test goNext/PrevVisitedNode
#@+node:ekr.20090121163905.576:@test indent-relative
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.577:work
first line
line 1
    line a
        line b
        line c
last line
#@-node:ekr.20090121163905.577:work
#@+node:ekr.20090121163905.578:before sel=5.0,5.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.578:before sel=5.0,5.0
#@+node:ekr.20090121163905.579:after sel=5.8,5.8
first line
line 1
    line a
        line b
        line c
last line
#@-node:ekr.20090121163905.579:after sel=5.8,5.8
#@-node:ekr.20090121163905.576:@test indent-relative
#@+node:ekr.20090121163905.580:@test indent-rigidly
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.581:work
first line
	line 1
	    line a
	        line b
	line c
last line
#@-node:ekr.20090121163905.581:work
#@+node:ekr.20090121163905.582:before sel=2.0,5.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.582:before sel=2.0,5.0
#@+node:ekr.20090121163905.583:after sel=2.0,5.1
first line
	line 1
	    line a
	        line b
	line c
last line
#@-node:ekr.20090121163905.583:after sel=2.0,5.1
#@-node:ekr.20090121163905.580:@test indent-rigidly
#@+node:ekr.20090121163905.584:@test indent-to-comment-column
import leo.core.leoTest as leoTest
c.editCommands.ccolumn = 4 # Set the comment column
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.585:work
first line
    line b
last line
#@nonl
#@-node:ekr.20090121163905.585:work
#@+node:ekr.20090121163905.586:before sel=2.0,2.0
first line
line b
last line
#@nonl
#@-node:ekr.20090121163905.586:before sel=2.0,2.0
#@+node:ekr.20090121163905.587:after sel=2.4,2.4
first line
    line b
last line
#@nonl
#@-node:ekr.20090121163905.587:after sel=2.4,2.4
#@-node:ekr.20090121163905.584:@test indent-to-comment-column
#@+node:ekr.20090121163905.588:@test insert-newline
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.589:work
first li
ne
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.589:work
#@+node:ekr.20090121163905.590:before sel=1.8,1.8
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.590:before sel=1.8,1.8
#@+node:ekr.20090121163905.591:after sel=2.0,2.0
first li
ne
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.591:after sel=2.0,2.0
#@-node:ekr.20090121163905.588:@test insert-newline
#@+node:ekr.20090121163905.592:@test insert-parentheses
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.593:work
first() line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.593:work
#@+node:ekr.20090121163905.594:before sel=1.5,1.5
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.594:before sel=1.5,1.5
#@+node:ekr.20090121163905.595:after sel=1.6,1.6
first() line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.595:after sel=1.6,1.6
#@-node:ekr.20090121163905.592:@test insert-parentheses
#@+node:ekr.20090121163905.596:@test kill-line end-1
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.597:work
line 1
line 2
#@-node:ekr.20090121163905.597:work
#@+node:ekr.20090121163905.598:before sel=3.0,3.0
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.598:before sel=3.0,3.0
#@+node:ekr.20090121163905.599:after sel=3.0,3.0
line 1
line 2
#@-node:ekr.20090121163905.599:after sel=3.0,3.0
#@-node:ekr.20090121163905.596:@test kill-line end-1
#@+node:ekr.20090121163905.600:@test kill-line end-2
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.601:work
line 1
line 2
#@nonl
#@-node:ekr.20090121163905.601:work
#@+node:ekr.20090121163905.602:before sel=3.0,3.0
line 1
line 2
#@-node:ekr.20090121163905.602:before sel=3.0,3.0
#@+node:ekr.20090121163905.603:after sel=2.6,2.6
line 1
line 2
#@nonl
#@-node:ekr.20090121163905.603:after sel=2.6,2.6
#@-node:ekr.20090121163905.600:@test kill-line end-2
#@+node:ekr.20090121163905.604:@test kill-line middle-1
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.605:work
line 1
line 2

line 4
#@nonl
#@-node:ekr.20090121163905.605:work
#@+node:ekr.20090121163905.606:before sel=3.0,3.0
line 1
line 2
line 3
line 4
#@nonl
#@-node:ekr.20090121163905.606:before sel=3.0,3.0
#@+node:ekr.20090121163905.607:after sel=3.0,3.0
line 1
line 2

line 4
#@nonl
#@-node:ekr.20090121163905.607:after sel=3.0,3.0
#@-node:ekr.20090121163905.604:@test kill-line middle-1
#@+node:ekr.20090121163905.608:@test kill-line middle-2
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.609:work
line 1
line 2
line 4
#@nonl
#@-node:ekr.20090121163905.609:work
#@+node:ekr.20090121163905.610:before sel=3.0,3.0
line 1
line 2

line 4
#@nonl
#@-node:ekr.20090121163905.610:before sel=3.0,3.0
#@+node:ekr.20090121163905.611:after sel=3.0,3.0
line 1
line 2
line 4
#@nonl
#@-node:ekr.20090121163905.611:after sel=3.0,3.0
#@-node:ekr.20090121163905.608:@test kill-line middle-2
#@+node:ekr.20090121163905.612:@test kill-paragraph
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.613:work
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@-node:ekr.20090121163905.613:work
#@+node:ekr.20090121163905.614:before sel=9.0,9.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.

Some 90% of all presidentially declared disasters are weather related, leading
to around 500 deaths per year and nearly $14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK, helps arm America's communities with the
communication and safety skills needed to save lives and property– before and
during the event. StormReady helps community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@-node:ekr.20090121163905.614:before sel=9.0,9.0
#@+node:ekr.20090121163905.615:after sel=8.0,8.0
Americans live in the most severe weather-prone country on Earth. Each year,
Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000
tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly
weather impacts every American. Communities can now rely on the National Weather
Service’s StormReady program to help them guard against the ravages of Mother
Nature.



StormReady communities are better prepared to save lives from the onslaught of
severe weather through better planning, education, and awareness. No community
is storm proof, but StormReady can help communities save lives. Does StormReady
make a difference?
#@-node:ekr.20090121163905.615:after sel=8.0,8.0
#@-node:ekr.20090121163905.612:@test kill-paragraph
#@+node:ekr.20090121163905.616:@test kill-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.617:work
before
aaabbb
aaabbb
aaabbb
aaabbb
after
#@nonl
#@-node:ekr.20090121163905.617:work
#@+node:ekr.20090121163905.618:before sel=2.3,5.6
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
#@nonl
#@-node:ekr.20090121163905.618:before sel=2.3,5.6
#@+node:ekr.20090121163905.619:after sel=5.3,5.3
before
aaabbb
aaabbb
aaabbb
aaabbb
after
#@nonl
#@-node:ekr.20090121163905.619:after sel=5.3,5.3
#@-node:ekr.20090121163905.616:@test kill-rectangle
#@+node:ekr.20090121163905.620:@test kill-sentence
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.621:work
This is the first sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.621:work
#@+node:ekr.20090121163905.622:before sel=2.2,2.2
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.622:before sel=2.2,2.2
#@+node:ekr.20090121163905.623:after sel=1.27,1.27
This is the first sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.623:after sel=1.27,1.27
#@-node:ekr.20090121163905.620:@test kill-sentence
#@+node:ekr.20090121163905.624:@test kill-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.625:work
This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.625:work
#@+node:ekr.20090121163905.626:before sel=2.6,2.6
This is the first sentence.  This
is the second sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.626:before sel=2.6,2.6
#@+node:ekr.20090121163905.627:after sel=2.7,2.7
This is the first sentence.  This
is the  sentence.  And
this is the last sentence.
#@-node:ekr.20090121163905.627:after sel=2.7,2.7
#@-node:ekr.20090121163905.624:@test kill-word
#@+node:ekr.20090121163905.628:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
#@-node:ekr.20090121163905.628:@test zz restore the screen
#@-node:ekr.20090121163905.518: Commands F-L
#@+node:ekr.20090121163905.629: Commands M-Z
#@+node:ekr.20090121163905.630:@@test zap-to-chararacter
#@+node:ekr.20090121163905.631:work
first line
line 1
    line a
        line b
line c
last line
#@nonl
#@-node:ekr.20090121163905.631:work
#@-node:ekr.20090121163905.630:@@test zap-to-chararacter
#@+node:ekr.20090121163905.632:@test move-lines-down
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.633:work
first line
line 1
line c
    line a
        line b
last line
#@-node:ekr.20090121163905.633:work
#@+node:ekr.20090121163905.634:before sel=3.3,4.3
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.634:before sel=3.3,4.3
#@+node:ekr.20090121163905.635:after sel=4.0,5.0
first line
line 1
line c
    line a
        line b
last line
#@-node:ekr.20090121163905.635:after sel=4.0,5.0
#@-node:ekr.20090121163905.632:@test move-lines-down
#@+node:ekr.20090121163905.636:@test move-lines-up
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@+node:ekr.20090121163905.637:work
line 1
first line
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.637:work
#@+node:ekr.20090121163905.638:before sel=2.2,2.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.638:before sel=2.2,2.2
#@+node:ekr.20090121163905.639:after sel=1.0,1.0
line 1
first line
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.639:after sel=1.0,1.0
#@-node:ekr.20090121163905.636:@test move-lines-up
#@+node:ekr.20090121163905.640:@test move-past-close
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.641:work
first (line)
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.641:work
#@+node:ekr.20090121163905.642:before sel=1.10,1.10
first (line)
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.642:before sel=1.10,1.10
#@+node:ekr.20090121163905.643:after sel=1.12,1.12
first (line)
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.643:after sel=1.12,1.12
#@-node:ekr.20090121163905.640:@test move-past-close
#@+node:ekr.20090121163905.644:@test move-past-close-extend-selection
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.645:work
first line
line 1
    (line )a
        line b
line c
last line
#@-node:ekr.20090121163905.645:work
#@+node:ekr.20090121163905.646:before sel=3.7,3.7
first line
line 1
    (line )a
        line b
line c
last line
#@-node:ekr.20090121163905.646:before sel=3.7,3.7
#@+node:ekr.20090121163905.647:after sel=3.7,3.11
first line
line 1
    (line )a
        line b
line c
last line
#@-node:ekr.20090121163905.647:after sel=3.7,3.11
#@-node:ekr.20090121163905.644:@test move-past-close-extend-selection
#@+node:ekr.20090121163905.648:@test newline-and-indent
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.649:work
first line
line 1

    line a
        line b
line c
last line
#@-node:ekr.20090121163905.649:work
#@+node:ekr.20090121163905.650:before sel=2.6,2.6
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.650:before sel=2.6,2.6
#@+node:ekr.20090121163905.651:after sel=3.4,3.4
first line
line 1

    line a
        line b
line c
last line
#@-node:ekr.20090121163905.651:after sel=3.4,3.4
#@-node:ekr.20090121163905.648:@test newline-and-indent
#@+node:ekr.20090121163905.652:@test next-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.653:work
a

b
#@nonl
#@-node:ekr.20090121163905.653:work
#@+node:ekr.20090121163905.654:before sel=1.1,1.1
a

b
#@nonl
#@-node:ekr.20090121163905.654:before sel=1.1,1.1
#@+node:ekr.20090121163905.655:after sel=2.0,2.0
a

b
#@nonl
#@-node:ekr.20090121163905.655:after sel=2.0,2.0
#@-node:ekr.20090121163905.652:@test next-line
#@+node:ekr.20090121163905.656:@test open-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.657:work
before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
#@nonl
#@-node:ekr.20090121163905.657:work
#@+node:ekr.20090121163905.658:before sel=2.3,5.6
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
#@nonl
#@-node:ekr.20090121163905.658:before sel=2.3,5.6
#@+node:ekr.20090121163905.659:after sel=2.3,5.6
before
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
aaa   xxxbbb
after
#@nonl
#@-node:ekr.20090121163905.659:after sel=2.3,5.6
#@-node:ekr.20090121163905.656:@test open-rectangle
#@+node:ekr.20090121163905.660:@test previous-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.661:work
a

b
#@nonl
#@-node:ekr.20090121163905.661:work
#@+node:ekr.20090121163905.662:before sel=3.0,3.0
a

b
#@nonl
#@-node:ekr.20090121163905.662:before sel=3.0,3.0
#@+node:ekr.20090121163905.663:after sel=2.0,2.0
a

b
#@nonl
#@-node:ekr.20090121163905.663:after sel=2.0,2.0
#@-node:ekr.20090121163905.660:@test previous-line
#@+node:ekr.20090121163905.664:@test remove-blank-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.665:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.665:work
#@+node:ekr.20090121163905.666:before sel=1.0,9.0
first line

line 1
    line a
        line b

line c
last line
#@-node:ekr.20090121163905.666:before sel=1.0,9.0
#@+node:ekr.20090121163905.667:after sel=1.0,6.9
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.667:after sel=1.0,6.9
#@-node:ekr.20090121163905.664:@test remove-blank-lines
#@+node:ekr.20090121163905.668:@test remove-space-from-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.669:work
first line

line 1
   line a
       line b

line c
last line
#@-node:ekr.20090121163905.669:work
#@+node:ekr.20090121163905.670:before sel=1.0,9.0
first line

line 1
    line a
        line b

line c
last line
#@-node:ekr.20090121163905.670:before sel=1.0,9.0
#@+node:ekr.20090121163905.671:after sel=1.0,9.0
first line

line 1
   line a
       line b

line c
last line
#@-node:ekr.20090121163905.671:after sel=1.0,9.0
#@-node:ekr.20090121163905.668:@test remove-space-from-lines
#@+node:ekr.20090121163905.672:@test remove-tab-from-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.673:work
first line
line 1
line a
    line b
line c
last line
#@-node:ekr.20090121163905.673:work
#@+node:ekr.20090121163905.674:before sel=1.0,7.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.674:before sel=1.0,7.0
#@+node:ekr.20090121163905.675:after sel=1.0,7.0
first line
line 1
line a
    line b
line c
last line
#@-node:ekr.20090121163905.675:after sel=1.0,7.0
#@-node:ekr.20090121163905.672:@test remove-tab-from-lines
#@+node:ekr.20090121163905.676:@test reverse-region
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.677:work

last line
line c
        line b
    line a
line 1
first line
#@-node:ekr.20090121163905.677:work
#@+node:ekr.20090121163905.678:before sel=1.0,7.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.678:before sel=1.0,7.0
#@+node:ekr.20090121163905.679:after sel=7.10,7.10

last line
line c
        line b
    line a
line 1
first line
#@-node:ekr.20090121163905.679:after sel=7.10,7.10
#@-node:ekr.20090121163905.676:@test reverse-region
#@+node:ekr.20090121163905.680:@test reverse-sort-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.681:work
z
x
e
d
a
#@-node:ekr.20090121163905.681:work
#@+node:ekr.20090121163905.682:before sel=1.0,5.1
a
d
e
z
x
#@nonl
#@-node:ekr.20090121163905.682:before sel=1.0,5.1
#@+node:ekr.20090121163905.683:after sel=1.0,5.1
z
x
e
d
a
#@-node:ekr.20090121163905.683:after sel=1.0,5.1
#@-node:ekr.20090121163905.680:@test reverse-sort-lines
#@+node:ekr.20090121163905.684:@test reverse-sort-lines-ignoring-case
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.685:work
z
Y
X
c
b
A
#@-node:ekr.20090121163905.685:work
#@+node:ekr.20090121163905.686:before sel=1.0,6.1
c
A
z
X
Y
b
#@nonl
#@-node:ekr.20090121163905.686:before sel=1.0,6.1
#@+node:ekr.20090121163905.687:after sel=1.0,6.1
z
Y
X
c
b
A
#@-node:ekr.20090121163905.687:after sel=1.0,6.1
#@-node:ekr.20090121163905.684:@test reverse-sort-lines-ignoring-case
#@+node:ekr.20090121163905.688:@test selfInsertCommand-1
@first # -*- coding: utf-8 -*-
@language python

try:
    ec = c.editCommands ; w = c.frame.body.bodyCtrl
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉΩBぅ乼cz):\n'
    u = u'(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        event = g.Bunch(widget=w,char=char,keysym=None)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    #g.trace('result',repr(result))
    assert result.endswith('    '),'result:\n%s' % result
    # Test of autocompleter.
finally:
    if 1:
        w.setAllText(s)
        p.setBodyString(s)
        # g.trace(repr(s))
        c.recolor()

# end:
#@nonl
#@-node:ekr.20090121163905.688:@test selfInsertCommand-1
#@+node:ekr.20090121163905.689:@test selfInsertCommand-2 (replacing tabs)
@language python

try:
    ec = c.editCommands ; w = c.frame.body.bodyCtrl
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.Bunch(widget=w,char='\t',keysym=None)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    # g.trace('result',repr(result))
    assert result.endswith('\n    abcdef'),'last line:%s' % repr(result.split('\n')[-1])
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

###abcdef
#@nonl
#@-node:ekr.20090121163905.689:@test selfInsertCommand-2 (replacing tabs)
#@+node:ekr.20090121163905.690:@test set-fill-prefix
# xxxx.yyyy

s = p.b
w = c.frame.body.bodyCtrl
w.setSelectionRange(2,11)
c.editCommands.setFillPrefix(event=None)
assert c.editCommands.fillPrefix == 'xxxx.yyyy'
#@-node:ekr.20090121163905.690:@test set-fill-prefix
#@+node:ekr.20090121163905.691:@test sort-columns
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.692:work
        line b
    line a
first line
last line
line 1
line c
#@-node:ekr.20090121163905.692:work
#@+node:ekr.20090121163905.693:before sel=1.0,6.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.693:before sel=1.0,6.2
#@+node:ekr.20090121163905.694:after sel=1.0,7.0
        line b
    line a
first line
last line
line 1
line c
#@-node:ekr.20090121163905.694:after sel=1.0,7.0
#@-node:ekr.20090121163905.691:@test sort-columns
#@+node:ekr.20090121163905.695:@test sort-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.696:work
first line
        line b
    line a
line 1
line c
last line
#@-node:ekr.20090121163905.696:work
#@+node:ekr.20090121163905.697:before sel=2.0,5.6
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.697:before sel=2.0,5.6
#@+node:ekr.20090121163905.698:after sel=2.0,5.6
first line
        line b
    line a
line 1
line c
last line
#@-node:ekr.20090121163905.698:after sel=2.0,5.6
#@-node:ekr.20090121163905.695:@test sort-lines
#@+node:ekr.20090121163905.699:@test sort-lines-ignoring-case
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.700:work
A
B
c
x
z
#@-node:ekr.20090121163905.700:work
#@+node:ekr.20090121163905.701:before sel=1.0,5.1
x
z
A
c
B
#@nonl
#@-node:ekr.20090121163905.701:before sel=1.0,5.1
#@+node:ekr.20090121163905.702:after sel=1.0,5.1
A
B
c
x
z
#@-node:ekr.20090121163905.702:after sel=1.0,5.1
#@-node:ekr.20090121163905.699:@test sort-lines-ignoring-case
#@+node:ekr.20090121163905.703:@test split-line
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.704:work
first
 line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.704:work
#@+node:ekr.20090121163905.705:before sel=1.5,1.5
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.705:before sel=1.5,1.5
#@+node:ekr.20090121163905.706:after sel=2.0,2.0
first
 line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.706:after sel=2.0,2.0
#@-node:ekr.20090121163905.703:@test split-line
#@+node:ekr.20090121163905.707:@test string-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.708:work
before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
#@nonl
#@-node:ekr.20090121163905.708:work
#@+node:ekr.20090121163905.709:before sel=2.3,5.6
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
#@nonl
#@-node:ekr.20090121163905.709:before sel=2.3,5.6
#@+node:ekr.20090121163905.710:after sel=2.3,5.8
before
aaas...sbbb
aaas...sbbb
aaas...sbbb
aaas...sbbb
after
#@nonl
#@-node:ekr.20090121163905.710:after sel=2.3,5.8
#@-node:ekr.20090121163905.707:@test string-rectangle
#@+node:ekr.20090121163905.711:@test tabify
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.712:work
first line
line 1
	line a
		line b
line c
last line
#@-node:ekr.20090121163905.712:work
#@+node:ekr.20090121163905.713:before sel=1.0,7.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.713:before sel=1.0,7.0
#@+node:ekr.20090121163905.714:after sel=7.0,7.0
first line
line 1
	line a
		line b
line c
last line
#@-node:ekr.20090121163905.714:after sel=7.0,7.0
#@-node:ekr.20090121163905.711:@test tabify
#@+node:ekr.20090121163905.715:@test transpose-chars
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.716:work
frist line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.716:work
#@+node:ekr.20090121163905.717:before sel=1.2,1.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.717:before sel=1.2,1.2
#@+node:ekr.20090121163905.718:after sel=1.2,1.2
frist line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.718:after sel=1.2,1.2
#@-node:ekr.20090121163905.715:@test transpose-chars
#@+node:ekr.20090121163905.719:@test transpose-lines
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.720:work
line 1
first line
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.720:work
#@+node:ekr.20090121163905.721:before sel=2.2,2.2
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.721:before sel=2.2,2.2
#@+node:ekr.20090121163905.722:after sel=2.10,2.10
line 1
first line
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.722:after sel=2.10,2.10
#@-node:ekr.20090121163905.719:@test transpose-lines
#@+node:ekr.20090121163905.723:@test untabify
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.724:work
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.724:work
#@+node:ekr.20090121163905.725:before sel=1.0,7.0
first line
line 1
	line a
		line b
line c
last line
#@-node:ekr.20090121163905.725:before sel=1.0,7.0
#@+node:ekr.20090121163905.726:after sel=7.0,7.0
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.726:after sel=7.0,7.0
#@-node:ekr.20090121163905.723:@test untabify
#@+node:ekr.20090121163905.727:@test upcase-region
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')
#@nonl
#@+node:ekr.20090121163905.728:work
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.728:work
#@+node:ekr.20090121163905.729:before sel=3.0,4.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.729:before sel=3.0,4.0
#@+node:ekr.20090121163905.730:after sel=3.0,4.0
Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

SOME 90% OF ALL PRESIDENTIALLY DECLARED DISASTERS ARE WEATHER RELATED, LEADING TO AROUND 500 DEATHS PER YEAR AND NEARLY $14 BILLION IN DAMAGE. STORMREADY, A PROGRAM STARTED IN 1999 IN TULSA, OK, HELPS ARM AMERICA'S COMMUNITIES WITH THE COMMUNICATION AND SAFETY SKILLS NEEDED TO SAVE LIVES AND PROPERTY– BEFORE AND DURING THE EVENT. STORMREADY HELPS COMMUNITY LEADERS AND EMERGENCY MANAGERS STRENGTHEN LOCAL SAFETY PROGRAMS.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?
#@-node:ekr.20090121163905.730:after sel=3.0,4.0
#@-node:ekr.20090121163905.727:@test upcase-region
#@+node:ekr.20090121163905.731:@test upcase-word
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
assert g.app.unitTestDict.get('colorized')
#@nonl
#@+node:ekr.20090121163905.732:work
first line
line 1
    LINE a
        line b
line c
last line
#@-node:ekr.20090121163905.732:work
#@+node:ekr.20090121163905.733:before sel=3.7,3.7
first line
line 1
    line a
        line b
line c
last line
#@-node:ekr.20090121163905.733:before sel=3.7,3.7
#@+node:ekr.20090121163905.734:after sel=3.7,3.7
first line
line 1
    LINE a
        line b
line c
last line
#@-node:ekr.20090121163905.734:after sel=3.7,3.7
#@-node:ekr.20090121163905.731:@test upcase-word
#@+node:ekr.20090121163905.735:@test yank-rectangle
import leo.core.leoTest as leoTest
leoTest.runEditCommandTest(c,p)
#@nonl
#@+node:ekr.20090121163905.736:work
before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
#@nonl
#@-node:ekr.20090121163905.736:work
#@+node:ekr.20090121163905.737:before sel=2.3,5.6
before
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
aaaxxxbbb
after
#@nonl
#@-node:ekr.20090121163905.737:before sel=2.3,5.6
#@+node:ekr.20090121163905.738:after sel=2.3,5.6
before
aaaY1Ybbb
aaaY2Ybbb
aaaY3Ybbb
aaaY4Ybbb
after
#@nonl
#@-node:ekr.20090121163905.738:after sel=2.3,5.6
#@-node:ekr.20090121163905.735:@test yank-rectangle
#@+node:ekr.20090121163905.739:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

#@-node:ekr.20090121163905.739:@test zz restore the screen
#@-node:ekr.20090121163905.629: Commands M-Z
#@+node:ekr.20090121163905.740: Function tests
#@+node:ekr.20090121163905.741:@test capitalizeHelper
# TARGETWORD

w = c.frame.body.bodyCtrl

for (which,result) in (('cap','Targetword'),('low','targetword'),('up','TARGETWORD')):
    w.setInsertPoint(5)
    c.editCommands.capitalizeHelper(event=None,which=which,undoType=None)
    s = w.getAllText()
    word = s[2:12]
    assert word == result, 'Expected %s, got: %s' % (result,repr(word))
    i = w.getInsertPoint()
    assert i == 5, 'Expected 5, got: %d' % i
#@-node:ekr.20090121163905.741:@test capitalizeHelper
#@+node:ekr.20090121163905.742:@test crollHelper
ec = c.editCommands

for direction,extend in (('up',False),('down',False),('up',True),('down',True),):
    event = g.Bunch(widget=c.frame.body.bodyCtrl)
    ec.scrollHelper(event,direction,extend)

#@-node:ekr.20090121163905.742:@test crollHelper
#@+node:ekr.20090121163905.743:@test extendHelper
ec = c.editCommands ; w = c.frame.body.bodyCtrl

for i,j,python in (
    # ('1.0','4.5',False),
    (5,50,True),
):
    extend = True
    ec.moveSpot = None # It's hard to init this properly.
    ec.extendHelper(w,extend,j)
    i2,j2 = w.getSelectionRange()
    # print(i2,j2)
    #assert 0==i2, 'Expected i=%s, got %s' % (repr(i),repr(i2))
    #assert j==j2, 'Expected j=%s, got %s' % (repr(j),repr(j2))
#@-node:ekr.20090121163905.743:@test extendHelper
#@+node:ekr.20090121163905.744:@test findWordInLine
# targetWord

e = c.editCommands
k = c.k ; w = c.frame.body.bodyCtrl
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
k.setState('find-word',1)
for val in (True,False):
    e.oneLineFlag = val
    f = e.findWordInLine(event=None)
    i,j = w.getSelectionRange()
    assert i == 2, 'expected 2, got' % (i)
    # s = w.getAllText()
    # ch = s[i]
    # assert word == 'targetWord', 'got: %s' % word

#@-node:ekr.20090121163905.744:@test findWordInLine
#@+node:ekr.20090121163905.745:@test findWord
# start
# targetWord

e = c.editCommands
k = c.k ; w = c.frame.body.bodyCtrl
w.setInsertPoint(0)
k.arg = 't' # 'targetWord'
k.setState('find-word',1)
e.oneLineFlag = False
f = e.findWord(event=None)
i,j = w.getSelectionRange()
assert i == 10, 'expected 15, got %s' % (i)
#@-node:ekr.20090121163905.745:@test findWord
#@+node:ekr.20090121163905.746:@test helpForMinibuffer
c.helpCommands.helpForMinibuffer()
#@-node:ekr.20090121163905.746:@test helpForMinibuffer
#@+node:ekr.20090121163905.747:@test moveToHelper
ec = c.editCommands ; w = c.frame.body.bodyCtrl

for i,j,python in (
    #('1.0','4.5',False),
    (5,50,True),
):
    event = None ; extend = True ; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveToHelper (event,j,extend)
    i2,j2 = w.getSelectionRange()
    assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
    assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
    w.setSelectionRange(0,0,insert=None)
#@-node:ekr.20090121163905.747:@test moveToHelper
#@+node:ekr.20090121163905.748:@test moveUpOrDownHelper
ec = c.editCommands ; w = c.frame.body.bodyCtrl

for i,result,direction in (('5.8','4.8','up'),('5.8','6.8','down')):
    event = None ; extend = False; ec.moveSpot = None
    w.setInsertPoint(i)
    ec.moveUpOrDownHelper (event,direction,extend)
    i2,j2 = w.getSelectionRange()
    if 1:
        break
    else:
        assert i==i2, 'Expected %s, got %s' % (repr(i),repr(i2))
        assert j==j2, 'Expected %s, got %s' % (repr(j),repr(j2))
        w.setSelectionRange(0,0,insert=None)
#@-node:ekr.20090121163905.748:@test moveUpOrDownHelper
#@+node:ekr.20090121163905.749:@test scrollHelper
ec = c.editCommands

for direction,extend in (('up',False),('down',False),('up',True),('down',True),):
    event = g.Bunch(widget=c.frame.body.bodyCtrl)
    ec.scrollHelper(event,direction,extend)

#@-node:ekr.20090121163905.749:@test scrollHelper
#@+node:ekr.20090121163905.750:@test selfInsertCommand-1
@first # -*- coding: utf-8 -*-

try:
    ec = c.editCommands ; w = c.frame.body.bodyCtrl
    s = w.getAllText()

    # This strings tests unicode, paren matching, and auto-indentation.
    u = u'(a\u00c9\u03a9B\u3045\u4e7cz):\n' # '(aÉΩBぅ乼cz):\n'
    u = u'(pdq):\n'
    w.setInsertPoint(len(s))
    for char in u:
        event = g.Bunch(widget=w,char=char,keysym=None)
        ec.selfInsertCommand(event)
    result = w.getAllText()
    #g.trace('result',repr(result))
    assert result.endswith('    '),'result:%s' % repr(result) # Test of autocompleter.
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# end:
#@nonl
#@-node:ekr.20090121163905.750:@test selfInsertCommand-1
#@+node:ekr.20090121163905.751:@test selfInsertCommand-2 (replacing tabs)
try:
    ec = c.editCommands ; w = c.frame.body.bodyCtrl
    s = w.getAllText()
    w.setSelectionRange(len(s)-9,len(s)-6)
    event = g.Bunch(widget=w,char='\t',keysym=None)
    ec.selfInsertCommand(event)
    result = w.getAllText()
    # g.trace('result',repr(result))
    assert result.endswith('\n    abcdef'),'last line:%s' % repr(result.split('\n')[-1])
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

###abcdef
#@nonl
#@-node:ekr.20090121163905.751:@test selfInsertCommand-2 (replacing tabs)
#@+node:ekr.20090121163905.752:@test setMoveCol
w = c.frame.body.bodyCtrl
ec = c.editCommands

for spot,result in (('1.0',0),(5,5)):
    ec.setMoveCol(w,spot)
    assert ec.moveSpot == result
    assert ec.moveCol == result
#@-node:ekr.20090121163905.752:@test setMoveCol
#@-node:ekr.20090121163905.740: Function tests
#@+node:ekr.20090121163905.753: Typing
# These are mysteriously fragile tests, so they go first
#@+node:ekr.20090121164439.15888:@unit-tests
# The run-unit-tests commands copy all descendants
# of this node to dynamicUnitTest.leo.
#@nonl
#@+node:ekr.20090121163905.755:Test headline abc
#@-node:ekr.20090121163905.755:Test headline abc
#@-node:ekr.20090121164439.15888:@unit-tests
#@+node:ekr.20090121163905.754:@test make sure the window is visible (Make this the first test)
#@-node:ekr.20090121163905.754:@test make sure the window is visible (Make this the first test)
#@+node:ekr.20090121163905.756:Typing and undo tests
#@+node:ekr.20090121163905.757:@test return ends editing of headline
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

h = '@test return ends editing of headline'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
w.event_generate('<Return>')
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'
#@nonl
#@-node:ekr.20090121163905.757:@test return ends editing of headline
#@+node:ekr.20090121163905.758:@test editLabel selects entire headline
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = '@test editLabel selects entire headline'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
assert w
s = w.getAllText()
selectAll = c.config.getBool('select_all_text_when_editing_headlines')
# g.trace('editLabel selects entire headline',selectAll)
i,j = w.getSelectionRange()
if selectAll:
    assert i == 0 and j == len(s),'oops1: i: %d, j: %d' % (i,j)
else:
    assert i == len(s) and j == len(s),'oops2: i: %d, j: %d' % (i,j)
#@-node:ekr.20090121163905.758:@test editLabel selects entire headline
#@+node:ekr.20090121163905.759:@test paste at end of headline
trace = False ; verbose = False
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
if trace: print('='*20)
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
if trace: print ('focus 1',w2)
if trace: print ('*** w ***',w)
if 0: # The tkGui.set_focus now does an update to force the focus.
    w2 = g.app.gui.get_focus(c)
    if w != w2:
        print ('*** FAIL ***\nw: %s\nw2: %s' % (w,w2))
    assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    if trace: print('focus',w2)
# For the qt gui w is a wrapper and w.widget is the actual widget.

try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    if trace: print ('focus 1',w2)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    if 0: # Easiest.
        c.endEditing()
    else: # More thorough test.
        w.event_generate('<Return>')
        w.update()
    if 1:
        assert p.h == h + paste,'Expected: %s, got %s' % (
            h + paste,p.h)
finally:
    if trace: print('-'*20)
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.759:@test paste at end of headline
#@+node:ekr.20090121163905.760:@@@test typing and undo in headline - at end
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k

if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redrawAndEdit(p) # To make the node visible.
    w = c.edit_widget(p)
    # print('guiName',g.app.gui.guiName())
    try:
        assert w, 'oops1'
        wName = g.app.gui.widget_name(w)
        assert wName.startswith('head'),'w.name:%s' % wName
        w.setSelectionRange('end','end')
        w.event_generate('X')
        w.event_generate('Y')
        w.event_generate('Z')
        w.event_generate('<Return>')
        assert p.h == h + 'XYZ',(
            'oops2: expected: %s, got: %s' % (
                h + 'XYZ',p.h))
        if g.app.gui.guiName() != 'nullGui':
            assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
                c.undoer.undoMenuLabel)
        k.manufactureKeyPressForCommandName(w,'undo')
        if g.app.gui.guiName() != 'nullGui':
            assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
        assert p.h == h,'oops5 got: %s, expected: %s' % (
            p.h,h)
    finally:
        if 1:
            c.setHeadString(p,h) # Essential.
            c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.760:@@@test typing and undo in headline - at end
#@+node:ekr.20090121163905.761:@test paste and undo in headline - at end
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    w.event_generate('<Return>')
    assert p.h == h + paste,'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'oops3 got: %s' % p.h
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.761:@test paste and undo in headline - at end
#@+node:ekr.20090121163905.762:@test paste and undo in headline - with selection
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w, 'Null w'
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('1.1','1.2')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    w.event_generate('<Return>')
    assert p.h == h[0] + paste + h[2:]
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, 'head mismatch'
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.762:@test paste and undo in headline - with selection
#@+node:ekr.20090121163905.763:@@@test selecting new node retains typing in headline
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k

if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        w.event_generate('X')
        w.event_generate('Y')
        w.event_generate('Z')
        w.event_generate('<Return>')
        assert p.h == h + 'XYZ'
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h
    finally:
        if 1:
            c.setHeadString(p,h) # Essential.
            c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.763:@@@test selecting new node retains typing in headline
#@+node:ekr.20090121163905.764:@test paste from menu into body sticks
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

if c.k.defaultUnboundKeyAction == 'insert':
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p)
    c.bodyWantsFocusNow()
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    if 1: # New code calls pasteText directly.
        event = g.Bunch(widget=c.frame.body.bodyCtrl)
        c.frame.pasteText(event)
    else: # old code uses menu.invoke.
        # Post by hand.
        menu = c.frame.menu.getMenu('Edit')
        i = menu.index('Paste')
        menu.invoke(i)
    # Move around and and make sure it doesn't change.
    try:
        assert p.b == paste, 'paste1 failed'
        c.selectPosition(p.threadBack())
        assert p.b == paste, 'stick failed'
        c.selectPosition(p)
        assert p.b == paste, 'revisit failed'
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)
#@-node:ekr.20090121163905.764:@test paste from menu into body sticks
#@+node:ekr.20090121163905.765:@test paste from menu into headline sticks
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
if 1: # New code calls pasteText directly.
    event = g.Bunch(widget=w)
    c.frame.pasteText(event)
else:
    menu = c.frame.menu.getMenu('Edit')
    i = menu.index('Paste')
    menu.invoke(i)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.765:@test paste from menu into headline sticks
#@+node:ekr.20090121163905.766:@test paste from menu to body recolors the body
# Should be a comment# Should be a comment# Should be a comment# Should be a comment
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.bodyWantsFocusNow()
paste = '# Should be a comment'
g.app.gui.replaceClipboardWith(paste)
c.outerUpdate()
n = c.frame.body.colorizer.count
if 1:
    event = g.Bunch(widget=c.frame.body.bodyCtrl)
    c.frame.pasteText(event)
else:
    menu = c.frame.menu.getMenu('Edit')
    i = menu.index('Paste')
    menu.invoke(i)
# Move around and and make sure it doesn't change.
try:
    # There is no colorizer to test for wx.
    if g.app.gui.guiName() == 'tkinter':
        c.outerUpdate() # Force the coloring before doing the test.
        assert c.frame.body.colorizer.count > n, 'did not recolor text'
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.766:@test paste from menu to body recolors the body
#@+node:ekr.20090121163905.767:@@@test typing in headline recomputes width
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    # assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    w.setSelectionRange('end','end')
    n = w.getWidth()
    w.event_generate('X')
    w.event_generate('Y')
    w.event_generate('Z')
    w.update()
    if 1: # Easiest.
        c.endEditing()
    else: # More thorough test.
        w.event_generate('<Return>')
        w.update()
    assert w, 'fail 2'
    n2 = w.getWidth()
    if g.app.gui.guiName() == 'tkinter':
        assert n2 > n, '%s %s' % (n2,n)
    # g.trace(n,n2)
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.767:@@@test typing in headline recomputes width
#@+node:ekr.20090121163905.768:@test selecting new node retains paste in headline
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.768:@test selecting new node retains paste in headline
#@+node:ekr.20090121163905.769:@test typing in empty body text redraws the screen (and icon)
# This test is too flaky for Tk.
if g.app.gui.guiName() != 'tkinter':

    import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.selectPosition(p)
    c.bodyWantsFocusNow()
    c.redraw(p) # To make node visible
    n = c.frame.tree.redrawCount
    assert not p.b, 'oops1'
    try:
        # print('before insert a',c.currentPosition())
        assert p == c.currentPosition(),'position has changed!'
        c.frame.body.bodyCtrl.event_generate('a')
        assert p.b == 'a', 'expected "a", got: %s' % repr(p.b)
        if g.app.gui.guiName() != 'nullGui':
            n2 = c.frame.tree.redrawCount
            c.outerUpdate() # Force the coloring before doing the test.
            assert n2 == n + 1,'too many or too few redraws: expected 1: got: %d' % (n2-n)
    finally:
        if 1:
            c.setBodyString(p,'')
            c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.769:@test typing in empty body text redraws the screen (and icon)
#@+node:ekr.20090121163905.770:@test typing in non-empty body text does not redraw the screen
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.setBodyString(p,'a')
c.redraw(p) # To make node visible
# print ('after redraw_now')
c.bodyWantsFocusNow()
n = c.frame.tree.redrawCount
try:
    c.frame.body.bodyCtrl.event_generate('a')
    n2 = c.frame.tree.redrawCount
    assert n2 == n,'too many redraws: %d' % (n2-n)
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.770:@test typing in non-empty body text does not redraw the screen
#@+node:ekr.20090121163905.771:@test inserting a new node can be undone and redone
u = c.undoer
c.insertHeadline()
assert u.undoMenuLabel == 'Undo Insert Node',repr(c.undoMenuLabel)
c.undoer.undo()
assert u.redoMenuLabel == 'Redo Insert Node',repr(u.undoMenuLabel)
#@nonl
#@-node:ekr.20090121163905.771:@test inserting a new node can be undone and redone
#@+node:ekr.20090121163905.772:@test inserting a new node draws the screen exactly once
n = c.frame.tree.redrawCount
# print ('before')
c.insertHeadline()
c.outerUpdate() # Not actually needed, but should not matter.
# print ('after')

try:
    n2 = c.frame.tree.redrawCount
    assert n2 == n + 1,'redraws: %d' % (n2 - n)
finally:
    c.undoer.undo()
#@nonl
#@-node:ekr.20090121163905.772:@test inserting a new node draws the screen exactly once
#@+node:ekr.20090121163905.773:@test undoing insert node restores previous node's body text
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
body = 'This is a test'
c.setBodyString(p,body)

try:
    assert p.b == body
    c.insertHeadline()
    c.undoer.undo()
    assert p.b == body
finally:
    c.setBodyString(p,'')
#@nonl
#@-node:ekr.20090121163905.773:@test undoing insert node restores previous node's body text
#@+node:ekr.20090121163905.774:@test <Delete> key sticks in body
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
s = 'ABC'
c.setBodyString(p,s)
try:
    c.bodyWantsFocusNow()
    w = c.frame.body.bodyCtrl
    w.setInsertPoint(2)
    c.outerUpdate() # This fixed the problem.
    w.event_generate('<Delete>') # Calls c.outerUpdate()
    assert p.b == s[:-1],'oops1: expected "AB", got %s' % p.b
    c.selectPosition(p.threadBack())
    c.selectPosition(p)
    assert p.b == s[:-1],'oops2: expected "AB", got %s' % p.b
finally:
    if 1:
        c.setBodyString(p,'')
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.774:@test <Delete> key sticks in body
#@+node:ekr.20090121163905.775:@test <Delete> key sticks in headline
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
    # w.event_generate('X')
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.775:@test <Delete> key sticks in headline
#@+node:ekr.20090121163905.776:print end of typing and undo tests
print('\nEnd of typing and undo tests')
#@nonl
#@-node:ekr.20090121163905.776:print end of typing and undo tests
#@-node:ekr.20090121163905.756:Typing and undo tests
#@+node:ekr.20090121163905.777:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractAllHeadlines()
g.app.unitTestDict['restoreSelectedNode']=False

#@-node:ekr.20090121163905.777:@test zz restore the screen
#@-node:ekr.20090121163905.753: Typing
#@+node:ekr.20090121163905.778:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoEditCommands tests.')
#@nonl
#@-node:ekr.20090121163905.778:@test zz restore the screen
#@-node:ekr.20090121163905.299:leoEditCommands
#@+node:ekr.20090121163905.779:leoFileCommands
#@+node:ekr.20090121163905.780:@test fc.deleteFileWithMessage
fc=c.fileCommands
fc.deleteFileWithMessage('xyzzy','test')

if 0: # one-time test of es statements.
    fileName = 'fileName' ; kind = 'kind'
    g.es("read only",color="red")
    g.es("exception deleting %s file: %s" % (fileName,kind))
    g.es("exception deleting backup file:" + fileName)
#@-node:ekr.20090121163905.780:@test fc.deleteFileWithMessage
#@+node:ekr.20090121163905.781:@test minimal test of putTnodeList
fc = c.fileCommands
t = p.v.t
child = p.firstChild()
assert child,'no child'
grandChild = child.firstChild()
assert grandChild,'no grandChild'
assert not t.tnodeList,repr(t.tnodeList)

try:
    t.tnodeList = [t,child.v.t,grandChild.v.t]
    s = fc.putTnodeList(p.v)
    expected = ' tnodeList="ekr.20061001124008,ekr.20061001124008.1,ekr.20061001124008.2"'
    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    t.tnodeList = []
#@nonl
#@+node:ekr.20090121163905.782:child
#@+node:ekr.20090121163905.783:grandchild
#@-node:ekr.20090121163905.783:grandchild
#@-node:ekr.20090121163905.782:child
#@-node:ekr.20090121163905.781:@test minimal test of putTnodeList
#@+node:ekr.20090121163905.784:@test putDescendentTnodeUas
fc = c.fileCommands
child = p.firstChild()
grandChild = child.firstChild()
# Note: only tnodes can have unknown attributes.
child.v.t.unknownAttributes = {'unit_test_child':'abcd'}
grandChild.v.t.unknownAttributes = {'unit_test_grandchild':'wxyz'}

try:

    s = fc.putDescendentTnodeUas (p)

    expected = ' descendentTnodeUnknownAttributes="\
7d7100285514656b722e32303036313030313039313634372e3\
171017d71025514756e69745f746573745f6772616e64636869\
6c64710355047778797a7104735512656b722e3230303631303\
03130393136343771057d7106550f756e69745f746573745f63\
68696c647107550461626364710873752e"'

    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    del child.v.t.unknownAttributes
    del grandChild.v.t.unknownAttributes
#@nonl
#@+node:ekr.20090121163905.785:child
#@+node:ekr.20090121163905.786:grandChild
#@-node:ekr.20090121163905.786:grandChild
#@-node:ekr.20090121163905.785:child
#@-node:ekr.20090121163905.784:@test putDescendentTnodeUas
#@+node:ekr.20090121163905.787:@test putDescendentVnodeUas
fc = c.fileCommands
child = p.firstChild()
grandChild = child.firstChild()
child.v.unknownAttributes = {'unit_test_child':'abcd'}
grandChild.v.unknownAttributes = {'unit_test_grandchild':'wxyz'}

try:

    s = fc.putDescendentVnodeUas (p)

    expected = ' descendentVnodeUnknownAttributes="\
7d7100285503302e3071017d7102550f756e69745f746573745f\
6368696c6471035504616263647104735505302e302e3071057d\
71065514756e69745f746573745f6772616e646368696c647107\
55047778797a710873752e"'

    assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
finally:
    del child.v.unknownAttributes
    del grandChild.v.unknownAttributes
#@nonl
#@+node:ekr.20090121163905.788:child
#@+node:ekr.20090121163905.789:grandChild
#@-node:ekr.20090121163905.789:grandChild
#@-node:ekr.20090121163905.788:child
#@-node:ekr.20090121163905.787:@test putDescendentVnodeUas
#@+node:ekr.20090121163905.790:@test putUa
fc = c.fileCommands # self is a dummy
p.v.unknownAttributes = {'unit_test':'abcd'}
s = fc.putUnknownAttributes (p.v)
expected = ' unit_test="55046162636471002e"'
assert s == expected, 'expected: %s, got: %s' % (repr(expected),repr(s))
#@-node:ekr.20090121163905.790:@test putUa
#@+node:ekr.20090121163905.791:@test Select a node when file is first loaded
c.redraw(p) # To make node visible

c2 = c.new()
p2 = c2.p

try:
    # This fails, but it is possible to edit the headline.
    # assert c2.edit_widget(p2),'c2.edit_widget(p2) failed: %s' % repr(p2)
    assert p2,'p2 failed: %s' % repr(p2)
    # assert c.edit_widget(p),'c.edit_widget(p) failed: %s' % repr(p)
finally:
    c2.setChanged(False)
    c2.close()
#@nonl
#@-node:ekr.20090121163905.791:@test Select a node when file is first loaded
#@+node:ekr.20090121163905.792:@test write .leo file with @ignore node
assert p.firstChild(), 'no child node'
assert p.firstChild().b.startswith('@ignore'), 'No @ignore in child'
ok = c.fileCommands.write_Leo_file(
    'file-name',outlineOnlyFlag=True,toString=True,toOPML=False)
assert ok, 'error writing file'
count = 0
for line in g.splitLines(g.app.write_Leo_file_string):
    if line.find('@ignore') != -1:
        count += 1
assert count >=3, "not enough @ignore's in written file"
#@+node:ekr.20090121163905.793:child
@ignore # Test that this node gets written.
#@nonl
#@-node:ekr.20090121163905.793:child
#@-node:ekr.20090121163905.792:@test write .leo file with @ignore node
#@+node:ekr.20090121163905.794:@test p.archivedPosition
val = p.archivedPosition(root_p=p)
assert val == [0],'expected %s, got %s' % ([0],val)

i = 0
for z in p.parent().children_iter():
    val = z.archivedPosition(root_p=p.parent())
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,i],'expected %s, got %s'%([0,i],val)
    i += 1

i = 0
for z in p.firstChild().next().children_iter():
    val = z.archivedPosition(root_p=p)
    assert val == [0,1,i],'expected %s, got %s'%([0,1,i],val)
    i += 1
#@nonl
#@+node:ekr.20090121163905.795:first child
#@-node:ekr.20090121163905.795:first child
#@+node:ekr.20090121163905.796:second child
#@+node:ekr.20090121163905.797:grandChild
#@-node:ekr.20090121163905.797:grandChild
#@+node:ekr.20090121163905.798:grandChild 2
#@-node:ekr.20090121163905.798:grandChild 2
#@-node:ekr.20090121163905.796:second child
#@-node:ekr.20090121163905.794:@test p.archivedPosition
#@+node:ekr.20090121163905.799:@test fc.resolveArchivedPosition
child1 = p.firstChild()
child2 = p.firstChild().next()
grandChild1 = child2.firstChild()
grandChild2 = grandChild1.next()
greatGrandChild11 = grandChild1.firstChild()
greatGrandChild12 = greatGrandChild11.next()
greatGrandChild21 = grandChild2.firstChild()
greatGrandChild22 = greatGrandChild21.next()
root_v = p.v

table = (
    # Errors.
    (None,'-1'),
    (None,'1'),
    (None,'0.2'),
    (None,'0.0.0'),
    (None,'0.1.2'),
    # Valid.
    (root_v,'0'),
    (child1.v,'0.0'),
    (child2.v,'0.1'),
    (grandChild1.v,'0.1.0'),
    (greatGrandChild11.v,'0.1.0.0'),
    (greatGrandChild12.v,'0.1.0.1'),
    (grandChild2.v,'0.1.1'),
    (greatGrandChild21.v,'0.1.1.0'),
    (greatGrandChild22.v,'0.1.1.1'),
)

for v,archivedPosition in table:
    v2 = c.fileCommands.resolveArchivedPosition(archivedPosition,root_v)
    assert v == v2,'got %s, expected %s' % (v2,v)
#@+node:ekr.20090121163905.800:first child
#@-node:ekr.20090121163905.800:first child
#@+node:ekr.20090121163905.801:second child
#@+node:ekr.20090121163905.802:grandChild1
#@+node:ekr.20090121163905.803:greatGrandChild11
#@-node:ekr.20090121163905.803:greatGrandChild11
#@+node:ekr.20090121163905.804:greatGrandChild12
#@-node:ekr.20090121163905.804:greatGrandChild12
#@-node:ekr.20090121163905.802:grandChild1
#@+node:ekr.20090121163905.805:grandChild 2
#@+node:ekr.20090121163905.806:greatGrandChild21
#@-node:ekr.20090121163905.806:greatGrandChild21
#@+node:ekr.20090121163905.807:greatGrandChild22
#@-node:ekr.20090121163905.807:greatGrandChild22
#@-node:ekr.20090121163905.805:grandChild 2
#@-node:ekr.20090121163905.801:second child
#@-node:ekr.20090121163905.799:@test fc.resolveArchivedPosition
#@+node:ekr.20090121163905.808:@@test round-trip-uAs for @thin
root = p.firstChild()
uA = 'unknownAttributes'
tag = 'round-trip-u.uA'
ttag = 'round-trip-t.uA'
trace = False

if 0: # Set the uA's.
    for p2 in root.self_and_subtree_iter():
        p2.v.unknownAttributes = {tag: p2.h}
        p2.v.t.unknownAttributes = {ttag: p2.h}
else: # Test the uA's.
    # The root is a special case.
    v = root.v
    assert hasattr(v,uA),'no v.uA for %s' % v
    assert getattr(v,uA),'empty v.uA for %s' % v
    for p2 in root.self_and_subtree_iter():
        v = p2.v
        assert hasattr(v,uA),'no v.uA for %s' % v
        a = getattr(v,uA)
        d = {tag: v.h}
        if trace: print(d)
        assert a == d, 'expected v.uA: "%s", got "%s"' % (d,a)
        t = p2.v.t
        assert hasattr(t,uA),'no t.uA for %s' % p.h
        a = getattr(t,uA)
        d = {ttag: v.h}
        if trace: print(d)
        assert a == d, 'expected t.uA: "%s", got "%s"' % (d,a)
#@nonl
#@+node:ekr.20090121163905.809:@@thin uA_test_file.py
@others
#@nonl
#@+node:ekr.20090121163905.810:child1
pass
#@nonl
#@+node:ekr.20090121163905.811:grandChild1
pass
#@+node:ekr.20090121163905.812:greatGrandChild1
pass
#@nonl
#@-node:ekr.20090121163905.812:greatGrandChild1
#@-node:ekr.20090121163905.811:grandChild1
#@-node:ekr.20090121163905.810:child1
#@-node:ekr.20090121163905.809:@@thin uA_test_file.py
#@-node:ekr.20090121163905.808:@@test round-trip-uAs for @thin
#@+node:ekr.20090121163905.813:@@test round-trip-uAs for @shadow
root = p.firstChild()
uA = 'unknownAttributes'
tag = 'round-trip-u.uA'
ttag = 'round-trip-t.uA'
trace = False

if 0: # Set the uA's.
    for p2 in root.self_and_subtree_iter():
        p2.v.unknownAttributes = {tag: p2.h}
        p2.v.t.unknownAttributes = {ttag: p2.h}
else: # Test the uA's.
    # The root is a special case.
    v = root.v
    assert hasattr(v,uA),'no v.uA for %s' % v
    assert getattr(v,uA),'empty v.uA for %s' % v
    for p2 in root.self_and_subtree_iter():
        v = p2.v
        assert hasattr(v,uA),'no v.uA for %s' % v
        a = getattr(v,uA)
        d = {tag: v.h}
        if trace: print(d)
        assert a == d, 'expected v.uA: "%s", got "%s"' % (d,a)
        t = p2.v.t
        assert hasattr(t,uA),'no t.uA for %s' % p.h
        a = getattr(t,uA)
        d = {ttag: v.h}
        if trace: print(d)
        assert a == d, 'expected t.uA: "%s", got "%s"' % (d,a)
#@nonl
#@+node:ekr.20090121163905.814:@@shadow uA_test_shadow_file.py
@language python
@tabwidth -4
@others
#@+node:ekr.20090121163905.815:uA_test_shadow_file declarations
pass
pass
pass
#@-node:ekr.20090121163905.815:uA_test_shadow_file declarations
#@-node:ekr.20090121163905.814:@@shadow uA_test_shadow_file.py
#@-node:ekr.20090121163905.813:@@test round-trip-uAs for @shadow
#@+node:ekr.20090121163905.816:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoFileCommands tests.')
#@nonl
#@-node:ekr.20090121163905.816:@test zz restore the screen
#@-node:ekr.20090121163905.779:leoFileCommands
#@+node:ekr.20090121163905.817:leoFind
#@+node:ekr.20090121163905.818:@@test Find keeps focus in body & shows selected text
import leo.core.leoEditCommands as leoEditCommands
s = 'foo' ; bodyCtrl = c.frame.body.bodyCtrl

c.searchCommands.openFindTab()
h = c.searchCommands.findTabHandler
w = h.find_ctrl
w.setAllText(s)
c.bodyWantsFocus()
bodyCtrl.setInsertPoint(0)
c.searchCommands.findTabFindNext()
w = c.get_focus()
wName = g.app.gui.widget_name(w)

# in wxPython w != bodyCtrl (it's a proxy)
assert 'body' in wName, 'focus: %s = %s, expected %s = %s' % (
    w,wName,bodyCtrl,g.app.gui.widget_name(bodyCtrl))
#@nonl
#@-node:ekr.20090121163905.818:@@test Find keeps focus in body & shows selected text
#@+node:ekr.20090121163905.819:@test minbuffer find commands
table = (
    're-search-forward',
    're-search-backward',
    'search-forward',
    'search-backward',
    'word-search-forward',
    'word-search-backward',
)

for command in table:
    # This is not a full test.  We must use keyboardQuit here!
    c.k.simulateCommand(command)
    c.k.keyboardQuit(None)
#@nonl
#@-node:ekr.20090121163905.819:@test minbuffer find commands
#@+node:ekr.20090121163905.820:@test set find mode commands
table = (
    'set-find-everywhere',
    'set-find-node-only',
    'set-find-suboutline-only',
)

# show-find-tab-options     = Ctrl-o
# show-find-options         = o

for command in table:
    c.k.simulateCommand(command)
#@-node:ekr.20090121163905.820:@test set find mode commands
#@+node:ekr.20090121163905.821:@test show-find-options
c.k.simulateCommand('show-find-options')
#@nonl
#@-node:ekr.20090121163905.821:@test show-find-options
#@+node:ekr.20090121163905.822:@test togle find options commands
table = (
    # 'toggle-find-clone-find-all-option',
    'toggle-find-ignore-case-option',
    'toggle-find-in-body-option',
    'toggle-find-in-headline-option',
    'toggle-find-mark-changes-option',
    'toggle-find-mark-finds-option',
    'toggle-find-regex-option',
    'toggle-find-reverse-option',
    'toggle-find-word-option',
    'toggle-find-wrap-around-option',
)

for command in table:
    c.k.simulateCommand(command)
    c.k.simulateCommand(command)
#@-node:ekr.20090121163905.822:@test togle find options commands
#@+node:ekr.20090121163905.823:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoFind tests.')
#@nonl
#@-node:ekr.20090121163905.823:@test zz restore the screen
#@-node:ekr.20090121163905.817:leoFind
#@+node:ekr.20090121163905.824:leoFrame
#@+node:ekr.20090121163905.825:@test Add & Delete editor
body = c.frame.body
body.addEditor()
body.deleteEditor()
#@nonl
#@-node:ekr.20090121163905.825:@test Add & Delete editor
#@+node:ekr.20090121163905.826:@test Add editor, Delete leftmost editor

frame = c.frame ; body = frame.body
body.addEditor()

# Select the leftmost editor.
w = body.editorWidgets.get('1')
assert(w)
body.selectEditor(w)
body.bodyCtrl = frame.bodyCtrl = w
body.deleteEditor()
#@nonl
#@-node:ekr.20090121163905.826:@test Add editor, Delete leftmost editor
#@+node:ekr.20090121163905.827:@test c.frame.pasteText
# target.

try:
    w = c.frame.body.bodyCtrl
    s = w.getAllText()
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.Bunch(widget=w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

# end
#@nonl
#@-node:ekr.20090121163905.827:@test c.frame.pasteText
#@+node:ekr.20090121163905.828:@test c.frame.pasteText 2
# target

try:
    w = c.frame.body.bodyCtrl
    # print((w))
    s2 = p.b
    s = w.getAllText()
    assert s == s2, 'w.getAllText() != p.b: len(w)=%d, len(p)=%d' % (len(s),len(s2))
    w.setInsertPoint(len(s))
    c.k.previousSelection = 2,8
    event = g.Bunch(widget=w)
    c.frame.pasteText(event=event,middleButton=True)
    s2 = w.getAllText()
    assert len(s2) == len(s) + len('target')
finally:
    w.setAllText(s)
    p.setBodyString(s)
    # g.trace(repr(s))
    c.recolor()

# end5targettargettargettargettargettargettargettargettargettargettargettargettargettargettargettarget
#@nonl
#@-node:ekr.20090121163905.828:@test c.frame.pasteText 2
#@+node:ekr.20090121163905.829:@test leoBody.getInsertLines
# line 1
# line 2
# line 3

w = c.frame.body.bodyCtrl
index = 11 # in the second line.
w.setInsertPoint(index)
before,ins,after = c.frame.body.getInsertLines()
assert before == '# line 1\n','Got %s' % repr(before)
assert ins    == '# line 2\n','Got %s' % repr(ins)
assert after.startswith('# line 3\n')
assert after.endswith('# end.')

# end.
#@nonl
#@-node:ekr.20090121163905.829:@test leoBody.getInsertLines
#@+node:ekr.20090121163905.830:@test leoBody.getSelectionAreas
# line 1
# line 2
# line 3

w = c.frame.body.bodyCtrl
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
#@nonl
#@-node:ekr.20090121163905.830:@test leoBody.getSelectionAreas
#@+node:ekr.20090121163905.831:@test leoBody.getSelectionAreas & test
# line 1
# line 2
# line 3

w = c.frame.body.bodyCtrl
s = w.getAllText()
start,end = 11,15
w.setSelectionRange(start,end)
before,ins,after = c.frame.body.getSelectionAreas()
assert before == s[0:start],'Got %s' % repr(before)
assert ins    == s[start:end],'Got %s' % repr(ins)
assert after == s[end:]

# end.
#@nonl
#@-node:ekr.20090121163905.831:@test leoBody.getSelectionAreas & test
#@+node:ekr.20090121163905.832:@test tkBody.onClick
w = c.frame.body.bodyCtrl
y = 10
for x in xrange(0,100,10):
    event = g.Bunch(c=c,x=x,y=y,widget=w)
    c.frame.body.onClick(event)
#@-node:ekr.20090121163905.832:@test tkBody.onClick
#@+node:ekr.20090121163905.833:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoFrame tests.')
#@nonl
#@-node:ekr.20090121163905.833:@test zz restore the screen
#@-node:ekr.20090121163905.824:leoFrame
#@+node:ekr.20090121163905.834:leoGlobals
#@+node:ekr.20090121163905.835: Unicode tests
#@+node:ekr.20090121163905.836:@test open non-existent non-ascii directory
@first # -*- coding: utf-8 -*-

file = u'Ỗ'
path = g.os_path_join('Ỗ','Ỗ')
# print(g.toEncodedString(file,'utf-8'))

ok,frame = g.openWithFileName(path,c)

assert not ok and not frame
#@nonl
#@-node:ekr.20090121163905.836:@test open non-existent non-ascii directory
#@+node:ekr.20090121163905.837:@test can't open message in g.openWithFileName
@first # -*- coding: utf-8 -*-

old_c = c
filename = "testᾹ(U+1FB9: Greek Capital Letter Alpha With Macron)"
ok,frame = g.openWithFileName(filename,old_c)
assert(not ok)
#@nonl
#@-node:ekr.20090121163905.837:@test can't open message in g.openWithFileName
#@+node:ekr.20090121163905.838:@test atFile.printError
@first # -*- coding: utf-8 -*-

at = c.atFileCommands
at.errors = 0

s = u'La Pe\xf1a'
s = u'La Peña'
# s = u'Ă: U+0102: Latin Capital Letter A With Breve'
at.printError('test of at.printError:',s)
#@nonl
#@-node:ekr.20090121163905.838:@test atFile.printError
#@+node:ekr.20090121163905.839:@test % operator with unicode
@first # -*- coding: utf-8 -*-

s = "testᾹ(U+1FB9: Greek Capital Letter Alpha With Macron)"

s2 = 'test: %s' % s
#@nonl
#@-node:ekr.20090121163905.839:@test % operator with unicode
#@+node:ekr.20090121163905.840:@test failure to convert unicode characters to ascii
@first # -*- coding: utf-8 -*-

encoding = 'ascii'

s = '炰'

s2,ok = g.toUnicodeWithErrorCode(s,encoding)
assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s

s = u'炰'
s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@nonl
#@-node:ekr.20090121163905.840:@test failure to convert unicode characters to ascii
#@+node:ekr.20090121163905.841:@test of round-tripping toUnicode & toEncodedString
@first # -*- coding: utf-8 -*-

for s,encoding in (
    ('a',    'utf-8'),
    ('a',    'ascii'),
    ('äöü',  'utf-8'),
    ('äöü',  'mbcs'),
    ('炰',    'utf-8'),
    ('炰',    'mbcs'),
):
    if g.isValidEncoding(encoding):
        s2,ok = g.toUnicodeWithErrorCode(s,encoding)
        assert ok, 'toUnicodeWithErrorCode fails for %s' %s
        s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
        assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
        assert s3 == s, 'Round-trip one fails for %s' %s

        s2 = g.toUnicode(s,encoding)
        s3 = g.toEncodedString(s2,encoding)
        assert s3 == s, 'Round-trip two fails for %s' %s
#@nonl
#@-node:ekr.20090121163905.841:@test of round-tripping toUnicode & toEncodedString
#@+node:ekr.20090121163905.842:@test failure with ascii encodings
@first # -*- coding: utf-8 -*-

encoding = 'ascii'

s = '炰'
s2,ok = g.toUnicodeWithErrorCode(s,encoding)
assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s

s = u'炰'
s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@-node:ekr.20090121163905.842:@test failure with ascii encodings
#@+node:ekr.20090121163905.843:@test round trip toUnicode toEncodedString
@first # -*- coding: utf-8 -*-

table = [
    ('a',    'utf-8'),
    ('a',    'ascii'),
    ('äöü',  'utf-8'),
    ('äöü',  'mbcs'),
    ('炰',   'utf-8'),
]

import sys

if sys.platform.startswith('win'):
    data = '炰','mbcs'
    table.append(data)

for s,encoding in table:
    if g.isValidEncoding(encoding):
        s2,ok = g.toUnicodeWithErrorCode(s,encoding)
        assert ok, 'toUnicodeWithErrorCode fails for %s' %s
        s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
        assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
        assert s3 == s, 'Round-trip one failed for %s' %s

        s2 = g.toUnicode(s,encoding)
        s3 = g.toEncodedString(s2,encoding)
        assert s3 == s, 'Round-trip two failed for %s' %s
#@nonl
#@-node:ekr.20090121163905.843:@test round trip toUnicode toEncodedString
#@-node:ekr.20090121163905.835: Unicode tests
#@+node:ekr.20090121163905.844:@test CheckVersionToInt
assert g.CheckVersionToInt('12') == 12,'fail 1'
assert g.CheckVersionToInt('2a5') == 2, 'fail 2'
assert g.CheckVersionToInt('b2') == 0, 'fail 3'
#@nonl
#@-node:ekr.20090121163905.844:@test CheckVersionToInt
#@+node:ekr.20090121163905.845:@test g.cantImport returns None
assert(g.cantImport("xyzzy","during unit testing") is None)
#@nonl
#@-node:ekr.20090121163905.845:@test g.cantImport returns None
#@+node:ekr.20090121163905.846:@test g.checkVersion
# for condition in ('<','<=','>','>='):

for v1,condition,v2 in (
    ('8.4.12','>','8.4.3'),
    ('1','==','1.0'),
    ('2','>','1'),
    ('1.2','>','1'),
    ('2','>','1.2.3'),
    ('1.2.3','<','2'),
    ('1','<','1.1'),
):
    assert g.CheckVersion(v1,v2,condition=condition,trace=False)
#@nonl
#@-node:ekr.20090121163905.846:@test g.checkVersion
#@+node:ekr.20090121163905.847:@test g.convertPythonIndexToRowCol
s1 = 'abc\n\np\nxy'
table1 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too many.
    (10,(3,2)), # Two too many.
)
s2 = 'abc\n\np\nxy\n'
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One too many.
    (11,(4,0)), # Two too many.
)
s3 = 'ab' # Test special case.  This was the cause of off-by-one problems.
table3 = (
    (-1,(0,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)), # One too many.
    (3,(0,3)), # Two too many.
)

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        row,col = g.convertPythonIndexToRowCol(s,i)
        assert row == result[0], 'i: %d, expected row %d, got %d' % (i,result[0],row)
        assert col == result[1], 'i: %d, expected col %d, got %d' % (i,result[1],col)
#@-node:ekr.20090121163905.847:@test g.convertPythonIndexToRowCol
#@+node:ekr.20090121163905.848:@test g.convertRowColToPythonIndex
s1 = 'abc\n\np\nxy'
s2 = 'abc\n\np\nxy\n'
table1 = (
    (0,(-1,0)), # One too small.
    (0,(0,0)),
    (1,(0,1)),
    (2,(0,2)),
    (3,(0,3)), # The newline ends a row.
    (4,(1,0)),
    (5,(2,0)),
    (6,(2,1)),
    (7,(3,0)),
    (8,(3,1)),
    (9,(3,2)), # One too large.
)
table2 = (
    (9,(3,2)),
    (10,(4,0)), # One two many.
)
for s,table in ((s1,table1),(s2,table2)):
    for i,data in table:
        row,col = data
        result = g.convertRowColToPythonIndex(s,row,col)
        assert i == result, 'row: %d, col: %d, expected: %d, got: %s' % (row,col,i,result)
#@nonl
#@-node:ekr.20090121163905.848:@test g.convertRowColToPythonIndex
#@+node:ekr.20090121163905.849:@test g.create_temp_file
import types

theFile,theFileName = g.create_temp_file()

assert type(theFile) == types.FileType, 'not file type'
assert type(theFileName) in (types.StringType, types.UnicodeType), 'not string type'
#@-node:ekr.20090121163905.849:@test g.create_temp_file
#@+node:ekr.20090121163905.850:@test g.es_exception
if c.config.redirect_execute_script_output_to_log_pane:
    pass # Test doesn't work when redirection is on.
else:
    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@-node:ekr.20090121163905.850:@test g.es_exception
#@+node:ekr.20090121163905.851:@test g.es_trace
@first # -*- coding: utf-8 -*-

if 0: # Not usually enabled.
    g.es_trace('\ntest of es_trace: Ă',color='red')
#@-node:ekr.20090121163905.851:@test g.es_trace
#@+node:ekr.20090121163905.852:@test g.get_directives_dict
# This will work regardless of where this method is.
@language python
@tabwidth -4
# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.
@pagewidth 120

d = c.atFileCommands.scanAllDirectives(p)

assert d.get('language') == 'python'
assert d.get('tabwidth') == -4
# assert d.get('path').endswith('xyzzy')
assert d.get('pagewidth') == 120
#@-node:ekr.20090121163905.852:@test g.get_directives_dict
#@+node:ekr.20090121163905.853:@test g.getLine
s = 'a\ncd\n\ne'

for i,result in (
    (-1,(0,2)), # One too few.
    (0,(0,2)),(1,(0,2)),
    (2,(2,5)),(3,(2,5)),(4,(2,5)),
    (5,(5,6)),
    (6,(6,7)),
    (7,(6,7)), # One too many.
):
    j,k = g.getLine(s,i)
    assert (j,k) == result, 'i: %d, expected %d,%d, got %d,%d' % (i,result[0],result[1],j,k)
#@nonl
#@-node:ekr.20090121163905.853:@test g.getLine
#@+node:ekr.20090121163905.854:@test g.getScript strips crlf
script = g.getScript(c,p) # This will get the text of this node.
assert script.find('\r\n') == -1, repr(script)
#@-node:ekr.20090121163905.854:@test g.getScript strips crlf
#@+node:ekr.20090121163905.855:@test g.getWord
s = 'abc xy_z5 pdq'
i,j = g.getWord(s,5)
assert s[i:j] == 'xy_z5','got %s' % s[i:j]
#@-node:ekr.20090121163905.855:@test g.getWord
#@+node:ekr.20090121163905.856:@test g.pdb
import sys

# Not a good unit test; it probably will never fail.
def aFunction(): pass
assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)

class myStdout:
    def write(self,s):
        pass # g.es('From pdb:',s)

class myStdin:
    def readline (self):
        return 'c' # Return 'c' (continue) for all requests for input.

def restore():
    sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__

try:
    sys.stdin = myStdin() # Essential
    sys.stdout=myStdout() # Optional
    g.pdb()
    restore()
    # assert False,'test of reraising'
except Exception:
    restore()
    raise
#@-node:ekr.20090121163905.856:@test g.pdb
#@+node:ekr.20090121163905.857:@test g.removeExtraLws
for s,expected in (
    (' a\n b\n c', 'a\nb\nc'),
    (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
):
    result = g.removeExtraLws(s,c.tab_width)
    assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
        repr(s),repr(expected),repr(result))
#@-node:ekr.20090121163905.857:@test g.removeExtraLws
#@+node:ekr.20090121163905.858:@test g.reportBadChars
@first # -*- coding: utf-8 -*-

for s,encoding in (
    ('aĂbĂ',  'ascii'),
    (u'aĂbĂ', 'ascii'),
    ('炰',    'ascii'),
    (u'炰',   'ascii'),

    ('aĂbĂ',  'utf-8'),
    (u'aĂbĂ', 'utf-8'),
    ('炰',    'utf-8'),
    (u'炰',   'utf-8'),
):

    g.reportBadChars(s,encoding)
#@-node:ekr.20090121163905.858:@test g.reportBadChars
#@+node:ekr.20090121163905.859:@test g.skip_line
s = 'a\n\nc'

for i,result in (
    (-1,2), # One too few.
    (0,2),(1,2),
    (2,3),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
#@nonl
#@-node:ekr.20090121163905.859:@test g.skip_line
#@+node:ekr.20090121163905.860:@test g.skip_to_end_of_line
s = 'a\n\nc'

for i,result in (
    (-1,1), # One too few.
    (0,1),(1,1),
    (2,2),
    (3,4),
    (4,4), # One too many.
):
    j = g.skip_to_end_of_line(s,i)
    assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
#@nonl
#@-node:ekr.20090121163905.860:@test g.skip_to_end_of_line
#@+node:ekr.20090121163905.861:@test g.skip_to_start_of_line
s1 = 'a\n\nc'
table1 = (
    (-1,0), # One too few.
    (0,0),(1,0),
    (2,2),
    (3,3),
    (4,4), # One too many.
)
s2 = 'a\n'
table2 = ((1,0),(2,2)) # A special case at end.

for s,table in ((s1,table1),(s2,table2)):
    for i,result in table:
        j = g.skip_to_start_of_line(s,i)
        assert j == result, 'i: %d, expected %d, got %d' % (i,result,j)
#@-node:ekr.20090121163905.861:@test g.skip_to_start_of_line
#@+node:ekr.20090121163905.862:@test g.utils_remove
import os

exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)

assert not exists(path)
assert not g.utils_remove(path,verbose=False)

f = file(path,'w')
f.write('test')
f.close()

assert exists(path)
assert g.utils_remove(path,verbose=True)
assert not exists(path)
#@nonl
#@-node:ekr.20090121163905.862:@test g.utils_remove
#@+node:ekr.20090121163905.863:@test g.utils_rename
import os

exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert g.utils_rename(c,path,path2,verbose=True)
assert exists(path2)
f = file(path2)
s = f.read()
f.close()
# print('Contents of %s: %s' % (path2,s))
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)
#@nonl
#@-node:ekr.20090121163905.863:@test g.utils_rename
#@+node:ekr.20090121163905.864:@test pre-definition of g in scripts
# print(g.listToString(dir()))

for ivar in ('c','g','p'):
    assert ivar in dir()

assert hasattr(g.app,'tkEncoding')
#@nonl
#@-node:ekr.20090121163905.864:@test pre-definition of g in scripts
#@+node:ekr.20090121163905.865:Directives, new
#@+node:ekr.20090121163905.866:@test c.scanAllDirectives
@language python
@comment a b c
    # @comment must follow @language
@tabwidth -4
@pagewidth 72
@encoding utf-8
@lineending crlf

d = c.scanAllDirectives(p)
# print g.dictToString(d)

table = (
    ('delims', ('a','b','c'),),
    ('encoding','utf-8'),
    ('language','python'),
    ('lineending','\r\n'),
    ('pagewidth',72),
    ('tabwidth',-4),
)

for kind,expected in table:
    got = d.get(kind)
    assert got == expected, 'kind: %s, expected %s, got %s' % (
        kind,repr(expected),repr(got))
#@-node:ekr.20090121163905.866:@test c.scanAllDirectives
#@+node:ekr.20090121163905.867:@test c.scanAtRootDirectives root-code
@root-code

aList = g.get_directives_dict_list(p)
s = c.scanAtRootDirectives(aList)

assert s == 'code',repr(s)
#@nonl
#@-node:ekr.20090121163905.867:@test c.scanAtRootDirectives root-code
#@+node:ekr.20090121163905.868:@test c.scanAtRootDirectives root-doc
@root-doc

aList = g.get_directives_dict_list(p)
s = c.scanAtRootDirectives(aList)

assert s == 'doc',repr(s)
#@nonl
#@-node:ekr.20090121163905.868:@test c.scanAtRootDirectives root-doc
#@+node:ekr.20090121163905.869:@test g.get_directives_dict
@language python
@comment a b c
    # @comment must follow @language.
@tabwidth -8
@pagewidth 72
@encoding utf-8

# @path xyzzy # Creates folder called xyzzy: interferes with other unit tests.

d = g.get_directives_dict(p)

assert d.get('_p') == p
assert d.get('language') == 'python'
assert d.get('tabwidth') == '-8'
assert d.get('pagewidth') == '72'
assert d.get('encoding') == 'utf-8'
assert d.get('comment') == 'a b c'
# assert d.get('path').endswith('xyzzy')
#@-node:ekr.20090121163905.869:@test g.get_directives_dict
#@+node:ekr.20090121163905.870:@test g.scanAtHeaderDirectives header
@header

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
#@-node:ekr.20090121163905.870:@test g.scanAtHeaderDirectives header
#@+node:ekr.20090121163905.871:@test g.scanAtHeaderDirectives noheader
@noheader

aList = g.get_directives_dict_list(p)
g.scanAtHeaderDirectives(aList)
#@-node:ekr.20090121163905.871:@test g.scanAtHeaderDirectives noheader
#@+node:ekr.20090121163905.872:@test g.scanAtLineendingDirectives cr
@lineending cr

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\r'
#@-node:ekr.20090121163905.872:@test g.scanAtLineendingDirectives cr
#@+node:ekr.20090121163905.873:@test g.scanAtLineendingDirectives crlf
@lineending crlf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)
# print ('@lineending: %s'%repr(s))

assert s == '\r\n'
#@-node:ekr.20090121163905.873:@test g.scanAtLineendingDirectives crlf
#@+node:ekr.20090121163905.874:@test g.scanAtLineendingDirectives lf
@lineending lf

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
#@-node:ekr.20090121163905.874:@test g.scanAtLineendingDirectives lf
#@+node:ekr.20090121163905.875:@test g.scanAtLineendingDirectives nl
@lineending nl

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

assert s == '\n'
#@-node:ekr.20090121163905.875:@test g.scanAtLineendingDirectives nl
#@+node:ekr.20090121163905.876:@test g.scanAtLineendingDirectives platform
@lineending platform

import sys

aList = g.get_directives_dict_list(p)
s = g.scanAtLineendingDirectives(aList)

if sys.platform.startswith('win'):
    assert s == '\r\n'
else:
    assert s == '\n'
#@-node:ekr.20090121163905.876:@test g.scanAtLineendingDirectives platform
#@+node:ekr.20090121163905.877:@test g.scanAtPagewidthDirectives -40
@pagewidth -40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

assert n is None
#@nonl
#@-node:ekr.20090121163905.877:@test g.scanAtPagewidthDirectives -40
#@+node:ekr.20090121163905.878:@test g.scanAtPagewidthDirectives 40
@pagewidth 40

aList = g.get_directives_dict_list(p)
n = g.scanAtPagewidthDirectives(aList)

assert n == 40
#@nonl
#@-node:ekr.20090121163905.878:@test g.scanAtPagewidthDirectives 40
#@+node:ekr.20090121163905.879:@test g.scanAtPathDirectives ../test/unittest/at-path-test1.py
aList = g.get_directives_dict_list(p.firstChild())
s = c.scanAtPathDirectives(aList,force=True)
end = g.os_path_normpath(r'leo/test')

assert s.endswith(end),repr(s)
#@nonl
#@+node:ekr.20090121163905.880:@file ../test/unittest/at-path-test1.py
@language python
# unittest/at-path-test1.py 
#@nonl
#@-node:ekr.20090121163905.880:@file ../test/unittest/at-path-test1.py
#@-node:ekr.20090121163905.879:@test g.scanAtPathDirectives ../test/unittest/at-path-test1.py
#@+node:ekr.20090121163905.881:@test g.scanAtPathDirectives @path ../test/unittest @file at-path-test2.py
grandChild = p.firstChild().firstChild()
aList = g.get_directives_dict_list(grandChild)
s = c.scanAtPathDirectives(aList,force=True)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)
#@nonl
#@+node:ekr.20090121163905.882:@path ../test/unittest
#@+node:ekr.20090121163905.883:@file at-path-test2.py
@language python
# unittest/at-path-test2.py
#@nonl
#@-node:ekr.20090121163905.883:@file at-path-test2.py
#@-node:ekr.20090121163905.882:@path ../test/unittest
#@-node:ekr.20090121163905.881:@test g.scanAtPathDirectives @path ../test/unittest @file at-path-test2.py
#@+node:ekr.20090121163905.884:@test g.scanAtPathDirectives @path ../test @path unittest @file at-path-test3.py
greatGrandChild = p.firstChild().firstChild().firstChild()
aList = g.get_directives_dict_list(greatGrandChild)
s = c.scanAtPathDirectives(aList,force=True)
end = g.os_path_normpath(r'leo/test/unittest')

assert s.endswith(end),repr(s)
#@nonl
#@+node:ekr.20090121163905.885:@path ../test
#@+node:ekr.20090121163905.886:@path unittest
#@+node:ekr.20090121163905.887:@file at-path-test3.py
@language python
# unittest/at-path-test3.py 
#@nonl
#@-node:ekr.20090121163905.887:@file at-path-test3.py
#@-node:ekr.20090121163905.886:@path unittest
#@-node:ekr.20090121163905.885:@path ../test
#@-node:ekr.20090121163905.884:@test g.scanAtPathDirectives @path ../test @path unittest @file at-path-test3.py
#@+node:ekr.20090121163905.888:@test g.scanAtTabwidthDirectives +6
@tabwidth 6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == 6
#@nonl
#@-node:ekr.20090121163905.888:@test g.scanAtTabwidthDirectives +6
#@+node:ekr.20090121163905.889:@test g.scanAtTabwidthDirectives -6
@tabwidth -6

aList = g.get_directives_dict_list(p)
n = g.scanAtTabwidthDirectives(aList)

assert n == -6
#@nonl
#@-node:ekr.20090121163905.889:@test g.scanAtTabwidthDirectives -6
#@+node:ekr.20090121163905.890:@test g.scanAtWrapDirectives nowrap
@nowrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is False,repr(s)
#@nonl
#@-node:ekr.20090121163905.890:@test g.scanAtWrapDirectives nowrap
#@+node:ekr.20090121163905.891:@test g.scanAtWrapDirectives wrap
@wrap

aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is True,repr(s)
#@nonl
#@-node:ekr.20090121163905.891:@test g.scanAtWrapDirectives wrap
#@+node:ekr.20090121163905.892:@test g.scanAtWrapDirectives wrap
aList = g.get_directives_dict_list(p)
s = g.scanAtWrapDirectives(aList)

assert s is None,repr(s)
#@nonl
#@-node:ekr.20090121163905.892:@test g.scanAtWrapDirectives wrap
#@-node:ekr.20090121163905.865:Directives, new
#@+node:ekr.20090121163905.893:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoGlobals tests.')
#@nonl
#@-node:ekr.20090121163905.893:@test zz restore the screen
#@-node:ekr.20090121163905.834:leoGlobals
#@+node:ekr.20090121163905.894:leoGui
#@+node:ekr.20090121163905.895:@test w.toGui/PythonIndex
w = c.frame.body.bodyCtrl
s = w.getAllText()

for i in xrange(len(s)):
    i2 = w.toGuiIndex(i)
    i3 = w.toPythonIndex(i2)
    assert(i3==i)
#@-node:ekr.20090121163905.895:@test w.toGui/PythonIndex
#@+node:ekr.20090121163905.896:@test w.toGuiIndex (test2)
#ab
#

w = c.frame.body.bodyCtrl

# This test applies only to tkinter indices.
if g.app.gui.guiName() == 'tkinter':

    table = (
        (-1,'1.0'), # One too small.
        (0,'1.0'),
        (1,'1.1'),
        (2,'1.2'),
        (3,'1.3'), # The newline ends a row.
        (4,'2.0'),
        (5,'2.1'),
    )

    for i,expected in table:
        result = w.toGuiIndex(i)
        assert result == expected,'toGuiIndex(i): %s, expected: %s, got: %s' % (i,expected,result)
#@nonl
#@-node:ekr.20090121163905.896:@test w.toGuiIndex (test2)
#@+node:ekr.20090121163905.897:@test leoTextWidget
if g.app.gui.guiName() == 'tkinter':

    import leo.core.leoPlugins as leoPlugins
    tkGui = leoPlugins.loadOnePlugin ('tkGui',verbose=False)
    import Tkinter as Tk
    w = tkGui.leoTkTextWidget()
    w.setAllText('abcdef\n')
    s = w.getAllText()
    assert s == 'abcdef\n'
    s1 = w.get(0,len(s))
    assert s1 == 'abcdef\n'
    w.delete(0,len(s))
    assert len(w.getAllText()) == 0
    w.setAllText('')
    w.insert(0,'abcdef\n')
    s = w.getAllText()
    assert s == 'abcdef\n','got: %s' % repr(s)
    w.setInsertPoint(2)
    i = w.getInsertPoint()
    assert i == 2
    w.setSelectionRange(2,4)
    assert w.hasSelection()
    i,j = w.getSelectionRange()
    assert i==2 and j==4
    s3 = w.getSelectedText()
    assert s3 == 'cd'
    w.deleteTextSelection()
    s4 = w.getAllText()
    assert s4 == 'abef\n'
    w.selectAllText()
    i,j = w.getSelectionRange()
    assert i==0 and j==5,'getSelectionRange failed: i=%d,j=%d' % (i,j)
    w.replace(0,3,'wxyz')
    s5 = w.getAllText()
    assert s5 == 'wxyzf\n','getAllText failed'
    w.flashCharacter(3)
    i = w.xyToGuiIndex(0,0)
    assert i == '1.0','wxToGuiIndex failed'
    i = w.xyToPythonIndex(0,0)
    assert i == 0
    w.mark_set('insert','1.3'),'xyToPythonIndex failed'
    i = w.getInsertPoint()
    assert i == 3
    w.tag_add('test',4,6)
    aTuple = w.tag_ranges('test')
    assert aTuple == (4,6),'tag_add failed: %s' % aTuple
#@-node:ekr.20090121163905.897:@test leoTextWidget
#@+node:ekr.20090121163905.898:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoGui tests.')
#@nonl
#@-node:ekr.20090121163905.898:@test zz restore the screen
#@-node:ekr.20090121163905.894:leoGui
#@+node:ekr.20090121163905.899:leoImport
#@+node:ekr.20090121163905.900: Export tests
@language python
@tabwidth -4
#@nonl
#@+node:ekr.20090121163905.901:@suite Export tests
# Create unit tests in g.app.scriptDict["suite"]


import unittest
import leo.core.leoTest as leoTest

@others

suite = leoTest.makeImportExportSuite(c,"exportTests",doImport=False)

g.app.scriptDict['suite'] = suite
#@nonl
#@-node:ekr.20090121163905.901:@suite Export tests
#@+node:ekr.20090121163905.902:exportTests
@language plain
#@nonl
#@+node:ekr.20090121163905.903:tempNode
#@-node:ekr.20090121163905.903:tempNode
#@+node:ekr.20090121163905.904:exportHeadlines
#@+node:ekr.20090121163905.905:dialog
saveFileDialog
test\\unittest\\output\\exportHeadlines.txt
#@nonl
#@-node:ekr.20090121163905.905:dialog
#@-node:ekr.20090121163905.904:exportHeadlines
#@+node:ekr.20090121163905.906:flattenOutline
#@+node:ekr.20090121163905.907:dialog
saveFileDialog
test\\unittest\\output\\flattenOutline.txt
#@nonl
#@-node:ekr.20090121163905.907:dialog
#@-node:ekr.20090121163905.906:flattenOutline
#@+node:ekr.20090121163905.908:weave
#@+node:ekr.20090121163905.909:dialog
saveFileDialog
test\\unittest\\output\\weave.txt
#@nonl
#@-node:ekr.20090121163905.909:dialog
#@-node:ekr.20090121163905.908:weave
#@+node:ekr.20090121163905.910:outlineToNoweb
#@+node:ekr.20090121163905.911:dialog
saveFileDialog
test\\unittest\\output\\outlineToNoweb.txt
#@nonl
#@-node:ekr.20090121163905.911:dialog
#@-node:ekr.20090121163905.910:outlineToNoweb
#@+node:ekr.20090121163905.912:outlineToCWEB
#@+node:ekr.20090121163905.913:dialog
saveFileDialog
test\\unittest\\output\\outlineToCweb.txt
#@nonl
#@-node:ekr.20090121163905.913:dialog
#@-node:ekr.20090121163905.912:outlineToCWEB
#@-node:ekr.20090121163905.902:exportTests
#@-node:ekr.20090121163905.900: Export tests
#@+node:ekr.20090121163905.914: Import tests
#@+node:ekr.20090121163905.915:@suite Import tests
# Create unit tests in g.app.scriptDict["suite"]

import unittest
import leo.core.leoTest as leoTest

@others

suite = leoTest.makeImportExportSuite(c,"importTests",doImport=True)

g.app.scriptDict['suite'] = suite
#@nonl
#@-node:ekr.20090121163905.915:@suite Import tests
#@+node:ekr.20090121163905.916:importTests
@language plain
#@nonl
#@+node:ekr.20090121163905.917:tempNode
#@-node:ekr.20090121163905.917:tempNode
#@+node:ekr.20090121163905.918:importAtRoot
#@+node:ekr.20090121163905.919:dialog
openFileDialog
test\\unittest\\perfectImport\\formatter.py
#@nonl
#@-node:ekr.20090121163905.919:dialog
#@-node:ekr.20090121163905.918:importAtRoot
#@+node:ekr.20090121163905.920:importDerivedFile
#@+node:ekr.20090121163905.921:dialog
openFileDialog
core\\runLeo.py
#@nonl
#@-node:ekr.20090121163905.921:dialog
#@-node:ekr.20090121163905.920:importDerivedFile
#@+node:ekr.20090121163905.922:importNowebFiles
#@+node:ekr.20090121163905.923:dialog
openFileDialog
test\\unittest\\input\\noweave.nw.txt
#@nonl
#@-node:ekr.20090121163905.923:dialog
#@-node:ekr.20090121163905.922:importNowebFiles
#@+node:ekr.20090121163905.924:importFlattenedOutline
#@+node:ekr.20090121163905.925:dialog
openFileDialog
test\\unittest\\input\\flat.txt
#@nonl
#@-node:ekr.20090121163905.925:dialog
#@-node:ekr.20090121163905.924:importFlattenedOutline
#@+node:ekr.20090121163905.926:importCWEBFiles
#@+node:ekr.20090121163905.927:dialog
openFileDialog
test\\unittest\\input\\cweave.w
#@nonl
#@-node:ekr.20090121163905.927:dialog
#@-node:ekr.20090121163905.926:importCWEBFiles
#@+node:ekr.20090121163905.928:removeSentinels
#@+node:ekr.20090121163905.929:dialog
openFileDialog
test\\unittest\\input\\testLeoAtFile.py
#@nonl
#@-node:ekr.20090121163905.929:dialog
#@-node:ekr.20090121163905.928:removeSentinels
#@+node:ekr.20090121163905.930:importAtFile
#@+node:ekr.20090121163905.931:dialog
openFileDialog
test\\unittest\\perfectImport\\formatter.py
#@nonl
#@-node:ekr.20090121163905.931:dialog
#@-node:ekr.20090121163905.930:importAtFile
#@-node:ekr.20090121163905.916:importTests
#@-node:ekr.20090121163905.914: Import tests
#@+node:ekr.20090121163905.932: Tests of @auto
@tabwidth -4
@language python
#@nonl
#@+node:ekr.20090121163905.933:C tests
#@+node:ekr.20090121163905.934:@test c class 1
fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.934:@test c class 1
#@+node:ekr.20090121163905.935:@test c class--underindented line
fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
# an underindented line.
        a = 2 ;
    }

    # This should go with the next function.

    char bar (float c) {
        ;
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 1
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.935:@test c class--underindented line
#@+node:ekr.20090121163905.936:@test defaultImporter
fileName = p.h

s = '''\
class cTestClass1 {

    int foo (int a) {
        a = 2 ;
    }

    char bar (float c) {
        ;
    }
}
'''

c.importCommands.defaultImporterUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.936:@test defaultImporter
#@+node:ekr.20090121163905.937:@test c test--comment follows arg list
fileName = p.h

s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) //  <---------------------problem
{
    return true;
}
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.937:@test c test--comment follows arg list
#@+node:ekr.20090121163905.938:@test c test--comment follows block delim
fileName = p.h

s = '''\
void
aaa::bbb::doit
    (
    awk* b
    )
{
    assert(false);
}

bool
aaa::bbb::dothat
    (
    xyz *b
    ) 
{
    return true;
} //  <---------------------problem
'''

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.938:@test c test--comment follows block delim
#@+node:ekr.20090121163905.939:@test c test--intermixed blanks and tabs
fileName = p.h

s = '''
void
aaa::bbb::doit
    (
    awk* b  // leading blank
    )
{
	assert(false); // leading tab
}

'''

g.app.unitTestDict ['expectedErrors'] = 0 # Intermixed blanks and tabs are ok for C.

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.939:@test c test--intermixed blanks and tabs
#@+node:ekr.20090121163905.940:@test c old-style decl 1
fileName = p.h

s = '''\
static void
ReleaseCharSet(cset)
    CharSet *cset;
{
    ckfree((char *)cset->chars);
    if (cset->ranges) {
    ckfree((char *)cset->ranges);
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.940:@test c old-style decl 1
#@+node:ekr.20090121163905.941:@test c old-style decl 2
fileName = p.h

s = '''\
Tcl_Obj *
Tcl_NewLongObj(longValue)
    register long longValue;	/* Long integer used to initialize the
         * new object. */
{
    return Tcl_DbNewLongObj(longValue, "unknown", 0);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.941:@test c old-style decl 2
#@+node:ekr.20090121163905.942:@test c extern
fileName = p.h

s = '''\
extern  "C"
{
#include "stuff.h"
void    init(void);
#include "that.h"
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.942:@test c extern
#@-node:ekr.20090121163905.933:C tests
#@+node:ekr.20090121163905.943:Pascal tests
#@+node:ekr.20090121163905.944:@test pascal-to-delphi interface
s = '''
unit Unit1;

interface

uses
Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls,
Forms,
Dialogs;

type
TForm1 = class(TForm)
procedure FormCreate(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;

var
Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
var
x,y: double;
begin
x:= 4;
Y := x/2;
end;

end.
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pascalUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.944:@test pascal-to-delphi interface
#@-node:ekr.20090121163905.943:Pascal tests
#@+node:ekr.20090121163905.945:Python tests
# Warning: setting atAuto=True can wipe out unit tests.
#@nonl
#@+node:ekr.20090121163905.946:@@test nested class
s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.946:@@test nested class
#@+node:ekr.20090121163905.947:@test comment after dict assign
s = '''\
NS = { 'i': 'http://www.inkscape.org/namespaces/inkscape',
      's': 'http://www.w3.org/2000/svg',
      'xlink' : 'http://www.w3.org/1999/xlink'}

tabLevels = 4  # number of defined tablevels, FIXME, could derive from template?
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.947:@test comment after dict assign
#@+node:ekr.20090121163905.948:@test decorator test
s = '''\
class Index:
    """docstring"""
    @cherrypy.nocolor
    @cherrypy.expose
    def index(self):
        return "Hello world!"
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.948:@test decorator test
#@+node:ekr.20090121163905.949:@test def inside def
s = '''\
class aClass:
    def outerDef(self):
        """docstring.
        line two."""

        def pr(*args,**keys):
            g.es_print(color='blue',*args,**keys)

        a = 3
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.949:@test def inside def
#@+node:ekr.20090121163905.950:@test docstring only
s = '''\
"""A file consisting only of a docstring.
"""
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.950:@test docstring only
#@+node:ekr.20090121163905.951:@test overindent def--no following def
s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.951:@test overindent def--no following def
#@+node:ekr.20090121163905.952:@test overindent def--one following def
s = '''\
class aClass:
    def def1(self):
        pass

    if False or g.unitTesting:

        def pr(*args,**keys): # reportMismatch test
            g.es_print(color='blue',*args,**keys)

        pr('input...')

    def def2(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.952:@test overindent def--one following def
#@+node:ekr.20090121163905.953:@test overindented def 3
@language python

# This caused PyParse.py not to be imported properly.

s = '''\

import re

if 0: # Causes the 'overindent'
   if 0:   # for throwaway debugging output
      def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")

for ch in "({[":
   _tran[ord(ch)] = '('

class testClass1:
    pass
# '''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.953:@test overindented def 3
#@+node:ekr.20090121163905.954:@test python bad class test
s = '''\
class testClass1 # no colon
    pass

def spam():
    pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # Not really an error.

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.954:@test python bad class test
#@+node:ekr.20090121163905.955:@test python class test 2
s = '''\
class testClass2:
    pass
'''

tree = c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.955:@test python class test 2
#@+node:ekr.20090121163905.956:@test python class tests 1
s = '''\
class testClass1:
    """A docstring"""
    def __init__ (self):
        pass
    def f1(self):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.956:@test python class tests 1
#@+node:ekr.20090121163905.957:@test python decls test 1
s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.957:@test python decls test 1
#@+node:ekr.20090121163905.958:@test python def test 1
s = '''\

class test:

    def importFilesCommand (self,files=None,treeType=None,
        perfectImport=True,testing=False,verbose=False):
            # Not a command.  It must *not* have an event arg.

        c = self.c
        if c == None: return
        v = current = c.currentVnode()

    # Used by paste logic.

    def convertMoreStringToOutlineAfter (self,s,firstVnode):
        s = string.replace(s,"\\r","")
        strings = string.split(s,"\\n")
        return self.convertMoreStringsToOutlineAfter(strings,firstVnode)
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.958:@test python def test 1
#@+node:ekr.20090121163905.959:@test python def test 2
s = '''\

class test:
    def spam(b):
        pass

    # Used by paste logic.

    def foo(a):
        pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.959:@test python def test 2
#@+node:ekr.20090121163905.960:@test python empty decls
s = '''\
import leo.core.leoGlobals as g

a = 3
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.960:@test python empty decls
#@+node:ekr.20090121163905.961:@test python extra leading ws test
s = '''\

class cls:
     def fun(): # one extra space.
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None # No error unless we get an unexpected mismatch line.
g.app.unitTestDict ['expectedMismatchLine'] = 3 # The error happens before any lines are checked.
g.app.unitTestDict ['expectedErrorMessage'] = 'leading whitespace not consistent with @tabwidth -4'

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.961:@test python extra leading ws test
#@+node:ekr.20090121163905.962:@test python indent decls
s = '''\

class mammalProviderBase(object):
    """Root class for content providers used by DWEtree.py"""
    def __init__(self, params):
        """store reference to parameters"""
        self.params = params
    def provide(self, what):
        """default <BASE> value"""
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/'])
        return None

    def imagePath(self, sppdat):
        """return path to images and list of images for *species*"""
        path = 'MNMammals/imglib/Mammalia'
        for i in 'Order', 'Family', 'Genus', 'Species':
            path = os.path.join(path, sppdat['%sName' % (i,)])
        imglib = os.path.join('/var/www',path)
        imglib = os.path.join(imglib, '*.[Jj][Pp][Gg]')
        path = os.path.join('/',path)
        lst = [os.path.split(i)[1] for i in glob.glob(imglib)]
        lst.sort()
        return path, lst

class mainPages(mammalProviderBase):
    """provide content for pages in 'main' folder"""
    __parent = mammalProviderBase
    def provide(self, what):
        """add one layer to <BASE>"""
        ans = self.__parent.provide(self, what)
        if what == 'doctitle':
            return ELE('base', href=self.params['/BASE/']+'main/')
        return ans
''' 

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.962:@test python indent decls
#@+node:ekr.20090121163905.963:@test python minimal class 1
s = '''\

class ItasException(Exception):

    pass

def gpRun(gp, cmd, args, log = None):

    """Wrapper for making calls to the geoprocessor and reporting errors"""

    if log:

        log('gp: %s: %s\\n' % (cmd, str(args)))
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)


#@-node:ekr.20090121163905.963:@test python minimal class 1
#@+node:ekr.20090121163905.964:@test python minimal class 2
s = '''\

class emptyClass: pass

def followingDef():
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.964:@test python minimal class 2
#@+node:ekr.20090121163905.965:@test python minimal class 3
s = '''\

class emptyClass: pass # comment

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.965:@test python minimal class 3
#@+node:ekr.20090121163905.966:@test python underindent method
s = '''\

class emptyClass: 

    def spam():

        """docstring line 1
\-4under-indented docstring line"""
        pass

def followingDef(): # comment
    pass
'''

c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.966:@test python underindent method
#@+node:ekr.20090121163905.967:@test scanPythonText: leoImportNosent.py
@encoding utf-8
# leoImport.py uses unicode characters, so *this* test must have the directive above.

fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'leoImport.py'))

f = file(fileName)
s = f.read()
f.close()

g.app.unitTestDict['testingLeoImport.py'] = True

c.importCommands.pythonUnitTest(p,s=None,fileName=fileName,showTree=False)
#@nonl
#@-node:ekr.20090121163905.967:@test scanPythonText: leoImportNosent.py
#@+node:ekr.20090121163905.968:@test string test: extra indent
s = '''\
class baseScannerClass:

        """The base class for all import scanner classes."""

        def __init__ (self,importCommands,language):

            self.c = ic.c

        def createHeadline (self,parent,body,headline):
            # g.trace("parent,headline:",parent,headline)
            return p
'''

# We expect mismatches because the indentation does not match @tabwidth -4.
g.app.unitTestDict ['expectedErrors'] = None # No error unless we get an unexpected mismatch line.
g.app.unitTestDict ['expectedMismatchLine'] = 3
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.968:@test string test: extra indent
#@+node:ekr.20090121163905.969:@test string underindent lines
s = '''\
class baseScannerClass:
    def containsUnderindentedComment(self):
        a = 2
    # A true underindented comment.
        b = 3
    # This underindented comment should be placed with next function.
    def empty(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # underindented comments are no longer an error.
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.969:@test string underindent lines
#@+node:ekr.20090121163905.970:@test string underindent lines 2
s = '''\
class baseScannerClass:
    def containsUnderindentedComment(self):
        a = 2
    #
        b = 3
        # This comment is part of the present function.

    def empty(self):
        pass
'''

g.app.unitTestDict ['expectedErrors'] = 0 # underindented comments are no longer an error.
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.970:@test string underindent lines 2
#@+node:ekr.20090121163905.971:@test trailing comment
s = '''\
class aClass: # trailing comment


    def def1(self):             # trailing comment
        pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.971:@test trailing comment
#@+node:ekr.20090121163905.972:@test trailing comment--outer levels
s = '''\

xyz = 6 # trailing comment
pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.972:@test trailing comment--outer levels
#@+node:ekr.20090121163905.973:@test two functions (for comparison with unindent does not end function)
s = '''\

def foo():
    pass

def bar():
    pass
'''

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.973:@test two functions (for comparison with unindent does not end function)
#@+node:ekr.20090121163905.974:@test unindent in triple string does not end function
s = '''\

def foo():

    error("""line1
line2.
""")

    a = 5

def bar():
    pass
'''

showTree = False
keepTree = False

g.app.unitTestDict ['expectedErrors'] = None
g.app.unitTestDict ['expectedMismatchLine'] = None
c.importCommands.pythonUnitTest(p,s=s,showTree=showTree)

if showTree:
    try:
        child = p.firstChild()
        n = child.numberOfChildren()
        assert n == 2, 'expected 2 children, got %s' % n
    finally:
        if keepTree:
            h = child.h
            print 'h',h
            child.setHeadString('@'+h)
        else:
            while p.hasChildren():
                p.firstChild().doDelete()
        c.redraw(p)
#@nonl
#@-node:ekr.20090121163905.974:@test unindent in triple string does not end function
#@-node:ekr.20090121163905.945:Python tests
#@+node:ekr.20090121163905.975:c# tests
#@+node:ekr.20090121163905.976:@test c# namespace indent
s = '''\
namespace {
    class cTestClass1 {
        ;
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cSharpUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.976:@test c# namespace indent
#@+node:ekr.20090121163905.977:@test c# namespace no indent
s = '''\
namespace {
class cTestClass1 {
    ;
}
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.cSharpUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.977:@test c# namespace no indent
#@+node:ekr.20090121163905.978:@@test c# ref card
import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','big-c#-test.c#'))

    f = file(fileName)
    s = f.read()
    f.close()

    c.importCommands.cSharpUnitTest(p,s=s,fileName=fileName,showTree=False)
#@nonl
#@-node:ekr.20090121163905.978:@@test c# ref card
#@-node:ekr.20090121163905.975:c# tests
#@+node:ekr.20090121163905.979:Java tests
#@+node:ekr.20090121163905.980:@test java interface test1
s = '''\
interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.980:@test java interface test1
#@+node:ekr.20090121163905.981:@test java interface test2
s = '''\
interface Bicycle {
void changeCadence(int newValue);
void changeGear(int newValue);
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.981:@test java interface test2
#@+node:ekr.20090121163905.982:@@test constants.java
import sys

if sys.platform.lower().startswith('win'):

    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','constants.java'))

    f = file(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=None,fileName=fileName,showTree=False)
#@-node:ekr.20090121163905.982:@@test constants.java
#@+node:ekr.20090121163905.983:@test from AdminPermission.java
s = '''\
/**
 * Indicates the caller's authority to perform lifecycle operations on
 */

public final class AdminPermission extends BasicPermission
{
    /**
     * Creates a new <tt>AdminPermission</tt> object.
     */
    public AdminPermission()
    {
        super("AdminPermission");
    }
}
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)

#@-node:ekr.20090121163905.983:@test from AdminPermission.java
#@+node:ekr.20090121163905.984:@@test AdminPermission.java
import sys

if sys.platform.lower().startswith('win'):


    fileName = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','AdminPermission.java'))

    f = file(fileName)
    s = f.read()
    f.close()

    c.importCommands.javaUnitTest(p,s=s,fileName=fileName,showTree=False)
#@nonl
#@-node:ekr.20090121163905.984:@@test AdminPermission.java
#@+node:ekr.20090121163905.985:Test BundleException.java
@tabwidth 8
#@nonl
#@+node:ekr.20090121163905.986:@test from BundleException.java
@language python

s = '''\
/*
 * $Header: /cvs/leo/test/unitTest.leo,v 1.247 2008/02/14 14:59:04 edream Exp $
 * 
 * Copyright (c) OSGi Alliance (2000, 2005). All Rights Reserved.
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this 
 * distribution, and is available at http://www.eclipse.org/legal/epl-v10.html.
 */

package org.osgi.framework;

/**
 * A Framework exception used to indicate that a bundle lifecycle problem
 * occurred.
 * 
 * <p>
 * <code>BundleException</code> object is created by the Framework to denote
 * an exception condition in the lifecycle of a bundle.
 * <code>BundleException</code>s should not be created by bundle developers.
 * 
 * <p>
 * This exception is updated to conform to the general purpose exception
 * chaining mechanism.
 * 
 * @version $Revision: 1.247 $
 */

public class BundleException extends Exception {
	static final long	serialVersionUID	= 3571095144220455665L;
	/**
	 * Nested exception.
	 */
	private Throwable	cause;

	/**
	 * Creates a <code>BundleException</code> that wraps another exception.
	 * 
	 * @param msg The associated message.
	 * @param cause The cause of this exception.
	 */
	public BundleException(String msg, Throwable cause) {
		super(msg);
		this.cause = cause;
	}
}

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.986:@test from BundleException.java
#@-node:ekr.20090121163905.985:Test BundleException.java
#@-node:ekr.20090121163905.979:Java tests
#@+node:ekr.20090121163905.987:Javascript tests
#@+node:ekr.20090121163905.988:Problems
@language javascript

// regexps that look like section references.

{
	name: "macro",
	match: "<<",
	lookaheadRegExp: /<<([^>\s]+)(?:\s*)((?:[^>]|(?:>(?!>)))*)>>/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart && lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

// Comments that look like section references.

// <<gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... >>

config.macros.gradient.handler = function(place,macroName,params,wikifier)
{
	var panel = wikifier ? createTiddlyElement(place,"div",null,"gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	var colours = [];
	for(var t=1; t<params.length; t++) {
		var c = new RGB(params[t]);
		if(c)
			colours.push(c);
	}
	drawGradient(panel,params[0] != "vert",colours);
	if(wikifier)
		wikifier.subWikify(panel,">>");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

// @Deprecated: Use <br> or <br /> instead of <<br>>
config.macros.br = {};
config.macros.br.handler = function(place)
{
	createTiddlyElement(place,"br");
};
#@-node:ekr.20090121163905.988:Problems
#@+node:ekr.20090121163905.989:@test Javascript-regex-1
s = '''\

String.prototype.toJSONString = function()
{
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.989:@test Javascript-regex-1
#@+node:ekr.20090121163905.990:@test Javascript-2
    s = '''\

// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
String.prototype.toJSONString = function()
{
	var m = {
		'\\b': '\\\\b',
		'\\f': '\\\\f',
		'\\n': '\\\\n',
		'\\r': '\\\\r',
		'\\t': '\\\\t',
		'"' : '\\\\"',
		'\\\\': '\\\\\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
    if(/["\\\\\\x00-\\x1f]/.test(this))
		return '"' + this.replace(/([\\x00-\\x1f\\"])/g,replaceFn) + '"';

	return '"' + this + '"';
};

'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.990:@test Javascript-2
#@+node:ekr.20090121163905.991:@test Javascript-3
s = '''\

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		var tiddlers = store.filterTiddlers(store.getTiddlerText("DefaultTiddlers"));
		for(var t=0; t<tiddlers.length; t++) {
			story.displayTiddler("bottom",tiddlers[t].title);
		}
	}
	window.scrollTo(0,0);
}

'''

# Double each backslash (they are in a docstring).
# chars = [z for z in s]
# s = []
# for z in char:
    # if z == '\\': s.append('\\\\')
    # else: s.append(z)
# s = s.join('')

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.991:@test Javascript-3
#@+node:ekr.20090121163905.992:@@test javascript-test-js
f = file('test.js')
s = f.read()
f.close()

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.javaScriptUnitTest(p,s=s,showTree=False)
#@nonl
#@-node:ekr.20090121163905.992:@@test javascript-test-js
#@-node:ekr.20090121163905.987:Javascript tests
#@+node:ekr.20090121163905.993:xml tests
#@+node:ekr.20090121163905.994:@test xml 1
s = '''\
<html>
<head>
    <title>Bodystring</title>
</head>
<body class='bodystring'>
<div id='bodydisplay'></div>
</body>
</html>
'''

g.app.unitTestDict ['expectedErrors'] = 0

c.importCommands.xmlUnitTest(p,s=s,showTree=False)
#@-node:ekr.20090121163905.994:@test xml 1
#@-node:ekr.20090121163905.993:xml tests
#@+node:ekr.20090121163905.995:@test checkTrialWrite
@first # -*- coding: utf-8 -*-

import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.baseScannerClass(ic,atAuto=True,language='python')
runner.root = p.copy()

g.app.unitTestDict ['expectedMismatchLine'] = 1

s1 = g.toUnicode('line Ä, ڱ,  궯, 奠 end',encoding='utf-8')
s2 = g.toUnicode('line Ä, ڱ,  궯, 奠 x end',encoding='utf-8')

ok = runner.checkTrialWrite(s1=s1,s2=s2)

assert ok
#@-node:ekr.20090121163905.995:@test checkTrialWrite
#@+node:ekr.20090121163905.996:@test collapse-all
c.contractAllHeadlines()
#@nonl
#@-node:ekr.20090121163905.996:@test collapse-all
#@-node:ekr.20090121163905.932: Tests of @auto
#@+node:ekr.20090121163905.997:@test compareHelper
import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.baseScannerClass(ic,atAuto=True,language='python')
i = 0
lines1 = ['abc',]
lines2 = ['xyz',]

g.app.unitTestDict ['expectedErrors'] = 1
g.app.unitTestDict ['expectedMismatchLine'] = 1

runner.compareHelper(lines1,lines2,i,strict=True)
#@-node:ekr.20090121163905.997:@test compareHelper
#@+node:ekr.20090121163905.998:@test compareHelper-warning
import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.baseScannerClass(ic,atAuto=True,language='java')
runner.tab_width = -4
i = 0
lines1 = ['abc',]
lines2 = [' abc',]

# g.unitTesting = False # force the warning.

g.app.unitTestDict ['expectedErrors'] = 0
g.app.unitTestDict ['expectedMismatchLine'] = 1

runner.compareHelper(lines1,lines2,i,strict=False)
#@nonl
#@-node:ekr.20090121163905.998:@test compareHelper-warning
#@+node:ekr.20090121163905.999:@test regularizeWhitespace
s = '''\
    a
\tb
'''

import leo.core.leoImport as leoImport
ic = c.importCommands
runner = leoImport.pythonScanner(c.importCommands,atAuto=False)
runner.tab_width = -4
runner.regularizeWhitespace(s)
assert runner.errors == 1
#@nonl
#@-node:ekr.20090121163905.999:@test regularizeWhitespace
#@+node:ekr.20090121163905.1000:@test languageForExtension
d = g.app.extra_extension_dict

for ext in g.app.extension_dict.keys():
    language =  c.importCommands.languageForExtension(ext)
    language2 = c.importCommands.languageForExtension('.'+ext)
    assert language == language2

    # Now a many-one relationship.
    if language:
        # Do not test extensions that have 'none' as the value of d.get(ext)
        # Otherwise, test only d.get(ext).
        language2 = d.get(ext)
        if language2 in ('None','none'):  continue
        if language2: language = language2
        # Made-up languages do not have mode files.
        if not language.endswith('_language'):
            path = g.os_path_join(g.app.loadDir,'..','modes','%s.py' % (language))
            assert g.os_path_exists(path), 'for ext=%s does not exist: %s' % (ext,path)

    if 0:
        if language is None:
            print('no language for ext=%s' % (ext))
#@nonl
#@-node:ekr.20090121163905.1000:@test languageForExtension
#@+node:ekr.20090121163905.1001:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoImport tests.')
#@nonl
#@-node:ekr.20090121163905.1001:@test zz restore the screen
#@-node:ekr.20090121163905.899:leoImport
#@+node:ekr.20090121163905.1002:leoKeys
#@+node:ekr.20090121163905.1003:@@test strokeFromEvent (no longer used)
alt = 0x20000 ; ctrl  = 4 ; shift = 1 ; key = 0

table = (
    (key, 'a','a','a'),
    (shift,'A','A','A'),
    (alt,'','a','Alt+a'),
    (alt+shift,'','A','Alt+A'),
    (shift,'A','A','A',),
    (key,'','Right','Right'),
    (shift,'','Right','Shift+Right'),
    (ctrl,'','Right','Ctrl+Right'),
    (ctrl+shift,'','Right','Ctrl+Shift+Right'),
)
for state, ch, keysym, result in table:
    val = c.k.strokeFromEvent(g.Bunch(state=state,char=ch,keysym=keysym))
    assert val==result,'Expected %s, Got %s' % (result,val)
#@nonl
#@-node:ekr.20090121163905.1003:@@test strokeFromEvent (no longer used)
#@+node:ekr.20090121163905.1004:@test isPlainKey
import string

k = c.k

for ch in (string.printable):
    if ch == '\n': continue # A special case.
    assert k.isPlainKey(ch), 'wrong: not plain: %s' % (ch)

special = (
    'Return', # A special case.
    'Begin','Break','Caps_Lock','Clear','Down','End','Escape',
    'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
    'KP_Add', 'KP_Decimal', 'KP_Divide', 'KP_Enter', 'KP_Equal',
    'KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab',
    'KP_F1','KP_F2','KP_F3','KP_F4',
    'KP_0','KP_1','KP_2','KP_3','KP_4','KP_5','KP_6','KP_7','KP_8','KP_9',
    'Home','Left','Linefeed','Next','Num_Lock',
    'PageDn','PageUp','Pause','Prior','Right','Up',
    'Sys_Req',
)

for ch in special:
    assert not k.isPlainKey(ch), 'wrong: is plain: %s' % (ch)
#@-node:ekr.20090121163905.1004:@test isPlainKey
#@+node:ekr.20090121163905.1005:@test k.autoCompleterClass.calltip
try:
    k = c.k ; ac = k.autoCompleter
    w = c.frame.body.bodyCtrl
    ac.widget = w
    s = w.getAllText()
    import string
    # Just test that this doesn't crash.
    for obj in (None,g,string,c,p):
        w.setInsertPoint('end')
        c.k.autoCompleter.calltip(obj=g)
finally:
    w.setAllText(s)
    p.setBodyString(s)
    c.recolor()

# end:
#@nonl
#@-node:ekr.20090121163905.1005:@test k.autoCompleterClass.calltip
#@+node:ekr.20090121163905.1006:@test k.registerCommand
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k ; p = c.currentPosition() ; w = c.edit_widget(p)
commandName = 'test-registerCommand'

def callback (event=None,c=c): # Must have an event param to pass later unit test.
    g.app.unitTestDict[commandName] = True

# Test 1
g.app.unitTestDict[commandName] = False
k.registerCommand(commandName,'Alt-Ctrl-Shift-z',callback,pane='all',verbose=True)
k.simulateCommand(commandName)
assert g.app.unitTestDict.get(commandName)

if 0: # Test 2
    g.app.unitTestDict[commandName] = False
    k.manufactureKeyPressForCommandName(w,commandName)
    assert g.app.unitTestDict.get(commandName)
#@nonl
#@-node:ekr.20090121163905.1006:@test k.registerCommand
#@+node:ekr.20090121163905.1007:@test strokeFromSetting
# print('settingsNameDict',c.k.settingsNameDict)

table = (
    ('a','a'),
    ('A','a'),
    ('Alt-a','Alt+a'),
    ('Alt-A','Alt+a'),
    ('Alt-Shift-a','Alt+A'),
    ('Alt-=','Alt+equal'),
    ('Alt-+','Alt+plus'),
    ('Alt-Shift++','Alt+plus'), # Ignore the shift.
    ('Alt--','Alt+minus'),
    ('Shift-a','A'),
    ('Shift-A','A'),
    ('RtArrow','Right'),
    ('Shift-RtArrow','Shift+Right'),
    ('Ctrl-RtArrow','Ctrl+Right'),
    ('Control-Right','Ctrl+Right'),
    ('PageUp','Prior'), ('Prior','Prior'),('Shift-PageUp','Shift+Prior'),
    ('PageDn','Next'),('Next','Next'),('Shift-Next','Shift+Next'),
)
for setting, result in table:
    val = c.k.strokeFromSetting(setting)
    assert val==result,'Expected %s, Got %s' % (result,val)
#@nonl
#@-node:ekr.20090121163905.1007:@test strokeFromSetting
#@+node:ekr.20090121163905.1008:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

# print('\nEnd of leoKeys tests.')
#@nonl
#@-node:ekr.20090121163905.1008:@test zz restore the screen
#@-node:ekr.20090121163905.1002:leoKeys
#@+node:ekr.20090121163905.1009:leoNodes
#@+node:ekr.20090121163905.1010: inner @test: Test consistency between parents iter and v.parents
# The actual test is in a child node.
#@nonl
#@clone 2
#@+node:ekr.20090121163905.1011:parent
#@+node:ekr.20090121163905.1012:@test consistency between parents iter and v.parents
try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            parents1 = p.v.parents
            # if p.v._parent: parents1 = p.v._parent.t.vnodeList
            # else:           parents1 = []
            parents2 = p.v.directParents()

        assert len(parents1) == len(parents2), "length mismatch: %s" % (p)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print("parents1")
    for parent in parents1: print(parent)
    print("parents2")
    for parent in parents2: print(parent)
    raise
#@nonl
#@-node:ekr.20090121163905.1012:@test consistency between parents iter and v.parents
#@-node:ekr.20090121163905.1011:parent
#@-node:ekr.20090121163905.1010: inner @test: Test consistency between parents iter and v.parents
#@+node:ekr.20090121163905.1013: Position tests
#@+node:ekr.20090121163905.1014: Diabled tests
#@+node:ekr.20090121163905.1015:@@test consistency of p.v.t.vnodeList & v.parents for cloned nodes
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print("parents...")
    for parent in parents: print(parent)
    print("vparents...")
    for parent in vparents: print(parent)
    raise # for unittest.
#@nonl
#@-node:ekr.20090121163905.1015:@@test consistency of p.v.t.vnodeList & v.parents for cloned nodes
#@+node:ekr.20090121163905.1016:@@test consistency of tnodeListAndParents
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.directParents()
                assert(len(parents) == len(vparents)), 'fail 1'
                for z in parents:
                    assert(z in vparents), 'fail 2'
                for z in vparents:
                    assert(z in parents), 'fail 3'

except AssertionError:
    print("parents...")
    for parent in parents: print(parent)
    print("vparents...")
    for parent in vparents: print(parent)
    g.pdb()
    raise # for unittest.
#@nonl
#@-node:ekr.20090121163905.1016:@@test consistency of tnodeListAndParents
#@-node:ekr.20090121163905.1014: Diabled tests
#@+node:ekr.20090121163905.1017:@test c iters
<< coverage tests >>
<< duplicate tests >>

if 0:
    print("vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()]))
    print("tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()]))

if 0: # all nodes
    for v in c.all_vnodes_iter(): print(v)
    for t in c.all_tnodes_iter(): print(t)

if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print(v)
    for t in c.all_unique_tnodes_iter(): print(t)
#@nonl
#@+node:ekr.20090121163905.1018:<< coverage tests >>
v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print("coverage tests pass")
#@nonl
#@-node:ekr.20090121163905.1018:<< coverage tests >>
#@+node:ekr.20090121163905.1019:<< duplicate tests >>
nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)

nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)

# print("duplicate tests pass")
#@nonl
#@-node:ekr.20090121163905.1019:<< duplicate tests >>
#@-node:ekr.20090121163905.1017:@test c iters
#@+node:ekr.20090121163905.1020:@test consistency of back/next links
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)
#@nonl
#@-node:ekr.20090121163905.1020:@test consistency of back/next links
#@+node:ekr.20090121163905.1021:@test consistency of c.allNodes_iter() and p.ThreadNext()
for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()

    assert not p2, repr(p2)
#@-node:ekr.20090121163905.1021:@test consistency of c.allNodes_iter() and p.ThreadNext()
#@+node:ekr.20090121163905.1022:@test consistency of firstChild & children_iter()
for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):

        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)
#@nonl
#@-node:ekr.20090121163905.1022:@test consistency of firstChild & children_iter()
#@+node:ekr.20090121163905.1023:@test consistency of level
for p in c.allNodes_iter():

    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)

    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())
#@nonl
#@-node:ekr.20090121163905.1023:@test consistency of level
#@+node:ekr.20090121163905.1024:@test consistency of parent & parents_iter()
for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)
#@nonl
#@-node:ekr.20090121163905.1024:@test consistency of parent & parents_iter()
#@+node:ekr.20090121163905.1025:@test consistency of parent/child links
# Test consistency of p.parent, p.next, p.back and p.firstChild.
for p in c.allNodes_iter():

    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))

    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())

    if p.hasBack():
        assert(p.back().parent() == p.parent())
#@nonl
#@-node:ekr.20090121163905.1025:@test consistency of parent/child links
#@+node:ekr.20090121163905.1026:@test consistency of threadBack/Next links
for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())
#@nonl
#@-node:ekr.20090121163905.1026:@test consistency of threadBack/Next links
#@+node:ekr.20090121163905.1027:@test hasNextBack
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))

    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))
#@nonl
#@-node:ekr.20090121163905.1027:@test hasNextBack
#@+node:ekr.20090121163905.1028:@test hasParentChild
for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))

    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))
#@nonl
#@-node:ekr.20090121163905.1028:@test hasParentChild
#@+node:ekr.20090121163905.1029:@test hasThreadNextBack
for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))

    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))
#@nonl
#@-node:ekr.20090121163905.1029:@test hasThreadNextBack
#@+node:ekr.20090121163905.1030:@test isAncestorOf
for p in c.allNodes_iter():

    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)
#@nonl
#@-node:ekr.20090121163905.1030:@test isAncestorOf
#@+node:ekr.20090121163905.1031:@test onHyperLinkControlClick
# This hack is needed only for tkinter gui.
if g.app.gui.guiName() == 'tkinter':
    p.OnHyperLinkControlClick(event=None)
#@-node:ekr.20090121163905.1031:@test onHyperLinkControlClick
#@+node:ekr.20090121163905.1032:@test p.comparisons
copy = p.copy()
assert(p == copy)
assert(p != p.threadNext())

root = c.rootPosition()
# assert p.equal(p.copy()) is True
# assert p.equal(root) is False
assert p.__eq__(copy) is True
assert p.__ne__(copy) is False
assert p.__eq__(root) is False
assert p.__ne__(root) is True
#@nonl
#@-node:ekr.20090121163905.1032:@test p.comparisons
#@+node:ekr.20090121163905.1033:@test p.isCurrentPosition
n = g.app.positions
assert c.isCurrentPosition(None) is False
assert c.isCurrentPosition(p) is True
assert g.app.positions == n
#@nonl
#@-node:ekr.20090121163905.1033:@test p.isCurrentPosition
#@+node:ekr.20090121163905.1034:@test p.isRootPosition
n = g.app.positions
assert c.isRootPosition(None) is False
assert c.isRootPosition(p) is False
assert g.app.positions == n
#@nonl
#@-node:ekr.20090121163905.1034:@test p.isRootPosition
#@+node:ekr.20090121163905.1035:@test p.iters and v.iters
import leo.core.leoNodes as leoNodes

current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print(v)
    for v in vList2: print(v)

if 0:
    print(len(allList),len(vList1),len(vList2))

if 0: # v.iters no longer exist.
    << tests of consistency of p and v iters >>
<< tests that node iterators return no duplicate nodes >>
<< print nodes returned by iterators >>
#@nonl
#@+node:ekr.20090121163905.1036:child1
#@clone 2
#@+node:ekr.20090121163905.1037:a
#@+node:ekr.20090121163905.1038:b
#@-node:ekr.20090121163905.1038:b
#@-node:ekr.20090121163905.1037:a
#@+node:ekr.20090121163905.1039:c
#@-node:ekr.20090121163905.1039:c
#@+node:ekr.20090121163905.1040:d
#@+node:ekr.20090121163905.1041:e
#@-node:ekr.20090121163905.1041:e
#@-node:ekr.20090121163905.1040:d
#@-node:ekr.20090121163905.1036:child1
#@+node:ekr.20090121163905.1042:child2
#@-node:ekr.20090121163905.1042:child2
#@+node:ekr.20090121163905.1043:<< tests of consistency of p and v iters >>
try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)

    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)

    # print("consistency tests pass")

except AssertionError:
    print(tag)
    print("list1")
    for v in list1: print(v)
    print("list2")
    for v in list2: print(v)
    raise
#@nonl
#@-node:ekr.20090121163905.1043:<< tests of consistency of p and v iters >>
#@+node:ekr.20090121163905.1044:<< tests that node iterators return no duplicate nodes >>
nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)

nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)

# print("duplicate tests pass")
#@nonl
#@-node:ekr.20090121163905.1044:<< tests that node iterators return no duplicate nodes >>
#@+node:ekr.20090121163905.1045:<< print nodes returned by iterators >>
if 0:
    for v in current.vnodes_iter(): print(v)
    for v in current.unique_vnodes_iter(): print(v)

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print(v)
    for t in root.tnodes_iter(): print(t)

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print(v)
    for t in child.tnodes_iter(): print(t)
#@nonl
#@-node:ekr.20090121163905.1045:<< print nodes returned by iterators >>
#@-node:ekr.20090121163905.1035:@test p.iters and v.iters
#@+node:ekr.20090121163905.1046:@test c.positionExists
child = p.insertAsLastChild()
assert c.positionExists(child)
child.doDelete()
assert not c.positionExists(child)
#@nonl
#@-node:ekr.20090121163905.1046:@test c.positionExists
#@+node:ekr.20090121163905.1047:@test c.positionExists for all nodes
root = c.rootPosition()

for p in c.allNodes_iter():
    assert c.positionExists(p,root)
#@nonl
#@-node:ekr.20090121163905.1047:@test c.positionExists for all nodes
#@+node:ekr.20090121163905.1048:@test p.setBodyStringOrPane
# Tests that c.setBodyString works immediately.
h = p.h

try:
    child = p.firstChild()
    before = child.b
    after = "after"
    c.setBodyString(child,"after")
    c.selectPosition(child)
    t = c.frame.body.bodyCtrl
    s = t.get("1.0","end")
    assert s.rstrip() == after.rstrip(), \
        "c.setBodyString failed: %s, %s" % (repr(s),repr(after))
finally:
    c.setBodyString(child,before)
    c.selectPosition(p)
#@nonl
#@+node:ekr.20090121163905.1049:child
after
#@nonl
#@-node:ekr.20090121163905.1049:child
#@-node:ekr.20090121163905.1048:@test p.setBodyStringOrPane
#@+node:ekr.20090121163905.1050:@test p.t == p.v.t
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in c.allNodes_iter():
    assert(p.t == p.v.t)
#@nonl
#@-node:ekr.20090121163905.1050:@test p.t == p.v.t
#@+node:ekr.20090121163905.1051:@test that clones share subtrees
for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        # assert(childv == p.v.t._firstChild)
        # assert(id(childv) == id(p.v.t._firstChild))
        firstChild = p.v.t.children[0]
        assert childv == firstChild
        for v in p.v.t.vnodeList:
            # assert(v.t._firstChild == childv)
            # assert(id(v.t._firstChild) == id(childv))
            firstChild = v.t.children[0]
            assert(id(firstChild) == id(childv))
#@nonl
#@-node:ekr.20090121163905.1051:@test that clones share subtrees
#@+node:ekr.20090121163905.1052:@test v/t.__hash__
import leo.core.leoNodes as leoNodes

if leoNodes.use_zodb:
    p.v.__hash__()
    p.v.t.__hash__()
#@nonl
#@-node:ekr.20090121163905.1052:@test v/t.__hash__
#@+node:ekr.20090121163905.1053:@test vnode list
for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) > 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)
#@nonl
#@-node:ekr.20090121163905.1053:@test vnode list
#@-node:ekr.20090121163905.1013: Position tests
#@+node:ekr.20090121163905.1054:Fundamental node operations
#@+node:ekr.20090121163905.1055:@test at most one vnode has str_leo_pos attribute
n = 0
for v in c.all_unique_vnodes_iter():
    if hasattr(v,'unknownAttributes'):
        d = v.unknownAttributes
        if d.get('str_leo_pos'):
            n += 1

# print(n)
assert n < 2
#@nonl
#@-node:ekr.20090121163905.1055:@test at most one vnode has str_leo_pos attribute
#@+node:ekr.20090121163905.1056:@test clone and move the clone to the root
# Delete all children.
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')
assert child, 'no child'

try:
    c.selectPosition(child)
    c.clone()
    clone = c.currentPosition()
    assert clone.h == 'child','fail headstring'
    assert child.isCloned(), 'fail 1'
    assert clone.isCloned(), 'fail 2'
    assert child.isCloned(), 'fail 3'
    assert clone.isCloned(), 'fail 4'
    c.undoer.undo()
    assert not child.isCloned(), 'fail 1-a'
    c.undoer.redo()
    assert child.isCloned(), 'fail 1-b'
    c.undoer.undo()
    assert not child.isCloned(), 'fail 1-c'
    c.undoer.redo()
    assert child.isCloned(), 'fail 1-d'
    oldRoot = c.rootPosition()
    clone.moveToRoot(oldRoot=oldRoot) # Does not change child position.
    assert child.isCloned(), 'fail 3-2'
    assert clone.isCloned(), 'fail 4-2'
    assert not clone.parent(), 'fail 5'
    assert not clone.back(), 'fail 6'
    clone.doDelete()
    assert not child.isCloned(), 'fail 7'
finally:
    # Delete all children.
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1056:@test clone and move the clone to the root
#@+node:ekr.20090121163905.1057:@test create-chapter
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')
c.selectPosition(child)

try:
    for undoType in ('Create Chapter From Node','Create Chapter'):
        c.chapterController.createChapterByName('new-chapter',p,undoType)
        c.undoer.undo()
        c.undoer.redo()
        c.undoer.undo()
        c.undoer.redo()
        c.undoer.undo() # Don't pollute future unit tests.

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1057:@test create-chapter
#@+node:ekr.20090121163905.1058:@test delete node
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p.expand()
    c.redraw_now()
    c.setCurrentPosition(p3)
    c.deleteOutline()
    c.outerUpdate()
    p = c.currentPosition()
    assert p.h == 'A', 'fail 1: got %s' % p.h
    assert p.next().h == 'C', 'fail 2'
    c.undoer.undo()
    c.outerUpdate()
    p = c.currentPosition()
    assert p.back() == p2, 'fail 4'
    assert p.next() == p4, 'fail 5'
    c.undoer.redo()
    c.outerUpdate()
    p = c.currentPosition()
    assert p.h == 'A', 'fail 1-2'
    assert p.next().h == 'C', 'fail 2-2'
    c.undoer.undo()
    c.outerUpdate()
    p = c.currentPosition()
    assert p.back() == p2, 'fail 4-2'
    assert p.next() == p4, 'fail 5-2'
    c.undoer.redo()
    c.outerUpdate()
    p = c.currentPosition()
    assert p.h == 'A', 'fail 1-3'
    assert p.next().h == 'C', 'fail 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1058:@test delete node
#@+node:ekr.20090121163905.1059:@test deleting the root should select another node
import leo.core.leoNodes as leoNodes

while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')

try:
    oldRoot = c.rootPosition()
    child.moveToRoot(oldRoot=oldRoot) # Does not change child position.
    c.setRootPosition(child)
    assert c.positionExists(child)
    assert c.rootPosition().h == 'child', 'fail 1'
    next = c.rootPosition().next()
    assert next.h == 'Startup', 'fail 2: next: %s' % next
    c.rootPosition().doDelete(newNode=next)
    c.setRootPosition(next)
finally:
    while p.hasChildren():
        p.firstChild().doDelete(newNode=None)
    # c.selectPosition(p)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1059:@test deleting the root should select another node
#@+node:ekr.20090121163905.1060:@test demote
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p3)
    c.demote()
    p = c.currentPosition()
    assert p == p3,                                     'fail 1'
    assert p.h == 'B',                       'fail 2'
    assert not p.next(),                                'fail 3'
    assert p.firstChild().h == 'C',          'fail child 1'
    assert p.firstChild().next().h == 'D',   'fail child 2'
    c.undoer.undo()
    p = c.currentPosition()
    assert p == p3
    assert p.back() == p2, 'fail 5'
    assert p.next() == p4, 'fail 6'
    c.undoer.redo()
    assert p == p3,                                     'fail 1-2'
    assert p.h == 'B',                       'fail 2-2'
    assert not p.next(),                                'fail 3-2'
    assert p.firstChild().h == 'C',          'fail child 1-2'
    assert p.firstChild().next().h == 'D',   'fail child 2-2'
    c.undoer.undo()
    p = c.currentPosition()
    assert p.back() == p2, 'fail 4-2'
    assert p.next() == p4, 'fail 5-2'
    c.undoer.redo()
    assert p == p3,                                     'fail 1-3'
    assert p.h == 'B',                       'fail 2-3'
    assert not p.next(),                                'fail 3-3'
    assert p.firstChild().h == 'C',          'fail child 1-3'
    assert p.firstChild().next().h == 'D',   'fail child 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1060:@test demote
#@+node:ekr.20090121163905.1061:@test insert node
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p.expand()
    c.setCurrentPosition(p2)
    c.insertHeadline()
    p = c.currentPosition()
    p.setHeadString('inserted')
    assert p.back().h == 'A', 'fail 1'
    assert p.next().h == 'B', 'fail 2'
    c.undoer.undo()
    p = c.currentPosition()
    assert p == p2,        'fail 3'
    assert p.next() == p3, 'fail 4'
    c.undoer.redo()
    p = c.currentPosition()
    assert p.back().h == 'A', 'fail 1-2'
    assert p.next().h == 'B', 'fail 2-2'
    c.undoer.undo()
    p = c.currentPosition()
    assert p == p2,        'fail 3-2'
    assert p.next() == p3, 'fail 3-2'
    c.undoer.redo()
    p = c.currentPosition()
    assert p.back().h == 'A', 'fail 1-3'
    assert p.next().h == 'B', 'fail 2-3'

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1061:@test insert node
#@+node:ekr.20090121163905.1062:@test move-outline-down & undo/redo
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p3)
    c.moveOutlineDown()
    moved = c.currentPosition()
    assert moved.h == 'B', 'fail 1'
    assert moved.back().h == 'C', 'fail 2'
    assert moved.next().h == 'D', 'fail 3'
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    # assert moved.back() == p4, 'fail 4: %s != %s' % (moved.back(),p4)
    assert moved.next() == p5, 'fail 5: %s != %s' % (moved.next(),p5)
    c.undoer.undo()
    moved = c.currentPosition()
    assert moved.back() == p2, 'fail 4'
    assert moved.next() == p4, 'fail 5'
    c.undoer.redo()
    moved = c.currentPosition()
    assert moved.h == 'B', 'fail 1-2'
    assert moved.back().h == 'C', 'fail 2-2'
    assert moved.next().h == 'D', 'fail 3-2'
    c.undoer.undo()
    moved = c.currentPosition()
    assert moved.back() == p2, 'fail 4-2'
    assert moved.next() == p4, 'fail 5-2'
    c.undoer.redo()
    moved = c.currentPosition()
    assert moved.h == 'B', 'fail 1-3'
    assert moved.back().h == 'C', 'fail 2-3'
    assert moved.next().h == 'D', 'fail 3-3'

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1062:@test move-outline-down & undo/redo
#@+node:ekr.20090121163905.1063:@test move-outline-left
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p.expand()
    c.setCurrentPosition(p2)
    c.moveOutlineLeft()
    moved = c.currentPosition()
    assert moved.h == 'A','fail 1'
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    assert moved.back() == p, 'fail 2: %s != %s' % (moved.back(),p4)
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()



    moved.doDelete(newNode=p)

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
        c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1063:@test move-outline-left
#@+node:ekr.20090121163905.1064:@test move-outline-right
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p.expand()
    c.setCurrentPosition(p3)
    c.moveOutlineRight()
    moved = c.currentPosition()
    assert moved.h == 'B', 'fail 1'
    assert moved.parent() == p2
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1064:@test move-outline-right
#@+node:ekr.20090121163905.1065:@test move-outline-up
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p.insertAsNthChild(2)
    p4.setHeadString('C')
    p5 = p.insertAsNthChild(3)
    p5.setHeadString('D')
    p.expand()
    c.setCurrentPosition(p4)
    c.moveOutlineUp()
    moved = c.currentPosition()
    assert moved.h == 'C', 'fail 1'
    assert moved.back().h == 'A', 'fail 2'
    assert moved.next().h == 'B', 'fail 3'
    assert moved.back() == p2, 'fail 4: %s != %s' % (moved.back(),p2)
    # This assert fails because p4._childIndex != moved.back()._childIndex.
    # assert moved.next() == p3, 'fail 5: %s != %s' % (moved.next(),p3)
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1065:@test move-outline-up
#@+node:ekr.20090121163905.1066:@test paste-node
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')
grandChild = child.insertAsNthChild(0)
grandChild.setHeadString('grand child')
c.selectPosition(grandChild)
c.clone()
c.selectPosition(child)

try:
    p.expand()
    c.selectPosition(child)
    c.copyOutline()
    oldTnodes = [p2.v.t for p2 in child.self_and_subtree_iter()]
    c.selectPosition(child)
    c.currentPosition().contract() # Essential
    c.pasteOutline()
    current = c.currentPosition()
    assert current != child, 'fail 2'
    newTnodes = [p2.v.t for p2 in current.self_and_subtree_iter()]
    for t in newTnodes:
        assert t not in oldTnodes, 'fail 3'
    c.undoer.undo()
    c.undoer.redo()
    c.undoer.undo()
    c.undoer.redo()

finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1066:@test paste-node
#@+node:ekr.20090121163905.1067:@test paste-retaining-clones
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

child = p.insertAsNthChild(0)
child.setHeadString('child')
assert child, 'no child'
grandChild = child.insertAsNthChild(0)
grandChild.setHeadString('grand child')

try:
    c.selectPosition(child)
    c.copyOutline()
    oldTnodes = [p2.v.t for p2 in child.self_and_subtree_iter()]
    c.currentPosition().contract() # Essential
    c.pasteOutlineRetainingClones()
    current = c.currentPosition()
    assert current != child, 'fail 2'
    newTnodes = [p2.v.t for p2 in current.self_and_subtree_iter()]
    for t in newTnodes:
        assert t in oldTnodes, 'fail 3'
finally:
    if 1:
        while p.hasChildren():
            p.firstChild().doDelete(newNode=None)
    if 1:
        c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1067:@test paste-retaining-clones
#@+node:ekr.20090121163905.1068:@test promote
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode=None)

try:
    p2 = p.insertAsNthChild(0)
    p2.setHeadString('A')
    p3 = p.insertAsNthChild(1)
    p3.setHeadString('B')
    p4 = p3.insertAsNthChild(0)
    p4.setHeadString('child 1')
    p5 = p3.insertAsNthChild(1)
    p5.setHeadString('child 2')
    p.expand()
    p6 = p.insertAsNthChild(2)
    p6.setHeadString('C')
    c.setCurrentPosition(p3)
    c.promote()
    p = c.currentPosition()
    assert p == p3,                                     'fail 1'
    assert p.h == 'B',                       'fail 2'
    assert p.next().h=='child 1',            'fail 3'
    assert p.next().next().h == 'child 2',   'fail child 1'
    assert p.next().next().next().h == 'C',  'fail child 2'
    c.undoer.undo()
    p = c.currentPosition()
    assert p == p3
    assert p.back() == p2,                              'fail 5'
    assert p.next() == p6,                              'fail 6'
    assert p.firstChild().h=='child 1',          'fail child 3'
    assert p.firstChild().next().h == 'child 2', 'fail child 4'
    c.undoer.redo()
    p = c.currentPosition()
    assert p == p3,                                     'fail 1-2'
    assert p.h == 'B',                       'fail 2-2'
    assert p.next().h=='child 1',            'fail 3-2'
    assert p.next().next().h == 'child 2',   'fail child 1-2'
    assert p.next().next().next().h == 'C',  'fail child 2-2'
    c.undoer.undo()
    p = c.currentPosition()
    assert p == p3
    assert p.back() == p2,                                  'fail 5-2'
    assert p.next() == p6,                                  'fail 6-2'
    assert p.firstChild().h=='child 1',          'fail child 3-2'
    assert p.firstChild().next().h == 'child 2', 'fail child 4-2'
    c.undoer.redo()
    p = c.currentPosition()
    assert p == p3,                                     'fail 1-3'
    assert p.h == 'B',                       'fail 2-3'
    assert p.next().h=='child 1',            'fail 3-3'
    assert p.next().next().h == 'child 2',   'fail child 1-3'
    assert p.next().next().next().h == 'C',  'fail child 2-3'


finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode=None)
    c.redraw_now()
#@nonl
#@-node:ekr.20090121163905.1068:@test promote
#@-node:ekr.20090121163905.1054:Fundamental node operations
#@+node:ekr.20090121163905.1069:@test nodeIndices.toString(None) allocates a new index
gnx = g.app.nodeIndices.toString(None)
assert(gnx not in (None,'None'))
assert(len(gnx) > 1)
#@nonl
#@-node:ekr.20090121163905.1069:@test nodeIndices.toString(None) allocates a new index
#@+node:ekr.20090121163905.1070:@@test visback
p1 = p.copy()
a = p.firstChild()
b = a.firstChild()
c2 = b.firstChild()
limit = a.next()
d = limit.firstChild()
e = limit.next()
assert e.h == 'e'
for p2,h in ((a,'a'),(b,'b'),(c2,'c2'),(d,'d'),(limit,'limit')):
    p2.expand()
    assert p2.h==h,'headString mismatch'

try: # Tests without hoist...
    p1.expand()
    assert not c.hoistStack
    c.selectPosition(limit)
    result = limit.copy().moveToVisBack(c)
    assert result==c2,'visBack != c2: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'visNext != d: %s' % result
finally:
    p1.contract()

try: # Tests with hoist.
    p1.expand()
    c.selectPosition(limit)
    c.hoist()
    result = limit.copy().moveToVisBack(c)
    assert not result,'limited visBack: %s' % result
    #
    result = limit.copy().moveToVisNext(c)
    assert result==d,'limited visNext !=d: %s' % result
finally:
    c.dehoist()
    c.selectPosition(p1)
    p1.contract()
    c.redraw_now()
#@+node:ekr.20090121163905.1071:a
#@+node:ekr.20090121163905.1072:b
#@+node:ekr.20090121163905.1073:c2
#@-node:ekr.20090121163905.1073:c2
#@-node:ekr.20090121163905.1072:b
#@-node:ekr.20090121163905.1071:a
#@+node:ekr.20090121163905.1074:limit
#@+node:ekr.20090121163905.1075:d
#@-node:ekr.20090121163905.1075:d
#@-node:ekr.20090121163905.1074:limit
#@+node:ekr.20090121163905.1076:e
#@-node:ekr.20090121163905.1076:e
#@-node:ekr.20090121163905.1070:@@test visback
#@+node:ekr.20090121163905.1077:@test convertTreeToString and allies
p = p.firstChild()
assert(p.h=="File Conversion")
p.convertTreeToString()
#@nonl
#@+node:ekr.20090121163905.1078:File Conversion
@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
#@+node:ekr.20090121163905.1079:moreHead
def moreHead (self, firstLevel,useVerticalBar=False):

    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")

    return "%s%s %s" % ('\t'*level,plusMinus,p.h)
#@nonl
#@-node:ekr.20090121163905.1079:moreHead
#@+node:ekr.20090121163905.1080:moreBody
@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  

    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []

    # Only escape the first non-blank character of the line.
    s =  p.b ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i < len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
#@-node:ekr.20090121163905.1080:moreBody
#@-node:ekr.20090121163905.1078:File Conversion
#@-node:ekr.20090121163905.1077:@test convertTreeToString and allies
#@+node:ekr.20090121163905.1081:tests for p.textOffset()
#@+node:ekr.20090121163905.1082:@test node that doesn't belong to a derived file
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:

    p1 = p.insertAsLastChild()
    assert p1.textOffset() == 0

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
#@-node:ekr.20090121163905.1082:@test node that doesn't belong to a derived file
#@+node:ekr.20090121163905.1083:@test root of a derived file
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:

    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    assert p1.textOffset() == 0

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
#@-node:ekr.20090121163905.1083:@test root of a derived file
#@+node:ekr.20090121163905.1084:@test organizer node
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:

    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    p2 = p1.insertAsLastChild()
    assert p1.textOffset() == 0
    assert p2.textOffset() == 0

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
#@-node:ekr.20090121163905.1084:@test organizer node
#@+node:ekr.20090121163905.1085:@test section node
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:

    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    body = '''   %s
    ''' % (g.angleBrackets(' section '))
    p1.setBodyString(body)
    p2 = p1.insertAsLastChild()
    head = g.angleBrackets(' section ')
    p2.setHeadString(head)
    assert p1.textOffset() == 0
    assert p2.textOffset() == 3

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
#@-node:ekr.20090121163905.1085:@test section node
#@+node:ekr.20090121163905.1086:@test "others" directive
root = p.copy()
while p.hasChildren():
    p.firstChild().doDelete(newNode = None)

try:

    p1 = p.insertAsLastChild()
    p1.setHeadString('@file zzz')
    body = '''     %s
    ''' % (chr(64) + 'others') # ugly hack
    p1.setBodyString(body)
    p2 = p1.insertAsLastChild()
    assert p1.textOffset() == 0
    assert p2.textOffset() == 5
    root.firstChild().doDelete(newNode = None)

finally:
    if 1:
        while root.hasChildren():
            root.firstChild().doDelete(newNode = None)
    c.redraw_now()
#@-node:ekr.20090121163905.1086:@test "others" directive
#@-node:ekr.20090121163905.1081:tests for p.textOffset()
#@+node:ekr.20090121163905.1087:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoNodes tests.')
#@nonl
#@-node:ekr.20090121163905.1087:@test zz restore the screen
#@-node:ekr.20090121163905.1009:leoNodes
#@+node:ekr.20090121163905.1088:leoPlugins
#@+node:ekr.20090121163905.1089:@test getHandlersForTag
import leo.core.leoPlugins as leoPlugins

aList1 = leoPlugins.getHandlersForTag('select1')
aList2 = leoPlugins.getHandlersForOneTag('select1')

assert type(aList1) == type([])
assert type(aList2) == type([])
assert aList1 == aList2
#@-node:ekr.20090121163905.1089:@test getHandlersForTag
#@-node:ekr.20090121163905.1088:leoPlugins
#@+node:ekr.20090121163905.1090:leoShadow
#@+node:ekr.20090121163905.1091:@suite run @shadow-test nodes in the @shadow-tests tree
import unittest

if 1:
    x = c.shadowController
else:
    import leo.core.leoShadow as leoShadow
    x = leoShadow.shadowController(c,trace=False,trace_writers=False)

suite = unittest.makeSuite(unittest.TestCase)
root = g.findNodeAnywhere(c,'@shadow-tests')
assert root, 'Node not found: @shadow-tests'

trace = False ; vrbose = False
for p in root.children_iter():
    h = p.h.strip()
    if h.startswith('@shadow-test-lax'):
        test = x.atShadowTestCase(c,p,x,lax=True)
    elif h.startswith('@shadow-test'):
        test = x.atShadowTestCase(c,p,x,lax=False)
    else:
        test = None
    if test:
        if trace and verbose: print(h)
        suite.addTest(test)
if suite:
    g.app.scriptDict['suite'] = suite
#@-node:ekr.20090121163905.1091:@suite run @shadow-test nodes in the @shadow-tests tree
#@+node:ekr.20090121163905.1092:@shadow-tests
@

All the tags should be tested at least once (equal, replace, delete, insert).

The replace, delete, insert operations should happen at least once:
    1. At the beginning of a node.
    2. In the middle of a node.
    3. At the end of a node.

For the delete and replace operators we must also test the case that the
deletion or replacement spans more than one block.
#@+node:ekr.20090121163905.1093:passed
#@-node:ekr.20090121163905.1093:passed
#@+node:ekr.20090121163905.1094:@shadow-test change middle line
#@+node:ekr.20090121163905.1095:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1095:old
#@+node:ekr.20090121163905.1096:new
line 1
line 2 changed
line 3
#@nonl
#@-node:ekr.20090121163905.1096:new
#@-node:ekr.20090121163905.1094:@shadow-test change middle line
#@+node:ekr.20090121163905.1097:@shadow-test change first line
#@+node:ekr.20090121163905.1098:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1098:old
#@+node:ekr.20090121163905.1099:new
line 1 changed
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1099:new
#@-node:ekr.20090121163905.1097:@shadow-test change first line
#@+node:ekr.20090121163905.1100:@shadow-test change last line
#@+node:ekr.20090121163905.1101:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1101:old
#@+node:ekr.20090121163905.1102:new
line 1
line 2
line 3 changed
#@nonl
#@-node:ekr.20090121163905.1102:new
#@-node:ekr.20090121163905.1100:@shadow-test change last line
#@+node:ekr.20090121163905.1103:@shadow-test delete first line
#@+node:ekr.20090121163905.1104:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1104:old
#@+node:ekr.20090121163905.1105:new
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1105:new
#@-node:ekr.20090121163905.1103:@shadow-test delete first line
#@+node:ekr.20090121163905.1106:@shadow-test delete middle line
#@+node:ekr.20090121163905.1107:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1107:old
#@+node:ekr.20090121163905.1108:new
line 1
line 3
#@nonl
#@-node:ekr.20090121163905.1108:new
#@-node:ekr.20090121163905.1106:@shadow-test delete middle line
#@+node:ekr.20090121163905.1109:@shadow-test delete last line
#@+node:ekr.20090121163905.1110:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1110:old
#@+node:ekr.20090121163905.1111:new
line 1
line 2
#@nonl
#@-node:ekr.20090121163905.1111:new
#@-node:ekr.20090121163905.1109:@shadow-test delete last line
#@+node:ekr.20090121163905.1112:@shadow-test insert before first line
#@+node:ekr.20090121163905.1113:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1113:old
#@+node:ekr.20090121163905.1114:new
inserted line
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1114:new
#@-node:ekr.20090121163905.1112:@shadow-test insert before first line
#@+node:ekr.20090121163905.1115:@shadow-test insert after first line
#@+node:ekr.20090121163905.1116:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1116:old
#@+node:ekr.20090121163905.1117:new
line 1
inserted line
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1117:new
#@-node:ekr.20090121163905.1115:@shadow-test insert after first line
#@+node:ekr.20090121163905.1118:@shadow-test insert before last line
#@+node:ekr.20090121163905.1119:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1119:old
#@+node:ekr.20090121163905.1120:new
line 1
line 2
inserted line
line 3
#@nonl
#@-node:ekr.20090121163905.1120:new
#@-node:ekr.20090121163905.1118:@shadow-test insert before last line
#@+node:ekr.20090121163905.1121:@shadow-test insert after last line
#@+node:ekr.20090121163905.1122:old
line 1
line 2
line 3
#@nonl
#@-node:ekr.20090121163905.1122:old
#@+node:ekr.20090121163905.1123:new
line 1
line 2
line 3
inserted line
#@nonl
#@-node:ekr.20090121163905.1123:new
#@-node:ekr.20090121163905.1121:@shadow-test insert after last line
#@+node:ekr.20090121163905.1124:@shadow-test-lax insert between nodes: at end of prev node
#@+node:ekr.20090121163905.1125:old
@others
#@nonl
#@+node:ekr.20090121163905.1126:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1126:node 1
#@+node:ekr.20090121163905.1127:node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1127:node 2
#@-node:ekr.20090121163905.1125:old
#@+node:ekr.20090121163905.1128:new
@others
#@nonl
#@+node:ekr.20090121163905.1129:node 1
node 1 line 1
inserted node at end of node 1
#@nonl
#@-node:ekr.20090121163905.1129:node 1
#@+node:ekr.20090121163905.1130:node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1130:node 2
#@-node:ekr.20090121163905.1128:new
#@-node:ekr.20090121163905.1124:@shadow-test-lax insert between nodes: at end of prev node
#@+node:ekr.20090121163905.1131:@shadow-test insert between nodes: at start of next node
#@+node:ekr.20090121163905.1132:old
@others
#@nonl
#@+node:ekr.20090121163905.1133:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1133:node 1
#@+node:ekr.20090121163905.1134:node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1134:node 2
#@-node:ekr.20090121163905.1132:old
#@+node:ekr.20090121163905.1135:new
@others
#@nonl
#@+node:ekr.20090121163905.1136:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1136:node 1
#@+node:ekr.20090121163905.1137:node 2
inserted node at start of node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1137:node 2
#@-node:ekr.20090121163905.1135:new
#@-node:ekr.20090121163905.1131:@shadow-test insert between nodes: at start of next node
#@+node:ekr.20090121163905.1138:@shadow-test delete between nodes: at end of prev node
#@+node:ekr.20090121163905.1139:old
@others
#@nonl
#@+node:ekr.20090121163905.1140:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1140:node 1
#@+node:ekr.20090121163905.1141:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1141:node 2
#@-node:ekr.20090121163905.1139:old
#@+node:ekr.20090121163905.1142:new
@others
#@nonl
#@+node:ekr.20090121163905.1143:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1143:node 1
#@+node:ekr.20090121163905.1144:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1144:node 2
#@-node:ekr.20090121163905.1142:new
#@-node:ekr.20090121163905.1138:@shadow-test delete between nodes: at end of prev node
#@+node:ekr.20090121163905.1145:@shadow-test delete between nodes: at start of next node
#@+node:ekr.20090121163905.1146:old
@others
#@nonl
#@+node:ekr.20090121163905.1147:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1147:node 1
#@+node:ekr.20090121163905.1148:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1148:node 2
#@-node:ekr.20090121163905.1146:old
#@+node:ekr.20090121163905.1149:new
@others
#@nonl
#@+node:ekr.20090121163905.1150:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1150:node 1
#@+node:ekr.20090121163905.1151:node 2
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1151:node 2
#@-node:ekr.20090121163905.1149:new
#@-node:ekr.20090121163905.1145:@shadow-test delete between nodes: at start of next node
#@+node:ekr.20090121163905.1152:@shadow-test change end of prev node
#@+node:ekr.20090121163905.1153:old
@others
#@nonl
#@+node:ekr.20090121163905.1154:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1154:node 1
#@+node:ekr.20090121163905.1155:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1155:node 2
#@-node:ekr.20090121163905.1153:old
#@+node:ekr.20090121163905.1156:new
@others
#@nonl
#@+node:ekr.20090121163905.1157:node 1
node 1 line 1
node 1 line 1 changed
#@nonl
#@-node:ekr.20090121163905.1157:node 1
#@+node:ekr.20090121163905.1158:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1158:node 2
#@-node:ekr.20090121163905.1156:new
#@-node:ekr.20090121163905.1152:@shadow-test change end of prev node
#@+node:ekr.20090121163905.1159:@shadow-test change start of next node
#@+node:ekr.20090121163905.1160:old
@others
#@nonl
#@+node:ekr.20090121163905.1161:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1161:node 1
#@+node:ekr.20090121163905.1162:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1162:node 2
#@-node:ekr.20090121163905.1160:old
#@+node:ekr.20090121163905.1163:new
@others
#@nonl
#@+node:ekr.20090121163905.1164:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1164:node 1
#@+node:ekr.20090121163905.1165:node 2
node 2 line 1 changed
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1165:node 2
#@-node:ekr.20090121163905.1163:new
#@-node:ekr.20090121163905.1159:@shadow-test change start of next node
#@+node:ekr.20090121163905.1166:@shadow-test-lax multiple-line insert between nodes: at end of prev node
#@+node:ekr.20090121163905.1167:old
@others
#@nonl
#@+node:ekr.20090121163905.1168:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1168:node 1
#@+node:ekr.20090121163905.1169:node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1169:node 2
#@-node:ekr.20090121163905.1167:old
#@+node:ekr.20090121163905.1170:new
@others
#@nonl
#@+node:ekr.20090121163905.1171:node 1
node 1 line 1
inserted node 1 at end of node 1
inserted node 2 at end of node 1
#@nonl
#@-node:ekr.20090121163905.1171:node 1
#@+node:ekr.20090121163905.1172:node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1172:node 2
#@-node:ekr.20090121163905.1170:new
#@-node:ekr.20090121163905.1166:@shadow-test-lax multiple-line insert between nodes: at end of prev node
#@+node:ekr.20090121163905.1173:@shadow-test multiple-line insert between nodes: at start of next node
#@+node:ekr.20090121163905.1174:old
@others
#@nonl
#@+node:ekr.20090121163905.1175:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1175:node 1
#@+node:ekr.20090121163905.1176:node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1176:node 2
#@-node:ekr.20090121163905.1174:old
#@+node:ekr.20090121163905.1177:new
@others
#@nonl
#@+node:ekr.20090121163905.1178:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1178:node 1
#@+node:ekr.20090121163905.1179:node 2
inserted node 1 at start of node 2
inserted node 2 at start of node 2
node 2 line 1
#@nonl
#@-node:ekr.20090121163905.1179:node 2
#@-node:ekr.20090121163905.1177:new
#@-node:ekr.20090121163905.1173:@shadow-test multiple-line insert between nodes: at start of next node
#@+node:ekr.20090121163905.1180:@shadow-test multiple-line change end of prev node
#@+node:ekr.20090121163905.1181:old
@others
#@nonl
#@+node:ekr.20090121163905.1182:node 1
node 1 line 1
node 1 line 2
node 1 line 3
#@nonl
#@-node:ekr.20090121163905.1182:node 1
#@+node:ekr.20090121163905.1183:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1183:node 2
#@-node:ekr.20090121163905.1181:old
#@+node:ekr.20090121163905.1184:new
@others
#@nonl
#@+node:ekr.20090121163905.1185:node 1
node 1 line 1
node 1 line 2 changed
node 1 line 3 changed
#@nonl
#@-node:ekr.20090121163905.1185:node 1
#@+node:ekr.20090121163905.1186:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1186:node 2
#@-node:ekr.20090121163905.1184:new
#@-node:ekr.20090121163905.1180:@shadow-test multiple-line change end of prev node
#@+node:ekr.20090121163905.1187:@shadow-test multiple-line change start of next node
#@+node:ekr.20090121163905.1188:old
@others
#@nonl
#@+node:ekr.20090121163905.1189:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1189:node 1
#@+node:ekr.20090121163905.1190:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1190:node 2
#@-node:ekr.20090121163905.1188:old
#@+node:ekr.20090121163905.1191:new
@others
#@nonl
#@+node:ekr.20090121163905.1192:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1192:node 1
#@+node:ekr.20090121163905.1193:node 2
node 2 line 1 changed
node 2 line 2 changed
#@nonl
#@-node:ekr.20090121163905.1193:node 2
#@-node:ekr.20090121163905.1191:new
#@-node:ekr.20090121163905.1187:@shadow-test multiple-line change start of next node
#@+node:ekr.20090121163905.1194:@shadow-test multiple-line delete between nodes: at end of prev node
#@+node:ekr.20090121163905.1195:old
@others
#@nonl
#@+node:ekr.20090121163905.1196:node 1
node 1 line 1
node 1 line 2
node 1 line 3
#@nonl
#@-node:ekr.20090121163905.1196:node 1
#@+node:ekr.20090121163905.1197:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1197:node 2
#@-node:ekr.20090121163905.1195:old
#@+node:ekr.20090121163905.1198:new
@others
#@nonl
#@+node:ekr.20090121163905.1199:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1199:node 1
#@+node:ekr.20090121163905.1200:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1200:node 2
#@-node:ekr.20090121163905.1198:new
#@-node:ekr.20090121163905.1194:@shadow-test multiple-line delete between nodes: at end of prev node
#@+node:ekr.20090121163905.1201:@shadow-test multiple-line delete between nodes: at start of next node
#@+node:ekr.20090121163905.1202:old
@others
#@nonl
#@+node:ekr.20090121163905.1203:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1203:node 1
#@+node:ekr.20090121163905.1204:node 2
node 2 line 1
node 2 line 2
node 2 line 3
#@nonl
#@-node:ekr.20090121163905.1204:node 2
#@-node:ekr.20090121163905.1202:old
#@+node:ekr.20090121163905.1205:new
@others
#@nonl
#@+node:ekr.20090121163905.1206:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1206:node 1
#@+node:ekr.20090121163905.1207:node 2
node 2 line 3
#@nonl
#@-node:ekr.20090121163905.1207:node 2
#@-node:ekr.20090121163905.1205:new
#@-node:ekr.20090121163905.1201:@shadow-test multiple-line delete between nodes: at start of next node
#@+node:ekr.20090121163905.1208:@shadow-test verbatim sentinels-delete verbatim line
#@+node:ekr.20090121163905.1209:old
@others
#@nonl
#@+node:ekr.20090121163905.1210:node 1
node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@ should be handled by verbatim
line 1 line 3
#@nonl
#@-node:ekr.20090121163905.1210:node 1
#@+node:ekr.20090121163905.1211:node 2
node 2 line 1
node 2 line 2
node 2 line 3
#@nonl
#@-node:ekr.20090121163905.1211:node 2
#@-node:ekr.20090121163905.1209:old
#@+node:ekr.20090121163905.1212:new
@others
#@nonl
#@+node:ekr.20090121163905.1213:node 1
node 1 line 1
line 1 line 3
#@nonl
#@-node:ekr.20090121163905.1213:node 1
#@+node:ekr.20090121163905.1214:node 2
node 2 line 1
node 2 line 2
node 2 line 3
#@nonl
#@-node:ekr.20090121163905.1214:node 2
#@-node:ekr.20090121163905.1212:new
#@-node:ekr.20090121163905.1208:@shadow-test verbatim sentinels-delete verbatim line
#@+node:ekr.20090121163905.1215:@shadow-test verbatim sentinels-delete verbatim line: at start of node
#@+node:ekr.20090121163905.1216:old
@others
#@nonl
#@+node:ekr.20090121163905.1217:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1217:node 1
#@+node:ekr.20090121163905.1218:node 2
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@ should be handled by verbatim
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1218:node 2
#@-node:ekr.20090121163905.1216:old
#@+node:ekr.20090121163905.1219:new
@others
#@nonl
#@+node:ekr.20090121163905.1220:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1220:node 1
#@+node:ekr.20090121163905.1221:node 2
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1221:node 2
#@-node:ekr.20090121163905.1219:new
#@-node:ekr.20090121163905.1215:@shadow-test verbatim sentinels-delete verbatim line: at start of node
#@+node:ekr.20090121163905.1222:@shadow-test verbatim sentinels-no change
#@+node:ekr.20090121163905.1223:old
@others
#@nonl
#@+node:ekr.20090121163905.1224:node 1
node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@ should be handled by verbatim
line 1 line 3
#@nonl
#@-node:ekr.20090121163905.1224:node 1
#@+node:ekr.20090121163905.1225:node 2
node 2 line 1
node 2 line 2
node 2 line 3
#@nonl
#@-node:ekr.20090121163905.1225:node 2
#@-node:ekr.20090121163905.1223:old
#@+node:ekr.20090121163905.1226:new
@others
#@nonl
#@+node:ekr.20090121163905.1227:node 1
node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@ should be handled by verbatim
line 1 line 3
#@nonl
#@-node:ekr.20090121163905.1227:node 1
#@+node:ekr.20090121163905.1228:node 2
node 2 line 1
node 2 line 2
node 2 line 3
#@nonl
#@-node:ekr.20090121163905.1228:node 2
#@-node:ekr.20090121163905.1226:new
#@-node:ekr.20090121163905.1222:@shadow-test verbatim sentinels-no change
#@+node:ekr.20090121163905.1229:@shadow-test verbatim sentinels-delete verbatim line: at end of node
#@+node:ekr.20090121163905.1230:old
@others
#@nonl
#@+node:ekr.20090121163905.1231:node 1
node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@ should be handled by verbatim
#@nonl
#@-node:ekr.20090121163905.1231:node 1
#@+node:ekr.20090121163905.1232:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1232:node 2
#@-node:ekr.20090121163905.1230:old
#@+node:ekr.20090121163905.1233:new
@others
#@nonl
#@+node:ekr.20090121163905.1234:node 1
node 1 line 1
#@nonl
#@-node:ekr.20090121163905.1234:node 1
#@+node:ekr.20090121163905.1235:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1235:node 2
#@-node:ekr.20090121163905.1233:new
#@-node:ekr.20090121163905.1229:@shadow-test verbatim sentinels-delete verbatim line: at end of node
#@+node:ekr.20090121163905.1236:@shadow-test verbatim sentinels-add verbatim line
#@+node:ekr.20090121163905.1237:old
@others
#@nonl
#@+node:ekr.20090121163905.1238:node 1
node 1 line 1
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1238:node 1
#@+node:ekr.20090121163905.1239:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1239:node 2
#@-node:ekr.20090121163905.1237:old
#@+node:ekr.20090121163905.1240:new
@others
#@nonl
#@+node:ekr.20090121163905.1241:node 1
node 1 line 1
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
@verbatim
#@verbatim
#@ should be handled by verbatim
node 1 line 2
#@nonl
#@-node:ekr.20090121163905.1241:node 1
#@+node:ekr.20090121163905.1242:node 2
node 2 line 1
node 2 line 2
#@nonl
#@-node:ekr.20090121163905.1242:node 2
#@-node:ekr.20090121163905.1240:new
#@-node:ekr.20090121163905.1236:@shadow-test verbatim sentinels-add verbatim line
#@-node:ekr.20090121163905.1092:@shadow-tests
#@+node:ekr.20090121163905.1243:Other unit tests of shadowController
#@+node:ekr.20090121163905.1244:@test x.baseDirName
x = c.shadowController

path = x.baseDirName()
expected = g.os_path_dirname(g.os_path_abspath(g.os_path_join(c.fileName())))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
#@nonl
#@-node:ekr.20090121163905.1244:@test x.baseDirName
#@+node:ekr.20090121163905.1245:@test x.pathName
x = c.shadowController

filename = 'xyzzy'

path = x.pathName(filename)
expected = g.os_path_abspath(g.os_path_join(x.baseDirName(),filename))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
#@nonl
#@-node:ekr.20090121163905.1245:@test x.pathName
#@+node:ekr.20090121163905.1246:@test x.dirName
x = c.shadowController

filename = 'xyzzy'
path = x.dirName(filename)
expected = g.os_path_dirname(g.os_path_abspath(
    g.os_path_join(g.os_path_dirname(c.fileName()),filename)))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
#@nonl
#@-node:ekr.20090121163905.1246:@test x.dirName
#@+node:ekr.20090121163905.1247:@test x.shadowPathName
x = c.shadowController

subdir = c.config.getString('shadow_subdir') or 'LeoFolder'
prefix = c.config.getString('shadow_prefix') or ''

# print('c.fileName',c.fileName())
# print('c.relativeFileName',c.relativeFileName())

filename = 'xyzzy'
path = x.shadowPathName(filename)
expected = g.os_path_abspath(g.os_path_join(
    g.os_path_dirname(c.fileName()),subdir,prefix+filename))

if 0:
    print('prefix',prefix)
    print(path)
    print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
#@nonl
#@-node:ekr.20090121163905.1247:@test x.shadowPathName
#@+node:ekr.20090121163905.1248:@test x.shadowDirName
x = c.shadowController

subdir = c.config.getString('shadow_subdir') or 'LeoFolder'
prefix = c.config.getString('shadow_prefix') or ''

# print('c.fileName',c.fileName())
# print('c.relativeFileName',c.relativeFileName())

filename = 'xyzzy'
path = x.shadowDirName(filename)
expected = g.os_path_abspath(
    g.os_path_join(g.os_path_dirname(c.fileName()),subdir))

# print(path)
# print(expected)

assert path == expected,'\nexpected: %s\ngot     : %s' % (expected,path)
#@nonl
#@-node:ekr.20090121163905.1248:@test x.shadowDirName
#@+node:ekr.20090121163905.1249:@test x.rename
x = c.shadowController

filename = x.pathName('xyzzy')
assert not g.os_path_exists(filename)
n = x.errors
x.rename('xyzzy','xyzzy2',silent=True)
assert x.errors == n+1
assert x.last_error.startswith('can not rename')
# print(x.last_error)
#@nonl
#@-node:ekr.20090121163905.1249:@test x.rename
#@+node:ekr.20090121163905.1250:@test x.unlink
x = c.shadowController

filename = x.pathName('xyzzy')
# print(filename)
assert not g.os_path_exists(filename)
n = x.errors
x.unlink('xyzzy',silent=True)
assert x.errors == n+1
assert x.last_error.startswith('can not delete xyzzy')
# print(x.last_error)
#@nonl
#@-node:ekr.20090121163905.1250:@test x.unlink
#@+node:ekr.20090121163905.1251:@test x.makeShadowDirectory
import glob
import os

x = c.shadowController

@others

shadow_fn  = x.shadowPathName('unittest/xyzzy')
shadow_dir = x.shadowDirName('unittest/xyzzy')

if g.os_path_exists(shadow_fn):
    g.utils_remove(shadow_fn,verbose=True)
    assert not os.path.exists(shadow_fn),'still exists: %s' % shadow_fn

deleteShadowDir(shadow_dir)

x.makeShadowDirectory(shadow_dir)
assert os.path.exists(shadow_dir)

deleteShadowDir(shadow_dir)
#@+node:ekr.20090121163905.1252:deleteShadowDir
def deleteShadowDir(shadowDir):

    if g.os_path_exists(shadow_dir):
        files = g.os_path_abspath(g.os_path_join(shadow_dir,"*.*"))
        files = glob.glob(files)
        for z in files:
            if z != shadow_dir:
                os.unlink(z)
        os.rmdir(shadow_dir)
        assert not os.path.exists(shadow_dir),'still exists: %s' % shadow_dir
#@nonl
#@-node:ekr.20090121163905.1252:deleteShadowDir
#@-node:ekr.20090121163905.1251:@test x.makeShadowDirectory
#@+node:ekr.20090121163905.1253:@test x.replaceFileWithString
x = c.shadowController
s = 'abc'

fn = '../test/unittest/replaceFileWithStringTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,fn))

x.replaceFileWithString(path,s)
f = file(path)
s2 = f.read()
f.close()
assert s == s2
#@nonl
#@-node:ekr.20090121163905.1253:@test x.replaceFileWithString
#@+node:ekr.20090121163905.1254:@test x.markerFromExtension
x = c.shadowController

table = (
    ('ini',';@'),
    ('c','//@'),
    ('h','//@'),
    ('py','#@'),
    ('xyzzy','#--unknown-language--@'),
)

for ext,result in table:
    filename = 'x.%s' % ext
    z = x.marker_from_extension(filename)
    assert result == z, 'ext=%s, got %s, expected %s' % (ext,z,result)
#@-node:ekr.20090121163905.1254:@test x.markerFromExtension
#@+node:ekr.20090121163905.1255:@@test (minitest) x.show_error
x = c.shadowController

lines1 = ('a','b','c')
lines2 = ('a','x','c')

x.show_error(
    lines1,lines2,
    message = "Test of x.show_error",
    lines1_message = "lines1",
    lines2_message = "lines2")
#@-node:ekr.20090121163905.1255:@@test (minitest) x.show_error
#@-node:ekr.20090121163905.1243:Other unit tests of shadowController
#@+node:ekr.20090121163905.1256:Unit tests for atFileCommands
#@+node:ekr.20090121163905.1257:@test at.open/closeStringFile
at = c.atFileCommands

# at.toString is set by the execute-script command.

f = at.openStringFile('abc')

assert f.__class__.__name__ == 'fileLikeObject'

s = 'abc'
f.write(s)
s2 = at.closeStringFile(f)

assert s == s2

# assert at.toString

#@-node:ekr.20090121163905.1257:@test at.open/closeStringFile
#@+node:ekr.20090121163905.1258:@test at.openForWrite: not a shadow file
at = c.atFileCommands
x = c.shadowController

filename = x.pathName('xyzzy')
assert not g.os_path_exists(filename)

try:
    kind,theFile = at.openForWrite(filename)
    assert kind == 'check'
    # print(repr(theFile))
    if theFile: theFile.close()

finally:
    if g.os_path_exists(filename):
        x.unlink(filename)
        assert not g.os_path_exists(filename)
#@nonl
#@-node:ekr.20090121163905.1258:@test at.openForWrite: not a shadow file
#@+node:ekr.20090121163905.1259:@test at.readOneAtShadowNode
at = c.atFileCommands
x = c.shadowController

changed = c.changed
child = p.firstChild()
s = child.b

try:
    fn = 'unittest/read_test.py'
    child.setHeadString('@shadow %s' % fn)
    # shadow_fn = x.shadowPathName(fn)
    at.writeOneAtShadowNode(child,toString=False,force=True)
    at.readOneAtShadowNode(fn,child)
finally:
    child.setHeadString('@@shadow %s' % fn)
    c.setChanged(changed)
    # c.redraw_now()
#@nonl
#@+node:ekr.20090121163905.1260:@@shadow unittest/read_test.py
@language python
@tabwidth -4
@others
# body of @shadow test node
# The last line.
#@-node:ekr.20090121163905.1260:@@shadow unittest/read_test.py
#@-node:ekr.20090121163905.1259:@test at.readOneAtShadowNode
#@+node:ekr.20090121163905.1261:@test at.replaceFileWithString
import os
s = 'abc'
fn = 'unitTestFile.py'
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','unittest',fn))
try:
    c.atFileCommands.replaceFileWithString(path,s)
    f = file(path)
    s2 = f.read()
    f.close()
    assert s == s2
finally:
    if g.os_path_exists(path):
        os.unlink(path)
#@nonl
#@-node:ekr.20090121163905.1261:@test at.replaceFileWithString
#@+node:ekr.20090121163905.1262:@test at.writeOneAtShadowNode
at = c.atFileCommands
x = c.shadowController
changed = c.changed
child = p.firstChild()
s = child.b

try:
    child.setHeadString('@shadow unittest/test_1.py')
    fn = 'unittest/test_1.py'
    shadow_fn = x.shadowPathName(fn)
    shadow_dir = x.shadowDirName(fn)
    x.makeShadowDirectory(shadow_dir)
    if g.os_path_exists(shadow_fn):
        g.utils_remove(shadow_fn,verbose=True)
    at.writeOneAtShadowNode(child,toString=True,force=True)
    assert at.startSentinelComment == '#',repr(at.startSentinelComment)
    assert at.endSentinelComment == None,repr(at.endSentinelComment)
    if 0:
        print('public...\n',at.public_s)
        print('private...\n',at.private_s)
    at.writeOneAtShadowNode(child,toString=False,force=True)
    # assert at.stringOutput == s,'got %s, expected %s' % (repr(at.stringOutput),repr(s))
    assert g.os_path_exists(shadow_fn)
    # No need to remove this: it's in the unittest directory.
    # g.utils_remove(shadow_fn,verbose=True)
finally:

    child.setHeadString('@@shadow unittest/test_1.py')
    c.setChanged(changed)
    # c.redraw_now()
#@nonl
#@+node:ekr.20090121163905.1263:@@shadow unittest/test_1.py
# body of @shadow test node
# The last line.
#@nonl
#@-node:ekr.20090121163905.1263:@@shadow unittest/test_1.py
#@-node:ekr.20090121163905.1262:@test at.writeOneAtShadowNode
#@-node:ekr.20090121163905.1256:Unit tests for atFileCommands
#@+node:ekr.20090121163905.1264:@test delete unittest shadow directory
# This unit test should come last.

import glob
import os

x = c.shadowController

shadow_dir = x.shadowDirName('unittest/xyzzy')

if g.os_path_exists(shadow_dir):
    files = g.os_path_abspath(g.os_path_join(shadow_dir,"*.*"))
    files = glob.glob(files)
    for z in files:
        if z != shadow_dir:
            os.unlink(z)
    os.rmdir(shadow_dir)
    assert not os.path.exists(shadow_dir)
    # g.es_print('deleted directory',shadow_dir,color='red')
#@-node:ekr.20090121163905.1264:@test delete unittest shadow directory
#@-node:ekr.20090121163905.1090:leoShadow
#@+node:ekr.20090121163905.1265:leoTangle
#@+node:ekr.20090121163905.1266:@test tangle.scanAllDirectives
# This will work regardless of where this method is.
@language python
@tabwidth -4

d = c.tangleCommands.scanAllDirectives(
    p,require_path_flag=False,issue_error_flag=False)

assert d.get('encoding') == 'utf-8'
assert d.get('language') == 'python'
assert d.get('pagewidth') == 80
assert d.get('path') == g.os_path_finalize_join(g.app.loadDir,'..','test')
assert d.get('tabwidth') == -4
#@-node:ekr.20090121163905.1266:@test tangle.scanAllDirectives
#@+node:ekr.20090121163905.1267:@test @root
import leo.core.leoTest as leoTest

leoTest.runAtFileTest(c,p)
#@nonl
#@+node:ekr.20090121163905.1268:#@root
@root 'root-test'

# A totally simple test of @root.
#@nonl
#@-node:ekr.20090121163905.1268:#@root
#@+node:ekr.20090121163905.1269:Output
# A totally simple test of @root.
#@-node:ekr.20090121163905.1269:Output
#@-node:ekr.20090121163905.1267:@test @root
#@-node:ekr.20090121163905.1265:leoTangle
#@+node:ekr.20090121163905.1270:leoTest
#@+node:ekr.20090121163905.1271:@test unit testing with embedded class
def sendEmail(self):
    pass # g.trace('self2',self)

class test:
    pass

X = test()
sendEmail(X)
#@-node:ekr.20090121163905.1271:@test unit testing with embedded class
#@-node:ekr.20090121163905.1270:leoTest
#@+node:ekr.20090121163905.1272:leoUndo
@ 

Any unit test that changes the structure of the outline should do the
following:

- The setUp method should do
    self.undoMark = c.undoer.getMark()
before altering the outline.

- The tearDown method should do
    c.undoer.rollBackToMark(self.undoMark)
after restoring the outline.

u.rollBackToMark deletes all entries in the undo stack following the saved mark.
This eliminates references to nodes that no longer exist in the present outline.
#@nonl
#@+node:ekr.20090121163905.1273:@suite Edit body tests
# Create unit tests in g.app.scriptDict["suite"]

import leo.core.leoTest as leoTest

g.app.enableUnitTest = True

suite = leoTest.makeEditBodySuite(c,p)

g.app.scriptDict['suite'] = suite
#@nonl
#@+node:ekr.20090121163905.1274:editBodyTests
@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:

- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
#@nonl
#@+node:ekr.20090121163905.1275:tempNode
#@-node:ekr.20090121163905.1275:tempNode
#@+node:ekr.20090121163905.1276:addComments
#@+node:ekr.20090121163905.1277:before
@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@nonl
#@-node:ekr.20090121163905.1277:before
#@+node:ekr.20090121163905.1278:after
@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
#@nonl
#@-node:ekr.20090121163905.1278:after
#@+node:ekr.20090121163905.1279:selection
5.0
7.8
#@nonl
#@-node:ekr.20090121163905.1279:selection
#@-node:ekr.20090121163905.1276:addComments
#@+node:ekr.20090121163905.1280:convertAllBlanks
#@+node:ekr.20090121163905.1281:before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20090121163905.1281:before
#@+node:ekr.20090121163905.1282:after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20090121163905.1282:after
#@+node:ekr.20090121163905.1283:selection
1.0
6.5
#@nonl
#@-node:ekr.20090121163905.1283:selection
#@-node:ekr.20090121163905.1280:convertAllBlanks
#@+node:ekr.20090121163905.1284:convertAllTabs
#@+node:ekr.20090121163905.1285:before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20090121163905.1285:before
#@+node:ekr.20090121163905.1286:after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20090121163905.1286:after
#@+node:ekr.20090121163905.1287:selection
1.0
6.5
#@nonl
#@-node:ekr.20090121163905.1287:selection
#@-node:ekr.20090121163905.1284:convertAllTabs
#@+node:ekr.20090121163905.1288:convertBlanks
#@+node:ekr.20090121163905.1289:before
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20090121163905.1289:before
#@+node:ekr.20090121163905.1290:after
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20090121163905.1290:after
#@+node:ekr.20090121163905.1291:selection
1.0
6.5
#@nonl
#@-node:ekr.20090121163905.1291:selection
#@-node:ekr.20090121163905.1288:convertBlanks
#@+node:ekr.20090121163905.1292:convertTabs
#@+node:ekr.20090121163905.1293:before
@tabwidth -4

line 1
	line 2
	  line 3
line4
#@nonl
#@-node:ekr.20090121163905.1293:before
#@+node:ekr.20090121163905.1294:after
@tabwidth -4

line 1
    line 2
      line 3
line4
#@nonl
#@-node:ekr.20090121163905.1294:after
#@+node:ekr.20090121163905.1295:selection
1.0
6.5
#@nonl
#@-node:ekr.20090121163905.1295:selection
#@-node:ekr.20090121163905.1292:convertTabs
#@+node:ekr.20090121163905.1296:dedentBody
#@+node:ekr.20090121163905.1297:before
line 1
    line 2
    line 3
line 4
#@nonl
#@-node:ekr.20090121163905.1297:before
#@+node:ekr.20090121163905.1298:after
line 1
line 2
line 3
line 4
#@nonl
#@-node:ekr.20090121163905.1298:after
#@+node:ekr.20090121163905.1299:selection
2.0
3.5
#@nonl
#@-node:ekr.20090121163905.1299:selection
#@-node:ekr.20090121163905.1296:dedentBody
#@+node:ekr.20090121163905.1300:deleteComments
#@+node:ekr.20090121163905.1301:before
@language python

def deleteCommentTest():

    # if 1:
        # a = 2
        # b = 3

    pass
#@nonl
#@-node:ekr.20090121163905.1301:before
#@+node:ekr.20090121163905.1302:after
@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3

    pass
#@nonl
#@-node:ekr.20090121163905.1302:after
#@+node:ekr.20090121163905.1303:selection
5.0
7.8
#@nonl
#@-node:ekr.20090121163905.1303:selection
#@-node:ekr.20090121163905.1300:deleteComments
#@+node:ekr.20090121163905.1304:extract test1
#@+node:ekr.20090121163905.1305:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20090121163905.1305:before
#@+node:ekr.20090121163905.1306:after
before
after
#@nonl
#@+node:ekr.20090121163905.1307:<< section >>
sec line 1
    sec line 2 indented
sec line 3
#@nonl
#@-node:ekr.20090121163905.1307:<< section >>
#@-node:ekr.20090121163905.1306:after
#@+node:ekr.20090121163905.1308:selection
2.0
5.10
#@nonl
#@-node:ekr.20090121163905.1308:selection
#@-node:ekr.20090121163905.1304:extract test1
#@+node:ekr.20090121163905.1309:extract test2
#@+node:ekr.20090121163905.1310:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20090121163905.1310:before
#@+node:ekr.20090121163905.1311:after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20090121163905.1311:after
#@+node:ekr.20090121163905.1312:selection
2.0
2.16
#@nonl
#@-node:ekr.20090121163905.1312:selection
#@-node:ekr.20090121163905.1309:extract test2
#@+node:ekr.20090121163905.1313:extractSection test1
#@+node:ekr.20090121163905.1314:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20090121163905.1314:before
#@+node:ekr.20090121163905.1315:after
before
    << section >>
after
#@nonl
#@+node:ekr.20090121163905.1316:<< section >>
sec line 1
    sec line 2 indented
sec line 3
#@nonl
#@-node:ekr.20090121163905.1316:<< section >>
#@-node:ekr.20090121163905.1315:after
#@+node:ekr.20090121163905.1317:selection
2.0
5.10
#@nonl
#@-node:ekr.20090121163905.1317:selection
#@-node:ekr.20090121163905.1313:extractSection test1
#@+node:ekr.20090121163905.1318:extractSection test2
#@+node:ekr.20090121163905.1319:before
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20090121163905.1319:before
#@+node:ekr.20090121163905.1320:after
before
    << section >>
    sec line 1
        sec line 2 indented
sec line 3
after
#@nonl
#@-node:ekr.20090121163905.1320:after
#@+node:ekr.20090121163905.1321:selection
2.0
2.16
#@nonl
#@-node:ekr.20090121163905.1321:selection
#@-node:ekr.20090121163905.1318:extractSection test2
#@-node:ekr.20090121163905.1274:editBodyTests
#@-node:ekr.20090121163905.1273:@suite Edit body tests
#@+node:ekr.20090121163905.1322:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False

print('\nEnd of leoUndo tests.')
#@nonl
#@-node:ekr.20090121163905.1322:@test zz restore the screen
#@-node:ekr.20090121163905.1272:leoUndo
#@+node:ekr.20090121163905.1323:@test zz restore the screen
# This is **not** a real unit test.
# It simply restores the screen to a more convenient state.

c.contractParent()
g.app.unitTestDict['restoreSelectedNode']=False
#@-node:ekr.20090121163905.1323:@test zz restore the screen
#@-node:ekr.20090121163905.59:Organized by file
#@-all
#@nonl
#@-node:ekr.20090113083258.1:@thin test_core.txt
#@-leo
