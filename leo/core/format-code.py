#@+leo-ver=5-thin
#@+node:ekr.20100811091636.5997: * @thin format-code.py
#@+others
#@+node:ekr.20100811091636.5838: ** @button format-code
'''A script showing how to convert code in Leo outlines to rST/Sphinx code.

The defaultOptions dict specifies default options.'''

#@+<< imports >>
#@+node:ekr.20100811091636.5919: *3* << imports >>
import leo.core.leoGlobals as g

import os
import pprint
import sys

if g.isPython3:
    import io
    StringIO = io.StringIO
else:
    import StringIO
    StringIO = StringIO.StringIO

#@-<< imports >>

h = '@button format-code'
p = g.findNodeAnywhere(c,h)
#@+<< options >>
#@+node:ekr.20100811091636.5995: *3* << options >>
fn = '%s.rst.txt' % (g.sanitize_filename(p.h))
     # 'format-code.rst.txt'

# g.es('output file',repr(fn))

defaultOptionsDict = {
    'code_block_string': '<***code block string***>',
    # 'default_path': None, # Must be None, not ''.
    'encoding': 'utf-8',
    'generate-rst-header-comment': True,
    'number-code-lines': False,
    'output-file-name': fn,
    'publish_argv_for_missing_stylesheets': None,
    'show_doc_parts_as_paragraphs': True,
    # 'show_doc_parts_in_rst_mode': True,
    'show_headlines': True,
    'show_leo_directives': False,
    'show_markup_doc_parts': False,
    'show_options_doc_parts': False,
    'show_options_nodes': False,
    'show_organizer_nodes': True,
    'show_sections': True,
    # 'strip_at_file_prefixes': True,
    'stylesheet_embed': True,
    'stylesheet_name': 'default.css',
    'stylesheet_path': None, # Must be None, not ''.
    'underline_characters': '''#=+*^~"'`-:><_''',
    'verbose': True,
    }
#@-<< options >>

class formatController:

    '''A class to convert a Leo outline to rst/Sphinx markup.
    The outline is presumed to contain computer source code.'''

    #@+others
    #@+node:ekr.20100811091636.5922: *3*  Birth & init
    #@+node:ekr.20100811091636.5923: *4*  ctor (rstClass)
    def __init__ (self,c,p,defaultOptionsDict):

        self.c = c
        self.p = p.copy()
        self.defaultOptionsDict = defaultOptionsDict

        #@+<< init ivars >>
        #@+node:ekr.20100811091636.5924: *5* << init ivars >>
        # The options dictionary.
        self.optionsDict = {}
        self.vnodeOptionDict = {}
        ### self.option_prefix = '@rst-option'

        # Formatting...
        self.code_block_string = ''
        self.node_counter = 0
        self.topLevel = 0
        self.topNode = None

        if 0:# Http support...
            self.nodeNumber = 0
            # All nodes are numbered so that unique anchors can be generated.

            self.http_map = {} 
            # Keys are named hyperlink targets.  Value are positions.
            # The targets mark the beginning of the html code specific
            # for this position.

            self.anchor_map = {}
            # Maps anchors (generated by this module) to positions

        self.rst3_all = False
        # Set to True by the button which processes all @rst trees.

        # For writing.
        self.atAutoWrite = False # True, special cases for writeAtAutoFile.
        self.atAutoWriteUnderlines = '' # Forced underlines for writeAtAutoFile.
        self.leoDirectivesList = g.globalDirectiveList
        self.encoding = 'utf-8'
        self.ext = None # The file extension.
        self.outputFileName = None # The name of the file being written.
        self.outputFile = None # The open file being written.
        self.path = '' # The path from any @path directive.
        self.source = None # The written source as a string.
        self.trialWrite = False # True if doing a trialWrite.
        #@-<< init ivars >>

        ### self.createDefaultOptionsDict()
        self.initOptionsFromSettings() # Still needed.
        ### self.initHeadlineCommands() # Only needs to be done once.
        self.initSingleNodeOptions()
    #@+node:ekr.20100811091636.5928: *4* initSingleNodeOptions
    def initSingleNodeOptions (self):

        self.singleNodeOptions = [
            'ignore_this_headline',
            'ignore_this_node',
            'ignore_this_tree',
            'preformat_this_node',
            'show_this_headline',
        ]
    #@+node:ekr.20100811091636.6000: *3*  Top-Level
    #@+node:ekr.20100811091636.5930: *4* run
    def run (self,event=None):

        fn = self.defaultOptionsDict.get('output-file-name','format-code.rst.txt')
        self.outputFileName = g.os_path_finalize_join(g.app.loadDir,fn)
        self.outputFile = StringIO()
        self.writeTree(self.p.copy())
        s = self.outputFile.getvalue()
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(s)
        self.outputFile.close()
        g.es('rst-format: wrote',self.outputFileName)
    #@+node:ekr.20100811091636.5975: *4* write
    def write (self,s):

        g.trace('%20s %20s %20s %s' % (self.p.h[:20],repr(s)[:20],repr(s)[-20:],g.callers(2)))

        if g.isPython3:
            if g.is_binary_file(self.outputFile):
                s = self.encode(s)
        else:
            s = self.encode(s)

        self.outputFile.write(s)
    #@+node:ekr.20100811091636.5976: *4* writeBody & helper
    def writeBody (self,p):

        # g.trace(p.h,p.b)

        self.p = p.copy() # for traces.

        # remove trailing cruft and split into lines.
        lines = g.splitLines(p.b)

        if 1:
            if not self.getOption('show_options_doc_parts'):
                lines = self.handleSpecialDocParts(lines,'@rst-options',
                    retainContents=False)

            if not self.getOption('show_markup_doc_parts'):
                lines = self.handleSpecialDocParts(lines,'@rst-markup',
                    retainContents=False)
            if not self.getOption('show_leo_directives'):
                lines = self.removeLeoDirectives(lines)

        if 0:
            lines = self.handleCodeMode(lines)

        # Write the lines.
        s = ''.join(lines)

        # We no longer add newlines to the start of nodes because
        # we write a blank line after all sections.
        # s = g.ensureLeadingNewlines(s,1)
        s = g.ensureTrailingNewlines(s,2)
        self.write(s)
    #@+node:ekr.20100811091636.5963: *5* handleCodeMode & helper
    def handleCodeMode (self,lines):

        '''Handle the preprocessed body text in code mode as follows:

        - Clean and copy blank lines.
        - Copy @ @rst-markup lines as is.
        - Everything else gets put into a code-block directive.'''

        result = [] ; n = 0 ; code = []
        while n < len(lines):
            s = lines [n] ; n += 1
            if (
                self.isSpecialDocPart(s,'@rst-markup') or (
                    self.getOption('show_doc_parts_as_paragraphs') and
                    self.isSpecialDocPart(s,None)
                )
            ):
                if code:
                    self.finishCodePart(result,code)
                    code = []
                result.append('')
                n, lines2 = self.getDocPart(lines,n)
                result.extend(lines2)
            elif not s.strip() and not code:
                pass # Ignore blank lines before the first code block.
            elif not code: # Start the code block.
                result.append('')
                result.append(self.code_block_string)
                code.append(s)
            else: # Continue the code block.
                code.append(s)

        if code:
            self.finishCodePart(result,code)
            code = []

        if 1:
            # Munge the result so as to keep docutils happy.
            # Don't use self.rstripList: it's not the same.
            result2 = []
            for z in result:
                if z == '': result2.append('\n\n')
                elif not z.rstrip(): pass
                elif z.endswith('\n\n'): result2.append(z) # Leave alone.
                else: result2.append('%s\n' % z.rstrip())
            return result2
        else:
            return result
    #@+node:ekr.20100811091636.5964: *6* formatCodeModeLine
    def formatCodeModeLine (self,s,n,numberOption):

        if not s.strip(): s = ''

        if numberOption:
            return '    %d: %s' % (n,s)
        else:
            return '    %s' % s
    #@+node:ekr.20100811091636.5965: *6* rstripList
    def rstripList (self,theList):

        '''Removed trailing blank lines from theList.'''

        s = '\n'.join(theList).rstrip()
        return s.split('\n')
    #@+node:ekr.20100811091636.5966: *6* finishCodePart
    def finishCodePart (self,result,code):

        numberOption = self.getOption('number-code-lines')

        code = self.rstripList(code)
        i = 0
        for line in code:
            i += 1
            result.append(self.formatCodeModeLine(line,i,numberOption))
    #@+node:ekr.20100811091636.5979: *4* writeNode (rst)
    def writeNode (self,p):

        '''Format a node according to the options presently in effect.

        Side effect: advance p'''

        self.scanAllOptions(p)

        h = p.h.strip()

        if self.getOption('ignore_this_tree'):
            p.moveToNodeAfterTree()
        elif self.getOption('ignore_this_node'):
            p.moveToThreadNext()
        elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
            p.moveToThreadNext()
        else:
            self.writeHeadline(p)
            self.writeBody(p)
            p.moveToThreadNext()
    #@+node:ekr.20100811091636.5981: *4* writeTree
    def writeTree(self,p):

        '''Write p's tree to self.outputFile.'''

        print('\n\n\n==========')

        self.scanAllOptions(p)

        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))

        # We can't use an iterator because we may skip parts of the tree.
        p = p.copy() # Only one copy is needed for traversal.
        self.topNode = p.copy() # Indicate the top of this tree.
        after = p.nodeAfterTree()
        while p and p != after:
            self.writeNode(p) # Side effect: advances p.
    #@+node:ekr.20100811091636.5931: *3* options...
    #@+node:ekr.20100811091636.5933: *4* dumpSettings (debugging)
    def dumpSettings (self):

        d = self.optionsDict
        keys = sorted(d)

        g.pr('present settings...')
        for key in keys:
            g.pr('%20s %s' % (key,d.get(key)))
    #@+node:ekr.20100811091636.5934: *4* get/SetOption
    def getOption (self,name):

        return self.optionsDict.get(self.munge(name))

    def setOption (self,name,val,tag):

        self.optionsDict [self.munge(name)] = val
    #@+node:ekr.20100811091636.5929: *4* munge
    def munge (self,name):

        '''Convert an option name to the equivalent ivar name.'''

        return name.lower().replace('-','').replace('_','')
    #@+node:ekr.20100811091636.5944: *4* scanAllOptions & helpers
    # Once an option is seen, no other related options in ancestor nodes have any effect.

    def scanAllOptions(self,p):

        '''Scan position p and p's ancestors looking for options,
        setting corresponding ivars.
        '''

        self.initOptionsFromSettings() # Must be done on every node.
        self.preprocessNode(p)
        self.handleSingleNodeOptions(p)
        seen = self.singleNodeOptions[:] # Suppress inheritance of single-node options.

        # g.trace('-'*20)
        for p in p.self_and_parents():
            d = self.vnodeOptionDict.get(p.v,{})
            # g.trace(p.h,d)
            for key in d.keys():
                if not ivar in seen:
                    seen.append(key)
                    val = d.get(key)
                    self.setOption(key,val,p.h)
    #@+node:ekr.20100811091636.5945: *5* initOptionsFromSettings
    def initOptionsFromSettings (self):

        d = self.defaultOptionsDict

        for key in sorted(d):
            self.setOption(key,d.get(key),'initOptionsFromSettings')

        # c = self.c
        # for key in keys:
            # for getter,kind in (
                # (c.config.getBool,'@bool'),
                # (c.config.getString,'@string'),
                # (d.get,'default'),
            # ):
                # val = getter(key)
                # if kind == 'default' or val is not None:
                    # self.setOption(key,val,'initOptionsFromSettings')
                    # break
    #@+node:ekr.20100811091636.5946: *5* handleSingleNodeOptions
    def handleSingleNodeOptions (self,p):

        '''Init the settings of single-node options from the tnodeOptionsDict.

        All such options default to False.'''

        d = self.vnodeOptionDict.get(p.v, {} )

        for ivar in self.singleNodeOptions:
            val = d.get(ivar,False)
            #g.trace('%24s %8s %s' % (ivar,val,p.h))
            self.setOption(ivar,val,p.h)

    #@+node:ekr.20100811091636.5937: *5* preprocessNode
    def preprocessNode (self,p):

        d = self.vnodeOptionDict.get(p.v)

        if d is None:
            d = self.scanNodeForOptions(p)
            self.vnodeOptionDict [p.v] = d
    #@+node:ekr.20100811091636.5941: *4* scanNodeForOptions & helpers
    def scanNodeForOptions (self,p):

        '''Return a dictionary containing all the option-name:value entries in p.

        Such entries may arise from @rst-option or @rst-options in the headline,
        or from @ @rst-options doc parts.'''

        d = self.scanHeadlineForOptions(p)
        d2 = self.scanForOptionDocParts(p,p.b)
        d.update(d2)  # Body options over-ride headline options.

        if d: g.trace(p.h,d)

        return d
    #@+node:ekr.20100811091636.5938: *5* parseOptionLine
    def parseOptionLine (self,s):

        '''Parse a line containing name=val and return (name,value) or None.

        If no value is found, default to True.'''

        s = s.strip()
        if s.endswith(','): s = s[:-1]
        # Get name.  Names may contain '-' and '_'.
        i = g.skip_id(s,0,chars='-_')
        name = s [:i]
        if not name: return None
        j = g.skip_ws(s,i)
        if g.match(s,j,'='):
            val = s [j+1:].strip()
            # g.trace(val)
            return name,val
        else:
            # g.trace('*True')
            return name,'True'
    #@+node:ekr.20100811091636.5939: *5* scanForOptionDocParts
    def scanForOptionDocParts (self,p,s):

        '''Return a dictionary containing all options from @rst-options doc parts in p.
        Multiple @rst-options doc parts are allowed: this code aggregates all options.
        '''

        d = {} ; n = 0 ; lines = g.splitLines(s)
        while n < len(lines):
            line = lines[n] ; n += 1
            if line.startswith('@'):
                i = g.skip_ws(line,1)
                for kind in ('@rst-options','@rst-option'):
                    if g.match_word(line,i,kind):
                        # Allow options on the same line.
                        line = line[i+len(kind):]
                        d.update(self.scanOption(p,line))
                        # Add options until the end of the doc part.
                        while n < len(lines):
                            line = lines[n] ; n += 1 ; found = False
                            for stop in ('@c','@code', '@'):
                                if g.match_word(line,0,stop):
                                    found = True ; break
                            if found:
                                break
                            else:
                                d.update(self.scanOption(p,line))
                        break
        return d
    #@+node:ekr.20100811091636.5940: *5* scanHeadlineForOptions
    def scanHeadlineForOptions (self,p):

        '''Return a dictionary containing the options implied by p's headline.'''

        h = p.h.strip()

        if p == self.topNode:
            return {} # Don't mess with the root node.
        ### elif g.match_word(h,0,self.getOption(self.option_prefix)):
            ### s = h [len(self.option_prefix):]
        elif g.match_word(h,0,self.getOption('option_prefix')):
            s = h[len('option_prefix'):]
            return self.scanOption(p,s)
        ### elif g.match_word(h,0,self.getOption('options_prefix')): # '@rst-options'
        elif g.match_word(h,0,self.getOption('@rst-options')): 
            return self.scanOptions(p,p.b)
        else:
            # Careful: can't use g.match_word because options may have '-' chars.
            i = g.skip_id(h,0,chars='@-')
            word = h[0:i]

            # for prefix,ivar,val in (
                # ('code_prefix','code_mode',True), # '@rst-code'
                # ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
                # ('default_path_prefix','default_prefix',''), # '@rst-default-path'
                # ('rst_prefix','code_mode',False), # '@rst'
                # ('ignore_headline_prefix','ignore_this_headline',True), # '@rst-no-head'
                # ('show_headline_prefix','show_this_headline',True), # '@rst-head'  
                # ('ignore_headlines_prefix','show_headlines',False), # '@rst-no-headlines'
                # ('ignore_prefix','ignore_this_tree',True),      # '@rst-ignore'
                # ('ignore_node_prefix','ignore_this_node',True), # '@rst-ignore-node'
                # ('ignore_tree_prefix','ignore_this_tree',True), # '@rst-ignore-tree'
                # ('preformat_prefix','preformat_this_node',True), # '@rst-preformat
            # ):
                # prefix = self.getOption(prefix)
                # if prefix and word == prefix: # Do _not_ munge this prefix!
                    # d = { ivar: val }
                    # if ivar != 'code_mode':
                        # d ['code_mode'] = False # Enter rst mode.
                        # d ['doc_only_mode'] = False
                    # # Special case: Treat a bare @rst like @rst-no-head
                    # if h == self.getOption('rst_prefix'):
                        # d ['ignore_this_headline'] = True
                    # # g.trace(repr(h),repr(prefix),ivar,d)
                    # return d

            for option,ivar,val in (
                ### ('code_prefix','code_mode',True), # '@rst-code'
                ### ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
                ### ('default_path_prefix','default_prefix',''), # '@rst-default-path'
                ### ('rst_prefix','code_mode',False), # '@rst'
                ('@rst-no-head','ignore_this_headline',True),
                ('@rst-head'  ,'show_this_headline',True),
                ('@rst-no-headlines','show_headlines',False),
                ('@rst-ignore','ignore_this_tree',True),
                ('@rst-ignore-node','ignore_this_node',True),
                ('@rst-ignore-tree','ignore_this_tree',True),
                ('@rst-preformat','preformat_this_node',True),
            ):
                name = self.getOption(option)
                if name:
                    d = { name: val }
                    return d

            return {}
    #@+node:ekr.20100811091636.5942: *5* scanOption
    def scanOption (self,p,s):

        '''Return { name:val } if s is a line of the form name=val.
        Otherwise return {}'''

        if not s.strip() or s.strip().startswith('..'): return {}

        data = self.parseOptionLine(s)

        if data:
            name,val = data
            ### fullName = 'rst3_' + self.munge(name)
            if name in list(self.defaultOptionsDict.keys()):
                if   val.lower() == 'true': val = True
                elif val.lower() == 'false': val = False
                # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
                ### return { self.munge(name): val }
                return {name: val}
            else:
                g.es_print('ignoring unknown option: %s' % (name),color='red')
                return {}
        else:
            g.trace(repr(s))
            s2 = 'bad rst3 option in %s: %s' % (p.h,s)
            g.es_print(s2,color='red')
            return {}
    #@+node:ekr.20100811091636.5943: *5* scanOptions
    def scanOptions (self,p,s):

        '''Return a dictionary containing all the options in s.'''

        d = {}

        for line in g.splitLines(s):
            d2 = self.scanOption(p,line)
            if d2: d.update(d2)

        return d
    #@+node:ekr.20100811091636.5960: *3* write methods
    #@+node:ekr.20100811091636.5961: *4* getDocPart
    def getDocPart (self,lines,n):

        # g.trace('n',n,repr(''.join(lines)))

        result = []
        #@+<< Append whatever follows @doc or @space to result >>
        #@+node:ekr.20100811091636.5962: *5* << Append whatever follows @doc or @space to result >>
        if n > 0:
            line = lines[n-1]
            if line.startswith('@doc'):
                s = line[4:].lstrip()
            elif line.startswith('@'):
                s = line[1:].lstrip()
            else:
                s = ''

            # New in Leo 4.4.4: remove these special tags.
            for tag in ('@rst-options','@rst-option','@rst-markup'):
                if g.match_word(s,0,tag):
                    s = s[len(tag):].strip()

            if s.strip():
                result.append(s)
        #@-<< Append whatever follows @doc or @space to result >>
        while n < len(lines):
            s = lines [n] ; n += 1
            if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
                break
            result.append(s)
        return n, result
    #@+node:ekr.20100811091636.5968: *4* handleSpecialDocParts
    def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

        # g.trace(kind,g.listToString(lines))

        result = [] ; n = 0
        while n < len(lines):
            s = lines [n] ; n += 1
            if s.strip().endswith('::'):
                n, lit = self.skip_literal_block(lines,n-1)
                result.extend(lit)
            elif self.isSpecialDocPart(s,kind):
                n, lines2 = self.getDocPart(lines,n)
                if retainContents:
                    result.extend([''])
                    if asClass:
                        result.extend(['.. container:: '+asClass, ''])
                        if 'literal' in asClass.split():
                            result.extend(['  ::', ''])
                        for l2 in lines2: result.append('    '+l2)
                    else:
                        result.extend(lines2)
                    result.extend([''])
            else:
                result.append(s)

        return result
    #@+node:ekr.20100811091636.5969: *4* isAnyDocPart
    def isAnyDocPart (self,s):

        if s.startswith('@doc'):
            return True
        elif not s.startswith('@'):
            return False
        else:
            return len(s) == 1 or s[1].isspace()
    #@+node:ekr.20100811091636.5970: *4* isAnySpecialDocPart
    def isAnySpecialDocPart (self,s):

        for kind in (
            '@rst-markup',
            '@rst-option',
            '@rst-options',
        ):
            if self.isSpecialDocPart(s,kind):
                return True

        return False
    #@+node:ekr.20100811091636.5971: *4* isSpecialDocPart
    def isSpecialDocPart (self,s,kind):

        '''Return True if s is a special doc part of the indicated kind.

        If kind is None, return True if s is any doc part.'''

        if s.startswith('@') and len(s) > 1 and s[1].isspace():
            if kind:
                i = g.skip_ws(s,1)
                result = g.match_word(s,i,kind)
            else:
                result = True
        elif not kind:
            result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
        else:
            result = False

        # g.trace('kind %s, result %s, s %s' % (
            # repr(kind),result,repr(s)))

        return result
    #@+node:ekr.20100811091636.5972: *4* removeLeoDirectives
    def removeLeoDirectives (self,lines):

        '''Remove all Leo directives, except within literal blocks.'''

        n = 0 ; result = []
        while n < len(lines):
            s = lines [n] ; n += 1
            if s.strip().endswith('::'):
                n, lit = self.skip_literal_block(lines,n-1)
                result.extend(lit)
            elif s.startswith('@') and not self.isAnySpecialDocPart(s):
                for key in self.leoDirectivesList:
                    if g.match_word(s,0,key):
                        # g.trace('removing %s' % s)
                        break
                else:
                    result.append(s)
            else:
                result.append(s)

        return result
    #@+node:ekr.20100811091636.5973: *4* replaceCodeBlockDirectives
    def replaceCodeBlockDirectives (self,lines):

        '''Replace code-block directive, but not in literal blocks.'''

        n = 0 ; result = []
        while n < len(lines):
            s = lines [n] ; n += 1
            if s.strip().endswith('::'):
                n, lit = self.skip_literal_block(lines,n-1)
                result.extend(lit)
            else:
                i = g.skip_ws(s,0)
                if g.match(s,i,'..'):
                    i = g.skip_ws(s,i+2)
                    if g.match_word(s,i,'code-block'):
                        if 1: # Create a literal block to hold the code.
                            result.append('::\n')
                        else: # This 'annotated' literal block is confusing.
                            result.append('%s code::\n' % s[i+len('code-block'):])
                    else:
                        result.append(s)
                else:
                    result.append(s)

        return result
    #@+node:ekr.20100811091636.5974: *4* skip_literal_block
    def skip_literal_block (self,lines,n):

        s = lines[n] ; result = [s] ; n += 1
        indent = g.skip_ws(s,0)

        # Skip lines until a non-blank line is found with same or less indent.
        while n < len(lines):
            s = lines[n]
            indent2 = g.skip_ws(s,0)
            if s and not s.isspace() and indent2 <= indent:
                break # We will rescan lines [n]
            n += 1
            result.append(s)

        # g.printList(result,tag='literal block')
        return n, result
    #@+node:ekr.20100811091636.5977: *4* writeHeadline & helper
    def writeHeadline (self,p):

        '''Generate an rST section if options permit it.
        Remove headline commands from the headline first,
        and never generate an rST section for @rst-option and @rst-options.'''

        if 0: ### Testing

            docOnly             = self.getOption('doc_only_mode')
            ignore              = self.getOption('ignore_this_headline')
            showHeadlines       = self.getOption('show_headlines')
            showThisHeadline    = self.getOption('show_this_headline')
            showOrganizers      = self.getOption('show_organizer_nodes')

            if (
                p == self.topNode or
                ignore or
                docOnly or # handleDocOnlyMode handles this.
                not showHeadlines and not showThisHeadline or
                # docOnly and not showOrganizers and not thisHeadline or
                not p.h.strip() and not showOrganizers or
                not p.b.strip() and not showOrganizers
            ):
                return

        self.writeHeadlineHelper(p)
    #@+node:ekr.20100811091636.5978: *5* writeHeadlineHelper
    def writeHeadlineHelper (self,p):

        h = p.h
        if not self.atAutoWrite:
            h = h.strip()

        # Remove any headline command before writing the headline.
        i = g.skip_ws(h,0)
        i = g.skip_id(h,0,chars='@-')
        word = h [:i].strip()
        if word:
            # Never generate a section for @rst-option or @rst-options or @rst-no-head.
            if word in ('@rst-option','@rst-options','@rst-no-head','@rst-no-leadlines'):
                return

            ### if word in (
                # self.getOption('option_prefix'),
                # self.getOption('options_prefix'),
                # self.getOption('ignore_headline_prefix'), # Bug fix: 2009-5-13
                # self.getOption('ignore_headlines_prefix'),  # Bug fix: 2009-5-13
            # ):
                # return

            # Remove all other headline commands from the headline.
            self.getOption('ignore_node_prefix'),
            self.getOption('ignore_tree_prefix'),
            self.getOption('show_headline_prefix'),

            ### for prefix in self.headlineCommands:
            for prefix in ('@rst-ignore-node','@rst-ignore-tree','@rst-ignore'):
                if word == prefix:
                    h = h [len(word):].strip()
                    break

            # New in Leo 4.4.4.
            if word.startswith('@'):
                if self.getOption('strip_at_file_prefixes'):
                    for s in ('@auto','@file','@nosent','@thin',):
                        if g.match_word(word,0,s):
                            h = h [len(s):].strip()

        if not h.strip(): return

        if self.getOption('show_sections'):
            self.write(self.underline(h,p))
        else:
            self.write('\n**%s**\n\n' % h.replace('*',''))
    #@+node:ekr.20100811091636.5980: *4* writePreformat
    def writePreformat (self,p):

        '''Write p's body text lines as if preformatted.

         ::

            line 1
            line 2 etc.
        '''

        # g.trace(p.h,g.callers())

        lines = p.b.split('\n')
        lines = [' '*4 + z for z in lines]
        lines.insert(0,'::\n')

        s = '\n'.join(lines)
        if s.strip():
            self.write('%s\n\n' % s)
    #@+node:ekr.20100811091636.5982: *3* Utils
    #@+node:ekr.20100811091636.5984: *4* encode
    def encode (self,s):

        # g.trace(self.encoding)

        return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
    #@+node:ekr.20100811091636.5985: *4* report
    def report (self,name):

        if self.getOption('verbose'):

            name = g.os_path_finalize(name)

            g.es_print('wrote: %s' % (name),color="blue")
    #@+node:ekr.20100811091636.5986: *4* rstComment
    def rstComment (self,s):

        return '.. %s' % s
    #@+node:ekr.20100811091636.5987: *4* underline
    def underline (self,s,p):

        '''Return the underlining string to be used at the given level for string s.
        This includes the headline, and possibly a leading overlining line.
        '''

        trace = False and not g.unitTesting

        if self.atAutoWrite:
            # We *might* generate overlines for top-level sections.
            u = self.atAutoWriteUnderlines
            level = p.level()-self.topLevel

            if trace: g.trace('level: %s under2: %s under1: %s %s' % (
                level,repr(self.underlines2),repr(self.underlines1),p.h))

            # This is tricky. The index n depends on several factors.
            if self.underlines2:
                level -= 1 # There *is* a double-underlined section.
                n = level
            else:
                n = level-1

            if 0 <= n < len(u):
                ch = u[n]
            elif u:
                ch = u[-1]
            else:
                g.trace('can not happen: no u')
                ch = '#'

            # 2010/01/10: write longer underlines for non-ascii characters.
            n = max(4,len(g.toEncodedString(s,encoding=self.encoding,reportErrors=False)))
            if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
            if level == 0 and self.underlines2:
                return '%s\n%s\n%s\n\n' % (ch*n,p.h,ch*n)
            else:
                return '%s\n%s\n\n' % (p.h,ch*n)
        else:
            # The user is responsible for top-level overlining.
            u = self.getOption('underline_characters') #  '''#=+*^~"'`-:><_'''
            level = max(0,p.level()-self.topLevel)
            level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
            ch = u [level]
            if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
            n = max(4,len(g.toEncodedString(s,encoding=self.encoding,reportErrors=False)))
            return '%s\n%s\n\n' % (p.h.strip(),ch*n)
    #@-others

if p:
    fc = formatController(c,p,defaultOptionsDict)
    fc.run()
else:
    print('not found',h)
#@-others
#@-leo
