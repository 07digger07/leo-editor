<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="48" left="228" height="692" width="793"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20090620052003.8505"><vh>@button add-test @key=alt-9</vh></v>
<v t="ekr.20090514093345.6054"><vh>Disabled buttons</vh>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
<v t="ekr.20081202093528.33"><vh>@@command complete-next</vh>
<v t="ekr.20081202093528.20"><vh>WordCompleter</vh>
<v t="ekr.20081202093528.21"><vh>complete_word</vh>
<v t="ekr.20081202093528.22"><vh>&lt;&lt;backward search&gt;&gt;</vh>
<v t="ekr.20081202093528.23"><vh>&lt;&lt;counter check&gt;&gt;</vh></v>
</v>
<v t="ekr.20081202093528.24"><vh>&lt;&lt;forward search&gt;&gt;</vh>
<v t="ekr.20081202093528.23"></v>
</v>
<v t="ekr.20081202093528.25"><vh>&lt;&lt;clean up and exit&gt;&gt;</vh></v>
</v>
<v t="ekr.20081202093528.26"><vh>acceptable_word</vh></v>
<v t="ekr.20081202093528.27"><vh>undo_replacement</vh></v>
<v t="ekr.20081202093528.28"><vh>redo_replacement</vh></v>
<v t="ekr.20081202093528.29"><vh>exit</vh></v>
<v t="ekr.20081202093528.30"><vh>run</vh></v>
<v t="ekr.20081202093528.31"><vh>adjust</vh></v>
</v>
<v t="ekr.20081202093528.32"><vh>getCurrentWord</vh></v>
</v>
<v t="ekr.20081202093528.19"><vh>@@command complete-previous</vh>
<v t="ekr.20081202093528.20"></v>
<v t="ekr.20081202093528.32"></v>
</v>
</v>
<v t="ekr.20070605104410"><vh>@chapters</vh></v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f7461746571037d71042855046e6f6465710555007106550262677107680655087072696f726974797108550439393939710955026667710a6806550870726f6772657373710b68065509617263686574797065710c68067573732e"
marks="ekr.20080510153327.4,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20090502071837.71,ekr.20031218072017.2829,ekr.20080510153327.4,ekr.20061031131434.110,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20090113083258.3"><vh>Unit tests &amp; helper files</vh>
<v t="ekr.20090514093345.6053"><vh>@button run-all-core-tests @key = Alt-7</vh></v>
<v t="ekr.20090517102212.5874"><vh>Helper files</vh>
<v t="ekr.20090517102548.5889"><vh>@@@mark-for-unit-tests</vh>
<v t="ekr.20090517020744.5906"><vh>@path ../test/unittest</vh>
<v t="ekr.20090517020744.5907"><vh>@@thin at-path-test2.py</vh></v>
</v>
<v t="ekr.20090517020744.5909"><vh>@path ../test</vh>
<v t="ekr.20090517020744.5910"><vh>@path unittest</vh>
<v t="ekr.20090517020744.5911"><vh>@@thin at-path-test3.py</vh></v>
</v>
</v>
<v t="ekr.20090517020744.5904"><vh>@@thin ../test/unittest/at-path-test1.py</vh></v>
</v>
</v>
<v t="ekr.20090113083258.1" descendentVnodeUnknownAttributes="7d7100285507302e322e372e3471017d71025808000000616e6e6f7461746571037d7104735503302e3071057d71065808000000616e6e6f7461746571077d7108735507302e322e302e3571097d710a5808000000616e6e6f74617465710b7d710c735507302e322e362e33710d7d710e5808000000616e6e6f74617465710f7d7110735508302e322e332e333571117d71125808000000616e6e6f7461746571137d711473752e"><vh>@thin test_core.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@thin leoVersion.py</vh></v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external</vh>
<v t="ville.20091010232339.6117"><vh>@thin ../external/lproto.py</vh></v>
<v t="ekr.20091204131831.6103"><vh>@thin ../external/path.py</vh></v>
<v t="ekr.20090831103504.6069"><vh>@thin ../external/pickleshare.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@thin runLeo.py </vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@thin leoBridge.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@thin leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20031218072017.2829,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005506302e31352e3071017d71025808000000616e6e6f7461746571037d710473732e"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20090502071837.3"
marks="ekr.20090502071837.71,"><vh>@thin leoRst.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@thin leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20061031131434"
marks="ekr.20061031131434.110,ekr.20080510153327.4,"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Test classes</vh>
<v t="ekr.20080730161153.2"><vh>@thin leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@thin leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@thin leoTest.py</vh></v>
</v>
</v>
<v t="ekr.20091203060018.6100"><vh>leo-3k</vh>
<v t="ekr.20090521175848.5881"><vh>&lt;&lt; define the nullObject class &gt;&gt;</vh></v>
<v t="ekr.20071117060958"><vh>getFileName &amp; helper</vh>
<v t="ekr.20041124083125"><vh>completeFileName</vh></v>
</v>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
<v t="ekr.20090502071837.65"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090502071837.66"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="bob.20071231111744.2"><vh>get / getColor</vh></v>
<v t="ekr.20080710101653.1"><vh>g.pr</vh></v>
<v t="ville.20090606150238.6351"><vh>_contentHashFile (atFile)</vh></v>
<v t="ekr.20090520055433.5945"><vh>g.openWithFileName &amp; helpers</vh>
<v t="ekr.20090520055433.5951"><vh>g.createMenu</vh></v>
<v t="ekr.20090520055433.5948"><vh>g.findOpenFile</vh></v>
<v t="ekr.20090520055433.5952"><vh>g.finishOpen</vh></v>
<v t="ekr.20090520055433.5950"><vh>g.handleOpenHooks</vh></v>
<v t="ekr.20090520055433.5954"><vh>g.mungeFileName</vh></v>
<v t="ekr.20090520055433.5946"><vh>g.openWithFileNameHelper</vh>
<v t="ekr.20090520055433.5949"><vh>preRead</vh></v>
</v>
<v t="ekr.20080921154026.1"><vh>g.openWrapperLeoFile</vh></v>
</v>
<v t="ville.20090620122043.6275"><vh>app.setGlobalDb</vh></v>
<v t="ville.20090606131405.6362"><vh>writeCachedTree (atFile)</vh></v>
</v>
<v t="ekr.20091203060018.6067"><vh>2to3 output</vh>
<v t="ekr.20091203165343.6144"><vh>2to3 args</vh></v>
<v t="ekr.20091203165343.6146"><vh>Run2</vh>
<v t="ekr.20091203165343.6150"><vh>leo_RemoteDebugger</vh></v>
<v t="ekr.20091203165343.6149"><vh>leo_shell</vh></v>
<v t="ekr.20091203165343.6148"><vh>leo_run (tkinter: to be deleted?)</vh></v>
<v t="ekr.20091203165343.6147"><vh>runLeo (tkinter: to be deleted?)</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="bob.20071231111744.2">def getColor(name, default=None):
    """ Translate a named color into #rrggbb' format.

    if 'name' is not a string it is returned unchanged.

    If 'name' is already in '#rrggbb' format then it is returned unchanged.

    If 'name' is not in global_color_database then getColor(default, None)
    is called and that result returned.


    """
    if g.isPython3:
        if not isinstance(name,str):
            return name
    else:
        if not isinstance(name,basestring):
            return name

    #g.trace(name, default)

    if name[0] == '#':
        return name

    name = name.replace(' ', '').lower()

    if name in leo_color_database:
        return leo_color_database[name]

    if default:
        return getColor(default, default=None)

    return None

get = getColor


</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ 
This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobal module.
i, j, k: indices into a string.
p:  a position.
s:  a string.
t:  a tnode or a text widget.
u:  an undoer.
w:  a gui widget.
v:  a vnode
z:  a local temp.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None
self.timeStampDict = {} # New in Leo 4.6.

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = '' # Must always be a string.
self.navTime = None

# Controller-specific pickleshare db at /foo/bar.leo_db/

import leo.external.pickleshare
import hashlib
pth, bname = os.path.split(self.mFileName)

if pth and bname and g.enableDB:
    fn = self.mFileName.lower()
    fn = g.toEncodedString(fn,'utf-8')
    dbdirname = g.app.homeLeoDir + "/db/" + bname + "_" + hashlib.md5(fn).hexdigest()
    # use compressed pickles (handy for @thin caches)
    self.db = leo.external.pickleshare.PickleShareDB(dbdirname, protocol='picklez')

else:
    self.db = {}
    # if not g.app.silentMode and not g.unitTesting:
        # print('caching disabled')
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20041124083125">def completeFileName (fileName):

    trace = False
    if trace: print('completeFileName',fileName)

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)

    # Bug fix: don't add .leo to existing files.
    if g.os_path_exists(fileName):
        pass # use the fileName as is.
    elif ext != '.leo':
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    if trace: print('completeFileName',fileName)

    return fileName,relativeFileName
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240" str_leo_pos="5"></t>
<t tx="ekr.20060217111834"></t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.p
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.h)
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().h
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20070605104410"></t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.b
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20071117060958">def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    # import pdb ; pdb.set_trace()

    if g.isPython3:
        ### Testing only.
        # fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        # assert g.os_path_exists(fileName)
        pass
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) &gt; 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) &gt; 1 and sys.argv[-1]

    return completeFileName(fileName)
</t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.b,ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'"))
        for z in sorted(self.decls)]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080710101653.1"># see: http://www.diveintopython.org/xml_processing/unicode.html

pr_warning_given = False

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    nl = g.choose(newline,'\n','')
    if hasattr(sys.stdout,'encoding') and sys.stdout.encoding:
        encoding = sys.stdout.encoding
    else:
        encoding = 'utf-8'

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.
    if g.isPython3:
        s2 = s
    else:
        s2 = g.toEncodedString(s,encoding)

    if app.logInited:
        try: # We can't use any print keyword args in Python 2.x!
            sys.stdout.write(s2+nl)
        except Exception:
            if not g.pr_warning_given:
                g.pr_warning_given = True
                print('unexpected Exception in g.pr')
                print('make sure your sitecustomize.py contains::')
                print('    sys.setdefaultencoding("utf-8")')
                g.es_exception()
                g.trace(g.callers())
            s2 = s.encode('ascii',"replace")
            sys.stdout.write(s2+nl)
    else:
        app.printWaiting.append(s2)
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080921154026.1">def openWrapperLeoFile (old_c,fileName,gui):

    '''Open a wrapper .leo file for the given file,
    and import the file into .leo file.'''

    # This code is similar to c.new, but different enough to be separate.
    if not g.os_path_exists(fileName):
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    if 0: # This causes duplicate common buttons.
        g.doHook("new",old_c=old_c,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.

    if True: # Just read the file into the node.
        try:
            fileName = g.os_path_finalize(fileName)
            f = open(fileName)
            s = f.read()
            f.close()
        except IOError:
            g.es_print("can not open: ",fileName,color='red')
            return None
        p = c.rootPosition()
        if p:
            p.setHeadString('@edit %s' % fileName)
            p.setBodyString(s)
            c.selectPosition(p)
    else:  # Import the file into the new outline.
        junk,ext = g.os_path_splitext(fileName)
        p = c.p
        p = c.importCommands.createOutline(fileName,parent=p,atAuto=False,ext=ext)
        c.setCurrentPosition(p)
        c.moveOutlineLeft()
        p = c.p
        c.setCurrentPosition(p.back())
        c.deleteOutline(op_name=None)
        p = c.p
        p.expand()

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.config.getBool('use_chapters') and c.chapterController:
        c.chapterController.finishCreate()

    frame.c.setChanged(True) # Mark the outline dirty.
    return c
</t>
<t tx="ekr.20081202093528.19">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'back_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p,c,back=True)
    g.app.config.set(c,word_completer_key,'WordCompleter',completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()
</t>
<t tx="ekr.20081202093528.20">class WordCompleter:
    def __init__(self, p, c, back=True):
        self.p = p.copy()
        self.c = c
        self.back = back
        self.pos = -1
    @others
</t>
<t tx="ekr.20081202093528.21">def complete_word(self):
    txt = self.chunk
    word = self.word
    try:
        if self.back:
            &lt;&lt;backward search&gt;&gt;
        else:
            &lt;&lt;forward search&gt;&gt;
        &lt;&lt;clean up and exit&gt;&gt;
    except:
        self.exit()
        g.es_exception()</t>
<t tx="ekr.20081202093528.22">p = self.search_pos
start = -1
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.rfind(word, 0, start)
    if i == -1:
        p.moveToThreadBack()
        if p:self.chunk = txt = p.b
        start = -1
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[:i+len(word)-1]
            return
        start = i+len(word)-1</t>
<t tx="ekr.20081202093528.23">counter+=1
if counter &gt; 10000:
    g.es_trace("counter max")
    break</t>
<t tx="ekr.20081202093528.24">p = self.search_pos
start = 0
counter = 0
while p:
    &lt;&lt;counter check&gt;&gt;
    i = txt.find(word, start)
    if i == -1:
        p.moveToThreadNext()
        if p:self.chunk = txt = p.b
        start = 0
    else:
        if self.acceptable_word(i, txt, word):
            self.chunk = txt[i+1:]
            return
        start = i+1</t>
<t tx="ekr.20081202093528.25">if len(self.tried) &gt; 1:
    # there was some tries so we need to restore
    self.c.setBodyString(self.p, self.before+self.word+self.after)
    self.c.frame.body.setInsertPoint(self.pos)
return self.exit()</t>
<t tx="ekr.20081202093528.26">@ if found word for the first time then try it
@c
def acceptable_word(self, i, txt, word):
    if i == 0 or wordsep.find(txt[i-1]) != -1:
        j = i+len(word)
        while j &lt; len(txt) and wordsep.find(txt[j]) &lt; 0:
            j += 1
        nword = txt[i:j]
        if nword not in self.tried:
            self.tried[nword] = 1
            u = self.c.undoer
            bunch = u.createCommonBunch(p)
            bunch.oldBody = p.b
            bunch.insertPos = self.pos
            # Set the type &amp; helpers.
            bunch.kind = 'node'
            bunch.undoType = 'complete word'
            bunch.undoHelper = self.undo_replacement
            bunch.redoHelper = self.redo_replacement
            bunch.newBody = newBody = self.before+nword+self.after

            self.c.setBodyString(self.p, newBody)
            self.c.frame.body.setInsertPoint(self.pos)

            bunch.dirtyVnodeList = [p.v]
            bunch.newChanged = u.c.isChanged()
            bunch.newDirty = p.isDirty()
            bunch.newMarked = p.isMarked()

            u.pushBead(bunch)

            return True
    return False
</t>
<t tx="ekr.20081202093528.27">def undo_replacement(self):
    u = self.c.undoer; c=self.c; p=u.p
    bunch = u.getBead(u.bead)
    c.setBodyString(p, bunch.oldBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="ekr.20081202093528.28">def redo_replacement(self):
    c = self.c; u=c.undoer; bunch=u.getBead(u.bead+1)
    c.setBodyString(bunch.p, bunch.newBody)
    c.frame.body.setInsertPoint(bunch.insertPos)</t>
<t tx="ekr.20081202093528.29">def exit(self):
    #g.app.config.set(c,word_completer_key,'WordCompleter',None)
    #g.app.config.set(c,'next_word_completer','WordCompleter',None)
    self.pos = -1</t>
<t tx="ekr.20081202093528.30">def run(self):
    self.adjust(self.p, c.frame.body.getInsertPoint())
    self.complete_word()
</t>
<t tx="ekr.20081202093528.31">def adjust(self, p, pos):
    if p != self.p or pos != self.pos:
        self.p = p.copy()
        self.pos = pos
        bs = p.b
        word = getCurrentWord(bs, pos)
        self.word = word
        self.before = bs[:pos-len(word)]
        self.after = bs[pos:]
        self.search_pos = p.copy()
        if self.back:
            self.chunk = self.before
        else:
            self.chunk = self.after
        self.tried = {word:1}</t>
<t tx="ekr.20081202093528.32">def getCurrentWord(s, pos):
    i = pos-1
    while i&gt;=0 and wordsep.find(s[i]) &lt; 0:
         i -= 1
    return s[i+1:pos]</t>
<t tx="ekr.20081202093528.33">wordsep = u'., -+\n\r[]{}&lt;&gt;=-+*&amp;%$#@!"\'?/\\|^()~`:;'
word_completer_key = 'next_word_completer'
@others
completer = g.app.config.get(c,word_completer_key,'WordCompleter')
if completer is None:
    completer = WordCompleter(p, c, back=False)
    g.app.config.set(c, word_completer_key, 'WordCompleter', completer)
    completer.run()
else:
    completer.adjust(p, c.frame.body.getInsertPoint())
    completer.complete_word()

</t>
<t tx="ekr.20090113083258.3"># These should all pass with Alt-5 or Alt-6.
# They will pass with Alt-4 only if the code has not been changed.</t>
<t tx="ekr.20090502071837.65">def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    trace = True and not g.unitTesting
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if self.getOption('stylesheet_embed') == False:
        rel_path = g.os_path_join(
            rel_stylesheet_path,self.getOption('stylesheet_name'))
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        if trace: g.trace('overrides',overrides)
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        # g.es_print('Docutils error (%s):' % (
            # error.__class__.__name__),color='red')
        g.es_print('Docutils error:',color='red')
        g.es_print(error,color='blue')
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
</t>
<t tx="ekr.20090502071837.66">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    trace = False and not g.unitTesting
    force = False

    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass':'report', 'documentoptions':'english,12pt,lettersize'}

    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return {}

    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:] ; i = s.find('=')
        if i == -1: break
        key = s[:i] ; s = s[i+1:] ; i = s.find('--')
        if i == -1:
            val = s ; s = ''
        else:
            val = s[:i] ; s = s[i:]
        # g.trace('s',repr(s))
        if val.endswith(','): val = val[:-1]
        if val.startswith('[') and val.endswith(']'): val = val[1:-1]
        val = val.strip()
        if not val: val = '1'
        d[str(key)] = str(val)

    if trace: g.trace(d)
    return d

    # if args.find(',') == -1:
        # args = [args]
    # else:
        # args = args.split(',')

    # for arg in args:
        # data = arg.split('=')
        # if len(data) == 1:
            # key = data[0]
            # d[str(key)] = "1" # New in Leo 4.7: empty arg defaults to "1".
        # elif len(data) == 2:
            # key,value = data
            # value = value.strip()
            # if value.startswith('[') and value.endswith(']'):
                # value = value[1:-1]
            # d[str(key)] = str(value)
        # else:
            # g.es_print('bad option: %s' % s,color='red')
            # break

    # return d
</t>
<t tx="ekr.20090514093345.6053">'''
Run all the unit tests in the .leo file given by the path.
The path is relative to the leo\test directory.
'''

import leo.core.leoTest as leoTest

leoTest.runUnitTestLeoFile(gui='nullGui',path='../core/leoPy.leo')

g.es_print('unit tests done',color='blue')</t>
<t tx="ekr.20090514093345.6054"></t>
<t tx="ekr.20090517020744.5904"></t>
<t tx="ekr.20090517020744.5906"></t>
<t tx="ekr.20090517020744.5907"></t>
<t tx="ekr.20090517020744.5909"></t>
<t tx="ekr.20090517020744.5910"></t>
<t tx="ekr.20090517020744.5911"></t>
<t tx="ekr.20090517102212.5874"></t>
<t tx="ekr.20090517102548.5889"># Add the nodes in the following tree to external unit tests.</t>
<t tx="ekr.20090520055433.5945">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    trace = False and not g.unitTesting

    if not fileName: return False, None
    isLeo,fn,relFn = g.mungeFileName(fileName)

    # Return if the file is already open.
    c = g.findOpenFile(fn)
    if c: return True,c.frame

    # Open the file.
    if isLeo:
        c,f = g.openWithFileNameHelper(old_c,gui,fn,relFn)
    else:
        c,f = g.openWrapperLeoFile(old_c,fn,gui),None
    if not c: return False,None

    # Init the open file.
    assert c.frame and c.frame.c == c
    c.frame.log.enable(enableLog)
    g.app.writeWaitingLog(c,forceLog=not g.app.initing)
    ok = g.handleOpenHooks(c,old_c,gui,fn,f,readAtFileNodesFlag)
    if not ok: return False,None
    g.createMenu(c,fn)
    g.finishOpen(c)
    return True,c.frame
</t>
<t tx="ekr.20090520055433.5946">def openWithFileNameHelper(old_c,gui,fileName,relativeFileName):

    if old_c: g.preRead(fileName)
    g.doHook('open0')

    # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
    theFile,isZipped = g.openLeoOrZipFile(fileName)
    if not theFile:
        return None,None

    # This call will take 3/4 sec. to open a file from the leoBridge.
    # This is due to imports in c.__init__
    c,frame = app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        gui=gui)

    c.isZipped = isZipped
    return c,theFile
</t>
<t tx="ekr.20090520055433.5948">def findOpenFile(fileName):

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    for frame in g.app.windowList:
        c = frame.c
        if munge(fileName) == munge(c.mFileName):
            frame.bringToFront()
            c.setLog()
            c.outerUpdate()
            return c
    return None
</t>
<t tx="ekr.20090520055433.5949">def preRead(fileName):

    '''Read the file for the first time,
    setting the setting for a later call to finishCreate.
    '''

    c = g.app.config.openSettingsFile(fileName)
    if c:
        g.app.config.updateSettings(c,localFlag=True)
</t>
<t tx="ekr.20090520055433.5950">def handleOpenHooks(c,old_c,gui,fileName,theFile,readAtFileNodesFlag):

    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if theFile:
            app.lockLog()
            ok = c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(c.frame)
                return False
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)

    # Bug fix in 4.4.
    if not c.openDirectory:
        c.openDirectory = c.frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    return True</t>
<t tx="ekr.20090520055433.5951">def createMenu(c,fileName=None):

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.

    if not g.doHook("menu1",c=c,p=c.p,v=c.p):
        c.frame.menu.createMenuBar(c.frame)
        c.updateRecentFiles(fileName)
        g.doHook("menu2",c=c,p=c.p,v=c.p)
        g.doHook("after-create-leo-frame",c=c)
</t>
<t tx="ekr.20090520055433.5952">def finishOpen(c):

    k = c.k
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    if c.chapterController:
        c.chapterController.finishCreate()
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()
    c.frame.initCompleteHint()
    return True
</t>
<t tx="ekr.20090520055433.5954">def mungeFileName(fileName):

    '''Create a full, normalized, Unicode path name, preserving case.'''

    relFn = g.os_path_normpath(fileName)
    fn = g.os_path_finalize(fileName)

    isZipped = fn and zipfile.is_zipfile(fn)
    isLeo = isZipped or fn.endswith('.leo')

    return isLeo,fn,relFn
</t>
<t tx="ekr.20090521175848.5881"># From the Python cookbook, recipe 5.23

class nullObject:

    """An object that does nothing, and does it very well."""

    def __init__   (self,*args,**keys): pass
    def __call__   (self,*args,**keys): return self
    # def __len__    (self): return 0 # Debatable.
    def __repr__   (self): return "nullObject"
    def __str__    (self): return "nullObject"
    def __nonzero__(self): return 0
    def __delattr__(self,attr):     return None ### self
    def __getattr__(self,attr):     return None ### self
    def __setattr__(self,attr,val): return None ### self
</t>
<t tx="ekr.20090620052003.8505">u = c.undoer
w = c.frame.body.bodyCtrl
p2 = p.insertAsNthChild(0)
c.setHeadString(p2,'@test xxx')
s = '''\
if g.unitTesting:

    c,p = g.getTestVars()

    '''
c.setBodyString(p2,s)
c.selectPosition(p2)
c.redraw()
w.setInsertPoint(len(s))
c.bodyWantsFocus()
c.outerUpdate()
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20091203060018.6067">To do:
    
- (done) add list for .keys(), .values(), .items()</t>
<t tx="ekr.20091203060018.6100">@nocolor-node

Done:
- (mostly) Make the 2to3 changes.
- Use something better than repr to create item hash in qtGui.</t>
<t tx="ekr.20091203165343.6144">Available transformations for the -f/--fix option:
apply
basestring
buffer
callable
dict
except
exec
execfile
filter
funcattrs
future
getcwdu
has_key
idioms
import
imports
imports2
input
intern
isinstance
itertools
itertools_imports
long
map
metaclass
methodattrs
ne
next
nonzero
numliterals
paren
### print
raise
raw_input
reduce
renames
repr
set_literal
standarderror
sys_exc
throw
tuple_params
types
unicode
urllib
ws_comma
xrange
xreadlines
zip
</t>
<t tx="ekr.20091203165343.6146">@nocolor-node

--- leo/core/leoApp.py (original)
+++ leo/core/leoApp.py (refactored)
@@ -667,7 +667,7 @@
         if g.app.gui is None:
             # tkinter broken/doesn't exist. Print error
             print("Please enter LeoID (e.g. your username, 'johndoe'...)")
-            leoid = raw_input('LeoID: ')
+            leoid = input('LeoID: ')
 
         else:
             leoid = g.app.gui.runAskLeoIDDialog()
             

--- leo/core/leoAtFile.py (original)
+++ leo/core/leoAtFile.py (refactored)
@@ -335,7 +335,7 @@
             if g.isPython3:
                 self.targetFileName = self.outputFileName = ''
             else:
-                self.targetFileName = self.outputFileName = unicode('')
+                self.targetFileName = self.outputFileName = str('')
         #@-node:ekr.20041005105605.16:&lt;&lt; init ivars for writing &gt;&gt;&gt;
         #@nl
 
@@ -1837,7 +1837,7 @@
 
         tag = "@first"
         foundAtFirstYet = 0
-        outRange = range(len(out))
+        outRange = list(range(len(out)))
         j = 0
         for k in outRange:
             # skip leading whitespace lines
@@ -1865,7 +1865,7 @@
 
         tag = "@last"
         foundAtLastYet = 0
-        outRange = range(-1,-len(out),-1)
+        outRange = list(range(-1,-len(out),-1))
         j = -1
         for k in outRange:
             # skip trailing whitespace lines

@@ -4095,7 +4095,7 @@
             if g.isPython3:
                 at.outputFileName = ''
             else:
-                at.outputFileName = unicode('')
+                at.outputFileName = str('')
 
             at.shortFileName = ''
             at.targetFileName = None
             
--- leo/core/leoChapters.py (original)
+++ leo/core/leoChapters.py (refactored)
@@ -82,7 +82,7 @@
         state = k.getState(tag)
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Clone node to chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
@@ -147,7 +147,7 @@
             return
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             k.setLabelBlue('Convert node to chapter: ',protect=True)
             k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
         else:
@@ -167,7 +167,7 @@
         state = k.getState(tag)
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Copy node to chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
@@ -216,7 +216,7 @@
         state = k.getState(tag)
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             k.setLabelBlue('Create chapter: ',protect=True)
             k.getArg(event,tag,1,self.createChapter,tabList=names)
         else:
@@ -275,7 +275,7 @@
             return
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             k.setLabelBlue('Create chapter from node: ',protect=True)
             k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
         else:
@@ -295,7 +295,7 @@
         state = k.getState(tag)
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Move node to chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
@@ -402,7 +402,7 @@
         state = k.getState(tag)
 
         if state == 0 and not newName:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             prefix = 'Rename this chapter: '
             k.setLabelBlue(prefix,protect=True)
             k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
@@ -433,7 +433,7 @@
         state = k.getState(tag)
 
         if state == 0:
-            names = cc.chaptersDict.keys()
+            names = list(cc.chaptersDict.keys())
             g.es('Chapters:\n' + '\n'.join(names))
             prefix = 'Select chapter: '
             k.setLabelBlue(prefix,protect=True)
             

--- leo/core/leoColor.py (original)
+++ leo/core/leoColor.py (refactored)

@@ -2060,7 +2060,7 @@
                             w.tag_config(key,font=font)
                             break
                 else: # Neither the general setting nor the language-specific setting exists.
-                    if len(self.fonts.keys()) &gt; 1: # Restore the default font.
+                    if len(list(self.fonts.keys())) &gt; 1: # Restore the default font.
                         # g.trace('default',key)
                         w.tag_config(key,font=defaultBodyfont)
             #@nonl

--- leo/core/leoCommands.py (original)
+++ leo/core/leoCommands.py (refactored)
@@ -178,7 +178,7 @@
 
             # copy global commands to this controller    
 
-            for name,f in g.app.global_commands_dict.items():
+            for name,f in list(g.app.global_commands_dict.items()):
                 k.registerCommand(name,shortcut = None, func = f, pane='all',verbose=False)        
 
             k.finishCreate()
@@ -454,7 +454,7 @@
             m = re.finditer(pat, p.b)
             t1,t2 = itertools.tee(m,2)
             try:
-                first = t1.next()
+                first = next(t1)
             except StopIteration:
                 continue
             pc = p.copy()
@@ -851,7 +851,7 @@
                     # This clause by Jim Sizelove.
                     elif openType == "subprocess.Popen":
                         use_shell = True
-                        if isinstance(arg, basestring):
+                        if isinstance(arg, str):
                             vtuple = arg + " " + path
                         elif isinstance(arg, (list, tuple)):
                             vtuple = arg[:]
@@ -866,7 +866,7 @@
                                 g.es_exception()
                         else:
                             g.trace('Can not import subprocess.  Skipping: "%s"' % command)
-                    elif callable(openType):
+                    elif hasattr(openType, '__call__'):
                         # Invoke openWith like this:
                         # c.openWith(data=[f,None,None])
                         # f will be called with one arg, the filename
@@ -1806,7 +1806,7 @@
                     # g.trace('**** before',writeScriptFile)
                     if writeScriptFile:
                         scriptFile = self.writeScriptFile(script)
-                        execfile(scriptFile,d)
+                        exec(compile(open(scriptFile).read(), scriptFile, 'exec'),d)
                     else:
                         exec(script,d)
                     # g.trace('**** after')

--- leo/core/leoConfig.py (original)
+++ leo/core/leoConfig.py (refactored)
 
@@ -1922,7 +1922,7 @@
         if 0: # Good trace.
             if localFlag:
                 g.trace(c.fileName())
-                g.trace(d and d.keys())
+                g.trace(d and list(d.keys()))
     #@-node:ekr.20051013161232:updateSettings
     #@-node:ekr.20041120064303:readSettingsFiles &amp; helpers (g.app.config)
     #@+node:ekr.20041117083857.1:g.app.config.readSettings

--- leo/core/leoDebugger.py (original)
+++ leo/core/leoDebugger.py (refactored)
@@ -4,7 +4,7 @@
 
 #@&lt;&lt; imports &gt;&gt;
 #@+node:ekr.20060307120420:&lt;&lt; imports &gt;&gt;
-import leoGlobals as g
+from . import leoGlobals as g
 import pdb
 import sys
 #@nonl
 
 
--- leo/core/leoEditCommands.py (original)
+++ leo/core/leoEditCommands.py (refactored)
@@ -15,11 +15,12 @@
 import leo.core.leoKeys as leoKeys
 import leo.core.leoPlugins as leoPlugins
 import leo.core.leoTest as leoTest
+from functools import reduce
 
@@ -2145,7 +2146,7 @@
     def _addPrefix (self,ntxt):
 
         ntxt = ntxt.split('.')
-        ntxt = map(lambda a: self.fillPrefix+a,ntxt)
+        ntxt = [self.fillPrefix+a for a in ntxt]
         ntxt = '.'.join(ntxt)
         return ntxt
     #@-node:ekr.20050920084036.71:_addPrefix
@@ -4705,7 +4706,7 @@
             columns = [w.get('%s.%s' % (z,sint2),'%s.%s' % (z,sint4))
                 for z in range(sint1,sint3+1)]
             aList = g.splitLines(txt)
-            zlist = zip(columns,aList)
+            zlist = list(zip(columns,aList))
             zlist.sort()
             s = g.joinLines([z[1] for z in zlist])
             w.delete(i,j)
@@ -4751,7 +4752,7 @@
                 if len(f) &lt; i: return
                 i = i-1
                 fields.append(f[i])
-        nz = zip(fields,txt)
+        nz = list(zip(fields,txt))
         nz.sort()
         w.delete(i,j)
         int1 = i
@@ -5848,7 +5849,7 @@
             return self
         #@-node:ekr.20071003160252.1:__init__ &amp; __iter__
         #@+node:ekr.20071003160252.2:next
-        def next(self):
+        def __next__(self):
 
             commands = self.c.killBufferCommands
             aList = commands.killBuffer
@@ -6013,7 +6014,7 @@
         try:
             if not pop or self.lastYankP and self.lastYankP != current:
                 self.reset = 0
-            s = self.kbiterator.next()
+            s = next(self.kbiterator)
             if s is None: s = clip_text or ''
             if i != j: w.deleteTextSelection()
             if s != s.lstrip(): # s contains leading whitespace.
             

--- leo/core/leoFileCommands.py (original)
+++ leo/core/leoFileCommands.py (refactored)

@@ -476,7 +476,7 @@
                         'tx':'ekr.123','testAttr':'abc',
                     }
                 def getNames(self):
-                    return self.attrs.keys()
+                    return list(self.attrs.keys())
                 def getValue(self,key):
                     return self.attrs.get(key)
 
@@ -572,7 +572,7 @@
             g.pr('\nnode: tnx: %s len(body): %d %s' % (
                 self.tnx,len(self.bodyString),self.headString))
             g.pr('children:',g.listToString(self.children))
-            g.pr('attrs:',self.attributes.values())
+            g.pr('attrs:',list(self.attributes.values()))
         #@nonl
         #@-node:ekr.20060919110638.18:node.dump
         #@-others
@@ -1149,7 +1149,7 @@
 
         trace = False and not g.unitTesting
         d = sax_node.tnodeAttributes
-        if trace and d: g.trace(sax_node,d.keys())
+        if trace and d: g.trace(sax_node,list(d.keys()))
 
         aDict = {}
         for key in d:
@@ -1159,7 +1159,7 @@
             aDict[key] = val2
 
         if aDict:
-            if trace: g.trace('uA',v,aDict.keys())
+            if trace: g.trace('uA',v,list(aDict.keys()))
             v.unknownAttributes = aDict
     #@+node:ekr.20090702070510.6028:@test handleTnodeSaxAttributes
     if g.unitTesting:
@@ -1454,7 +1454,7 @@
             else:
                 if theFile: s = theFile.read()
                 s = self.cleanSaxInputString(s)
-                theFile = cStringIO.StringIO(s)
+                theFile = io.StringIO(s)
             parser = xml.sax.make_parser()
             parser.setFeature(xml.sax.handler.feature_external_ges,1)
                 # Include external general entities, esp. xml-stylesheet lines.
@@ -2541,7 +2541,7 @@
             g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
             return ''
         else:
-            val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
+            val = ''.join([self.putUaHelper(torv,key,val) for key,val in list(attrDict.items())])
             # g.trace(torv,attrDict)
             return val
     #@-node:EKR.20040526202501:putUnknownAttributes
     
    
--- leo/core/leoFind.py (original)
+++ leo/core/leoFind.py (refactored)
 
--- leo/core/leoFrame.py (original)
+++ leo/core/leoFrame.py (refactored)
@@ -856,7 +856,7 @@
         if self.numberOfEditors == 2:
             # Inject the ivars into the first editor.
             # Bug fix: Leo 4.4.8 rc1: The name of the last editor need not be '1'
-            d = self.editorWidgets ; keys = d.keys()
+            d = self.editorWidgets ; keys = list(d.keys())
             if len(keys) == 1:
                 w_old = d.get(keys[0])
                 self.updateInjectedIvars(w_old,p)
@@ -918,11 +918,11 @@
         '''Cycle keyboard focus between the body text editors.'''
 
         c = self.c ; d = self.editorWidgets ; w = c.frame.body.bodyCtrl
-        values = d.values()
+        values = list(d.values())
         if len(values) &gt; 1:
             i = values.index(w) + 1
             if i == len(values): i = 0
-            w2 = d.values()[i]
+            w2 = list(d.values())[i]
             assert(w!=w2)
             self.selectEditor(w2)
             c.frame.body.bodyCtrl = w2
@@ -937,7 +937,7 @@
 
         c = self.c ; w = c.frame.body.bodyCtrl ; d = self.editorWidgets
 
-        if len(d.keys()) == 1: return
+        if len(list(d.keys())) == 1: return
 
         name = w.leo_name
 
@@ -950,7 +950,7 @@
             self.pb.configurepane(pane,size=minSize)
 
         # Select another editor.
-        w = d.values()[0]
+        w = list(d.values())[0]
         # c.frame.body.bodyCtrl = w # Don't do this now?
         self.numberOfEditors -= 1
         self.selectEditor(w)
@@ -960,7 +960,7 @@
 
         '''Return an editor to be assigned to chapter.'''
 
-        c = self.c ; d = self.editorWidgets ; values = d.values()
+        c = self.c ; d = self.editorWidgets ; values = list(d.values())
 
         # First, try to match both the chapter and position.
         if p:
@@ -1104,7 +1104,7 @@
 
         c = self.c ; p = c.p
         d = self.editorWidgets
-        if len(d.keys()) &lt; 2: return # There is only the main widget.
+        if len(list(d.keys())) &lt; 2: return # There is only the main widget.
 
         for key in d:
             w = d.get(key)
@@ -2157,11 +2157,11 @@
         w = d.get(self.tabName)
         # g.trace(self.tabName,w)
 
-        values = d.values()
+        values = list(d.values())
         if self.numberOfVisibleTabs() &gt; 1:
             i = i2 = values.index(w) + 1
             if i == len(values): i = 0
-            tabName = d.keys()[i]
+            tabName = list(d.keys())[i]
             self.selectTab(tabName)
             return 
     #@nonl
@@ -2207,7 +2207,7 @@
     #@+node:ekr.20070302094848.9:numberOfVisibleTabs
     def numberOfVisibleTabs (self):
 
-        return len([val for val in self.frameDict.values() if val != None])
+        return len([val for val in list(self.frameDict.values()) if val != None])
     #@-node:ekr.20070302094848.9:numberOfVisibleTabs
     #@+node:ekr.20070302094848.10:renameTab
     def renameTab (self,oldName,newName):
@@ -3367,7 +3367,7 @@
         if not w:
             d[p.v] = w = stringTextWidget(
                 c=self.c,
-                name='head-%d' % (1 + len(d.keys())))
+                name='head-%d' % (1 + len(list(d.keys()))))
             w.setAllText(p.h)
         # g.trace('w',w,'p',p.h)
         return w
         

--- leo/core/leoGlobals.py (original)
+++ leo/core/leoGlobals.py (refactored)

@@ -46,6 +46,7 @@
 import re
 import sys
 import time
+from functools import reduce
 
 try:
     import zipfile
@@ -105,7 +106,7 @@
     # def __len__    (self): return 0 # Debatable.
     def __repr__   (self): return "nullObject"
     def __str__    (self): return "nullObject"
-    def __nonzero__(self): return 0
+    def __bool__(self): return 0
     def __delattr__(self,attr):     return None ### self
     def __getattr__(self,attr):     return None ### self
     def __setattr__(self,attr,val): return None ### self
@@ -135,7 +136,7 @@
     if not g.app:
         # Important: these references do not make Leo's core gui-dependent.
         # In other words, this function is called only when Tkinter should be the gui.
-        import Tkinter as Tk
+        import tkinter as Tk
         Pmw = g.importExtension('Pmw',pluginName=pluginName,verbose=True)
         if Tk and Pmw:
             import leo.core.leoApp as leoApp, leoGui

@@ -1971,7 +1972,7 @@
 
     g.pr(s)
 
-    i = 0 ; n = long(1000) * long(1000)
+    i = 0 ; n = int(1000) * int(1000)
     while i &lt; n:
         i += 1
 #@-node:ekr.20031218072017.3128:pause
@@ -2515,7 +2516,7 @@
     theFile,theFileName = g.create_temp_file()
 
     assert type(theFile) == types.FileType, 'not file type'
-    assert type(theFileName) in (types.StringType, types.UnicodeType), 'not string type'
+    assert type(theFileName) in (bytes, str), 'not string type'
 #@-node:ekr.20090517020744.5873:@test g.create_temp_file
 #@-node:ekr.20031218072017.3117:g.create_temp_file &amp; test
 #@+node:ekr.20031218072017.3118:g.ensure_extension
@@ -2734,7 +2735,7 @@
     try:
         isZipped = zipfile and zipfile.is_zipfile(fileName)
         if isZipped:
-            import StringIO
+            import io
             theFile = zipfile.ZipFile(fileName,'r')
             if not theFile: return None,False
             # New in Leo 4.6 b2: read the file into an StringIO file.
@@ -2742,7 +2743,7 @@
             name = aList and len(aList) == 1 and aList[0]
             if not name: return None,False
             s = theFile.read(name)
-            theStringFile =  StringIO.StringIO(s)
+            theStringFile =  io.StringIO(s)
             return theStringFile,True
         else:
             # mode = g.choose(g.isPython3,'r','rb')
@@ -3351,7 +3352,7 @@
         d[t] = d.get(t,0) + 1
 
     if 1: # Sort by n
-        items = d.items()
+        items = list(d.items())
         try:
             # Support for keword args to sort function exists in Python 2.4.
             # Support for None as an alternative to omitting cmp exists in Python 2.3.
@@ -3385,7 +3386,7 @@
 
         for obj in gc.get_objects():
             t = type(obj)
-            if t == 'instance' and t != types.UnicodeType:
+            if t == 'instance' and t != str:
                 try: t = obj.__class__
                 except Exception: pass
             if t != types.FrameType:
@@ -3695,7 +3696,7 @@
     if d is None: d = {}
 
     result = {}
-    for key,default_val in d.items():
+    for key,default_val in list(d.items()):
         isBool = default_val in (True,False)
         val = keys.get(key)
         if isBool and val in (True,'True','true'):
@@ -5094,7 +5095,7 @@
 
     subprocess = g.importExtension('subprocess',None,verbose=False)
 
-    cwd = os.getcwdu()
+    cwd = os.getcwd()
     fdir, fname = g.os_path_split(filename)
 
     if subprocess: # Only exists in Python 2.4.
@@ -5120,7 +5121,7 @@
     else:
         if fdir: os.chdir(fdir)
         d = {'__name__': '__main__'}
-        execfile(fname, d)  #, globals()
+        exec(compile(open(fname).read(), fname, 'exec'), d)  #, globals()
         os.system('%s %s' % (sys.executable, fname))
         if fdir: os.chdir(cwd)
 #@-node:ekr.20050503112513.7:g.executeFile

@@ -5873,7 +5874,7 @@
 
     result = []
     for item in theList:
-        if type(item) == types.ListType:
+        if type(item) == list:
             result.extend(g.flattenList(item))
         else:
             result.append(item)
@@ -6389,7 +6390,7 @@
         return 'module'
     elif type(obj) == types.InstanceType:
         return 'object'
-    elif type(obj) in (types.UnicodeType,types.StringType):
+    elif type(obj) in (str,bytes):
         return 'string'
     else:
         theType = str(type(obj))
@@ -6618,7 +6619,7 @@
 
     # Requires minimal further imports.
     try:
-        import Tkinter as Tk
+        import tkinter as Tk
         root = g.app.root or Tk.Tk()
         title = 'Can not import %s' % moduleName
         top = createDialogFrame(Tk,root,title,message)


--- leo/core/leoGui.py (original)
+++ leo/core/leoGui.py (refactored)


--- leo/core/leoImport.py (original)
+++ leo/core/leoImport.py (refactored)

@@ -1831,7 +1831,7 @@
 
         if s1 is None and s2 is None:
             if self.isRst: # Errors writing file at present...
-                outputFile = StringIO.StringIO()
+                outputFile = io.StringIO()
                 c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile,trialWrite=True)
                 s1,s2 = self.file_s,outputFile.getvalue()
             else:
                 

--- leo/core/leoKeys.py (original)
+++ leo/core/leoKeys.py (refactored)
@@ -22,6 +22,7 @@
 import string
 import sys
 import types
+from functools import reduce
 
 # The following imports _are_ used.
 
@@ -167,13 +168,13 @@
 
         for z in gc.get_objects():
             t = type(z)
-            if t == types.ClassType:
+            if t == type:
                 name = z.__name__
             elif t == types.InstanceType:
                 name = z.__class__.__name__
             elif repr(t).startswith('&lt;class'): # A wretched kludge.
                 name = z.__class__.__name__
-            elif t == types.TypeType:
+            elif t == type:
                 name = z.__name__
             else:
                 name = None
@@ -212,7 +213,7 @@
         ]
 
         if 0: # Not useful at this point.
-            for key in __builtins__.keys():
+            for key in list(list(__builtins__.keys())):
                 obj = __builtins__.get(key)
                 if obj in (True,False,None): continue
                 data = [key],'object',obj
@@ -305,9 +306,9 @@
         elif keysym == '!':
             # Toggle between verbose and brief listing.
             self.verbose = not self.verbose
-            if type(self.theObject) == types.DictType:
-                self.membersList = self.theObject.keys()
-            elif type(self.theObject) in (types.ListType,types.TupleType):
+            if type(self.theObject) == dict:
+                self.membersList = list(list(self.theObject.keys()))
+            elif type(self.theObject) in (list,tuple):
                 self.membersList = self.theObject
             self.computeCompletionList(verbose=self.verbose)
         elif ch and ch in string.printable:
@@ -518,7 +519,7 @@
             #@+node:ekr.20061031131434.21:&lt;&lt; try to set s from a Python global function &gt;&gt;
             # The first line of the docstring is good enough, except for classes.
             f = __builtins__.get(self.leadinWord)
-            doc = f and type(f) != types.ClassType and f.__doc__
+            doc = f and type(f) != type and f.__doc__
             if doc:
                 # g.trace(doc)
                 s = g.splitLines(doc)
@@ -533,7 +534,7 @@
         if not s:
             #@        &lt;&lt; get s using inspect &gt;&gt;
             #@+node:ekr.20061031131434.22:&lt;&lt; get s using inspect &gt;&gt;
-            isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType
+            isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == bytes
 
             # g.trace(self.prevObjects)
 
@@ -980,7 +981,7 @@
             # Leading dot shows all classes.
             self.leadinWord = None
             self.theObject = sys.modules
-            self.membersList = sys.modules.keys()
+            self.membersList = list(list(sys.modules.keys()))
             self.beginTabName('Modules')
         elif word in ( "'",'"'):
             word = 'aString' # This is in the objectsDict.
@@ -1337,7 +1338,7 @@
 
         if 0: # Calling the real ctor is way too dangerous.
             # Set args to the list of required arguments.
-            args = inspect.getargs(theClass.__init__.im_func.func_code)
+            args = inspect.getargs(theClass.__init__.__func__.__code__)
             args = args[0] ; n = len(args)-1
             args = [None for z in range(n)]
 
@@ -2514,7 +2515,7 @@
         if k.regx.iter:
             try:
                 k.regXKey = keysym
-                k.regx.iter.next() # EKR: next() may throw StopIteration.
+                next(k.regx.iter) # EKR: next() may throw StopIteration.
             except StopIteration:
                 pass
             return 'break'
@@ -2650,11 +2651,11 @@
                 k.callAltXFunction(k.mb_event)
         elif keysym in ('Tab','\t'):
             if trace and verbose: g.trace('***Tab')
-            k.doTabCompletion(c.commandsDict.keys())
+            k.doTabCompletion(list(c.commandsDict.keys()))
             c.minibufferWantsFocus()
         elif keysym == 'BackSpace':
             if trace and verbose: g.trace('***BackSpace')
-            k.doBackSpace(c.commandsDict.keys())
+            k.doBackSpace(list(c.commandsDict.keys()))
             c.minibufferWantsFocus()
         elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
             # g.trace('non-ascii')
@@ -2695,7 +2696,7 @@
         else:
             if 1: # Useful.
                 if trace: g.trace('*** tab completion')
-                k.doTabCompletion(c.commandsDict.keys())
+                k.doTabCompletion(list(c.commandsDict.keys()))
             else: # Annoying.
                 k.keyboardQuit(event)
                 k.setLabel('Command does not exist: %s' % commandName)
@@ -3252,7 +3253,7 @@
         if commandName.startswith('press-') and commandName.endswith('-button'):
             d = c.config.getAbbrevDict()
                 # Keys are full command names, values are abbreviations.
-            if commandName in d.values():
+            if commandName in list(d.values()):
                 for key in d:
                     if d.get(key) == commandName:
                         c.commandsDict [key] = c.commandsDict.get(commandName)
@@ -4014,7 +4015,7 @@
         else:
             k.modeBindingsDict = d
             prompt = d.get('*command-prompt*') or modeName
-            if trace: g.trace('modeName',modeName,prompt,'d.keys()',d.keys())
+            if trace: g.trace('modeName',modeName,prompt,'d.keys()',list(d.keys()))
 
         k.inputModeName = modeName
         k.silentMode = False
         

--- leo/core/leoNodes.py (original)
+++ leo/core/leoNodes.py (refactored)

@@ -1819,7 +1819,7 @@
 
@@ -2839,7 +2839,7 @@
             m = re.finditer(pat, p.b)
             t1,t2 = itertools.tee(m,2)
             try:
-                first = t1.next()
+                first = next(t1)
                 # if does not raise StopIteration...
                 pc = p.copy()
                 pc.matchiter = t2
                 

--- leo/core/leoPlugins.py (original)
+++ leo/core/leoPlugins.py (refactored)
@@ -303,7 +303,7 @@
 
     import types
 
-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         result = []
         for tag in tags:
             aList = getHandlersForOneTag(tag) 
@@ -571,7 +571,7 @@
 
     import types
 
-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         for tag in tags:
             registerOneExclusiveHandler(tag,fn)
     else:
@@ -606,7 +606,7 @@
 
     import types
 
-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         for tag in tags:
             registerOneHandler(tag,fn)
     else:
@@ -659,7 +659,7 @@
 
     import types
 
-    if type(tags) in (types.TupleType,types.ListType):
+    if type(tags) in (tuple,list):
         for tag in tags:
             unregisterOneHandler(tag,fn)
     else:
         

--- leo/core/leoRst.py (original)
+++ leo/core/leoRst.py (refactored)

@@ -73,7 +73,7 @@
         module = SilverCity and getattr(SilverCity,language)
         generator = module and getattr(module,language+"HTMLGenerator")
         if generator:
-            io = StringIO.StringIO()
+            io = io.StringIO()
             generator().generate_html(io,'\n'.join(content))
             html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
         else:
@@ -381,7 +381,7 @@
 
         if 0:
             g.trace(root.h)
-            for key in self.tnodeOptionDict.keys():
+            for key in list(self.tnodeOptionDict.keys()):
                 g.trace(key)
                 g.printDict(self.tnodeOptionDict.get(key))
     #@nonl
@@ -531,7 +531,7 @@
         if data:
             name,val = data
             fullName = 'rst3_' + self.munge(name)
-            if fullName in self.defaultOptionsDict.keys():
+            if fullName in list(self.defaultOptionsDict.keys()):
                 if   val.lower() == 'true': val = True
                 elif val.lower() == 'false': val = False
                 # g.trace('%24s %8s %s' % (self.munge(name),val,p.h))
@@ -577,7 +577,7 @@
         for p in p.self_and_parents():
             d = self.tnodeOptionDict.get(p.v,{})
             # g.trace(p.h,d)
-            for key in d.keys():
+            for key in list(d.keys()):
                 ivar = self.munge(key)
                 if not ivar in seen:
                     seen.append(ivar)
@@ -740,7 +740,7 @@
         self.initWrite(p)
 
         # Always write to a string first.
-        self.outputFile = StringIO.StringIO()
+        self.outputFile = io.StringIO()
         self.writeTree(p)
         self.source = self.stringOutput = self.outputFile.getvalue()
 
@@ -821,7 +821,7 @@
                 g.es('SilverCity not present so no syntax highlighting')
 
         self.initWrite(p,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
-        self.outputFile = StringIO.StringIO()
+        self.outputFile = io.StringIO()
         self.writeTree(p)
         self.source = self.outputFile.getvalue()
         self.outputFile = None

--- leo/core/leoTangle.py (original)
+++ leo/core/leoTangle.py (refactored)
@@ -2091,7 +2091,7 @@
         for name in sorted(self.ust):
             section = self.ust[name]
             s += "\n\n" + section.name
-            for part in section.parts.values():
+            for part in list(section.parts.values()):
                 assert(part.of == section.of)
                 s += "\n----- part %d of %d -----\n" % (part.part,part.of)
                 s += repr(g.get_line(part.code,0))
@@ -2163,9 +2163,9 @@
         """Issues a warning about any sections in the derived file for which
         no corresponding section has been seen in the outline."""
 
-        for section in self.ust.values():
+        for section in list(self.ust.values()):
             # g.trace(section)
-            for part in section.parts.values():
+            for part in list(section.parts.values()):
                 assert(part.of == section.of)
                 if not part.update_flag:
                     lp = g.choose(self.use_noweb_flag,"&lt;&lt; ","@&lt; ")
                     

--- leo/core/leoTest.py (original)
+++ leo/core/leoTest.py (refactored)
@@ -190,7 +190,7 @@
 
         if writeScriptFile:
             scriptFile = c.writeScriptFile(script)
-            execfile(scriptFile,d)
+            exec(compile(open(scriptFile).read(), scriptFile, 'exec'),d)
         else:
             exec(script,d)
 
@@ -1337,7 +1337,7 @@
 def checkFileTabs (fileName,s):
 
     try:
-        readline = g.readLinesClass(s).next
+        readline = g.readLinesClass(s).__next__
         tabnanny.process_tokens(tokenize.generate_tokens(readline))
 
     except tokenize.TokenError(msg):
@@ -1739,7 +1739,7 @@
         try:
             result *= factor
         except OverflowError:
-            result *= long(factor)
+            result *= int(factor)
         factor += 1
     return result
 #@-node:ekr.20051104075904.97:factorial
 
 
--- leo/core/leoUndo.py (original)
+++ leo/core/leoUndo.py (refactored)
@@ -261,7 +261,7 @@
             g.pr('-' * 20)
 
         # bunch is not a dict, so bunch.keys() is required.
-        for key in bunch.keys(): 
+        for key in list(bunch.keys()): 
             val = bunch.get(key)
             # g.trace(key,val)
             setattr(u,key,val)


--- leo/core/leo_Debugger.py (original)
+++ leo/core/leo_Debugger.py (refactored)
@@ -2,12 +2,12 @@
 #@+node:ekr.20060516135654.94:@thin leo_Debugger.py
 #@&lt;&lt; imports &gt;&gt;
 #@+node:ekr.20060516135654.95:&lt;&lt; imports &gt;&gt;
-import leoGlobals as g
-
-import leo_FileList
-import leo_run
-import leo_RemoteDebugger
-import leo_Shell
+from . import leoGlobals as g
+
+from . import leo_FileList
+from . import leo_run
+from . import leo_RemoteDebugger
+from . import leo_Shell
 
 import idlelib.ScrolledList as ScrolledList
 
@@ -18,8 +18,8 @@
 import time
 import types
 
-import Tkinter as Tk
-import tkMessageBox
+import tkinter as Tk
+import tkinter.messagebox
 
 import __main__
 #@nonl
@@ -245,8 +245,8 @@
             height = 20*len(dict) # XXX 20 == observed height of Entry widget
         self.master = master
         self.title = title
-        import repr
-        self.repr = repr.Repr()
+        import reprlib
+        self.repr = reprlib.Repr()
         self.repr.maxstring = 60
         self.repr.maxother = 60
         self.frame = frame = Tk.Frame(master)
@@ -274,14 +274,14 @@
             return
         subframe = self.subframe
         frame = self.frame
-        for c in subframe.children.values():
+        for c in list(subframe.children.values()):
             c.destroy()
         self.dict = None
         if not dict:
             l = Tk.Label(subframe, text="None")
             l.grid(row=0, column=0)
         else:
-            names = dict.keys()
+            names = list(dict.keys())
             names.sort()
             row = 0
             for name in names:
@@ -372,7 +372,7 @@
         bl.append(b)
         self.bstep = b = Tk.Button(bframe, text="Step", command=self.step)
         bl.append(b)
-        self.bnext = b = Tk.Button(bframe, text="Over", command=self.next)
+        self.bnext = b = Tk.Button(bframe, text="Over", command=self.__next__)
         bl.append(b)
         self.bret = b = Tk.Button(bframe, text="Out", command=self.ret)
         bl.append(b)
@@ -553,7 +553,7 @@
         self.root.quit()
     #@-node:ekr.20060516135654.197:step
     #@+node:ekr.20060516135654.198:next
-    def next(self):
+    def __next__(self):
         self.idb.set_next(self.frame)
         self.root.quit()
     #@-node:ekr.20060516135654.198:next
@@ -595,8 +595,9 @@
             self.sync_source_line()
     #@-node:ekr.20060516135654.203:show_source
     #@+node:ekr.20060516135654.204:show_frame
-    def show_frame(self, (frame, lineno)):
-    
+    def show_frame(self, xxx_todo_changeme):
+    
+        (frame, lineno) = xxx_todo_changeme
         self.frame = frame
         self.show_variables()
     #@-node:ekr.20060516135654.204:show_frame
@@ -676,7 +677,7 @@
         g.trace()
         
         if 0: # "Load PyShellEditorWindow breakpoints into subprocess debugger"
-            pyshell_edit_windows = self.pyshell.flist.inversedict.keys()
+            pyshell_edit_windows = list(self.pyshell.flist.inversedict.keys())
             for editwin in pyshell_edit_windows:
                 filename = editwin.io.filename
                 try:
                     

--- leo/core/leo_FileList.py (original)
+++ leo/core/leo_FileList.py (refactored)
@@ -3,7 +3,7 @@
 #@@language python
 #@@tabwidth -4
 
-import leoGlobals as g
+from . import leoGlobals as g
 
 import os
 # from Tkinter import *
@@ -61,7 +61,7 @@
         return key # EKR
     
         if 0:
-            if self.dict.has_key(key):
+            if key in self.dict:
                 edit = self.dict[key]
                 edit.top.wakeup()
                 return edit
@@ -104,7 +104,7 @@
         g.trace()
         
         if 0: # The Leo editor never closes
-            for edit in self.inversedict.keys():
+            for edit in list(self.inversedict.keys()):
                 reply = edit.close()
                 if reply == "cancel":
                     break
@@ -152,7 +152,7 @@
             newkey = os.path.normcase(filename)
             if newkey == key:
                 return
-            if self.dict.has_key(newkey):
+            if newkey in self.dict:
                 conflict = self.dict[newkey]
                 self.inversedict[conflict] = None
                 tkMessageBox.showerror(
                 

</t>
<t tx="ekr.20091203165343.6147">
@@ -17,7 +17,7 @@
 import traceback
 
 try:
-    import Tkinter ; Tkinter.wantobjects = 0
+    import tkinter ; tkinter.wantobjects = 0
         # An ugly hack for Tk/Tkinter 8.5
         # See http://sourceforge.net/forum/message.php?msg_id=4078577
 except ImportError:
@@ -503,7 +503,7 @@
             print(message)
             try:
                 # g.app.gui does not exist yet.
-                import Tkinter as Tk
+                import tkinter as Tk
                 #@                &lt;&lt; define emergency dialog class &gt;&gt;
                 #@+node:ekr.20080822065427.8:&lt;&lt; define emergency dialog class &gt;&gt;
                 class emergencyDialog:
</t>
<t tx="ekr.20091203165343.6148">--- leo/core/leo_run.py (original)
+++ leo/core/leo_run.py (refactored)
@@ -7,7 +7,7 @@
 
 #@&lt;&lt; imports &gt;&gt;
 #@+node:ekr.20060516135654.2:&lt;&lt; imports &gt;&gt;
-import leoGlobals as g
+from . import leoGlobals as g
 
 import sys
 import os
@@ -15,12 +15,12 @@
 import time
 import socket
 import traceback
-import thread
+import _thread
 import threading
-import Queue
+import queue
 
 import idlelib.CallTips as CallTips
-import leo_RemoteDebugger as RemoteDebugger
+from . import leo_RemoteDebugger as RemoteDebugger
 import idlelib.RemoteObjectBrowser as RemoteObjectBrowser
 import idlelib.StackViewer as StackViewer
 import idlelib.rpc as rpc
@@ -111,7 +111,7 @@
                     continue
             try:
                 seq, request = rpc.request_queue.get(0)
-            except Queue.Empty:
+            except queue.Empty:
                 time.sleep(0.05)
                 continue
             method, args, kwargs = request
@@ -143,7 +143,7 @@
         try:
             server = MyRPCServer(address, MyHandler)
             break
-        except socket.error, err:
+        except socket.error as err:
             print&gt;&gt;sys.__stderr__,"Leo Subprocess: socket error: "\
                                         + err[1] + ", retrying...."
     else:
@@ -158,18 +158,18 @@
 #@-node:ekr.20060516135654.5:manage_socket
 #@+node:ekr.20060516135654.6:show_socket_error
 def show_socket_error(err, address):
-    import Tkinter
-    import tkMessageBox
-    root = Tkinter.Tk()
+    import tkinter
+    import tkinter.messagebox
+    root = tkinter.Tk()
     root.withdraw()
     if err[0] == 61: # connection refused
         msg = "Leo's subprocess can't connect to %s:%d.  This may be due "\
               "to your personal firewall configuration.  It is safe to "\
               "allow this internal connection because no data is visible on "\
               "external ports." % address
-        tkMessageBox.showerror("Leo Subprocess Error", msg, parent=root)
+        tkinter.messagebox.showerror("Leo Subprocess Error", msg, parent=root)
     else:
-        tkMessageBox.showerror("Leo Subprocess Error", "Socket Error: %s" % err[1])
+        tkinter.messagebox.showerror("Leo Subprocess Error", "Socket Error: %s" % err[1])
     root.destroy()
 #@nonl
 #@-node:ekr.20060516135654.6:show_socket_error
@@ -269,7 +269,7 @@
         except EOFError:
             global exit_now
             exit_now = True
-            thread.interrupt_main()
+            _thread.interrupt_main()
         except:
             erf = sys.__stderr__
             print&gt;&gt;erf, '\n' + '-'*40
@@ -281,7 +281,7 @@
             print&gt;&gt;erf, '\n*** Unrecoverable, server exiting!'
             print&gt;&gt;erf, '-'*40
             quitting = True
-            thread.interrupt_main()
+            _thread.interrupt_main()
     #@-node:ekr.20060516135654.12:handle_error
     #@-others
 #@nonl
@@ -313,14 +313,14 @@
         "Override SocketIO method - terminate wait on callback and exit thread"
         global quitting
         quitting = True
-        thread.interrupt_main()
+        _thread.interrupt_main()
     #@-node:ekr.20060516135654.16:EOFhook
     #@+node:ekr.20060516135654.17:decode_interrupthook
     def decode_interrupthook(self):
         "interrupt awakened thread"
         global quitting
         quitting = True
-        thread.interrupt_main()
+        _thread.interrupt_main()
     #@-node:ekr.20060516135654.17:decode_interrupthook
     #@-others
 #@nonl
@@ -344,7 +344,7 @@
     
         try:
             self.usr_exc_info = None
-            exec code in self.locals
+            exec(code, self.locals)
         except:
             self.usr_exc_info = sys.exc_info()
             if quitting:
@@ -360,7 +360,7 @@
     #@+node:ekr.20060516135654.21:interrupt_the_server
     def interrupt_the_server(self):
         
-        thread.interrupt_main()
+        _thread.interrupt_main()
     
     #@-node:ekr.20060516135654.21:interrupt_the_server
     #@+node:ekr.20060516135654.22:leo_run.Executive.start_the_debugger
    </t>
<t tx="ekr.20091203165343.6149">@@ -5,9 +5,9 @@
 
 #@&lt;&lt; imports &gt;&gt;
 #@+node:ekr.20060517102458:&lt;&lt; imports &gt;&gt;
-import leoGlobals as g
-
-import leo_RemoteDebugger
+from . import leoGlobals as g
+
+from . import leo_RemoteDebugger
 
 from code import InteractiveInterpreter
 
@@ -100,7 +100,7 @@
                 self.rpcclt = MyRPCClient(addr)
                 g.trace(self.rpcclt)
                 break
-            except socket.error, err:
+            except socket.error as err:
                 pass
         else:
             self.display_port_binding_error()
@@ -109,7 +109,7 @@
         self.rpcclt.listening_sock.settimeout(10)
         try:
             self.rpcclt.accept()
-        except socket.timeout, err:
+        except socket.timeout as err:
             self.display_no_subprocess_error()
             return None
         self.rpcclt.register("stdin", self.tkconsole)
@@ -144,7 +144,7 @@
         self.spawn_subprocess()
         try:
             self.rpcclt.accept()
-        except socket.timeout, err:
+        except socket.timeout as err:
             self.display_no_subprocess_error()
             return None
         self.transfer_path()
@@ -328,7 +328,7 @@
         self.more = 0
         self.save_warnings_filters = warnings.filters[:]
         warnings.filterwarnings(action="error", category=SyntaxWarning)
-        if isinstance(source, types.UnicodeType):
+        if isinstance(source, str):
             import IOBinding
             try:
                 source = source.encode(IOBinding.encoding)
@@ -424,7 +424,7 @@
     #@+node:ekr.20060516135654.121:checklinecache
     def checklinecache(self):
         c = linecache.cache
-        for key in c.keys():
+        for key in list(c.keys()):
             if key[:1] + key[-1:] != "&lt;&gt;":
                 del c[key]
     #@-node:ekr.20060516135654.121:checklinecache
@@ -438,7 +438,7 @@
         if self.rpcclt:
             self.rpcclt.remotequeue("exec", "runcode", (code,), {})
         else:
-            exec code in self.locals
+            exec(code, self.locals)
         return 1
     #@-node:ekr.20060516135654.122:runcommand
     #@+node:ekr.20060516135654.123:runcode
@@ -460,7 +460,7 @@
                 elif debugger:
                     debugger.run(code, self.locals)
                 else:
-                    exec code in self.locals
+                    exec(code, self.locals)
             except SystemExit:
                 if tkMessageBox.askyesno(
                     "Exit?",
</t>
<t tx="ekr.20091203165343.6150">@@ -30,7 +30,7 @@
 #@@language python
 #@@tabwidth -4
 
-import leo_Debugger
+from . import leo_Debugger
 
 # This probably can not access Leo directly.
 
@@ -216,7 +216,7 @@
     #@+node:ekr.20060516135654.55:dict_keys
     def dict_keys(self, did):
         dict = dicttable[did]
-        return dict.keys()
+        return list(dict.keys())
     #@-node:ekr.20060516135654.55:dict_keys
     #@+node:ekr.20060516135654.56:dict_item
     def dict_item(self, did, key):
@@ -266,7 +266,7 @@
     #@+node:ekr.20060516135654.61:__getattr__
     def __getattr__(self, name):
         if name[:1] == "_":
-            raise AttributeError, name
+            raise AttributeError(name)
         if name == "f_code":
             return self._get_f_code()
         if name == "f_globals":
@@ -295,7 +295,7 @@
     #@-node:ekr.20060516135654.64:_get_f_locals
     #@+node:ekr.20060516135654.65:_get_dict_proxy
     def _get_dict_proxy(self, did):
-        if self._dictcache.has_key(did):
+        if did in self._dictcache:
             return self._dictcache[did]
         dp = DictProxy(self._conn, self._oid, did)
         self._dictcache[did] = dp
@@ -346,7 +346,7 @@
     #@+node:ekr.20060516135654.73:__getattr__
     def __getattr__(self, name):
         ##print &gt;&gt;sys.__stderr__, "failed DictProxy.__getattr__:", name
-        raise AttributeError, name
+        raise AttributeError(name)
     #@-node:ekr.20060516135654.73:__getattr__
     #@-others
 #@-node:ekr.20060516135654.69:class DictProxy
 </t>
<t tx="ville.20090606131405.6362">def writeCachedTree(self, p, cachefile):

    trace = False and not g.unitTesting
    c = self.c

    if not g.enableDB:
        if trace: g.trace('cache disabled')
    elif cachefile in c.db:
        if trace: g.trace('already cached')
    else:
        if trace: g.trace('caching ',p.h)
        #tree = g.tree_at_position(p)
        #c.db[cachefile] = tree
        c.db[cachefile] = p.makeCacheList()</t>
<t tx="ville.20090606150238.6351">def _contentHashFile(self, p, content):
    c = self.c
    m = hashlib.md5()
    # note that we also consider the headline in hash, to separate @auto foo.py from @thin foo.py
    if g.isPython3:
        m.update(g.toEncodedString(p.h,encoding='utf-8'))
        m.update(g.toEncodedString(content,encoding='utf-8'))
    else:
        m.update(p.h)
        m.update(content)
    return "fcache/" + m.hexdigest()




</t>
<t tx="ville.20090620122043.6275">def setGlobalDb(self):
    """ Create global pickleshare db

    Usable by::

        g.app.db['hello'] = [1,2,5]

    """

    trace = True
    if trace: g.trace('g.enableDB',g.enableDB)

    if g.enableDB:
        dbdirname = self.homeLeoDir + "/db/global"
        self.db = leo.external.pickleshare.PickleShareDB(dbdirname, protocol='picklez')
        if trace: g.trace(self.db,dbdirname)
    else:
        self.db = {}
</t>
</tnodes>
</leo_file>
