<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20101218103123.12443"><vh>@button load-all</vh></v>
<v t="ekr.20090620052003.8505"><vh>@@button add-test</vh></v>
<v t="ekr.20100210214809.5767"><vh>@@button compare old/new</vh></v>
<v t="ekr.20090514093345.6054"><vh>Disabled buttons</vh>
<v t="ekr.20100205152016.14055"><vh>@@button find-node-by-gnx</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20100205162207.5844"><vh>@@button print gnx</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
</v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20100223133351.5996"><vh>@@button clean all blank lines</vh></v>
<v t="ekr.20100223133351.5999"><vh>@@button find long line</vh></v>
<v t="ekr.20100225053729.5761"><vh>@@button strip diff</vh></v>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20100407063358.5748"><vh>inspect modules</vh></v>
<v t="ekr.20100515063611.5801"><vh>max N</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20100902154544.5872"><vh>@bool enable-abbreviations = True</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"
expanded="ekr.20110604043410.16737,"><vh>@file ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@file ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20110527182640.18358"><vh>b3</vh>
<v t="ekr.20110605065044.17008"><vh>Fix chapters problems</vh></v>
<v t="ekr.20110605121601.17012"><vh>On Mac: change qttabs to qt</vh></v>
<v t="ekr.20110604043410.17850"><vh>topics to discuss</vh></v>
<v t="ekr.20110604182206.16760"><vh>alt-ctrl-keys abort the find command!</vh></v>
<v t="ekr.20110604182206.16757"><vh>regex word-only does not work</vh></v>
<v t="ekr.20110526083709.18337"><vh>Simplify Key handling</vh>
<v t="ekr.20110604182206.16758"><vh>Simplifications possible</vh></v>
<v t="ekr.20110604182206.16753"><vh>Notes</vh></v>
<v t="ekr.20110604182206.16752"><vh>Posting</vh></v>
<v t="ekr.20110527182640.18357"><vh>Add KeyStroke class</vh></v>
<v t="ekr.20070123143428"><vh>k.defineTkNames</vh></v>
<v t="ekr.20110604182206.16755"><vh>Found: \.masterKeyHandler</vh>
<v t="ekr.20050920084036.206"><vh>endKbdMacro</vh></v>
<v t="ekr.20050920084036.203"><vh>executeMacro</vh></v>
<v t="ekr.20050920084036.197"><vh>loadMacros</vh></v>
<v t="ekr.20050920084036.204"><vh>startKbdMacro</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20061031131434.97"><vh>k.completeAllBindings</vh></v>
<v t="ekr.20061031131434.103"><vh>k.makeMasterGuiBinding</vh></v>
<v t="ekr.20061031131434.105"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20061031131434.106"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20061031131434.107"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20061031131434.109"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20061031131434.110"><vh>k.handleDefaultChar</vh></v>
</v>
<v t="ekr.20061031131434.155"><vh>masterMenuHandler</vh></v>
<v t="ekr.20070228074312.2"><vh>onChar (baseTextWidget)</vh></v>
<v t="ekr.20070228074312.15"><vh>event_generate (baseTextWidget)</vh></v>
</v>
<v t="ekr.20110604043410.16735"><vh>Use ascii characters instead of Tk names</vh>
<v t="ekr.20110604043410.16737"><vh>Should not change</vh>
<v t="ekr.20070123143428"></v>
<v t="ekr.20110604182206.16765"><vh>Found: tkNamesList</vh>
<v t="ekr.20070123143428"></v>
<v t="ekr.20070123085931"><vh>k.defineSpecialKeys</vh></v>
</v>
</v>
<v t="ekr.20110604182206.16763"><vh>Found: ['"]backspace['"]</vh>
<v t="ekr.20050920084036.27"><vh>expandAbbrev</vh></v>
<v t="ekr.20050920084036.83"><vh>viewLossage</vh></v>
<v t="ekr.20090204084607.2"><vh>iSearch</vh></v>
<v t="ekr.20050920084036.264"></v>
<v t="ekr.20061031131434.11"><vh>auto_completer_state_handler</vh></v>
<v t="ekr.20070123143428"></v>
<v t="ekr.20061031131434.110"></v>
<v t="ekr.20061031131434.111"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20061031131434.112"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20061031131434.128"><vh>getArg</vh>
<v t="ekr.20061031131434.129"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.152"><vh>handleMiniBindings</vh></v>
<v t="ekr.20061031131434.168"><vh>getFileName &amp; helpers</vh>
<v t="ekr.20061031131434.169"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.170"><vh>k.doFileNameBackSpace</vh></v>
<v t="ekr.20061031131434.171"><vh>k.doFileNameChar</vh></v>
<v t="ekr.20061031131434.172"><vh>k.doFileNameTab</vh></v>
<v t="ekr.20061031131434.173"><vh>k.computeFileNameCompletionList</vh></v>
<v t="ekr.20061031131434.174"><vh>k.showFileNameTabList</vh></v>
</v>
</v>
<v t="ekr.20110604182206.16761"><vh>Found: ['"]linefeed['"]</vh>
<v t="ekr.20070123143428"></v>
</v>
<v t="ekr.20110604043410.16736"><vh>Found: ['"]return['"]</vh>
<v t="ekr.20050920084036.211"><vh>getUserResponse</vh></v>
<v t="ekr.20050920084036.27"></v>
<v t="ekr.20050920084036.64"><vh>escEvaluate (Revise)</vh></v>
<v t="ekr.20061103114242"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20050920084036.83"></v>
<v t="ekr.20050920084036.264"></v>
<v t="ekr.20080531075119.6"><vh>tracer</vh></v>
<v t="ekr.20061031131434.11"></v>
<v t="ekr.20061031131434.110"></v>
<v t="ekr.20061031131434.111"></v>
<v t="ekr.20061031131434.122"><vh>repeatComplexCommand &amp; helper</vh></v>
<v t="ekr.20061031131434.128"></v>
<v t="ekr.20061031131434.152"></v>
<v t="ekr.20061031131434.168"></v>
</v>
<v t="ekr.20110604182206.16762"><vh>Found: ['"]tab['"]</vh>
<v t="ekr.20050920084036.27"></v>
<v t="ekr.20061103114242"></v>
<v t="ekr.20050920084036.83"></v>
<v t="ekr.20061031131434.11"></v>
<v t="ekr.20070123143428"></v>
<v t="ekr.20061031131434.110"></v>
<v t="ekr.20061031131434.111"></v>
<v t="ekr.20061031131434.128"></v>
<v t="ekr.20061031131434.152"></v>
<v t="ekr.20061031131434.168"></v>
<v t="ekr.20061031131434.182"><vh>isPlainKey</vh></v>
</v>
<v t="ekr.20110604182206.16764"><vh>Found: defineTkNames</vh>
<v t="ekr.20070123143428"></v>
<v t="ekr.20061031131434.76"><vh> ctor (keyHandler)</vh>
<v t="ekr.20061031131434.78"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.79"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20110604182206.16768"><vh>Found: \.getArg</vh>
<v t="ekr.20050920084036.215"><vh>stateHandler</vh></v>
<v t="ekr.20061031131434.128"></v>
<v t="ekr.20061031131434.152"></v>
<v t="ekr.20061031131434.168"></v>
<v t="ekr.20070317085437.50"><vh>cc.cloneNodeToChapter &amp; helper</vh>
<v t="ekr.20070604155815.1"><vh>cc.cloneToChapterHelper</vh></v>
</v>
<v t="ekr.20070608072116"><vh>cc.convertNodeToChapter</vh></v>
<v t="ekr.20070317085437.51"><vh>cc.copyNodeToChapter &amp; helper</vh>
<v t="ekr.20070604155815.2"><vh>cc.copyNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070317085437.31"><vh>cc.createChapter</vh></v>
<v t="ekr.20070607092909"><vh>cc.createChapterFromNode</vh></v>
<v t="ekr.20070604155815.3"><vh>cc.moveNodeToChapter &amp; helper</vh>
<v t="ekr.20070317085437.52"><vh>cc.moveNodeToChapterHelper (works)</vh></v>
</v>
<v t="ekr.20070317085437.41"><vh>cc.renameChapter</vh></v>
<v t="ekr.20070604165126"><vh>cc.selectChapter</vh></v>
<v t="ekr.20070605110441"><vh>dynamicExpandHelper (added event arg)</vh></v>
<v t="ekr.20050920084036.25"><vh>addAbbreviation</vh></v>
<v t="ekr.20051004080550"><vh>addInverseAbbreviation</vh></v>
<v t="ekr.20050927093851"><vh>getBufferName (added event arg)</vh></v>
<v t="ekr.20050920084036.158"><vh>shellCommand</vh></v>
<v t="ekr.20050920084036.65"><vh>evalExpression</vh></v>
<v t="ekr.20050920084036.68"><vh>setFillColumn</vh></v>
<v t="ekr.20060417194232.1"><vh>findCharacterHelper</vh></v>
<v t="ekr.20080408060320.1"><vh>findWordHelper</vh></v>
<v t="ekr.20050929115226"><vh>gotoCharacter</vh></v>
<v t="ekr.20060417181052"><vh>gotoGlobalLine</vh></v>
<v t="ekr.20050929124234"><vh>gotoLine</vh></v>
<v t="ekr.20110530082209.18248"><vh>replaceCurrentCharacter</vh></v>
<v t="ekr.20050920084036.80"><vh>howMany</vh></v>
<v t="ekr.20050920084036.90"><vh>flushLines</vh></v>
<v t="ekr.20051002095724"><vh>keepLines</vh></v>
<v t="ekr.20110527105255.18386"><vh>setUa</vh></v>
<v t="ekr.20050920084036.164"><vh>deleteFile</vh></v>
<v t="ekr.20050920084036.168"><vh>makeDirectory</vh></v>
<v t="ekr.20050920084036.169"><vh>removeDirectory</vh></v>
<v t="ekr.20060602154458"><vh>pythonHelp</vh></v>
<v t="ekr.20050920084036.194"><vh>callNamedMacro</vh></v>
<v t="ekr.20050920084036.198"><vh>nameLastKbdMacro</vh></v>
<v t="ekr.20050920084036.232"><vh>stringRectangle</vh></v>
<v t="ekr.20070105123800"><vh>changeAll (minibufferFind)</vh></v>
<v t="ekr.20060209064140"><vh>findAll</vh></v>
<v t="ekr.20050920084036.113"><vh>replaceString</vh></v>
<v t="ekr.20060124140224.3"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060124140224.1"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060125093807"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060210173041"><vh>stateZeroHelper</vh></v>
<v t="ekr.20091230094319.6244"><vh>doMode</vh></v>
</v>
<v t="ekr.20110604182206.16766"><vh>Found: keysym</vh>
<v t="ekr.20050920084036.211"></v>
<v t="ekr.20061031131434.105"></v>
<v t="ekr.20061031131434.155"></v>
<v t="ekr.20070228074312.2"></v>
<v t="ekr.20070228074312.15"></v>
<v t="ekr.20051106040126"><vh>c.executeMinibufferCommand</vh></v>
<v t="ekr.20060923202156"><vh>c.onCanvasKey</vh>
<v t="ekr.20061002095711.1"><vh>c.navQuickKey</vh></v>
<v t="ekr.20061002095711"><vh>c.navHelper</vh></v>
</v>
<v t="ekr.20050920084036.250"><vh>_checkIfRectangle</vh></v>
<v t="ekr.20050920084036.63"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20050920084036.64"></v>
<v t="ekr.20051125080855"><vh>selfInsertCommand, helpers</vh>
<v t="ekr.20061103114242"></v>
<v t="ekr.20090213065933.14"><vh>doPlainTab</vh></v>
<v t="ekr.20060627091557"><vh>flashCharacter</vh></v>
<v t="ekr.20060627083506"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20060804095512"><vh>initBracketMatcher</vh></v>
<v t="ekr.20051026171121"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20051026171121.1"><vh>updateAutoIndent (leoEditCommands)</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20050920084036.238"><vh>appendToRegister</vh></v>
<v t="ekr.20050920084036.237"><vh>prependToRegister</vh></v>
<v t="ekr.20050920084036.239"><vh>copyRectangleToRegister</vh></v>
<v t="ekr.20050920084036.240"><vh>copyToRegister</vh></v>
<v t="ekr.20050920084036.241"><vh>incrementRegister</vh></v>
<v t="ekr.20050920084036.242"><vh>insertRegister</vh></v>
<v t="ekr.20050920084036.243"><vh>jumpToRegister</vh></v>
<v t="ekr.20050920084036.244"><vh>numberToRegister (not used)</vh></v>
<v t="ekr.20050920084036.245"><vh>pointToRegister</vh></v>
<v t="ekr.20050920084036.246"><vh>viewRegister</vh></v>
<v t="ekr.20090204084607.2"></v>
<v t="ekr.20061031131434.11"></v>
<v t="ekr.20061031131434.39"><vh>insert_general_char</vh></v>
<v t="ekr.20061031131434.111"></v>
<v t="ekr.20061031131434.118"><vh>numberCommand</vh></v>
<v t="ekr.20061031131434.122"></v>
<v t="ekr.20061031131434.127"><vh>simulateCommand</vh></v>
<v t="ekr.20061031131434.128"></v>
<v t="ekr.20061031131434.146"><vh>masterKeyHandler &amp; helpers</vh>
<v t="ekr.20061031131434.147"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.108"><vh>callStateFunction</vh></v>
<v t="ekr.20091230094319.6244"></v>
<v t="ekr.20091230094319.6240"><vh>getPaneBinding</vh></v>
<v t="ekr.20061031131434.152"></v>
<v t="ekr.20110209083917.16004"><vh>isAutoCompleteChar</vh></v>
<v t="ekr.20080510095819.1"><vh>k.handleUnboundKeys</vh></v>
</v>
<v t="ekr.20061031170011.12"><vh>updateLabel</vh></v>
<v t="ekr.20061031131434.168"></v>
<v t="ekr.20061031131434.200"><vh>k.universalDispatcher &amp; helpers</vh>
<v t="ekr.20061031131434.201"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20061031131434.202"><vh>executeNTimes</vh></v>
<v t="ekr.20061031131434.203"><vh>doControlU</vh></v>
</v>
<v t="ekr.20061031132907"><vh>Events (leoGui)</vh></v>
<v t="ekr.20070228160107"><vh>class leoKeyEvent (leoGui)</vh></v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
</v>
<v t="ekr.20110605040658.17004"><vh>Found: event_generate</vh>
<v t="ekr.20070228074312.15"></v>
<v t="ekr.20061031131434.118"></v>
<v t="ekr.20061031131434.126"><vh>manufactureKeyPressForCommandName</vh></v>
<v t="ekr.20061031131434.202"></v>
<v t="ekr.20061031132907"></v>
</v>
<v t="ekr.20110605065044.17009"><vh>Removing leoGui.leoKeyEvent</vh>
<v t="ekr.20070228160107"></v>
<v t="ekr.20061031131434.146"></v>
</v>
<v t="ekr.20110605040658.17005"><vh>c.check_event</vh></v>
<v t="ekr.20110605121601.17013"><vh>Replace all dummy (g.bunch) events</vh></v>
</v>
<v t="ekr.20110527084258.18378"><vh>New file format</vh>
<v t="ekr.20110427135155.14306"><vh>Add &lt;attr&gt; elements to .leo files</vh></v>
<v t="ekr.20110414065052.6100"><vh>* Treat gnx's as strings: don't parse them</vh></v>
<v t="ekr.20101123131018.5842"><vh>* Don't save expansion bits in uA if not saving expansion bits</vh></v>
<v t="ekr.20110421132230.6107"><vh>File format, v3 draft 4</vh></v>
<v t="ekr.20110419083918.6104"><vh>File format, v3 graphml</vh></v>
<v t="ekr.20110415173840.6098"><vh>new uA's</vh>
<v t="ekr.20040701065235.2"><vh>putDescendentAttributes</vh></v>
<v t="ekr.20080805071954.2"><vh>putDescendentVnodeUas</vh></v>
<v t="EKR.20040526202501"><vh>putUnknownAttributes</vh></v>
<v t="ekr.20090130114732.6"><vh>v.u Property</vh></v>
</v>
<v t="ekr.20110414164347.6082"><vh>Reference for json stuff</vh>
<v t="ekr.20031218072017.1997"><vh>scanGnx</vh></v>
<v t="ekr.20060919104530"><vh>Sax (reading)</vh>
<v t="ekr.20090525144314.6526"><vh>cleanSaxInputString</vh></v>
<v t="ekr.20060919110638.5"><vh>fc.createSaxChildren &amp; helpers</vh>
<v t="ekr.20060919110638.7"><vh>fc.createSaxVnode &amp; helpers</vh>
<v t="ekr.20060919110638.8"><vh>handleTnodeSaxAttributes</vh></v>
<v t="ekr.20061004053644"><vh>handleVnodeSaxAttributes</vh></v>
</v>
</v>
<v t="ekr.20060919110638.2"><vh>dumpSaxTree</vh></v>
<v t="ekr.20061003093021"><vh>getSaxUa</vh></v>
<v t="ekr.20060919110638.14"><vh>parse_leo_file</vh></v>
<v t="ekr.20060919110638.3"><vh>readSaxFile</vh></v>
<v t="ekr.20060919110638.11"><vh>resolveTnodeLists</vh></v>
<v t="ekr.20080805132422.3"><vh>resolveArchivedPosition  (New in Leo 4.5)</vh></v>
<v t="ekr.20060919110638.13"><vh>setPositionsFromVnodes &amp; helper (sax read)</vh>
<v t="ekr.20061006104837.1"><vh>archivedPositionToPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20090218115025.3"><vh>Why are attributes pickled by default?</vh></v>
</v>
<v t="ekr.20110524141405.18370"><vh>Get macros working well</vh>
<v t="ekr.20110528034751.18278"><vh>Add apropos-macros</vh></v>
<v t="ekr.20060628103226.2"><vh>Alt-x handlers should add to lossage</vh></v>
</v>
<v t="ekr.20110604043410.16734"><vh>Regularize command names</vh></v>
<v t="ekr.20090601083544.6051"><vh>Add expand_noweb_references for rst3 plugin</vh>
<v t="ekr.20090601083544.6052"><vh>post</vh></v>
</v>
<v t="ekr.20040329094003"><vh>Apply patch command</vh>
<v t="ekr.20110604043410.17848"><vh>Script</vh></v>
<v t="ekr.20110604043410.17824"><vh>patch-11.01.py (study only)</vh>
<v t="ekr.20110604043410.17843"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20110604043410.17844"><vh>&lt;&lt; global data &gt;&gt;</vh></v>
<v t="ekr.20110604043410.17845"><vh>top-level</vh>
<v t="ekr.20110604043410.17826"><vh>fromfile</vh></v>
<v t="ekr.20110604043410.17827"><vh>fromstring</vh></v>
<v t="ekr.20110604043410.17828"><vh>fromurl</vh></v>
</v>
<v t="ekr.20110604043410.17829"><vh>class Hunk</vh>
<v t="ekr.20110604043410.17830"><vh>__init__</vh></v>
<v t="ekr.20110604043410.17831"><vh>copy</vh></v>
<v t="ekr.20110604043410.17847"><vh>apply</vh></v>
</v>
<v t="ekr.20110604043410.17832"><vh>class Patch</vh>
<v t="ekr.20110604043410.17833"><vh>__init__</vh></v>
<v t="ekr.20110604043410.17834"><vh>copy</vh></v>
<v t="ekr.20110604043410.17835"><vh>parse &amp; helper class</vh>
<v t="ekr.20110604043410.17846"><vh>class wrapumerate</vh></v>
</v>
<v t="ekr.20110604043410.17836"><vh>apply</vh></v>
<v t="ekr.20110604043410.17837"><vh>can_patch</vh></v>
<v t="ekr.20110604043410.17838"><vh>_match_file_hunks</vh></v>
<v t="ekr.20110604043410.17839"><vh>patch_stream</vh></v>
<v t="ekr.20110604043410.17840"><vh>write_hunks</vh></v>
<v t="ekr.20110604043410.17841"><vh>_get_file_idx</vh></v>
</v>
<v t="ekr.20110604043410.17842"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20110527084258.18377"><vh>Ashland sprint: 2</vh>
<v t="ekr.20110527084258.18374"><vh> Summary of the Ashland sprint</vh>
<v t="ekr.20110528034751.18270"><vh>Notes</vh></v>
</v>
<v t="ekr.20110528034751.18273"><vh>Global search in Nav plugin?</vh></v>
<v t="ekr.20110528034751.18272"><vh>Support for tabifying Leo's core panes</vh></v>
</v>
<v t="ekr.20110531190516.19365"><vh>Minor/Maybe: 4</vh>
<v t="ekr.20100112051224.6226"><vh>Vim-related: Range prefix to commands/objects (k.getArgs)</vh>
<v t="ekr.20110601105631.19373"><vh>Simple vim bindings</vh>
<v t="ekr.20110601105631.19374"><vh>Cursors</vh></v>
<v t="ekr.20110601105631.19375"><vh>Enter insert mode after ctrl-h</vh></v>
<v t="ekr.20110601105631.19376"><vh>Colorize headline text depending on state</vh></v>
<v t="ekr.20110601105631.19377"><vh>colon destroys alt-x binding</vh></v>
</v>
</v>
<v t="ekr.20110530063322.18333"><vh>scala not colored properly</vh></v>
<v t="ekr.20110518103946.18179"><vh>Add external/leosax.py to leoPyRef.leo</vh></v>
<v t="ekr.20090801103907.6018"><vh>Add entries to global dicts for more languages (waiting for requests)</vh>
<v t="ekr.20110528103005.18323"><vh>Found: extension_dict</vh>
<v t="ekr.20080819075811.13"><vh>adjustTargetLanguage</vh></v>
<v t="ekr.20090212054250.9"><vh>c.createNodeFromExternalFile</vh></v>
<v t="ekr.20031218072017.2824"><vh>c.getOpenWithExt</vh></v>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20080811174246.1"><vh>languageForExtension</vh></v>
</v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; (leoApp.py)</vh></v>
<v t="ekr.20110528103005.18319"><vh>Script to global data structures from in modes/*.py files</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20100120092047.6087"><vh>@file ../external/ipy_leo.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py </vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@file leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31332e3071017d71025808000000616e6e6f7461746571037d710473732e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20110605121601.17863"><vh>@file ../plugins/baseNativeTree.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qtframecommands.py</vh></v>
<v t="ekr.20110605121601.18002"
expanded="ekr.20110605121601.18474,ekr.20110605121601.18475,"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20110605121601.18695"><vh>QDesigner files</vh>
<v t="ekr.20110605121601.18696"><vh>@auto ../test/qtui_generate.py</vh></v>
<v t="ekr.20110605121601.18698"><vh>@auto qt_main.py</vh></v>
<v t="ekr.20110605121601.18703"><vh>@auto qt_main.ui</vh></v>
<v t="ekr.20110605121601.18704"><vh>@auto qt_quicksearch.py</vh></v>
<v t="ekr.20110605121601.18709"><vh>@auto qt_quicksearch.ui</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@file leoTest.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040504150046.4">def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; import leo.core.leoGlobals as g
    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', '', '')

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    ('', '&lt;!--', '--&gt;')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
</t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040526202501">def putUnknownAttributes (self,torv):

    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""

    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return ''
    else:
        val = ''.join([self.putUaHelper(torv,key,val) for key,val in attrDict.items()])
        # g.trace(torv,attrDict)
        return val
</t>
<t tx="ekr.20031218072017.1997">def scanGnx (self,s,i):

    """Create a gnx from its string representation"""

    if not g.isString(s):
        g.es("scanGnx: unexpected index type:",type(s),'',s,color="red")
        return None,None,None

    s = s.strip()

    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass

    return theId,t,n
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 70

@ 
This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a vnode
z:  a local temp.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2604">

</t>
<t tx="ekr.20031218072017.2824">def getOpenWithExt (self,p,ext):

    trace = False and not g.app.unitTesting
    c = self

    if not ext:
        # if node is part of @&lt;file&gt; tree, get ext from file name
        for p2 in p.self_and_parents():
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None,1)[1]
                ext = g.os_path_splitext(fn)[1]
                if trace: g.trace('found node:',ext,p2.h)
                break

    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
        if trace: g.trace('found directive',language,ext)

    if not ext:
        ext = '.txt'
        if trace: g.trace('use default (.txt)')

    if ext[0] != '.':
        ext = '.'+ext

    return ext
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.368"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM_", # Use the REM hack.
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @&gt;", # Use the "cweb hack"
    "cython"        : "#",
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "haskell"       : "--_ {-_ _-}",
    "haxe"          : "//",
    "html"          : "&lt;!-- --&gt;",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lisp"          : ";", # EKR: 2010/09/29
    "lua"           : "--",  # ddm 13/02/06
    "nsi"           : ";", # EKR: 2010/10/27
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "rest"          : ".._",
    "rst"           : ".._",
    "ruby"          : "#",  # thyrsus 2008-11-05
    "scala"         : "// /* */",
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--',
        # For unknown extensions in @shadow files.
    "vim"           : "\"",
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "&lt;!-- --&gt;",
    "xslt"          : "&lt;!-- --&gt;",
}

# Used only by c.getOpenWithExt.
self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    #"cython"        : "pyd",
    #"cython"        : "pyi",
    "cython"        : "pyx", # Only one extension is valid at present.
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f90",
    "haskell"       : "hs",
    "haxe"          : "hx",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "nsi"           : "nsi", # EKR: 2010/10/27
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    # "rst"           : "rst", # caught by pylint.
    "rst"           : "rest",
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "scala"         : "scala",
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vim"           : "vim",
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran",
    "f90"   : "fortran90",
    "h"     : "c",
    "html"  : "html",
    "hs"    : "haskell",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nsi"   : "nsi", # EKR: 2010/10/27
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "pyd"   : "cython",
    "pyi"   : "cython",
    "pyx"   : "cython",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "rest"  : "rst",
    "rst"   : "rst",
    "scala" : "scala",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "vim"   : "vim",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
    "hx"    : "haxe",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran90',
    'hx'    : 'none',
    'ksh'   : 'none', # Leo 4.5.1
    'nsi'   : 'none', # Leo 4.8.
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}

self.global_commands_dict = {}
</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self,command,name,minibufferCommand):
    
    c = self.c

    if minibufferCommand:

        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',stroke='',widget='')
        c.check_event(event)

        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            c = self.c
            return c.doCommand(command,label,event)

        return minibufferMenuCallback

    else:

        # The first parameter must be event, and it must default to None.
        event = None
        def legacyMenuCallback(event=event,self=self,command=command,label=name):
            c.check_event(event)
            return c.doCommand(command,label)

        return legacyMenuCallback
</t>
<t tx="ekr.20040329094003"></t>
<t tx="ekr.20040701065235.2">def putDescendentAttributes (self,p):

    nodeIndices = g.app.nodeIndices

    # Create lists of all tnodes whose vnodes are marked or expanded.
    marks = [] ; expanded = []
    for p in p.subtree():
        v = p.v
        if p.isMarked() and p.v not in marks:
            marks.append(v)
        if p.hasChildren() and p.isExpanded() and v not in expanded:
            expanded.append(v)

    result = []
    for theList,tag in ((marks,"marks"),(expanded,"expanded")):
        if theList:
            sList = []
            for v in theList:
                sList.append("%s," % nodeIndices.toString(v.fileIndex))
            s = ''.join(sList)
            # g.trace(tag,[str(p.h) for p in theList])
            result.append('\n%s="%s"' % (tag,s))

    return ''.join(result)
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily. 

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass. 

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.
  
- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction. 
</t>
<t tx="ekr.20050920084036.113">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20050920084036.158">def shellCommand (self,event):

    '''Execute a shell command.'''

    if subprocess:
        k = self.k ; state = k.getState('shell-command')

        if state == 0:
            k.setLabelBlue('shell-command: ',protect=True)
            k.getArg(event,'shell-command',1,self.shellCommand)
        else:
            command = k.arg
            k.commandName = 'shell-command: %s' % command
            k.clearState()
            self.executeSubprocess(event,command)
    else:
        k.setLabelGrey('can not execute shell-command: can not import subprocess')
</t>
<t tx="ekr.20050920084036.164">def deleteFile (self,event):

    '''Prompt for the name of a file and delete it.'''

    k = self.k ; state = k.getState('delete_file')

    if state == 0:
        prefix = 'Delete File: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'delete_file',1,self.deleteFile,prefix=prefix)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.remove(k.arg)
            k.setLabel('Deleted: %s' % k.arg)
        except Exception:
            k.setLabel('Not Deleted: %s' % k.arg)
</t>
<t tx="ekr.20050920084036.168">def makeDirectory (self,event):

    '''Prompt for the name of a directory and create it.'''

    k = self.k ; state = k.getState('make_directory')

    if state == 0:
        prefix = 'Make Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'make_directory',1,self.makeDirectory,prefix=prefix)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.mkdir(k.arg)
            k.setLabel("Created: %s" % k.arg)
        except Exception:
            k.setLabel("Not Create: %s" % k.arg)
</t>
<t tx="ekr.20050920084036.169">def removeDirectory (self,event):

    '''Prompt for the name of a directory and delete it.'''

    k = self.k ; state = k.getState('remove_directory')

    if state == 0:
        prefix = 'Remove Directory: '
        k.setLabelBlue('%s%s%s' % (prefix,os.getcwd(),os.sep))
        k.getArg(event,'remove_directory',1,self.removeDirectory,prefix=prefix)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.rmdir(k.arg)
            k.setLabel('Removed: %s' % k.arg)
        except Exception:
            k.setLabel('Not Remove: %s' % k.arg)
</t>
<t tx="ekr.20050920084036.194">def callNamedMacro (self,event):

    '''Prompts for a macro name to save, then executes it.'''

    k = self.k ; tag = 'macro-name'
    state = k.getState(tag)
    prompt = 'Call macro named: '

    if state == 0:
        k.setLabelBlue(prompt,protect=True)
        k.getArg(event,tag,1,self.callNamedMacro)
    else:
        macro = self.namedMacros.get(k.arg)
        # Must do this first!
        k.clearState()
        if macro:
            self.executeMacro(macro)
        else:
            g.es('no macro named %s' % k.arg)
        k.resetLabel()

</t>
<t tx="ekr.20050920084036.197">def loadMacros (self,f):

    '''Loads a macro file into the macros dictionary.'''

    c = self.c ; w = c.frame.body.bodyCtrl
    try:
        d = pickle.load(f)
    except pickle.UnpicklingError:
        g.es('error unpickling %s' % f.name)
        return

    # g.trace(f.name,d)

    for name in d:
        aList = d.get(name)
        macro = []
        for stroke in aList:
            # Create a dummy event with just enough attribute
            # to keep k.masterKeyHandler happy
            actualEvent = g.Bunch(stroke=stroke,char=stroke,widget=w)
            event = g.app.gui.leoKeyEvent(actualEvent,c)
            macro.append(event)
        self.addToDoAltX(name,macro)
            # sets self.namedMacros[name]=macro


</t>
<t tx="ekr.20050920084036.198">def nameLastKbdMacro (self,event):

    '''Prompt for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ',protect=True)
        k.getArg(event,'name-macro',1,self.nameLastKbdMacro)
    else:
        k.clearState()
        name = k.arg
        self.addToDoAltX(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
</t>
<t tx="ekr.20050920084036.203">def executeMacro (self,macro):

    c = self.c ; k = self.k

    c.bodyWantsFocus()

    for event in macro:
        # New in Leo 4.6: macro entries are leoKeyEvents.
        g.trace(event.stroke)
        k.masterKeyHandler(event,stroke=event.stroke)
</t>
<t tx="ekr.20050920084036.204">def startKbdMacro (self,event=None):

    '''Start recording a keyboard macro.'''

    g.trace(self.recordingMacro)

    k = self.k

    if not self.recordingMacro:
        self.recordingMacro = True
            # A flag for k.masterCommandHandler &amp; k.masterKeyHandler.
        k.setLabelBlue('Recording macro. ctrl-g to end...',protect=True)
    else:
        g.trace(event)
        self.macro.append(event)
</t>
<t tx="ekr.20050920084036.206">def endKbdMacro (self,event=None):

    '''Stop recording a keyboard macro.'''

    k = self.k
    self.recordingMacro = False
        # Tell k.masterKeyHandler and masterCommandHandler we are done.

    if self.macro:
        # self.macro = self.macro [: -4]
        self.macros.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelBlue('Keyboard macro defined, not named')
    else:
        k.setLabelBlue('Empty keyboard macro')
</t>
<t tx="ekr.20050920084036.211">def getUserResponse (self,event):

    w = self.editWidget(event)
    if not w or not hasattr(event,'keysym'): return

    # g.trace(event.keysym)
    if event.keysym == 'y':
        self.doOneReplace(event)
        if not self.findNextMatch(event):
            self.quitSearch(event)
    elif event.keysym in ('q','Return'):
        self.quitSearch(event)
    elif event.keysym == '!':
        while self.findNextMatch(event):
            self.doOneReplace(event)
    elif event.keysym in ('n','Delete'):
        # Skip over the present match.
        i = w.getInsertPoint()
        w.setInsertPoint(i + len(self.qQ))
        if not self.findNextMatch(event):
            self.quitSearch(event)

    w.seeInsertPoint()
</t>
<t tx="ekr.20050920084036.215">def stateHandler (self,event):

    k = self.k ; state = k.getState('query-replace')

    prompt = g.choose(self.regexp,'Query replace regexp','Query replace')

    if state == 0: # Get the first arg.
        self.init()
        k.setLabelBlue(prompt + ': ',protect=True)
        k.getArg(event,'query-replace',1,self.stateHandler)
    elif state == 1: # Get the second arg.
        self.qQ = k.arg
        if len(k.arg) &gt; 0:
            prompt = '%s %s with: ' % (prompt,k.arg)
            k.setLabelBlue(prompt)
            k.getArg(event,'query-replace',2,self.stateHandler)
        else:
            k.resetLabel()
            k.clearState()
    elif state == 2: # Set the prompt and find the first match.
        self.qR = k.arg # Null replacement arg is ok.
        k.setLabelBlue('Query replacing %s with %s\n' % (self.qQ,self.qR) +
            'y: replace, (n or Delete): skip, !: replace all, (q or Return): quit',
            protect=True)
        k.setState('query-replace',3,self.stateHandler)
        self.findNextMatch(event)
    elif state == 3:
        self.getUserResponse(event)
</t>
<t tx="ekr.20050920084036.232">def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ',protect=True)
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        r1, r2, r3, r4 = self.stringRect
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)
        self.endCommand()
        # 2010/1/1: Fix bug 480422:
        # string-rectangle kills syntax highlighting.
        c.frame.body.recolor(c.p,incremental=False)

</t>
<t tx="ekr.20050920084036.237">def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'prepend-to-register' ; state = k.getState(tag)
    
    c.check_event(event)

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Prepend to Register: ',protect=True)
        k.setState(tag,1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                val = w.getSelectedText() + val
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.238">def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'append-to-register' ; state = k.getState(tag)
    
    c.check_event(event)

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Append to Register: ',protect=True)
        k.setState(tag,1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = event.keysym.lower()
                val = self.registers.get(key,'')
                val = val + w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.239">def copyRectangleToRegister (self,event):

    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')
    
    c.check_event(event)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ',protect=True)
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 &lt;= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.240">def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'copy-to-register' ; state = k.getState(tag)
    
    c.check_event(event)

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Copy to Register: ',protect=True)
        k.setState(tag,1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if event.keysym.isalpha():
                key = event.keysym.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                val = w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.241">def incrementRegister (self,event):

    '''Prompt for a register name and increment its value if it has a numeric value.'''

    c = self.c ; k = self.k ; state = k.getState('increment-reg')
    
    c.check_event(event)

    if state == 0:
        k.setLabelBlue('Increment register: ',protect=True)
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.242">def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')
    
    c.check_event(event)

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ',protect=True)
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.rectangleCommands.yankRectangle(val)
                else:
                    i = w.getInsertPoint()
                    w.insert(i,val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.243">def jumpToRegister (self,event):

    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')
    
    c.check_event(event)

    if state == 0:
        k.setLabelBlue('Jump to register: ',protect=True)
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            if self._checkIfRectangle(event): return
            key = event.keysym.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.setInsertPoint(val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.244">@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):

    c,k = self.c, self.k ; state = k.getState('number-to-reg')
    
    c.check_event(event)

    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ',protect=True)
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            # self.registers[event.keysym.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
</t>
<t tx="ekr.20050920084036.245">def pointToRegister (self,event):

    '''Prompt for a register name and put a value indicating the insert point in the register.'''

    c = self.c ; k = self.k ; state = k.getState('point-to-reg')
    
    c.check_event(event)

    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ',protect=True)
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = event.keysym.lower()
            val = w.getInsertPoint()
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.246">def viewRegister (self,event):

    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')
    
    

    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ',protect=True)
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if event.keysym.isalpha():
            key = event.keysym.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.25">def addAbbreviation (self,event):

    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''

    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ',protect=True)
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        value = k.argSelectedText # 2010/09/01.
        if k.arg.strip():
            self.abbrevs [k.arg] = value,'dynamic'
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviation (on): '%s' = '%s'" % (
                    k.arg,value))
</t>
<t tx="ekr.20050920084036.250">def _checkIfRectangle (self,event):

    c,k = self.c,self.k ; key = event.keysym.lower()
    
    c.check_event(event)

    val = self.registers.get(key)

    if val and type(val) == type([]):
        k.clearState()
        k.setLabelGrey("Register contains Rectangle, not text")
        return True

    return False
</t>
<t tx="ekr.20050920084036.264"># Called from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k
    stroke = event.stroke
    if trace: g.trace('stroke',repr(stroke))

    # No need to recognize ctrl-z.
    if stroke in ('Escape','Return'):
        self.endSearch()
    elif stroke in self.iSearchStrokes:
        self.iSearch(again=True)
    elif stroke == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif stroke.startswith('Ctrl+') or stroke.startswith('Alt+'):
        # End the search and execute the command.
        self.endSearch()
        k.masterKeyHandler(event,stroke=stroke)
    else:
        if trace: g.trace('event',event)
        k.updateLabel(event)
        self.iSearch()
</t>
<t tx="ekr.20050920084036.27">def expandAbbrev (self,event,stroke):

    '''Not a command.  Called from k.masterCommand to expand
    abbreviations in event.widget.

    Words start with '@'.
    '''

    trace = False and not g.unitTesting
    k = self.k ; c = self.c
    ch = event.char
    w = self.editWidget(event,forceFocus=False)
    if not w: return False
    if w.hasSelection(): return False
    if stroke=='BackSpace': return False
    d = {'Return':'\n','Tab':'\t','space':' ','underscore':'_'}
    if stroke:
        ch = d.get(stroke,stroke)
        if len(ch) &gt; 1:
            if (stroke.find('Ctrl+') &gt; -1 or
                stroke.find('Alt+') &gt; -1 or
                stroke.find('Meta+') &gt; -1
            ):
                ch = ''
            else:
                ch = event.char
    else:
        ch = event.char
        
    if trace: g.trace('event.char',repr(event.char),'ch',repr(ch),'stroke',repr(stroke))

    if len(ch) != 1 or (len(ch) == 1 and ch.isalpha()):
        # Normal chars other special chars abort abbreviations.
        return False

    # Get the text and insert point.
    s = w.getAllText()
    i = i1 = w.getInsertPoint()

    # Find the word to the left of the insert point.
    j = i ; i -= 1
    while 0 &lt;= i &lt; len(s) and g.isWordChar(s[i]):
        i -= 1
    if 0 &lt;= i &lt; len(s) and s[i] == '@':
        i -= 1
    i += 1
    word = s[i:j].strip()
    if trace: g.trace(i,j,repr(word))
    if not word: return False

    # First, look up the word without ch.
    val,tag = self.abbrevs.get(word,(None,None))
    if trace: g.trace(word,val,tag)
    
    if val:
        # Add ch to the result.
        if ch: val = val + ch
    else:
        # Look up the word with ch.
        if ch and not val:
            val,tag = self.abbrevs.get(word+ch,(None,None))
            if trace: g.trace(word+ch,val,tag)
    if val:
        if trace: g.trace('**inserting',repr(val))
        oldSel = j,j
        c.frame.body.onBodyChanged(undoType='Typing',oldSel=oldSel)
        if i != j: w.delete(i,j)
        w.insert(i,val)
        c.frame.body.onBodyChanged(undoType='Abbreviation',oldSel=oldSel)

    return val is not None
</t>
<t tx="ekr.20050920084036.63">def watchEscape (self,event):

    c,k = self.c,self.k
    
    c.check_event(event)

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = leoKeys.keyHandlerClass.lossage[0]
        data2 = leoKeys.keyHandlerClass.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and event.keysym == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit()
</t>
<t tx="ekr.20050920084036.64">def escEvaluate (self,event):
    
    c,k = self.c,self.k
    
    c.check_event(event)
    
    w = self.editWidget(event)
    if not w: return

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            i = w.getInsertPoint()
            w.insert(i,result)
            ok = True
        finally:
            k.keyboardQuit()
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)
</t>
<t tx="ekr.20050920084036.65">def evalExpression (self,event):

    '''Evaluate a Python Expression entered in the minibuffer.'''

    k = self.k ; state = k.getState('eval-expression')

    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
</t>
<t tx="ekr.20050920084036.68">def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            # Bug fix: 2011/05/23: set the fillColumn ivar!
            self.fillColumn = n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
</t>
<t tx="ekr.20050920084036.80">def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
</t>
<t tx="ekr.20050920084036.83">def viewLossage (self,event):

    '''Put the Emacs-lossage in the minibuffer label.'''

    k = self.k

    g.es('lossage...')
    aList = leoKeys.keyHandlerClass.lossage
    aList.reverse()
    for data in aList:
        ch,stroke = data
        d = {' ':'Space','\t':'Tab','\b':'Backspace','\n':'Newline','\r':'Return'}
        g.es('',stroke or d.get(ch) or ch or 'None')
</t>
<t tx="ekr.20050920084036.90">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
</t>
<t tx="ekr.20050927093851">def getBufferName (self,event,finisher):

    '''Get a buffer name into k.arg and call k.setState(kind,n,handler).'''

    c,k = self.c,self.k ; state = k.getState('getBufferName')
    
    c.check_event(event)

    if state == 0:
        self.computeData()
        self.getBufferNameFinisher = finisher
        prefix = k.getLabel()
        ### event = None
        k.getArg(event,'getBufferName',1,self.getBufferName,
            prefix=prefix,tabList=self.nameList)
    else:
        k.resetLabel()
        k.clearState()
        finisher = self.getBufferNameFinisher
        self.getBufferNameFinisher = None
        finisher(k.arg)
</t>
<t tx="ekr.20050929115226">def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n &gt;= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.es('goto-char takes non-negative integer argument',color='blue')
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20050929124234">def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20051002095724">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
</t>
<t tx="ekr.20051004080550">def addInverseAbbreviation (self,event):

    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''

    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ',protect=True)
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg,'add-inverse-abbr'
</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
</t>
<t tx="ekr.20051026171121">def insertNewlineHelper (self,w,oldSel,undoType):

    trace = False and not g.unitTesting
    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'
    if trace:
        s = w.widget.toPlainText()
        g.trace(i,j,len(s),w)

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
</t>
<t tx="ekr.20051026171121.1">def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins&lt;len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051106040126">def executeMinibufferCommand (self,commandName):

    c = self ; k = c.k

    func = c.commandsDict.get(commandName)

    if func:
        event = g.Bunch(c=c,char='',keysym='',widget=c.frame.body.bodyCtrl)
            #### Was keysym = None
        stroke = None
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.error('no such command: %s %s' % (commandName,g.callers()))
        return None
</t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    
    c,k = self.c,self.k
    c.check_event(event)
   
    verbose = True
    w = self.editWidget(event)
    if not w: return # (for Tk) 'break'
    &lt;&lt; set local vars &gt;&gt;
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return # (for Tk) "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i &gt; j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:
            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return # (for Tk) 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return # (for Tk) 'break'
</t>
<t tx="ekr.20060124140224.1">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060124140224.3">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060125093807">def searchWithPresentOptions (self,event):

    trace = False and not g.unitTesting
    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    if trace: g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        self.setupSearchPattern(k.arg) # 2010/01/10: update the find text immediately.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20060209064140">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
</t>
<t tx="ekr.20060210173041">def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
</t>
<t tx="ekr.20060417181052">def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    c = self.c
    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            c.goToLineNumber(c).go(n=int(n))
</t>
<t tx="ekr.20060417194232.1">def findCharacterHelper (self,event,backward,extend):

    '''Put the cursor at the next occurance of a character on a line.'''

    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward
        self.extend = extend or self.extendMode # Bug fix: 2010/01/19
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            g.choose(backward,'Backward find','Find'),
            g.choose(extend,' &amp; extend',''))
        k.setLabelBlue(s,protect=True)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward
        extend = self.extend or self.extendMode
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + g.choose(backward,-1,+1) # skip the present character.
        if backward:
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        else:
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.

       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others
</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()

    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")
</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.p

    # "Title" is the headline of the current node
    self.title.configure(text=cp.h)

    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)

    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().h
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)

    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)
</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060602154458">def pythonHelp (self,event=None):

    '''Prompt for a arg for Python's help function, and put it to the log pane.'''

    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)

    if state == 0:
        c.minibufferWantsFocus()
        k.setLabelBlue('Python help: ',protect=True)
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            g.redirectStderr()
            g.redirectStdout()
            try: help(str(s))
            except Exception: pass
            g.restoreStderr()
            g.restoreStdout()
</t>
<t tx="ekr.20060627083506">def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20060627091557">def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
</t>
<t tx="ekr.20060628103226.2">Probably useful as part of macro handling.
</t>
<t tx="ekr.20060804095512">def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060919104530"></t>
<t tx="ekr.20060919110638.11">def resolveTnodeLists (self):

    trace = False and not g.unitTesting
    c = self.c

    for p in c.all_unique_positions():
        if hasattr(p.v,'tempTnodeList'):
            # g.trace(p.v.headString())
            result = []
            for tnx in p.v.tempTnodeList:
                index = self.canonicalTnodeIndex(tnx)
                v = self.gnxDict.get(index)
                if v:
                    if trace: g.trace(tnx,v)
                    result.append(v)
                else:
                    g.trace('*** No vnode for %s' % tnx)
            if result:
                p.v.tnodeList = result
                # g.trace('*** tnodeList for',p.h,result)
            delattr(p.v,'tempTnodeList')
</t>
<t tx="ekr.20060919110638.13">def setPositionsFromVnodes (self):

    trace = False and not g.unitTesting
    c = self.c ; p = c.rootPosition()
    current,str_pos = None,None

    use_db = g.enableDB and c.mFileName
    if use_db:
        str_pos = c.cacher.getCachedStringPosition()

    if not str_pos:
        d = hasattr(p.v,'unknownAttributes') and p.v.unknownAttributes
        if d: str_pos = d.get('str_leo_pos')
        if trace: g.trace('from p.v.u',str_pos)

    if str_pos:
        current = self.archivedPositionToPosition(str_pos)

    c.setCurrentPosition(current or c.rootPosition())
</t>
<t tx="ekr.20060919110638.14">def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    try:
        if g.isPython3:
            if theFile:
                # Use the open binary file, opened by g.openLeoOrZipFile.
                s = theFile.read() # type(s) is bytes.
                s = self.cleanSaxInputString(s)
                theFile = BytesIO(s)
            else:
                s = str(s,encoding='utf-8')
                s = self.cleanSaxInputString(s)
                theFile = StringIO(s)
        else:
            if theFile: s = theFile.read()
            s = self.cleanSaxInputString(s)
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the &lt;?xml&gt; element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
</t>
<t tx="ekr.20060919110638.2">def dumpSaxTree (self,root,dummy):

    if not root:
        g.pr('dumpSaxTree: empty tree')
        return
    if not dummy:
        root.dump()
    for child in root.children:
        self.dumpSaxTree(child,dummy=False)
</t>
<t tx="ekr.20060919110638.3">def readSaxFile (self,theFile,fileName,silent,inClipboard,reassignIndices,s=None):

    dump = False and not g.unitTesting
    fc = self ; c = fc.c

    # Pass one: create the intermediate nodes.
    saxRoot = fc.parse_leo_file(theFile,fileName,
        silent=silent,inClipboard=inClipboard,s=s)

    if dump: fc.dumpSaxTree(saxRoot,dummy=True)

    # Pass two: create the tree of vnodes and tnodes from the intermediate nodes.
    if saxRoot:
        parent_v = c.hiddenRootNode
        children = fc.createSaxChildren(saxRoot,parent_v)
        assert c.hiddenRootNode.children == children
        v = children and children[0] or None
        return v
    else:
        return None
</t>
<t tx="ekr.20060919110638.5">def createSaxChildren (self, sax_node, parent_v):

    c = self.c
    trace = False and not g.unitTesting # and c.shortFileName().find('small') &gt; -1
    children = []

    for sax_child in sax_node.children:
        tnx = sax_child.tnx
        v = self.gnxDict.get(tnx)

        if v: # A clone.
            if trace: g.trace('**clone',v)
            v = self.createSaxVnode(sax_child,parent_v,v=v)   
        else:
            v = self.createSaxVnode(sax_child,parent_v)
            self.createSaxChildren(sax_child,v)

        children.append(v)

    parent_v.children = children
    for child in children:
        child.parents.append(parent_v)
        if trace: g.trace(
            '*** added parent',parent_v,'to',child,
            'len(child.parents)',len(child.parents))

    return children
</t>
<t tx="ekr.20060919110638.7">def createSaxVnode (self,sax_node,parent_v,v=None):

    c = self.c
    trace = False and not g.unitTesting and c.shortFileName().find('test') &gt; -1
    verbose = False
    h = sax_node.headString
    b = sax_node.bodyString

    if v:
        # The body of the later node overrides the earlier.
        # Don't set t.h: h is always empty.
        # This may be an internal error.
        if v.b == b:
            if trace and verbose: g.trace(
                '***no update\nold: %s\nnew: %s' % (v.b,b))
        else:
            if trace: g.trace(
                '***update\nold: %s\nnew: %s' % (v.b,b))
            v.b = b 
    else:
        v = leoNodes.vnode(context=c)
        v.setBodyString(b)
        v.setHeadString(h)

        if sax_node.tnx:
            v.fileIndex = g.app.nodeIndices.scanGnx(sax_node.tnx,0)

    index = self.canonicalTnodeIndex(sax_node.tnx)
    self.gnxDict [index] = v

    if trace and verbose: g.trace(
        'tnx','%-22s' % (index),'v',id(v),
        'len(body)','%-4d' % (len(b)),h)

    self.handleVnodeSaxAttributes(sax_node,v)
    self.handleTnodeSaxAttributes(sax_node,v)

    return v
</t>
<t tx="ekr.20060919110638.8">def handleTnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.tnodeAttributes
    if trace and d: g.trace(sax_node,list(d.keys()))

    aDict = {}
    for key in d:
        val = g.toUnicode(d.get(key)) # 2011/02/22
        val2 = self.getSaxUa(key,val)
        # g.trace(key,val,val2)
        aDict[key] = val2

    if aDict:
        if trace: g.trace('uA',v,list(aDict.keys()))
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20060923202156">def onCanvasKey (self,event):

    '''Navigate to the next headline starting with ch = event.char.
    If ch is uppercase, search all headlines; otherwise search only visible headlines.
    This is modelled on Windows explorer.'''

    # g.trace(event and event.char)

    if not event or not event.char or not event.keysym.isalnum():
        return
    c  = self ; p = c.p ; p1 = p.copy()
    c.check_event(event)
    invisible = c.config.getBool('invisible_outline_navigation')
    ch = event.char
    allFlag = ch.isupper() and invisible # all is a global (!?)
    if not invisible: ch = ch.lower()
    found = False
    extend = self.navQuickKey()
    attempts = g.choose(extend,(True,False),(False,))
    for extend2 in attempts:
        p = p1.copy()
        while 1:
            if allFlag:
                p.moveToThreadNext()
            else:
                p.moveToVisNext(c)
            if not p:
                p = c.rootPosition()
            if p == p1: # Never try to match the same position.
                # g.trace('failed',extend2)
                found = False ; break
            newPrefix = c.navHelper(p,ch,extend2)
            if newPrefix:
                found = True ; break
        if found: break
    if found:
        c.selectPosition(p)
        c.redraw_after_select(p)
        c.navTime = time.clock()
        c.navPrefix = newPrefix
        # g.trace('extend',extend,'extend2',extend2,'navPrefix',c.navPrefix,'p',p.h)
    else:
        c.navTime = None
        c.navPrefix = ''
    c.treeWantsFocus()
</t>
<t tx="ekr.20061002095711">def navHelper (self,p,ch,extend):

    c = self ; h = p.h.lower()

    if extend:
        prefix = c.navPrefix + ch
        return h.startswith(prefix.lower()) and prefix

    if h.startswith(ch):
        return ch

    # New feature: search for first non-blank character after @x for common x.
    if ch != '@' and h.startswith('@'):
        for s in ('button','command','file','thin','asis','nosent',):
            prefix = '@'+s
            if h.startswith('@'+s):
                while 1:
                    n = len(prefix)
                    ch2 = n &lt; len(h) and h[n] or ''
                    if ch2.isspace():
                        prefix = prefix + ch2
                    else: break
                if len(prefix) &lt; len(h) and h.startswith(prefix + ch.lower()):
                    return prefix + ch
    return ''
</t>
<t tx="ekr.20061002095711.1">def navQuickKey (self):

    '''return true if there are two quick outline navigation keys
    in quick succession.

    Returns False if @float outline_nav_extend_delay setting is 0.0 or unspecified.'''

    c = self

    deltaTime = c.config.getFloat('outline_nav_extend_delay')

    if deltaTime in (None,0.0):
        return False
    else:
        nearTime = c.navTime and time.clock() - c.navTime &lt; deltaTime
        return nearTime
</t>
<t tx="ekr.20061003093021">def getSaxUa(self,attr,val,kind=None): # Kind is for unit testing.

    """Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element.
    The unknown tag has been pickled and hexlify'd.
    """

    try:
        # val = str(val)
        val = g.toEncodedString(val) # 2011/02/22.
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None

    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if type(val) == type(''):
            return val
        elif type(val) == type(b''):
            # 2011/05/26.
            return g.toUnicode(val)

    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass

    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw','unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr,val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return val2
    except (pickle.UnpicklingError,ImportError,AttributeError,ValueError):
        g.trace('can not unpickle %s=%s' % (attr,val))
        return val
</t>
<t tx="ekr.20061004053644"># The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnodeUnknownAttributes.
# New in Leo 4.5: added descendentVnodeUnknownAttributes to native attributes.

def handleVnodeSaxAttributes (self,sax_node,v):

    trace = False and not g.unitTesting
    d = sax_node.attributes

    s = d.get('a')
    if s:
        if trace and 'E' in s: g.trace('expand',v)
        # g.trace('%s a=%s %s' % (id(sax_node),s,v.headString()))
        # 'C' (clone) and 'D' bits are not used.
        if 'M' in s: v.setMarked()
        if 'E' in s: v.expand()
        if 'O' in s: v.setOrphan()
        # if 'T' in s: self.topVnode = v
        if 'V' in s:
            # g.trace('setting currentVnode',v,color='red')
            self.currentVnode = v

    s = d.get('tnodeList','')
    tnodeList = s and s.split(',')
    if tnodeList:
        # This tnodeList will be resolved later.
        if trace: g.trace('found tnodeList',v.headString(),tnodeList)
        v.tempTnodeList = tnodeList

    s = d.get('descendentTnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentTnodeUaDictList',aDict)
            self.descendentTnodeUaDictList.append(aDict)

    s = d.get('descendentVnodeUnknownAttributes')
    if s: 
        aDict = self.getDescendentUnknownAttributes(s,v=v)
        if aDict:
            # g.trace('descendentVnodeUaDictList',aDict)
            self.descendentVnodeUaDictList.append((v,aDict),)

    s = d.get('expanded')
    if s:
        aList = self.getDescendentAttributes(s,tag="expanded")
        # g.trace('expanded list',len(aList))
        self.descendentExpandedList.extend(aList)

    s = d.get('marks')
    if s:
        aList = self.getDescendentAttributes(s,tag="marks")
        # g.trace('marks list',len(aList))
        self.descendentMarksList.extend(aList)

    aDict = {}
    for key in d:
        if key in self.nativeVnodeAttributes:
            # This is not a bug.
            if False and trace: g.trace(
                '****ignoring***',key,d.get(key))
        else:
            val = d.get(key)
            val2 = self.getSaxUa(key,val)
            aDict[key] = val2
            # g.trace(key,val,val2)
    if aDict:
        # if trace: g.trace('uA',v,aDict)
        v.unknownAttributes = aDict
</t>
<t tx="ekr.20061006104837.1">def archivedPositionToPosition (self,s):

    c = self.c
    s = g.toUnicode(s) # 2011/02/25
    aList = s.split(',')
    try:
        aList = [int(z) for z in aList]
    except Exception:
        # g.trace('oops: bad archived position. not an int:',aList,c)
        aList = None
    if not aList: return None
    p = c.rootPosition() ; level = 0
    while level &lt; len(aList):
        i = aList[level]
        while i &gt; 0:
            if p.hasNext():
                p.moveToNext()
                i -= 1
            else:
                # g.trace('oops: bad archived position. no sibling:',aList,p.h,c)
                return None
        level += 1
        if level &lt; len(aList):
            p.moveToFirstChild()
            # g.trace('level',level,'index',aList[level],p.h)
    return p
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    trace = True and not g.unitTesting
    k = self ; c = k.c ; f = c.frame

    bindStroke = k.tkbindingFromStroke(stroke)

    if stroke.lower().startswith('key'):
        g.trace('stroke',repr(stroke),'bindStroke',repr(bindStroke),g.callers(5))

    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        if 0: # Canvas and bindingWidget bindings are now set in tree.setBindings.
            widgets = (c.miniBufferWidget,bodyCtrl)
        else:
            widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    # This is the only real key callback.
    def masterBindKeyCallback (event,k=k,stroke=stroke):
        # g.trace(stroke,event.w)
        return k.masterKeyHandler(event,stroke=stroke)

    if 0:
        if stroke.lower().endswith('+s') or stroke.lower().endswith('-s'):
            g.trace(sroke,widgets)
        if stroke in ('s','S'):
            g.trace(stroke,widgets)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(bindStroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [bindStroke] = aList
            try:
                c.bind(w,bindStroke,masterBindKeyCallback)
                # g.trace(stroke,bindStroke,g.app.gui.widget_name(w))
            except Exception:
                if self.trace_bind_key_exceptions:
                    g.es_exception()
                g.es_print('exception binding',bindStroke,'to',c.widget_name(w),color='blue')

                if g.app.unitTesting: raise
</t>
<t tx="ekr.20061031131434.105">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    
    c.check_event(event)

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return # (for Tk) 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return # (for Tk) 'break'

    if special: # Don't pass these on.
        return # (for Tk) 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return # (for Tk) 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return # (for Tk) 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return # (for Tk) 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return # (for Tk) 'break'
    elif k.inState():
        return # (for Tk) 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
</t>
<t tx="ekr.20061031131434.106">specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
</t>
<t tx="ekr.20061031131434.107">if stroke or len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20061031131434.108">def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) &lt; 32 or ord(ch) &gt; 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
</t>
<t tx="ekr.20061031131434.109">def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(commandName)

    return func
</t>
<t tx="ekr.20061031131434.11">def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    
    c.check_event(event)
    
    ch = gui.eventChar(event)
    keysym = gui.eventKeysym(event)
    stroke = gui.eventStroke(event)
    is_plain = k.isPlainKey(stroke)

    if trace: g.trace('state: %s, ch: %s, keysym: %s, stroke: %s' % (
        state,repr(ch),repr(keysym),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif keysym == 'Return':
        self.exit()
    elif keysym == 'Escape':
        self.exit()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym in ('\b','BackSpace'):
        self.do_backspace()
    elif keysym == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = g.choose(self.verbose,'ON','OFF')
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    elif ch == 'Down' and hasattr(self,'onDown'):
        self.onDown()
    elif ch == 'Up' and hasattr(self,'onUp'):
        self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch,keysym)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.es('No completions',color='blue')
                self.exit()
            return
        else:
            if trace: g.trace('ignore non plain key',repr(stroke))
            return 'do-standard-keys'
</t>
<t tx="ekr.20061031131434.110">def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') &gt; -1 or stroke.find('Alt') &gt; -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return # (for Tk) 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return # (for Tk) 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return # (for Tk) 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return # (for Tk) 'break'
    elif name.startswith('log'):
        i = w.logCtrl.getInsertPoint()
        if not stroke:
            stroke = event.stroke # 2010/05/04.
        if stroke.lower() == 'return': stroke = '\n'
        elif stroke.lower() == 'tab': stroke = '\t'
        elif stroke.lower() == 'backspace': stroke = '\b'
        elif stroke.lower() == 'period': stroke = '.'
        w.logCtrl.insert(i,stroke)
        return # None
    else:
        # Let the widget handle the event.
        return # None
</t>
<t tx="ekr.20061031131434.111">def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):

    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; gui = g.app.gui
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    
    c.check_event(event)
    
    keysym = gui.eventKeysym(event) ; ch = gui.eventChar(event)
    trace = False or c.config.getBool('trace_modes') ; verbose = True
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = g.choose(help,helpPrompt,k.altX_prompt)
        k.setLabelBlue('%s' % (prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif keysym == 'Ins' or k.isFKey(keysym):
        pass
    elif keysym == 'Escape':
        k.keyboardQuit()
    elif keysym == 'Return':
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif keysym in ('Tab','\t'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return # (for Tk) 'break'
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None

    # g.trace(func and func.__name__,'mb_event',event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061031131434.118">def numberCommand (self,event,stroke,number):

    k = self ; c = self.c
    k.stroke = stroke
    w = event.widget
    
    c.check_event(event)

    k.universalDispatcher(event)
    g.app.gui.event_generate(c,w,'&lt;Key&gt;',keysym=number)
    return # (for Tk) 'break'

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
</t>
<t tx="ekr.20061031131434.122">def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.es('no previous command',color='blue')
    return # (for Tk) 'break'

def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c ; gui = g.app.gui
    
    c.check_event(event)

    keysym = gui.eventKeysym(event)
    # g.trace('state',k.state.kind,'event',repr(event),g.callers())
    if keysym == 'Return' and k.mb_history:
    # if k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
        return # (for Tk) 'break'
    else:
        # g.trace('oops')
        return k.keyboardQuit()
</t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)

    # g.trace('stroke',repr(stroke),'commandName',commandName,'w',w,g.callers())

    if stroke and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(c,w,stroke)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.trace(message,color='red')
</t>
<t tx="ekr.20061031131434.127">def simulateCommand (self,commandName):

    k = self ; c = k.c

    commandName = commandName.strip()
    if not commandName: return

    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]

    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)

    if func:
        # g.trace(commandName,func.__name__)
        stroke = None
        if commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.bunch(c=c,keysym='',char='',stroke='',widget=None)
            
        c.check_event(event)

        k.masterCommand(event,func,stroke)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        g.trace('no command for %s' % (commandName),color='red')
        if g.app.unitTesting:
            raise AttributeError
        else:
            return None
</t>
<t tx="ekr.20061031131434.128">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    trace = (False or (c.config.getBool('trace_modes')) and not g.app.unitTesting)
    state = k.getState('getArg')
    
    c.check_event(event)

    keysym = gui.eventKeysym(event)
    if trace: g.trace(
        'state',state,'keysym',repr(keysym),'stroke',repr(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif keysym == 'Escape':
        k.keyboardQuit()
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym in('Tab','\t'):
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym in('BackSpace','\b'): # 2010/02/20: Test for \b also.
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return # (for Tk) 'break'
</t>
<t tx="ekr.20061031131434.129">k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
</t>
<t tx="ekr.20061031131434.146">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''
    
    k,c = self,self.c ; gui = g.app.gui
    
    c.check_event(event)

    &lt;&lt; define vars &gt;&gt;
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'keysym:',
        repr(event.keysym),'ch:',repr(event.char),'state',state,'state2',k.unboundKeyAction)

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return # (for Tk) 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        if trace: g.trace('   state %-10s %s' % (stroke,state))
        done,val = k.doMode(event,state,stroke)
        if done: return val

    if traceGC: g.printNewObjects('masterKey 2')
            
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            return k.handleUnboundKeys(event,char,keysym,stroke)

    # 2011/02/08: Use getPandBindings for *all* keys.
    b = k.getPaneBinding(stroke,w)
    if b:
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke)
        return k.masterCommand(event,b.func,b.stroke,b.commandName)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        return k.handleUnboundKeys(event,char,keysym,stroke)
</t>
<t tx="ekr.20061031131434.147">if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
stroke = event.stroke
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = (False or self.trace_masterKeyHandler) and not g.app.unitTesting

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','\t','Escape',):
            return False
        if k.isFKey(stroke): # 2010/10/23.
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
</t>
<t tx="ekr.20061031131434.155">def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('focus',w)
    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',stroke='',widget=w)
    
    c.check_event(event)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
</t>
<t tx="ekr.20061031131434.168">def getFileName (self,event=None,handler=None,prefix='',filterExt='.leo'):

    '''Similar to k.getArg, but uses completion to indicate files on the file system.'''

    k = self ; c = k.c ; gui = g.app.gui
    tag = 'getFileName' ; state = k.getState(tag)
    tabName = 'Completion'
    
    c.check_event(event)

    keysym = gui.eventKeysym(event)
    # g.trace('state',state,'keysym',keysym)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        k.getFileNameHandler = handler
        k.setState(tag,1,k.getFileName)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        c.frame.log.clearTab(tabName)
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        handler = k.getFileNameHandler
        c.frame.log.deleteTab(tabName)
        if handler: handler(event)
    elif keysym in ('Tab','\t'):
        k.doFileNameTab()
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doFileNameBackSpace() 
        c.minibufferWantsFocus()
    else:
        k.doFileNameChar(event)
    return # (for Tk) 'break'
</t>
<t tx="ekr.20061031131434.169">k.filterExt = filterExt
k.mb_prefix = (prefix or k.getLabel())
k.mb_prompt = prefix or k.getLabel()
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
theDir = g.os_path_finalize(os.curdir)
k.extendLabel(theDir,select=False,protect=False)

k.mb_tabListPrefix = k.getLabel()
</t>
<t tx="ekr.20061031131434.170">def doFileNameBackSpace (self):

    '''Cut back to previous prefix and update prefix.'''

    k = self ; c = k.c

    if 0:
        g.trace(
            len(k.mb_tabListPrefix) &gt; len(k.mb_prefix),
            repr(k.mb_tabListPrefix),repr(k.mb_prefix))

    if len(k.mb_tabListPrefix) &gt; len(k.mb_prefix):
        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)
</t>
<t tx="ekr.20061031131434.171">def doFileNameChar (self,event):

    k = self

    # Clear the list, any other character besides tab indicates that a new prefix is in effect.
    k.mb_tabList = []
    k.updateLabel(event)
    k.mb_tabListPrefix = k.getLabel()

    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
    else:
        # Restore everything.
        old = k.getLabel(ignorePrompt=True)[:-1]
        k.setLabel(k.mb_prompt + old)
</t>
<t tx="ekr.20061031131434.172">def doFileNameTab (self):

    k = self
    common_prefix = k.computeFileNameCompletionList()

    if k.mb_tabList:
        k.setLabel(k.mb_prompt + common_prefix)
</t>
<t tx="ekr.20061031131434.173"># This code must not change mb_tabListPrefix.
def computeFileNameCompletionList (self):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    path = k.getLabel(ignorePrompt=True)
    sep = os.path.sep
    tabList = []
    for f in glob.glob(path+'*'):
        if g.os_path_isdir(f):
            tabList.append(f + sep)
        else:
            junk,ext = g.os_path_splitext(f)
            if not ext or ext == k.filterExt:
                tabList.append(f)
    k.mb_tabList = tabList
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if tabList:
        c.frame.log.clearTab(tabName)
        k.showFileNameTabList()
    return common_prefix
</t>
<t tx="ekr.20061031131434.174">def showFileNameTabList (self):

    k = self ; tabName = 'Completion'

    for path in k.mb_tabList:
        theDir,fileName = g.os_path_split(path)
        s = g.choose(path.endswith('\\'),theDir,fileName)
        s = fileName or g.os_path_basename(theDir) + '\\'
        g.es('',s,tabName=tabName)
</t>
<t tx="ekr.20061031131434.182">def isPlainKey (self,shortcut):

    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''

    k = self ; shortcut = shortcut or ''

    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True

    for s in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(s) != -1:            
            return False
    else:
        # Careful, allow bare angle brackets for unit tests.
        if shortcut.startswith('&lt;') and shortcut.endswith('&gt;'):
            shortcut = shortcut[1:-1]

        isPlain = (
            len(shortcut) == 1 or
            len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
            # A hack: allow Return to be bound to command.
            shortcut in ('Tab','\t')
        )

        # g.trace(isPlain,repr(shortcut))
        return isPlain and not self.isFKey(shortcut)
</t>
<t tx="ekr.20061031131434.200">def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    &lt;&lt; about repeat counts &gt;&gt;

    c,k = self.c,self ; gui = g.app.gui
    state = k.getState('u-arg')
    
    c.check_event(event)

    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        keysym = gui.eventKeysym(event)
        # g.trace(state,keysym)
        if keysym == 'Escape':
            k.keyboardQuit()
        elif keysym == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif keysym.isdigit() or keysym == '-':
            k.updateLabel(event)
        elif keysym in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n,stroke=keysym)
            k.keyboardQuit()
            # k.clearState()
            # k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '&lt;Control-x&gt;':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return # (for Tk) 'break'
</t>
<t tx="ekr.20061031131434.201">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
</t>
<t tx="ekr.20061031131434.202">def executeNTimes (self,event,n,stroke):

    trace = False and not g.unitTesting
    k = self

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand()
    else:
        stroke = g.stripBrackets(stroke)
        b = k.getPaneBinding(stroke,event.widget)
        if b:
            if trace: g.trace('repeat',n,'method',b.func.__name__,
                'stroke',stroke,'widget',event.widget)
            for z in range(n):
                # event = g.Bunch(
                    # c = self.c,
                    # widget = event.widget,
                    # keysym = event.keysym,
                    # stroke = event.stroke,
                    # char = event.char,
                # )
                k.masterCommand(event,b.func,'&lt;%s&gt;' % stroke)
        else:
            # This does nothing for Qt gui.
            w = event.widget
            for z in range(n):
                g.app.gui.event_generate(c,w,'&lt;Key&gt;',keysym=event.keysym)
</t>
<t tx="ekr.20061031131434.203">def doControlU (self,event,stroke):

    k = self ; c = k.c
    ch = g.app.gui.eventChar(event)

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
</t>
<t tx="ekr.20061031131434.39">def insert_general_char (self,ch,keysym):

    trace = False and not g.unitTesting
    c,k = self.c,self.k ; w = self.w
    
    if trace: g.trace(repr(ch))

    if g.isWordChar(ch):
        self.insert_string(ch)
        common_prefix,prefix,aList = self.compute_completion_list()
        if trace: g.trace('ch',repr(ch),'prefix',repr(prefix),'len(aList)',len(aList))
        if not aList:
            if 0: # Annoying. Let the user type "by hand".
                # Delete the character we just inserted.
                self.do_backspace()
        elif self.auto_tab and len(common_prefix) &gt; len(prefix):
            extend = common_prefix[len(prefix):]
            if trace: g.trace('*** extend',extend)
            ins = w.getInsertPoint()
            w.insert(ins,extend)
    else:
        if ch == '(' and k.enable_calltips:
            # This calls self.exit if the '(' is valid.
            self.calltip()
        else:
            if trace: g.trace('ch',repr(ch),'calling exit')
            self.insert_string(ch)
            self.exit()
</t>
<t tx="ekr.20061031131434.76">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):

    '''Create a key handler for c.

    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''

    self.c = c
    self.dispatchEvent = None
    self.inited = False # Set at end of finishCreate.
    self.w = c.frame.miniBufferWidget
    self.new_bindings = True
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '

    # These must be defined here to avoid memory leaks.
    getBool = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')
    self.trace_bind_key_exceptions      = getBool('trace_bind_key_exceptions')
    self.trace_masterClickHandler       = getBool('trace_masterClickHandler')
    self.traceMasterCommand             = getBool('trace_masterCommand')
    self.trace_masterKeyHandler         = getBool('trace_masterKeyHandler')
    self.trace_masterKeyHandlerGC       = getBool('trace_masterKeyHandlerGC')
    self.trace_key_event                = getBool('trace_key_event')
    self.trace_minibuffer               = getBool('trace_minibuffer')
    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;

    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    fn = c.shortFileName()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction() # 2011/02/09
</t>
<t tx="ekr.20061031131434.78">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.argSelectedText = '' # The selected text in state 0.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.getArgEscape = None # A signal that the user escaped getArg in an unusual way.
self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.modePrompt = '' # The mode promopt.
self.negativeArg = False
self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.previousSelection = None # A hack for middle-button paste: set by masterClickHandler, used by pasteText.
self.state = g.bunch(kind=None,n=None,handler=None)
</t>
<t tx="ekr.20061031131434.79">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
self.masterBindingsDict = {}
    # Keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)
self.masterGuiBindingsDict = {}
    # Keys are strokes; value is True;

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None
self.mb_help = False

# Keys whose bindings are computed by initSpecialIvars.
self.abortAllModesKey = None
self.autoCompleteForceKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.getArgEscapes = []
self.modeBindingsDict = {}
self.modeWidget = None
self.silentMode = False

# The actual values are set later in k.finishCreate.
self.command_mode_bg_color = 'white'
self.command_mode_fg_color = 'black'
self.insert_mode_bg_color = 'white'
self.insert_mode_fg_color = 'black'
self.overwrite_mode_bg_color = 'white'
self.overwrite_mode_fg_color = 'black'
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20061031132907">def event_generate(self,c,w,kind,*args,**keys):
    '''Generate an event.'''
    # g.trace('baseGui','kind',kind,'args,keys',*args,**keys)
    return w.event_generate(kind,*args,**keys)
    # g.trace('can not happen: must be defined in subclasses')

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    assert not event or event.keysym == event.char,repr(event) ####
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    assert not event or event.keysym == event.char,repr(event) ####
    return event and event.keysym

def eventStroke (self,event,c=None):
    assert not event or event.keysym == event.char,repr(event) ####
    return event and hasattr(event,'stroke') and event.stroke or ''

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''
    assert not event or event.keysym == event.char,repr(event) ####
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0
</t>
<t tx="ekr.20061031170011.12">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or self.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    
    c.check_event(event)

    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    # g.trace(g.callers())

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
</t>
<t tx="ekr.20061103114242">p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab':
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)
</t>
<t tx="ekr.20070105123800">def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        # Bug fix: 2009-5-31.
        # None denotes that we use the present value of the option.
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)
</t>
<t tx="ekr.20070123085931">def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # g.trace('base keyHandler')

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&amp;" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        "&gt;" : "greater",
        "&lt;" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key

</t>
<t tx="ekr.20070123143428">def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
</t>
<t tx="ekr.20070228074312.15"># Called from leoGui.event_generate.

#### This should be the default implementation in the gui base class.


def event_generate(self,stroke,keysym=None):
    
    # g.trace('can not happen: must be defined in subclasses')
    # return

    trace = False # and not g.unitTesting
    w = self ; c = self.c
    
    # Canonicalize the setting.
    stroke1 = stroke ####
    stroke = c.k.shortcutFromSetting(stroke)
    char = keysym or stroke1 ####

    if trace: g.trace('(baseTextWidget)','char',repr(char),'stroke',repr(stroke),'w',w)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,stroke):
            self.c = c
            self.char = char
            self.keysym = char
            self.stroke = stroke
            self.leoWidget = w
            self.widget = self.w = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
    c.outerUpdate()
</t>
<t tx="ekr.20070228074312.2"># Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

# Must be defined in subclasses.

def onChar (self, event):
    
    g.trace('can not happen: must be defined in subclasses')

    # c = self.c
    # keycode = event.GetKeyCode()
    # event.leoWidget = self
    # keysym = g.app.gui.eventKeysym(event)
    # #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    # if keysym:
        # c.k.masterKeyHandler(event,stroke=keysym)
        # c.outerUpdate()
</t>
<t tx="ekr.20070228160107">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c,stroke=None):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.state  = hasattr(event,'state') and event.state or 0
        self.stroke = hasattr(event,'stroke') and event.stroke or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        if stroke and not self.stroke:
            self.stroke = self.actualEvent.stroke = stroke

        self.widget = self.w

    def __repr__ (self):

        if self.stroke:
            return 'leoGui.leoKeyEvent: stroke: %s' % (repr(self.stroke))
        else:
            return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (
                repr(self.char),repr(self.keysym))
</t>
<t tx="ekr.20070317085437.31">def createChapter (self,event=None):

    '''create-chapter command.
    Create a chapter with a dummy first node.'''

    cc = self ; k = cc.c.k ; tag = 'create-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter: ',protect=True)
        k.getArg(event,tag,1,self.createChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=None,
                undoType='Create Chapter')
</t>
<t tx="ekr.20070317085437.41"># newName is for unitTesting.

def renameChapter (self,event=None,newName=None):

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc = self ; c = cc.c ; k = cc.c.k ; tt = cc.tt
    tag = 'rename-chapter'
    theChapter = cc.selectedChapter
    if not theChapter: return
    if theChapter.name == 'main':
        return cc.error('Can not rename the main chapter')

    state = k.getState(tag)

    if state == 0 and not newName:
        names = list(cc.chaptersDict.keys())
        prefix = 'Rename this chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.renameChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if newName: k.arg = newName
        if k.arg and k.arg != theChapter.name:
            oldChapterName = theChapter.name
            del cc.chaptersDict[theChapter.name]
            cc.chaptersDict[k.arg] = theChapter
            theChapter.name = k.arg
            root = theChapter.root
            root.initHeadString('@chapter %s' % k.arg)
            if tt:
                tt.setTabLabel(k.arg)
                tt.destroyTab(oldChapterName)
                tt.createTab(k.arg)
            c.redraw()
</t>
<t tx="ekr.20070317085437.50">def cloneNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then clone the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'clone-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Clone node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.cloneNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070317085437.51">def copyNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then copy the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'copy-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.copyNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.copyNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070317085437.52">def moveNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; p = c.p ; u = c.undoer
    undoType = 'Move Node To Chapter'
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('chapter "%s" does not exist' % toChapterName)
    if fromChapter.name == 'main' and g.match_word(p.h,0,'@chapter'):
        return cc.error('can not move @chapter node')

    if toChapter.name == 'main':
        sel = (p.threadBack() != fromChapter.root and p.threadBack()) or p.nodeAfterTree()
    else:
        sel = p.threadBack() or p.nodeAfterTree()
    if sel:
        # Get 'before' undo data.
        inAtIgnoreRange = p.inAtIgnoreRange()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        # Do the move.
        if toChapter.name == 'main':
            p.moveAfter(toChapter.p)
        else:
            p.moveToLastChildOf(toChapter.root)
        c.redraw(sel)
        c.setChanged(True)
        # Do the 'after' undo operation.
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)

    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.error('Can not move the last remaining node of a chapter.')
</t>
<t tx="ekr.20070604155815.1">def cloneNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; p = c.p ; u = c.undoer
    undoType = 'Clone Node To Chapter'
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('chapter "%s" does not exist' % toChapterName)
    if fromChapter.name == 'main' and g.match_word(p.h,0,'@chapter'):
        return cc.error('can not clone @chapter node')

    # Open the group undo.
    c.undoer.beforeChangeGroup(toChapter.root,undoType)
    # Do the clone.  c.clone handles the inner undo.
    clone = c.clone()
    # Do the move.
    undoData2 = u.beforeMoveNode(clone)
    if toChapter.name == 'main':
        clone.moveAfter(toChapter.p)
    else:
        clone.moveToLastChildOf(toChapter.root)
    u.afterMoveNode(clone,'Move Node',undoData2,dirtyVnodeList=[])
    c.redraw(clone)
    c.setChanged(True)
    # Close the group undo.
    # Only the ancestors of the moved node get set dirty.
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.undoer.afterChangeGroup(clone,undoType,reportFlag=False,dirtyVnodeList=dirtyVnodeList)

    toChapter.p = clone.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070604155815.2">def copyNodeToChapterHelper (self,toChapterName):

    cc = self ; c = cc.c ; p = c.p ; u = c.undoer
    undoType = 'Copy Node To Chapter'
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.error('no such chapter: %s' % toChapterName)
    if fromChapter.name == 'main' and g.match_word(p.h,0,'@chapter'):
        return cc.error('can not copy @chapter node')

    # For undo, we treat the copy like a pasted (inserted) node.
    undoData = u.beforeInsertNode(toChapter.root,pasteAsClone=False,copiedBunchList=[])
    s = c.fileCommands.putLeoOutline()
    p2 = c.fileCommands.getLeoOutline(s)
    p2.moveToLastChildOf(toChapter.root)
    c.redraw(p2)
    u.afterInsertNode(p2,undoType,undoData)
    c.setChanged(True)

    toChapter.p = p2.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070604155815.3">def moveNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then move the selected node to the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'move-node-to-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Move node to chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.moveNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.moveNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070604165126">def selectChapter (self,event=None):

    '''Use the minibuffer to get a chapter name,
    then create the chapter.'''

    cc = self ; k = cc.c.k ; tag = 'select-chapter'
    state = k.getState(tag)

    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Select chapter: '
        k.setLabelBlue(prefix,protect=True)
        k.getArg(event,tag,1,self.selectChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.selectChapterByName(k.arg)
</t>
<t tx="ekr.20070605110441">def dynamicExpandHelper (self,event,prefix=None,rlist=None,w=None):

    c,k = self.c,self.k ; tag = 'dabbrev-expand'
    state = k.getState(tag)
    
    c.check_event(event)

    if state == 0:
        self.w = w
        if w:
            names = rlist
            prefix2 = 'dabbrev-expand: '
            k.setLabelBlue(prefix2+prefix,protect=True)
            ### event = None
            k.getArg(event,tag,1,self.dynamicExpandHelper,prefix=prefix2,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ins = w.getInsertPoint()
            i,j = g.getWord(s,ins)
            w.delete(i,j)
            w.insert(i,k.arg)
</t>
<t tx="ekr.20070607092909">def createChapterFromNode (self,event=None):

    '''create-chapter-from-node command.

    Create a chapter whose first node is a clone of the presently selected node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'create-chapter-from-node'
    state = k.getState(tag)

    p = c.p
    if p.h.startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter from node: ',protect=True)
        k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,
                undoType='Create Chapter From Node')
</t>
<t tx="ekr.20070608072116">def convertNodeToChapter (self,event=None):

    '''convert-node-to-chapter command.

    Make the selected node into a new chapter, 'in place'.
    That is, create the new @chapter node as the next sibling of the node,
    then move the node as the first child of the new @chapter node.'''

    cc = self ; c = cc.c ; k = c.k ; tag = 'convert-node-to-chapter'
    state = k.getState(tag)

    p = c.p
    if p.h.startswith('@chapter'):
        cc.error('Can not create a new chapter from from an @chapter or @chapters node.')
        return

    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Convert node to chapter: ',protect=True)
        k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=c.p,
                undoType='Convert Node To Chapter')
</t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.b
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.b,ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'"))
        for z in sorted(self.decls)]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080408060320.1">def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            g.choose(oneLine,'in line ','')))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg ; w = self.w ; c = k.c
        if ch:
            i = w.getInsertPoint()
            s = w.getAllText()
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            else:
                end = len(s)

            while i &lt; end:
                i = s.find(ch,i+1,end) # Ensure progress and i &gt; 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break

        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080510095819.1">def handleUnboundKeys (self,event,char,keysym,stroke):

    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)

    if trace and verbose: g.trace('ch: %s keysym: %s stroke %s' % (
        repr(event.char),repr(event.keysym),repr(stroke)))

    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return # (for Tk) 'break'

    elif k.isFKey(stroke):
        if trace: g.trace('ignoring F-key',stroke)
        return # (for Tk) 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',stroke,keysym)
        return # (for Tk) 'break'

    elif k.ignore_unbound_non_ascii_keys and len(char) &gt; 1:
        if trace: g.trace('ignoring unbound non-ascii key',repr(stroke))
        return # (for Tk) 'break'

    elif (
        keysym and keysym.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return # (for Tk) 'break'

    else:
        if trace: g.trace('no func',stroke)
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20080531075119.6">def tracer (self, frame, event, arg):

    '''A function to be passed to sys.settrace.'''

    n = len(self.stack)
    if event == 'return': n = max(0,n-1)
    pad = '.' * n

    if event == 'call':
        if not self.inited:
            # Add an extra stack element for the routine containing the call to startTracer.
            self.inited = True
            name = self.computeName(frame.f_back)
            self.updateStats(name)
            self.stack.append(name)
        name = self.computeName(frame)
        if self.trace and (self.limit == 0 or len(self.stack) &lt; self.limit):
            g.trace('%scall' % (pad),name)
        self.updateStats(name)
        self.stack.append(name)
        return self.tracer
    elif event == 'return':
        if self.stack:
            name = self.stack.pop()
            if self.trace and self.verbose and (self.limit == 0 or len(self.stack) &lt; self.limit):
                g.trace('%sret ' % (pad),name)
        else:
            g.trace('return underflow')
            self.stop()
            return None
        if self.stack:
            return self.tracer
        else:
            self.stop()
            return None
    else:
        return self.tracer
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080805071954.2">def putDescendentVnodeUas (self,p):

    '''Return the a uA field for descendent vnode attributes,
    suitable for reconstituting uA's for anonymous vnodes.'''

    trace = False
    if trace: g.trace(p.h)

    # Create aList of tuples (p,v) having a valid unknownAttributes dict.
    # Create dictionary: keys are vnodes, values are corresonding archived positions.
    pDict = {} ; aList = []
    for p2 in p.self_and_subtree():
        if hasattr(p2.v,"unknownAttributes"):
            aList.append((p2.copy(),p2.v),)
            pDict[p2.v] = p2.archivedPosition(root_p=p)

    # Create aList of pairs (v,d) where d contains only pickleable entries.
    if aList: aList = self.createUaList(aList)
    if not aList: return ''

    # Create d, an enclosing dict to hold all the inner dicts.
    d = {}
    for v,d2 in aList:
        aList2 = [str(z) for z in pDict.get(v)]
        # g.trace(aList2)
        key = '.'.join(aList2)
        d[key]=d2

    if trace: g.trace(p.h,g.dictToString(d))

    # Pickle and hexlify d
    return d and self.pickle(
        torv=p.v,val=d,tag='descendentVnodeUnknownAttributes') or ''
</t>
<t tx="ekr.20080805132422.3">def resolveArchivedPosition(self,archivedPosition,root_v):

    '''Return a vnode corresponding to the archived position relative to root node root_v.'''

    def oops (message):
        if not g.app.unitTesting:
            g.es_print('bad archived position: %s' % (message),color='red')

    try:
        aList = [int(z) for z in archivedPosition.split('.')]
        aList.reverse()
    except Exception:
        return oops('"%s"' % archivedPosition)

    if not aList:
        return oops('empty')

    last_v = root_v
    n = aList.pop()
    if n != 0:
        return oops('root index="%s"' % n )

    while aList:
        n = aList.pop()
        children = last_v.children
        if n &lt; len(children):
            last_v = children[n]
        else:
            return oops('bad index="%s", len(children)="%s"' % (n,len(children)))

    return last_v
</t>
<t tx="ekr.20080811174246.1">def languageForExtension (self,ext):

    '''Return the language corresponding to the extension ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20080819075811.13">def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
</t>
<t tx="ekr.20090130114732.6">def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
</t>
<t tx="ekr.20090204084607.2">def iSearch (self,again=False):

    '''Handle the actual incremental search.'''

    c = self.c ; k = self.k ; p = c.p
    ifinder = self.ifinder
    reverse = not self.forward
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        return self.abortSearch()
    ifinder.c = c ; ifinder.p = p.copy()
    # Get the base ivars from the find tab.
    ifinder.update_ivars()
    # Save
    oldPattern = ifinder.find_text
    oldRegexp  = ifinder.pattern_match
    oldReverse = ifinder.reverse
    oldWord =  ifinder.whole_word
    # Override
    ifinder.pattern_match = self.regexp
    ifinder.reverse = reverse
    ifinder.find_text = pattern
    ifinder.whole_word = False # Word option can't be used!
    # Prepare the search.
    if len(self.stack) &lt;= 1: ifinder.in_headline = False
    w = self.setWidget()
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if again:   ins = g.choose(reverse,i,j+len(pattern))
    else:       ins = g.choose(reverse,j+len(pattern),i)
    ifinder.init_s_ctrl(s,ins)
    # Do the search!
    pos, newpos = ifinder.findNextMatch()
    # Restore.
    ifinder.find_text = oldPattern
    ifinder.pattern_match = oldRegexp
    ifinder.reverse = oldReverse
    ifinder.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None: # success.
        w = ifinder.showSuccess(pos,newpos,showState=False)
        if w: i,j = w.getSelectionRange(sort=False)
        # else: g.trace('****')
        if not again: self.push(c.p,i,j,ifinder.in_headline)
    elif ifinder.wrapping:
        g.es("end of wrapped search")
    else:
        g.es("not found","'%s'" % (pattern))
        event = g.Bunch(char='\b',keysym='\b',stroke='BackSpace')
        c.check_event(event)
        k.updateLabel(event)
</t>
<t tx="ekr.20090212054250.9">def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    s,e = g.readFileIntoString(fn)
    if s is None: return
    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()
</t>
<t tx="ekr.20090213065933.14">def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width &gt; 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
</t>
<t tx="ekr.20090218115025.3">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/326a221f4c698f7a

&gt; On Wed, Feb 18, 2009 at 12:12 PM, Kent Tenney &lt;ktenney@gmail.com&gt; wrote:
&gt;&gt;
&gt;&gt; Currently, Leo pickles the value of unknown attributes unless
&gt;&gt; the name starts with 'str_'
&gt;&gt;
&gt;&gt; Running the following code in node 'UA'
&gt;&gt;
&gt;&gt; p = c.currentPosition()
&gt;&gt; p.v.u = {'hello':'world', 'str_hello':'world'}
&gt;&gt;
&gt;&gt; results in the following in the .leo file:
&gt;&gt;
&gt;&gt; &lt;v t="ktenney.20090218114928.367" str_hello="world"
&gt;&gt; hello="5505776f726c6471002e"&gt;&lt;vh&gt;UA&lt;/vh&gt;&lt;/v&gt;
&gt;&gt;
&gt;&gt; I think this is surprising, Python-centric and contrary to the
&gt;&gt; spirit of Leo as a flexible data management platform.
&gt;
&gt; I suppose your point is that you can't create an arbitrarily named attribute
&gt; with a string value. Does that create a real problem?

It requires a translation layer, either to (un)munge the name or
(un)pickle. Real problem?

Let's say each time I think 'I can use UAs to store that' I change
my mind when I realize my values will be in a pickle. (I really don't
want to name all my attributes str_xxx)

&gt; As far as being Python-centric, can you suggest any other way of converting
&gt; arbitrary data to a text string?

How is it done in any other XML file?
I've not used XML for arbitrary data, but it probably can be done.

&gt; Why would that way be better than pickle?

My suspicion is that UAs would be used more for
storing text and numbers (as seems common for XML files)
than Python data objects.

Does Leo use UAs to store pickles?

I'm sure pickling capability is great, but I'm not convinced
it should be the _default._

No big deal.
</t>
<t tx="ekr.20090514093345.6054"></t>
<t tx="ekr.20090525144314.6526">def cleanSaxInputString(self,s):

    '''Clean control characters from s.
    s may be a bytes or a (unicode) string.'''

    # Note: form-feed ('\f') is 12 decimal.
    badchars = [chr(ch) for ch in range(32)]
    badchars.remove('\t')
    badchars.remove('\r')
    badchars.remove('\n')

    flatten = ''.join(badchars)
    pad = ' ' * len(flatten)

    if g.isPython3:
        flatten = bytes(flatten,'utf-8')
        pad = bytes(pad,'utf-8')
        transtable = bytes.maketrans(flatten,pad)
    else:
        transtable = string.maketrans(flatten,pad)

    return s.translate(transtable)

# for i in range(32): print i,repr(chr(i))
</t>
<t tx="ekr.20090601083544.6051">http://groups.google.com/group/leo-editor/browse_thread/thread/3cd5cb06d32264d

&gt; What would work for me is if named sections in a @rst subtree
&gt; would work exactly as they work for other derived files: they
&gt; get inserted at the place where they are referenced.

- Add support for the following options:
    - expand_noweb_references: default False for compatibility.
    - ignore_noweb definitions: default False for compatibility.

- When expand_noweb_references is True, definitions (typically clones)
  must be descendants of the referencing node (in the @rst tree)
</t>
<t tx="ekr.20090601083544.6052">I want to write the documentation for the source program in a @rst3 subtree. In
this @rst3 subtree I want to refer to fragments of the program, like:

In the following code fragment::

  &lt;&lt;code fragment&gt;&gt;

Unfortunately, &lt;&lt;code fragment&gt;&gt; will not be expanded. Furthermore, in order to
get to this work, I should have &lt;&lt;code fragment&gt;&gt; under the @rst3 subtree as
well, but this is then also treated as @rst3 input (which in this case, is not
what I want).
</t>
<t tx="ekr.20090620052003.8505">u = c.undoer
w = c.frame.body.bodyCtrl
p2 = p.insertAsNthChild(0)
c.setHeadString(p2,'@test xxx')
s = '''\
if g.unitTesting:

    c,p = g.getTestVars()

    '''
c.setBodyString(p2,s)
c.selectPosition(p2)
c.redraw()
w.setInsertPoint(len(s))
c.bodyWantsFocus()
c.outerUpdate()
</t>
<t tx="ekr.20090801103907.6018">http://groups.google.com/group/leo-editor/browse_thread/thread/b41ddfeb3c84e780

Especially languages in leo/modes.

** Only c.getOpenWithExt uses app.language_extension_dict.

I'll wait until I get requests for particular language.
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20091230094319.6240">def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction

    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))

    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                b = d.get(stroke)
                if b:
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and b.commandName in table:
                        if trace: g.trace('***** special case',b.commandName)
                        pass
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(b.stroke),b.commandName))
                        return b
</t>
<t tx="ekr.20091230094319.6244">def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self

    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete'):
        if k.handleMiniBindings(event,state,stroke):
            return True,'break'

    # Second, honor general modes.
    if state == 'getArg':
        return True,k.getArg(event,stroke=stroke)
    elif state == 'getFileName':
        return True,k.getFileName(event)
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-standard-keys':
            return True,'break'

    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return True,'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False,None
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True,'break'
</t>
<t tx="ekr.20100112051224.6226">The ability to specify a numeric range prefix is not supported. For example,
entering "3dd" will not delete the next three lines and "20G" will not move the
cursor to the 20th line in the file.

The ability to specify a numeric range prefix to an object is not supported. For
example, the "d2fx" command should Delete up to and including the 2nd Found "x"
character.
</t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20100205152016.14055">gnx = 'ekr.20100205162207.5844'
for v in c.all_nodes():
    if v.gnx == gnx:
        print(v.h)</t>
<t tx="ekr.20100205162207.5844">print(p.v.gnx)

# ekr.20100205162207.5844
</t>
<t tx="ekr.20100210214809.5767">old,new = None,None
for child in p.children():
    if child.h.startswith('old'):
        old = child.copy()
    if child.h.startswith('new'):
        new = child.copy()
if old and new:
    print(old.b == new.b)
    if old.b != new.b:
        print('*' * 20)
        print(len(old.b),len(new.b))
        old_lines = g.splitLines(old.b)
        new_lines = g.splitLines(new.b)
        for i in range(max(len(old_lines),len(new_lines))):
            if (i &lt; len(old_lines) and i &lt; len(new_lines) and
                old_lines[i] == new_lines[i]
            ):
                pass
            else:
                if i &lt; len(old_lines):
                    print('old %2d %s' % (i,repr(old_lines[i])))
                if i &lt; len(new_lines):
                    print('new %2d %s' % (i,repr(new_lines[i])))</t>
<t tx="ekr.20100223133351.5996"># for v in c.all_unique_nodes():
n = 0
g.es('cleaning',c.p.h)
for p in c.p.self_and_subtree():
    print(p.h)
    lines = []
    for s in g.splitLines(p.b):
        if s.strip():
            lines.append(s)
        else:
            # Ensures a trailing newline.
            lines.append('\n')
    s2 = ''.join(lines)
    if s2 != p.b:
        p.b = s2
        p.v.setDirty()
        n += 1

c.redraw()
g.es('cleaned %s nodes' % n)
</t>
<t tx="ekr.20100223133351.5999"># This works, but splitting long lines by hand
# is the very essence of stupidity.

# Don't use this script!
# Use a *reliable* pep8 tool instead.

g.es('finding long lines in',p.h)
found = False
while p and not found:
    for line in g.splitLines(p.b):
        if len(line) &gt; 80:
            found = True
            g.es('long line in',p.h)
            c.selectPosition(p)
            break
    else:
        p.moveToThreadNext()
g.es('done')</t>
<t tx="ekr.20100225053729.5761"># Strips comments and context lines from a diff
# so real changes can be seen more easily.

result = []
for s in g.splitLines(p.b):
    if s.startswith('===') or s.startswith('+') or s.startswith('-'):
        i = s.find('#')
        if i &gt; -1:
            result.append(s[:i] + '\n')
        else:
            result.append(s)

p.b = ''.join(result)

</t>
<t tx="ekr.20100407063358.5748">import inspect

fn = g.os_path_finalize_join(g.app.loadDir,'leoNodes.py')

m = __import__ ('leoNodes')
# print(m)

classes = inspect.getmembers(m,inspect.isclass)
# print(classes)
print('='*20)
for z in classes:
    name,value = z
    print(name)
    members = inspect.getmembers(value)
    print('members of',name)
    for name2,value2 in members:
        if False: # not name2.startswith('__'):
            print('  ',name2)
        if name2 == '__init__':
            print('__init__',value2)
            if inspect.isfunction(value2):
                init_members = inspect.getmembers(value2)
                print('init members')
                for name3,value3 in init_members:
                    if not name3.startswith('__'):
                        print('    ',name3)</t>
<t tx="ekr.20100515063611.5801">n = 0

for p in c.all_positions():
    n = max(n,p.level())

g.es('n',n)

last = 0
delta = 0
d = {}

for p in c.all_positions():
    n = p.level()
    if n &lt; last:
        delta = max(delta,last-n)
        d [last-n] = d.get(last-n,0) + 1
    last = n

g.es('delta',delta)
g.es('d',d)
</t>
<t tx="ekr.20100902154544.5872"></t>
<t tx="ekr.20101123131018.5842">@bool put_expansion_bits_in_leo_files = False

It's illogical to save bits in uA's if they aren't save in in the &lt;v&gt; elements.
</t>
<t tx="ekr.20101218103123.12443">table = (
    'core/leoPy.leo',
    'plugins/leoGuiPlugins.leo',
    'plugins/leoPlugins.leo',
    # 'test/unitTest.leo',
    # 'doc/LeoDocs.leo',
)

for z in table:
    fn = g.os_path_finalize_join(g.app.loadDir,'..',z)
    ok,frame = g.openWithFileName(fn,c)
    if not ok:
        g.es('not found',z)
</t>
<t tx="ekr.20110209083917.16004">def isAutoCompleteChar (self,stroke):
    
    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction
    
    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                b = d.get(stroke)
                if b and b.commandName == 'auto-complete':
                    return True
    return False
</t>
<t tx="ekr.20110414065052.6100">http://mail.google.com/mail/#inbox/12f3d4950fbabeea
</t>
<t tx="ekr.20110414164347.6082"></t>
<t tx="ekr.20110415173840.6098"></t>
<t tx="ekr.20110419083918.6104">@language rest
@pagewidth 65

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

The draft is also intended to be compatible with graphml.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

I am willing to change "type" to "key" in &lt;edge&gt; elements if that
would be preferable.

Recent changes
==============

- Added &lt;graphml&gt; element defining the default namespace.

- Defined the leo namespace for leo-only elements.
    - Renamed &lt;leo_file&gt; to &lt;leo:outline&gt;
    - Renamed &lt;descendant-attributes&gt; to &lt;leo:at-file-attributes&gt;

- Used &lt;leo:at-file-attributes&gt; for marks, removing the special case.

- Enclosed &lt;leo:descendant-attributes&gt; in a (graphml) &lt;data&gt; element.

- Changed the format of the "marked" attribute to be a string-valued attribute.

First lines
===========

Leo file will start with the following::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo:file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"/&gt;
        

No session data
===============

There will be no &lt;globals&gt;, &lt;preferences&gt; or
&lt;find_panel_settings&gt; elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within &lt;node&gt; elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo:outline file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;graphml xmlns="http://graphml.graphdrawing.org/xmlns"/&gt;
    &lt;graph&gt;
    &lt;nodes&gt;
        &lt;!-- marked attribute appears only if the vnode is marked --&gt;
        &lt;node id="gnx"&gt; 
            &lt;head&gt;headline text&lt;/head&gt;
            &lt;attr key="marked"&gt;1&lt;/attr&gt;
            &lt;!-- uA's... --&gt;
            &lt;!-- format="string" is the default --&gt;
            &lt;attr key="a"&gt;a string&lt;/attr&gt;
            &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
            &lt;attr key="c" format="pickle"&gt;a pickled string&lt;/attr&gt;
            &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
            ...
            &lt;body&gt;body text&lt;/body&gt;
        &lt;/node&gt;
        ...
        &lt;!-- @file nodes contain a &lt;data&gt; package --&gt;
        &lt;node id="gnx"&gt;
            &lt;head&gt;@file x.py&lt;/head&gt;
            ...
            &lt;data&gt;
                &lt;leo:at-file-attributes&gt;
                    &lt;attr&gt;key="ua-name"
                        format="(empty)/json/pickle/binhex"
                        gnx="gnx"&gt;value
                    &lt;/attr&gt;
                    ...
                &lt;/leo:at-file-attributes&gt;
            &lt;/data&gt;
        &lt;/node&gt;
        ...
    &lt;/nodes&gt;
    &lt;edges&gt;
        &lt;edge type="child" from="gnx" to="gnx"&lt;/edge&gt;
        ...
    &lt;/edges&gt;
    &lt;/graph&gt;
    &lt;/graphml&gt;
    &lt;/leo:outline&gt;

&lt;attr&gt; elements
===============

&lt;attr&gt; elements will one of the following forms::

    &lt;attr key="a"&gt;a unicode string&lt;/attr&gt;
    &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
    &lt;attr key="c" format="pickle"&gt;a json string&lt;/attr&gt;
    &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No &lt;attr&gt; element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

&lt;edge&gt; elements
===============

&lt;edge&gt; elements will have the form::

    &lt;edge type="child" from="gnx" to="gnx"/&gt;
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    &lt;edge type="undirected" from="gnx" to="gnx"/&gt;
    &lt;edge type="bidirectional" from="gnx" to="gnx"/&gt;
    &lt;edge type="backlink" from="gnx" to="gnx"/&gt;
    &lt;edge type="myPlugin" from="gnx" to="gnx"/&gt;
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The &lt;leo:at-file-attributes&gt; element may be contained in the
&lt;node&gt; element for @file nodes. For compatibility with graphml,
it will enclosed in a data element::
    
    &lt;data&gt;
        &lt;leo:at-file-attributes&gt;
            &lt;attr&gt;key="ua-name"
                format="(empty)/json/pickle/binhex"
                gnx="gnx"&gt;value
            &lt;/attr&gt;
            ...
        &lt;/leo:at-file-attributes&gt;
    &lt;/data&gt;
    
In other words, we use the graphml &lt;attr&gt; element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
</t>
<t tx="ekr.20110421132230.6107">@language rest
@pagewidth 65

Leo's file format: version 3, draft 4

http://groups.google.com/group/leo-editor/browse_thread/thread/a2b7e5321d62b64/a4cc51d404af94aa

Here is the latest version, with the graphml stuff removed.

This draft is intended to reflect our recent discussions, with no
new invention from me. All comments and corrections welcome.

This draft covers only Leo's xml format, but it may be adapted
for use as a json file format.

Recent changes
==============

- Removed graphml stuff, including leo: prefixes.

- Used "key" in &lt;attr&gt; elements (and "type" in &lt;edge&gt; elements.)

First lines
===========

Leo file will start with the following::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo_file file_format="3"
        xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
        

No session data
===============

There will be no &lt;globals&gt;, &lt;preferences&gt; or
&lt;find_panel_settings&gt; elements. All such "session data" will be
restored from the cache, or from defaults if caching is disabled.

**Important**: there is no representation of expansion state or
the currently selected node anywhere in the .leo file.
Eliminating these data is contingent on having Leo work well with
caching disabled.

Note: marks are more than session data. They must appear
somewhere within &lt;node&gt; elements.


Summary of format
=================

.leo files will have the following form, with similar indentation::

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;?xml-stylesheet my_stylesheet?&gt;
    &lt;!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) --&gt;
    &lt;leo_file file_format="3" xmlns:leo="http://www.leo-editor.org/2011/leo"/&gt;
    &lt;graph&gt;
    &lt;nodes&gt;
        &lt;!-- marked attribute appears only if the vnode is marked --&gt;
        &lt;node id="gnx"&gt; 
            &lt;head&gt;headline text&lt;/head&gt;
            &lt;attr key="marked"&gt;1&lt;/attr&gt;
            &lt;!-- uA's... --&gt;
            &lt;!-- format="string" is the default --&gt;
            &lt;attr key="a"&gt;a string&lt;/attr&gt;
            &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
            &lt;attr key="c" format="pickle"&gt;a pickled string&lt;/attr&gt;
            &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
            ...
            &lt;body&gt;body text&lt;/body&gt;
        &lt;/node&gt;
        ...
        &lt;!-- @file nodes contain a &lt;data&gt; package --&gt;
        &lt;node id="gnx"&gt;
            &lt;head&gt;@file x.py&lt;/head&gt;
            ...
            &lt;at-file-attributes&gt;
                &lt;attr&gt;key="ua-name"
                    format="(empty)/json/pickle/binhex"
                    gnx="gnx"&gt;value
                &lt;/attr&gt;
                ...
            &lt;/at-file-attributes&gt;
        &lt;/node&gt;
        ...
    &lt;/nodes&gt;
    &lt;edges&gt;
        &lt;edge type="child" from="gnx" to="gnx"&lt;/edge&gt;
        ...
    &lt;/edges&gt;
    &lt;/graph&gt;
    &lt;/leo_file&gt;

&lt;attr&gt; elements
===============

&lt;attr&gt; elements will one of the following forms::

    &lt;attr key="a"&gt;a unicode string&lt;/attr&gt;
    &lt;attr key="b" format="json"&gt;a json string&lt;/attr&gt;
    &lt;attr key="c" format="pickle"&gt;a json string&lt;/attr&gt;
    &lt;attr key="d" format="binhex"&gt;a binhexed string&lt;/attr&gt;
    
That is, the value will be a string by default.

uA's that start with "binhex_" will use the binhex format. This
prefix must be retained in the type field, so the read code can
restore them.

If the value is not a string, and there is no "binhex_" prefix,
the write code will use format="json" if json.dumps succeeds, and
will use format="pickle" otherwise.

No &lt;attr&gt; element will be written if both json.dumps and
pickle.dumps fail. Attribute failures will create a warning for
the plugin developer.

&lt;edge&gt; elements
===============

&lt;edge&gt; elements will have the form::

    &lt;edge type="child" from="gnx" to="gnx"/&gt;
    
Leo will use type="child" to represent Leo's official edges.
Plugins are free to define any type except "child". Examples::

    &lt;edge type="undirected" from="gnx" to="gnx"/&gt;
    &lt;edge type="bidirectional" from="gnx" to="gnx"/&gt;
    &lt;edge type="backlink" from="gnx" to="gnx"/&gt;
    &lt;edge type="myPlugin" from="gnx" to="gnx"/&gt;
    
Descendant attributes in @file trees
====================================

Descendants of @file nodes do not appear in .leo files. Thus,
important data must be stored in the so-called hidden machinery:
attributes of the @file node.

The &lt;at-file-attributes&gt; element may be contained in the
&lt;node&gt; element for @file nodes::

    &lt;at-file-attributes&gt;
        &lt;attr&gt;key="ua-name"
            format="(empty)/json/pickle/binhex"
            gnx="gnx"&gt;value
        &lt;/attr&gt;
        ...
    &lt;/at-file-attributes&gt;
    
In other words, we use the graphml &lt;attr&gt; element, extended with the
gnx attribute, to represent all the uA's in the descendants of @file nodes.
</t>
<t tx="ekr.20110427135155.14306">@language rest

- &lt;attr&gt; solves pickle problem.
</t>
<t tx="ekr.20110518103946.18179">http://groups.google.com/group/leo-editor/browse_thread/thread/93f2cc88ebbf9893

Would be ok with you if I pulled it into leoPy.leo, thereby adding sentinels to it? 
</t>
<t tx="ekr.20110524141405.18370"></t>
<t tx="ekr.20110526083709.18337">@nocolor-node

- Eliminate event.keysym from Leo's core: test only ev.char and ev.stroke.

* Never use g.bunch to represent an event!
    Create a proper way instead.
    
* Aha: replace event-related asserts (####) by x.check_event.
    That way we can degrade more gracefully.
    
* Define leoGui (base class) defaults for important methods.
    (Maybe?) override this in qtGui.

- Do *not* change the Tk names used to handle user bindings.
    Leave BackSpace,LineFeed,Return and Tab alone.
    Maybe the code should *also* always test for \b,\r,\n,\t.
    
- Replace w.event_generate by g.app.gui.event_generate everywhere.
    It should take only a stroke argument.
    It should be defined in subclasses?  Null gui, unitTestGui ?
    Remove angle brackets from strokes passed to event_generate.
    Create proper calls in numberCommand and executeNTimes.
        Actually, executeNTimes should just use the event.
    
- Rename leoKeyEvent to leoQtKeyEvent in qtGui.py.
    There is a *separate* leoKeyEvent in leoGui.py.
    Is it possible to eliminate leoKeyEvent ??

- Improve/rewrite the theory of operation.
</t>
<t tx="ekr.20110527084258.18374">http://groups.google.com/group/leo-editor/browse_thread/thread/9b1dbebd56d50e14/d5a690127ddad38e
 
"Sprint" isn't really the correct term.  We wrote no code.  Instead,
we discussed what seemed to each of us as the most important
directions for Leo.

After much pleasant discussion, we reached agreement, dreaded or not,
on just about everything. I'll summarize the topics here, and
elaborate about file format issues in a separate thread.

1.  (Done) Make .leo files as standards-compliant as possible.

This will demonstrate to newbies that we have some sophistication re
web standards, and it will allow external tools to handle .leo files
in the easiest possible way.

I've delegated the design of this project to Kent.  I'll be in charge
of implementation.

2. Simplify and revise Leo's file format.

Details in a separate thread: some items deserve just a bit more
discussion.  In particular, we want the about-to-be-renamed &lt;t&gt;
elements to contain headline text so that &lt;t&gt; elements represent key/
value pairs directly.  The question is, should the about-to-be-renamed
&lt;v&gt; elements contain headline text (readable, but "denormalized")?

3. Support reading and writing Leo outlines in JSON format.

This will allow closer cooperation with databases and other tools.
I'll do this.

4. Complete the transition to Terry's free_layout plugin.

A. Place separate body editors in free_layout areas.  This should
*easy* to do!  Almost nothing changes in the code, but the visual
effect should be much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane)
and "untabified."  There are a few details to be handled, but nothing
major.

Terry and I will collaborate on this.

5. Add global search to the quicksearch plugin and to Leo's find
command.

6. (Abandoned) Add node-specific undo asap.

The present undo is almost useless after a few levels.  Node-specific
undo would be much more useful. This has been on the list forever.  It
should be done yesterday.

7.  Rejected direct support for .ini files instead of Leo's @settings
nodes.

After some discussion we decided that the present .ini importer should
suffice.  In other words, it seems like a bad idea to support .ini
settings *instead* of, or in *addition* to, .ini files.  However,
scripts or commands to import/export Leo settings to one or more .ini
files would be fine.

8.  Make uA's first class citizens.

There should be commands to get and set uA's.  This is easy to do:
it's just an oversight.

Summary
=======

Looking back on the discussions, I am struck once again by how minor
the suggestions are.  Most of these items can be done in a day or two,
or a week or two at most.  The conclusion is that Leo has reached a
mature state.

Kent, Terry, did I omit anything?  Misstate anything? 
</t>
<t tx="ekr.20110527084258.18377"></t>
<t tx="ekr.20110527084258.18378">@nocolor-node

Stuff that got left out:
    
- Use uuid's?

- Remove spaces from user names.
</t>
<t tx="ekr.20110527105255.18386">def setUa (self,event):
    
    c,k = self.c,self.k
    tag = 'set-ua' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Set uA: ',protect=True)
            k.getArg(event,tag,1,self.setUa)
    elif state == 1:
        self.uaName = k.arg
        s = 'Set uA: %s To: ' % (self.uaName)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,tag,2,self.setUa,completion=False,prefix=s)
    else:
        assert state == 2,state
        val = k.arg
        d = c.p.v.u
        d[self.uaName] = val
        self.printUas()
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
</t>
<t tx="ekr.20110527182640.18357">Internally, everything will either be a unicode character or a KeyStroke object.
</t>
<t tx="ekr.20110527182640.18358"></t>
<t tx="ekr.20110528034751.18270">- Viewrendered @html is a good way to learn/debug .css.

- Study blender interface.
</t>
<t tx="ekr.20110528034751.18272">Collaborate with Terry.

A. Place separate body editors in free_layout areas. This should *easy* to
   do! Almost nothing changes in the code, but the visual effect should be
   much better.

B. Allow any pane to be "tabified" (placed in a tab in the Log pane) and
   "untabified." There are a few details to be handled, but nothing major.
   
C. Labels for panes.
</t>
<t tx="ekr.20110528034751.18273"></t>
<t tx="ekr.20110528034751.18278"></t>
<t tx="ekr.20110528103005.18319">import glob
import imp

theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes','*.py')
aList = glob.glob(theDir)
theDir = g.os_path_finalize_join(g.app.loadDir,'..','modes')

print('-'*40,len(aList))
known_keys = list(g.app.language_delims_dict.keys())
known_keys.sort()
known = []
computed = {}
for z in aList:
    name = g.os_path_basename(z)
    name2 = name[:-3]
    if name2.startswith('__'): continue
    # if name2 in known_keys:
        # known.append(name)
        # continue
    try:
        theFile, pathname, description = imp.find_module(name2,[theDir])
        m = imp.load_module(name2, theFile, pathname, description)
    except Exception:
        g.es_exception()
        m = None
    if m:
        aList2 = [m.properties.get(z)
            for z in ('lineComment','commentStart','commentEnd')
                if m.properties.get(z)]
        print('%-20s : "%s",' % (
            '"%s"' % (name2),
            ' '.join(aList2)))
        computed[name2] = ' '.join(aList2)
mismatches = 0
for z in known_keys:
    val = g.app.language_delims_dict.get(z)
    val2 = computed.get(z)
    if not val:
        print('oops: no val',z)
    elif not val2:
        print('oops: no val2',z)
    elif val != val2:
        mismatches += 1
        print('mismatch for %s' % z)
        print(repr(val))
        print(repr(val2))
print('%s total languages' % len(aList))
print('%s new languages' % (len(list(computed.keys())) - len(known_keys)))
print('%s mismatches' % mismatches)
print('%s known language: %s' % (len(known_keys),known_keys))
</t>
<t tx="ekr.20110528103005.18323"></t>
<t tx="ekr.20110530063322.18333"></t>
<t tx="ekr.20110530082209.18248">def replaceCurrentCharacter (self,event):

    c = self.c ; k = self.k ; tag = 'replace-current-character'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Replace Character: ',protect=True)
            k.getArg(event,tag,1,self.replaceCurrentCharacter)
    else:
        w = self.w
        ch = k.arg
        if ch:
            i,j = w.getSelectionRange()
            if i &gt; j: i,j = j,i
            # Use raw insert/delete to retain the coloring.
            if i == j:
                i = max(0,i-1)
                w.delete(i)
            else:
                w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
</t>
<t tx="ekr.20110531190516.19365">@language rest

</t>
<t tx="ekr.20110601105631.19373"></t>
<t tx="ekr.20110601105631.19374">Vi normally uses two different "current character" designators depending on the
current state.

Insert state:

In the Insert state, a vertical bar is placed between two characters to indicate
where the next key will be inserted. Leo's cursor is of this type.

Command state: 

In the Command state, vi expects that the cursor is highlighting a current
character and provides commands to enter the insert state or paste text either
before or after that current character. Leo's vi emulation currently does not
support a "current character" cursor. As a result, inserting and pasting before
or after is replaced by inserting or pasting "at" the current cursor location.
For example, the 'i' and 'a' command are both mapped to enter the insert state
at the current cursor location.
</t>
<t tx="ekr.20110601105631.19375"></t>
<t tx="ekr.20110601105631.19376"></t>
<t tx="ekr.20110601105631.19377">This project reorganizes makeBindingFromCommandsDict
</t>
<t tx="ekr.20110604043410.16734">For abbreviations, macros, registers, etc.

Look for the getPublicCommands methods in leoEditCommands.py
</t>
<t tx="ekr.20110604043410.16735">@nocolor-node

It is not a great idea to try to replace these.
It would have subtle effects everywhere and does not really simplify the core.
</t>
<t tx="ekr.20110604043410.16736"></t>
<t tx="ekr.20110604043410.16737"></t>
<t tx="ekr.20110604043410.17824">""" Patch utility to apply unified diffs

    Brute-force line-by-line non-recursive parsing 

    Copyright (c) 2008-2011 anatoly techtonik
    Available under the terms of MIT license

    Project home: http://code.google.com/p/python-patch/

    $Id: patch.py 117 2011-01-09 16:38:03Z techtonik $
    $HeadURL: https://python-patch.googlecode.com/svn/trunk/patch.py $
"""

@language python
@tabwidth -2

__author__ = "techtonik.rainforce.org"
__version__ = "11.01"

&lt;&lt; imports &gt;&gt;
&lt;&lt; global data &gt;&gt;

@others

if __name__ == "__main__":
  main()
</t>
<t tx="ekr.20110604043410.17826">def fromfile(filename):
  """ Parse patch file and return Patch() object
  """
  debug("reading %s" % filename)
  fp = open(filename, "rb")
  patch = Patch(fp)
  fp.close()
  return patch
</t>
<t tx="ekr.20110604043410.17827">def fromstring(s):
  """ Parse text string and return Patch() object
  """
  return Patch( StringIO(s) )
</t>
<t tx="ekr.20110604043410.17828">def fromurl(url):
  """ Read patch from URL
  """
  return Patch( urllib2.urlopen(url) )
</t>
<t tx="ekr.20110604043410.17829">class Hunk(object):

  """ Parsed hunk data container (hunk starts with @@ -R +R @@) """
  
  @others
</t>
<t tx="ekr.20110604043410.17830">def __init__(self):

  self.startsrc=None #: line count starts with 1
  self.linessrc=None
  self.starttgt=None
  self.linestgt=None
  self.invalid=False
  self.text=[]
</t>
<t tx="ekr.20110604043410.17831">def copy(self):
  
  return copy.copy(self)
</t>
<t tx="ekr.20110604043410.17832">class Patch(object):

  @others
</t>
<t tx="ekr.20110604043410.17833">def __init__(self, stream=None):

  # define Patch data members
  # table with a row for every source file

  #: list of source filenames
  self.source=None
  self.target=None
  #: list of lists of hunks
  self.hunks=None
  #: file endings statistics for every hunk
  self.hunkends=None
  #: headers for each file
  self.header=None

  #: patch type - one of constants
  self.type = None

  if stream:
    self.parse(stream)
</t>
<t tx="ekr.20110604043410.17834">def copy(self):
  
  return copy.copy(self)
</t>
<t tx="ekr.20110604043410.17835">def parse(self, stream):
  """ parse unified diff """
  self.header = []

  self.source = []
  self.target = []
  self.hunks = []
  self.hunkends = []

  lineends = dict(lf=0, crlf=0, cr=0)
  nextfileno = 0
  nexthunkno = 0    #: even if index starts with 0 user messages number hunks from 1

  # hunkinfo variable holds parsed values, hunkactual - calculated
  hunkinfo = Hunk()
  hunkactual = dict(linessrc=None, linestgt=None)
  
  @others # Define class wraumerate.

  # define states (possible file regions) that direct parse flow
  headscan  = True  # start with scanning header
  filenames = False # lines starting with --- and +++

  hunkhead = False  # @@ -R +R @@ sequence
  hunkbody = False  #
  hunkskip = False  # skipping invalid hunk mode

  hunkparsed = False # state after successfully parsed hunk

  # regexp to match start of hunk, used groups - 1,3,4,6
  re_hunk_start = re.compile("^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))?")
  
  # start of main cycle
  # each parsing block already has line available in fe.line
  fe = wrapumerate(stream)
  while fe.next():

    # -- deciders: these only switch state to decide who should process
    # --           line fetched at the start of this cycle
    if hunkparsed:
      hunkparsed = False
      if re_hunk_start.match(fe.line):
          hunkhead = True
      elif fe.line.startswith("--- "):
          filenames = True
      else:
          headscan = True
    # -- ------------------------------------

    # read out header
    if headscan:
      header = ''
      while not fe.is_empty and not fe.line.startswith("--- "):
          header += fe.line
          fe.next()
      if fe.is_empty:
          if len(self.source) == 0:
            warning("warning: no patch data is found")
          else:
            info("%d unparsed bytes left at the end of stream" % len(header))
          # this is actually a loop exit
          continue
      self.header.append(header)

      headscan = False
      # switch to filenames state
      filenames = True

    line = fe.line
    lineno = fe.lineno

    # hunkskip and hunkbody code skipped until definition of hunkhead is parsed
    if hunkbody:
      # process line first
      if re.match(r"^[- \+\\]", line):
          # gather stats about line endings
          if line.endswith("\r\n"):
            self.hunkends[nextfileno-1]["crlf"] += 1
          elif line.endswith("\n"):
            self.hunkends[nextfileno-1]["lf"] += 1
          elif line.endswith("\r"):
            self.hunkends[nextfileno-1]["cr"] += 1
            
          if line.startswith("-"):
            hunkactual["linessrc"] += 1
          elif line.startswith("+"):
            hunkactual["linestgt"] += 1
          elif not line.startswith("\\"):
            hunkactual["linessrc"] += 1
            hunkactual["linestgt"] += 1
          hunkinfo.text.append(line)
          # todo: handle \ No newline cases
      else:
          warning("invalid hunk no.%d at %d for target file %s" % (nexthunkno, lineno+1, self.target[nextfileno-1]))
          # add hunk status node
          self.hunks[nextfileno-1].append(hunkinfo.copy())
          self.hunks[nextfileno-1][nexthunkno-1]["invalid"] = True
          # switch to hunkskip state
          hunkbody = False
          hunkskip = True

      # check exit conditions
      if hunkactual["linessrc"] &gt; hunkinfo.linessrc or hunkactual["linestgt"] &gt; hunkinfo.linestgt:
          warning("extra lines for hunk no.%d at %d for target %s" % (nexthunkno, lineno+1, self.target[nextfileno-1]))
          # add hunk status node
          self.hunks[nextfileno-1].append(hunkinfo.copy())
          self.hunks[nextfileno-1][nexthunkno-1]["invalid"] = True
          # switch to hunkskip state
          hunkbody = False
          hunkskip = True
      elif hunkinfo.linessrc == hunkactual["linessrc"] and hunkinfo.linestgt == hunkactual["linestgt"]:
          # hunk parsed successfully
          self.hunks[nextfileno-1].append(hunkinfo.copy())
          # switch to hunkparsed state
          hunkbody = False
          hunkparsed = True

          # detect mixed window/unix line ends
          ends = self.hunkends[nextfileno-1]
          if ((ends["cr"]!=0) + (ends["crlf"]!=0) + (ends["lf"]!=0)) &gt; 1:
            warning("inconsistent line ends in patch hunks for %s" % self.source[nextfileno-1])
          if debugmode:
            debuglines = dict(ends)
            debuglines.update(file=self.target[nextfileno-1], hunk=nexthunkno)
            debug("crlf: %(crlf)d  lf: %(lf)d  cr: %(cr)d\t - file: %(file)s hunk: %(hunk)d" % debuglines)
          # fetch next line
          continue

    if hunkskip:
      if re_hunk_start.match(line):
        # switch to hunkhead state
        hunkskip = False
        hunkhead = True
      elif line.startswith("--- "):
        # switch to filenames state
        hunkskip = False
        filenames = True
        if debugmode and len(self.source) &gt; 0:
          debug("- %2d hunks for %s" % (len(self.hunks[nextfileno-1]), self.source[nextfileno-1]))

    if filenames:
      if line.startswith("--- "):
        if nextfileno in self.source:
          warning("skipping invalid patch for %s" % self.source[nextfileno])
          del self.source[nextfileno]
          # double source filename line is encountered
          # attempt to restart from this second line
        re_filename = "^--- ([^\t]+)"
        match = re.match(re_filename, line)
        # todo: support spaces in filenames
        if match:
          self.source.append(match.group(1).strip())
        else:
          warning("skipping invalid filename at line %d" % lineno)
          # switch back to headscan state
          filenames = False
          headscan = True
      elif not line.startswith("+++ "):
        if nextfileno in self.source:
          warning("skipping invalid patch with no target for %s" % self.source[nextfileno])
          del self.source[nextfileno]
        else:
          # this should be unreachable
          warning("skipping invalid target patch")
        filenames = False
        headscan = True
      else:
        if nextfileno in self.target:
          warning("skipping invalid patch - double target at line %d" % lineno)
          del self.source[nextfileno]
          del self.target[nextfileno]
          nextfileno -= 1
          # double target filename line is encountered
          # switch back to headscan state
          filenames = False
          headscan = True
        else:
          re_filename = "^\+\+\+ ([^\t]+)"
          match = re.match(re_filename, line)
          if not match:
            warning("skipping invalid patch - no target filename at line %d" % lineno)
            # switch back to headscan state
            filenames = False
            headscan = True
          else:
            self.target.append(match.group(1).strip())
            nextfileno += 1
            # switch to hunkhead state
            filenames = False
            hunkhead = True
            nexthunkno = 0
            self.hunks.append([])
            self.hunkends.append(lineends.copy())
            continue

    if hunkhead:
      match = re.match("^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))?", line)
      if not match:
        if nextfileno-1 not in self.hunks:
          warning("skipping invalid patch with no hunks for file %s" % self.target[nextfileno-1])
          # switch to headscan state
          hunkhead = False
          headscan = True
          continue
        else:
          # switch to headscan state
          hunkhead = False
          headscan = True
      else:
        hunkinfo.startsrc = int(match.group(1))
        hunkinfo.linessrc = 1
        if match.group(3): hunkinfo.linessrc = int(match.group(3))
        hunkinfo.starttgt = int(match.group(4))
        hunkinfo.linestgt = 1
        if match.group(6): hunkinfo.linestgt = int(match.group(6))
        hunkinfo.invalid = False
        hunkinfo.text = []

        hunkactual["linessrc"] = hunkactual["linestgt"] = 0

        # switch to hunkbody state
        hunkhead = False
        hunkbody = True
        nexthunkno += 1
        continue


  if not hunkparsed:
    if hunkskip:
      warning("warning: finished with warnings, some hunks may be invalid")
    elif headscan:
      if len(self.source) == 0:
        warning("error: no patch data found!")
        # ? sys.exit(-1)
      else: # extra data at the end of file
        pass 
    else:
      warning("error: patch stream is incomplete!")

  if debugmode and len(self.source) &gt; 0:
      debug("- %2d hunks for %s" % (len(self.hunks[nextfileno-1]), self.source[nextfileno-1]))

  debug("total files: %d  total hunks: %d" % (len(self.source), sum(len(hset) for hset in self.hunks)))
</t>
<t tx="ekr.20110604043410.17836">def apply(self):
  """ apply parsed patch
      return True on success
  """

  total = len(self.source)
  errors = 0
  for fileno, filename in enumerate(self.source):

    f2patch = filename
    if not exists(f2patch):
      f2patch = self.target[fileno]
      if not exists(f2patch):
        warning("source/target file does not exist\n--- %s\n+++ %s" % (filename, f2patch))
        errors += 1
        continue
    if not isfile(f2patch):
      warning("not a file - %s" % f2patch)
      errors += 1
      continue
    filename = f2patch

    debug("processing %d/%d:\t %s" % (fileno+1, total, filename))

    # validate before patching
    f2fp = open(filename)
    hunkno = 0
    hunk = self.hunks[fileno][hunkno]
    hunkfind = []
    hunkreplace = []
    validhunks = 0
    canpatch = False
    for lineno, line in enumerate(f2fp):
      if lineno+1 &lt; hunk.startsrc:
        continue
      elif lineno+1 == hunk.startsrc:
        hunkfind = [x[1:].rstrip("\r\n") for x in hunk.text if x[0] in " -"]
        hunkreplace = [x[1:].rstrip("\r\n") for x in hunk.text if x[0] in " +"]
        #pprint(hunkreplace)
        hunklineno = 0

        # todo \ No newline at end of file

      # check hunks in source file
      if lineno+1 &lt; hunk.startsrc+len(hunkfind)-1:
        if line.rstrip("\r\n") == hunkfind[hunklineno]:
          hunklineno+=1
        else:
          info("file %d/%d:\t %s" % (fileno+1, total, filename))
          info(" hunk no.%d doesn't match source file at line %d" % (hunkno+1, lineno))
          info("  expected: %s" % hunkfind[hunklineno])
          info("  actual  : %s" % line.rstrip("\r\n"))
          # not counting this as error, because file may already be patched.
          # check if file is already patched is done after the number of
          # invalid hunks if found
          # TODO: check hunks against source/target file in one pass
          #   API - check(stream, srchunks, tgthunks)
          #           return tuple (srcerrs, tgterrs)

          # continue to check other hunks for completeness
          hunkno += 1
          if hunkno &lt; len(self.hunks[fileno]):
            hunk = self.hunks[fileno][hunkno]
            continue
          else:
            break

      # check if processed line is the last line
      if lineno+1 == hunk.startsrc+len(hunkfind)-1:
        debug(" hunk no.%d for file %s  -- is ready to be patched" % (hunkno+1, filename))
        hunkno+=1
        validhunks+=1
        if hunkno &lt; len(self.hunks[fileno]):
          hunk = self.hunks[fileno][hunkno]
        else:
          if validhunks == len(self.hunks[fileno]):
            # patch file
            canpatch = True
            break
    else:
      if hunkno &lt; len(self.hunks[fileno]):
        warning("premature end of source file %s at hunk %d" % (filename, hunkno+1))
        errors += 1

    f2fp.close()

    if validhunks &lt; len(self.hunks[fileno]):
      if self._match_file_hunks(filename, self.hunks[fileno]):
        warning("already patched  %s" % filename)
      else:
        warning("source file is different - %s" % filename)
        errors += 1
    if canpatch:
      backupname = filename+".orig"
      if exists(backupname):
        warning("can't backup original file to %s - aborting" % backupname)
      else:
        import shutil
        shutil.move(filename, backupname)
        if self.write_hunks(backupname, filename, self.hunks[fileno]):
          info("successfully patched %d/%d:\t %s" % (fileno+1, total, filename))
          unlink(backupname)
        else:
          errors += 1
          warning("error patching file %s" % filename)
          shutil.copy(filename, filename+".invalid")
          warning("invalid version is saved to %s" % filename+".invalid")
          # todo: proper rejects
          shutil.move(backupname, filename)

  # todo: check for premature eof
  return (errors == 0)
</t>
<t tx="ekr.20110604043410.17837">def can_patch(self, filename):
  """ Check if specified filename can be patched. Returns None if file can
  not be found among source filenames. False if patch can not be applied
  clearly. True otherwise.

  :returns: True, False or None
  """
  idx = self._get_file_idx(filename, source=True)
  if idx == None:
    return None
  return self._match_file_hunks(filename, self.hunks[idx])
</t>
<t tx="ekr.20110604043410.17838">def _match_file_hunks(self, filepath, hunks):
  matched = True
  fp = open(abspath(filepath))

  class NoMatch(Exception):
    pass

  lineno = 1
  line = fp.readline()
  hno = None
  try:
    for hno, h in enumerate(hunks):
      # skip to first line of the hunk
      while lineno &lt; h.starttgt:
        if not len(line): # eof
          debug("check failed - premature eof before hunk: %d" % (hno+1))
          raise NoMatch
        line = fp.readline()
        lineno += 1
      for hline in h.text:
        if hline.startswith("-"):
          continue
        if not len(line):
          debug("check failed - premature eof on hunk: %d" % (hno+1))
          # todo: \ No newline at the end of file
          raise NoMatch
        if line.rstrip("\r\n") != hline[1:].rstrip("\r\n"):
          debug("file is not patched - failed hunk: %d" % (hno+1))
          raise NoMatch
        line = fp.readline()
        lineno += 1

  except NoMatch:
    matched = False
    # todo: display failed hunk, i.e. expected/found

  fp.close()
  return matched
</t>
<t tx="ekr.20110604043410.17839">def patch_stream(self, instream, hunks):
  """ Generator that yields stream patched with hunks iterable
  
      Converts lineends in hunk lines to the best suitable format
      autodetected from input
  """

  # todo: At the moment substituted lineends may not be the same
  #       at the start and at the end of patching. Also issue a
  #       warning/throw about mixed lineends (is it really needed?)

  hunks = iter(hunks)

  srclineno = 1

  lineends = {'\n':0, '\r\n':0, '\r':0}
  def get_line():
    """
    local utility function - return line from source stream
    collecting line end statistics on the way
    """
    line = instream.readline()
      # 'U' mode works only with text files
    if line.endswith("\r\n"):
      lineends["\r\n"] += 1
    elif line.endswith("\n"):
      lineends["\n"] += 1
    elif line.endswith("\r"):
      lineends["\r"] += 1
    return line

  for hno, h in enumerate(hunks):
    debug("hunk %d" % (hno+1))
    # skip to line just before hunk starts
    while srclineno &lt; h.startsrc:
      yield get_line()
      srclineno += 1

    for hline in h.text:
      # todo: check \ No newline at the end of file
      if hline.startswith("-") or hline.startswith("\\"):
        get_line()
        srclineno += 1
        continue
      else:
        if not hline.startswith("+"):
          get_line()
          srclineno += 1
        line2write = hline[1:]
        # detect if line ends are consistent in source file
        if sum([bool(lineends[x]) for x in lineends]) == 1:
          newline = [x for x in lineends if lineends[x] != 0][0]
          yield line2write.rstrip("\r\n")+newline
        else: # newlines are mixed
          yield line2write
   
  for line in instream:
    yield line
</t>
<t tx="ekr.20110604043410.17840">def write_hunks(self, srcname, tgtname, hunks):
  src = open(srcname, "rb")
  tgt = open(tgtname, "wb")

  debug("processing target file %s" % tgtname)

  tgt.writelines(self.patch_stream(src, hunks))

  tgt.close()
  src.close()
  return True
</t>
<t tx="ekr.20110604043410.17841">def _get_file_idx(self, filename, source=None):

  """ Detect index of given filename within patch.

      :param filename:
      :param source: search filename among sources (True),
                     targets (False), or both (None)
      :returns: int or None
  """
  filename = abspath(filename)
  if source == True or source == None:
    for i,fnm in enumerate(self.source):
      if filename == abspath(fnm):
        return i  
  if source == False or source == None:
    for i,fnm in enumerate(self.target):
      if filename == abspath(fnm):
        return i  


</t>
<t tx="ekr.20110604043410.17842">def main():
  
  from optparse import OptionParser
  from os.path import exists
  import sys

  opt = OptionParser(usage="1. %prog [options] unipatch-file\n"
                    "       2. %prog [options] http://host/patch",
                     version="python-patch %s" % __version__)
  opt.add_option("-q", "--quiet", action="store_const", dest="verbosity",
                                  const=0, help="print only warnings and errors", default=1)
  opt.add_option("-v", "--verbose", action="store_const", dest="verbosity",
                                  const=2, help="be verbose")
  opt.add_option("--debug", action="store_true", dest="debugmode", help="debug mode")
  (options, args) = opt.parse_args()

  if not args:
    opt.print_version()
    opt.print_help()
    sys.exit()
  debugmode = options.debugmode

  verbosity_levels = {0:logging.WARNING, 1:logging.INFO, 2:logging.DEBUG}
  loglevel = verbosity_levels[options.verbosity]
  logformat = "%(message)s"
  if debugmode:
    loglevel = logging.DEBUG
    logformat = "%(levelname)8s %(message)s"
  logger.setLevel(loglevel)
  loghandler.setFormatter(logging.Formatter(logformat))


  patchfile = args[0]
  urltest = patchfile.split(':')[0]
  if (':' in patchfile and urltest.isalpha()
      and len(urltest) &gt; 1): # one char before : is a windows drive letter
    patch = fromurl(patchfile)
  else:
    if not exists(patchfile) or not isfile(patchfile):
      sys.exit("patch file does not exist - %s" % patchfile)
    patch = fromfile(patchfile)

  #pprint(patch)
  patch.apply() or sys.exit(-1)

  # todo: document and test line ends handling logic - patch.py detects proper line-endings
  #       for inserted hunks and issues a warning if patched file has incosistent line ends
</t>
<t tx="ekr.20110604043410.17843">
import copy
import logging
import re
# cStringIO doesn't support unicode in 2.5
from StringIO import StringIO
import urllib2

from os.path import exists, isfile, abspath
from os import unlink
</t>
<t tx="ekr.20110604043410.17844"># Logging is controlled by "python_patch" logger

debugmode = False
logger = logging.getLogger("python_patch")
loghandler = logging.StreamHandler()
logger.addHandler(loghandler)
debug = logger.debug
info = logger.info
warning = logger.warning

#: disable library logging by default
logger.setLevel(logging.CRITICAL)

# constants for patch types

DIFF = PLAIN = "plain"
HG = MERCURIAL = "mercurial"
SVN = SUBVERSION = "svn"
</t>
<t tx="ekr.20110604043410.17845"></t>
<t tx="ekr.20110604043410.17846">class wrapumerate(enumerate):
  """Enumerate wrapper that uses boolean end of stream status instead of
  StopIteration exception, and properties to access line information.
  """

  def __init__(self, *args, **kwargs):
    # we don't call parent, it is magically created by __new__ method

    self._exhausted = False
    self._lineno = False     # after end of stream equal to the num of lines
    self._line = False       # will be reset to False after end of stream

  def next(self):
    """Try to read the next line and return True if it is available,
       False if end of stream is reached."""
    if self._exhausted:
      return False

    try:
      self._lineno, self._line = super(wrapumerate, self).next()
    except StopIteration:
      self._exhausted = True
      self._line = False
      return False
    return True

  @property
  def is_empty(self):
    return self._exhausted

  @property
  def line(self):
    return self._line

  @property
  def lineno(self):
    return self._lineno
</t>
<t tx="ekr.20110604043410.17847">#  def apply(self, estream):
#    """ write hunk data into enumerable stream
#        return strings one by one until hunk is
#        over
#
#        enumerable stream are tuples (lineno, line)
#        where lineno starts with 0
#    """
#    pass
</t>
<t tx="ekr.20110604043410.17848">import leo.extensions.patch_11_01 as patch

fn = 'xyzzy.patch'

if g.os_path_exists(fn):
    patch.fromfile(fn)
else:
    g.es_print('not found:',fn)
</t>
<t tx="ekr.20110604043410.17850">@nocolor-node

- &lt;attr&gt;

- patch command

- macros
</t>
<t tx="ekr.20110604182206.16752">@language rest

As part of killing Tk I shall simplify how Leo's Qt gui reports keys to the
core.  The general design will be as follows:

1. The leoKeyEvent class will be strengthened. The following improvements will be done
   in leoKeyEvent or its precursors in eventFilter.

2. There will be several "invariants" that the core will depend on:

A. event.ch will be empty except for characters that will, by default, be
   inserted into body text. This includes all printable ascii characters and any
   unicode characters, but does *not* include any ctrl/alt/meta characters.

**Important**: there may be (will be) clashes between some unicode characters
and alt/ctrl/meta characters.  I know of no way to "guess" what is meant, so all
such characters, or at least all such characters with Leo bindings, will be
treated as non-printable. 

B. event.ch will contain the *actual character* represented by the event. In
   particular, it will contain '\t', not 'Tab', '\n', not 'Return', '.', not
   'period', etc., etc.

C. event.stroke will contain the "standard" spelling of the key. As before,
   k.masterKeyHandler will use the stroke to determine the binding in effect for
   the key. There will be no substantial changes to k.masterKeyHandler, except
   as required by invariant B.

The effect of these invariants is that Leo's core will not have to do AI to
determine what character an event refers to.  If event.ch is non-empty, the
character can be inserted (modulo any plain-key bindings).  Otherwise, the
stroke tells everything there is to be known about the key event. 

For example, k.isPlainKey will become trivial, or better, unnecessary.

None of this can be done easily while Tk exists.  After the work is done, the
work will become a new "standard" that future gui's can implement. 
</t>
<t tx="ekr.20110604182206.16753">@nocolor-node

- kev: keyboard event.

- regex for keys to translate to corresponding ascii characters:
    
    '\b','\r','\n','\t'
    
    see k.defineTkNames
    
    ['"]backspace|linefeed|return|tab['"]


- Calls to k.masterKeyHander:
    - Several calls involving macros.
    - Only one call in qtGui.py: in eventFilter.
        - This is very good: it means that *all* calls to k.masterKeyHandler
          can use a *single* kev argument.  This will simplify macro handling.

- Candidates for removal:
    - makeMasterGuiBinding
    - event_generate:
        - used by number_command.
        - Probably could be rewritten, or maybe eliminated entirely using kev instead of stroke.
    - onChar: must be defined in subclasses.
        - Does this really call QTabWidget.onChar??
</t>
<t tx="ekr.20110604182206.16755"></t>
<t tx="ekr.20110604182206.16757"></t>
<t tx="ekr.20110604182206.16758">@nocolor-node

1. kev.keysym is always the same as kev.ch.
   We should be able to remove kev.keysym from Leo's core:
   It's very confusing.
   
2. (Optional): Replace BackSpace,LineFeed,Return,Tab by \b,\r,\n,\t.
   This would be easy to do: remove the entires in k.defineTkNames.
   However, it really is not important.
   
3. (Important): Use only a single kev arg to k.masterKeyHandler.
   This simplifies the macro handling.
   
4. (Useful): define kev.isPlain() and use it instead of k.isPlainKey.
   This is a much better encapsulation.
</t>
<t tx="ekr.20110604182206.16760"></t>
<t tx="ekr.20110604182206.16761"></t>
<t tx="ekr.20110604182206.16762"></t>
<t tx="ekr.20110604182206.16763"></t>
<t tx="ekr.20110604182206.16764"></t>
<t tx="ekr.20110604182206.16765"></t>
<t tx="ekr.20110604182206.16766">@nocolor-node

Added assert that event.keysym == event.char  Marked with ####</t>
<t tx="ekr.20110604182206.16768">@nocolor-node

Theres should be an event arg for all calls.
### Marks where I changed the code to propagate an event arg from caller.</t>
<t tx="ekr.20110605040658.17004"></t>
<t tx="ekr.20110605040658.17005">def check_event (self,event):
    
    # assert not event or event.keysym == event.char,repr(event)
    
    if event:
        if g.unitTesting:
            # assert isinstance(event,leoKeyEvent)
                ### Will fail for g.bunches.
            assert event.keysym == event.char,repr(event)
            for ivar in ('char','keysym','stroke',): # 'stroke',
                assert hasattr(event,ivar),'event: %s, ivar: %s, callers: %s' % (
                    event,ivar,g.callers())
        else:
            if event.keysym != event.char:
                g.trace('can not happen: keysym != event.char',
                    repr(event.keysym),repr(event.char),event)
            for ivar in ('char','keysym',): # 'stroke',
                if not hasattr(event,ivar):
                    g.trace('can not happen: not hasattr(event,%s) event: %s' % (
                        ivar,event))
</t>
<t tx="ekr.20110605065044.17008">http://groups.google.com/group/leo-editor/browse_thread/thread/3f15a855ca38b26e

</t>
<t tx="ekr.20110605065044.17009"></t>
<t tx="ekr.20110605121601.17012"></t>
<t tx="ekr.20110605121601.17013"></t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.</t>
<t tx="ekr.20110605121601.18695"></t>
</tnodes>
</leo_file>
