<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://webpages.charter.net/edreamleo/front.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20110607155823.16449"><vh>@chapters</vh></v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
<v t="ekr.20100902154544.5872"><vh>@bool enable-abbreviations = True</vh></v>
<v t="ekr.20111123042248.12701"><vh>@@@enabled-plugins</vh></v>
<v t="ekr.20111031081007.9985"><vh>@shortcuts</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20130412022445.12389"><vh>Next actions</vh>
<v t="ekr.20130510070942.10609"><vh>Organization</vh></v>
<v t="ekr.20130510070942.10603"><vh>Ask</vh>
<v t="ekr.20130411131638.10311"><vh>* Ask the qt people about leaving foreground text unchanged</vh></v>
<v t="ekr.20130510070942.10604"><vh>* Ask NSIS people about install bug</vh></v>
</v>
<v t="ekr.20130510070942.10602"><vh>Docs</vh>
<v t="ekr.20130506071114.15452"><vh>***Document Windows associations</vh></v>
<v t="ekr.20130502104323.10581"><vh>** Get github working</vh></v>
<v t="ekr.20130503155210.24819"><vh>Fix flattr button on Leo's home page</vh></v>
<v t="ekr.20130503053253.10548"><vh>Draft: unit testing tutorial</vh></v>
<v t="ekr.20130514082726.10612"><vh>Document valuespace from Ville's blog</vh></v>
<v t="ekr.20130521062549.10856"><vh>Position tutorial</vh>
<v t="ekr.20130521122236.15095"><vh>other info</vh></v>
</v>
</v>
<v t="ekr.20130510070942.10605"><vh>Install</vh>
<v t="ekr.20130508134143.10598"><vh>Leo for portableapps?</vh></v>
</v>
<v t="ekr.20130510070942.10606"><vh>Bugs</vh>
<v t="ekr.20130503134311.13447"><vh>Fix all pylint complaints</vh></v>
<v t="ekr.20130502102046.10578"><vh>Crash deleting body editor</vh></v>
</v>
<v t="ekr.20130506071114.15468"><vh>Cool scripts to put **somewhere**</vh>
<v t="ekr.20130506071114.15469"><vh>push_to_Gist.txt</vh></v>
<v t="ekr.20130508084413.10638"><vh>cool hack: detach body editor</vh></v>
<v t="ekr.20130508084413.10648"><vh>Call hierarchy tracing (using python 'trace' module)</vh></v>
</v>
<v t="ekr.20130510070942.10611"><vh>Can undo headline put focus in headline?</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
<v t="ekr.20111124095033.10203"><vh>@edit bzr_version.py</vh></v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20100120092047.6087"><vh>@file ../external/ipy_leo.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py </vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@file leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005506302e31352e3071017d71025808000000616e6e6f7461746571037d710473732e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20111116103733.9817"><vh>@file leoInspect.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285505302e332e3271017d71022858090000007374725f6374696d657103580c000000313331393436303438332e30710458090000007374725f6d74696d657105580d000000313331393436373035302e3438710658090000007374725f6174696d657107580d000000313331393436373035302e34387108755505302e332e3371097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313332303432323639302e3534710e58090000007374725f6174696d65710f580d000000313332303433343235372e33367110755505302e332e3071117d71122858090000007374725f6374696d657113580c000000313331393439313330362e30711458090000007374725f6d74696d657115580d000000313331393439323330312e3532711658090000007374725f6174696d657117580d000000313331393534393339302e38397118755505302e332e3171197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313331393436373033382e3235711e58090000007374725f6174696d65711f580c000000313332303432323637302e397120755505302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755505302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20110605121601.17863"><vh>@file ../plugins/baseNativeTree.py</vh></v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qtframecommands.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20110605121601.18695"><vh>QDesigner files</vh>
<v t="ekr.20110605121601.18696"><vh>@auto ../test/qtui_generate.py</vh></v>
<v t="ekr.20110605121601.18698"><vh>@auto ../plugins/qt_main.py</vh></v>
<v t="ekr.20110605121601.18703"><vh>@auto ../plugins/qt_main.ui</vh></v>
<v t="ekr.20110605121601.18704"><vh>@auto ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20110605121601.18709"><vh>@auto ../plugins/qt_quicksearch.ui</vh></v>
</v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@file leoTest.py</vh></v>
</v>
</v>
<v t="ekr.20130521122236.10867"><vh>Test p.deletePositionsInList</vh>
<v t="ekr.20100802121531.5804"><vh>p.deletePositionsInList</vh></v>
</v>
<v t="ekr.20130522131838.15047"><vh>position script</vh></v>
<v t="ekr.20130521122236.15099"><vh>Ask about installer bug</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e">@tabwidth -4
@pagewidth 70

@ 
This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a vnode
z:  a local temp.

In more limited contexts, the following conventions apply:
    
si: a g.ShortcutInfo object.
ks: a g.KeyStroke object
stroke: a KeyStroke object.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2604">
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily. 

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass. 

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.
  
- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction. 
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20100802121531.5804">def deletePositionsInList (self,aList,callback=None):

    '''Traverse the tree starting from self until all nodes in aList have been
    found.

    This method calls the callback for any position in aList found in the range,
    excluding any node whose ancestor has already been passed to the callback.

    The callback takes one explicit argument, p. As usual, the callback can bind
    values using keyword arguments. The callback may delete p or move p out of
    the range. The callback **must not** move p within range of the traversal.
    If no callback is given, this method deletes all found nodes.
    '''

    if callback is None:
        def callback_f(p):
            p.doDelete(newNode=None)
    else:
        callback_f = callback # To keep pylint happy.

    p = self.copy()
    while p and aList:
        # g.trace(repr(p))
        if p in aList:
            aList.remove(p)
            for z in aList:
                if p.isAncestorOf(z):
                    aList.remove(z)
            next = p.nodeAfterTree()
            callback_f(p.copy())
            p = next
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20100902154544.5872"></t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.</t>
<t tx="ekr.20110605121601.18695"></t>
<t tx="ekr.20110607155823.16449"></t>
<t tx="ekr.20111031081007.9985">run-selected-unit-tests-externally = Alt-4 # Standard binding, unchanged.
run-marked-unit-tests-externally = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20111123042248.12701"># Leo loads plugins in the order they appear here.

# Highly-recommended plugins:

plugins_menu.py
free_layout.py # needs to be early
viewrendered.py
mod_scripting.py
bigdash.py
</t>
<t tx="ekr.20130411131638.10311"></t>
<t tx="ekr.20130412022445.12389">@language rest

Priorities:
- Organization
- Installation
- Documentation
- Bugs/Code
</t>
<t tx="ekr.20130502102046.10578"># Trying to delete a second body editor.

Traceback (most recent call last):
  File "c:\leo.repo\trunk\leo\core\leoCommands.py", line 560, in doCommand
    val = command(event)
  File "c:\leo.repo\trunk\leo\plugins\qtGui.py", line 2980, in deleteEditor
    name = w.leo_name
AttributeError: 'LeoQTextBrowser' object has no attribute 'leo_name'
</t>
<t tx="ekr.20130502104323.10581">Used for Leo's blog.

bzr ci =&gt; git commit -a
bzr add =&gt; git add
bzr push =&gt; git push
bzr revert =&gt; git reset --hard
</t>
<t tx="ekr.20130503053253.10548">@wrap
@language rest

The following is a first draft of a unit-testing tutorial.  It will form the basis of a new help-for-unit-testing command, and will also become the introduction to Leo unit-testing chapter.

All comments are welcome.  Please let me know if anything is unclear.


------------------

.. |br| raw:: html

   &lt;br /&gt;

Leo makes it easy to create unit tests from individual outline nodes or trees.

A node whose headline starts with @tests defines a unit test.

The body text of the @test node contains a **self-contained** unit test.

For example, this creates a complete unit test::

    @test fails  (headline)
    assert False (body text)

To run this test, select the @test node and do: |br|
&lt;alt-x&gt;run-selected-unit-tests-locally. |br|
Leo will create and run the unit test automatically.

To see all of Leo's unit testing commands, do: |br|
&lt;alt-x&gt;run&lt;tab&gt;

Leo pre-defines 'c', 'g' and 'p' in unit tests just as in scripts.

@test nodes may use section references and \@others
as usual, but unit tests may also put test data 
in child nodes.

For more details about unit testing, see:
http://leoeditor.com/unitTesting.html

**Notes for Leo developers**

leo/test/unitTest.leo contains all of Leo's own unit tests.

Running all tests is not necessary.  Just select::

    Active Unit Tests

and then do Alt-4 (run-selected-unit-tests-locally).

**Note**: Some tests will likely fail on machines other than EKR's. You only need to be concerned about unit tests that start failing after you make your changes.
</t>
<t tx="ekr.20130503134311.13447">@nocolor-node

************* Module leo.core.leoFrame
E1101:1066,0:leoBody.pyflake_test: Instance of 'leoBody' has no 'xyzzy22' member
E1101:1069,0:leoBody.pyflake_test: Instance of 'leoBody' has no 'def_stack' member

************* Module leo.core.leoGlobals
W0108:5375,0:find_constants_defined.&lt;lambda&gt;: Lambda may not be necessary

************* Module leo.plugins.qtGui
W0101:2781,0:leoQtBody.setEditorColors: Unreachable code
W0403:7485,0:leoQtGui.runWithIpythonKernel:
    Relative import 'internal_ipkernel', should be 'leo.plugins.internal_ipkernel'
</t>
<t tx="ekr.20130503155210.24819"></t>
<t tx="ekr.20130506071114.15452">
Installing Leo on Windows

    Install Python from http://www.python.org/download/releases/

    Install either Tk or Qt, as described above.

    Install Leo. Get Leo’s .zip file from http://sourceforge.net/projects/leo/ You can unpack the .zip file anywhere, including Python’s site-packages folder, for example, C:\Python26\Lib\site-packages

    [optional] Generate/update a junction link from unpacked leo folder to ...\site-packages\leo:

    cd C:\Python26\Lib\site-packages\
    junction leo leo-4-6-2-final

    Create windows shortcut (edit paths as necessary):

    Target   =  C:\Python26\pythonw.exe "C:\Python26\Lib\site-packages\leo\launchLeo.py"
    Start in =  D:\code

    Associate .leo filetype batch file:

    ftype LeoFile=C:\Python26\pythonw.exe "C:\Python26\Lib\site-packages\leo\launchLeo.py" "%*"
    assoc .leo=LeoFile

    [optional] Put this leo.bat in %PATH%:

    @C:\Python26\python.exe "C:\Python26\Lib\site-packages\leo\launchLeo.py" %*

For more information see:

Junction links:
    http://technet.microsoft.com/en-gb/sysinternals/bb896768.aspx,
    http://groups.google.com/group/leo-editor/msg/30116f9193241dc4
ftype:
    http://ss64.com/nt/ftype.html
assoc:
    http://ss64.com/nt/assoc.html

</t>
<t tx="ekr.20130506071114.15468"></t>
<t tx="ekr.20130506071114.15469"># Leo button to publish selected node as Gist.
# https://groups.google.com/forum/?fromgroups=#!topic/leo-editor/KgejcZHiEl0

import requests
import json

tmp = g.os.environ['TEMP']

description = "published from Leo"
public = True
filename = p.h      # node headline
content = p.b       # node body

g.es(filename)
print('\n\n--- %s ---' % filename)
payload = {
    'description': description,
    'public': public,
    'files': {
        filename: {'content': content}
        }
    }
           
print (payload)
r = requests.post('https://api.github.com/gists',  data=json.dumps(payload))
print (r.status_code)
print (r.text)
</t>
<t tx="ekr.20130508084413.10638">http://groups.google.com/group/leo-editor/browse_thread/thread/8616f4e171e1a24b

This features a long an important discussion of using Leo with vim.
</t>
<t tx="ekr.20130508084413.10648">@language python
@tabwidth -4

"""
Analyzing program flow.

Run (ctrl+b) this script after 

cd ~/leo-editor
python -m trace --trackcalls launchLeo.py --gui=qt &gt;trace.txt

"""

tracefile = '~/leo-editor/trace.txt'

import os

tr = open(os.path.expanduser(tracefile))
print tr
top = p.insertAsLastChild().copy()
top.h = 'trace session'
cur = None
no = None
for l in tr:
    if l.startswith('***'):
        cur = top.insertAsLastChild().copy()
        cur.h = os.path.basename(l.split()[1])
    elif l.startswith('  --&gt;'):
        no = cur.insertAsLastChild().copy()
        no.h = os.path.basename(l.split()[1].strip())
    else:
        if no:
            no.b += l.strip() + '\n'

    print ".",
</t>
<t tx="ekr.20130508134143.10598"></t>
<t tx="ekr.20130510070942.10602"></t>
<t tx="ekr.20130510070942.10603"></t>
<t tx="ekr.20130510070942.10604"></t>
<t tx="ekr.20130510070942.10605"></t>
<t tx="ekr.20130510070942.10606"></t>
<t tx="ekr.20130510070942.10609"></t>
<t tx="ekr.20130510070942.10611">This would fix a reported bug.
</t>
<t tx="ekr.20130514082726.10612">http://leo-editor.github.io/valuespace-intro.html
</t>
<t tx="ekr.20130521062549.10856">@language rest

A **position** object represents a specific node in a Leo outline.

Equivalently, a position represents the state of a Leo generator, that is,
a specific node during a traversal of a Leo outline.

Because of clones, a node may appear arbitrarily many times in an outline,
so a node may appear at arbitrarily many positions in the outline.

For any position p, **p.v** is the vnode at position p.

A node's vnode never changes, regardless of where the node appears in the
outline, and regardless of whether the node is cloned or not.

**Positions become invalid when the outline changes.**

You may save and and use positions *provided* the outline remains unchanged.

Leo's generators deliver positions, one after each other, using a *single*
(ever-changing) position. As a result, scripts must use p.copy() to create
lists of positions. For example::

    aList = [p.copy() for p in c.rootPosition().subtree()]
</t>
<t tx="ekr.20130521122236.10867"># Deleting all childs of a node:
# https://groups.google.com/forum/?fromgroups#!topic/leo-editor/IR8tV9a99NY</t>
<t tx="ekr.20130521122236.15095">Consider this example, where nodes with the same names are clones of each other::

+ Root
    + A
        - B
    + A
        - B
    - B

Leo's c.all_nodes() iterator will deliver 9 positions:

    1: Root
    2: A
    3: B
    4: A
    5: B
    6: B

*All* positions returned by a traversal are distinct.  Some examples:

- Position 2: A is different from position 4: A
  The former is the first child of root; the latter is the second child of root.
  
- The parent of position 3: B is A at childIndex 0 of Root.
  The parent of position 5: B is A at childIndex 1 of Root.
  The parent of position 6: B is Root. The childIndex of 6: B is 2.

</t>
<t tx="ekr.20130521122236.15099">@nocolor-node

# https://bugs.launchpad.net/leo-editor/+bug/1021849

I just installed Leo 4.10 final, using the installer, on Win 7. It creates
a desktop icon, but no lion picture showed up. I tried changing the icon,
and got a message that the current path to the icon was not existing. It
appears there was a colon lacking right after the drive letter C. After
browsing for the icon in the right folder the icon showed up of course.</t>
<t tx="ekr.20130522131838.15047">g.cls()
root = g.findNodeAnywhere(c,'root')
assert root
line = 0
for p in root.self_and_subtree():
    line += 1
    print('%s: %4s @ %d p._childIndex: %d p.stack: %s' % (
        line,
        p.cleanHeadString(),
        id(p.v),
        p._childIndex,
        # p.level(),p.key(),
        # p.stack,
        '[%s]' % ', '.join(['(v:%s @ %s, %s)' % (v.h,id(v),i) for v,i in p.stack]),
    ))
</t>
</tnodes>
</leo_file>
