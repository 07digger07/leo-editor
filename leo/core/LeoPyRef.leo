<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20160122104332.1"><vh>Buttons</vh>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183832.1"><vh>define_s</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150531102337.1"><vh>@bool tidy-keep-blank-lines = False</vh></v>
<v t="ekr.20150617060607.1"><vh>@bool tidy_autobeautify = False</vh></v>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
</v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20140919093158.17876"><vh>@int max-pre-loaded-body-chars = 0</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20140923085942.17943"><vh>Recent scripts</vh>
<v t="ekr.20140905060158.18560"><vh>Script: change body.x to body.wrapper.x</vh>
<v t="ekr.20140905060158.18561"><vh>test</vh></v>
</v>
<v t="ekr.20140918124632.19450"><vh>Script: print Qt color names</vh></v>
<v t="ekr.20160315161104.1"><vh>@test rt</vh>
<v t="ekr.20160315163533.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
</v>
<v t="ekr.20160316065700.1"><vh>@@file ../test/report_test.py</vh>
<v t="ekr.20160316065936.1"><vh>&lt;&lt; includes &gt;&gt;</vh></v>
<v t="ekr.20160316070146.1"><vh>class TestClass</vh>
<v t="ekr.20160316070255.1"><vh>if_tests</vh></v>
<v t="ekr.20160316070709.1"><vh>comprehension_tests</vh></v>
<v t="ekr.20160316081359.1"><vh>try_tests</vh></v>
</v>
</v>
<v t="ekr.20160316100329.1"><vh>@@button py2cs</vh>
<v t="ekr.20160316100524.1"><vh>cmd</vh></v>
<v t="ekr.20160316091923.1"><vh>ccc.python-to-coffeescript</vh>
<v t="ekr.20160316092837.1"><vh>class Python_To_Coffeescript_Adapter</vh>
<v t="ekr.20160316112717.1"><vh>py2cs.ctor</vh></v>
<v t="ekr.20160316093019.1"><vh>py2cs.main</vh></v>
<v t="ekr.20160316094011.7"><vh>py2cs.finalize</vh></v>
<v t="ekr.20160316094011.8"><vh>py2cs.to_coffeescript</vh></v>
<v t="ekr.20160316094011.9"><vh>py2cs.run</vh></v>
<v t="ekr.20160316141812.1"><vh>py2cs.strip_sentinels</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329" descendentVnodeUnknownAttributes="7d71005805000000302e312e3071017d7102285808000000616e6e6f7461746571037d710428580a000000707269736574646174657105580a000000323031352d30352d3237710658080000007072696f7269747971074d0f2775580b0000006c696e65594f666673657471084b0075732e"><vh>@file ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20150605175037.1"><vh>@file leoCheck.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh>
<v t="ekr.20140827092102.18575"><vh>&lt;&lt; imports &gt;&gt; (leoColorizer.py)</vh></v>
<v t="ekr.20140825132752.18554"><vh>&lt;&lt; class PythonQSyntaxHighlighter &gt;&gt;</vh>
<v t="ekr.20140825132752.18561"><vh>pqsh.Birth &amp; death</vh></v>
<v t="ekr.20140825132752.18588"><vh>pqsh.Entry points</vh>
<v t="ekr.20140827112712.18469"><vh>pqsh.kill</vh></v>
<v t="ekr.20140825132752.18566"><vh>pqsh.rehighlight</vh></v>
<v t="ekr.20140825132752.18568"><vh>pqsh.rehighlightBlock (not used)</vh></v>
<v t="ekr.20140825132752.18591"><vh>pqsh.rehighlight_helper</vh></v>
</v>
<v t="ekr.20140825132752.18590"><vh>pqsh.Getters &amp; Setters</vh>
<v t="ekr.20140825132752.18582"><vh>pqsh.currentBlock &amp; currentBlockUserData</vh></v>
<v t="ekr.20140825132752.18580"><vh>pqsh.currentBlockState &amp; previousBlockState</vh></v>
<v t="ekr.20140825132752.18565"><vh>pqsh.document</vh></v>
<v t="ekr.20140825132752.18575"><vh>pqsh.format</vh></v>
<v t="ekr.20140825132752.18576"><vh>pqsh.setCurrentBlockState &amp; setCurrentBlockUserData</vh></v>
<v t="ekr.20140825132752.18564"><vh>pqsh.setDocument</vh></v>
<v t="ekr.20140825132752.18584"><vh>pqsh.setFormat (start,count,format)</vh></v>
</v>
<v t="ekr.20140825132752.18589"><vh>pqsh.Helpers</vh>
<v t="ekr.20140825132752.18557"><vh>pqsh.applyFormatChanges</vh></v>
<v t="ekr.20140825132752.18592"><vh>pqsh.delayedRehighlight</vh></v>
<v t="ekr.20140826120657.18649"><vh>pqsh.format_to_color</vh></v>
<v t="ekr.20140826120657.18650"><vh>pqsh.highlightBlock</vh></v>
<v t="ekr.20140827063632.18569"><vh>pqsh.idle_handler</vh></v>
<v t="ekr.20140826120657.18648"><vh>pqsh.is_valid</vh></v>
<v t="ekr.20140825132752.18558"><vh>pqsh.q_reformatBlocks</vh></v>
<v t="ekr.20140827074435.18570"><vh>pqsh.reformat_blocks_helper</vh></v>
<v t="ekr.20140825132752.18560"><vh>pqsh.reformatBlock</vh></v>
<v t="ekr.20140825132752.18559"><vh>pqsh.reformatBlocks (main line)</vh></v>
</v>
</v>
<v t="ekr.20140906081909.18690"><vh>class ColorizerMixin</vh>
<v t="ekr.20140906081909.18715"><vh>cm.findColorDirectives</vh></v>
<v t="ekr.20140906081909.18701"><vh>cm.findLanguageDirectives</vh></v>
<v t="ekr.20140906081909.18702"><vh>cm.isValidLanguage</vh></v>
<v t="ekr.20140906081909.18711"><vh>cm.scanColorByPosition</vh></v>
<v t="ekr.20140906081909.18697"><vh>cm.scanColorDirectives</vh></v>
<v t="ekr.20140906081909.18704"><vh>cm.updateSyntaxColorer</vh></v>
<v t="ekr.20140906081909.18714"><vh>cm.useSyntaxColoring</vh></v>
</v>
<v t="ekr.20110605121601.18569"><vh>class JEditColorizer</vh>
<v t="ekr.20110605121601.18570"><vh>&lt;&lt; about the line-oriented jEdit colorizer &gt;&gt;</vh></v>
<v t="ekr.20110605121601.18571"><vh> Birth &amp; init</vh>
<v t="ekr.20110605121601.18572"><vh>__init__ (JEditColorizer)</vh>
<v t="ekr.20110605121601.18573"><vh>defineLeoKeywordsDict</vh></v>
<v t="ekr.20110605121601.18574"><vh>defineDefaultColorsDict</vh></v>
<v t="ekr.20110605121601.18575"><vh>defineDefaultFontDict</vh></v>
</v>
<v t="ekr.20110605121601.18576"><vh>addImportedRules</vh></v>
<v t="ekr.20110605121601.18577"><vh>addLeoRules</vh></v>
<v t="ekr.20111024091133.16702"><vh>configure_hard_tab_width (JEditColorizer)</vh></v>
<v t="ekr.20110605121601.18578"><vh>configure_tags</vh></v>
<v t="ekr.20110605121601.18579"><vh>configure_variable_tags</vh></v>
<v t="ekr.20110605121601.18580"><vh>init (jeditColorizer)</vh></v>
<v t="ekr.20110605121601.18581"><vh>init_mode &amp; helpers</vh>
<v t="btheado.20131124162237.16303"><vh>init_mode_from_module</vh></v>
<v t="ekr.20110605121601.18582"><vh>nameToRulesetName</vh></v>
<v t="ekr.20110605121601.18583"><vh>setKeywords</vh></v>
<v t="ekr.20110605121601.18584"><vh>setModeAttributes</vh></v>
<v t="ekr.20110605121601.18585"><vh>initModeFromBunch</vh></v>
<v t="ekr.20110605121601.18586"><vh>updateDelimsTables</vh></v>
</v>
<v t="ekr.20110605121601.18587"><vh>munge</vh></v>
<v t="ekr.20110605121601.18588"><vh>setFontFromConfig (JEditColorizer)</vh></v>
</v>
<v t="ekr.20110605121601.18589"><vh> Pattern matchers</vh>
<v t="ekr.20110605121601.18590"><vh> About the pattern matchers</vh></v>
<v t="ekr.20110605121601.18591"><vh>dump</vh></v>
<v t="ekr.20110605121601.18592"><vh>Leo rule functions</vh>
<v t="ekr.20110605121601.18593"><vh>match_at_color</vh></v>
<v t="ekr.20110605121601.18594"><vh>match_at_language</vh></v>
<v t="ekr.20110605121601.18595"><vh>match_at_nocolor &amp; restarter</vh>
<v t="ekr.20110605121601.18596"><vh>restartNoColor</vh></v>
</v>
<v t="ekr.20110605121601.18597"><vh>match_at_killcolor &amp; restarter</vh>
<v t="ekr.20110605121601.18598"><vh>restartKillColor</vh></v>
</v>
<v t="ekr.20110605121601.18599"><vh>match_at_nocolor_node &amp; restarter</vh>
<v t="ekr.20110605121601.18600"><vh>restartNoColorNode</vh></v>
</v>
<v t="ekr.20150622072456.1"><vh>match_at_wrap</vh></v>
<v t="ekr.20110605121601.18601"><vh>match_blanks</vh></v>
<v t="ekr.20110605121601.18602"><vh>match_doc_part &amp; restarter</vh>
<v t="ekr.20110605121601.18603"><vh>restartDocPart</vh></v>
</v>
<v t="ekr.20110605121601.18604"><vh>match_leo_keywords</vh></v>
<v t="ekr.20110605121601.18605"><vh>match_section_ref</vh>
<v t="ekr.20110605121601.18606"><vh>&lt;&lt; set the hyperlink &gt;&gt;</vh></v>
</v>
<v t="ekr.20110605121601.18607"><vh>match_tabs</vh></v>
<v t="ekr.20110605121601.18608"><vh>match_url_any/f/h  (new)</vh></v>
</v>
<v t="ekr.20110605121601.18609"><vh>match_compiled_regexp (new)</vh>
<v t="ekr.20110605121601.18610"><vh>match_compiled_regexp_helper</vh></v>
</v>
<v t="ekr.20110605121601.18611"><vh>match_eol_span</vh></v>
<v t="ekr.20110605121601.18612"><vh>match_eol_span_regexp</vh></v>
<v t="ekr.20110605121601.18613"><vh>match_everything</vh></v>
<v t="ekr.20110605121601.18614"><vh>match_keywords</vh></v>
<v t="ekr.20110605121601.18615"><vh>match_line</vh></v>
<v t="ekr.20110605121601.18616"><vh>match_mark_following &amp; getNextToken</vh>
<v t="ekr.20110605121601.18617"><vh>getNextToken</vh></v>
</v>
<v t="ekr.20110605121601.18618"><vh>match_mark_previous</vh></v>
<v t="ekr.20110605121601.18619"><vh>match_regexp_helper</vh></v>
<v t="ekr.20110605121601.18620"><vh>match_seq</vh></v>
<v t="ekr.20110605121601.18621"><vh>match_seq_regexp</vh></v>
<v t="ekr.20110605121601.18622"><vh>match_span &amp; helper &amp; restarter</vh>
<v t="ekr.20110605121601.18623"><vh>match_span_helper</vh></v>
<v t="ekr.20110605121601.18624"><vh>restart_match_span</vh></v>
</v>
<v t="ekr.20110605121601.18625"><vh>match_span_regexp</vh></v>
<v t="ekr.20110605121601.18626"><vh>match_word_and_regexp</vh></v>
<v t="ekr.20110605121601.18627"><vh>skip_line</vh></v>
<v t="ekr.20110605121601.18628"><vh>trace_match</vh></v>
</v>
<v t="ekr.20110605121601.18629"><vh> State methods</vh>
<v t="ekr.20110605121601.18630"><vh>clearState</vh></v>
<v t="ekr.20110605121601.18631"><vh>computeState</vh></v>
<v t="ekr.20110605121601.18632"><vh>currentState and prevState</vh></v>
<v t="ekr.20110605121601.18633"><vh>setRestart</vh></v>
<v t="ekr.20110605121601.18634"><vh>setState</vh></v>
<v t="ekr.20110605121601.18635"><vh>showState &amp; showCurrentState</vh></v>
<v t="ekr.20110605121601.18636"><vh>stateNameToStateNumber</vh></v>
</v>
<v t="ekr.20110605121601.18637"><vh>colorRangeWithTag</vh></v>
<v t="ekr.20110605121601.18638"><vh>mainLoop &amp; restart</vh>
<v t="ekr.20110605121601.18639"><vh>restart</vh></v>
</v>
<v t="ekr.20110605121601.18640"><vh>recolor (entry point)</vh></v>
<v t="ekr.20110605121601.18641"><vh>setTag</vh></v>
</v>
<v t="ekr.20110605121601.18551"><vh>class LeoQtColorizer</vh>
<v t="ekr.20110605121601.18552"><vh> ctor (LeoQtColorizer)</vh></v>
<v t="ekr.20110605121601.18553"><vh>colorize (LeoQtColorizer) &amp; helper</vh>
<v t="ekr.20120309075544.9888"><vh>scanColorByPosition (LeoQtColorizer)</vh></v>
</v>
<v t="ekr.20110605121601.18554"><vh>enable/disable (not used)</vh></v>
<v t="ekr.20140827112712.18468"><vh>kill (LeoQtColorizer)</vh></v>
<v t="ekr.20110605121601.18556"><vh>scanColorDirectives (LeoQtColorizer) &amp; helper</vh>
<v t="ekr.20121003152523.10126"><vh>&lt;&lt; Test for @colorcache &gt;&gt;</vh></v>
<v t="ekr.20110605121601.18557"><vh>&lt;&lt; Test for @language &gt;&gt;</vh></v>
<v t="ekr.20110605121601.18558"><vh>&lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;</vh></v>
<v t="ekr.20110605121601.18559"><vh>findLanguageDirectives</vh></v>
<v t="ekr.20110605121601.18560"><vh>isValidLanguage</vh></v>
</v>
<v t="ekr.20110605121601.18561"><vh>setHighlighter</vh></v>
<v t="ekr.20110605121601.18562"><vh>updateSyntaxColorer (LeoQtColorizer)</vh></v>
<v t="ekr.20110605121601.18563"><vh>useSyntaxColoring &amp; helper</vh>
<v t="ekr.20110605121601.18564"><vh>findColorDirectives</vh></v>
</v>
<v t="ekr.20121003051050.10198"><vh>write_colorizer_cache (LeoQtColorizer)</vh></v>
</v>
<v t="ekr.20110605121601.18565"><vh>class LeoQtSyntaxHighlighter (PythonQSyntaxHighlighter)</vh>
<v t="ekr.20110605121601.18566"><vh>ctor (LeoQtSyntaxHighlighter)</vh></v>
<v t="ekr.20110605121601.18567"><vh>highlightBlock (LeoQtSyntaxHighlighter)</vh></v>
<v t="ekr.20110605121601.18568"><vh>rehighlight  (leoQtSyntaxhighligher) &amp; helper</vh>
<v t="ekr.20121003051050.10201"><vh>rehighlight_with_cache (LeoQtSyntaxHighlighter)</vh></v>
</v>
</v>
<v t="ekr.20140906095826.18717"><vh>class NullScintillaLexer</vh></v>
<v t="ekr.20140906081909.18689"><vh>class QScintillaColorizer(ColorizerMixin)</vh>
<v t="ekr.20140906081909.18709"><vh>qsc.ctor</vh></v>
<v t="ekr.20140906081909.18718"><vh>qsc.changeLexer</vh></v>
<v t="ekr.20140906095826.18721"><vh>qsc.configure_lexer</vh></v>
<v t="ekr.20140906081909.18707"><vh>qsc.colorize (revise)</vh></v>
<v t="ekr.20140906081909.18716"><vh>qsc.kill</vh></v>
</v>
<v t="ekr.20140906143232.18697"><vh>class PythonLexer (does not work)</vh></v>
</v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31372e3171017d71025808000000616e6e6f7461746571037d710473732e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3171017d71022858090000007374725f6174696d657103580c000000313332303432323637302e39710458090000007374725f6374696d657105580c000000313331393436303438332e30710658090000007374725f6d74696d657107580d000000313331393436373033382e32357108755805000000302e332e3271097d710a2858090000007374725f6174696d65710b580d000000313331393436373035302e3438710c58090000007374725f6374696d65710d580c000000313331393436303438332e30710e58090000007374725f6d74696d65710f580d000000313331393436373035302e34387110755805000000302e332e3471117d71122858090000007374725f6174696d657113580c000000313331393634353330362e32711458090000007374725f6374696d657115580c000000313331393633383634382e30711658090000007374725f6d74696d657117580d000000313331393634313038352e30387118755805000000302e332e3071197d711a2858090000007374725f6174696d65711b580d000000313331393534393339302e3839711c58090000007374725f6374696d65711d580c000000313331393439313330362e30711e58090000007374725f6d74696d65711f580d000000313331393439323330312e35327120755805000000302e332e3571217d71222858090000007374725f6174696d657123580d000000313331393634313435352e3937712458090000007374725f6374696d657125580c000000313331393633383634382e30712658090000007374725f6d74696d657127580c000000313331393634313131372e397128755805000000302e332e3371297d712a2858090000007374725f6174696d65712b580d000000313332303433343235372e3336712c58090000007374725f6374696d65712d580c000000313331393436303438332e30712e58090000007374725f6d74696d65712f580d000000313332303432323639302e3534713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040144.1"><vh>@file ../commands/macroCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040234.1"><vh>@file ../commands/registerCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20140919181357.24956"><vh>@file ../plugins/qt_big_text.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20160226082945.1"><vh>PyInstaller</vh>
<v t="ekr.20160124165611.1"><vh>@file ../../launchLeo-unified.spec</vh></v>
</v>
<v t="ekr.20170107222248.1"><vh>Pyzo</vh>
<v t="ekr.20170107211202.1"><vh>@file ../external/pyzo/highlighter.py</vh></v>
<v t="ekr.20170107220425.1"
expanded="ekr.20170107212231.7,"><vh>@file ../external/pyzo/parsers.py</vh></v>
<v t="ekr.20170107213100.1"><vh>@file ../external/pyzo/python_parser.py</vh></v>
<v t="ekr.20170107214315.1"><vh>@file ../external/pyzo/style.py</vh></v>
<v t="ekr.20170107212657.1"><vh>@file ../external/pyzo/tokens.py</vh></v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt;</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt;</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt;</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20160316091152.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20160316091152.2"><vh>The problem</vh></v>
<v t="ekr.20160316091152.3"><vh>The design</vh></v>
<v t="ekr.20160316091152.4"><vh>Using TokenSync class</vh></v>
<v t="ekr.20160316091152.5"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="btheado.20131124162237.16303">def init_mode_from_module(self, name, mode):
    '''Name may be a language name or a delegate name.
       Mode is a python module or class containing all
       coloring rule attributes for the mode.
    '''
    trace = False and not g.unitTesting
    language, rulesetName = self.nameToRulesetName(name)
    if mode:
        # A hack to give modes/forth.py access to c.
        if hasattr(mode, 'pre_init_mode'):
            mode.pre_init_mode(self.c)
    else:
        # Create a dummy bunch to limit recursion.
        self.modes[rulesetName] = self.modeBunch = g.Bunch(
            attributesDict={},
            defaultColor=None,
            keywordsDict={},
            language='unknown-language',
            mode=mode,
            properties={},
            rulesDict={},
            rulesetName=rulesetName,
            word_chars=self.word_chars, # 2011/05/21
        )
        if trace: g.trace('***** No colorizer file: %s.py' % language)
        self.rulesetName = rulesetName
        self.language_name = 'unknown-language'
        return False
    self.colorizer.language = language
    self.rulesetName = rulesetName
    self.properties = hasattr(mode, 'properties') and mode.properties or {}
    self.keywordsDict = hasattr(mode, 'keywordsDictDict') and mode.keywordsDictDict.get(rulesetName, {}) or {}
    self.setKeywords()
    self.attributesDict = hasattr(mode, 'attributesDictDict') and mode.attributesDictDict.get(rulesetName) or {}
    # if trace: g.trace(rulesetName,self.attributesDict)
    self.setModeAttributes()
    self.rulesDict = hasattr(mode, 'rulesDictDict') and mode.rulesDictDict.get(rulesetName) or {}
    # if trace: g.trace(self.rulesDict)
    self.addLeoRules(self.rulesDict)
    self.defaultColor = 'null'
    self.mode = mode
    self.modes[rulesetName] = self.modeBunch = g.Bunch(
        attributesDict=self.attributesDict,
        defaultColor=self.defaultColor,
        keywordsDict=self.keywordsDict,
        language=self.colorizer.language,
        mode=self.mode,
        properties=self.properties,
        rulesDict=self.rulesDict,
        rulesetName=self.rulesetName,
        word_chars=self.word_chars, # 2011/05/21
    )
    # Do this after 'officially' initing the mode, to limit recursion.
    self.addImportedRules(mode, self.rulesDict, rulesetName)
    self.updateDelimsTables()
    initialDelegate = self.properties.get('initialModeDelegate')
    if initialDelegate:
        if trace: g.trace('initialDelegate', initialDelegate)
        # Replace the original mode by the delegate mode.
        self.init_mode(initialDelegate)
        language2, rulesetName2 = self.nameToRulesetName(initialDelegate)
        self.modes[rulesetName] = self.modes.get(rulesetName2)
        self.language_name = language2 # 2011/05/30
    else:
        self.language_name = language # 2011/05/30
    return True
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858050000006c696e6b7371015d710258010000007871034b0058010000007971044b00580400000074797065710558080000006e6f6465526563747106752e"># This file contains almost all of Leo's sources.
# See the "About this file" node for important notes.
@language python
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.18551"># This is c.frame.body.colorizer

class LeoQtColorizer(object):
    '''An adaptor class that interfaces Leo's core to two class:

    1. a subclass of QSyntaxHighlighter,

    2. the JEditColorizer class that contains the
       pattern-matchin code from the threading colorizer plugin.'''
    @others
</t>
<t tx="ekr.20110605121601.18552">def __init__(self, c, widget):
    '''Ctor for LeoQtColorizer class.'''
    # g.trace('(LeoQtColorizer)',widget)
    self.c = c
    self.widget = widget
    # Step 1: create the ivars.
    self.changingText = False
    self.count = 0 # For unit testing.
    self.colorCacheFlag = False
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.full_recolor_count = 0 # For unit testing.
    self.killColorFlag = False
    self.language = 'python' # set by scanColorDirectives.
    self.languageList = [] # List of color directives in the node the determines it.
    # self.max_chars_to_colorize = c.config.getInt('qt_max_colorized_chars') or 0
        # No longer needed now that coloring is continued in the background.
    self.oldLanguageList = []
    self.oldV = None
    self.showInvisibles = False
    # Step 2: create the highlighter.
    if isinstance(widget, QtWidgets.QTextEdit):
        self.highlighter = LeoQtSyntaxHighlighter(c, widget, colorizer=self)
        self.colorer = self.highlighter.colorer
    else:
        # No coloring for Scintilla
        self.highlighter = None
        self.colorer = None
    widget.leo_colorizer = self
    # Step 3: finish enabling.
    if self.enabled:
        self.enabled = hasattr(self.highlighter, 'currentBlock')
</t>
<t tx="ekr.20110605121601.18553">def colorize(self, p, incremental=False, interruptable=True):
    '''The main colorizer entry point.'''
    trace = False and not g.unitTesting
    verbose = True
    self.count += 1 # For unit testing.
    if not incremental:
        self.full_recolor_count += 1
    s = p.b
    if not s.strip():
        if trace: g.trace('no body', p.h)
        self.kill()
        return
    if s.startswith('@killcolor'):
        if trace: g.trace('@killcolor')
        self.kill()
        return
    elif self.enabled:
        oldFlag = self.flag
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace and verbose:
            g.trace('old: %s, new: %s, %s' % (
                self.oldLanguageList, self.languageList, repr(p.h)))
        # fullRecolor is True if we can not do an incremental recolor.
        fullRecolor = (
            oldFlag != self.flag or
            self.oldV != p.v or
            self.oldLanguageList != self.languageList or
            not incremental
        )
        # 2012/03/09: Determine the present language from the insertion
        # point if there are more than one @language directives in effect
        # and we are about to do an incremental recolor.
        if len(self.languageList) &gt; 0 and not fullRecolor:
            language = self.scanColorByPosition(p) # May reset self.language
            if language != self.colorer.language_name:
                if trace: g.trace('** must rescan', self.c.frame.title, language)
                fullRecolor = True
                self.language = language
        if fullRecolor:
            if trace: g.trace('** calling rehighlight', g.callers())
            self.oldLanguageList = self.languageList[:]
            self.oldV = p.v
            self.highlighter.rehighlight(p)
    return "ok" # For unit testing.
</t>
<t tx="ekr.20110605121601.18554">def disable(self, p):
    g.trace(g.callers(4))
    if self.enabled:
        self.flag = False
        self.enabled = False
        self.highlighter.rehighlight(p) # Do a full recolor (to black)

def enable(self, p):
    g.trace(g.callers(4))
    if not self.enabled:
        self.enabled = True
        self.flag = True
        # Do a full recolor, but only if we aren't changing nodes.
        if self.c.currentPosition() == p:
            self.highlighter.rehighlight(p)
</t>
<t tx="ekr.20110605121601.18556">def scanColorDirectives(self, p):
    '''Set self.language based on the directives in p's tree.'''
    trace = False and not g.unitTesting
    c = self.c
    if c is None: return None # self.c may be None for testing.
    root = p.copy()
    self.colorCacheFlag = False
    self.language = None
    self.rootMode = None # None, "code" or "doc"
    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        &lt;&lt; Test for @colorcache &gt;&gt;
        &lt;&lt; Test for @language &gt;&gt;
        &lt;&lt; Test for @root, @root-doc or @root-code &gt;&gt;
    # 2011/05/28: If no language, get the language from any @&lt;file&gt; node.
    if self.language:
        if trace: g.trace('found @language %s %s' % (self.language, self.languageList))
        return self.language
    #  Attempt to get the language from the nearest enclosing @&lt;file&gt; node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)
    if not self.language:
        if trace: g.trace('using default', c.target_language)
        self.language = c.target_language
    return self.language # For use by external routines.
</t>
<t tx="ekr.20110605121601.18557">if 'language' in theDict:
    s = theDict["language"]
    aList = self.findLanguageDirectives(p)
    # In the root node, we use the first (valid) @language directive,
    # no matter how many @language directives the root node contains.
    # In ancestor nodes, only unambiguous @language directives
    # set self.language.
    if p == root or len(aList) == 1:
        self.languageList = list(set(aList))
        self.language = aList and aList[0] or []
        break
</t>
<t tx="ekr.20110605121601.18558">if 'root' in theDict and not self.rootMode:
    s = theDict["root"]
    if g.match_word(s, 0, "@root-code"):
        self.rootMode = "code"
    elif g.match_word(s, 0, "@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = "doc" if doc else "code"
</t>
<t tx="ekr.20110605121601.18559">def findLanguageDirectives(self, p):
    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s, 0, '@language'):
            i = len('@language')
            i = g.skip_ws(s, i)
            j = g.skip_id(s, i)
            if j &gt; i:
                word = s[i: j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace: g.trace('invalid', word)
    if trace: g.trace(aList)
    return aList
</t>
<t tx="ekr.20110605121601.18560">def isValidLanguage(self, language):
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', '%s.py' % (language))
    return g.os_path_exists(fn)
</t>
<t tx="ekr.20110605121601.18561"># Called *only* from LeoTree.setBodyTextAfterSelect

def setHighlighter(self, p):
    if self.enabled:
        self.flag = self.updateSyntaxColorer(p)
        return self.flag
</t>
<t tx="ekr.20110605121601.18562">def updateSyntaxColorer(self, p):
    '''Scan p.b for color directives.'''
    trace = False and not g.unitTesting
    # An important hack: shortcut everything if the first line is @killcolor.
    if p.b.startswith('@killcolor'):
        if trace: g.trace('@killcolor')
        self.flag = False
        return self.flag
    else:
        # self.flag is True unless an unambiguous @nocolor is seen.
        p = p.copy()
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p) # Sets self.language
    if trace: g.trace(self.flag, len(p.b), self.language, p.h, g.callers(5))
    return self.flag
</t>
<t tx="ekr.20110605121601.18563">def useSyntaxColoring(self, p):
    """Return True unless p is unambiguously under the control of @nocolor."""
    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p', repr(p))
        return False
    p = p.copy()
    first = True; kind = None; val = True
    self.killColorFlag = False
    for p in p.self_and_parents():
        d = self.findColorDirectives(p)
        color, no_color = 'color' in d, 'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True; break
        first = False
    if trace: g.trace(val, kind)
    return val
</t>
<t tx="ekr.20110605121601.18564">color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    , re.MULTILINE)

def findColorDirectives(self, p):
    '''Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.'''
    trace = False and not g.unitTesting
    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word
    if trace: g.trace(d)
    return d
</t>
<t tx="ekr.20110605121601.18565"># This is c.frame.body.colorizer.highlighter
# Careful: we may be running from the bridge.
if QtGui:
    if python_qsh:
        base_highlighter = PythonQSyntaxHighlighter
    else:
        base_highlighter = QtGui.QSyntaxHighlighter

    class LeoQtSyntaxHighlighter(base_highlighter):
        '''A subclass of QSyntaxHighlighter that overrides
        the highlightBlock and rehighlight methods.

        All actual syntax coloring is done in the jeditColorer class.'''
        @others
</t>
<t tx="ekr.20110605121601.18566">def __init__(self, c, widget, colorizer):
    '''ctor for LeoQtSyntaxHighlighter class.'''
    self.c = c
    self.widget = widget # widget is a LeoQTextBrowser.
    # print('LeoQtSyntaxHighlighter.__init__',widget,self.setDocument)
    # Not all versions of Qt have the crucial currentBlock method.
    self.hasCurrentBlock = hasattr(self, 'currentBlock')
    # Init the base class.
    self.colorizer = colorizer
    self.colorer = JEditColorizer(c,
        colorizer=colorizer,
        highlighter=self,
        wrapper=c.frame.body.wrapper)
    # Create the highligter after the colorizer &amp; colorer.
    if python_qsh:
        # The c argument is now optional.
        # If present, it allows an extra safety check in PQSH.idle_handler.
        PythonQSyntaxHighlighter.__init__(self, parent=widget, c=c)
    else:
        QtGui.QSyntaxHighlighter.__init__(self, widget)
</t>
<t tx="ekr.20110605121601.18567">def highlightBlock(self, s):
    """ Called by QSyntaxHiglighter """
    trace = False and not g.unitTesting
    if self.hasCurrentBlock and not self.colorizer.killColorFlag:
        # pylint: disable=undefined-variable, no-member
        # builtins.unicode.
        if g.isPython3:
            s = str(s)
        else:
            s = builtins.unicode(s)
        self.colorer.recolor(s)
        v = self.c.p.v
        if hasattr(v, 'colorCache') and v.colorCache and not self.colorizer.changingText:
            if trace: g.trace('clearing cache', g.callers())
            self.c.p.v.colorCache = None # Kill the color caching.
</t>
<t tx="ekr.20110605121601.18568">def rehighlight(self, p):
    '''Override base rehighlight method'''
    # pylint: disable=arguments-differ
    trace = False and not g.unitTesting
    c = self.c
    # if trace: g.trace(c.shortFileName(),p and p.h,g.callers(20))
    if not p.b.strip():
        if trace: g.trace('no body', c.shortFileName(), p and p.h)
        return
    tree = c.frame.tree
    self.widget = c.frame.body.widget
    if trace:
        t1 = time.time()
    # Call the base class method, but *only*
    # if the crucial 'currentBlock' method exists.
    n = self.colorer.recolorCount
    if self.colorizer.enabled and self.hasCurrentBlock:
        # Lock out onTextChanged.
        old_selecting = tree.selecting
        try:
            tree.selecting = True
            if (
                self.colorizer.colorCacheFlag and
                hasattr(p.v, 'colorCache') and
                p.v.colorCache and
                not g.unitTesting
            ):
                # Should be no need to init the colorizer.
                self.rehighlight_with_cache(p.v.colorCache)
            else:
                self.colorer.init(p, p.b)
                base_highlighter.rehighlight(self)
        finally:
            tree.selecting = old_selecting
    if trace:
        g.trace('(LeoQtSyntaxHighlighter) recolors: %4s %2.3f sec' % (
            self.colorer.recolorCount - n, time.time() - t1))
</t>
<t tx="ekr.20110605121601.18569"># This is c.frame.body.colorizer.highlighter.colorer

class JEditColorizer(object):
    '''
    This class contains jEdit pattern matchers adapted
    for use with QSyntaxHighlighter.
    '''
    &lt;&lt; about the line-oriented jEdit colorizer &gt;&gt;
    @others
</t>
<t tx="ekr.20110605121601.18570">@nocolor-node
@
The aha behind the line-oriented jEdit colorizer is that we can define one or
more *restarter* methods for each pattern matcher that could possibly match
across line boundaries. I say "one or more" because we need a separate restarter
method for all combinations of arguments that can be passed to the jEdit pattern
matchers. In effect, these restarters are lambda bindings for the generic
restarter methods.

In actuality, very few restarters are needed. For example, for Python, we need
restarters for continued strings, and both flavors of continued triple-quoted
strings. For python, these turn out to be three separate lambda bindings for
restart_match_span.

When a jEdit pattern matcher partially succeeds, it creates the lambda binding
for its restarter and calls setRestart to set the ending state of the present
line to an integer representing the bound restarter. setRestart calls
computeState to create a *string* representing the lambda binding of the
restarter. setRestart then calls stateNameToStateNumber to convert that string
to an integer state number that then gets passed to Qt's setCurrentBlockState.
The string is useful for debugging; Qt only uses the corresponding number.
</t>
<t tx="ekr.20110605121601.18571"></t>
<t tx="ekr.20110605121601.18572">def __init__(self, c, colorizer, highlighter, wrapper):
    '''Ctor for JEditColorizer class.'''
    # Basic data...
    self.c = c
    self.colorizer = colorizer
    self.highlighter = highlighter # a QSyntaxHighlighter
    self.p = None
    self.wrapper = wrapper
    assert(wrapper == self.c.frame.body.wrapper)
    # Used by recolor and helpers...
    self.actualColorDict = {} # Used only by setTag.
    self.defaultState = 'default-state:' # The name of the default state.
    self.hyperCount = 0
    self.lineCount = 0 # The number of lines recolored so far.
    self.nextState = 1 # Dont use 0.
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.
    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Config settings...
    self.showInvisibles = c.config.getBool("show_invisibles_by_default")
    self.colorizer.showInvisibles = self.showInvisibles
    # g.trace(self.showInvisibles)
        # Also set in init().
    self.underline_undefined = c.config.getBool("underline_undefined_section_names")
    self.use_hyperlinks = c.config.getBool("use_hyperlinks")
    # Debugging...
    self.count = 0 # For unit testing.
    self.allow_mark_prev = True # The new colorizer tolerates this nonsense :-)
    self.tagCount = 0
    self.trace = False or c.config.getBool('trace_colorizer')
    self.trace_leo_matches = False
    self.trace_match_flag = False
        # True: trace all matching methods.
        # This isn't so useful now that colorRangeWithTag shows g.callers(2).
    self.verbose = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalChars = 0 # The total number of characters examined by recolor.
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
    self.language_name = None # The name of the language for the current mode.
    self.last_language = None # The language for which configuration tags are valid.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.setFontFromConfig()
    self.tags = [
        # 8 Leo-specific tags.
        "blank", # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        # jEdit tags.
        'comment1', 'comment2', 'comment3', 'comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1', 'keyword2', 'keyword3', 'keyword4',
        'label', 'literal1', 'literal2', 'literal3', 'literal4',
        'markup', 'operator',
    ]
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
</t>
<t tx="ekr.20110605121601.18573">def defineLeoKeywordsDict(self):
    self.leoKeywordsDict = {}
    for key in g.globalDirectiveList:
        self.leoKeywordsDict[key] = 'leokeyword'
</t>
<t tx="ekr.20110605121601.18574">@nobeautify

def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {

        # Used in Leo rules...

        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),

        # Used by the old colorizer: to be removed.

        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', 'black'), # 2014/09/17
    }
</t>
<t tx="ekr.20110605121601.18575">@nobeautify

def defineDefaultFontDict (self):

    self.default_font_dict = {

        # Used in Leo rules...

            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',

        # Used by old colorizer.

            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',

         # jEdit tags.

             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
    }
</t>
<t tx="ekr.20110605121601.18576">def addImportedRules(self, mode, rulesDict, rulesetName):
    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''
    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets[rulesetName] = True
    names = hasattr(mode, 'importDict') and mode.importDict.get(rulesetName, []) or []
    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key, [])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        # g.trace([z.__name__ for z in rules])
                        aList.extend(rules)
                        self.rulesDict[key] = aList
        # g.trace('***** added rules for %s from %s' % (name,rulesetName))
        self.initModeFromBunch(savedBunch)
</t>
<t tx="ekr.20110605121601.18577">def addLeoRules(self, theDict):
    '''Put Leo-specific rules to theList.'''
    # pylint: disable=no-member
    # Python 2 uses rule.im_func. Python 3 uses rule.__func__.
    table = (
        # Rules added at front are added in **reverse** order.
        ('@', self.match_leo_keywords, True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@', self.match_at_color, True),
        ('@', self.match_at_killcolor, True),
        ('@', self.match_at_language, True), # 2011/01/17
        ('@', self.match_at_nocolor, True),
        ('@', self.match_at_nocolor_node, True),
        ('@', self.match_at_wrap, True), # 2015/06/22
        ('@', self.match_doc_part, True),
        ('f', self.match_url_f, True),
        ('g', self.match_url_g, True),
        ('h', self.match_url_h, True),
        ('m', self.match_url_m, True),
        ('n', self.match_url_n, True),
        ('p', self.match_url_p, True),
        ('t', self.match_url_t, True),
        ('w', self.match_url_w, True),
        ('&lt;', self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ', self.match_blanks, False),
        ('\t', self.match_tabs, False),
    )
    for ch, rule, atFront, in table:
        # Replace the bound method by an unbound method.
        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        # g.trace(rule)
        theList = theDict.get(ch, [])
        if rule not in theList:
            if atFront:
                theList.insert(0, rule)
            else:
                theList.append(rule)
            theDict[ch] = theList
    # g.trace(g.listToString(theDict.get('@')))
</t>
<t tx="ekr.20110605121601.18578">def configure_tags(self):
    '''Configure all tags.'''
    trace = False and not g.unitTesting
    traceColors = True
    traceFonts = False
    c = self.c
    wrapper = self.wrapper
    isQt = g.app.gui.guiName().startswith('qt')
    if trace: g.trace(self.colorizer.language)
    if wrapper and hasattr(wrapper, 'start_tag_configure'):
        wrapper.start_tag_configure()
    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant", "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont
    # Configure fonts.
    if trace and traceFonts: g.trace('*' * 10, 'configuring fonts')
    keys = list(self.default_font_dict.keys()); keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.colorizer.language, option_name), (option_name)):
            if trace and traceFonts: g.trace(name)
            font = self.fonts.get(name)
            if font:
                if trace and traceFonts:
                    g.trace('**found', name, id(font))
                wrapper.tag_configure(key, font=font)
                break
            else:
                family = c.config.get(name + '_family', 'family')
                size = c.config.get(name + '_size', 'size')
                slant = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight', 'weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size = size or c.config.defaultBodyFontSize
                    slant = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family, size, slant, weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    if trace and traceFonts:
                        g.trace('**found', key, name, family, size, slant, weight, id(font))
                    wrapper.tag_configure(key, font=font)
                    break
        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                if trace and traceFonts:
                    g.trace('default', key, font)
                self.fonts[key] = font # 2010/02/19: Essential
                wrapper.tag_configure(key, font=defaultBodyfont)
            else:
                if trace and traceFonts:
                    g.trace('no fonts')
        if isQt and key == 'url' and font:
            font.setUnderline(True) # 2011/03/04
    keys = sorted(self.default_colors_dict.keys())
    for name in keys:
        # if name == 'operator': g.pdb()
        option_name, default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.colorizer.language, option_name)) or
            c.config.getColor(option_name) or
            default_color)
        if trace and traceColors: g.trace(option_name, color)
        # Must use foreground, not fg.
        try:
            wrapper.tag_configure(name, foreground=color)
        except Exception: # Recover after a user error.
            g.es_exception()
            wrapper.tag_configure(name, foreground=default_color)
    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        wrapper.tag_configure("link", underline=1) # defined
        wrapper.tag_configure("name", underline=0) # undefined
    else:
        wrapper.tag_configure("link", underline=0)
        if self.underline_undefined:
            wrapper.tag_configure("name", underline=1)
        else:
            wrapper.tag_configure("name", underline=0)
    self.configure_variable_tags()
    try:
        wrapper.end_tag_configure()
    except AttributeError:
        pass
</t>
<t tx="ekr.20110605121601.18579">def configure_variable_tags(self):
    c = self.c
    wrapper = self.wrapper
    for name, option_name, default_color in (
        # ("blank", "show_invisibles_space_background_color", "Gray90"),
        # ("tab", "show_invisibles_tab_background_color", "Gray80"),
        ("elide", None, "yellow"),
    ):
        if self.showInvisibles:
            color = option_name and c.config.getColor(option_name) or default_color
        else:
            option_name, default_color = self.default_colors_dict.get(name, (None, None),)
            color = option_name and c.config.getColor(option_name) or ''
        try:
            wrapper.tag_configure(name, background=color)
        except Exception: # A user error.
            wrapper.tag_configure(name, background=default_color)
    # Special case:
    if not self.showInvisibles:
        wrapper.tag_configure("elide", elide="1")
</t>
<t tx="ekr.20110605121601.18580">def init(self, p, s):
    '''Init the colorizer.'''
    trace = False and not g.unitTesting
    if p: self.p = p.copy()
    self.all_s = s or ''
    if trace: g.trace('=' * 20, self.colorizer.language)
    # State info.
    self.all_s = s
    self.global_i, self.global_j = 0, 0
    self.global_offset = 0
    self.lineCount = 0
    # These *must* be recomputed.
    self.nextState = 1 # Dont use 0.
    self.stateDict = {}
    self.stateNameDict = {}
    self.restartDict = {}
    self.init_mode(self.colorizer.language)
    self.clearState()
    self.showInvisibles = self.colorizer.showInvisibles
        # The show/hide-invisible commands changes this.
    # Used by matchers.
    self.prev = None
    if self.last_language != self.colorizer.language:
        # Must be done to support per-language @font/@color settings.
        self.configure_tags()
        self.last_language = self.colorizer.language
    self.configure_hard_tab_width() # 2011/10/04
</t>
<t tx="ekr.20110605121601.18581">def init_mode(self, name):
    '''Name may be a language name or a delegate name.'''
    trace = False and not g.unitTesting
    if not name: return False
    language, rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            if trace: g.trace('found unknown language')
            return False
        else:
            if trace: g.trace('found', language, rulesetName)
            self.initModeFromBunch(bunch)
            self.language_name = language # 2011/05/30
            return True
    else:
        if trace: g.trace(language, rulesetName)
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        path = g.os_path_join(g.app.loadDir, '..', 'modes')
        fn = g.os_path_join(path, '%s.py' % (language))
        if g.os_path_exists(fn):
            mode = g.importFromPath(moduleName=language, path=path)
            if trace: g.trace(mode)
        else:
            mode = None
        return self.init_mode_from_module(name, mode)
</t>
<t tx="ekr.20110605121601.18582">def nameToRulesetName(self, name):
    '''
    Compute language and rulesetName from name, which is either a language
    name or a delegate name.
    '''
    if not name:
        return ''
    i = name.find('::')
    if i == -1:
        language = name
        # New in Leo 5.0: allow delegated language names.
        language = g.app.delegate_language_dict.get(language, language)
        rulesetName = '%s_main' % (language)
    else:
        language = name[: i]
        delegate = name[i + 2:]
        rulesetName = self.munge('%s_%s' % (language, delegate))
    # if rulesetName == 'php_main': rulesetName = 'php_php'
    # g.trace(name,language,rulesetName)
    return language, rulesetName
</t>
<t tx="ekr.20110605121601.18583">def setKeywords(self):
    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.
     '''
    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d[key] = 'leokeyword'
    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]
    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))
    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)
    # g.trace(self.colorizer.language,[str(z) for z in chars])
    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
    # g.trace(sorted(self.word_chars.keys()))
</t>
<t tx="ekr.20110605121601.18584">def setModeAttributes(self):
    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''
    d = self.attributesDict
    aList = (
        ('default', 'null'),
        ('digit_re', ''),
        ('escape', ''), # New in Leo 4.4.2.
        ('highlight_digits', True),
        ('ignore_case', True),
        ('no_word_sep', ''),
    )
    # g.trace(d)
    for key, default in aList:
        val = d.get(key, default)
        if val in ('true', 'True'): val = True
        if val in ('false', 'False'): val = False
        setattr(self, key, val)
        # g.trace(key,val)
</t>
<t tx="ekr.20110605121601.18585">def initModeFromBunch(self, bunch):
    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor = bunch.defaultColor
    self.keywordsDict = bunch.keywordsDict
    self.colorizer.language = bunch.language
    self.mode = bunch.mode
    self.properties = bunch.properties
    self.rulesDict = bunch.rulesDict
    self.rulesetName = bunch.rulesetName
    self.word_chars = bunch.word_chars # 2011/05/21
</t>
<t tx="ekr.20110605121601.18586">def updateDelimsTables(self):
    '''Update g.app.language_delims_dict if no entry for the language exists.'''
    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')
    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment, startComment, endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment, endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None
    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.colorizer.language):
            d[self.colorizer.language] = delims
            # g.trace(self.colorizer.language,'delims:',repr(delims))
</t>
<t tx="ekr.20110605121601.18587">def munge(self, s):
    '''Munge a mode name so that it is a valid python id.'''
    valid = string.ascii_letters + string.digits + '_'
    return ''.join([ch.lower() if ch in valid else '_' for ch in s])
</t>
<t tx="ekr.20110605121601.18588">def setFontFromConfig(self):
    c = self.c
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.color_tags_list = []
</t>
<t tx="ekr.20110605121601.18589"></t>
<t tx="ekr.20110605121601.18590">@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
</t>
<t tx="ekr.20110605121601.18591">def dump(self, s):
    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
</t>
<t tx="ekr.20110605121601.18592"></t>
<t tx="ekr.20110605121601.18593">def match_at_color(self, s, i):
    if self.trace_leo_matches: g.trace()
    seq = '@color'
    # Only matches at start of line.
    if i != 0: return 0
    if g.match_word(s, i, seq):
        self.colorizer.flag = True # Enable coloring.
        j = i + len(seq)
        self.colorRangeWithTag(s, i, j, 'leokeyword')
        self.clearState()
        return j - i
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18594">def match_at_language(self, s, i):
    '''Match Leo's @language directive.'''
    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i, repr(s))
    seq = '@language'
    # Only matches at start of line.
    if i != 0: return 0
    if g.match_word(s, i, seq):
        j = i + len(seq)
        j = g.skip_ws(s, j)
        k = g.skip_c_id(s, j)
        name = s[j: k]
        ok = self.init_mode(name)
        if trace: g.trace(ok, name, self.language_name)
        if ok:
            self.colorRangeWithTag(s, i, k, 'leokeyword')
        self.clearState()
        return k - i
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18595">def match_at_nocolor(self, s, i):
    if self.trace_leo_matches: g.trace(i, repr(s))
    # Only matches at start of line.
    if i == 0 and not g.match(s, i, '@nocolor-') and g.match_word(s, i, '@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18596">def restartNoColor(self, s):
    if self.trace_leo_matches: g.trace(repr(s))
    if g.match_word(s, 0, '@color'):
        self.clearState()
    else:
        self.setRestart(self.restartNoColor)
    return len(s) # Always match everything.
</t>
<t tx="ekr.20110605121601.18597">def match_at_killcolor(self, s, i):
    if self.trace_leo_matches: g.trace(i, repr(s))
    # Only matches at start of line.
    if i != 0 and s[i - 1] != '\n':
        return 0
    tag = '@killcolor'
    if g.match_word(s, i, tag):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18598">def restartKillColor(self, s):
    self.setRestart(self.restartKillColor)
    return len(s) + 1
</t>
<t tx="ekr.20110605121601.18599">def match_at_nocolor_node(self, s, i):
    if self.trace_leo_matches: g.trace()
    # Only matches at start of line.
    if i != 0 and s[i - 1] != '\n':
        return 0
    tag = '@nocolor-node'
    if g.match_word(s, i, tag):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18600">def restartNoColorNode(self, s):
    self.setRestart(self.restartNoColorNode)
    return len(s) + 1
</t>
<t tx="ekr.20110605121601.18601">def match_blanks(self, s, i):
    if 1: # Use Qt code to show invisibles.
        return 0
    else: # Old code...
        if not self.showInvisibles:
            return 0
        j = i; n = len(s)
        while j &lt; n and s[j] == ' ':
            j += 1
        if j &gt; i:
            self.colorRangeWithTag(s, i, j, 'blank')
            return j - i
        else:
            return 0
</t>
<t tx="ekr.20110605121601.18602">def match_doc_part(self, s, i):
    '''
    Colorize Leo's @ and @ doc constructs.
    Matches only at the start of the line.
    '''
    if i != 0:
        return 0
    elif g.match_word(s, i, '@doc'):
        j = i + 4
    elif g.match(s, i, '@') and (i + 1 &gt;= len(s) or s[i + 1] in (' ', '\t', '\n')):
        j = i + 1
    else:
        return 0
    self.colorRangeWithTag(s, i, j, 'leokeyword')
    self.colorRangeWithTag(s, j, len(s), 'docpart')
    self.setRestart(self.restartDocPart)
    return len(s)
</t>
<t tx="ekr.20110605121601.18603">def restartDocPart(self, s):
    '''
    Restarter for @ and @ contructs.
    Continue until an @c, @code or @language at the start of the line.
    '''
    for tag in ('@c', '@code', '@language'):
        if g.match_word(s, 0, tag):
            if tag == '@language':
                return self.match_at_language(s, 0)
            else:
                j = len(tag)
                self.colorRangeWithTag(s, 0, j, 'leokeyword') # 'docpart')
                self.clearState()
                return j
    self.setRestart(self.restartDocPart)
    self.colorRangeWithTag(s, 0, len(s), 'docpart')
    return len(s)
</t>
<t tx="ekr.20110605121601.18604">def match_leo_keywords(self, s, i):
    '''Succeed if s[i:] is a Leo keyword.'''
    # g.trace(i,g.get_line(s,i))
    self.totalLeoKeywordsCalls += 1
    if s[i] != '@':
        return 0
    # fail if something besides whitespace precedes the word on the line.
    i2 = i - 1
    while i2 &gt;= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ', '\t'):
            i2 -= 1
        else:
            # g.trace('not a word 1',repr(ch))
            return 0
    # Get the word as quickly as possible.
    j = i + 1
    while j &lt; len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i + 1: j] # entries in leoKeywordsDict do not start with '@'.
    if j &lt; len(s) and s[j] not in (' ', '\t', '\n'):
        # g.trace('not a word 2',repr(word))
        return 0 # Fail, but allow a rescan, as in objective_c.
    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i + 1 # Bug fix: skip the last character.
        self.trace_match(kind, s, i, j)
        # g.trace('*** match',repr(s))
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s, i, j, kind)
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            # g.trace('found',word)
            return j - i
        else:
            # g.trace('fail',repr(word),repr(self.word_chars))
            return -(j - i + 1) # An important optimization.
</t>
<t tx="ekr.20110605121601.18605">def match_section_ref(self, s, i):
    if self.trace_leo_matches: g.trace()
    c = self.c; p = c.p
    if not g.match(s, i, '&lt;&lt;'):
        return 0
    k = g.find_on_line(s, i + 2, '&gt;&gt;')
    if k == -1:
        return 0
    else:
        j = k + 2
        self.colorRangeWithTag(s, i, i + 2, 'namebrackets')
        ref = g.findReference(c, s[i: j], p)
        if ref:
            if self.use_hyperlinks:
                &lt;&lt; set the hyperlink &gt;&gt;
            else:
                self.colorRangeWithTag(s, i + 2, k, 'link')
        else:
            self.colorRangeWithTag(s, i + 2, k, 'name')
        self.colorRangeWithTag(s, k, j, 'namebrackets')
        return j - i
</t>
<t tx="ekr.20110605121601.18606"># Set the bindings to VNode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
</t>
<t tx="ekr.20110605121601.18607">def match_tabs(self, s, i):
    if 1: # Use Qt code to show invisibles.
        return 0
    else: # Old code...
        if not self.showInvisibles:
            return 0
        if self.trace_leo_matches: g.trace()
        j = i; n = len(s)
        while j &lt; n and s[j] == '\t':
            j += 1
        if j &gt; i:
            self.colorRangeWithTag(s, i, j, 'tab')
            return j - i
        else:
            return 0
</t>
<t tx="ekr.20110605121601.18608"># Fix bug 893230: URL coloring does not work for many Internet protocols.
# Added support for: gopher, mailto, news, nntp, prospero, telnet, wais
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_g = re.compile(r"""gopher://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex_m = re.compile(r"""mailto://[^\s'"]+[\w=/]""")
url_regex_n = re.compile(r"""(news|nntp)://[^\s'"]+[\w=/]""")
url_regex_p = re.compile(r"""prospero://[^\s'"]+[\w=/]""")
url_regex_t = re.compile(r"""telnet://[^\s'"]+[\w=/]""")
url_regex_w = re.compile(r"""wais://[^\s'"]+[\w=/]""")
kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
# url_regex   = re.compile(r"""(file|ftp|http|https)://[^\s'"]+[\w=/]""")
url_regex = re.compile(r"""%s://[^\s'"]+[\w=/]""" % (kinds))

def match_any_url(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex)

def match_url_f(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_f)

def match_url_g(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_g)

def match_url_h(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_h)

def match_url_m(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_m)

def match_url_n(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_n)

def match_url_p(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_p)

def match_url_t(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_t)

def match_url_w(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_w)
</t>
<t tx="ekr.20110605121601.18609">def match_compiled_regexp(self, s, i, kind, regexp, delegate=''):
    '''Succeed if the compiled regular expression regexp matches at s[i:].'''
    if self.verbose: g.trace(g.callers(1), i, repr(s[i: i + 20]), 'regexp', regexp)
    # if at_line_start and i != 0 and s[i-1] != '\n': return 0
    # if at_whitespace_end and i != g.skip_ws(s,0): return 0
    # if at_word_start and i &gt; 0 and s[i-1] in self.word_chars: return 0
    n = self.match_compiled_regexp_helper(s, i, regexp)
    if n &gt; 0:
        j = i + n
        assert(j - i == n)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return j - i
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18610">def match_compiled_regexp_helper(self, s, i, regex):
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s, i) # re_obj.search(s,i)
    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    # if trace:
        # g.trace('pattern',pattern)
        # g.trace('match: %d, %d, %s' % (start,end,repr(s[start: end])))
        # g.trace('groups',mo.groups())
    return end - start
</t>
<t tx="ekr.20110605121601.18611">def match_eol_span(self, s, i,
    kind=None, seq='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False
):
    '''Succeed if seq matches s[i:]'''
    if self.verbose: g.trace(g.callers(1), i, repr(s[i: i + 20]))
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i + len(seq)] in self.word_chars:
        return 0
    if g.match(s, i, seq):
        j = len(s)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        # g.trace(s[i:j])
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18612">def match_eol_span_regexp(self, s, i,
    kind='', regexp='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False
):
    '''Succeed if the regular expression regex matches s[i:].'''
    if self.verbose: g.trace(g.callers(1), i, repr(s[i: i + 20]))
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    n = self.match_regexp_helper(s, i, regexp)
    if n &gt; 0:
        j = len(s)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return j - i
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18613"># def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):
    # '''Match the entire rest of the string.'''
    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    # return j
</t>
<t tx="ekr.20110605121601.18614"># This is a time-critical method.

def match_keywords(self, s, i):
    '''
    Succeed if s[i:] is a keyword.
    Returning -len(word) for failure greatly reduces the number of times this
    method is called.
    '''
    trace = False and not g.unitTesting
    traceFail = True
    self.totalKeywordsCalls += 1
    # g.trace(i,repr(s[i:]))
    # We must be at the start of a word.
    if i &gt; 0 and s[i - 1] in self.word_chars:
        # if trace: g.trace('not at word start',s[i-1])
        return 0
    # Get the word as quickly as possible.
    j = i; n = len(s)
    chars = self.word_chars
    # 2013/11/04: A kludge just for Haskell:
    if self.language_name == 'haskell':
        chars["'"] = "'"
    while j &lt; n and s[j] in chars:
        j += 1
    word = s[i: j]
    if not word:
        g.trace('can not happen', repr(s[i: max(j, i + 1)]), repr(s[i: i + 10]), g.callers())
        return 0
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i
        if trace: g.trace('success', word, kind, result)
        self.trace_match(kind, s, i, j)
        return result
    else:
        if trace and traceFail: g.trace('fail', word, kind)
        return -len(word) # An important new optimization.
</t>
<t tx="ekr.20110605121601.18615">def match_line(self, s, i, kind=None, delegate='', exclude_match=False):
    '''Match the rest of the line.'''
    j = g.skip_to_end_of_line(s, i)
    self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
    return j - i
</t>
<t tx="ekr.20110605121601.18616">def match_mark_following(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Succeed if s[i:] matches pattern.'''
    if not self.allow_mark_prev: return 0
    # g.trace(g.callers(1),i,repr(s[i:i+20]))
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 &lt; len(s) and s[i + len(pattern)] in self.word_chars:
        return 0 # 7/5/2008
    if g.match(s, i, pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s, j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k &gt; j:
            self.colorRangeWithTag(s, i, j, kind, exclude_match=exclude_match)
            self.colorRangeWithTag(s, j, k, kind, exclude_match=False)
            j = k
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            return j - i
        else:
            return 0
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18617">def getNextToken(self, s, i):
    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?
    while i &lt; len(s) and s[i] in self.word_chars:
        i += 1
    # 2011/05/31: was i+1
    return min(len(s), i)
</t>
<t tx="ekr.20110605121601.18618">def match_mark_previous(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''
    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
</t>
<t tx="ekr.20110605121601.18619">def match_regexp_helper(self, s, i, pattern):
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
    trace = False and not g.unitTesting
    if trace: g.trace('%-10s %-20s %s' % (
        self.colorizer.language, pattern, s)) # g.callers(1)
    try:
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        re_obj = re.compile(pattern, flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0
    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s, i) # re_obj.search(s,i)
    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        if trace:
            g.trace('pattern', pattern)
            g.trace('match: %d, %d, %s' % (start, end, repr(s[start: end])))
            g.trace('groups', mo.groups())
        return end - start
</t>
<t tx="ekr.20110605121601.18620">def match_seq(self, s, i,
    kind='', seq='',
    at_line_start=False,
    at_whitespace_end=False,
    at_word_start=False,
    delegate=''
):
    '''Succeed if s[:] mathces seq.'''
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i + len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s, i, seq):
        j = i + len(seq)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
    else:
        j = i
    return j - i
</t>
<t tx="ekr.20110605121601.18621">def match_seq_regexp(self, s, i,
    kind='', regexp='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate=''
):
    '''Succeed if the regular expression regexp matches at s[i:].'''
    if self.verbose: g.trace(g.callers(1), i, repr(s[i: i + 20]), 'regexp', regexp)
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0
    n = self.match_regexp_helper(s, i, regexp)
    j = i + n
    assert(j - i == n)
    self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
    self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    return j - i
</t>
<t tx="ekr.20110605121601.18622">def match_span(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False
):
    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''
    trace = False and not g.unitTesting
    if i &gt;= len(s): return 0
    # g.trace(begin,end,no_escape,no_line_break,no_word_break)
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i &gt; 0 and s[i - 1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 &lt; len(s) and s[i + len(begin)] in self.word_chars:
        j = i
    elif not g.match(s, i, begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s, i + len(begin), end,
            no_escape, no_line_break, no_word_break=no_word_break)
        # g.trace('** helper returns',j,len(s))
        if j == -1:
            j = i # A real failure.
        else:
            # A match
            i2 = i + len(begin); j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s, i, i2, kind, delegate=None, exclude_match=exclude_match)
                self.colorRangeWithTag(s, i2, j, kind, delegate=delegate, exclude_match=exclude_match)
                self.colorRangeWithTag(s, j, j2, kind, delegate=None, exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
            j = j2
            self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):
        j = len(s) + 1

        def boundRestartMatchSpan(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keyword args.
            delegate=delegate, end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
        if trace: g.trace('***Continuing', kind, i, j, len(s), s[i: j])
    elif j != i:
        if trace: g.trace('***Ending', kind, i, j, s[i: j])
        self.clearState()
    return j - i # Correct, whatever j is.
</t>
<t tx="ekr.20110605121601.18623">def match_span_helper(self, s, i, pattern, no_escape, no_line_break, no_word_break):
    '''
    Return n &gt;= 0 if s[i] ends with a non-escaped 'end' string.
    '''
    esc = self.escape
    while 1:
        j = s.find(pattern, i)
        # g.trace(no_line_break,j,len(s))
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s) + 1
        elif no_word_break and j &gt; 0 and s[j - 1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i: j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k &gt;= 0 and s[j - k] == esc:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                assert s[j - 1] == esc
                i += 1 # 2013/08/26: just advance past the *one* escaped character.
                # g.trace('escapes',escapes,repr(s[i:]))
            else:
                return j
        else:
            return j
</t>
<t tx="ekr.20110605121601.18624">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    '''Remain in this state until 'end' is seen.'''
    trace = False and not g.unitTesting
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind, delegate=None, exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def boundRestartMatchSpan(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(boundRestartMatchSpan,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
        if trace: g.trace('***Re-continuing', i, j, len(s), s)
    else:
        if trace: g.trace('***ending', i, j, len(s), s)
        self.clearState()
    return j # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20110605121601.18625">def match_span_regexp(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False,
):
    '''Succeed if s[i:] starts with 'begin' (a regular expression) and
    contains a following 'end'.
    '''
    if self.verbose: g.trace('begin', repr(begin), 'end', repr(end), self.dump(s[i:]))
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 &lt; len(s) and s[i + len(begin)] in self.word_chars:
        return 0 # 7/5/2008
    n = self.match_regexp_helper(s, i, begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n &gt; 0:
        j = i + n
        j2 = s.find(end, j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k &gt;= 0 and s[j - k] == self.escape:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s, i, j, kind, delegate=None, exclude_match=exclude_match)
            self.colorRangeWithTag(s, j, i2, kind, delegate=delegate, exclude_match=False)
            self.colorRangeWithTag(s, i2, j2, kind, delegate=None, exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j2)
        return j2 - i
    else: return 0
</t>
<t tx="ekr.20110605121601.18626">def match_word_and_regexp(self, s, i,
    kind1='', word='',
    kind2='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Succeed if s[i:] matches pattern.'''
    if not self.allow_mark_prev: return 0
    if (False or self.verbose): g.trace(i, repr(s[i: i + 20]))
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 &lt; len(s) and s[i + len(word)] in self.word_chars:
        j = i
    if not g.match(s, i, word):
        return 0
    j = i + len(word)
    n = self.match_regexp_helper(s, j, pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s, i, j, kind1, exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s, j, k, kind2, exclude_match=False)
    self.prev = (j, k, kind2)
    self.trace_match(kind1, s, i, j)
    self.trace_match(kind2, s, j, k)
    return k - i
</t>
<t tx="ekr.20110605121601.18627">def skip_line(self, s, i):
    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i &lt; len(s):
            j = g.skip_line(s, i)
            if not g.match(s, j - n, escape):
                return j
            # g.trace('escape',s[i:j])
            i = j
        return i
    else:
        return g.skip_line(s, i)
            # Include the newline so we don't get a flash at the end of the line.
</t>
<t tx="ekr.20110605121601.18628">def trace_match(self, kind, s, i, j):
    if j != i and self.trace_match_flag:
        g.trace(kind, i, j, g.callers(2), self.dump(s[i: j]))
</t>
<t tx="ekr.20110605121601.18629"></t>
<t tx="ekr.20110605121601.18630">def clearState(self):
    self.setState(-1)
</t>
<t tx="ekr.20110605121601.18631">def computeState(self, f, keys):
    '''Compute the state name associated with f and all the keys.

    Return a unique int n representing that state.'''
    # Abbreviate arg names.
    d = {
        'delegate': 'del:',
        'end': 'end',
        'at_line_start': 'line-start',
        'at_whitespace_end': 'ws-end',
        'exclude_match': 'exc-match',
        'no_escape': 'no-esc',
        'no_line_break': 'no-brk',
        'no_word_break': 'no-word-brk',
    }
    result = [
        f.__name__,
        self.colorizer.language,
        self.rulesetName]
    for key in keys:
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key, val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None, ''):
            result.append('%s=%s' % (key, keyVal))
    state = ';'.join(result)
    n = self.stateNameToStateNumber(f, state)
    return n
</t>
<t tx="ekr.20110605121601.18632">def currentState(self):
    return self.highlighter.currentBlockState()

def prevState(self):
    return self.highlighter.previousBlockState()
</t>
<t tx="ekr.20110605121601.18633">def setRestart(self, f, **keys):
    n = self.computeState(f, keys)
    self.setState(n)
</t>
<t tx="ekr.20110605121601.18634">def setState(self, n):
    trace = False and not g.unitTesting
    self.highlighter.setCurrentBlockState(n)
    if trace:
        stateName = self.showState(n)
        g.trace(stateName, g.callers(4))
</t>
<t tx="ekr.20110605121601.18635">def showState(self, n):
    if n == -1:
        return 'default-state'
    else:
        return self.stateDict.get(n, '&lt;no state&gt;')

def showCurrentState(self):
    n = self.currentState()
    return self.showState(n)

def showPrevState(self):
    n = self.prevState()
    return self.showState(n)
</t>
<t tx="ekr.20110605121601.18636">def stateNameToStateNumber(self, f, stateName):
    # stateDict:     Keys are state numbers, values state names.
    # stateNameDict: Keys are state names, values are state numbers.
    # restartDict:   Keys are state numbers, values are restart functions
    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        # g.trace('========',n,stateName)
    return n
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''
    trace = False and not g.unitTesting
        # A superb trace: enable this first to see what gets colored.
    # Pattern matcher may set the .flag ivar.
    if self.colorizer.killColorFlag or not self.colorizer.flag:
        if trace: g.trace('disabled')
        return
    if delegate:
        if trace:
            s2 = repr(s[i: j]) if len(repr(s[i: j])) &lt;= 20 else repr(s[i: i + 17 - 2] + '...')
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate, tag)), i, j, s2, g.callers(2)))
        # self.setTag(tag,s,i,j) # 2011/05/31: Do the initial color.
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    # if trace: g.trace('delegate',delegate,i,n,f.__name__,repr(s[i:i+n]))
                    i += n; break
            else:
                # New in Leo 4.6: Use the default chars for everything else.
                # New in Leo 4.8 devel: use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                # g.trace(default_tag)
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = repr(s[i: j]) if len(repr(s[i: j])) &lt;= 20 else repr(s[i: i + 17 - 2] + '...')
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language_name, tag)), i, j, s2, g.callers(2)))
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            if s[i].lower() in 'fh': # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18638">def mainLoop(self, n, s):
    '''Colorize a *single* line s, starting in state n.'''
    trace = False and not g.unitTesting
    traceMatch = True
    traceFail = True
    traceState = True
    traceEndState = True
    if trace:
        if traceState:
            g.trace('%s %-30s' % (self.language_name,
                '** start: %s' % self.showState(n)), repr(s))
        else:
            g.trace(self.language_name, repr(s)) # Called from recolor.
    i = 0
    if n &gt; -1:
        i = self.restart(n, s, trace and traceMatch)
    if i == 0:
        self.setState(self.prevState())
    if False and trace:
        aList = self.rulesDict.get('&lt;')
        for f in aList:
            g.trace(f.__name__)
    while i &lt; len(s):
        progress = i
        functions = self.rulesDict.get(s[i], [])
        for f in functions:
            n = f(self, s, i)
            if n is None:
                g.trace('Can not happen: n is None', repr(f))
                break
            elif n &gt; 0: # Success.
                if trace and traceMatch and f.__name__ != 'match_blanks':
                    g.trace('%-30s' % ('   match: %s' % (f.__name__,)),
                        repr(s[i: i + n]))
                # The match has already been colored.
                i += n
                break # Stop searching the functions.
            elif n &lt; 0: # Fail and skip n chars.
                if trace and traceFail:
                    g.trace('fail: n: %s %-30s %s' % (
                        n, f.__name__, repr(s[i: i + n])))
                i += -n
                break # Stop searching the functions.
            else: # Fail. Try the next function.
                pass # Do not break or change i!
        else:
            i += 1
        assert i &gt; progress
    # Don't even *think* about clearing state here.
    # We remain in the starting state unless a match happens.
    if trace and traceEndState:
        g.trace('%-30s' % ('** end:   %s' % self.showCurrentState()), repr(s))
</t>
<t tx="ekr.20110605121601.18639">def restart(self, n, s, traceMatch):
    f = self.restartDict.get(n)
    if f:
        i = f(s)
        fname = f.__name__
        if traceMatch:
            if i &gt; 0:
                g.trace('** restart match', fname, s[: i])
            else:
                g.trace('** restart fail', fname, s)
    else:
        g.trace('**** no restart f')
        i = 0
    return i
</t>
<t tx="ekr.20110605121601.18640">def recolor(self, s):
    '''
    Recolor a *single* line, s.
    Qt calls this method repeatedly to colorizer all the text.
    '''
    trace = False and not g.unitTesting
    traceCallers = False; traceLine = True
    traceState = False; traceReturns = False
    # Update the counts.
    self.recolorCount += 1
    if self.colorizer.changingText:
        if trace and traceReturns: g.trace('changingText')
        return
    if not self.colorizer.flag:
        if trace and traceReturns: g.trace('not flag')
        return
    self.lineCount += 1
    # Get the previous state.
    self.totalChars += len(s)
    n = self.prevState() # The state at the end of the previous line.
    if trace:
        if traceLine and traceState:
            g.trace('%3s %2s %s %s' % (self.lineCount, n, self.showState(n), repr(s)))
        elif traceLine:
            g.trace('%3s %2s %s' % (self.lineCount, n, repr(s)))
        if traceCallers:
            # Called from colorize:rehightlight,highlightBlock
            g.trace(g.callers())
    if s.strip() or self.showInvisibles:
        self.mainLoop(n, s)
    else:
        self.setState(n) # Required
</t>
<t tx="ekr.20110605121601.18641">def setTag(self, tag, s, i, j):
    '''Set the tag in the highlighter.'''
    trace = False and not g.unitTesting
    if i == j:
        if trace: g.trace('empty range')
        return
    wrapper = self.wrapper # A QTextEditWrapper
    tag = tag.lower() # 2011/10/28
    colorName = wrapper.configDict.get(tag)
    # Munge the color name.
    if not colorName:
        if trace: g.trace('no color for %s' % tag)
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[: -1]
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name', colorName, g.callers())
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if trace:
        self.tagCount += 1
        g.trace(
            '%3s %3s %3s %9s %7s' % (i, j, len(s), font and id(font) or '&lt;no font&gt;', colorName),
            '%-10s %-25s' % (tag, s[i: j]), g.callers(2))
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setFontUnderline(True)
    else:
        format.setForeground(color)
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20111024091133.16702">def configure_hard_tab_width(self):
    '''Set the width of a hard tab.
    The stated default is 40, but apparently it must be set explicitly.
    '''
    trace = False and not g.unitTesting
    c, wrapper = self.c, self.wrapper
    # For some reason, the size is not accurate.
    font = wrapper.widget.currentFont()
    info = QtGui.QFontInfo(font)
    size = info.pointSizeF()
    pixels_per_point = 1.0 # 0.9
    hard_tab_width = abs(int(pixels_per_point * size * c.tab_width))
    if trace: g.trace(
        'family', font.family(), 'point size', size,
        'tab_width', c.tab_width,
        'hard_tab_width', hard_tab_width)
    wrapper.widget.setTabStopWidth(hard_tab_width)
</t>
<t tx="ekr.20120309075544.9888">def scanColorByPosition(self, p):
    c = self.c
    wrapper = c.frame.body.wrapper
    i = wrapper.getInsertPoint()
    s = wrapper.getAllText()
    i1, i2 = g.getLine(s, i)
    tag = '@language'
    language = self.language
    for s in g.splitLines(s[: i1]):
        if s.startswith(tag):
            language = s[len(tag):].strip()
    return language
</t>
<t tx="ekr.20121003051050.10198"># Used info from qt/src/gui/text/qsyntaxhighlighter.cpp

def write_colorizer_cache(self, p):
    '''
    Write colorizing data for p for later use by rehighlight_with_cache.
    Called from the node selection logic only if an @colorcache directive is in effect.
    '''
    trace = False and not g.unitTesting
    if not p: return
    c = self.c
    widget = c.frame.body.widget # a subclass of QTextBrowser
    doc = widget.document()
    if trace:
        t1 = time.time()
    aList = []
    for i in range(doc.blockCount()):
        b = doc.findBlockByNumber(i)
        s = g.u(b.text())
        layout = b.layout()
        ranges = list(layout.additionalFormats()) # A list of FormatRange objects.
        if ranges:
            aList.append(g.bunch(i=i, ranges=ranges, s=s))
            # Apparently not necessary.
                # ranges2 = []
                # for r in ranges:
                    # # Hold the format in memory by copying it.
                    # r.format = QtGui.QTextCharFormat(r.format)
                    # ranges2.append(r)
                # aList.append(g.bunch(i=i,ranges=ranges2,s=s))
    p.v.colorCache = g.bunch(aList=aList, n=doc.blockCount(), v=p.v)
    if trace:
        g.trace('%2.3f sec len(aList): %s v: %s' % (
            time.time() - t1, len(aList), c.p.v.h,))
</t>
<t tx="ekr.20121003051050.10201">def rehighlight_with_cache(self, bunch):
    '''
    Rehighlight the block from bunch, without calling QSH.rehighlight.

    - bunch.aList: a list of bunch2 objects.
    - bunch.n: a block (line) number.
    - bunch.v: the VNode.
        - bunch2.i: the index of the block.
        - bunch2.s: the contents of the block.
        - bunch2.ranges: a list of QTextLayout.FormatRange objects.
    '''
    trace = False and not g.unitTesting
    widget = self.c.frame.body.widget # a subclass of QTextEdit.
    doc = widget.document()
    if bunch.n != doc.blockCount():
        return g.trace('bad block count: expected %s got %s' % (
            bunch.n, doc.blockCount()))
    if trace:
        t1 = time.time()
    for i, bunch2 in enumerate(bunch.aList):
        b = doc.findBlockByNumber(bunch2.i) # a QTextBlock
        layout = b.layout() # a QTextLayout.
        if bunch2.s == g.u(b.text()):
            layout.setAdditionalFormats(bunch2.ranges)
        else:
            return g.trace('bad line: i: %s\nexpected %s\ngot     %s' % (
                i, bunch2.s, g.u(b.text())))
    if trace:
        g.trace('%2.3f sec' % (time.time() - t1))
</t>
<t tx="ekr.20121003152523.10126"># The @colorcache directive is a per-node directive.
if p == root:
    self.colorCacheFlag = 'colorcache' in theDict
    # g.trace('colorCacheFlag: %s' % self.colorCacheFlag)
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140825132752.18554">class PythonQSyntaxHighlighter(object):
    '''
    Python implementation of QtGui.QSyntaxHighlighter.

    This allows incremental coloring of text at idle time, trading slower
    overall speed for much faster response time.
    '''
    @others
</t>
<t tx="ekr.20140825132752.18557">def applyFormatChanges(self):
    '''Apply self.formats to the current layout.'''
    if self.formats:
        layout = self.cb.layout()
        layout.setAdditionalFormats(self.formats)
        self.formats = []
        self.d.markContentsDirty(self.cb.position(), self.cb.length())
</t>
<t tx="ekr.20140825132752.18558">def q_reformatBlocks(self, from_, charsRemoved, charsAdded):
    if not self.inReformatBlocks:
        # g.trace(from_,charsRemoved,charsAdded)
        self.reformatBlocks(from_, charsRemoved, charsAdded)
</t>
<t tx="ekr.20140825132752.18559">def reformatBlocks(self, from_, charsRemoved, charsAdded):
    '''Main line: Reformat the lines in the indicated range.'''
    self.rehighlightPending = False
    block = self.d.findBlock(from_)
    if not self.is_valid(block):
        return
    # Set the ivars for reformat_blocks_helper.
    adjust = 1 if charsRemoved &gt; 0 else 0
    lastBlock = self.d.findBlock(from_ + charsAdded + adjust)
    if self.is_valid(lastBlock):
        self.r_end = lastBlock.position() + lastBlock.length()
    else:
        self.r_end = self.d.blockCount()
    self.r_block = block
    self.r_p = self.c.p.copy()
    self.r_force = False
    # Delegate the colorizing to shared helper.
    self.reformat_blocks_helper()
</t>
<t tx="ekr.20140825132752.18560">def reformatBlock(self, block):
    trace = False and not g.unitTesting
    if self.is_valid(self.cb) and not isQt5:
        g.trace('can not happen: called recursively')
    else:
        self.cb = block
        self.formats = []
        for i in range(block.length()):
            r = QtGui.QTextLayout.FormatRange()
            r.start, r.length, r.format = i, 1, QtGui.QTextCharFormat()
            self.formats.append(r)
        if trace: g.trace(str(block.text()))
        self.highlightBlock(block.text())
        self.applyFormatChanges()
        self.cb = QtGui.QTextBlock()
</t>
<t tx="ekr.20140825132752.18561">def __init__(self, parent, c=None, delay=10, limit=50):
    '''
    Ctor for QSyntaxHighlighter class.
    Parent is a QTextDocument or QTextEdit: it becomes the owner of the QSyntaxHighlighter.
    '''
    # g.trace('(PythonQSyntaxBrowser)', parent)
    # Ivars corresponding to QSH ivars...
    self.c = c # The commander.
    self.cb = None # The current block: a QTextBlock.
    self.d = None # The QTextDocument attached to this colorizers.
    self.formats = [] # An array of QTextLayout.FormatRange objects.
    self.inReformatBlocks = False
    self.rehighlightPending = False
    # Ivars for reformatBlocks and idle_handler...
    self.idle_active = False # True if the idle_handler should colorize.
    self.r_block = None # The block to be colorized.
    self.r_end = None # The ultimate ending position.
    self.r_delay = delay # The waiting time, in msec. for self.timer.
    self.r_force = False # True if the next block must be recolored.
    self.r_limit = limit # The max number of lines to color at one time.
    self.timer = g.IdleTime(
        handler=self.idle_handler,
        delay=self.r_delay,
        tag='pqsh.idle_handler')
    # Attach the parent's QTextDocument and set self.d.
    self.setDocument(parent)
</t>
<t tx="ekr.20140825132752.18564">def setDocument(self, parent):
    '''Install self on the given QTextDocument.'''
    d = self.d
    if d:
        d.contentsChange.disconnect()
        cursor = QtGui.QTextCursor(d)
        cursor.beginEditBlock()
        blk = d.begin()
        while self.is_valid(blk): # blk: QTextBlock
            blk.layout().clearAdditionalFormats()
            blk = blk.next()
        cursor.endEditBlock()
    self.d = d = parent.document()
    assert isinstance(d, QtGui.QTextDocument), d
    if d:
        d.contentsChange.connect(self.q_reformatBlocks)
        d.rehighlightPending = True
            # Set d's pending flag.
        QtCore.QTimer.singleShot(0, self.delayedRehighlight)
</t>
<t tx="ekr.20140825132752.18565">def document(self):
    '''Returns the QTextDocument on which this syntax highlighter is installed.'''
    return self.d
</t>
<t tx="ekr.20140825132752.18566">def rehighlight(self):
    '''Color the whole document.'''
    trace = False and not g.unitTesting
    c, d = self.c, self.d
    if d:
        n = d.characterCount()
        if 0 &lt; c.max_pre_loaded_body_chars &lt; n:
            if trace: g.trace('big text: no color', c.p.h)
        elif n &gt; 1000*10:

            def rehightlight_callback(c=c, d=d, p=c.p, self=self):
                if p == c.p:
                    if trace: g.trace('=====', n, p.h)
                    cursor = QtGui.QTextCursor(d)
                    self.rehighlight_helper(cursor, QtGui.QTextCursor.End)
                else:
                    if trace: g.trace('node not selected', p.h)

            QtCore.QTimer.singleShot(200, rehightlight_callback)
        else:
            if trace: g.trace(n)
            cursor = QtGui.QTextCursor(d)
            self.rehighlight_helper(cursor, QtGui.QTextCursor.End)
</t>
<t tx="ekr.20140825132752.18568">def rehighlightBlock(self, block):
    '''Reapplies the highlighting to the given QTextBlock block.'''
    d = self.d
    if d and self.is_valid(block) and block.document() == d:
        self.rehighlightPending = d.rehighlightPending
        cursor = QtGui.QTextCursor(block)
        g.trace(g.u(block.text()))
        self.rehighlight_helper(cursor, QtGui.QTextCursor.EndOfBlock)
        if self.rehighlightPending:
            d.rehighlightPending = self.rehighlightPending
</t>
<t tx="ekr.20140825132752.18575">def format(self, pos):
    '''Return the format at the given position in the current text block.'''
    if 0 &lt;= pos &lt; len(self.formatChanges):
        return self.formatChanges[pos]
    else:
        return QtGui.QTextCharFormat()
</t>
<t tx="ekr.20140825132752.18576">def setCurrentBlockState(self, newState):
    '''Sets the state of the current text block.'''
    if self.is_valid(self.cb):
        self.cb.setUserState(newState)

def setCurrentBlockUserData(self, data):
    '''Set the user data of the current text block.'''
    if self.is_valid(self.cb):
        self.cb.setUserData(data)
</t>
<t tx="ekr.20140825132752.18580">def currentBlockState(self):
    '''Returns the state of the current block or -1.'''
    return self.cb.userState() if self.is_valid(self.cb) else - 1

def previousBlockState(self):
    '''Returns the end state previous text block or -1'''
    if self.is_valid(self.cb):
        previous = self.cb.previous()
        return previous.userState() if self.is_valid(previous) else - 1
    else:
        return -1
</t>
<t tx="ekr.20140825132752.18582">def currentBlock(self):
    '''Returns the current text block.'''
    return self.cb

def currentBlockUserData(self):
    '''Returns the QTextBlockUserData object attached to the current text block.'''
    return self.cb.userData() if self.is_valid(self.cb) else None
</t>
<t tx="ekr.20140825132752.18584">def setFormat(self, start, count, format):
    '''Remember the requested formatting.'''
    trace = False and not g.unitTesting
    verbose = False
    if start &gt;= 0:
        r = QtGui.QTextLayout.FormatRange()
        r.start, r.length, r.format = start, count, format
        self.formats.append(r)
        if trace and verbose: g.trace('%3s %3s %s %s' % (
            start, count, self.format_to_color(format), self.cb.text()))
    elif trace:
        g.trace('bad start value', repr(start), g.callers())
# Not used by Leo...
# def setFormat(self,start,count,color):
    # format = QTextCharFormat()
    # format.setForeground(color)
    # setFormat(start,count,format)
# def setFormat(self,start,count,font):
    # format = QTextCharFormat()
    # format.setFont(font)
    # self.setFormat(start,count,format)
</t>
<t tx="ekr.20140825132752.18588"></t>
<t tx="ekr.20140825132752.18589"># These helpers are the main reason QSyntaxHighlighter exists.
# Getting this code exactly right is the main challenge for PythonQSyntaxHighlighter.
</t>
<t tx="ekr.20140825132752.18590"></t>
<t tx="ekr.20140825132752.18591">def rehighlight_helper(self, cursor, operation):
        # QtGui.QTextCursor &amp;cursor
        # QtGui.QTextCursor.MoveOperation operation
    self.inReformatBlocks = True
    try:
        cursor.beginEditBlock()
        from_ = cursor.position()
        cursor.movePosition(operation)
        self.reformatBlocks(from_, 0, cursor.position() - from_)
        cursor.endEditBlock()
    finally:
        self.inReformatBlocks = False
</t>
<t tx="ekr.20140825132752.18592">def delayedRehighlight(self): # inline
    '''Queued rehighlight.'''
    # g.trace('=====',self.rehighlightPending)
    if self.rehighlightPending:
        self.rehighlightPending = False
        self.rehighlight()
</t>
<t tx="ekr.20140826120657.18648">def is_valid(self, obj):
    return obj and obj.isValid()
</t>
<t tx="ekr.20140826120657.18649">def format_to_color(self, format):
    '''Return the foreground color of the given character format.'''
    return str(format.foreground().color().name())
</t>
<t tx="ekr.20140826120657.18650">def highlightBlock(self, s):
    g.trace('must be defined in subclasses.' '')
</t>
<t tx="ekr.20140827063632.18569">def idle_handler(self, timer):
    trace = False and not g.unitTesting
    verbose = True
    if not self.idle_active:
        # Shortcut everything else.
        return
    c = self.c
    if trace and verbose:
        s = g.u(self.r_block.text()).lstrip()
        g.trace('force: %5s s: %s' % (self.r_force, s[: 20]))
    # This is defensive code.  Apparently it is never needed.
    # This is the only place c is used, so the c argument to the ctor is optional.
    if c:
        if c.p == self.r_p:
            self.reformat_blocks_helper()
        elif trace:
            self.idle_active = False
            g.trace('node changed: old: %s new: %s' % (
                self.r_p and self.r_p.h[: 10], c.p and c.p.h[: 10]))
</t>
<t tx="ekr.20140827074435.18570">def reformat_blocks_helper(self):
    '''The common code shared by reformatBlocks and idle_handler.'''
    block = self.r_block
    n, start = 0, False
    while self.is_valid(block) and (block.position() &lt; self.r_end or self.r_force):
        n += 1
        if n &gt;= self.r_limit &gt; 0 and self.timer:
            start = True
            break
        else:
            before_state = block.userState()
            self.reformatBlock(block)
            self.r_force = block.userState() != before_state
            block = self.r_block = block.next()
    self.formatChanges = []
    self.idle_active = start
    if self.timer and start:
        self.timer.start()
    elif self.timer:
        self.timer.stop()
        # g.trace('--end',g.app.allow_see,self.c.p and self.c.p.h or None)
        # Fix bug 78: find-next match not always scrolled into view.
        # https://github.com/leo-editor/leo-editor/issues/78
        w = self.c.frame.body.wrapper
        if g.app.allow_delayed_see and w:
            w.seeInsertPoint()
        g.app.allow_delayed_see = False
</t>
<t tx="ekr.20140827092102.18574">@first # -*- coding: utf-8 -*-
'''All colorizing code for Leo.'''
new = False
python_qsh = True
    # True use PythonQSyntaxHighlighter
    # False use QSyntaxHighlighter
&lt;&lt; imports &gt;&gt;
&lt;&lt; class PythonQSyntaxHighlighter &gt;&gt;
@others
@language python
@tabwidth -4
@pagewidth 70
</t>
<t tx="ekr.20140827092102.18575">import leo.core.leoGlobals as g
from leo.core.leoQt import isQt5, Qsci, QtCore, QtGui, QtWidgets
try:
    import builtins # Python 3
except ImportError:
    import __builtin__ as builtins # Python 2.
import re
import string
import time
</t>
<t tx="ekr.20140827112712.18468">def kill(self): # c.frame.body.colorizer.kill
    '''Kill any queue colorizing.'''
    if self.highlighter and hasattr(self.highlighter, 'kill'):
        self.highlighter.kill()
</t>
<t tx="ekr.20140827112712.18469">def kill(self):
    '''Kill any queued coloring.'''
    trace = False and not g.unitTesting
    if self.idle_active:
        if trace: g.trace('(PythonQSyntaxHighlighter)')
        self.idle_active = False
        if self.timer:
            self.timer.stop()
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@
@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.
@c
</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140905060158.18560">'''
A script to replace body.x with body.wrapper.x for all x in the WrapperAPI.

It is *not undoable* to save massive amounts of memory.
Please run on an already-saved .leo file, and take all other reasonable precautions.

If replace is False, it will just report the changes to be made.
'''
import leo.core.leoFrame as leoFrame
replace = False
aList = sorted([z for z in dir(leoFrame.WrapperAPI) if not z.startswith('__')])
nodes = 0
for p in c.all_unique_positions():
    s = p.b
    nodes += 1
    found = False
    for target in aList:
        i = 0
        pattern = 'body.' + target
        while True:
            i = s.find(pattern,i)
            if i == -1:
                break
            if g.match_word(s,i,pattern):
                if not found:
                    print('In node: %s' % p.h)
                    found = True
                i1,i2 = g.getLine(s,i)
                if replace:
                    j = i + len('body.')
                    s = s[:j] + 'wrapper.' + s[j:]
                    print(s[i1:i2+len('wrapper.')].rstrip())
                    i += len('wrapper.') + len(pattern)
                else:
                    print(s[i1:i2].rstrip())
                    i += len(pattern)
            else:
                i += len(pattern)
    if found and replace:
        p.b = s
print('searched %s nodes' % nodes)
</t>
<t tx="ekr.20140905060158.18561">a = c.frame.body.getInsertPoint()

aBody.getInsertPoint()

if 1:
    c.frame.body.setInsertPoint(0)</t>
<t tx="ekr.20140906081909.18689"># This is c.frame.body.colorizer

class QScintillaColorizer(ColorizerMixin):
    '''A colorizer for a QsciScintilla widget.'''
    @others
</t>
<t tx="ekr.20140906081909.18690">class ColorizerMixin(object):
    '''A mixin class for all c.frame.body.colorizer classes.'''

    def __init__(self, c):
        '''Ctor for ColorizerMixin class.'''
        self.c = c

    def colorize(self, p, incremental=False, interruptable=True):
        assert False, 'colorize must be defined in sublcasses'

    def kill(self):
        '''Kill colorizing.'''
        pass

    def write_colorizer_cache(self, p):
        '''Write colorizing data for p for later use by rehighlight_with_cache.'''
        pass
    @others
</t>
<t tx="ekr.20140906081909.18697">def scanColorDirectives(self, p):
    '''Set self.language based on the directives in p's tree.'''
    trace = False and not g.unitTesting
    c = self.c
    if not c:
        return None # self.c may be None for testing.
    root = p.copy()
    self.colorCacheFlag = False
    self.language = None
    self.rootMode = None # None, "code" or "doc"
    for p in root.self_and_parents():
        theDict = g.get_directives_dict(p)
        # if trace: g.trace(p.h,theDict)
        if p == root:
            # The @colorcache directive is a per-node directive.
            self.colorCacheFlag = 'colorcache' in theDict
            # g.trace('colorCacheFlag: %s' % self.colorCacheFlag)
        if 'language' in theDict:
            s = theDict["language"]
            aList = self.findLanguageDirectives(p)
            # In the root node, we use the first (valid) @language directive,
            # no matter how many @language directives the root node contains.
            # In ancestor nodes, only unambiguous @language directives
            # set self.language.
            if p == root or len(aList) == 1:
                self.languageList = list(set(aList))
                self.language = aList and aList[0] or []
                break
        if 'root' in theDict and not self.rootMode:
            s = theDict["root"]
            if g.match_word(s, 0, "@root-code"):
                self.rootMode = "code"
            elif g.match_word(s, 0, "@root-doc"):
                self.rootMode = "doc"
            else:
                doc = c.config.at_root_bodies_start_in_doc_mode
                self.rootMode = "doc" if doc else "code"
    # If no language, get the language from any @&lt;file&gt; node.
    if self.language:
        if trace: g.trace('found @language %s %s' % (self.language, self.languageList))
        return self.language
    #  Attempt to get the language from the nearest enclosing @&lt;file&gt; node.
    self.language = g.getLanguageFromAncestorAtFileNode(root)
    if not self.language:
        if trace: g.trace('using default', c.target_language)
        self.language = c.target_language
    return self.language # For use by external routines.
</t>
<t tx="ekr.20140906081909.18701">def findLanguageDirectives(self, p):
    '''Scan p's body text for *valid* @language directives.

    Return a list of languages.'''
    # Speed not very important: called only for nodes containing @language directives.
    trace = False and not g.unitTesting
    aList = []
    for s in g.splitLines(p.b):
        if g.match_word(s, 0, '@language'):
            i = len('@language')
            i = g.skip_ws(s, i)
            j = g.skip_id(s, i)
            if j &gt; i:
                word = s[i: j]
                if self.isValidLanguage(word):
                    aList.append(word)
                else:
                    if trace: g.trace('invalid', word)
    if trace: g.trace(aList)
    return aList
</t>
<t tx="ekr.20140906081909.18702">def isValidLanguage(self, language):
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', '%s.py' % (language))
    return g.os_path_exists(fn)
</t>
<t tx="ekr.20140906081909.18704">def updateSyntaxColorer(self, p):
    '''Scan p.b for color directives.'''
    trace = False and not g.unitTesting
    # An important hack: shortcut everything if the first line is @killcolor.
    if p.b.startswith('@killcolor'):
        if trace: g.trace('@killcolor')
        self.flag = False
        return self.flag
    else:
        # self.flag is True unless an unambiguous @nocolor is seen.
        p = p.copy()
        self.flag = self.useSyntaxColoring(p)
        self.scanColorDirectives(p) # Sets self.language
    if trace: g.trace(self.flag, len(p.b), self.language, p.h, g.callers(5))
    return self.flag
</t>
<t tx="ekr.20140906081909.18707">def colorize(self, p, incremental=False, interruptable=True):
    '''The main Scintilla colorizer entry point.'''
    trace = False and not g.unitTesting
    self.count += 1 # For unit testing.
    if not incremental:
        self.full_recolor_count += 1
    if p.b.startswith('@killcolor'):
        if trace: g.trace('kill: @killcolor')
        self.kill()
    else:
        self.updateSyntaxColorer(p)
            # sets self.flag and self.language and self.languageList.
        if trace: g.trace(self.language)
        self.changeLexer(self.language)
    return "ok" # For unit testing.
</t>
<t tx="ekr.20140906081909.18709">def __init__(self, c, widget):
    '''Ctor for QScintillaColorizer. widget is a '''
    # g.trace('QScintillaColorizer)',widget)
    ColorizerMixin.__init__(self, c)
        # init the base class.
    self.changingText = False
    self.count = 0 # For unit testing.
    self.colorCacheFlag = False
    self.enabled = c.config.getBool('use_syntax_coloring')
    self.error = False # Set if there is an error in jeditColorizer.recolor
    self.flag = True # Per-node enable/disable flag.
    self.full_recolor_count = 0 # For unit testing.
    self.language = 'python' # set by scanColorDirectives.
    self.languageList = [] # List of color directives in the node the determines it.
    self.lexer = None # Set in changeLexer.
    self.oldLanguageList = []
    self.showInvisibles = False
    widget.leo_colorizer = self
    # Define/configure various lexers.
    if Qsci:
        self.lexersDict = {
            'python': Qsci.QsciLexerPython(parent=c.frame.body.wrapper.widget),
            # 'python': PythonLexer(parent=c.frame.body.wrapper.widget),
        }
        self.nullLexer = NullScintillaLexer(c)
    else:
        self.lexersDict = {}
        self.nullLexer = None
    lexer = self.lexersDict.get('python')
    self.configure_lexer(lexer)
</t>
<t tx="ekr.20140906081909.18711">def scanColorByPosition(self, p):
    '''Scan p for color-related directives.'''
    c = self.c
    wrapper = c.frame.body.wrapper
    i = wrapper.getInsertPoint()
    s = wrapper.getAllText()
    i1, i2 = g.getLine(s, i)
    tag = '@language'
    language = self.language
    for s in g.splitLines(s[: i1]):
        if s.startswith(tag):
            language = s[len(tag):].strip()
    return language
</t>
<t tx="ekr.20140906081909.18714">def useSyntaxColoring(self, p):
    """Return True unless p is unambiguously under the control of @nocolor."""
    trace = False and not g.unitTesting
    if not p:
        if trace: g.trace('no p', repr(p))
        return False
    p = p.copy()
    first = True; kind = None; val = True
    self.killColorFlag = False
    for p in p.self_and_parents():
        d = self.findColorDirectives(p)
        color, no_color = 'color' in d, 'nocolor' in d
        # An @nocolor-node in the first node disabled coloring.
        if first and 'nocolor-node' in d:
            kind = '@nocolor-node'
            self.killColorFlag = True
            val = False; break
        # A killcolor anywhere disables coloring.
        elif 'killcolor' in d:
            kind = '@killcolor %s' % p.h
            self.killColorFlag = True
            val = False; break
        # A color anywhere in the target enables coloring.
        elif color and first:
            kind = 'color %s' % p.h
            val = True; break
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            kind = '@nocolor %s' % p.h
            val = False; break
        elif color and not no_color:
            kind = '@color %s' % p.h
            val = True; break
        first = False
    if trace: g.trace(val, kind)
    return val
</t>
<t tx="ekr.20140906081909.18715">color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    , re.MULTILINE)

def findColorDirectives(self, p):
    '''
    Scan p for @color, @killcolor, @nocolor and @nocolor-node directives.

    Return a dict containing pointers to the start of each directive.
    '''
    trace = False and not g.unitTesting
    d = {}
    anIter = self.color_directives_pat.finditer(p.b)
    for m in anIter:
        # Remove leading '@' for compatibility with
        # functions in leoGlobals.py.
        word = m.group(0)[1:]
        d[word] = word
    if trace: g.trace(d)
    return d
</t>
<t tx="ekr.20140906081909.18716">def kill(self):
    '''Kill coloring for this node.'''
    self.changeLexer(language=None)
</t>
<t tx="ekr.20140906081909.18718">def changeLexer(self, language):
    '''Set the lexer for the given language.'''
    c = self.c
    wrapper = c.frame.body.wrapper
    w = wrapper.widget # A Qsci.QsciSintilla object.
    self.lexer = self.lexersDict.get(language, self.nullLexer)
    w.setLexer(self.lexer)
    # g.trace(language,self.lexer)
</t>
<t tx="ekr.20140906095826.18717">if Qsci:

    class NullScintillaLexer(Qsci.QsciLexerCustom):
        '''A do-nothing colorizer for Scintilla.'''

        def __init__(self, c, parent=None):
            Qsci.QsciLexerCustom.__init__(self, parent)
                # Init the pase class
            self.leo_c = c
            self.configure_lexer()

        def description(self, style):
            return 'NullScintillaLexer'

        def setStyling(self, length, style):
            g.trace('(NullScintillaLexer)', length, style)

        def styleText(self, start, end):
            '''Style the text from start to end.'''
            # g.trace('(NullScintillaLexer)',start,end)

        def configure_lexer(self):
            '''Configure the QScintilla lexer.'''
            # c = self.leo_c
            lexer = self
            # To do: use c.config setting.
            # pylint: disable=no-member
            font = QtGui.QFont("DejaVu Sans Mono", 14)
            lexer.setFont(font)
</t>
<t tx="ekr.20140906095826.18721">def configure_lexer(self, lexer):
    '''Configure the QScintilla lexer.'''
    # return # Try to use  USERPROFILE:SciTEUser.properties

    def oops(s):
        g.trace('bad @data qt-scintilla-styles:', s)
    # A small font size, to be magnified.

    c = self.c
    qcolor, qfont = QtGui.QColor, QtGui.QFont
    # font = qfont("Courier New",8,qfont.Bold)
    font = qfont("DejaVu Sans Mono", 14)
    lexer.setFont(font)
    lexer.setEolFill(False, -1)
    lexer.setStringsOverNewlineAllowed(False)
    table = None
    aList = c.config.getData('qt-scintilla-styles')
    if aList:
        aList = [s.split(',') for s in aList]
        table = []
        for z in aList:
            if len(z) == 2:
                color, style = z
                table.append((color.strip(), style.strip()),)
            else: oops('entry: %s' % z)
        # g.trace('@data ** qt-scintilla-styles',table)
    if not table:
        # g.trace('using default color table')
        black = '#000000'
        leo_green = '#00aa00'
        # See http://pyqt.sourceforge.net/Docs/QScintilla2/classQsciLexerPython.html
        # for list of selector names.
        table = (
            # EKR's personal settings: they are reasonable defaults.
            (black, 'ClassName'),
            ('#CD2626', 'Comment'), # Firebrick3
            (leo_green, 'Decorator'),
            (leo_green, 'DoubleQuotedString'),
            (black, 'FunctionMethodName'),
            ('blue', 'Keyword'),
            (black, 'Number'),
            (leo_green, 'SingleQuotedString'), # Leo green.
            (leo_green, 'TripleSingleQuotedString'),
            (leo_green, 'TripleDoubleQuotedString'),
            (leo_green, 'UnclosedString'),
            # End of line where string is not closed
            # style.python.13=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
        )
    for color, style in table:
        if hasattr(lexer, style):
            style_number = getattr(lexer, style)
            try:
                # g.trace(color,style)
                lexer.setColor(qcolor(color), style_number)
            except Exception:
                oops('bad color: %s' % color)
        else: oops('bad style name: %s' % style)
</t>
<t tx="ekr.20140906143232.18697"># Stuck: regardless of class: there seems to be no way to force a recolor.
if Qsci:

    class PythonLexer(Qsci.QsciLexerCustom):
        '''A subclass of the Python lexer that colorizers section references.'''

        def __init__(self, parent=None):
            '''Ctor for PythonLexer class.'''
            Qsci.QsciLexerCustom.__init__(self, parent)
                # Init the base class.
            self.lexer = None
            self.parent = parent
            self.tag = '(PythonLexer)'

        def setStringsOverNewlineAllowed(self, aBool):
            pass

        def description(self, style):
            return self.tag

        def setStyling(self, length, style):
            g.trace(self.tag, length, style)

        def styleText(self, start, end):
            '''Style the text from start to end.'''
            g.trace(self.tag, start, end)
            self.lexer = Qsci.QsciLexerPython(parent=self.parent)
            self.lexer.setStringsOverNewlineAllowed(True)
            # self.lexer.styleText(start,end)

        def configure_lexer(self):
            '''Configure the QScintilla lexer.'''
            lexer = self
            # To do: use c.config setting.
            # pylint: disable=no-member
            font = QtGui.QFont("DejaVu Sans Mono", 14)
            lexer.setFont(font)
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140918124632.19450"># This script prints the list of known Qt names. Qt seems to ignore case.
from leo.core.leoQt import QtGui
aList = sorted([g.u(z) for z in QtGui.QColor().colorNames()])
print('\n'.join(aList))
</t>
<t tx="ekr.20140919093158.17876"></t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20140923085942.17943"></t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
import leo.core.leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    # g.trace('modes/forth.py',c)
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()
</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    '''Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule'''
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)
</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    '''Create an entry in d for a string keyword.'''
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False) # Don't require ending word.

    return forth_string_word_rule
</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList
    # g.trace(z,kind)
</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule20(colorer, s, i):
        return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.
properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {} # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}
</t>
<t tx="ekr.20150326145530.4">class extendForth(object):
    '''A helper class to extend the mode tables from @data forth-x settings.'''
    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None # set by pre_init_mode function.
    # g.trace('modes/forth.py:extendForth')
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = [] # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False # True: tell when extending forth words.
    # g.trace('rulesDict...\n',g.dictToString(rulesDict),tag='rulesDict...')
</t>
<t tx="ekr.20150326145530.6">def init(self):
    '''Set our ivars from settings.'''
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for(ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    # g.trace(setting,s)
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for(ivar, setting) in table2:
        self.splitList(ivar, setting)
    # g.trace('keywords',self.keywords)
</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    '''Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2.'''
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)
    if 0:
        g.trace(name1, getattr(self, name1))
        g.trace(name2, getattr(self, name2))
</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True) # Require word.

    return forth_bracket_rule
</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2", # defining word
            word=word,
            kind2="keyword3", # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule
</t>
<t tx="ekr.20150413091056.1">'''Warn if leoProjects.txt or leoToDo.txt contain any clones.'''

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    '''Warn if p appears in any @&lt;file&gt; node outside of root's tree.'''
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425145248.1">run-pylint
clone-to-at-spot
beautify-tree
cfa-code
sort-lines
# show-data
# test-ptb
check-clones
expand-log-pane
contract-log-pane</t>
<t tx="ekr.20150502050609.1">@language python
'''Save a copy of this file to the Backup directory.'''
theDir,base = g.os_path_split(c.fileName())
path = g.os_path_join('~/Dropbox/','backups','leoPy',base)
c.backup(path, useTimeStamp=True)
    # Dropbox can show previous versions!
    # But this depends on proxy/firewall settings.
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators(object):
    '''
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    '''
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    '''Return munged lines of '''
    # print('')
    # g.trace(root.h)
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    # print(s)
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    # print('\n'.join(lines))
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    '''Top-level code.'''
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    '''Create decorators for all items in d in root's tree.'''
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    if trace:
        print('')
        g.trace(publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    '''Return the position of the class enclosing p.'''
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree():
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    '''
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    '''
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators(object):
    '''
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    '''
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree():
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    '''Create decorators for all items in d in root's tree.'''
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %s' % (f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    '''Return munged lines of s. '''
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    '''Top-level code.'''
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150509183832.1"># 'check-all-python-code':      c.checkAllPythonCode,
# 'check-python-code':          c.checkPythonCode,
# 'extract-python-method':        c.extractPythonMethod,
# 'extract-section':              c.extractSection,
# 'import-at-file':               c.importAtFile,
# 'import-at-root':               c.importAtRoot,
# 'import-cweb-files':            c.importCWEBFiles,
# 'import-derived-file':          c.importDerivedFile,
# 'import-flattened-outline':     c.importFlattenedOutline,
# 'import-noweb-files':           c.importNowebFiles,
# 'mark-changed-roots':           c.markChangedRoots,
# 'mark-clones':                c.markClones,
# 'open-compare-window':        c.openCompareWindow,
# 'open-online-tutorial':       c.leoTutorial,
# 'reformat-body':              c.reformatBody, # 2013/10/02.
def define_s(self):
    return '''
'abort-edit-headline':          f.abortEditLabelCommand,
'about-leo':                    c.about,
'add-comments':                 c.addComments,     
'beautify':                     c.beautifyPythonCode,
'beautify-all':                 c.beautifyAllPythonCode,
'beautify-c':                   c.beautifyCCode,
'beautify-tree':                c.beautifyPythonTree,
'cascade-windows':              f.cascade,
'check-derived-file':           c.atFileCommands.checkDerivedFile,
'check-leo-file':               c.fileCommands.checkLeoFile,
'check-outline':                c.fullCheckOutline,
'clean-recent-files':           c.cleanRecentFiles,
'clear-recent-files':           c.clearRecentFiles,
'clone-node':                   c.clone,
'clone-node-to-last-node':      c.cloneToLastNode,
'close-window':                 c.close,
'contract-all':                 c.contractAllHeadlines,
'contract-all-other-nodes':     c.contractAllOtherNodes,
'contract-node':                c.contractNode,
'contract-or-go-left':          c.contractNodeOrGoToParent,
'contract-parent':              c.contractParent,
'convert-all-blanks':           c.convertAllBlanks,
'convert-all-tabs':             c.convertAllTabs,
'convert-blanks':               c.convertBlanks,
'convert-tabs':                 c.convertTabs,
'copy-node':                    c.copyOutline,
'copy-text':                    f.copyText,
'cut-node':                     c.cutOutline,
'cut-text':                     f.cutText,
'de-hoist':                     c.dehoist,
'delete-comments':              c.deleteComments,
'delete-node':                  c.deleteOutline,
'demote':                       c.demote,
'dump-outline':                 c.dumpOutline,
'edit-headline':                c.editHeadline,
'end-edit-headline':            f.endEditLabelCommand,
'equal-sized-panes':            f.equalSizedPanes,
'execute-script':               c.executeScript,
'exit-leo':                     g.app.onQuit,
'expand-all':                   c.expandAllHeadlines,
'expand-all-subheads':          c.expandAllSubheads,
'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
'expand-next-level':            c.expandNextLevel,
'expand-node':                  c.expandNode,
'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
'expand-prev-level':            c.expandPrevLevel,
'expand-to-level-1':            c.expandLevel1,
'expand-to-level-2':            c.expandLevel2,
'expand-to-level-3':            c.expandLevel3,
'expand-to-level-4':            c.expandLevel4,
'expand-to-level-5':            c.expandLevel5,
'expand-to-level-6':            c.expandLevel6,
'expand-to-level-7':            c.expandLevel7,
'expand-to-level-8':            c.expandLevel8,
'expand-to-level-9':            c.expandLevel9,
'export-headlines':             c.exportHeadlines,
'extract':                      c.extract,
'extract-names':                c.extractSectionNames,
'find-next-clone':              c.findNextClone,
'flatten-outline':              c.flattenOutline,
'flatten-outline-to-node':      c.flattenOutlineToNode,
'go-back':                      c.goPrevVisitedNode,
'go-forward':                   c.goNextVisitedNode,
'goto-first-node':              c.goToFirstNode,
'goto-first-sibling':           c.goToFirstSibling,
'goto-first-visible-node':      c.goToFirstVisibleNode,
'goto-last-node':               c.goToLastNode,
'goto-last-sibling':            c.goToLastSibling,
'goto-last-visible-node':       c.goToLastVisibleNode,
'goto-next-changed':            c.goToNextDirtyHeadline,
'goto-next-clone':              c.goToNextClone,
'goto-next-history-node':       c.goToNextHistory,
'goto-next-marked':             c.goToNextMarkedHeadline,
'goto-next-node':               c.selectThreadNext,
'goto-next-sibling':            c.goToNextSibling,
'goto-next-visible':            c.selectVisNext,
'goto-parent':                  c.goToParent,
'goto-prev-history-node':       c.goToPrevHistory,
'goto-prev-node':               c.selectThreadBack,
'goto-prev-sibling':            c.goToPrevSibling,
'goto-prev-visible':            c.selectVisBack,
'hide-invisibles':              c.hideInvisibles,
'hoist':                        c.hoist,
'import-file':                  c.importAnyFile,
'indent-region':                c.indentBody,
'insert-body-time':             c.insertBodyTime,
'insert-child':                 c.insertChild,
'insert-node':                  c.insertHeadline,
'insert-node-before':           c.insertHeadlineBefore,
'mark':                         c.markHeadline,
'mark-changed-items':           c.markChangedHeadlines,
'mark-subheads':                c.markSubheads,
'match-brackets':               c.findMatchingBracket,
'minimize-all':                 f.minimizeAll,
'move-outline-down':            c.moveOutlineDown,
'move-outline-left':            c.moveOutlineLeft,
'move-outline-right':           c.moveOutlineRight,
'move-outline-up':              c.moveOutlineUp,
'new':                          c.new,
'open-cheat-sheet-leo':         c.openCheatSheet,
'open-leoDocs-leo':             c.leoDocumentation,
'open-leoPlugins-leo':          c.openLeoPlugins,
'open-leoSettings-leo':         c.openLeoSettings,
'open-local-settings':          c.selectAtSettingsNode,
'open-myLeoSettings-leo':       c.openMyLeoSettings,
'open-offline-tutorial':        f.leoHelp,
'open-online-home':             c.leoHome,
'open-online-toc':              c.openLeoTOC,
'open-online-tutorials':        c.openLeoTutorials,
'open-online-videos':           c.openLeoVideos,
'open-outline':                 c.open,
'open-python-window':           c.openPythonWindow,
'open-quickstart-leo':          c.leoQuickStart,
'open-scripts-leo':             c.openLeoScripts,
'open-users-guide':             c.openLeoUsersGuide,
'open-with':                    c.openWith,
'outline-to-cweb':              c.outlineToCWEB,
'outline-to-noweb':             c.outlineToNoweb,
'paste-node':                   c.pasteOutline,
'paste-retaining-clones':       c.pasteOutlineRetainingClones,
'paste-text':                   f.pasteText,
'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
'pretty-print-python-code':     c.prettyPrintPythonCode,
'promote':                      c.promote,
'read-at-auto-nodes':           c.readAtAutoNodes,
'read-at-file-nodes':           c.readAtFileNodes,
'read-at-shadow-nodes':         c.readAtShadowNodes,
'read-file-into-node':          c.readFileIntoNode,
'read-outline-only':            c.readOutlineOnly,
'redo':                         c.undoer.redo,
'reformat-paragraph':           c.reformatParagraph,
'refresh-from-disk':            c.refreshFromDisk,
'remove-sentinels':             c.removeSentinels,
'resize-to-screen':             f.resizeToScreen,
'revert':                       c.revert,
'save-all':                     c.saveAll,
'save-file':                    c.save,
'save-file-as':                 c.saveAs,
'save-file-as-unzipped':        c.saveAsUnzipped,
'save-file-as-zipped':          c.saveAsZipped,
'save-file-to':                 c.saveTo,
'set-colors':                   c.colorPanel,
'set-font':                     c.fontPanel,
'settings':                     c.preferences,
'show-invisibles':              c.showInvisibles,
'sort-children':                c.sortChildren,
'sort-recent-files':            c.sortRecentFiles,
'sort-siblings':                c.sortSiblings,
'tangle':                       c.tangle,
'tangle-all':                   c.tangleAll,
'tangle-marked':                c.tangleMarked,
'toggle-active-pane':           f.toggleActivePane,
'toggle-angle-brackets':        c.toggleAngleBrackets,
'toggle-invisibles':            c.toggleShowInvisibles,
'toggle-sparse-move':           c.toggleSparseMove,
'toggle-split-direction':       f.toggleSplitDirection,
'undo':                         c.undoer.undo,
'unformat-paragraph':           c.unformatParagraph,
'unindent-region':              c.dedentBody,
'unmark-all':                   c.unmarkAll,
'untangle':                     c.untangle,
'untangle-all':                 c.untangleAll,
'untangle-marked':              c.untangleMarked,
'weave':                        c.weave,
'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
'write-file-from-node':         c.writeFileFromNode,
'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
'write-outline-only':           c.fileCommands.writeOutlineOnly,
'''
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150531102337.1"></t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150617060607.1"></t>
<t tx="ekr.20150622072456.1">def match_at_wrap(self, s, i):
    '''Match Leo's @wrap directive.'''
    c = self.c
    trace = (False or self.trace_leo_matches) and not g.unitTesting
    if trace: g.trace(i, repr(s))
    # Only matches at start of line.
    seq = '@wrap'
    if i == 0 and g.match_word(s, i, seq):
        j = i + len(seq)
        k = g.skip_ws(s, j)
        self.colorRangeWithTag(s, i, k, 'leokeyword')
        self.clearState()
        c.frame.setWrap(c.p, force=True)
        return k - i
    else:
        return 0
</t>
<t tx="ekr.20150703061709.1">@language python

'''myLeoSettings.py: save the outline and run the pylint command'''

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20160122104332.1"></t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160226082945.1"></t>
<t tx="ekr.20160315161104.1">&lt;&lt; imports &gt;&gt;
g.cls()
if c.isChanged(): c.save()
@others
path = g.os_path_finalize_join(g.app.loadDir,
    '..', 'test', 'report_test.py') # 'leoAst.py')
assert g.os_path_exists(path), path
fn = g.shortFileName(path)
source = open(path, 'r').read()
node = ast.parse(source, filename=fn, mode='exec')
s = HTMLReportTraverser(debug=True).main(fn, node)
out_fn = g.os_path_finalize_join(g.app.loadDir, '..', 'test', 
    'HTMLReportTraverser_test.html')
open(out_fn, 'w').write(s)
# print('%s %s' % (len(s), out_fn))
os.startfile(out_fn)
# os.system('ed ' + out_fn)</t>
<t tx="ekr.20160315163533.1">import leo.core.leoAst as leoAst
import ast
import os
import xml.sax.saxutils as saxutils
import textwrap
# Needed only for the script version
AstFullTraverser = leoAst.AstFullTraverser</t>
<t tx="ekr.20160316065700.1">'''Test file for HTMLReportTraverser class.'''
&lt;&lt; includes &gt;&gt;
@others

</t>
<t tx="ekr.20160316065936.1">import ast
import xml.sax.saxutils as saxutils
import leo.core.leoGlobals as g</t>
<t tx="ekr.20160316070146.1">class TestClass(object):
    '''A class exercising important cases in the HTMLReportTraverser code.'''
    @others</t>
<t tx="ekr.20160316070255.1">def if_tests(self, a, b):
    '''Test if statements, especially 'elif' vs. 'else if'.'''
    if a and b:
        rt.gen("&lt;div class='%s' %s&gt;" % (full_class_name, extra))
    elif a:
        rt.gen("&lt;div class='%s'&gt;" % (full_class_name))
    else:
        assert not extra
        rt.gen("&lt;div&gt;")
    if a:
        print('a')
    else: # elif is not correct here.
        if b:
            print(b)
        print(c)</t>
<t tx="ekr.20160316070709.1">def comprehension_tests(self):
    '''Test comprehensions'''
    for i, aList in enumerate(self.line_tokens):
        print('hi')
    return [z for z in aList if self.token_kind(z) == 'string']
</t>
<t tx="ekr.20160316081359.1">def try_tests(self):
    '''Test try/except/finally'''
    try:
        for z in node.optional_vars:
            vars_list.append(self.visit(z))
    except TypeError:
        vars_list.append(self.visit(node.optional_vars))
    finally:
        print('ooops')
        raise
    </t>
<t tx="ekr.20160316091152.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others



</t>
<t tx="ekr.20160316091152.2">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20160316091152.3">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20160316091152.4">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20160316091152.5">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream  
February 20 to 25, 2016
</t>
<t tx="ekr.20160316091923.1">@cmd('python-to-coffeescript')
def python2coffeescript(self, event):
    '''
    Converts python text to coffeescript text. The conversion is not
    perfect, but it eliminates a lot of tedious text manipulation.
    '''
    @others
    c = self.c
    Python_To_Coffeescript_Adapter(c).main()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20160316092837.1">class Python_To_Coffeescript_Adapter(object):
    '''An interface class between Leo and leo/external/py2cs.py.'''
    @others
</t>
<t tx="ekr.20160316093019.1">def main(self):
    '''Main line for Python_To_CoffeeScript class.'''
    if self.py2cs:
        self.run()
    else:
        g.es_print('can not load py2cs.py')
</t>
<t tx="ekr.20160316094011.7">def finalize(self, fn):
    '''Finalize and regularize a filename.'''
    return g.os_path_normpath(g.os_path_abspath(g.os_path_expanduser(fn)))
</t>
<t tx="ekr.20160316094011.8">def to_coffeescript(self, p):
    '''Convert the @&lt;file&gt; node at p to a .coffee file.'''
    assert p.isAnyAtFileNode()
    c = self.c
    fn = p.anyAtFileNodeName()
    if not fn.endswith('.py'):
        g.es_print('not a python file', fn)
        return
    abs_fn = g.fullPath(c, p)
    if not g.os_path_exists(abs_fn):
        g.es_print('not found', abs_fn)
        return
    if g.os_path_exists(self.output_directory):
        base_fn = g.os_path_basename(fn)
        out_fn = g.os_path_finalize_join(self.output_directory, base_fn)
    else:
        g.es_print('not found', self.output_directory)
        return
    out_fn = out_fn[:-3] + '.coffee'
    out_fn = g.os_path_normpath(out_fn)
    s = open(abs_fn).read()
    # s = self.strip_sentinels(s)
    if 0:
        for z in g.splitLines(s)[:20]:
            print(z.rstrip())
    x = self.py2cs.MakeCoffeeScriptController()
    # copy ivars and run.
    x.enable_unit_tests = False
    x.files = [abs_fn,]
    x.output_directory = self.output_directory
    x.overwrite = self.overwrite
    x.make_coffeescript_file(abs_fn, s=s)
</t>
<t tx="ekr.20160316094011.9">def run(self):
    '''Create .coffee files for all @&lt;file&gt; nodes in p's tree.'''
    p = c.p
    if p.isAnyAtFileNode():
        self.to_coffeescript(p)
        return
    # First, look down tree.
    after, p2 = p.nodeAfterTree(), p.firstChild()
    found = False
    while p2 and p != after:
        if p2.isAnyAtFileNode():
            self.to_coffeescript(p2)
            p2.moveToNext()
            found = True
        else:
            p2.moveToThreadNext()
    if not found:
        # Look up the tree.
        for p2 in p.parents():
            if p2.isAnyAtFileNode():
                self.to_coffeescript(p2)
                return
    g.es_print('no files found in tree:', p.h)
</t>
<t tx="ekr.20160316100329.1">from leo.commands.baseCommands import BaseEditCommandsClass as BaseEditCommandsClass
# h = '@file ../commands/convertCommands.py'
# p = g.findNodeAnywhere(c, h)
old_p = c.p
try:
    # c.selectPosition(p)
    # assert p, h
    @others
    class Dummy:
        def __init__(self, c):
            self.c = c
    python2coffeescript(self=Dummy(c), event=None)
finally:
    pass
    # c.selectPosition(old_p)
</t>
<t tx="ekr.20160316100524.1">def cmd(name):
    '''Command decorator for the ConvertCommandsClass class.'''
    return g.new_cmd_decorator(name, ['c', 'convertCommands',])
</t>
<t tx="ekr.20160316112717.1">def __init__(self,c):
    '''Ctor for Python_To_Coffeescript_Adapter class.'''
    self.c = c
    self.files = []
    self.output_directory = self.finalize(
        c.config.getString('py2cs-output-directory'))
    # self.output_fn = None
    self.overwrite = c.config.getBool('py2cs-overwrite', default=False)
    # Connect to the external module.
    self.py2cs = g.importExtension(
        'py2cs',
        pluginName=None,
        verbose=False,
        required=False,
    )
</t>
<t tx="ekr.20160316141812.1">def strip_sentinels(self, s):
    '''
    Strip s of all sentinel lines.
    This may be dubious because it destroys outline structure.
    '''
    delims = ['#', None, None]
    return ''.join([z for z in g.splitLines(s) if not g.is_sentinel(z, delims)])
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20170107222248.1"></t>
</tnodes>
</leo_file>
