<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="37" left="325" height="977" width="948"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="6"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20090514093345.6054"><vh>Disabled buttons</vh>
<v t="ekr.20070628175250"><vh>@@button Add if g.unitTesting @key=f6</vh></v>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
</v>
<v t="ekr.20070605104410"><vh>@chapters</vh></v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933" annotate="7d71002855046e6f6465710155007102550262677103680255087072696f72697479710455043939393971055502666771066802550870726f677265737371076802550961726368657479706571086802752e" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f7461746571037d71042855046e6f6465710555007106550262677107680655087072696f726974797108550439393939710955026667710a6806550870726f6772657373710b68065509617263686574797065710c68067573732e"
expanded="ekr.20090513153807.5743,ekr.20070627135407,ekr.20070627140344,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20090518072506.8310"><vh>To do first</vh>
<v t="ekr.20090518072506.8495"><vh>Fix ctrl-s bug</vh></v>
<v t="ekr.20090518072506.8311"><vh>Fix @thin bug!!</vh></v>
<v t="ekr.20090514111518.5660"><vh>Sorting can revert headline changes</vh></v>
<v t="ekr.20090511055302.5784"><vh>Finish rst.  @auto-rst</vh>
<v t="ekr.20090512080015.5801"><vh>import-files-recursively command?</vh></v>
<v t="ekr.20090512080015.5794"><vh>rst scanning</vh>
<v t="ekr.20090502071837.93"><vh>underline (leoRst)</vh></v>
<v t="ekr.20070703122141.65"><vh>&lt;&lt; class baseScannerClass &gt;&gt;</vh>
<v t="ekr.20070703122141.66"><vh>baseScannerClass.__init__</vh></v>
<v t="ekr.20070808115837"><vh>Checking</vh>
<v t="ekr.20070703122141.102"><vh>check</vh></v>
<v t="ekr.20070703122141.104"><vh>checkTrialWrite (baseScannerClass)</vh></v>
<v t="ekr.20070730093735"><vh>compareHelper &amp; helper</vh>
<v t="ekr.20090513073632.5735"><vh>compareRstUnderlines</vh></v>
</v>
<v t="ekr.20071110144948"><vh>checkLeadingWhitespace</vh></v>
<v t="ekr.20070911110507"><vh>reportMismatch &amp; test</vh>
<v t="ekr.20090517020744.5785"><vh>@test reportMismatch</vh></v>
</v>
</v>
<v t="ekr.20070706084535"><vh>Code generation</vh>
<v t="ekr.20090512080015.5800"><vh>adjustParent</vh></v>
<v t="ekr.20070707073044.1"><vh>addRef</vh></v>
<v t="ekr.20090122201952.6"><vh>appendStringToBody &amp; setBodyString (baseScannerClass)</vh></v>
<v t="ekr.20090512153903.5806"><vh>computeBody (baseScannerClass)</vh>
<v t="ekr.20090515065255.5678"><vh>@test</vh></v>
</v>
<v t="ekr.20090513073632.5737"><vh>createDeclsNode</vh></v>
<v t="ekr.20070707085612"><vh>createFunctionNode</vh></v>
<v t="ekr.20070703122141.77"><vh>createHeadline</vh></v>
<v t="ekr.20090502071837.1"><vh>endGen</vh></v>
<v t="ekr.20070703122141.79"><vh>getLeadingIndent</vh></v>
<v t="ekr.20070709094002"><vh>indentBody</vh></v>
<v t="ekr.20070705085335"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20070707113832.1"><vh>putClass &amp; helpers</vh>
<v t="ekr.20070707190351"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20070703122141.105"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20070703122141.106"><vh>getClassNodeRef</vh></v>
<v t="ekr.20070707171329"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20070707082432"><vh>putFunction (baseScannerClass)</vh></v>
<v t="ekr.20070705094630"><vh>putRootText</vh></v>
<v t="ekr.20090122201952.5"><vh>setBodyString</vh></v>
<v t="ekr.20070703122141.88"><vh>undentBody</vh></v>
<v t="ekr.20081216090156.1"><vh>undentBy</vh></v>
<v t="ekr.20070801074524"><vh>underindentedComment &amp; underindentedLine</vh></v>
</v>
<v t="ekr.20070703122141.78"><vh>error, oops, report and warning</vh></v>
<v t="ekr.20070706084535.1"><vh>Parsing</vh>
<v t="ekr.20071201072917"><vh>adjustDefStart</vh></v>
<v t="ekr.20070707150022"><vh>extendSignature</vh></v>
<v t="ekr.20071017132056"><vh>getIndent</vh></v>
<v t="ekr.20070706101600"><vh>scan &amp; scanHelper</vh>
<v t="ekr.20071018084830"><vh>scanHelper</vh></v>
</v>
<v t="ekr.20070712075148"><vh>skipArgs</vh></v>
<v t="ekr.20070707073859"><vh>skipBlock</vh></v>
<v t="ekr.20070712091019"><vh>skipCodeBlock</vh></v>
<v t="ekr.20070711104014"><vh>skipComment &amp; helper</vh>
<v t="ekr.20070707074541"><vh>skipBlockComment</vh></v>
</v>
<v t="ekr.20070707080042"><vh>skipDecls</vh></v>
<v t="ekr.20070707094858.1"><vh>skipId</vh></v>
<v t="ekr.20070730134936"><vh>skipNewline</vh></v>
<v t="ekr.20070712081451"><vh>skipParens</vh></v>
<v t="ekr.20070707073627.2"><vh>skipString</vh></v>
<v t="ekr.20070711132314"><vh>startsClass/Function (baseClass) &amp; helpers</vh>
<v t="ekr.20070711134534"><vh>getSigId</vh></v>
<v t="ekr.20070711140703"><vh>skipSigStart</vh></v>
<v t="ekr.20070712082913"><vh>skipSigTail</vh></v>
<v t="ekr.20070712112008"><vh>startsHelper</vh></v>
</v>
<v t="ekr.20070711104014.1"><vh>startsComment</vh></v>
<v t="ekr.20070707094858.2"><vh>startsId</vh></v>
<v t="ekr.20070707172732.1"><vh>startsString</vh></v>
</v>
<v t="ekr.20070707072749"><vh>run (baseScannerClass)</vh>
<v t="ekr.20071110105107"><vh>checkBlanksAndTabs</vh></v>
<v t="ekr.20070808115837.1"><vh>regularizeWhitespace</vh></v>
</v>
</v>
<v t="ekr.20090501095634.41"><vh>class rstScanner</vh>
<v t="ekr.20090501095634.42"><vh> __init__</vh></v>
<v t="ekr.20090512080015.5798"><vh>adjustParent</vh></v>
<v t="ekr.20090512080015.5797"><vh>computeSectionLevel</vh></v>
<v t="ekr.20090512153903.5810"><vh>createDeclsNode</vh></v>
<v t="ekr.20090502071837.2"><vh>endGen</vh></v>
<v t="ekr.20090501095634.46"><vh>isUnderLine</vh></v>
<v t="ekr.20090501095634.50"><vh>startsComment/ID/String</vh></v>
<v t="ekr.20090501095634.45"><vh>startsHelper</vh></v>
<v t="ekr.20090501095634.47"><vh>startsSection</vh></v>
</v>
</v>
<v t="ekr.20070730093735"></v>
<v t="ekr.20090502071837.58"><vh>write methods (leoRst)</vh>
<v t="ekr.20090502071837.59"><vh> Top-level write code</vh>
<v t="ekr.20090502071837.60"><vh>initWrite</vh></v>
<v t="ekr.20090512153903.5803"><vh>writeAtAutoFile (rstCommands)</vh>
<v t="ekr.20090513073632.5733"><vh>setAtAutoWriteOptions</vh></v>
</v>
<v t="ekr.20090502071837.61"><vh>writeNormalTree</vh></v>
<v t="ekr.20090502071837.62"><vh>processTopTree</vh></v>
<v t="ekr.20090502071837.63"><vh>processTree</vh></v>
<v t="ekr.20090502071837.64"><vh>writeSpecialTree</vh></v>
<v t="ekr.20090502071837.65"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090502071837.66"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="ekr.20090502071837.67"><vh>writeNodeToString (New in 4.4.1)</vh></v>
</v>
<v t="ekr.20090502071837.68"><vh>getDocPart</vh>
<v t="ekr.20090502071837.69"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20090502071837.70"><vh>skip_literal_block</vh></v>
<v t="ekr.20090502071837.71"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20090502071837.72"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20090502071837.73"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20090502071837.74"><vh>rstripList</vh></v>
<v t="ekr.20090502071837.75"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20090502071837.76"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20090502071837.77"><vh>isAnyDocPart</vh></v>
<v t="ekr.20090502071837.78"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20090502071837.79"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20090502071837.80"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20090502071837.81"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20090502071837.82"><vh>replaceCodeBlockDirectives</vh></v>
</v>
<v t="ekr.20090502071837.83"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20090502071837.84"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20090502071837.85"><vh>writeNode</vh></v>
<v t="ekr.20090502071837.86"><vh>writePreformat</vh></v>
<v t="ekr.20090502071837.87"><vh>writeTree</vh></v>
</v>
<v t="ekr.20090502071837.94"><vh>write (leoRst)</vh></v>
<v t="ekr.20090502071837.93"></v>
<v t="ekr.20090516135452.5776"><vh>g.removeTrailing and removeTrailingWs &amp; tests</vh>
<v t="ekr.20090516135452.5779"><vh>@test removeTrailing</vh></v>
</v>
<v t="ekr.20090516135452.5777"><vh>g.ensureTrailingNewlines &amp; tests</vh>
<v t="ekr.20090516135452.5778"><vh>@test ensureTrailingNewlines</vh></v>
</v>
<v t="ekr.20070911110507"></v>
</v>
<v t="ekr.20090518072506.8496"><vh>Move more unit tests into leoPy.leo</vh></v>
</v>
<v t="ekr.20090113083258.3"><vh>Unit tests &amp; helper files</vh>
<v t="ekr.20090514093345.6053"><vh>@button run-all-core-tests @key = Alt-7</vh></v>
<v t="ekr.20090517102212.5874"><vh>Helper files</vh>
<v t="ekr.20090517102548.5889"><vh>@@@mark-for-unit-tests</vh>
<v t="ekr.20090517020744.5906"><vh>@path ../test/unittest</vh>
<v t="ekr.20090517020744.5907"><vh>@@thin at-path-test2.py</vh></v>
</v>
<v t="ekr.20090517020744.5909"><vh>@path ../test</vh>
<v t="ekr.20090517020744.5910"><vh>@path unittest</vh>
<v t="ekr.20090517020744.5911"><vh>@@thin at-path-test3.py</vh></v>
</v>
</v>
<v t="ekr.20090517020744.5904"><vh>@@thin ../test/unittest/at-path-test1.py</vh></v>
</v>
</v>
<v t="ekr.20090113083258.1"><vh>@thin test_core.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20090128070032.1"><vh>  How to profile Leo</vh></v>
<v t="ekr.20081013084332.1"><vh>  Leo's MVC architecture</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"
expanded="ekr.20070227092442.2,"><vh>@thin leoBridge.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@thin leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005506302e31342e3071017d71025808000000616e6e6f7461746571037d710473732e"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@thin leoRst.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@thin leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
<v t="ekr.20031218072017.2605"
expanded="ekr.20031218072017.1934,"><vh>@thin runLeo.py </vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Test classes</vh>
<v t="ekr.20080730161153.2"
expanded="ekr.20080730161153.3,"><vh>@thin leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"
expanded="ekr.20080730161153.6,"><vh>@thin leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"
expanded="ekr.20070627135407,ekr.20070627140344,"><vh>@thin leoTest.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ 
This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog orf a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobal module.
i, j, k: indices into a string.
p:  a position.
s:  a string.
t:  a tnode or a text widget.
u:  an undoer.
w:  a gui widget.
v:  a vnode
z:  a local temp.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20040629121554.1"># Leo 4.5.1 final: September 14, 2008

def getSignOnLine (self):
    c = self
    return "Leo 4.6 beta 1, build %s, March 24, 2009" % c.getBuildNumber()
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060217111834"></t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.p
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.h)
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().h
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20070605104410"></t>
<t tx="ekr.20070628175250">@color

u = c.undoer
b = u.beforeChangeNodeContents(p)
s = p.b

result = [' '*4 + line for line in g.splitLines(s)]
result.insert(0,'if g.unitTesting:\n')
s = ''.join(result)
c.setBodyString(p,s)

u.afterChangeNodeContents(p,'add-if-g-unitTesting',b)
</t>
<t tx="ekr.20070703122141.65">class baseScannerClass (scanUtility):

    '''The base class for all import scanner classes.
    This class contains common utility methods.'''

    @others
</t>
<t tx="ekr.20070703122141.66">def __init__ (self,importCommands,atAuto,language):

    ic = importCommands

    self.atAuto = atAuto
    self.c = c = ic.c

    self.atAutoWarnsAboutLeadingWhitespace = c.config.getBool('at_auto_warns_about_leading_whitespace')
    self.classId = None # The identifier containing the class tag: 'class', 'interface', 'namespace', etc.
    self.codeEnd = None
        # The character after the last character of the class, method or function.
        # An error will be given if this is not a newline.
    self.encoding = ic.encoding # g.app.tkEncoding
    self.errors = 0
    ic.errors = 0
    self.errorLines = []
    self.extraIdChars = ''
    self.fileName = ic.fileName # The original filename.
    self.fileType = ic.fileType # The extension,  '.py', '.c', etc.
    self.file_s = '' # The complete text to be parsed.
    self.fullChecks = c.config.getBool('full_import_checks')
    self.functionSpelling = 'function' # for error message.
    self.importCommands = ic
    self.indentRefFlag = None # None, True or False.
    self.isRst = False
    self.language = language
    self.lastParent = None # The last generated parent node (used only by rstScanner).
    self.methodName = ic.methodName # x, as in &lt; &lt; x methods &gt; &gt; =
    self.methodsSeen = False
    self.mismatchWarningGiven = False
    self.output_newline = ic.output_newline # = c.config.getBool('output_newline')
    self.output_indent = 0 # The minimum indentation presently in effect.
    self.root = None # The top-level node of the generated tree.
    self.rootLine = ic.rootLine # '' or @root + self.fileName
    self.sigEnd = None # The index of the end of the signature.
    self.sigId = None # The identifier contained in the signature, i.e., the function or method name.
    self.sigStart = None
        # The start of the line containing the signature.
        # An error will be given if something other than whitespace precedes the signature.
    self.startSigIndent = None
    self.tab_width = None # Set in run: the tab width in effect in the c.currentPosition.
    self.tab_ws = '' # Set in run: the whitespace equivalent to one tab.
    self.trace = False or ic.trace # = c.config.getBool('trace_import')
    self.treeType = ic.treeType # '@root' or '@file'
    self.webType = ic.webType # 'cweb' or 'noweb'

    # Compute language ivars.
    delim1,junk,junk = g.set_delims_from_language(language)
    self.comment_delim = delim1

    # May be overridden in subclasses.
    self.anonymousClasses = [] # For Delphi Pascal interfaces.
    self.blockCommentDelim1 = None
    self.blockCommentDelim2 = None
    self.blockCommentDelim1_2 = None
    self.blockCommentDelim2_2 = None
    self.blockDelim1 = '{'
    self.blockDelim2 = '}'
    self.blockDelim2Cruft = [] # Stuff that can follow .blockDelim2.
    self.classTags = ['class',] # tags that start a tag.
    self.functionTags = []
    self.hasClasses = True
    self.hasFunctions = True
    self.lineCommentDelim = None
    self.lineCommentDelim2 = None
    self.outerBlockDelim1 = None
    self.outerBlockDelim2 = None
    self.outerBlockEndsDecls = True
    self.sigHeadExtraTokens = [] # Extra tokens valid in head of signature.
    self.sigFailTokens = []
        # A list of strings that abort a signature when seen in a tail.
        # For example, ';' and '=' in C.

    self.strict = False # True if leading whitespace is very significant.
</t>
<t tx="ekr.20070703122141.77">def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.h,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20070703122141.78">def error (self,s):
    self.errors += 1
    self.importCommands.errors += 1
    if g.unitTesting:
        if self.errors == 1:
            g.app.unitTestDict ['actualErrorMessage'] = s
        g.app.unitTestDict ['actualErrors'] = self.errors
        if 0: # For debugging unit tests.
            g.trace(g.callers())
            g.es_print('',s,color='red')
    else:
        g.es_print('error:',s,color='red')

def oops (self):
    g.pr('baseScannerClass oops: %s must be overridden in subclass' % g.callers())

def report (self,message):
    if self.strict: self.error(message)
    else:           self.warning(message)

def warning (self,s):
    if not g.unitTesting:
        g.es_print('warning:',s,color='red')
</t>
<t tx="ekr.20070703122141.79">def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
</t>
<t tx="ekr.20070703122141.88">def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    if self.isRst:
        return s # Never unindent rst code.

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result
</t>
<t tx="ekr.20070703122141.102">def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
</t>
<t tx="ekr.20070703122141.104">def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        if self.isRst: # Errors writing file at present...
            outputFile = StringIO.StringIO()
            c.rstCommands.writeAtAutoFile(self.root,self.fileName,outputFile)
            s1,s2 = self.file_s,outputFile.getvalue()
        else:
            at.write(self.root,
                nosentinels=True,thinFile=False,
                scriptWrite=False,toString=True)
            s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
</t>
<t tx="ekr.20070703122141.105">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
</t>
<t tx="ekr.20070703122141.106">def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
</t>
<t tx="ekr.20070705085335">def insertIgnoreDirective (self,parent):

    self.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
</t>
<t tx="ekr.20070705094630">def putRootText (self,p):

    c = self.c

    self.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
</t>
<t tx="ekr.20070706084535">@ None of these methods should ever need to be overridden in subclasses.

</t>
<t tx="ekr.20070706084535.1">@ Scan and skipDecls would typically not be overridden.
</t>
<t tx="ekr.20070706101600">def scan (self,s,parent):

    '''A language independent scanner: it uses language-specific helpers.

    Create a child of self.root for:
    - Leading outer-level declarations.
    - Outer-level classes.
    - Outer-level functions.
    '''

    # Init the parser status ivars.
    self.methodsSeen = False

    # Create the initial body text in the root.
    self.putRootText(parent)

    # Parse the decls.
    i = self.skipDecls(s,0,len(s),inClass=False)
    decls = s[:i]

    # Create the decls node.
    if decls: self.createDeclsNode(parent,decls)

    # Scan the rest of the file.
    start,junk,junk = self.scanHelper(s,i,end=len(s),parent=parent,kind='outer')

    # Finish adding to the parent's body text.
    self.addRef(parent)
    if start &lt; len(s):
        self.appendStringToBody(parent,s[start:])

    # Do any language-specific post-processing.
    self.endGen(s)
</t>
<t tx="ekr.20070707072749">def run (self,s,parent):

    c = self.c
    self.root = root = parent.copy()
    self.file_s = s
    self.tab_width = self.importCommands.getTabWidth(p=root)
    # g.trace('tab_width',self.tab_width)
    # Create the ws equivalent to one tab.
    if self.tab_width &lt; 0:
        self.tab_ws = ' '*abs(self.tab_width)
    else:
        self.tab_ws = '\t'

    # Init the error/status info.
    self.errors = 0
    self.errorLines = []
    self.mismatchWarningGiven = False
    changed = c.isChanged()

    # Use @verbatim to escape section references
    s = self.escapeFalseSectionReferences(s)

    # Check for intermixed blanks and tabs.
    if self.strict or self.atAutoWarnsAboutLeadingWhitespace:
        if not self.isRst:
            self.checkBlanksAndTabs(s)

    # Regularize leading whitespace for strict languages only.
    if self.strict: s = self.regularizeWhitespace(s) 

    # Generate the nodes, including directive and section references.
    self.scan(s,parent)

    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    ok = self.errors == 0 and self.check(s,parent)
    g.app.unitTestDict ['result'] = ok

    # Insert an @ignore directive if there were any serious problems.
    if not ok: self.insertIgnoreDirective(parent)

    if self.atAuto and ok:
        for p in root.self_and_subtree_iter():
            p.clearDirty()
        c.setChanged(changed)
    else:
        root.setDirty(setDescendentsDirty=False)
        c.setChanged(True)
</t>
<t tx="ekr.20070707073044.1">def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    if self.isRst and not self.atAuto:
        return

    if self.treeType == '@file':
        self.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        self.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
</t>
<t tx="ekr.20070707073627.2">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_string(s,i,verbose=False)
</t>
<t tx="ekr.20070707073859">def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level &lt;= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress &lt; i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
</t>
<t tx="ekr.20070707074541">def skipBlockComment (self,s,i):

    '''Skip past a block comment.'''

    start = i

    # Skip the opening delim.
    if g.match(s,i,self.blockCommentDelim1):
        delim2 = self.blockCommentDelim2
        i += len(self.blockCommentDelim1)
    elif g.match(s,i,self.blockCommentDelim1_2):
        i += len(self.blockCommentDelim1_2)
        delim2 = self.blockCommentDelim2_2
    else:
        assert False

    # Find the closing delim.
    k = s.find(delim2,i)
    if k == -1:
        self.error('Run on block comment: ' + s[start:i])
        return len(s)
    else:
        return k + len(delim2)
</t>
<t tx="ekr.20070707080042">def skipDecls (self,s,i,end,inClass):

    '''Skip everything until the start of the next class or function.

    The decls *must* end in a newline.'''

    trace = False or self.trace
    start = i ; prefix = None
    classOrFunc = False
    if trace: g.trace(g.callers())
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            # Add the comment to the decl if it *doesn't* start the line.
            i2,junk = g.getLine(s,i)
            i2 = g.skip_ws(s,i2)
            if i2 == i and prefix is None:
                prefix = i2 # Bug fix: must include leading whitespace in the comment.
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
            prefix = None
        elif self.startsClass(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsFunction(s,i):
            # Important: do not include leading ws in the decls.
            classOrFunc = True
            i = g.find_line_start(s,i)
            i = self.adjustDefStart(s,i)
            break
        elif self.startsId(s,i):
            i = self.skipId(s,i)
            prefix = None
        # Don't skip outer blocks: they may contain classes.
        elif g.match(s,i,self.outerBlockDelim1):
            if self.outerBlockEndsDecls:
                break
            else:
                i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
        else:
            i += 1 ;  prefix = None
        assert(progress &lt; i)

    if prefix is not None:
        i = g.find_line_start(s,prefix) # i = prefix
    decls = s[start:i]
    if inClass and not classOrFunc:
        # Don't return decls if a class contains nothing but decls.
        if trace and decls.strip(): g.trace('**class is all decls...\n',decls)
        return start
    elif decls.strip(): 
        if trace or self.trace: g.trace('\n'+decls)
        return i
    else: # Ignore empty decls.
        return start
</t>
<t tx="ekr.20070707082432">def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and not g.unitTesting
    verbose = False

    # if trace: g.trace(start,sigStart,self.sigEnd,codeEnd)

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body = self.computeBody(s,start,sigStart,codeEnd)

    if trace:
        g.trace('parent',parent.h)
        if verbose: g.trace('**body...\n',body)

    parent = self.adjustParent(parent,headline)
    self.lastParent = self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20070707085612">def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    return self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20070707094858.1">def skipId (self,s,i):

    return g.skip_id(s,i,chars=self.extraIdChars)</t>
<t tx="ekr.20070707094858.2">def startsId(self,s,i):

    return g.is_c_id(s[i:i+1])
</t>
<t tx="ekr.20070707113832.1">def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(
        s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20070707150022">def extendSignature(self,unused_s,i):

    '''Extend the signature line if appropriate.
    The text *must* end with a newline.

    For example, the Python scanner appends docstrings if they exist.'''

    return i
</t>
<t tx="ekr.20070707171329">def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
</t>
<t tx="ekr.20070707172732.1">def startsString(self,s,i):

    return g.match(s,i,'"') or g.match(s,i,"'")
</t>
<t tx="ekr.20070707190351">def appendTextToClassNode (self,class_node,s):

    c = self.c

    self.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20070709094002">def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20070711104014">def skipComment (self,s,i):

    '''Skip a comment and return the index of the following character.'''

    if g.match(s,i,self.lineCommentDelim) or g.match(s,i,self.lineCommentDelim2):
        return g.skip_to_end_of_line(s,i)
    else:
        return self.skipBlockComment(s,i)
</t>
<t tx="ekr.20070711104014.1">def startsComment (self,s,i):

    return (
        g.match(s,i,self.lineCommentDelim) or
        g.match(s,i,self.lineCommentDelim2) or
        g.match(s,i,self.blockCommentDelim1) or
        g.match(s,i,self.blockCommentDelim1_2)
    )
</t>
<t tx="ekr.20070711132314"># We don't expect to override this code, but subclasses may override the helpers.

def startsClass (self,s,i):
    '''Return True if s[i:] starts a class definition.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasClasses and self.startsHelper(s,i,kind='class',tags=self.classTags)
    return val

def startsFunction (self,s,i):
    '''Return True if s[i:] starts a function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''
    val = self.hasFunctions and self.startsHelper(s,i,kind='function',tags=self.functionTags)
    return val
</t>
<t tx="ekr.20070711134534">def getSigId (self,ids):

    '''Return the signature's id.

    By default, this is the last id in the ids list.'''

    return ids and ids[-1]
</t>
<t tx="ekr.20070711140703">def skipSigStart (self,s,i,kind,tags):

    '''Skip over the start of a function/class signature.

    tags is in (self.classTags,self.functionTags).

    Return (i,ids) where ids is list of all ids found, in order.'''

    trace = False and self.trace # or kind =='function'
    ids = [] ; classId = None
    if trace: g.trace('*entry',kind,i,s[i:i+20])
    start = i
    while i &lt; len(s):
        j = g.skip_ws_and_nl(s,i)
        for z in self.sigFailTokens:
            if g.match(s,j,z):
                if trace: g.trace('failtoken',z,'ids',ids)
                return start, [], None
        for z in self.sigHeadExtraTokens:
            if g.match(s,j,z):
                i += len(z) ; break
        else:
            i = self.skipId(s,j)
            theId = s[j:i]
            if theId and theId in tags: classId = theId
            if theId: ids.append(theId)
            else: break

    if trace: g.trace('*exit ',kind,i,i &lt; len(s) and s[i],ids,classId)
    return i, ids, classId
</t>
<t tx="ekr.20070712075148">def skipArgs (self,s,i,kind):

    '''Skip the argument or class list.  Return i, ok

    kind is in ('class','function')'''

    start = i
    i = g.skip_ws_and_nl(s,i)
    if not g.match(s,i,'('):
        return start,kind == 'class'

    i = self.skipParens(s,i)
    # skipParens skips the ')'
    if i &gt;= len(s):
        return start,False
    else:
        return i,True 
</t>
<t tx="ekr.20070712081451">def skipParens (self,s,i):

    '''Skip a parenthisized list, that might contain strings or comments.'''

    return self.skipBlock(s,i,delim1='(',delim2=')')
</t>
<t tx="ekr.20070712082913">def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    trace = False and self.trace
    start = i
    i = g.skip_ws(s,i)
    for z in self.sigFailTokens:
        if g.match(s,i,z):
            if trace: g.trace('failToken',z,'line',g.skip_line(s,i))
            return i,False
    while i &lt; len(s):
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif g.match(s,i,self.blockDelim1):
            if trace: g.trace(repr(s[start:i]))
            return i,True
        else:
            i += 1
    if trace: g.trace('no block delim')
    return i,False
</t>
<t tx="ekr.20070712091019">def skipCodeBlock (self,s,i,kind):

    '''Skip the code block in a function or class definition.'''

    trace = False
    start = i
    i = self.skipBlock(s,i,delim1=None,delim2=None)

    if self.sigFailTokens:
        i = g.skip_ws(s,i)
        for z in self.sigFailTokens:
            if g.match(s,i,z):
                if trace: g.trace('failtoken',z)
                return start,False

    if i &gt; start:
        i = self.skipNewline(s,i,kind)

    if trace:
        g.trace(g.callers())
        g.trace('returns...\n',g.listToString(g.splitLines(s[start:i])))

    return i,True
</t>
<t tx="ekr.20070712112008">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = False or self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    if kind == 'class' and self.sigId in self.anonymousClasses:
        # A hack for Delphi Pascal: interfaces have no id's.
        # g.trace('anonymous',self.sigId)
        classId = theId
        sigId = ''
    else:
        i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
        sigId = self.getSigId(ids)
        if not sigId:
            if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
            return False

    if self.output_indent &lt; self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if kind == 'class' and self.sigId in self.anonymousClasses:
            pass # Allow weird Pascal unit's.
        elif not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20070730093735">def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    trace = True and not g.unitTesting

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i &gt;= len(lines1):
        if self.isRst:
            return True # ignore extra lines.
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i &gt;= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif self.isRst and self.compareRstUnderlines(line1,line2):
        return True
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    # if trace:
        # g.es_print('original line: ',line1)
        # g.es_print('generated line:',line2)
        # return True # continue checking.

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.
</t>
<t tx="ekr.20070730134936">def skipNewline(self,s,i,kind):

    '''Skip whitespace and comments up to a newline, then skip the newline.
    Issue an error if no newline is found.'''

    while i &lt; len(s):
        i = g.skip_ws(s,i)
        if self.startsComment(s,i):
            i = self.skipComment(s,i)
        else: break

    if i &gt;= len(s):
        return len(s)

    if g.match(s,i,'\n'):
        i += 1
    else:
        self.error(
            '%s %s does not end in a newline; one will be added\n%s' % (
                kind,self.sigId,g.get_line(s,i)))
        # g.trace(g.callers())

    return i
</t>
<t tx="ekr.20070801074524">def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20070808115837"></t>
<t tx="ekr.20070808115837.1">def regularizeWhitespace (self,s):

    '''Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    This is only called for strict languages.'''

    changed = False ; lines = g.splitLines(s) ; result = [] ; tab_width = self.tab_width

    if tab_width &lt; 0: # Convert tabs to blanks.
        for line in lines:
            i, w = g.skip_leading_ws_with_indent(line,0,tab_width)
            s = g.computeLeadingWhitespace(w,-abs(tab_width)) + line [i:] # Use negative width.
            if s != line: changed = True
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for line in lines:
            s = g.optimizeLeadingWhitespace(line,abs(tab_width)) # Use positive width.
            if s != line: changed = True
            result.append(s)

    if changed:
        action = g.choose(self.tab_width &lt; 0,'tabs converted to blanks','blanks converted to tabs')
        message = 'inconsistent leading whitespace. %s' % action
        self.report(message)

    return ''.join(result)
</t>
<t tx="ekr.20070911110507">def reportMismatch (self,lines1,lines2,bad_i):

    trace = True and not g.unitTesting
    verbose = True

    kind = g.choose(self.atAuto,'@auto','import command')

    x2 = max(0,min(bad_i-1,len(lines2)-1))
    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d\n%s' % (
            kind,self.root.h,bad_i,repr(lines2[x2])))

    maxlines = 200
    if trace or len(lines1) &lt; maxlines:
        aList = []
        if True: # intermix lines.
            n1,n2 = len(lines1),len(lines2)
            for i in range(min(maxlines,max(n1,n2))):
                if i &lt; n1: line1 = repr(lines1[i])
                else:      line1 = '&lt;eof&gt;'
                if i &lt; n2: line2 = repr(lines2[i])
                else:      line2 = '&lt;eof&gt;'
                if verbose or line1 != line2:
                    aList.append('%3d %s' % (i,line1))
                    aList.append('%3d %s' % (i,line2))
        else:
            aList.append('input...')
            for i in range(len(lines1)):
                aList.append('%3d %s' % (i,repr(lines1[i])))
            aList.append('output...')
            for i in range(len(lines2)):
                aList.append('%3d %s' % (i,repr(lines2[i])))

        g.es_print('\n'.join(aList),color='blue')

    return False
</t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.b
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071017132056">def getIndent (self,s,i):

    j,junk = g.getLine(s,i)
    junk,indent = g.skip_leading_ws_with_indent(s,j,self.tab_width)
    return indent</t>
<t tx="ekr.20071018084830">def scanHelper(self,s,i,end,parent,kind):

    '''Common scanning code used by both scan and putClassHelper.'''

    # g.trace(g.callers())
    # g.trace('i',i,g.get_line(s,i))
    assert kind in ('class','outer')
    start = i ; putRef = False ; bodyIndent = None
    while i &lt; end:
        progress = i
        if s[i] in (' ','\t','\n'):
            i += 1 # Prevent lookahead below, and speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif self.startsClass(s,i):  # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            end2 = self.codeEnd # putClass may change codeEnd ivar.
            self.putClass(s,i,self.sigEnd,self.codeEnd,start,parent)
            i = start = end2
        elif self.startsFunction(s,i): # Sets sigStart,sigEnd &amp; codeEnd ivars.
            putRef = True
            if bodyIndent is None: bodyIndent = self.getIndent(s,i)
            self.putFunction(s,self.sigStart,self.codeEnd,start,parent)
            i = start = self.codeEnd
        elif self.startsId(s,i):
            i = self.skipId(s,i)
        elif kind == 'outer' and g.match(s,i,self.outerBlockDelim1): # Do this after testing for classes.
            i = self.skipBlock(s,i,delim1=self.outerBlockDelim1,delim2=self.outerBlockDelim2)
            # Bug fix: 2007/11/8: do *not* set start: we are just skipping the block.
        else: i += 1
        assert progress &lt; i,'i: %d, ch: %s' % (i,repr(s[i]))

    return start,putRef,bodyIndent
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20071110105107">def checkBlanksAndTabs(self,s):

    '''Check for intermixed blank &amp; tabs.'''

    # Do a quick check for mixed leading tabs/blanks.
    blanks = tabs = 0

    for line in g.splitLines(s):
        lws = line[0:g.skip_ws(line,0)]
        blanks += lws.count(' ')
        tabs += lws.count('\t')

    ok = blanks == 0 or tabs == 0

    if not ok:
        self.report('intermixed blanks and tabs')

    return ok
</t>
<t tx="ekr.20071110144948">def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
</t>
<t tx="ekr.20071201072917">def adjustDefStart (self,unused_s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    return i
</t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.b,ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'"))
        for z in sorted(self.decls)]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20081013084332.1">@nocolor-node

I. Background

Leo has had a robust MVC (Model,View,Controller) architecture from day one.

Leo's model are the classes in leoNodes.py. They are completely independent from
the rest of Leo. Many parts of Leo *use* these classes, but not vice versa!

Leo's controller is everything else in 'Code--&gt;Core classes'. This code has *no*
direct dependencies on Leo's gui code, as will be explained next.

Leo's view has two parts:

1. The classes in the tree 'Code--&gt;Gui Base classes'.
   These are part of Leo's core.

2. The classes in the tree 'Code--&gt;Gui Tkinter classes'.
   These are essentailly a gui plugin.

Leo's core consists of the Model, Controller and the gui base classes.


II. Why Leo's core is gui-independent

Leo uses a completely standard way of separating gui-dependent code from
gui-independent code. Base gui classes (part 1 of the view) define an interface
used by Leo's core. Subclasses (part 2 of the view) implement the interface for
a particular gui.

** Subclasses can change without affecting Leo's code in any way.**

The essential design rule is: if gui-related code can be made gui- independent,
it should be part of a base class. Otherwise it must be part of a subclass of a
base gui class.

The gui base classes are far more than do-nothing interfaces. Examples of
complex code that reside in base classes:

A. tree.select. I am proud that this method is gui-independent. Switching nodes
is a very tricky business. Making it gui-independent is a big win.

B. leoFind.py. Finds the next/previous matches, and dealing with an "idealized"
find tab. Adapter classes exist in leoEditCommands.py.

C. Autocompletion and minibuffer code in leoKeys.py. For comparison, look how
simple leoTkinterKeys.py is.

D. A generalized, gui-independent interface to Leo's body pane. The commands in
leoEditCommands.py (part of the controller) use this interface (baseTextWidget)
rather than calling Tk directly.

**If you want to understand Leo's design, study Leo's base gui classes.**
</t>
<t tx="ekr.20081216090156.1">def undentBy (self,s,undentVal):

    '''Remove leading whitespace equivalent to undentVal from each line.
    add an underindentEscapeString for underindented line.'''

    trace = False and not g.app.unitTesting

    if self.isRst:
        return s # Never unindent rst code.

    tag = self.c.atFileCommands.underindentEscapeString
    result = [] ; tab_width = self.tab_width
    for line in g.splitlines(s):
        lws_s = g.get_leading_ws(line)
        lws = g.computeWidth(lws_s,tab_width)
        s = g.removeLeadingWhitespace(line,undentVal,tab_width)
        n = lws - undentVal
        if s.strip() and lws &lt; undentVal:
            if trace: g.trace('undentVal: %s, lws: %s, %s' % (
                undentVal,lws,repr(line)))
            result.append("%s%s%s" % (tag,undentVal-lws,s.lstrip()))
        else:
            result.append(s)

    return ''.join(result)

</t>
<t tx="ekr.20090113083258.3"></t>
<t tx="ekr.20090122201952.5"></t>
<t tx="ekr.20090122201952.6">def appendStringToBody (self,p,s,encoding="utf-8"):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.appendStringToBody(p,s,encoding)

def setBodyString (self,p,s,encoding="utf-8"):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.setBodyString(p,s,encoding)
</t>
<t tx="ekr.20090128070032.1">@
@nocolor-node

To gather statistics, do the following in a console window, not idle:

    &gt; python
    &gt;&gt;&gt; import leo
    &gt;&gt;&gt; import leo.core.runLeo as r
    &gt;&gt;&gt; r.prof()  (this runs leo)
    load any .leo file from Leo
    quit Leo

Intermediate data is written to cwd.leoProfile.txt.
The statistics are written to stdout.
</t>
<t tx="ekr.20090501095634.41">class rstScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20090501095634.42">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='rest')

    # Scanner overrides
    self.blockDelim1 = self.blockDelim2 = None
    self.classTags = []
    self.functionSpelling = 'section'
    self.functionTags = []
    self.hasClasses = False
    self.isRst = True
    self.lineCommentDelim = '..'
    self.outerBlockDelim1 = None
    self.sigFailTokens = []
    self.strict = False # Mismatches in leading whitespace are irrelevant.

    # Ivars unique to rst scanning &amp; code generation.
    self.lastParent = None # The previous parent.
    self.lastSectionLevel = 0 # The section level of previous section.
    self.sectionLevel = 0 # The section level of the just-parsed section.
    self.underlineCh = '' # The underlining character of the last-parsed section.
    self.underlines = "!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~" # valid rst underlines.
    self.underlines1 = [] # Underlining characters for underlines.
    self.underlines2 = [] # Underlining characters for over/underlines.
</t>
<t tx="ekr.20090501095634.45">def startsHelper(self,s,i,kind,tags):

    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    trace = False and not g.unitTesting
    verbose = False
    kind,name,next,ch = self.startsSection(s,i)
    if kind == 'plain': return False

    self.underlineCh = ch
    self.lastSectionLevel = self.sectionLevel
    self.sectionLevel = self.computeSectionLevel(ch,kind)
    self.sigStart = g.find_line_start(s,i)
    self.sigEnd = next
    self.sigId = name ##.strip()
    i = next + 1

    if trace: g.trace('sigId',self.sigId,'next',next)

    while i &lt; len(s):
        progress = i
        i,j = g.getLine(s,i)
        kind,name,next,ch = self.startsSection(s,i)
        if trace and verbose: g.trace(kind,repr(s[i:j]))
        if kind in ('over','under'):
            break
        else:
            i = j
        assert i &gt; progress

    self.codeEnd = i

    if trace:
        if verbose:
            g.trace('found...\n%s' % s[self.sigStart:self.codeEnd])
        else:
            g.trace('level %s %s' % (self.sectionLevel,self.sigId))
    return True
</t>
<t tx="ekr.20090501095634.46">def isUnderLine(self,s):

    '''Return True if s consists of only rST underline characters.'''

    if not s: return False

    for ch in s:
        if ch not in self.underlines:
            return False

    return True
</t>
<t tx="ekr.20090501095634.47">def startsSection (self,s,i):

    '''Scan a line and possible one or two other lines,
    looking for an underlined or overlined/underlined name.

    Return (kind,name,i):
        kind: in ('under','over','plain')
        name: the name of the underlined or overlined line.
        i: the following character if kind is not 'plain'
        ch: the underlining and possibly overlining character.
    '''

    trace = False and not g.unitTesting
    i1,j = g.getLine(s,i)
    line = s[i1:j].strip()
    ch,kind = '','plain' # defaults.

    if self.isUnderLine(line): # an overline.
        name_i = g.skip_line(s,i1)
        name_i,name_j = g.getLine(s,name_i)
        name = s[name_i:name_j].strip()
        next_i = g.skip_line(s,name_i)
        i,j = g.getLine(s,next_i)
        line2 = s[i:j].strip()
        n1,n2,n3 = len(line),len(name),len(line2)
        ch1,ch3 = line[0],line2 and line2[0]
        ok = (self.isUnderLine(line2) and
            n1 &gt;= n2 and n2 &gt; 0 and n3 &gt;= n2 and ch1 == ch3)
        if ok:
            i += n3 # bug fix.
            ch,kind = ch1,'over'
            if ch1 not in self.underlines2:
                self.underlines2.append(ch1)
                # if trace: g.trace('underlines2',self.underlines2,name)
            if trace: g.trace('\nline  %s\nname  %s\nline2 %s' % (
                repr(line),repr(name),repr(line2)))
    else:
        name = line.strip()
        i = g.skip_line(s,i1)
        i,j = g.getLine(s,i)
        line2 = s[i:j].strip()
        n1,n2 = len(name),len(line2)
        # look ahead two lines.
        i3,j3 = g.getLine(s,j)
        name2 = s[i3:j3].strip()
        i4,j4 = g.getLine(s,j3)
        line4 = s[i4:j4].strip()
        n3,n4 = len(name2),len(line4)
        overline = (
            self.isUnderLine(line2) and
            self.isUnderLine(line4) and
            n3 &gt; 0 and n2 &gt;= n3 and n4 &gt;= n3)
        ok = (not overline and self.isUnderLine(line2) and
            n1 &gt; 0 and n2 &gt;= n1)
        if ok:
            i += n2 # Bug fix.
            ch,kind = line2[0],'under'
            if ch not in self.underlines1:
                self.underlines1.append(ch)
                # if trace: g.trace('underlines1',self.underlines1,name)
            if trace: g.trace('\nname  %s\nline2 %s' % (
                repr(name),repr(line2)))
    return kind,name,i,ch
</t>
<t tx="ekr.20090501095634.50"># These do not affect parsing.

def startsComment (self,s,i):
    return False

def startsID (self,s,i):
    return False

def startsString (self,s,i):
    return False
</t>
<t tx="ekr.20090502071837.1">def endGen (self,s):

    '''Do any language-specific post-processing.'''
    pass
</t>
<t tx="ekr.20090502071837.2">def endGen (self,s):

    '''Remember the underlining characters in the root's uA.'''

    p = self.root
    if p:
        tag = 'rst-import'
        d = p.v.u.get(tag,{})
        underlines1 = ''.join([str(z) for z in self.underlines1])
        underlines2 = ''.join([str(z) for z in self.underlines2])
        d ['underlines1'] = underlines1
        d ['underlines2'] = underlines2
        self.underlines1 = underlines1
        self.underlines2 = underlines2
        # g.trace(repr(underlines1),repr(underlines2))
        p.v.u [tag] = d

    # Append a warning to the root node.
    warningLines = (
        'Warning: this node is ignored when writing this file.',
        'However, @ @rst-options are recognized in this node.',
    )
    lines = ['.. %s' % (z) for z in warningLines]
    warning = '\n%s\n' % '\n'.join(lines)
    self.root.b = self.root.b + warning
</t>
<t tx="ekr.20090502071837.58"></t>
<t tx="ekr.20090502071837.59"></t>
<t tx="ekr.20090502071837.60">def initWrite (self,p,encoding=None):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c
    d = c.scanAllDirectives(p)
    self.encoding = encoding or d.get('encoding') or self.defaultEncoding
    self.path = d.get('path') or ''

    # g.trace('path:',self.path)
</t>
<t tx="ekr.20090502071837.61">def writeNormalTree (self,p,toString=False):

    self.initWrite(p)

    # Always write to a string first.
    self.outputFile = StringIO.StringIO()
    self.writeTree(p)
    self.source = self.stringOutput = self.outputFile.getvalue()

    # Copy to a file if requested.
    if not toString:
        # Comput the output file name *after* calling writeTree.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(self.stringOutput)
        self.outputFile.close()

    return True
</t>
<t tx="ekr.20090502071837.62">def processTopTree (self,p,justOneFile=False):

    c = self.c ; current = p.copy()

    for p in current.self_and_parents_iter():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
            break
    else:
        self.processTree(current,ext=None,toString=False,justOneFile=justOneFile)

    g.es_print('done',color='blue')</t>
<t tx="ekr.20090502071837.63">def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.topLevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                # g.trace('ext',self.ext,self.outputFileName)
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.es('No @rst nodes in selected tree',color='blue')
    return None,None
</t>
<t tx="ekr.20090502071837.64">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO.StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = True
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20090502071837.65">def writeToDocutils (self,s):

    '''Send s to docutils using the writer implied by self.ext and return the result.'''

    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }

    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()

    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.es_print('unknown docutils extension: %s' % (self.ext),color='red')
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.es_print('stylesheet not found: %s' % (path),color='red')
    else:
        g.es_print('stylesheet not found\n',path,color='red')
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        res = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError, error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    return res
</t>
<t tx="ekr.20090502071837.66">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.es_print('bad option: %s' % s,color='red')
            break

    return d
</t>
<t tx="ekr.20090502071837.67">def writeNodeToString (self,p=None,ext=None):

    '''Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period:  .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.'''

    c = self.c ; current = p or c.p

    for p in current.self_and_parents_iter():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    else:
        return self.processTree(current,ext=ext,toString=True,justOneFile=True)</t>
<t tx="ekr.20090502071837.68">def getDocPart (self,lines,n):

    # g.trace('n',n,repr(''.join(lines)))

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result</t>
<t tx="ekr.20090502071837.69">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20090502071837.70">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result</t>
<t tx="ekr.20090502071837.71">def writeBody (self,p):

    # remove trailing cruft and split into lines.
    ### lines = p.b.rstrip().split('\n')
    lines = g.splitLines(p.b)

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    if 1:
        # Preserve rst whitespace: uses lines = g.splitLines(p.b)
        s = ''.join(lines)
        if not self.atAutoWrite:
            # s += '\n\n' # Make sure all nodes end with a blank line.
            # Don't accumulate more and more trailing newlines!
            s = g.ensureTrailingNewlines(s,2)
        self.write(s)
    else:
        # Old code: uses lines = p.b.rstrip().split('\n')
        s = '\n'.join(lines).strip()
        if s:
            self.write('%s\n\n' % s)</t>
<t tx="ekr.20090502071837.72">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)</t>
<t tx="ekr.20090502071837.73">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s</t>
<t tx="ekr.20090502071837.74">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')</t>
<t tx="ekr.20090502071837.75">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))</t>
<t tx="ekr.20090502071837.76">def handleDocOnlyMode (self,p,lines):

    '''Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.'''

    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            # g.trace(len(result),p.h)
            self.writeHeadlineHelper(p)
    return result</t>
<t tx="ekr.20090502071837.77">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()</t>
<t tx="ekr.20090502071837.78">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result</t>
<t tx="ekr.20090502071837.79">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20090502071837.80">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    # g.trace('removing %s' % s)
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result</t>
<t tx="ekr.20090502071837.81">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    # g.trace(kind,g.listToString(lines))

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20090502071837.82">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result</t>
<t tx="ekr.20090502071837.83">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)</t>
<t tx="ekr.20090502071837.84">def writeHeadlineHelper (self,p):

    ### h = p.h.strip()
    h = p.h
    if not self.atAutoWrite:
        h = h.strip()

    # Remove any headline command before writing the headline.
    i = g.skip_ws(h,0) ###
    i = g.skip_id(h,0,chars='@-')
    word = h [:i].strip() ###
    if word:
        # Never generate a section for @rst-option or @rst-options or @rst-no-head.
        if word in (
            self.getOption('option_prefix'),
            self.getOption('options_prefix'),
            self.getOption('ignore_headline_prefix'), # Bug fix: 2009-5-13
            self.getOption('ignore_headlines_prefix'),  # Bug fix: 2009-5-13
        ):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write(self.underline(h,p)) # Used by @auto-rst.
        else:
            self.write('\n%s\n\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))</t>
<t tx="ekr.20090502071837.85">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20090502071837.86">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''

    # g.trace(p.h,g.callers())

    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')

    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20090502071837.87">def writeTree(self,p):

    '''Write p's tree to self.outputFile.'''

    self.scanAllOptions(p)

    # g.trace(self.getOption('generate_rst_header_comment'))

    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))

    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p) # Side effect: advances p.
</t>
<t tx="ekr.20090502071837.93">def underline (self,s,p):

    '''Return the underlining string to be used at the given level for string s.
    This includes the headline, and possibly a leading overlining line.
    '''

    trace = False and not g.unitTesting

    if self.atAutoWrite:
        # We *might* generate overlines for top-level sections.
        u = self.atAutoWriteUnderlines
        level = p.level()-self.topLevel

        # This is tricky. The index n depends on several factors.
        if self.underlines2:
            level -= 1 # There *is* a double-underlined section.
            n = level
        else:
            n = level-1
        if 0 &lt;= n &lt; len(u): ch = u[n]
        else: ch = u[-1]
        n = max(4,len(s))
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        if level == 0:
            return '%s\n%s\n%s\n' % (ch*n,p.h,ch*n)
        else:
            return '%s\n%s\n' % (p.h,ch*n)
    else:
        # The user is responsible for top-level overlining.
        u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
        level = max(0,p.level()-self.topLevel)
        level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
        ch = u [level]
        if trace: g.trace(self.topLevel,p.level(),level,repr(ch),p.h)
        n = max(4,len(s))
        return '%s\n%s\n\n' % (p.h.strip(),ch*n)
</t>
<t tx="ekr.20090502071837.94">def write (self,s):

    s = self.encode(s)

    # g.trace(repr(s),g.callers(2))

    self.outputFile.write(s)
</t>
<t tx="ekr.20090511055302.5784">@nocolor-node

To do:

- Create better tests of reportMismatch.
    - Fix off-by-one error when there is an rst mismatch.

- Use rst importer only for @auto-rst.
    - eliminate isRstFile.

- Revise rst chapter of Leo's documentation.

- rst3 command applied to @auto-rst node should work.</t>
<t tx="ekr.20090512080015.5794"></t>
<t tx="ekr.20090512080015.5797">def computeSectionLevel (self,ch,kind):

    '''Return the section level of the underlining character ch.'''

    # Can't use g.choose here.
    if kind == 'over':
        assert ch in self.underlines2
        level = 0
    else:
        level = 1 + self.underlines1.index(ch)

    if False:
        g.trace('level: %s kind: %s ch: %s under2: %s under1: %s' % (
            level,kind,ch,self.underlines2,self.underlines1))

    return level
</t>
<t tx="ekr.20090512080015.5798">def adjustParent (self,parent,headline):

    '''Return the proper parent of the new node.'''

    trace = False and not g.unitTesting

    level,lastLevel = self.sectionLevel,self.lastSectionLevel
    lastParent = self.lastParent

    if trace: g.trace('**entry level: %s lastLevel: %s lastParent: %s' % (
        level,lastLevel,lastParent and lastParent.h or '&lt;none&gt;'))

    if self.lastParent:

        if level &lt;= lastLevel:
            parent = lastParent.parent()
            while level &lt; lastLevel:
                level += 1
                parent = parent.parent()
        else: # level &gt; lastLevel.
            level -= 1
            parent = lastParent
            while level &gt; lastLevel:
                level -= 1
                h2 = '@rst-no-head %s' % headline
                body = ''
                parent = self.createFunctionNode(h2,body,parent)

    else:
        assert self.root
        self.lastParent = self.root

    if not parent: parent = self.root

    if trace: g.trace('level %s lastLevel %s %s returns %s' % (
        level,lastLevel,headline,parent.h))

    #self.lastSectionLevel = self.sectionLevel
    self.lastParent = parent.copy()
    return parent.copy()
</t>
<t tx="ekr.20090512080015.5800">def adjustParent (self,parent,headline):

    '''Return the effective parent.

    This is overridden by the rstScanner class.'''

    return parent
</t>
<t tx="ekr.20090512080015.5801">How would the command specify settings?

A line added to test bzr push.
</t>
<t tx="ekr.20090512153903.5803">def writeAtAutoFile (self,p,fileName,outputFile):

    '''Write an @auto tree containing imported rST code.
    The caller will close the output file.'''

    try:
        self.atAutoWrite = True
        self.initAtAutoWrite(p,fileName,outputFile)
        self.topNode = p.copy() # Indicate the top of this tree.
        self.topLevel = p.level()
        after = p.nodeAfterTree()
        p = p.firstChild() # A (temporary?) hack: ignore the root node.
        while p and p != after:
            self.writeNode(p) # side effect: advances p
    finally:
        self.atAutoWrite = False
</t>
<t tx="ekr.20090512153903.5806">def computeBody (self,s,start,sigStart,codeEnd):

    trace = False and not g.unitTesting

    body1 = s[start:sigStart]
    # Adjust start backwards to get a better undent.
    if body1.strip():
        while start &gt; 0 and s[start-1] in (' ','\t'):
            start -= 1

    if self.isRst:
        # Never indent any text; discard the entire signature.
        body1 = s[start:sigStart]
        body2 = s[self.sigEnd+1:codeEnd]
    else:
        body1 = self.undentBody(s[start:sigStart],ignoreComments=False)
        body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2

    if trace and verbose: g.trace('body\n%s' % body)

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            '%s %s does not end with a newline; one will be added\n%s' % (
            self.functionSpelling,self.sigId,g.get_line(s,codeEnd)))

    return body

</t>
<t tx="ekr.20090512153903.5810">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '@rst-no-head %s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20090513073632.5733">def initAtAutoWrite(self,p,fileName,outputFile):

    # Set up for a standard write.
    self.createDefaultOptionsDict()
    self.tnodeOptionDict = {}
    self.scanAllOptions(p)
    self.initWrite(p)
    self.preprocessTree(p) # Allow @ @rst-options, for example.

    # Do the overrides.
    self.outputFile = outputFile
    self.outputFileName = fileName

    # Set underlining characters.
    d = self.tnodeOptionDict.get(p.v.t) # Set by preprocessTree.
    underlines = d.get('underline_characters')
    if underlines:
        self.atAutoWriteUnderlines = underlines
    else:
        d = p.v.u.get('rst-import',{})
        underlines2 = d.get('underlines2','#')
        underlines1 = d.get('underlines1','=+*^~"\'`-:&gt;&lt;_') # The standard defaults.
        if len(underlines2) &gt; 1:
            underlines2 = underlines2[0]
            g.trace('too many top-level underlines, using %s' % (
                underlines2),color='blue')
        self.atAutoWriteUnderlines = underlines2 + underlines1
        self.underlines1 = underlines1
        self.underlines2 = underlines2

</t>
<t tx="ekr.20090513073632.5735">def compareRstUnderlines(self,s1,s2):

    s1,s2 = s1.rstrip(),s2.rstrip()
    if s1 == s2:
        return True # Don't worry about trailing whitespace.

    n1, n2 = len(s1),len(s2)
    ch1 = n1 and s1[0] or ''
    ch2 = n2 and s2[0] or ''

    val = (
        n1 &gt;= 2 and n2 &gt;= 2 and # Underlinings must be at least 2 long.
        ch1 == ch2 and # The underlining characters must match.
        s1 == ch1 * n1 and # The line must consist only of underlining characters.
        s2 == ch2 * n2)

    return val
</t>
<t tx="ekr.20090513073632.5737">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = '%s declarations' % self.methodName
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20090514093345.6053">'''
Run all the unit tests in the .leo file given by the path.
The path is relative to the leo\test directory.
'''

import leo.core.leoTest as leoTest

leoTest.runUnitTestLeoFile(gui='nullGui',path='../core/leoPy.leo')

g.es_print('unit tests done',color='blue')</t>
<t tx="ekr.20090514093345.6054"></t>
<t tx="ekr.20090514111518.5660"></t>
<t tx="ekr.20090515065255.5678">if g.app.unitTesting:

    pass</t>
<t tx="ekr.20090516135452.5776"># Warning: g.removeTrailingWs already exists.
# Do not change it!

def removeTrailing (s,chars):

    '''Remove all characters in chars from the end of s.'''

    i = len(s)-1
    while i &gt;= 0 and s[i] in chars:
        i -= 1
    i += 1
    return s[:i]
</t>
<t tx="ekr.20090516135452.5777">def ensureTrailingNewlines (s,n):

    s = g.removeTrailing(s,'\t\n\r ')
    return s + '\n' * n


</t>
<t tx="ekr.20090516135452.5778">if g.unitTesting:

    s = 'aa bc \n \n\t\n'
    s2 = 'aa bc'

    for i in range(3):
        result = g.ensureTrailingNewlines(s,i)
        val = s2 + ('\n' * i)
        assert result == val, 'expected %s, got %s' % (
            repr(val),repr(result))
</t>
<t tx="ekr.20090516135452.5779">if g.unitTesting:

    s = 'aa bc \n \n\t\n'
    table = (
        ('\t\n ','aa bc'),
        ('abc\t\n ',''),
        ('c\t\n ','aa b'),
    )

    for arg,val in table:
        result = g.removeTrailing(s,arg)
        assert result == val, 'expected %s, got %s' % (val,result)
</t>
<t tx="ekr.20090517020744.5785">if g.unitTesting:

    import leo.core.leoImport as leoImport
    ic = c.importCommands
    scanner = leoImport.rstScanner(importCommands=ic,atAuto=True)
    f = scanner.reportMismatch

    # Why is leoSettings.leo scanned twice in dynamicUnitTest.leo?</t>
<t tx="ekr.20090517020744.5904"></t>
<t tx="ekr.20090517020744.5906"></t>
<t tx="ekr.20090517020744.5907"></t>
<t tx="ekr.20090517020744.5909"></t>
<t tx="ekr.20090517020744.5910"></t>
<t tx="ekr.20090517020744.5911"></t>
<t tx="ekr.20090517102212.5874"></t>
<t tx="ekr.20090517102548.5889"># Add the nodes in the following tree to external unit tests.</t>
<t tx="ekr.20090518072506.8310"></t>
<t tx="ekr.20090518072506.8311">@nocolor-node

It should be possible to using the already-existing gnx for the @thin node.</t>
<t tx="ekr.20090518072506.8495">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/375502

r1795, Ubuntu 8.10, python 2.5.2, qt

open a file. open another file. close the second file. ctrl-s save the first
file. It saves, but the other file, which has been closed, re-opens.</t>
<t tx="ekr.20090518072506.8496">@nocolor-node

- update leoPyRef.leo.
- Create a "moved to leoPy.leo" section in unitTest.leo.
- Unit tests for leoImport.py can be gathered together.</t>
</tnodes>
</leo_file>
