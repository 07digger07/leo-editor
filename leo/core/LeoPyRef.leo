<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20190406193429.1"><vh>@@enabled-plugins</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons</vh>
<v t="ekr.20201013034659.1"><vh>Unused buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20190406154306.1"><vh>@@button open-pyzo</vh></v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
</v>
<v t="ekr.20201013034742.1"><vh>Unused buttons re plugins</vh>
<v t="ekr.20201013034742.2"><vh>@@button make-importer</vh>
<v t="ekr.20201013034742.3"><vh>&lt;&lt; define run &amp; helpers &gt;&gt;</vh>
<v t="ekr.20201013034742.4"><vh>copy_tree</vh></v>
<v t="ekr.20201013034742.5"><vh>make_substitutions</vh></v>
<v t="ekr.20201013034742.6"><vh>run</vh></v>
<v t="ekr.20201013034742.7"><vh>substitue</vh></v>
</v>
<v t="ekr.20201013034742.8"><vh>@@file importers/{{name}}.py</vh>
<v t="ekr.20201013034742.9"><vh>class {{cap_name}}_Importer</vh>
<v t="ekr.20201013034742.10"><vh>{{name}}.Overrides</vh>
<v t="ekr.20201013034742.11"><vh>{{name}}.clean_headline</vh></v>
<v t="ekr.20201013034742.12"><vh>{{name}}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20201013034742.13"><vh>class {{cap_name}}_ScanState</vh>
<v t="ekr.20201013034742.14"><vh>{{name}}_state.level</vh></v>
<v t="ekr.20201013034742.15"><vh>{{name}}_state.update</vh></v>
</v>
</v>
</v>
<v t="ekr.20201013034742.16"><vh>@@button pep8 @key=Ctrl-5</vh>
<v t="ekr.20201013034742.17"><vh>class Pep8</vh>
<v t="ekr.20201013034742.18"><vh>change_all &amp; helpers</vh>
<v t="ekr.20201013034742.19"><vh>change_body</vh></v>
<v t="ekr.20201013034742.20"><vh>change_headline</vh></v>
</v>
<v t="ekr.20201013034742.21"><vh>get_name</vh></v>
<v t="ekr.20201013034742.22"><vh>run</vh></v>
<v t="ekr.20201013034742.23"><vh>to_pep8</vh></v>
</v>
<v t="ekr.20201013034742.24"><vh>clear</vh></v>
</v>
<v t="ekr.20201013034742.25"><vh>@@button test-jup-export</vh></v>
<v t="ekr.20201013034742.26"><vh>@@button test-jup-import</vh></v>
</v>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
<v t="ekr.20201018062305.1"><vh>@button write-leoPyRef</vh>
<v t="ekr.20201018065757.1"><vh>check_file_names</vh></v>
<v t="ekr.20201018065921.1"><vh>check_nodes</vh></v>
<v t="ekr.20201018063747.1"><vh>get_content</vh></v>
<v t="ekr.20201018070822.1"><vh>main</vh></v>
<v t="ekr.20201018072911.1"><vh>oops</vh></v>
</v>
</v>
<v t="ekr.20200212095937.1"><vh>Beautify command settings</vh>
<v t="ekr.20200212095937.2"><vh>@bool beautify-allow-joined-strings = False</vh></v>
<v t="ekr.20200212095937.3"><vh>@bool beautify-keep-comment-indentation = True</vh></v>
<v t="ekr.20200212095937.5"><vh>@int beautify-max-join-line-length = 0</vh></v>
<v t="ekr.20200212095937.6"><vh>@int beautify-max-split-line-length = 90</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.1"><vh>@data:@auto leo_cloud.py</vh>
<v t="ekr.20201012142922.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20201012111649.3"><vh>@data:@auto leo_cloud_server.py</vh>
<v t="ekr.20201012142922.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh></v>
<v t="ekr.20200308193719.1"><vh>script: check gnx's</vh></v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches/revs (one file)</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-revs</vh></v>
<v t="ekr.20201015145257.1"><vh>script: import legacy file</vh></v>
<v t="ekr.20200222083959.1"><vh>script: start loggin</vh></v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
<v t="ekr.20200222151754.1"><vh>script: yoton "other end"</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20191029023442.1"><vh> 4 kinds of documentation</vh></v>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
<v t="ekr.20200522082827.1"><vh>From leoMenu.py</vh>
<v t="ekr.20051022044950"><vh>LeoMenu.computeOldStyleShortcutKey</vh></v>
<v t="ekr.20031218072017.4117"><vh>LeoMenu.defineMenuCallback</vh></v>
</v>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
<v t="ekr.20190122185223.1"><vh>regex: find all kwargs</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d7100285806000000302e31362e3071017d71025808000000616e6e6f7461746571037d7104735806000000302e31392e3171057d71065808000000616e6e6f7461746571077d7108735806000000302e32302e3171097d710a5808000000616e6e6f74617465710b7d710c73752e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20201012111545.1"><vh>Plugins</vh>
<v t="ekr.20090430075506.3"><vh>@file ../plugins/leoPluginNotes.txt</vh></v>
<v t="EKR.20040517090508"><vh>  Enable plugins using @enabled-plugins nodes</vh></v>
<v t="ekr.20050303051035"><vh>  Templates</vh>
<v t="ekr.20041114102139"><vh>Notes for plugin writers</vh></v>
<v t="ekr.20050306071629"><vh>Template for plugins that override commander methods</vh>
<v t="ekr.20050306071629.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050306071629.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050306071629.4"><vh>init</vh></v>
<v t="ekr.20050306071540"><vh>onStart2</vh></v>
</v>
<v t="ekr.20050303051035.2"><vh>Template for plugins with per-commander controller class</vh>
<v t="ekr.20050303051035.5"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050303051101"><vh>init</vh></v>
<v t="ekr.20050303051150"><vh>onCreate</vh></v>
<v t="ekr.20050303051222"><vh>class pluginController</vh>
<v t="ekr.20050303051222.1"><vh>__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20100103093121.5365"><vh>Auto completion</vh>
<v t="ekr.20091118065749.5261"><vh>@file ../plugins/ctagscompleter.py</vh></v>
</v>
<v t="edream.110203113231.667"><vh>Commands &amp; directives</vh>
<v t="edream.110203113231.741"><vh>@file ../plugins/add_directives.py</vh></v>
<v t="ekr.20101110084839.5682"><vh>@file ../plugins/bzr_qcommands.py</vh></v>
<v t="EKR.20040517080049.1"><vh>@file ../plugins/empty_leo_file.py</vh></v>
<v t="edream.110203113231.669"><vh>@file ../plugins/import_cisco_config.py</vh></v>
<v t="ekr.20101110092851.5812"><vh>@file ../plugins/initinclass.py</vh></v>
<v t="ekr.20101110091234.5700"><vh>@file ../plugins/leo_interface.py</vh></v>
<v t="ekr.20040419105219"><vh>@file ../plugins/lineNumbers.py</vh></v>
<v t="ekr.20040916084945"><vh>@file ../plugins/macros.py</vh></v>
<v t="edream.110203113231.724"><vh>@file ../plugins/mod_autosave.py</vh></v>
<v t="ekr.20050301083306"><vh>@file ../plugins/mod_read_dir_outline.py</vh></v>
<v t="edream.110203113231.727"><vh>@file ../plugins/mod_timestamp.py</vh></v>
<v t="TL.20090225102340.32"><vh>@file ../plugins/nodeActions.py</vh></v>
<v t="edream.110203113231.720"><vh>@file ../plugins/outline_export.py</vh></v>
<v t="danr7.20060912105041.1"><vh>@file ../plugins/paste_as_headlines.py</vh></v>
<v t="tbrown.20070117104409"><vh>@file ../plugins/quickMove.py</vh></v>
<v t="ekr.20081214160729.1"><vh>@file ../plugins/setHomeDirectory.py</vh></v>
<v t="danr7.20061010105952.1"><vh>@file ../plugins/word_count.py</vh></v>
</v>
<v t="edream.110203113231.729"><vh>Debugging</vh>
<v t="ekr.20101110091234.5689"><vh>@file ../plugins/debugger_pudb.py</vh></v>
<v t="edream.110203113231.730"><vh>@file ../plugins/dump_globals.py</vh></v>
<v t="edream.110203113231.732"><vh>@file ../plugins/enable_gc.py</vh></v>
<v t="edream.110203113231.734"><vh>@file ../plugins/quit_leo.py</vh></v>
<v t="edream.110203113231.735"><vh>@file ../plugins/trace_gc_plugin.py</vh></v>
<v t="edream.110203113231.736"><vh>@file ../plugins/trace_keys.py</vh></v>
<v t="edream.110203113231.738"><vh>@file ../plugins/trace_tags.py</vh></v>
</v>
<v t="ekr.20041030092101"><vh>Dyna plugins by e</vh></v>
<v t="ekr.20040722141148"><vh>Examples</vh>
<v t="ekr.20040828105233"><vh>@file ../plugins/examples/chinese_menu.py</vh></v>
<v t="EKR.20040517080202.3"><vh>@file ../plugins/examples/french_fm.py</vh></v>
<v t="edream.110203113231.916"><vh>@file ../plugins/examples/override_classes.py</vh></v>
<v t="edream.110203113231.919"><vh>@file ../plugins/examples/override_commands.py</vh></v>
<v t="ekr.20060621123339"><vh>@file ../plugins/examples/print_cp.py</vh></v>
<v t="edream.110203113231.921"><vh>@file ../plugins/examples/redefine_put.py</vh></v>
<v t="ekr.20180119164431.1"><vh>@file ../plugins/patch_python_colorizer.py</vh></v>
</v>
<v t="ekr.20101110150056.9457"><vh>Experimental</vh>
<v t="ekr.20090704103932.5160"><vh>@file ../plugins/leo_pdf.py</vh></v>
<v t="danr7.20060902083957"><vh>@file ../plugins/leo_to_rtf.py</vh></v>
<v t="ekr.20040205071616"><vh>@file ../plugins/mnplugins.py</vh></v>
<v t="ekr.20101110094759.5843"><vh>@file ../plugins/mod_speedups.py</vh></v>
<v t="ekr.20040910070811.1"><vh>@file ../plugins/run_nodes.py</vh></v>
<v t="ekr.20170313020320.1"><vh>@file ../plugins/settings_finder.py</vh></v>
<v t="ekr.20100103093121.5339"><vh>@file ../plugins/stickynotes_plus.py</vh></v>
<v t="ekr.20140225222704.16748"><vh>@file ../plugins/viewrendered2.py</vh></v>
<v t="ekr.20040331071919"><vh>Leo to AsciiDoc</vh>
<v t="ekr.20101110093449.5822"><vh>@file ../plugins/mod_leo2ascd.py</vh></v>
<v t="ekr.20101110150056.9445"><vh>@file ../plugins/mod_leo2ascd.txt</vh></v>
</v>
</v>
<v t="EKR.20040517075715"><vh>External programs</vh>
<v t="ekr.20110125103904.12504"><vh>@file ../plugins/gitarchive.py</vh></v>
<v t="EKR.20040517080049.4"><vh>@file ../plugins/open_shell.py</vh></v>
<v t="ville.20090503124249.1"><vh>@file ../plugins/tomboy_import.py</vh></v>
<v t="EKR.20040517075715.10"><vh>@file ../plugins/vim.py</vh></v>
<v t="EKR.20040517075715.12"><vh>@file ../plugins/xemacs.py</vh></v>
<v t="EKR.20040517075715.13"><vh>Word export</vh>
<v t="EKR.20040517075715.14"><vh>@file ../plugins/word_export.py</vh></v>
<v t="EKR.20040517075715.20"><vh>@file-nosent ../plugins/word_export.ini</vh></v>
</v>
</v>
<v t="edream.110203113231.872"><vh>Files and nodes</vh>
<v t="tbrown.20080613095157.2"><vh>@file ../plugins/active_path.py</vh></v>
<v t="edream.110203113231.873"><vh>@file ../plugins/at_folder.py</vh></v>
<v t="ekr.20040915085351"><vh>@file ../plugins/at_produce.py</vh></v>
<v t="ktenney.20041211072654.1"><vh>@file ../plugins/at_view.py</vh></v>
<v t="ekr.20170619151859.2"><vh>@file ../plugins/auto_colorize2_0.py</vh></v>
<v t="tbrown.20081223111325.3"><vh>@file ../plugins/backlink.py</vh></v>
<v t="tbrown.20070322113635"><vh>@file ../plugins/bookmarks.py</vh></v>
<v t="ekr.20060807103814.1"><vh>@file ../plugins/datenodes.py</vh></v>
<v t="ajones.20070122153625"><vh>@file ../plugins/expfolder.py</vh></v>
<v t="ekr.20040915105758.13"><vh>@file ../plugins/FileActions.py</vh></v>
<v t="ekr.20110110105526.5463"><vh>@file ../plugins/ftp.py</vh></v>
<v t="tbrown.20091214233510.5347"><vh>@file ../plugins/geotag.py</vh></v>
<v t="tbrown.20100228141752.5691"><vh>@file ../plugins/leocursor.py</vh></v>
<v t="ville.20120503224623.3574"><vh>@file ../plugins/leomylyn.py</vh></v>
<v t="ekr.20101110092851.5742"><vh>@file ../plugins/leoOPML.py</vh></v>
<v t="dan.20090217132953.1"><vh>@file ../plugins/mime.py</vh></v>
<v t="mork.20041018204908.1"><vh>@file ../plugins/multifile.py</vh></v>
<v t="ekr.20040331151007"><vh>@file ../plugins/niceNosent.py</vh></v>
<v t="edream.110203113231.876"><vh>@file ../plugins/read_only_nodes.py</vh></v>
<v t="ekr.20040828103325"><vh>@file ../plugins/startfile.py</vh></v>
<v t="ekr.20130808211520.15893"><vh>@file ../plugins/timestamp.py</vh></v>
<v t="tbrown.20110428144124.29061"><vh>@file ../plugins/xml_edit.py</vh></v>
<v t="mork.20041010095009"><vh>@file ../plugins/xsltWithNodes.py</vh></v>
</v>
<v t="ekr.20181030041436.1"><vh>Gui</vh>
<v t="ekr.20150107090324.1"><vh>@file ../plugins/cursesGui.py</vh></v>
<v t="ekr.20170419092835.1"><vh>@file ../plugins/cursesGui2.py</vh></v>
<v t="ekr.20181103094900.1"><vh>@file ../plugins/leoflexx.py</vh></v>
<v t="ekr.201811100000000.1"><vh>@file ../plugins/leoflexx_js.py</vh></v>
<v t="peckj.20150428142633.1"><vh>@file ../plugins/python_terminal.py</vh></v>
</v>
<v t="ekr.20140723122936.17925"><vh>Importer plugins</vh>
<v t="ekr.20140723122936.18139"><vh>@file ../plugins/importers/__init__.py</vh></v>
<v t="ekr.20140723122936.17926"><vh>@file ../plugins/importers/c.py</vh></v>
<v t="ekr.20160505094722.1"><vh>@file ../plugins/importers/coffeescript.py</vh></v>
<v t="ekr.20140723122936.18140"><vh>@file ../plugins/importers/csharp.py</vh></v>
<v t="tbrown.20140801105909.47549"><vh>@file ../plugins/importers/ctext.py</vh></v>
<v t="ekr.20200619141135.1"><vh>@file ../plugins/importers/cython.py</vh></v>
<v t="ekr.20141116100154.1"><vh>@file ../plugins/importers/dart.py</vh></v>
<v t="ekr.20140723122936.18141"><vh>@file ../plugins/importers/elisp.py</vh></v>
<v t="ekr.20140723122936.18138"><vh>@file ../plugins/importers/html.py</vh></v>
<v t="ekr.20140723122936.18142"><vh>@file ../plugins/importers/ini.py</vh></v>
<v t="ekr.20160412101008.1"><vh>@file ../plugins/importers/ipynb.py</vh></v>
<v t="ekr.20140723122936.18143"><vh>@file ../plugins/importers/java.py</vh></v>
<v t="ekr.20140723122936.18144"><vh>@file ../plugins/importers/javascript.py</vh></v>
<v t="ekr.20160504080826.1"><vh>@file ../plugins/importers/leo_json.py</vh></v>
<v t="ekr.20140723122936.18151"><vh>@file ../plugins/importers/leo_rst.py</vh></v>
<v t="ekr.20161108125620.1"><vh>@file ../plugins/importers/linescanner.py</vh></v>
<v t="ekr.20170530024520.2"><vh>@file ../plugins/importers/lua.py</vh></v>
<v t="ekr.20140725190808.18066"><vh>@file ../plugins/importers/markdown.py</vh></v>
<v t="ekr.20140723122936.18146"><vh>@file ../plugins/importers/org.py</vh></v>
<v t="ekr.20140723122936.18150"><vh>@file ../plugins/importers/otl.py</vh></v>
<v t="ekr.20140723122936.18147"><vh>@file ../plugins/importers/pascal.py</vh></v>
<v t="ekr.20161027100313.1"><vh>@file ../plugins/importers/perl.py</vh></v>
<v t="ekr.20140723122936.18148"><vh>@file ../plugins/importers/php.py</vh></v>
<v t="ekr.20140723122936.18149"><vh>@file ../plugins/importers/python.py</vh></v>
<v t="ekr.20200316100818.1"><vh>@file ../plugins/importers/rust.py</vh></v>
<v t="ekr.20170615153639.2"><vh>@file ../plugins/importers/tcl.py</vh></v>
<v t="ekr.20180201203240.2"><vh>@file ../plugins/importers/treepad.py</vh></v>
<v t="ekr.20140723122936.18152"><vh>@file ../plugins/importers/typescript.py</vh></v>
<v t="ekr.20140723122936.18137"><vh>@file ../plugins/importers/xml.py</vh></v>
</v>
<v t="ekr.20180504192522.1"><vh>leo_babel</vh>
<v t="ekr.20180504191650.34"><vh>@clean ../plugins/leo_babel/__init__.py</vh></v>
<v t="ekr.20180504191650.36"><vh>examples</vh>
<v t="bob.20170716135108.2"><vh>@file ../plugins/leo_babel/examples/slowOut.py</vh></v>
<v t="bob.20170716135108.3"><vh>@file ../plugins/leo_babel/examples/slowOutNoFlush.py</vh></v>
</v>
<v t="ekr.20180504191650.42"><vh>tests</vh>
<v t="ekr.20180504191650.68"><vh>@clean ../plugins/leo_babel/tests/__init__.py</vh></v>
<v t="bob.20180206123613.1"><vh>@file ../plugins/leo_babel/tests/idle_time.py</vh></v>
<v t="bob.20180205135005.1"><vh>@file ../plugins/leo_babel/tests/lib_test.py</vh></v>
<v t="bob.20180125160225.1"><vh>@file ../plugins/leo_babel/tests/tests.py</vh></v>
</v>
</v>
<v t="ekr.20130927050813.13031"><vh>Obsolete</vh>
<v t="ajones.20070122160142"><vh>@file ../plugins/textnode.py</vh></v>
<v t="ekr.20050817132814"><vh>rst3</vh>
<v t="ekr.20050805162550"><vh>@@file ../plugins/rst3.py</vh>
<v t="ekr.20050805162550.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050805162550.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050806162146"><vh>&lt;&lt; to do &gt;&gt;</vh>
<v t="ekr.20050804081215"><vh>More options</vh></v>
</v>
<v t="ekr.20050805162550.4"><vh>Module level</vh>
<v t="ekr.20050805162550.5"><vh> init</vh></v>
<v t="ekr.20050805162550.6"><vh>onCreate</vh></v>
<v t="ekr.20050806101253"><vh>code_block</vh></v>
<v t="ekr.20090429055156.63"><vh>runUnitTests</vh></v>
</v>
<v t="ekr.20050805162550.39"><vh>html parser classes</vh>
<v t="ekr.20050805162550.40"><vh> &lt;&lt; class linkAnchorParserClass &gt;&gt; (subclass of HTMLParser.HTMLParser)</vh>
<v t="ekr.20050805162550.41"><vh>__init__</vh></v>
<v t="ekr.20050805162550.42"><vh>is_anchor</vh></v>
<v t="ekr.20050805162550.43"><vh>is_link</vh></v>
<v t="ekr.20050815164715"><vh>is_node_marker</vh></v>
</v>
<v t="ekr.20050805162550.44"><vh>class htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.45"><vh>__init__</vh></v>
<v t="ekr.20050805162550.46"><vh>handle_starttag</vh>
<v t="ekr.20050815164715.1"><vh>&lt;&lt; trace the unknownAttribute &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.47"><vh>handle_endtag</vh></v>
<v t="ekr.20050805162550.49"><vh>feed</vh></v>
</v>
<v t="ekr.20050805162550.50"><vh>class anchor_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.51"><vh> __init__</vh></v>
<v t="ekr.20050805162550.52"><vh>handle_starttag</vh></v>
</v>
<v t="ekr.20050805162550.53"><vh>class link_htmlParserClass (linkAnchorParserClass)</vh>
<v t="ekr.20050805162550.54"><vh>__init__</vh></v>
<v t="ekr.20050805162550.55"><vh>handle_starttag</vh></v>
<v t="ekr.20050805162550.56"><vh>get_replacements</vh></v>
</v>
</v>
<v t="ekr.20050805162550.8"><vh>class rstClass</vh>
<v t="ekr.20050805162550.9"><vh> Birth &amp; init</vh>
<v t="ekr.20050805162550.10"><vh> ctor (rstClass)</vh>
<v t="ekr.20050805162550.11"><vh>&lt;&lt; init ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050805162550.12"><vh>addMenu (rstClass, rst3.py) (obsolete)</vh></v>
<v t="ekr.20050813083007"><vh>initHeadlineCommands</vh></v>
<v t="ekr.20050813085236"><vh>initSingleNodeOptions</vh></v>
<v t="ekr.20050808072943"><vh>munge</vh></v>
</v>
<v t="ekr.20050812122236"><vh>options...</vh>
<v t="ekr.20050808064245"><vh>createDefaultOptionsDict</vh></v>
<v t="ekr.20050812120933"><vh>dumpSettings (debugging)</vh></v>
<v t="ekr.20050814134351"><vh>getOption</vh></v>
<v t="ekr.20071015110830"><vh>initCodeBlockString</vh></v>
<v t="ekr.20050807120331.1"><vh>preprocessTree &amp; helpers</vh>
<v t="ekr.20051204070141"><vh>preprocessNode</vh></v>
<v t="ekr.20050808072943.1"><vh>parseOptionLine</vh></v>
<v t="ekr.20050808070018.2"><vh>scanForOptionDocParts</vh></v>
<v t="ekr.20050811173750"><vh>scanHeadlineForOptions</vh></v>
<v t="ekr.20050807120331.2"><vh>scanNodeForOptions</vh></v>
<v t="ekr.20050808070018"><vh>scanOption</vh></v>
<v t="ekr.20050808070018.1"><vh>scanOptions</vh></v>
</v>
<v t="ekr.20050808142313.28"><vh>scanAllOptions &amp; helpers</vh>
<v t="ekr.20050805162550.13"><vh>initOptionsFromSettings</vh></v>
<v t="ekr.20050810103731"><vh>handleSingleNodeOptions</vh></v>
</v>
<v t="ekr.20050811135526"><vh>setOption</vh></v>
</v>
<v t="ekr.20050809074827"><vh>write methods</vh>
<v t="ekr.20050809082854"><vh> Top-level write code</vh>
<v t="ekr.20050809075309"><vh>initWrite</vh></v>
<v t="ekr.20050809080925"><vh>writeNormalTree</vh></v>
<v t="ekr.20051121102358"><vh>processTopTree</vh></v>
<v t="ekr.20050805162550.17"><vh>processTree</vh></v>
<v t="ekr.20050805162550.21"><vh>writeSpecialTree</vh></v>
<v t="ekr.20050809082854.1"><vh>writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090428082801.64"><vh>handleMissingStyleSheetArgs</vh></v>
</v>
<v t="ekr.20060525102337"><vh>writeNodeToString (New in 4.4.1)</vh></v>
</v>
<v t="ekr.20050811154552"><vh>getDocPart</vh>
<v t="ekr.20060610104435"><vh>&lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811102607"><vh>skip_literal_block</vh></v>
<v t="ekr.20050811101550.1"><vh>writeBody &amp; helpers</vh>
<v t="ekr.20050811150541"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20050811152104"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20050813155021"><vh>rstripList</vh></v>
<v t="ekr.20050813160208"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20060608094815"><vh>handleDocOnlyMode</vh></v>
<v t="ekr.20060608094815.1"><vh>isAnyDocPart</vh></v>
<v t="ekr.20050811153208"><vh>isSpecialDocPart</vh></v>
<v t="ekr.20050811163802"><vh>isAnySpecialDocPart</vh></v>
<v t="ekr.20050811105438"><vh>removeLeoDirectives</vh></v>
<v t="ekr.20050811105438.1"><vh>handleSpecialDocParts</vh></v>
<v t="ekr.20050805162550.30"><vh>replaceCodeBlockDirectives</vh></v>
</v>
<v t="ekr.20050805162550.26"><vh>writeHeadline &amp; helper</vh>
<v t="ekr.20060608102001"><vh>writeHeadlineHelper</vh></v>
</v>
<v t="ekr.20050810083057"><vh>writeNode</vh></v>
<v t="ekr.20071115061253"><vh>writePreformat</vh></v>
<v t="ekr.20050805162550.23"><vh>writeTree</vh></v>
</v>
<v t="ekr.20050810083314"><vh>Utils</vh>
<v t="ekr.20051202070028"><vh>computeOutputFileName</vh></v>
<v t="ekr.20050805162550.16"><vh>encode</vh></v>
<v t="ekr.20050805162550.20"><vh>report</vh></v>
<v t="ekr.20050810083856"><vh>rstComment</vh></v>
<v t="ekr.20050805162550.19"><vh>underline</vh></v>
<v t="ekr.20050809080031"><vh>write</vh></v>
</v>
<v t="ekr.20050805162550.33"><vh>Support for http plugin</vh>
<v t="ekr.20050815091008.1"><vh>http_addNodeMarker</vh></v>
<v t="ekr.20050805162550.34"><vh>http_endTree &amp; helpers</vh>
<v t="ekr.20050805162550.36"><vh>set_initial_http_attributes</vh></v>
<v t="ekr.20050805162550.38"><vh>find_anchors</vh></v>
<v t="ekr.20050805162550.37"><vh>relocate_references</vh></v>
<v t="ekr.20050805162550.35"><vh>http_attribute_iter</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20181028052650.1"><vh>@file ../plugins/leowapp.py</vh></v>
<v t="ekr.20190410171646.1"><vh>Unused: pyzo_support.py</vh>
<v t="ekr.20190412042616.1"><vh>&lt;&lt; copyright &gt;&gt;</vh></v>
<v t="ekr.20190410171905.1"><vh>init (pyzo_support.py)</vh></v>
<v t="ekr.20190418161712.1"><vh>class PyzoInterface</vh>
<v t="ekr.20190803175344.1"><vh>pyzo_x.patch_pyzo</vh></v>
</v>
</v>
<v t="ekr.20190813161639.1"><vh>Obsolete: @file ../plugins/pyzo_in_leo.py</vh>
<v t="ekr.20190930051422.1"><vh>Top-level functions (pyzo_in_leo)</vh>
<v t="ekr.20190813161639.4"><vh>init (pyzo_in_leo)</vh></v>
<v t="ekr.20190928061911.1"><vh>onCreate</vh></v>
<v t="ekr.20190816163728.1"><vh>close_handler</vh></v>
<v t="ekr.20191012094334.1"><vh>patched: setShortcut</vh></v>
<v t="ekr.20191012093236.1"><vh>patched: _get_interpreters_win</vh></v>
</v>
<v t="ekr.20190930051034.1"><vh>class PyzoController</vh>
<v t="ekr.20190929180053.1"><vh>pz.init_pyzo_menu</vh></v>
<v t="ekr.20190814050859.1"><vh>pz.load_all_pyzo_docks</vh></v>
<v t="ekr.20190816131753.1"><vh>pz.main_window_ctor</vh></v>
<v t="ekr.20190816132847.1"><vh>pz.main_window_populate</vh></v>
<v t="ekr.20190813161921.1"><vh>pz.make_global_dock</vh></v>
<v t="ekr.20190816131343.1"><vh>pz.pyzo_start</vh></v>
</v>
</v>
<v t="ekr.20190805022257.1"><vh>Unused: @file ../plugins/file pyzo_file_browser.py</vh>
<v t="ekr.20190809093446.1"><vh> &lt;&lt; pyzo_file_browser imports &gt;&gt;</vh></v>
<v t="ekr.20190809093459.1"><vh> top-level Leo functions</vh>
<v t="ekr.20190809093459.3"><vh>init (pyzo_file_browser)</vh></v>
<v t="ekr.20190809093459.4"><vh>onCreate</vh></v>
<v t="ekr.20190814050007.1"><vh>make_dock</vh></v>
</v>
</v>
</v>
<v t="ekr.20041001210557"><vh>Scripting</vh>
<v t="tbrown.20100226095909.12777"><vh>@file ../plugins/leoscreen.py</vh></v>
<v t="tbrown.20140806084727.30174"><vh>@file ../plugins/livecode.py</vh></v>
<v t="ekr.20060328125248"><vh>@file ../plugins/mod_scripting.py</vh></v>
<v t="edream.110203113231.925"><vh>@file ../plugins/script_io_to_body.py</vh></v>
</v>
<v t="ekr.20120309073937.9878"><vh>Searching</vh>
<v t="ekr.20120309073748.9872"><vh>@file ../plugins/bigdash.py</vh></v>
<v t="peckj.20140804114520.9427"><vh>@file ../plugins/nodetags.py</vh></v>
<v t="peckj.20131130132659.5964"><vh>@file ../plugins/nodewatch.py</vh></v>
</v>
<v t="ekr.20050111122605"><vh>Servers &amp; web stuff</vh>
<v t="ekr.20170925083314.1"><vh>@auto ../plugins/leo_cloud.py</vh></v>
<v t="ekr.20170925083853.1"><vh>@auto ../plugins/leo_cloud_server.py</vh></v>
<v t="ville.20110206142055.10640"><vh>@file ../plugins/leofeeds.py</vh></v>
<v t="ville.20110125222411.10536"><vh>@file ../plugins/leomail.py</vh></v>
<v t="ville.20091009202416.10040"><vh>@file ../plugins/leoremote.py</vh></v>
<v t="EKR.20040517080250.1"><vh>@file ../plugins/mod_http.py</vh></v>
<v t="ekr.20131004162848.11444"><vh>@file ../plugins/rss.py</vh></v>
<v t="peckj.20140811080604.9496"><vh>@file ../plugins/sftp.py</vh></v>
</v>
<v t="ekr.20101004082701.5674"><vh>Slideshows, screencasts &amp; screenshots</vh>
<v t="ekr.20170128213103.1"><vh>@file ../plugins/demo.py</vh></v>
<v t="ekr.20120913110135.10579"><vh>@file ../plugins/screencast.py</vh></v>
<v t="ekr.20101121031443.5330"><vh>@file ../plugins/screenshots.py</vh></v>
<v t="ekr.20060831165821"><vh>@file ../plugins/slideshow.py</vh></v>
</v>
<v t="ekr.20071113084440"><vh>Testing</vh>
<v t="ekr.20080214092357"><vh>@file ../plugins/test/ekr_test.py</vh></v>
<v t="ekr.20050130120433"><vh>@@file ../plugins/test/failed_import.py</vh></v>
<v t="ekr.20071113085315"><vh>@file ../plugins/test/failed_to_load_plugin.py</vh></v>
<v t="ekr.20051016160700"><vh>@file ../plugins/testRegisterCommand.py</vh></v>
</v>
<v t="ekr.20050306081349"><vh>Text formatting</vh>
<v t="timo.20050213160555"><vh>@file ../plugins/bibtex.py</vh></v>
<v t="ekr.20070119094733.1"><vh>@file ../plugins/dtest.py</vh></v>
<v t="ville.20110409151021.5699"><vh>@file ../plugins/jinjarender.py</vh></v>
<v t="danr7.20060902215215.1"><vh>@file ../plugins/leo_to_html.py</vh></v>
<v t="tbrown.20130930160706.23451"><vh>@file ../plugins/markup_inline.py</vh></v>
<v t="vitalije.20180804172140.1"><vh>@file ../plugins/md_docer.py</vh></v>
<v t="peckj.20140113150237.7083"><vh>@file ../plugins/nodediff.py</vh></v>
<v t="tbrown.20130813134319.11942"><vh>@file ../plugins/richtext.py</vh></v>
<v t="ekr.20170217164004.1"><vh>@file ../plugins/tables.py</vh></v>
</v>
<v t="ekr.20121126102050.10134"><vh>Threading</vh>
<v t="ekr.20121126095734.12418"><vh>@file ../plugins/threadutil.py</vh></v>
</v>
<v t="ekr.20040915073259"><vh>User interface</vh>
<v t="ekr.20101110150056.9453"><vh> Qt only plugins</vh>
<v t="tbrown.20091029123555.5319"><vh>@file ../plugins/attrib_edit.py</vh></v>
<v t="ville.20090310191936.10"><vh>@file ../plugins/colorize_headlines.py</vh></v>
<v t="ekr.20090701111504.5294"><vh>@file ../plugins/contextmenu.py</vh></v>
<v t="tbrown.20090206153748.1"><vh>@file ../plugins/graphcanvas.py</vh></v>
<v t="ville.20090518182905.5419"><vh>@file ../plugins/nav_qt.py</vh></v>
<v t="ville.20120604212857.4215"><vh>@file ../plugins/notebook.py</vh></v>
<v t="ekr.20090622063842.5264"><vh>@file ../plugins/projectwizard.py</vh></v>
<v t="ekr.20160928073518.1"><vh>@file ../plugins/pyplot_backend.py</vh></v>
<v t="ville.20090314215508.4"><vh>@file ../plugins/quicksearch.py</vh></v>
<v t="tbrown.20130420091241.44181"><vh>@file ../plugins/screen_capture.py</vh></v>
<v t="ville.20090815203828.5235"><vh>@file ../plugins/spydershell.py</vh></v>
<v t="ekr.20100103093121.5329"><vh>@file ../plugins/stickynotes.py</vh></v>
<v t="tbrown.20090119215428.2" descendentVnodeUnknownAttributes="7d71005808000000302e362e31332e3071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file ../plugins/todo.py</vh></v>
<v t="ville.20110403115003.10348"><vh>@file ../plugins/valuespace.py</vh></v>
<v t="tbrown.20100318101414.5990"><vh>@file ../plugins/viewrendered.py</vh></v>
<v t="TomP.20191215195433.1"><vh>@file ../plugins/viewrendered3.py</vh></v>
</v>
<v t="ekr.20160519123329.1"><vh>@edit ../plugins/QNCalendarWidget.py</vh></v>
<v t="ekr.20060328125925"><vh>@file ../plugins/chapter_hoist.py</vh></v>
<v t="ville.20110115234843.8742"><vh>@file ../plugins/dragdropgoodies.py</vh></v>
<v t="vitalije.20190928154420.1"><vh>@file ../plugins/history_tracer.py</vh></v>
<v t="tbrown.20090513125417.5244"><vh>@file ../plugins/interact.py</vh></v>
<v t="vitalije.20170727201534.1"><vh>@file ../plugins/line_numbering.py</vh></v>
<v t="ekr.20040915073259.1"><vh>@file ../plugins/maximizeNewWindows.py</vh></v>
<v t="ekr.20101110093301.5818"><vh>@file ../plugins/mod_framesize.py</vh></v>
<v t="EKR.20040517080555.2"><vh>@file ../plugins/plugins_menu.py</vh></v>
<v t="edream.110203113231.924"><vh>@file ../plugins/redirect_to_log.py</vh></v>
<v t="ville.20110304230157.6513"><vh>@file ../plugins/systray.py</vh></v>
<v t="tbrown.20141101114322.1"><vh>@file ../plugins/wikiview.py</vh></v>
<v t="ekr.20181004143535.1"><vh>@file ../plugins/xdb_pane.py</vh></v>
<v t="ekr.20101110095202.5882"><vh>@file ../plugins/zenity_file_dialogs.py</vh></v>
</v>
<v t="ekr.20140726091031.18071"><vh>Writer plugins</vh>
<v t="ekr.20140726091031.18152"><vh>@file ../plugins/writers/__init__.py</vh></v>
<v t="ekr.20140726091031.18143"><vh>@file ../plugins/writers/basewriter.py</vh></v>
<v t="tbrown.20140804103545.29975"><vh>@file ../plugins/writers/ctext.py</vh></v>
<v t="ekr.20141116100154.2"><vh>@file ../plugins/writers/dart.py</vh></v>
<v t="ekr.20160412101901.1"><vh>@file ../plugins/writers/ipynb.py</vh></v>
<v t="ekr.20160504083330.1"><vh>@file ../plugins/writers/leo_json.py</vh></v>
<v t="ekr.20180202053206.1"><vh>@file ../plugins/writers/treepad.py</vh></v>
<v t="ekr.20140726091031.18080"><vh>@file ../plugins/writers/leo_rst.py</vh></v>
<v t="ekr.20140726091031.18073"><vh>@file ../plugins/writers/markdown.py</vh></v>
<v t="ekr.20140726091031.18079"><vh>@file ../plugins/writers/org.py</vh></v>
<v t="ekr.20140726091031.18078"><vh>@file ../plugins/writers/otl.py</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20190607124533.1"><vh>@nopylint</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt;</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt;</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt;</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="EKR.20040517075715"></t>
<t tx="EKR.20040517075715.13"></t>
<t tx="EKR.20040517075715.20">[Main]
use_styles = Yes
use_section_numbers = Yes
use_current_document = Yes
max_headings = 6
header_style = Heading
</t>
<t tx="EKR.20040517090508">@nocolor-node

Enable plugins by creating@enabled-plugins nodes in leoSettings files,
typically myLeoSettings.leo.See the node

Users Guide-- &gt; Chapter 8: Customizing Leo-- &gt;@rst
html\customizing.html-- &gt; Specifying settings-- &gt; Complex settings nodes

in LeoDocs.leo for full details.

**Important**: Leo no longer uses pluginsManager.txt to enable or disable plugins.
</t>
<t tx="edream.110203113231.667"></t>
<t tx="edream.110203113231.729"></t>
<t tx="edream.110203113231.872">@nocolor-node

These plugins create new kinds of nodes, some of which affect the file system.</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.

# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self, fileName,
    gui=None,
    parentFrame=None,
    previousSettings=None,
    relativeFileName=None,
):

    # tag = 'Commands.__init__ %s' % (g.shortFileName(fileName))
    c = self
    # Official ivars.
    self._currentPosition = None
    self._topPosition = None
    self.frame = None
    self.parentFrame = parentFrame  # New in Leo 6.0.
    self.gui = gui or g.app.gui
    self.ipythonController = None
        # Set only by the ipython plugin.
    # The order of these calls does not matter.
    c.initCommandIvars()
    c.initDebugIvars()
    c.initDocumentIvars()
    c.initEventIvars()
    c.initFileIvars(fileName, relativeFileName)
    c.initOptionsIvars()
    c.initObjectIvars()
    c.initSettings(previousSettings)
        # Init the settings *before* initing the objects.
    # Initialize all subsidiary objects, including subcommanders.
    c.initObjects(self.gui)
    assert c.frame
    assert c.frame.c
    # Complete the init!
    c.finishCreate()
</t>
<t tx="ekr.20031218072017.2814">def __repr__(self):
    return f"Commander {id(self)}: {repr(self.mFileName)}"

__str__ = __repr__
</t>
<t tx="ekr.20031218072017.3344">def __init__(self, context, gnx=None):
    """
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    """
    # The primary data: headline and body text.
    self._headString = 'newHeadline'
    self._bodyString = ''
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context  # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode(self):
    """
    Returns True if:
        
    - the vnode' body contains @ignore at the start of a line or

    - the vnode's headline starts with @ignore.
    """
    # v = self
    if g.match_word(self._headString, 0, '@ignore'):
        return True
    flag, i = g.is_special(self._bodyString, "@ignore")
    return flag
</t>
<t tx="ekr.20031218072017.3395">def contract(self):
    """Contract the node."""
    self.statusBits &amp;= ~self.expandedBit

def expand(self):
    """Expand the node."""
    self.statusBits |= self.expandedBit

def initExpandedBit(self):
    """Init self.statusBits."""
    self.statusBits |= self.expandedBit

def isExpanded(self):
    """Return True if the VNode expansion bit is set."""
    return (self.statusBits &amp; self.expandedBit) != 0
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self, command, name, minibufferCommand):
    # pylint: disable=no-else-return
        # This code is simpler as it is.
    c = self.c
    if minibufferCommand:
        # Create a dummy event as a signal to doCommand.
        event = g.app.gui.create_key_event(c)
        # The first parameter must be event, and it must default to None.

        def minibufferMenuCallback(
            event=event, self=self, command=command, label=name):
            c = self.c
            return c.doCommand(command, label, event)

        return minibufferMenuCallback
    else:
        # The first parameter must be event, and it must default to None.

        def legacyMenuCallback(event=None, self=self, command=command, label=name):
            c = self.c  # 2012/03/04.
            c.check_event(event)
            return c.doCommand(command, label)

        return legacyMenuCallback
    # For pylint
    return None
</t>
<t tx="ekr.20040331071919"></t>
<t tx="ekr.20040722141148">@nocolor-node
@

You would typically not enable any of the following "plugins".

These plugins contain example code only.
</t>
<t tx="ekr.20040915073259">@nocolor-node

These plugins add buttons and other widgets to the icon area or
affect Leo's panes and windows in various ways.

</t>
<t tx="ekr.20041001210557"></t>
<t tx="ekr.20041005105605.144">def write(self, kind, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    sentinels will be False for @clean and @nosent nodes.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(
            root, root.anyAtFileNodeName(), kind=kind, sentinels=sentinels)
        if not fileName or not at.precheck(fileName, root):
            if sentinels:
                # Raise dialog warning of data loss.
                at.addToOrphanList(root)
            else:
                # #1450: No danger of data loss.
                pass
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False  # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen=False,
        at_delims_seen=False,
        at_warning_given=False,
        has_at_others=False,
        in_code=True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i, p)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error(f"@all not valid in: {p.h}")
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error(f"multiple @others in: {p.h}")
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error(f"unmatched @end_raw directive: {p.h}")
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error(f"@verbatim is not a Leo directive: {p.h}")
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error(f"@comment and @delims in node {p.h}")
        at.putDirective(s, i, p)
    else:
        at.error(f"putBody: can not happen: unknown directive kind: {kind}")
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i:j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1:  # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line)  # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Append a string to at.outputList.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041030092101">@Notes by EKR: The dyna plugin is a remarkable body of work by 'e'. Have fun with it.

You may download the latest version at: http: // rclick.netfirms.com / dyna_menu.py.html
</t>
<t tx="ekr.20041114102139">@nocolor

Comments
--------

Most of the comments in the style guide are comments*about*the style guide.
You would replace these comments with your own, or eliminate them entirely in
your plugin.

Docstrings
----------

Several plugins show the docstring, so please take care to do a good job of
describing what the plugin does and how to use it.

Directives
----------

Please put the following at the end of the plugin's top-level node.

    @language python
    @tabwidth-4

Imports
-------

-Do* not*assume that modules like Qt are always available.

-Do* not*use from m import*

-Your code should test whether modules have been imported only if those modules
  may not be available on all platforms.

-To fail gracefully if the Qt gui is not in effect, put the following at
  the top level::

      g.assertUi('qt')

Exceptions
----------

It is usually best* not*to catch exceptions in plugins: doHook catches all
exceptions and disables further calls to plugins.

If a plugin catches exceptions during startup it should do either raise the
exception again or provide an init function at the top level that reports the
failure by returning False.

Use separate nodes
------------------

**Please**define each class, function or method in a separate node!To
make this work, just put@others in the root of your plugin as shown.Note
that@others may be nested, as shown in class myClass.
</t>
<t tx="ekr.20041130173135"># This is a bad idea.

def hash(self):
    c = self
    if c.mFileName:
        return g.os_path_finalize(c.mFileName).lower()  # #1341.
    return 0
</t>
<t tx="ekr.20050111122605"></t>
<t tx="ekr.20050130120433">'''A plugin to test import problems.'''

import leo.core.leoGlobals as g

def onStart(tag,keywords):
    pass

# pylint: disable=unused-import
try:
    import xyzzy
except ImportError:
    g.cantImport('xyzzy',pluginName='failed_import')

def init():
    '''Return True if the plugin has loaded successfully.'''
    g.registerHandler("start2", onStart)
    g.plugin_signon(__name__)
    return True
</t>
<t tx="ekr.20050303051035">@nocolor-node

The following nodes show recommended style when writing plugins.</t>
<t tx="ekr.20050303051035.2">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4
</t>
<t tx="ekr.20050303051035.5">import leo.core.leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050303051101">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=g.app.gui.guiName() in('qt','qttabs')
    if ok:
        if 1: # Use this if you want to create the commander class before the frame is fully created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Use this if you want to create the commander class after the frame is fully created.
            g.registerHandler('after-create-leo-frame',onCreate)
    return ok</t>
<t tx="ekr.20050303051150">def onCreate(tag, keys):

    c=keys.get('c')
    if not c: return

    thePluginController=pluginController(c)
</t>
<t tx="ekr.20050303051222">class pluginController:

    @others</t>
<t tx="ekr.20050303051222.1">def __init__(self,c):

    self.c=c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
</t>
<t tx="ekr.20050306071540">def onStart2(tag, keywords):

    """
    Showing how to define a global hook that affects all commanders.
    """

    log=c.frame.log.__class__

    # Replace frame.put with newPut (not shown).
    g.funcToMethod(newPut,log,"put")</t>
<t tx="ekr.20050306071629">'''
A docstring describing your plugin and how to use it.
If it's long, you might put it in a separate section.
'''
&lt;&lt; imports &gt;&gt;
@others
@language python
@tabwidth-4</t>
<t tx="ekr.20050306071629.1">'''This docstring should be a clear, concise description of
what the plugin does and how to use it.
'''
</t>
<t tx="ekr.20050306071629.3">import leo.core.leoGlobals as g

# Whatever other imports your plugins uses.
</t>
<t tx="ekr.20050306071629.4">def init():
    '''Return True if the plugin has loaded successfully.'''
    ok=True # This might depend on imports, etc.
    if ok:
        g.registerHandler('start2',onStart2)
    return ok</t>
<t tx="ekr.20050306081349"></t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050804081215">@nocolor
@
http://sourceforge.net/forum/message.php?msg_id=3276408

Leo has great potential for smoothing some of the bumps
outside of learning the details of the markup.
Here is my wish list;

(done) - Section level handling.
  - one of the problems with using rst comes when a new
    section level is inserted into a document. Leo can
    take care of this effortlessly, providing a correct
   underline character for each section heading.

    Other than the section management, I want Leo to
    assume that I'm writing rst, and should be rendered
    as-is. If I want to include some pretty Python, I put
    it in a ..  python-code:: block (or some such)

    On top of this base could be built special case
    handling.

- Assist in viewing rendered output
  - easy access to the command to render a tree to  html.
  - I would like an option which automatically inserted
    a @url node which pointed to the rendered file, or
    some other trick to make switching between source
    and output painless.

- Assist in working with the CSS file
  - a CSS file is now required by docutils. A @setting
    could specify the file. I would like some kind of
    sugar which made it easy to edit the CSS file, maybe
    an option to create a @file node automatically,
    like the @url node above. Again, I want to be able
    to effortlessly edit the CSS and see the results.

- The third file of interest when writing rst is the config
   file which controls many behaviours of the renderer.
   Again, some intelligence which located it, made it
   convenient to edit it, maybe even linked to
   documentation for it, would be very nice.

(done) - I would like a setting which would save the file with the
  rst markup and make it easy to examine and edit.

- On the someday/maybe list would be a @publish
  feature, which configured a directory to ftp the rendered
  file to.
</t>
<t tx="ekr.20050805162550">&lt;&lt; docstring &gt;&gt;

# Original rst code by Josef Dalcolmo:
# contributed under the same licensed as Leo.py itself.
# rst3.py based on rst2.py v2.4.
# This has largely been superceded by leo.core.leoRst.

&lt;&lt; imports &gt;&gt;
&lt;&lt; to do &gt;&gt;

bwm_file = None
if 0:
    bwm_file = open("bwm_file", "w")
controllers = {} # For use by @button rst3 code.

@others
</t>
<t tx="ekr.20050805162550.1">''' Creates output files from Leo outlines containing rST (reStructuredText)
markup. This plugin has been superseded by Leo's core rst3 command.

This is a powerful plugin with many options.  The full documentation is at:
http://leoeditor.com//rstplugin3.html

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu. This
command searches the selected outline looking for **rst root nodes** whose
headline have the form @rst &lt;filename&gt;. The plugin then creates the named file
in various ways depending which rst3 options are in effect.

By default, the rst3 plugin creates rST headings automatically from outlines, so
the higher-level nodes in the outline correspond to higher-level sections in the
output. Creating rST headings automatically eliminates one of the most tedious
chores associated with rST markup.

To use this plugin effectively, Python's docutils module must be installed. The
rst3 plugin will use the SilverCity syntax coloring package if it installed.

This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

rst3 options control most aspects of this plugin's operations. You can set
options in @settings trees, in headlines and in body text. There are too many
details to discuss here. For full details see:
http://leoeditor.com//rstplugin3.html

'''
</t>
<t tx="ekr.20050805162550.10">def __init__ (self,c):

    global SilverCity
    self.c = c
    &lt;&lt; init ivars &gt;&gt;

    self.createDefaultOptionsDict()
    self.initOptionsFromSettings() # Still needed.
    self.initHeadlineCommands() # Only needs to be done once.
    self.initSingleNodeOptions()
    self.addMenu()
</t>
<t tx="ekr.20050805162550.11">self.silverCityWarningGiven = False

# The options dictionary.
self.optionsDict = {}
self.option_prefix = '@rst-option'

# Formatting...
self.code_block_string = ''
self.node_counter = 0
self.toplevel = 0
self.topNode = None
self.use_alternate_code_block = SilverCity is None

# Http support...
self.nodeNumber = 0
# All nodes are numbered so that unique anchors can be generated.

self.http_map = {}
# Keys are named hyperlink targets.  Value are positions.
# The targets mark the beginning of the html code specific
# for this position.

self.anchor_map = {}
# Maps anchors (generated by this module) to positions

self.rst3_all = False
# Set to True by the button which processes all @rst trees.

# For writing.
self.defaultEncoding = 'utf-8'
self.leoDirectivesList = g.globalDirectiveList
self.encoding = self.defaultEncoding
self.ext = None # The file extension.
self.outputFileName = None # The name of the file being written.
self.outputFile = None # The open file being written.
self.path = '' # The path from any @path directive.
self.source = None # The written source as a string.
</t>
<t tx="ekr.20050805162550.12">def addMenu (self):

    c = self.c
    editMenu = c.frame.menu.getMenu('Edit')

    def rst3PluginCallback (event=None):
        self.processTopTree(c.p)

    c.k.registerCommand('write-restructured-text', rst3PluginCallback)
    table = (
        ("-",None,None),
        # ("Write Restructed Text","",rst3PluginCallback),
        '&amp;write-restructured-text',
    )
    c.frame.menu.createMenuEntries(editMenu, table)
</t>
<t tx="ekr.20050805162550.13">def initOptionsFromSettings (self):
    '''Init all options from settings.'''
    c = self.c
    d = self.defaultOptionsDict
    for key in sorted(d.keys()):
        for getter,kind in (
            (c.config.getBool,'@bool'),
            (c.config.getString,'@string'),
            (d.get,'default'),
        ):
            val = getter(key)
            if kind == 'default' or val is not None:
                self.setOption(key,val,'initOptionsFromSettings')
                break
    # Special case.
    if self.getOption('http_server_support') and not mod_http:
        g.error('No http_server_support: can not import mod_http plugin')
        self.setOption('http_server_support',False,tag='initOptionsFromSettings')
</t>
<t tx="ekr.20050805162550.16">def encode (self,s):

    return g.toEncodedString(s,encoding=self.encoding,reportErrors=True)
</t>
<t tx="ekr.20050805162550.17">def processTree(self,p,ext,toString,justOneFile):

    '''Process all @rst nodes in a tree.'''

    self.preprocessTree(p)
    found = False ; self.stringOutput = ''
    p = p.copy() ; after= p.nodeAfterTree()
    while p and p != after:
        h = p.h.strip()
        if g.match_word(h,0,"@rst"):
            self.outputFileName = h[4:].strip()
            if (
                (self.outputFileName and self.outputFileName[0] != '-') or
                (toString and not self.outputFileName)
            ):
                found = True
                self.toplevel = p.level() # Define toplevel separately for each rst file.
                if toString:
                    self.ext = ext
                else:
                    self.ext = g.os_path_splitext(self.outputFileName)[1].lower()
                if self.ext in ('.htm','.html','.tex','.pdf'):
                    ok = self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
                else:
                    ok = self.writeNormalTree(p,toString=toString)
                self.scanAllOptions(p) # Restore the top-level verbose setting.
                if toString:
                    return p.copy(),self.stringOutput
                else:
                    if ok: self.report(self.outputFileName)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else: p.moveToThreadNext()
    if not found:
        g.warning('No @rst nodes in selected tree')
    return None,None
</t>
<t tx="ekr.20050805162550.19">def underline (self,s,p):
    '''Return the underlining string to be used at the given level for string s.'''
    u = self.getOption('underline_characters') #  '''#=+*^~"'`-:&gt;&lt;_'''
    level = max(0,p.level()-self.toplevel)
    level = min(level+1,len(u)-1) # Reserve the first character for explicit titles.
    ch = u [level]
    n = max(4,len(s))
    return ch * n + '\n'
</t>
<t tx="ekr.20050805162550.2">import leo.core.leoGlobals as g

import html.parser as HTMLParser
import os
import pprint
import io
StringIO = io.StringIO
import sys

# Make sure the present directory in in sys.path.
dir,junk = os.path.split(__file__)
if dir not in sys.path: sys.path.append(dir)

try:
    import leo.plugins.mod_http as mod_http
except ImportError:
    mod_http = None

try:
    import docutils
    import docutils.parsers.rst
    import docutils.core
    import docutils.io
except ImportError:
    # This message given in init.
    # g.pr('rst3 plugin: can not import docutils')
    docutils = None

try:
    import SilverCity
except ImportError:
    if '--silent' not in sys.argv and not g.unitTesting and not g.app.batchMode:
        g.pr('rst3 plugin: SilverCity not loaded')
    SilverCity = None
</t>
<t tx="ekr.20050805162550.20">def report (self,name):

    if self.getOption('verbose'):

        name = g.os_path_finalize(name)

        g.blue('wrote: %s' % (name))
</t>
<t tx="ekr.20050805162550.21">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was ,encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = g.os_path_finalize(theDir) # #1341.
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.error('did not create:',theDir)
                return False

        # if not os.access(theDir,os.F_OK):
            # os.mkdir(theDir)

        if self.getOption('write_intermediate_file'):
            name = self.outputFileName + '.txt'
            f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = True
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20050805162550.23">def writeTree(self,p):
    '''Write p's tree to self.outputFile.'''
    self.scanAllOptions(p)
    if self.getOption('generate_rst'):
        if self.getOption('generate_rst_header_comment'):
            self.write(self.rstComment(
                'rst3: filename: %s\n\n' % self.outputFileName))
    # We can't use an iterator because we may skip parts of the tree.
    p = p.copy() # Only one copy is needed for traversal.
    self.topNode = p.copy() # Indicate the top of this tree.
    after = p.nodeAfterTree()
    while p and p != after:
        self.writeNode(p)
</t>
<t tx="ekr.20050805162550.26">def writeHeadline (self,p):

    '''Generate an rST section if options permit it.
    Remove headline commands from the headline first,
    and never generate an rST section for @rst-option and @rst-options.'''

    docOnly             =  self.getOption('doc_only_mode')
    ignore              = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')

    if (
        p == self.topNode or
        ignore or
        docOnly or # handleDocOnlyMode handles this.
        not showHeadlines and not showThisHeadline or
        # docOnly and not showOrganizers and not thisHeadline or
        not p.h.strip() and not showOrganizers or
        not p.b.strip() and not showOrganizers
    ):
        return

    self.writeHeadlineHelper(p)
</t>
<t tx="ekr.20050805162550.30">def replaceCodeBlockDirectives (self,lines):

    '''Replace code-block directive, but not in literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        else:
            i = g.skip_ws(s,0)
            if g.match(s,i,'..'):
                i = g.skip_ws(s,i+2)
                if g.match_word(s,i,'code-block'):
                    if 1: # Create a literal block to hold the code.
                        result.append('::\n')
                    else: # This 'annotated' literal block is confusing.
                        result.append('%s code::\n' % s[i+len('code-block'):])
                else:
                    result.append(s)
            else:
                result.append(s)

    return result
</t>
<t tx="ekr.20050805162550.33"></t>
<t tx="ekr.20050805162550.34"># Was http_support_main

def http_endTree (self,filename,p,justOneFile):

    '''Do end-of-tree processing to support the http plugin.'''

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.set_initial_http_attributes(filename)
        self.find_anchors(p)
        if justOneFile:
            self.relocate_references(p.self_and_subtree)

        g.blue('html updated for http plugin')

        if self.getOption('clear_http_attributes'):
            g.es_print("http attributes cleared")
</t>
<t tx="ekr.20050805162550.35">def http_attribute_iter (self, p):
    """
    Iterator for all the nodes which have html code.
    Look at the descendents of p.
    Used for relocation.
    """

    for p1 in p.self_and_subtree():
        attr = mod_http.get_http_attribute(p1)
        if attr:
            yield (p1.copy(),attr)
</t>
<t tx="ekr.20050805162550.36">def set_initial_http_attributes (self,filename):

    f = open(filename)
    parser = htmlParserClass(self)

    for line in f.readlines():
        parser.feed(line)

    f.close()
</t>
<t tx="ekr.20050805162550.37">@ Relocate references here if we are only running for one file.

Otherwise we must postpone the relocation until we have processed all files.
@c

def relocate_references (self, iterator_generator):

    for p in iterator_generator():
        attr = mod_http.get_http_attribute(p)
        if not attr:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file
            print &gt;&gt; bwm_file, "relocate_references(1): Position, attr:"
            pprint.pprint((p, attr), bwm_file)
        # http_lines = attr [3:]
        parser = link_htmlparserClass(self,p)
        for line in attr [3:]:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                parser.feed(line)
        replacements = parser.get_replacements()
        replacements.reverse()
        if not replacements:
            continue
        if bwm_file:
            print &gt;&gt; bwm_file, "relocate_references(2): Replacements:"
            pprint.pprint(replacements, bwm_file)
        for line, column, href, href_file, http_node_ref in replacements:
            if bwm_file:
                print &gt;&gt; bwm_file, ( "relocate_references(3): line:",
                    line, "Column:", column, "href:", href,
                    "href_file:", href_file, "http_node_ref:", http_node_ref)
            marker_parts = href.split("#")
            if len(marker_parts) == 2:
                marker = marker_parts [1]
                replacement = "%s#%s" % (http_node_ref,marker)
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,'href="%s"' % replacement)
                except Exception:
                    g.es("Skipped ", attr[line + 2])
            else:
                # filename = marker_parts [0]
                try:
                    attr [line + 2] = attr [line + 2].replace(
                        'href="%s"' % href,
                        'href="%s"' % http_node_ref)
                except Exception:
                    g.es("Skipped", attr[line+2])
</t>
<t tx="ekr.20050805162550.38">def find_anchors (self, p):

    '''Find the anchors in all the nodes.'''

    for p1, attrs in self.http_attribute_iter(p):
        html = mod_http.reconstruct_html_from_attrs(attrs)
        parser = anchor_htmlParserClass(self, p1)
        for line in html:
            try:
                parser.feed(line)
            except Exception:
                line = ''.join([ch for ch in line if ord(ch) &lt;= 127])
                # filter out non-ascii characters.
                # bwm: not quite sure what's going on here.
                parser.feed(line)
</t>
<t tx="ekr.20050805162550.39">@
The parser classes are used to construct the html code for nodes. The algorithm has two phases:
    1. In the first phase, the html code for each node is identified.
    2. The second phase identifies all links and checks if these links need to be modified.
The first phase of scanning is done by the anchor_hmlParserClass. The second phase of this algorithm is
done with the link_htmlParserClass.
@code

&lt;&lt; class linkAnchorParserClass &gt;&gt;

@others
</t>
<t tx="ekr.20050805162550.4"></t>
<t tx="ekr.20050805162550.40">class linkAnchorParserClass (HTMLParser.HTMLParser):

    '''
    A class to recognize anchors and links in HTML documents.
    A special marker is the "node_marker" which demarkates the border between
    node and the next.
    '''

    @others
</t>
<t tx="ekr.20050805162550.41">def __init__(self,rst):

    super().__init__()
    self.rst = rst

    # Set ivars from options.  This works only if we don't change nodes!
    self.node_begin_marker      = rst.getOption('node_begin_marker')
    self.clear_http_attributes  = rst.getOption('clear_http_attributes')
    self.current_file = rst.outputFileName
</t>
<t tx="ekr.20050805162550.42">def is_anchor(self, tag, attrs):
    """
    Check if the current tag is an anchor.
    Returns *all* anchors.
    Works with docutils 0.4
    """

    if tag == 'a':
        return True

    if self.is_node_marker(attrs):
        return True
    return tag == "span"
</t>
<t tx="ekr.20050805162550.43">def is_link(self, tag, attrs):
    '''
    Return True if tag, attrs is represents a link.
    '''

    if tag != 'a':
        return False

    result = 'href' in dict(attrs)
    return result
</t>
<t tx="ekr.20050805162550.44">class htmlParserClass (linkAnchorParserClass):

    '''
    The responsibility of the html parser is:
        1. Find out which html code belongs to which node.
        2. Keep a stack of open tags which apply to the current node.
        3. Keep a list of tags which should be included in the nodes, even
           though they might be closed.
           The &lt;style&gt; tag is one example of that.

    Later, we have to relocate inter-file links: if a reference to another location
    is in a file, we must change the link.

    '''

    @others
</t>
<t tx="ekr.20050805162550.45">def __init__ (self,rst):

    super().__init__(rst) # Init the base class.

    self.stack = None
    # The stack contains lists of the form:
        # [text1, text2, previous].
        # text1 is the opening tag
        # text2 is the closing tag
        # previous points to the previous stack element

    self.node_marker_stack = []
    # self.node_marker_stack.pop() returns True for a closing
    # tag if the opening tag identified an anchor belonging to a vnode.

    self.node_code = []
        # Accumulated html code.
        # Once the hmtl code is assigned a vnode, it is deleted here.

    self.deleted_lines = 0 # Number of lines deleted in self.node_code

    self.endpos_pending = False
    # Do not include self.node_code[0:self.endpos_pending] in the html code.

    self.last_position = None
    # Last position; we must attach html code to this node.

    self.last_marker = None
</t>
<t tx="ekr.20050805162550.46">def handle_starttag (self,tag,attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If it is an anchor, we check if this anchor marks the beginning of a new
       node
    3. If a new node begins, then we might have to store html code for the previous
       node.
    4. In any case, put the new tag on the stack.
    '''
    is_node_marker = False
    if self.is_anchor(tag,attrs) and self.is_node_marker(attrs):
        is_node_marker = self.is_node_marker(attrs)
        line, column = self.getpos()
        if self.last_position:
            lines = self.node_code [:]
            lines [0] = lines [0] [self.startpos:]
            del lines [line-self.deleted_lines-1:]
            mod_http.get_http_attribute(self.last_position).extend(lines)
            &lt;&lt; trace the unknownAttribute &gt;&gt;
        if self.deleted_lines &lt; line-1:
            del self.node_code [: line-1-self.deleted_lines]
            self.deleted_lines = line-1
            self.endpos_pending = True
    starttag = self.get_starttag_text()
    self.stack = [starttag, None, self.stack]
    self.node_marker_stack.append(is_node_marker)
</t>
<t tx="ekr.20050805162550.47">def handle_endtag(self, tag):
    '''
    1. Set the second element of the current top of stack.
    2. If this is the end tag for an anchor for a node,
       store the current stack for that node.
    '''
    self.stack[1] = "&lt;/" + tag + "&gt;"

    if self.endpos_pending:
        line, column = self.getpos()
        self.startpos = self.node_code[0].find("&gt;", column) + 1
        self.endpos_pending = False

    is_node_marker = self.node_marker_stack.pop()

    if is_node_marker and not self.clear_http_attributes:
        self.last_position = self.rst.http_map[is_node_marker]
        if is_node_marker != self.last_marker:
            if bwm_file: print &gt;&gt; bwm_file, "Handle endtag:", is_node_marker, self.stack
            mod_http.set_http_attribute(self.rst.http_map[is_node_marker], self.stack)
            self.last_marker = is_node_marker
            #bwm: last_marker is not needed?

    self.stack = self.stack[2]
</t>
<t tx="ekr.20050805162550.49">def feed(self, line):

    self.node_code.append(line)

    HTMLParser.HTMLParser.feed(self, line) # Call the base class's feed().
</t>
<t tx="ekr.20050805162550.5">def init ():
    '''Return True if the plugin has loaded successfully.'''
    ok = docutils is not None # Ok for unit testing.
    if ok:
        g.registerHandler('after-create-leo-frame', onCreate)
        g.plugin_signon(__name__)
    else:
        g.error('rst3 plugin not loaded: can not load docutils')
    return ok
</t>
<t tx="ekr.20050805162550.50">class anchor_htmlParserClass (linkAnchorParserClass):

    '''
    This htmlparser does the first step of relocating: finding all the anchors within the html nodes.

    Each anchor is mapped to a tuple:
        (current_file, position).

    Filters out markers which mark the beginning of the html code for a node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.51">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
</t>
<t tx="ekr.20050805162550.52">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; (filename, p)
    '''
    if not self.is_anchor(tag, attrs):
        return

    if self.current_file not in self.anchor_map:
        self.anchor_map[self.current_file] = (self.current_file, self.p)
        simple_name = g.os_path_split(self.current_file)[1]
        self.anchor_map[simple_name] = self.anchor_map[self.current_file]
        if bwm_file: print &gt;&gt; bwm_file, (
            "anchor(1): current_file:", self.current_file,
            "position:", self.p,
            "Simple name:", simple_name,
        )
        # Not sure what to do here, exactly. Do I need to manipulate
        # the pathname?

    for name, value in attrs:
        if name == 'name' or tag == 'span' and name == 'id':
            if not value.startswith(self.node_begin_marker):
                if bwm_file: print &gt;&gt; bwm_file, "anchor(2):", value, self.p
                self.anchor_map[value] = (self.current_file, self.p.copy())
</t>
<t tx="ekr.20050805162550.53">class link_htmlparserClass (linkAnchorParserClass):

    '''This html parser does the second step of relocating links:
    1. It scans the html code for links.
    2. If there is a link which links to a previously processed file
       then this link is changed so that it now refers to the node.
    '''

    @others
</t>
<t tx="ekr.20050805162550.54">def __init__ (self,rst,p):

    super().__init__(rst)

    self.p = p.copy()
    self.anchor_map = rst.anchor_map
    self.replacements = []
</t>
<t tx="ekr.20050805162550.55">def handle_starttag(self, tag, attrs):
    '''
    1. Find out if the current tag is an achor.
    2. If the current tag is an anchor, update the mapping;
         anchor -&gt; p
        Update the list of replacements for the document.
    '''
    if bwm_file: print &gt;&gt; bwm_file, "Is link?", tag, attrs
    if not self.is_link(tag, attrs):
        return

    marker = self.node_begin_marker
    for name, value in attrs:
        if name == 'href':
            href = value
            href_parts = href.split("#")
            if len(href_parts) == 1:
                href_a = href_parts[0]
            else:
                href_a = href_parts[1]
            if bwm_file: print &gt;&gt; bwm_file, "link(1):", name, value, href_a
            if not href_a.startswith(marker):
                if href_a in self.anchor_map:
                    href_file, href_node = self.anchor_map[href_a]
                    http_node_ref = mod_http.node_reference(href_node)
                    line, column = self.getpos()
                    if bwm_file: print &gt;&gt; bwm_file, "link(2):", line, column, href, href_file, http_node_ref
                    self.replacements.append((line, column, href, href_file, http_node_ref))
</t>
<t tx="ekr.20050805162550.56">def get_replacements(self):

    return self.replacements
</t>
<t tx="ekr.20050805162550.6">def onCreate(tag, keywords):

    c = keywords.get('new_c') or keywords.get('c')
    if c:
        global controllers
        controllers[c] = rstClass(c)
        # Warning: Do not return anything but None here!
        # Doing so suppresses the loading of other 'new' or 'open2' hooks!
</t>
<t tx="ekr.20050805162550.8">class rstClass:

    '''A class to write rst markup in Leo outlines.'''

@ This plugin optionally stores information for the http plugin.

Each node can have one additional attribute, with the name rst_http_attributename, which is a list.

The first three elements are stack of tags, the rest is html code.

[&lt;tag n start&gt;, &lt;tag n end&gt;, &lt;other stack elements&gt;, &lt;html line 1&gt;, &lt;html line 2&gt;, ...]

&lt;other stack elements has the same structure:
    [&lt;tag n-1 start&gt;, &lt;tag n-1 end&gt;, &lt;other stack elements&gt;]
@c

    @others
</t>
<t tx="ekr.20050805162550.9"></t>
<t tx="ekr.20050806101253">def code_block (name,arguments,options,content,lineno,content_offset,block_text,state,state_machine):

    '''Implement the code-block directive for docutils.'''

    try:
        language = arguments [0]
        # See http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/252170
        module = SilverCity and getattr(SilverCity,language)
        generator = module and getattr(module,language+"HTMLGenerator")
        if generator:
            io = StringIO()
            generator().generate_html(io,'\n'.join(content))
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % io.getvalue()
        else:
            html = '&lt;div class="code-block"&gt;\n%s\n&lt;/div&gt;\n' % '&lt;br&gt;\n'.join(content)
        raw = docutils.nodes.raw('',html,format='html')
        return [raw]
    except Exception: # Return html as shown.  Lines are separated by &lt;br&gt; elements.
        g.es_trace('exception in rst3:code_block()')
        g.es_exception()
        return [None]

# See http://docutils.sourceforge.net/spec/howto/rst-directives.html
code_block.arguments = (
    1, # Number of required arguments.
    0, # Number of optional arguments.
    0) # True if final argument may contain whitespace.

# A mapping from option name to conversion function.
if docutils:
    code_block.options = {
        'language':
        docutils.parsers.rst.directives.unchanged # Return the text argument, unchanged.
    }
    code_block.content = 1 # True if content is allowed.

    # Register the directive with docutils.
    docutils.parsers.rst.directives.register_directive('code-block',code_block)
else:
    code_block.options = {}

</t>
<t tx="ekr.20050806162146">@nocolor
@

- Specify option for the spelling of special doc parts.
    - The present code assumes to much about these commands.
- Warn if option gets set twice in same vnode.

Later or never:
    - show_context option.
    - encoding option: can override @encoding directives
    - Support docutils config files.

@c

@others
</t>
<t tx="ekr.20050807120331.1">def preprocessTree (self,root):

    self.tnodeOptionDict = {}

    # Bug fix 12/4/05: must preprocess parents too.
    for p in root.parents():
        self.preprocessNode(p)

    for p in root.self_and_subtree():
        self.preprocessNode(p)

    if 0:
        g.trace(root.h)
        for key in self.tnodeOptionDict.keys():
            g.trace(key)
            g.printDict(self.tnodeOptionDict.get(key))
</t>
<t tx="ekr.20050807120331.2">def scanNodeForOptions (self,p):
    '''
    Return a dictionary containing all the option-name:value entries in p.

    Such entries may arise from @rst-option or @rst-options in the headline,
    or from @ @rst-options doc parts.
    '''
    d = self.scanHeadlineForOptions(p)
    d2 = self.scanForOptionDocParts(p,p.b)
    # A fine point: body options over-ride headline options.
    d.update(d2)
    return d
</t>
<t tx="ekr.20050808064245">def createDefaultOptionsDict(self):

    # Warning: changing the names of options changes the names of the corresponding ivars.

    self.defaultOptionsDict = {
        # Http options...
        'rst3_clear_http_attributes':   False,
        'rst3_http_server_support':     False,
        'rst3_http_attributename':      'rst_http_attribute',
        'rst3_node_begin_marker':       'http-node-marker-',
        # Path options...
        'rst3_default_path': None, # New in Leo 4.4a4 # Bug fix: must be None, not ''.
        'rst3_stylesheet_name': 'default.css',
        'rst3_stylesheet_path': None, # Bug fix: must be None, not ''.
        'rst3_publish_argv_for_missing_stylesheets': None,
        # Global options...
        'rst3_code_block_string': '',
        'rst3_number_code_lines': True,
        'rst3_underline_characters': '''#=+*^~"'`-:&gt;&lt;_''',
        'rst3_verbose':True,
        'rst3_write_intermediate_file': False, # Used only if generate_rst is True.
        # Mode options...
        'rst3_code_mode': False, # True: generate rst markup from @code and @doc parts.
        'rst3_doc_only_mode': False, # True: generate only from @doc parts.
        'rst3_generate_rst': True, # True: generate rst markup.  False: generate plain text.
        'rst3_generate_rst_header_comment': True,
            # True generate header comment (requires generate_rst option)
        # Formatting options that apply to both code and rst modes....
        'rst3_show_headlines': True,  # Can be set by @rst-no-head headlines.
        'rst3_show_organizer_nodes': True,
        'rst3_show_options_nodes': False,
        'rst3_show_sections': True,
        'rst3_strip_at_file_prefixes': True,
        'rst3_show_doc_parts_in_rst_mode': True,
        # Formatting options that apply only to code mode.
        'rst3_show_doc_parts_as_paragraphs': False,
        'rst3_show_leo_directives': True,
        'rst3_show_markup_doc_parts': False,
        'rst3_show_options_doc_parts': False,
        # *Names* of headline commands...
        'rst3_code_prefix':             '@rst-code',     # Enter code mode.
        'rst3_doc_only_prefix':         '@rst-doc-only', # Enter doc-only mode.
        'rst3_rst_prefix':              '@rst',          # Enter rst mode.
        'rst3_ignore_headline_prefix':  '@rst-no-head',
        'rst3_ignore_headlines_prefix': '@rst-no-headlines',
        'rst3_ignore_node_prefix':      '@rst-ignore-node',
        'rst3_ignore_prefix':           '@rst-ignore',
        'rst3_ignore_tree_prefix':      '@rst-ignore-tree',
        'rst3_option_prefix':           '@rst-option',
        'rst3_options_prefix':          '@rst-options',
        'rst3_preformat_prefix':        '@rst-preformat',
        'rst3_show_headline_prefix':    '@rst-head',
    }
</t>
<t tx="ekr.20050808070018">def scanOption (self,p,s):
    '''
    Return { name:val } if s is a line of the form name=val.
    Otherwise return {}
    '''
    if not s.strip() or s.strip().startswith('..'):
        return {}
    data = self.parseOptionLine(s)
    if data:
        name,val = data
        fullName = 'rst3_' + self.munge(name)
        if fullName in self.defaultOptionsDict.keys():
            if   val.lower() == 'true': val = True
            elif val.lower() == 'false': val = False
            return { self.munge(name): val }
        else:
            g.error('ignoring unknown option: %s' % (name))
            return {}
    else:
        g.trace(repr(s))
        g.error('bad rst3 option in %s: %s' % (p.h,s))
        return {}
</t>
<t tx="ekr.20050808070018.1">def scanOptions (self,p,s):

    '''Return a dictionary containing all the options in s.'''

    d = {}

    for line in g.splitLines(s):
        d2 = self.scanOption(p,line)
        if d2: d.update(d2)

    return d
</t>
<t tx="ekr.20050808070018.2">def scanForOptionDocParts (self,p,s):

    '''Return a dictionary containing all options from @rst-options doc parts in p.
    Multiple @rst-options doc parts are allowed: this code aggregates all options.
    '''

    d = {} ; n = 0 ; lines = g.splitLines(s)
    while n &lt; len(lines):
        line = lines[n] ; n += 1
        if line.startswith('@'):
            i = g.skip_ws(line,1)
            for kind in ('@rst-options','@rst-option'):
                if g.match_word(line,i,kind):
                    # Allow options on the same line.
                    line = line[i+len(kind):]
                    d.update(self.scanOption(p,line))
                    # Add options until the end of the doc part.
                    while n &lt; len(lines):
                        line = lines[n] ; n += 1 ; found = False
                        for stop in ('@c','@code', '@'):
                            if g.match_word(line,0,stop):
                                found = True ; break
                        if found:
                            break
                        else:
                            d.update(self.scanOption(p,line))
                    break
    return d
</t>
<t tx="ekr.20050808072943">def munge (self,name):

    '''Convert an option name to the equivalent ivar name.'''

    i = 3 if name.startswith('rst') else 0

    while i &lt; len(name) and name[i].isdigit():
        i += 1

    if i &lt; len(name) and name[i] == '_':
        i += 1

    s = name[i:].lower()
    s = s.replace('-','_')

    return s
</t>
<t tx="ekr.20050808072943.1">def parseOptionLine (self,s):
    '''
    Parse a line containing name=val and return (name,value) or None.
    If no value is found, default to True.
    '''
    s = s.strip()
    if s.endswith(','): s = s[:-1]
    # Get name.  Names may contain '-' and '_'.
    i = g.skip_id(s,0,chars='-_')
    name = s [:i]
    if not name:
        return None,'False'
    j = g.skip_ws(s,i)
    if g.match(s,j,'='):
        val = s [j+1:].strip()
        return name,val
    else:
        return name,'True'
</t>
<t tx="ekr.20050808142313.28"># Once an option is seen, no other related options in ancestor nodes have any effect.

def scanAllOptions(self,p):

    '''Scan position p and p's ancestors looking for options,
    setting corresponding ivars.
    '''

    self.initOptionsFromSettings()
        # Must be done on every node.
    self.handleSingleNodeOptions(p)
    seen = self.singleNodeOptions[:]
        # Suppress inheritance of single-node options.
    for p in p.self_and_parents():
        d = self.tnodeOptionDict.get(p.v,{})
        for key in d.keys():
            ivar = self.munge(key)
            if ivar not in seen:
                seen.append(ivar)
                val = d.get(key)
                self.setOption(key,val,p.h)
    # self.dumpSettings()
    if self.rst3_all:
        self.setOption("generate_rst", True, "rst3_all")
        self.setOption("generate_rst_header_comment",True, "rst3_all")
        self.setOption("http_server_support", True, "rst3_all")
        self.setOption("write_intermediate_file", True, "rst3_all")
</t>
<t tx="ekr.20050809074827"></t>
<t tx="ekr.20050809075309">def initWrite (self,p):

    self.initOptionsFromSettings() # Still needed.

    # Set the encoding from any parent @encoding directive.
    # This can be overridden by @rst-option encoding=whatever.
    c = self.c
    d = c.scanAllDirectives(p)
    self.encoding = d.get('encoding') or self.defaultEncoding
    self.path = d.get('path') or ''
</t>
<t tx="ekr.20050809080031">def write (self,s):

    s = self.encode(s)

    self.outputFile.write(s)
</t>
<t tx="ekr.20050809080925">def writeNormalTree (self,p,toString=False):

    self.initWrite(p)

    # Always write to a string first.
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.stringOutput = self.outputFile.getvalue()

    # Copy to a file if requested.
    if not toString:
        # Comput the output file name *after* calling writeTree.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)
        self.outputFile = open(self.outputFileName,'w')
        self.outputFile.write(self.stringOutput)
        self.outputFile.close()

    return True
</t>
<t tx="ekr.20050809082854"></t>
<t tx="ekr.20050809082854.1">def writeToDocutils (self,s):
    '''
    Send s to docutils using the writer implied by self.ext and return the
    result.
    '''
    # openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding }
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs()
    writer = None
    for ext,writer in (
        ('.html','html'),
        ('.htm','html'),
        ('.tex','latex'),
        ('.pdf','leo_pdf'),
    ):
        if self.ext == ext:
            break
    else:
        g.error('unknown docutils extension: %s' % (self.ext))
        return ''

    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption('stylesheet_path') or ''

    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        self.c.frame.openDirectory,rel_stylesheet_path)

    path = g.os_path_finalize_join(
        stylesheet_path,self.getOption('stylesheet_name'))

    res = ""
    if g.os_path_exists(path):
        if self.ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error('stylesheet not found: %s' % (path))
    else:
        g.error('stylesheet not found\n',path)
        if self.path:g.es_print('@path:', self.path)
        g.es_print('open path:',self.c.frame.openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        res = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer_name=writer,
                settings_overrides=overrides)
    except docutils.ApplicationError as error:
        g.es_print('Error (%s): %s' % (error.__class__.__name__, error))
    return res
</t>
<t tx="ekr.20050810083057">def writeNode (self,p):

    '''Format a node according to the options presently in effect.'''

    self.initCodeBlockString(p)
    self.scanAllOptions(p)

    if 0:
        g.trace('%24s code_mode %s' % (p.h,self.getOption('code_mode')))

    h = p.h.strip()

    if self.getOption('preformat_this_node'):
        self.http_addNodeMarker(p)
        self.writePreformat(p)
        p.moveToThreadNext()
    elif self.getOption('ignore_this_tree'):
        p.moveToNodeAfterTree()
    elif self.getOption('ignore_this_node'):
        p.moveToThreadNext()
    elif g.match_word(h,0,'@rst-options') and not self.getOption('show_options_nodes'):
        p.moveToThreadNext()
    else:
        self.http_addNodeMarker(p)
        self.writeHeadline(p)
        self.writeBody(p)
        p.moveToThreadNext()
</t>
<t tx="ekr.20050810083314"></t>
<t tx="ekr.20050810083856">def rstComment (self,s):

    return '.. %s' % s
</t>
<t tx="ekr.20050810103731">def handleSingleNodeOptions (self,p):

    '''Init the settings of single-node options from the tnodeOptionsDict.

    All such options default to False.'''

    d = self.tnodeOptionDict.get(p.v, {} )

    for ivar in self.singleNodeOptions:
        val = d.get(ivar,False)
        self.setOption(ivar,val,p.h)

</t>
<t tx="ekr.20050811101550.1">def writeBody (self,p):

    # remove trailing cruft and split into lines.
    lines = p.b.rstrip().split('\n')

    if self.getOption('code_mode'):
        if not self.getOption('show_options_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-options',
                retainContents=False)
        if not self.getOption('show_markup_doc_parts'):
            lines = self.handleSpecialDocParts(lines,'@rst-markup',
                retainContents=False)
        if not self.getOption('show_leo_directives'):
            lines = self.removeLeoDirectives(lines)
        lines = self.handleCodeMode(lines)
    elif self.getOption('doc_only_mode'):
        # New in version 1.15
        lines = self.handleDocOnlyMode(p,lines)
    else:
        lines = self.handleSpecialDocParts(lines,'@rst-options',
            retainContents=False)
        lines = self.handleSpecialDocParts(lines,'@rst-markup',
            retainContents=self.getOption('generate_rst'))
        if self.getOption('show_doc_parts_in_rst_mode') is True:
            pass  # original behaviour, treat as plain text
        elif self.getOption('show_doc_parts_in_rst_mode'):
            # use value as class for content
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=True, asClass=self.getOption('show_doc_parts_in_rst_mode'))
        else:  # option evaluates to false, cut them out
            lines = self.handleSpecialDocParts(lines,None,
                retainContents=False)
        lines = self.removeLeoDirectives(lines)
        if self.getOption('generate_rst') and self.getOption('use_alternate_code_block'):
            lines = self.replaceCodeBlockDirectives(lines)

    s = '\n'.join(lines).strip()
    if s:
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20050811102607">def skip_literal_block (self,lines,n):

    s = lines[n] ; result = [s] ; n += 1
    indent = g.skip_ws(s,0)

    # Skip lines until a non-blank line is found with same or less indent.
    while n &lt; len(lines):
        s = lines[n]
        indent2 = g.skip_ws(s,0)
        if s and not s.isspace() and indent2 &lt;= indent:
            break # We will rescan lines [n]
        n += 1
        result.append(s)

    # g.printList(result,tag='literal block')
    return n, result
</t>
<t tx="ekr.20050811105438">def removeLeoDirectives (self,lines):

    '''Remove all Leo directives, except within literal blocks.'''

    n = 0 ; result = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif s.startswith('@') and not self.isAnySpecialDocPart(s):
            for key in self.leoDirectivesList:
                if g.match_word(s,0,key):
                    break
            else:
                result.append(s)
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811105438.1">def handleSpecialDocParts (self,lines,kind,retainContents,asClass=None):

    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if s.strip().endswith('::'):
            n, lit = self.skip_literal_block(lines,n-1)
            result.extend(lit)
        elif self.isSpecialDocPart(s,kind):
            n, lines2 = self.getDocPart(lines,n)
            if retainContents:
                result.extend([''])
                if asClass:
                    result.extend(['.. container:: '+asClass, ''])
                    if 'literal' in asClass.split():
                        result.extend(['  ::', ''])
                    for l2 in lines2: result.append('    '+l2)
                else:
                    result.extend(lines2)
                result.extend([''])
        else:
            result.append(s)

    return result
</t>
<t tx="ekr.20050811135526">def setOption (self,name,val,tag):

    ivar = self.munge(name)
    self.optionsDict [ivar] = val
</t>
<t tx="ekr.20050811150541">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or
            (self.getOption('show_doc_parts_as_paragraphs') and self.isSpecialDocPart(s,None))
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []
    return self.rstripList(result)
</t>
<t tx="ekr.20050811152104">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20050811153208">def isSpecialDocPart (self,s,kind):

    '''Return True if s is a special doc part of the indicated kind.

    If kind is None, return True if s is any doc part.'''

    if s.startswith('@') and len(s) &gt; 1 and s[1].isspace():
        if kind:
            i = g.skip_ws(s,1)
            result = g.match_word(s,i,kind)
        else:
            result = True
    elif not kind:
        result = g.match_word(s,0,'@doc') or g.match_word(s,0,'@')
    else:
        result = False

    return result
</t>
<t tx="ekr.20050811154552">def getDocPart (self,lines,n):

    result = []
    &lt;&lt; Append whatever follows @doc or @space to result &gt;&gt;
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if g.match_word(s,0,'@code') or g.match_word(s,0,'@c'):
            break
        result.append(s)
    return n, result
</t>
<t tx="ekr.20050811163802">def isAnySpecialDocPart (self,s):

    for kind in (
        '@rst-markup',
        '@rst-option',
        '@rst-options',
    ):
        if self.isSpecialDocPart(s,kind):
            return True

    return False
</t>
<t tx="ekr.20050811173750">def scanHeadlineForOptions (self,p):

    '''Return a dictionary containing the options implied by p's headline.'''

    h = p.h.strip()

    if p == self.topNode:
        return {} # Don't mess with the root node.
    elif g.match_word(h,0,self.getOption('option_prefix')): # '@rst-option'
        s = h [len(self.option_prefix):]
        return self.scanOption(p,s)
    elif g.match_word(h,0,self.getOption('options_prefix')): # '@rst-options'
        return self.scanOptions(p,p.b)
    else:
        # Careful: can't use g.match_word because options may have '-' chars.
        i = g.skip_id(h,0,chars='@-')
        word = h[0:i]

        for prefix,ivar,val in (
            ('code_prefix','code_mode',True), # '@rst-code'
            ('doc_mode_prefix','doc_only_mode',True), # @rst-doc-only.
            ('default_path_prefix','default_prefix',''), # '@rst-default-path'
            ('rst_prefix','code_mode',False), # '@rst'
            ('ignore_headline_prefix','ignore_this_headline',True), # '@rst-no-head'
            ('show_headline_prefix','show_this_headline',True), # '@rst-head'
            ('ignore_headlines_prefix','show_headlines',False), # '@rst-no-headlines'
            ('ignore_prefix','ignore_this_tree',True),      # '@rst-ignore'
            ('ignore_node_prefix','ignore_this_node',True), # '@rst-ignore-node'
            ('ignore_tree_prefix','ignore_this_tree',True), # '@rst-ignore-tree'
            ('preformat_prefix','preformat_this_node',True), # '@rst-preformat
        ):
            prefix = self.getOption(prefix)
            if prefix and word == prefix: # Do _not_ munge this prefix!
                d = { ivar: val }
                if ivar != 'code_mode':
                    d ['code_mode'] = False # Enter rst mode.
                    d ['doc_only_mode'] = False
                # Special case: Treat a bare @rst like @rst-no-head
                if h == self.getOption('rst_prefix'):
                    d ['ignore_this_headline'] = True
                return d

        if h.startswith('@rst'):
            g.trace('word',word,'rst_prefix',self.getOption('rst_prefix'))
            g.trace('unknown kind of @rst headline',p.h)

        return {}
</t>
<t tx="ekr.20050812120933">def dumpSettings (self):

    d = self.optionsDict
    keys = list(d.keys())
    keys.sort()

    g.pr('present settings...')
    for key in keys:
        g.pr('%20s %s' % (key,d.get(key)))
</t>
<t tx="ekr.20050812122236"></t>
<t tx="ekr.20050813083007">def initHeadlineCommands (self):

    '''Init the list of headline commands used by writeHeadline.'''

    self.headlineCommands = [
        self.getOption('code_prefix'),
        self.getOption('doc_only_prefix'),
        self.getOption('default_path_prefix'),
        self.getOption('rst_prefix'),
        self.getOption('ignore_headline_prefix'),
        self.getOption('ignore_headlines_prefix'),
        self.getOption('ignore_node_prefix'),
        self.getOption('ignore_tree_prefix'),
        self.getOption('option_prefix'),
        self.getOption('options_prefix'),
        self.getOption('show_headline_prefix'),
        # # Suggested by Hemanth P.S.: prevent @file nodes from creating headings.
        # self.getOption('keep_at_file_prefix'),
        # self.getOption('strip_at_file_prefix'),
    ]
</t>
<t tx="ekr.20050813085236">def initSingleNodeOptions (self):

    self.singleNodeOptions = [
        'ignore_this_headline',
        'ignore_this_node',
        'ignore_this_tree',
        'preformat_this_node',
        'show_this_headline',
    ]
</t>
<t tx="ekr.20050813155021">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20050813160208">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20050814134351">def getOption (self,name):

    bwm = False
    if bwm:
        g.trace("bwm: getOption self:%s, name:%s, value:%s" % (
            self, name, self.optionsDict.get(name)))

    return self.optionsDict.get(name)
</t>
<t tx="ekr.20050815091008.1">def http_addNodeMarker (self,p):

    if (
        self.getOption('http_server_support') and
        self.getOption('generate_rst')
    ):
        self.nodeNumber += 1
        anchorname = "%s%s" % (self.getOption('node_begin_marker'),self.nodeNumber)
        s = "\n\n.. _%s:\n\n" % anchorname
        self.write(s)
        self.http_map [anchorname] = p.copy()
        if bwm_file: print &gt;&gt; bwm_file, "addNodeMarker", anchorname, p
</t>
<t tx="ekr.20050815164715">def is_node_marker (self,attrs):
    '''
    Return the name of the anchor, if this is an anchor for the beginning of a node,
    False otherwise.
    '''

    d = dict(attrs)
    result = 'id' in d and d['id'].startswith(self.node_begin_marker)
    if result:
        return d['id']
    return result
</t>
<t tx="ekr.20050815164715.1">if 0:
    g.pr("rst3: unknownAttributes[self.http_attributename]")
    g.pr("For:", self.last_position)
    pprint.pprint(mod_http.get_http_attribute(self.last_position))
</t>
<t tx="ekr.20050817132814">@nocolor-node

Important: the rst3 plugin has largely been superceded by similar
commands built into Leo's core.

To activate the rst3 plugin, do the following:

1. Go to http://silvercity.sourceforge.net/.
- Follow the link 'SilverCity Releases'.
- Download the release that fits to your Python version.
- Double-klick on the downloaded file.

2. Go to http://docutils.sourceforge.net/.
- Have a look for item 'Download'
- Get, as the editor says, the latest snapshot by following the link
  'docutils-snapshot.tgz'.
- Make sure you have a application that can handle this format. 7zip is doing this great.
- Unpack it to a temporary folder.
- Open a console window, go to the temporary folder and type 'setup.py install'
  or '&lt;path_to_python.exe&gt;\python setup.py install'.

3. Start up Leo
- Check in the menu 'Edit' for item 'Write-Restructured-Text'.
</t>
<t tx="ekr.20050920093543">def finishCreate(self):
    """
    Finish creating the commander and all sub-objects.
    This is the last step in the startup process.
    """
    c, k = self, self.k
    assert c.gui
    assert k
    c.frame.finishCreate()
    c.miniBufferWidget = c.frame.miniBufferWidget
        # Will be None for nullGui.
    # Only c.abbrevCommands needs a finishCreate method.
    c.abbrevCommands.finishCreate()
    # Finish other objects...
    c.createCommandNames()
    k.finishCreate()
    c.findCommands.finishCreate()
    if not c.gui.isNullGui:
        g.registerHandler('idle', c.idle_focus_helper)
    if getattr(c.frame, 'menu', None):
        c.frame.menu.finishCreate()
    if getattr(c.frame, 'log', None):
        c.frame.log.finishCreate()
    c.undoer.clearUndoState()
    if c.vimCommands and c.vim_mode:
        c.vimCommands.finishCreate()
        # Menus must exist at this point.
    # Do not call chapterController.finishCreate here:
    # It must be called after the first real redraw.
    g.check_cmd_instance_dict(c, g)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20051007143620">def printCommandsDict(self):
    c = self
    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print(f"{key:30} = {command.__name__ if command else '&lt;None&gt;'}")
    print('')
</t>
<t tx="ekr.20051022044950">def computeOldStyleShortcutKey(self, s):
    """Compute the old-style shortcut key for @shortcuts entries."""
    # #1121: Allow Chinese characters in command names
    return s.strip()
</t>
<t tx="ekr.20051031040240">@nosearch</t>
<t tx="ekr.20051121102358">def processTopTree (self,p,justOneFile=False):

    current = p.copy()
    for p in current.self_and_parents():
        h = p.h
        if h.startswith('@rst') and not h.startswith('@rst-'):
            self.processTree(p,
                ext=None,
                toString=False,
                justOneFile=justOneFile,
            )
            break
    else:
        self.processTree(current,
            ext=None,
            toString=False,
            justOneFile=justOneFile,
        )
    g.blue('done')
</t>
<t tx="ekr.20051202070028">def computeOutputFileName (self,fileName):

    openDirectory = self.c.frame.openDirectory
    default_path = self.getOption('default_path')
    if default_path:
        path = g.os_path_finalize_join(self.path,default_path,fileName)
    elif self.path:
        path = g.os_path_finalize_join(self.path,fileName)
    elif openDirectory:
        path = g.os_path_finalize_join(self.path,openDirectory,fileName)
    else:
        path = g.os_path_finalize_join(fileName)

    return path
</t>
<t tx="ekr.20051204070141">def preprocessNode (self,p):

    d = self.tnodeOptionDict.get(p.v)
    if d is None:
        d = self.scanNodeForOptions(p)
        self.tnodeOptionDict [p.v] = d
</t>
<t tx="ekr.20060525102337">def writeNodeToString (self,p=None,ext=None):
    '''
    Scan p's tree (defaults to presently selected tree) looking for @rst nodes.
    Convert the first node found to an ouput of the type specified by ext.

    The @rst may or may not be followed by a filename; the filename is *ignored*,
    and its type does not affect ext or the output generated in any way.

    ext should start with a period:  .html, .tex or None (specifies rst output).

    Returns p, s, where p is the position of the @rst node and s is the converted text.
    '''
    c = self.c
    current = p or c.p
    for p in current.self_and_parents():
        if p.h.startswith('@rst'):
            return self.processTree(p,ext=ext,toString=True,justOneFile=True)
    return self.processTree(current,ext=ext,toString=True,justOneFile=True)
</t>
<t tx="ekr.20060608094815">def handleDocOnlyMode (self,p,lines):
    '''
    Handle the preprocessed body text in doc_only mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - All doc parts get copied.
    - All code parts are ignored.
    '''
    # ignore            = self.getOption('ignore_this_headline')
    showHeadlines       = self.getOption('show_headlines')
    showThisHeadline    = self.getOption('show_this_headline')
    showOrganizers      = self.getOption('show_organizer_nodes')
    result = [] ; n = 0
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if self.isSpecialDocPart(s,'@rst-options'):
            n, lines2 = self.getDocPart(lines,n) # ignore.
        elif self.isAnyDocPart(s):
            # Handle any other doc part, including @rst-markup.
            n, lines2 = self.getDocPart(lines,n)
            if lines2: result.extend(lines2)
    if not result: result = []
    if showHeadlines:
        if result or showThisHeadline or showOrganizers or p == self.topNode:
            self.writeHeadlineHelper(p)
    return result
</t>
<t tx="ekr.20060608094815.1">def isAnyDocPart (self,s):

    if s.startswith('@doc'):
        return True
    elif not s.startswith('@'):
        return False
    else:
        return len(s) == 1 or s[1].isspace()
</t>
<t tx="ekr.20060608102001">def writeHeadlineHelper (self,p):

    h = p.h.strip()

    # Remove any headline command before writing the
    i = g.skip_id(h,0,chars='@-')
    word = h [:i]
    if word:
        # Never generate a section for @rst-option or @rst-options.
        if word in (self.getOption('option_prefix'),self.getOption('options_prefix')):
            return
        # Remove all other headline commands from the headline.
        for prefix in self.headlineCommands:
            if word == prefix:
                h = h [len(word):].strip()
                break

        # New in Leo 4.4.4.
        if word.startswith('@'):
            if self.getOption('strip_at_file_prefixes'):
                for s in ('@auto','@file','@nosent','@thin',):
                    if g.match_word(word,0,s):
                        h = h [len(s):].strip()

    if not h.strip(): return

    if self.getOption('show_sections'):
        if self.getOption('generate_rst'):
            self.write('%s\n%s\n' % (h,self.underline(h,p)))
        else:
            self.write('\n%s\n' % h)
    else:
        self.write('\n**%s**\n\n' % h.replace('*',''))
</t>
<t tx="ekr.20060610104435">if n &gt; 0:
    line = lines[n-1]
    if line.startswith('@doc'):
        s = line[4:].lstrip()
    elif line.startswith('@'):
        s = line[1:].lstrip()
    else:
        s = ''

    # New in Leo 4.4.4: remove these special tags.
    for tag in ('@rst-options','@rst-option','@rst-markup'):
        if g.match_word(s,0,tag):
            s = s[len(tag):].strip()

    if s.strip():
        result.append(s)
</t>
<t tx="ekr.20060928062431">@g.commander_command('expand-ancestors-only')
def expandOnlyAncestorsOfNode(self, event=None, p=None):
    """Contract all nodes in the outline."""
    c = self
    level = 1
    if p: c.selectPosition(p)  # 2013/12/25
    root = c.p
    for p in c.all_unique_positions():
        p.v.expandedPositions = []
        p.v.contract()
    for p in root.parents():
        p.expand()
        level += 1
    c.expansionLevel = level  # Reset expansion level.
</t>
<t tx="ekr.20071015110830">def initCodeBlockString(self,p):

    # New in Leo 4.4.4: do this here, not in initWrite:
    c = self.c
    d = c.scanAllDirectives(p)
    language = d.get('language')
    if language is None:
        language = 'python'
    else:
        language = language.lower()
    syntax = SilverCity is not None
    s = self.getOption('code_block_string')
    if s:
        self.code_block_string = s.replace('\\n','\n')
    elif syntax and language in ('python','ruby','perl','c'):
        self.code_block_string = '**code**:\n\n.. code-block:: %s\n' % language.title()
    else:
        self.code_block_string = '**code**:\n\n.. class:: code\n..\n\n::\n'
</t>
<t tx="ekr.20071113084440"># These plugins are for testing Leo's own plugin loading logic.
# There is no reason ever to enable these plugins.</t>
<t tx="ekr.20071115061253">def writePreformat (self,p):

    '''Write p's body text lines as if preformatted.

     ::

        line 1
        line 2 etc.
    '''
    lines = p.b.split('\n')
    lines = [' '*4 + z for z in lines]
    lines.insert(0,'::\n')
    s = '\n'.join(lines)
    if s.strip():
        self.write('%s\n\n' % s)
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    """
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    """
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s or '')  # #1466.
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace(f"can not happen: encoding mismatch: {at.encoding} {self.encoding}")
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace(f"\nprivate lines...{old_private_file}")
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace(f"\npublic lines...{old_public_file}")
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(
    self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    """Init all ivars used by propagate_changed_lines &amp; its helpers."""
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = f"{x.delim1}@verbatim{x.delim2}\n"
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20081005065934.1">def initAfterLoad(self):
    """Provide an offical hook for late inits of the commander."""
    pass
</t>
<t tx="ekr.20090110073010.1">@cmd('redraw')
def redraw_command(self, event):
    c = event.get('c')
    if c:
        c.redraw()

def redraw(self, p=None):
    """Redraw the screen immediately."""
    c = self
    # New in Leo 5.6: clear the redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.p or c.rootPosition()
    if not p:
        return
    c.expandAllAncestors(p)
    if p:
        # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1183855
        # This looks redundant, but it is probably the only safe fix.
        c.frame.tree.select(p)
    # tree.redraw will change the position if p is a hoisted @chapter node.
    p2 = c.frame.tree.redraw(p)
    # Be careful.  NullTree.redraw returns None.
    # #503: NullTree.redraw(p) now returns p.
    c.selectPosition(p2 or p)
    # Do not call treeFocusHelper here.
        # c.treeFocusHelper()
    # Clear the redraw request, again.
    c.requestLaterRedraw = False

# Compatibility with old scripts

force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090213065933.6">def initConfigSettings(self):
    """Init all cached commander config settings."""
    c = self
    getBool = c.config.getBool
    getColor = c.config.getColor
    getData = c.config.getData
    getInt = c.config.getInt
    c.autoindent_in_nocolor = getBool('autoindent-in-nocolor-mode')
    c.collapse_nodes_after_move = getBool('collapse-nodes-after-move')
    c.collapse_on_lt_arrow = getBool('collapse-on-lt-arrow', default=True)
    c.contractVisitedNodes = getBool('contractVisitedNodes')
    c.fixedWindowPositionData = getData('fixedWindowPosition')
    c.focus_border_color = getColor('focus-border-color') or 'red'
    c.focus_border_command_state_color = getColor(
        'focus-border-command-state-color') or 'blue'
    c.focus_border_overwrite_state_color = getColor(
        'focus-border-overwrite-state-color') or 'green'
    c.focus_border_width = getInt('focus-border-width') or 1  # pixels
    c.forceExecuteEntireBody = getBool('force-execute-entire-body', default=False)
    c.make_node_conflicts_node = getBool('make-node-conflicts-node', default=True)
    c.outlineHasInitialFocus = getBool('outline-pane-has-initial-focus')
    c.page_width = getInt('page-width') or 132
    # c.putBitsFlag = getBool('put-expansion-bits-in-leo-files', default=True)
    c.sparse_move = getBool('sparse-move-outline-left')
    c.sparse_find = getBool('collapse-nodes-during-finds')
    c.sparce_spell = getBool('collapse-nodes-while-spelling')
    c.stayInTreeAfterSelect = getBool('stayInTreeAfterSelect')
    c.smart_tab = getBool('smart-tab')
    c.tab_width = getInt('tab-width') or -4
    c.verbose_check_outline = getBool('verbose-check-outline', default=False)
    c.vim_mode = getBool('vim-mode', default=False)
    c.write_script_file = getBool('write-script-file')
</t>
<t tx="ekr.20090213065933.7">def setWindowPosition(self):
    c = self
    if c.fixedWindowPositionData:
        try:
            aList = [z.strip() for z in c.fixedWindowPositionData if z.strip()]
            w, h, l, t = aList
            c.fixedWindowPosition = int(w), int(h), int(l), int(t)
        except Exception:
            g.error('bad @data fixedWindowPosition',
                repr(self.fixedWindowPosition))
    else:
        c.windowPosition = 500, 700, 50, 50  # width,height,left,top.
</t>
<t tx="ekr.20090428082801.64">def handleMissingStyleSheetArgs (self,s=None):

    '''Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.'''

    d = {}
    if not s:
        s = self.getOption('publish_argv_for_missing_stylesheets')
    if not s: return d

    args = s.strip()
    if args.find(',') == -1:
        args = [args]
    else:
        args = args.split(',')

    for arg in args:
        data = arg.split('=')
        if len(data) == 1:
            key = data[0]
            d[str(key)] = ""
        elif len(data) == 2:
            key,value = data
            d[str(key)] = str(value)
        else:
            g.error('bad option: %s' % s)
            break

    return d
</t>
<t tx="ekr.20090429055156.63">def runUnitTests(c):

    rstClass(c)
    p = g.findNodeAnywhere(c,'UnitTests')
    if p:
        c.selectPosition(p)
        c.testManager.doTests(all=None, marked=None, verbosity=1)
</t>
<t tx="ekr.20090514111518.5661">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False):
    """Perform python-related checks on root."""
    at = self
    if contents and fileName and fileName.endswith(
        '.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        body = body.replace('\r', '')
        fn = f"&lt;node: {p.h}&gt;"
        compile(body + '\n', fn, 'exec')
        return True
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
    return False
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("ParserError in", p.h)
        g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("IndentationError in", p.h)
        g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        g.error("TokenError in", p.h)
        g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        badline = nag.get_lineno()
        line = nag.get_line()
        message = nag.get_msg()
        g.error("indentation error in", p.h, "line", badline)
        g.es(message)
        line2 = repr(str(line))[1:-1]
        g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self, p, body):
    """Report a syntax error."""
    g.error(f"Syntax error in: {p.h}")
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = f"{p.get_UNL(with_proto=True, with_count=True)},-{j+1:d}"
        else:
            mark = ' '
            node_link = None
        text = f"{j+1:5}:{mark} {lines[j].rstrip()}"
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20100103093121.5365"># These are experimental plugins.
</t>
<t tx="ekr.20101004082701.5674"></t>
<t tx="ekr.20101110150056.9453"># Some of the most important recent plugins work only with the Qt gui.
</t>
<t tx="ekr.20101110150056.9457"></t>
<t tx="ekr.20110509064011.14563">idle_focus_count = 0

def idle_focus_helper(self, tag, keys):
    """An idle-tme handler that ensures that focus is *somewhere*."""
    trace = 'focus' in g.app.debug
    trace_inactive_focus = False  # Too disruptive for --trace-focus
    trace_in_dialog = False  # Not useful enough for --trace-focus
    c = self
    assert tag == 'idle'
    if g.app.unitTesting:
        return
    if keys.get('c') != c:
        if trace: g.trace('no c')
        return
    self.idle_focus_count += 1
    if c.in_qt_dialog:
        if trace and trace_in_dialog: g.trace('in_qt_dialog')
        return
    w = g.app.gui.get_focus(at_idle=True)
    if g.app.gui.active:
        # Always call trace_idle_focus.
        self.trace_idle_focus(w)
        if w and self.is_unusual_focus(w):
            if trace:
                w_class = w and w.__class__.__name__
                g.trace('***** unusual focus', w_class)
            # Fix bug 270: Leo's keyboard events doesn't work after "Insert"
            # on headline and Alt+Tab, Alt+Tab
            # Presumably, intricate details of Qt event handling are involved.
            # The focus was in the tree, so put the focus back in the tree.
            c.treeWantsFocusNow()
        # elif not w and active:
            # c.bodyWantsFocusNow()
    elif trace and trace_inactive_focus:
        w_class = w and w.__class__.__name__
        count = c.idle_focus_count
        g.trace(f"{count} inactive focus: {w_class}")
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17896">def onItemClicked(self, item, col, auto_edit=False):
    """Handle a click in a BaseNativeTree widget item."""
    # This is called after an item is selected.
    if self.busy:
        return
    c = self.c
    try:
        self.busy = True
        p = self.item2position(item)
        if p:
            auto_edit = self.prev_v == p.v
                # Fix #1049.
            self.prev_v = p.v
            event = None
            #
            # Careful. We may have switched gui during unit testing.
            if hasattr(g.app.gui, 'qtApp'):
                mods = g.app.gui.qtApp.keyboardModifiers()
                isCtrl = bool(mods &amp; QtConst.ControlModifier)
                # We could also add support for QtConst.ShiftModifier, QtConst.AltModifier
                # &amp; QtConst.MetaModifier.
                if isCtrl:
                    if g.doHook("iconctrlclick1", c=c, p=p, event=event) is None:
                        c.frame.tree.OnIconCtrlClick(p)
                            # Call the base class method.
                    g.doHook("iconctrlclick2", c=c, p=p, event=event)
                else:
                    # 2014/02/21: generate headclick1/2 instead of iconclick1/2
                    g.doHook("headclick1", c=c, p=p, event=event)
                    g.doHook("headclick2", c=c, p=p, event=event)
        else:
            auto_edit = None
            g.trace('*** no p')
        # 2011/05/27: click here is like ctrl-g.
        c.k.keyboardQuit(setFocus=False)
        c.treeWantsFocus()  # 2011/05/08: Focus must stay in the tree!
        c.outerUpdate()
        # 2011/06/01: A second *single* click on a selected node
        # enters editing state.
        if auto_edit and self.auto_edit:
            e, wrapper = self.createTreeEditorForItem(item)
        # 2014/10/26: Reset find vars.
        c.findCommands.reset_state_ivars()
    finally:
        self.busy = False
</t>
<t tx="ekr.20110605121601.17965">def splitter_menu(self, pos):
    """build the context menu for NestedSplitter"""
    splitter = self.splitter()
    if not splitter.enabled:
        g.trace('splitter not enabled')
        return
    index = splitter.indexOf(self)
    # get three pairs
    widget, neighbour, count = splitter.handle_context(index)
    lr = 'Left', 'Right'
    ab = 'Above', 'Below'
    split_dir = 'Vertically'
    if self.orientation() == QtCore.Qt.Vertical:
        lr, ab = ab, lr
        split_dir = 'Horizontally'
    # blue/orange - color-blind friendly
    color = '#729fcf', '#f57900'
    sheet = []
    for i in 0, 1:
        sheet.append(widget[i].styleSheet())
        widget[i].setStyleSheet(sheet[-1] + f"\nborder: 2px solid {color[i]};")
    menu = QtWidgets.QMenu()
    menu.hovered.connect(self.show_tip)

    def pl(n):
        return 's' if n &gt; 1 else ''

    def di(s):
        return {
            'Above': 'above',
            'Below': 'below',
            'Left': 'left of',
            'Right': 'right of',
        }[s]

    # Insert.

    def insert_callback(index=index):
        splitter.insert(index)

    self.add_item(insert_callback, menu, 'Insert',
        "Insert an empty pane here")
    # Remove, +0/-1 reversed, we need to test the one that remains
    # First see if a parent has more than two splits
    # (we could be a sole surviving child).
    max_parent_splits = 0
    up = splitter.parent()
    while isinstance(up, NestedSplitter):
        max_parent_splits = max(max_parent_splits, up.count())
        up = up.parent()
        if max_parent_splits &gt;= 2:
            break  # two is enough
    for i in 0, 1:
        # keep = splitter.widget(index)
        # cull = splitter.widget(index - 1)
        if (max_parent_splits &gt;= 2 or  # more splits upstream
            splitter.count() &gt; 2 or  # 3+ splits here, or 2+ downstream
            neighbour[not i] and neighbour[not i].max_count() &gt;= 2
        ):

            def remove_callback(i=i, index=index):
                splitter.remove(index, i)

            self.add_item(remove_callback, menu,
                f"Remove {count[i]:d} {lr[i]}",
                f"Remove the {count[i]} pane{pl(count[i])} {di(lr[i])} here")
    # Swap.

    def swap_callback(index=index):
        splitter.swap(index)

    self.add_item(swap_callback, menu,
        f"Swap {count[0]:d} {lr[0]} {count[1]:d} {lr[1]}",
        f"Swap the {count[0]:d} pane{pl(count[0])} {di(lr[0])} here "
        f"with the {count[1]:d} pane{pl(count[1])} {di(lr[1])} here"
        )
    # Split: only if not already split.
    for i in 0, 1:
        if not neighbour[i] or neighbour[i].count() == 1:

            def split_callback(i=i, index=index, splitter=splitter):
                splitter.split(index, i)

            self.add_item(
                split_callback, menu, f"Split {lr[i]} {split_dir}")
    for i in 0, 1:

        def mark_callback(i=i, index=index):
            splitter.mark(index, i)

        self.add_item(mark_callback, menu, f"Mark {count[i]:d} {lr[i]}")
    # Swap With Marked.
    if splitter.root.marked:
        for i in 0, 1:
            if not splitter.invalid_swap(widget[i], splitter.root.marked[2]):

                def swap_mark_callback(i=i, index=index, splitter=splitter):
                    splitter.swap_with_marked(index, i)

                self.add_item(swap_mark_callback, menu,
                    f"Swap {count[i]:d} {lr[i]} With Marked")
    # Add.
    for i in 0, 1:
        if (
            not isinstance(splitter.parent(), NestedSplitter) or
            splitter.parent().indexOf(splitter) ==
                [0, splitter.parent().count() - 1][i]
        ):

            def add_callback(i=i, splitter=splitter):
                splitter.add(i)

            self.add_item(add_callback, menu, f"Add {ab[i]}")
    # Rotate All.
    self.add_item(splitter.rotate, menu, 'Toggle split direction')

    def rotate_only_this(index=index):
        splitter.rotateOne(index)

    self.add_item(rotate_only_this, menu, 'Toggle split/dir. just this')
    # equalize panes

    def eq(splitter=splitter.top()):
        splitter.equalize_sizes(recurse=True)

    self.add_item(eq, menu, 'Equalize all')
    # (un)zoom pane

    def zoom(splitter=splitter.top()):
        splitter.zoom_toggle()

    self.add_item(
        zoom,
        menu,
        ('Un' if splitter.root.zoomed else '') + 'Zoom pane'
    )
    # open window
    if splitter.top().parent().__class__ != NestedSplitterTopLevel:
        # don't open windows from windows, only from main splitter
        # so owner is not a window which might close.  Could instead
        # set owner to main splitter explicitly.  Not sure how right now.
        submenu = menu.addMenu('Open window')
        if 1:
            # pylint: disable=unnecessary-lambda
            self.add_item(lambda: splitter.open_window(), submenu, "Empty")
        # adapted from choice_menu()
        if (splitter.root.marked and
            splitter.top().max_count() &gt; 1
        ):
            self.add_item(
                lambda: splitter.open_window(action="_move_marked_there"),
                submenu, "Move marked there")
        for provider in splitter.root.providers:
            if hasattr(provider, 'ns_provides'):
                for title, id_ in provider.ns_provides():

                    def cb(id_=id_):
                        splitter.open_window(action=id_)

                    self.add_item(cb, submenu, title)
    submenu = menu.addMenu('Debug')
    act = QtWidgets.QAction("Print splitter layout", self)

    def print_layout_c(checked, splitter=splitter):
        layout = splitter.top().get_layout()
        g.printObj(layout)

    act.triggered.connect(print_layout_c)
    submenu.addAction(act)

    def load_items(menu, items):
        for i in items:
            if isinstance(i, dict):
                for k in i:
                    load_items(menu.addMenu(k), i[k])
            else:
                title, id_ = i

                def cb(checked, id_=id_):
                    splitter.context_cb(id_, index)

                act = QtWidgets.QAction(title, self)
                act.triggered.connect(cb)
                menu.addAction(act)

    for provider in splitter.root.providers:
        if hasattr(provider, 'ns_context'):
            load_items(menu, provider.ns_context())
    menu.exec_(self.mapToGlobal(pos))
    for i in 0, 1:
        widget[i].setStyleSheet(sheet[i])
</t>
<t tx="ekr.20110605121601.17967">def __init__(self, parent=None, orientation=QtCore.Qt.Horizontal, root=None):
    """Ctor for NestedSplitter class."""
    super().__init__(orientation, parent)
        # This creates a NestedSplitterHandle.
    if root is None:
        root = self.top(local=True)
        if root == self:
            root.marked = None  # Tuple: self,index,side-1,widget
            root.providers = []
            root.holders = {}
            root.windows = []
            root._main = self.parent()  # holder of the main splitter
            # list of top level NestedSplitter windows opened from 'Open Window'
            # splitter handle context menu
            root.zoomed = False
        #
        # NestedSplitter is a kind of meta-widget, in that it manages
        # panes across multiple actual splitters, even windows.
        # So to create a signal for a click on splitter handle, we
        # need to propagate the .connect() call across all the
        # actual splitters, current and future
        root._splitterClickedArgs = []  # save for future added splitters
    for args in root._splitterClickedArgs:
        # apply any .connect() calls that occured earlier
        self._splitterClickedSignal.connect(*args)

    self.root = root
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:


    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        """A subclass of QTextBrowser that overrides the mouse event handlers."""
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    """ctor for LeoQTextBrowser class."""
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = ''  # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    super().__init__(parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0:  # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # #1286
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.onContextMenu)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return f"(LeoQTextBrowser) {id(self)}"

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    """ctor for LeoQListWidget class"""
    super().__init__()
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False  # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    """Kill completion and close the window."""
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    """End completion."""
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    """Handle a key event from QListWidget."""
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    """Called when user selects an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged()
        w.setInsertPoint(j)
        c.frame.body.onBodyChanged('Typing')
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    """Set the position of the QListWidget."""

    def glob(obj, pt):
        """Convert pt from obj's local coordinates to global coordinates."""
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry()  # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace(
                    f"Error: geom.topLeft: {geom2.topLeft()}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace(
                    f"Error 2: geom.topLeft: {glob(vp, geom2.topLeft())}, "
                    f"geom2.topLeft: {glob(w, r.topLeft())}")
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    """Set the QListView contents to aList."""
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    """Connect a QCompleter."""
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = f"unknown: {repr(button)}"
    return kind
</t>
<t tx="ekr.20110605121601.18106">def set_config(self):
    """Set QScintillaWrapper configuration options."""
    c, w = self.c, self.widget
    n = c.config.getInt('qt-scintilla-zoom-in')
    if n not in (None, 1, 0):
        w.zoomIn(n)
    w.setUtf8(True)  # Important.
    if 1:
        w.setBraceMatching(2)  # Sloppy
    else:
        w.setBraceMatching(0)  # wrapper.flashCharacter creates big problems.
    if 0:
        w.setMarginWidth(1, 40)
        w.setMarginLineNumbers(1, True)
    w.setIndentationWidth(4)
    w.setIndentationsUseTabs(False)
    w.setAutoIndent(True)
</t>
<t tx="ekr.20110605121601.18175">def set_style_sheets(self, all=True, top=None, w=None):
    """Set the master style sheet for all widgets using config settings."""
    if g.app.loadedThemes:
        return
    c = self.c
    if top is None: top = c.frame.top
    selectors = ['qt-gui-plugin-style-sheet']
    if all:
        selectors.append('qt-gui-user-style-sheet')
    sheets = []
    for name in selectors:
        sheet = c.config.getData(name, strip_comments=False)
            # don't strip `#selector_name { ...` type syntax
        if sheet:
            if '\n' in sheet[0]:
                sheet = ''.join(sheet)
            else:
                sheet = '\n'.join(sheet)
        if sheet and sheet.strip():
            line0 = f"\n/* ===== From {name} ===== */\n\n"
            sheet = line0 + sheet
            sheets.append(sheet)
    if sheets:
        sheet = "\n".join(sheets)
        # store *before* expanding, so later expansions get new zoom
        c.active_stylesheet = sheet
        sheet = self.expand_css_constants(sheet)
        if not sheet: sheet = self.default_style_sheet()
        if w is None:
            w = self.get_master_widget(top)
        w.setStyleSheet(sheet)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    """Get the vertical scrollbar position."""
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    """Set the position of the vertical scrollbar."""
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20120110174009.9965">def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if Leo should warn the user that p is an @&lt;file&gt; node that
    was not read during startup. Writing that file might cause data loss.
    
    See #50: https://github.com/leo-editor/leo-editor/issues/50
    '''
    trace = 'save' in g.app.debug
    sfn = g.shortFileName(fn)
    c = self.c
    efc = g.app.externalFilesController
    if p.isAtNoSentFileNode():
        # #1450.
        # No danger of overwriting a file.
        # It was never read.
        return False
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        if trace: g.trace('Return False: does not exist:', sfn)
        return False
    # #1347: Prompt if the external file is newer.
    if efc:
        # Like c.checkFileTimeStamp.
        if c.sqlite_connection and c.mFileName == fn:
            # sqlite database file is never actually overwriten by Leo,
            # so do *not* check its timestamp.
            pass
        elif efc.has_changed(c, fn):
            if trace: g.trace('Return True: changed:', sfn)
            return True
    if hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        for k in d:
            # Fix bug # #1469: make sure k still exists.
            if (
                os.path.exists(k) and os.path.samefile(k, fn)
                and p.h in d.get(k, set())
            ):
                d[fn] = d[k]
                if trace: g.trace('Return False: in p.v.at_read:', sfn)
                return False
        aSet = d.get(fn, set())
        if trace:
            g.trace(f"Return {p.h not in aSet()}: p.h not in aSet(): {sfn}")
        return p.h not in aSet
    if trace:
        g.trace('Return True: never read:', sfn)
    return True  # The file was never read.
</t>
<t tx="ekr.20120112084820.10001">def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@&lt;file&gt; type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
</t>
<t tx="ekr.20120217070122.10466">def initDebugIvars(self):
    """Init Commander debugging ivars."""
    self.command_count = 0
    self.scanAtPathDirectivesCount = 0
    self.trace_focus_count = 0
</t>
<t tx="ekr.20120217070122.10467">def initEventIvars(self):
    """Init ivars relating to gui events."""
    self.configInited = False
    self.doubleClickFlag = False
    self.exists = True
        # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    self.in_qt_dialog = False
        # True: in a qt dialog.
    self.loading = False
        # True: we are loading a file: disables c.setChanged()
    self.promptingForClose = False
        # True: lock out additional closing dialogs.
    self.suppressHeadChanged = False
        # True: prevent setting c.changed when switching chapters.
    # Flags for c.outerUpdate...
    self.enableRedrawFlag = True
    self.requestCloseWindow = False
    self.requestedFocusWidget = None
    self.requestLaterRedraw = False
</t>
<t tx="ekr.20120217070122.10468">def initObjectIvars(self):
    # These ivars are set later by leoEditCommands.createEditCommanders
    self.abbrevCommands = None
    self.editCommands = None
    self.db = {}  # May be set to a PickleShare instance later.
    self.bufferCommands = None
    self.chapterCommands = None
    self.controlCommands = None
    self.convertCommands = None
    self.debugCommands = None
    self.editFileCommands = None
    self.evalController = None
    self.gotoCommands = None
    self.helpCommands = None
    self.keyHandler = self.k = None
    self.keyHandlerCommands = None
    self.killBufferCommands = None
    self.leoCommands = None
    self.macroCommands = None
    self.miniBufferWidget = None
    self.printingController = None
    self.queryReplaceCommands = None
    self.rectangleCommands = None
    self.searchCommands = None
    self.spellCommands = None
    self.leoTestManager = None
    self.vimCommands = None
</t>
<t tx="ekr.20120217070122.10469">def initOptionsIvars(self):
    """Init Commander ivars corresponding to user options."""
    self.fixed = False
    self.fixedWindowPosition = []
    self.forceExecuteEntireBody = False
    self.focus_border_color = 'white'
    self.focus_border_width = 1  # pixels
    self.outlineHasInitialFocus = False
    self.page_width = 132
    self.sparse_find = True
    self.sparse_move = True
    self.sparse_spell = True
    self.stayInTreeAfterSelect = False
    self.tab_width = -4
    self.tangle_batch_flag = False
    self.target_language = "python"
    self.untangle_batch_flag = False
    # self.use_body_focus_border = True
    # self.use_focus_border = False
        # Replaced by style-sheet entries.
    self.vim_mode = False
</t>
<t tx="ekr.20120217070122.10470">@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = '&lt;hidden root vnode&gt;'
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.bufferCommands as bufferCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoMarkup as leoMarkup
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.markupCommands         = leoMarkup.MarkupCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.bufferCommands     = bufferCommands.BufferCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.bufferCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
</t>
<t tx="ekr.20120217070122.10471">def initDocumentIvars(self):
    """Init per-document ivars."""
    self.expansionLevel = 0
        # The expansion level of this outline.
    self.expansionNode = None
        # The last node we expanded or contracted.
    self.nodeConflictList = []
        # List of nodes with conflicting read-time data.
    self.nodeConflictFileName = None
        # The fileName for c.nodeConflictList.
    self.user_dict = {}
        # Non-persistent dictionary for free use by scripts and plugins.
</t>
<t tx="ekr.20120217070122.10472">def initFileIvars(self, fileName, relativeFileName):
    """Init file-related ivars of the commander."""
    self.changed = False
        # True: the ouline has changed since the last save.
    self.ignored_at_file_nodes = []
        # List of nodes for c.raise_error_dialogs.
    self.import_error_nodes = []
        # List of nodes for c.raise_error_dialogs.
    self.last_dir = None
        # The last used directory.
    self.mFileName = fileName or ''
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName or ''
        #
    self.openDirectory = None
        #
    self.orphan_at_file_nodes = []
        # List of orphaned nodes for c.raise_error_dialogs.
    self.wrappedFileName = None
        # The name of the wrapped file, for wrapper commanders.
        # Set by LM.initWrapperLeoFile
</t>
<t tx="ekr.20120217070122.10473">def initCommandIvars(self):
    """Init ivars used while executing a command."""
    self.commandsDict = {}
        # Keys are command names, values are functions.
    self.disableCommandsMessage = ''
        # The presence of this message disables all commands.
    self.hookFunction = None
        # One of three places that g.doHook looks for hook functions.
    self.ignoreChangedPaths = False
        # True: disable path changed message in at.WriteAllHelper.
    self.inCommand = False
        # Interlocks to prevent premature closing of a window.
    self.isZipped = False
        # Set by g.openWithFileName.
    self.outlineToNowebDefaultFileName = "noweb.nw"
        # For Outline To Noweb dialog.
    # For tangle/untangle
    self.tangle_errors = 0
    # Default Tangle options
    self.use_header_flag = False
    self.output_doc_flag = False
    # For hoist/dehoist commands.
    self.hoistStack = []
        # Stack of nodes to be root of drawn tree.
        # Affects drawing routines and find commands.
    # For outline navigation.
    self.navPrefix = ''  # Must always be a string.
    self.navTime = None

    self.sqlite_connection = None
</t>
<t tx="ekr.20120217070122.10475">def computeWindowTitle(self, fileName):
    """Set the window title and fileName."""
    if fileName:
        title = g.computeWindowTitle(fileName)
    else:
        s = "untitled"
        n = g.app.numberOfUntitledWindows
        if n &gt; 0:
            s += str(n)
        title = g.computeWindowTitle(s)
        g.app.numberOfUntitledWindows = n + 1
    return title
</t>
<t tx="ekr.20120219154958.10483">def computeFilesList(self, options, fileName):
    """Return the list of files on the command line."""
    lm = self
    files = []
    if fileName:
        files.append(fileName)
    for arg in sys.argv[1:]:
        if arg and not arg.startswith('-'):
            files.append(arg)
    result = []
    for z in files:
        # Fix #245: wrong: result.extend(glob.glob(lm.completeFileName(z)))
        aList = g.glob_glob(lm.completeFileName(z))
        if aList:
            result.extend(aList)
        else:
            result.append(z)
    return [g.os_path_normslashes(z) for z in result]
</t>
<t tx="ekr.20120219154958.10486">def scanOptions(self, fileName, pymacs):
    """Handle all options, remove them from sys.argv and set lm.options."""
    lm = self
    table = (
        '--dock',
        '--global-docks',  # #1643. use --use-docks instead.
        '--init-docks',
        '--no-cache',
        '--no-dock',  # #1171 and #1514: use --use-docks instead.
        '--session-restore',
        '--session-save',
        '--use-docks',
    )
    trace_m = '''beauty,cache,coloring,drawing,events,focus,git,gnx,ipython,
      keys,layouts,plugins,save,select,shutdown,size,startup,themes'''
    for bad_option in table:
        if bad_option in sys.argv:
            sys.argv.remove(bad_option)
            print(f"Ignoring the unused/deprecated {bad_option} option")
    lm.old_argv = sys.argv[:]
    parser = optparse.OptionParser(
        usage="usage: launchLeo.py [options] file1, file2, ...")
        # Automatically implements the --help option.
    #
    # Parse the options, and remove them from sys.argv.
    self.addOptionsToParser(parser, trace_m)
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]]
    sys.argv.extend(args)
    # Handle simple args...
    self.doSimpleOptions(options, trace_m)
    # Compute the lm.files ivar.
    lm.files = lm.computeFilesList(options, fileName)
    script = None if pymacs else self.doScriptOption(options, parser)
    d = {
        'gui': lm.doGuiOption(options),
        'load_type': lm.doLoadTypeOption(options),
        'screenshot_fn': lm.doScreenShotOption(options),
            # --screen-shot=fn
        'script': script,
        'select': options.select and options.select.strip('"'),
            # --select=headline
        'theme_path': options.theme,
            # --theme=name
        'version': options.version,
            # --version: print the version and exit.
        'windowFlag': script and options.script_window,
        'windowSize': lm.doWindowSizeOption(options),
        'windowSpot': lm.doWindowSpotOption(options),
    }
    return d
</t>
<t tx="ekr.20120309073937.9878"></t>
<t tx="ekr.20120427064024.10064">def checkForOpenFile(self, c, fn):
    """Warn if fn is already open and add fn to already_open_files list."""
    d, tag = g.app.db, 'open-leo-files'
    if g.app.reverting:
        # #302: revert to saved doesn't reset external file change monitoring
        g.app.already_open_files = []
    if (d is None or
        g.app.unitTesting or
        g.app.batchMode or
        g.app.reverting or
        g.app.inBridge
    ):
        return
    # #1519: check os.path.exists.
    aList = g.app.db.get(tag) or []
    if [x for x in aList if os.path.exists(x) and os.path.samefile(x, fn)]:
        # The file may be open in another copy of Leo, or not:
        # another Leo may have been killed prematurely.
        # Put the file on the global list.
        # A dialog will warn the user such files later.
        if fn not in g.app.already_open_files:
            g.es('may be open in another Leo:', color='red')
            g.es(fn)
            g.app.already_open_files.append(fn)
    else:
        g.app.rememberOpenFile(fn)
</t>
<t tx="ekr.20120427064024.10065">def rememberOpenFile(self, fn):

    #
    # Do not call g.trace, etc. here.
    d, tag = g.app.db, 'open-leo-files'
    if d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting:
        pass
    elif g.app.preReadFlag:
        pass
    else:
        aList = d.get(tag) or []
        # It's proper to add duplicates to this list.
        aList.append(fn)
        d[tag] = aList
</t>
<t tx="ekr.20120427064024.10066">def forgetOpenFile(self, fn, force=False):
    """Forget the open file, so that is no longer considered open."""
    trace = 'shutdown' in g.app.debug
    d, tag = g.app.db, 'open-leo-files'
    if not d or not fn:
        # #69.
        return
    if not force and (
        d is None or g.app.unitTesting or g.app.batchMode or g.app.reverting):
        return
    aList = d.get(tag) or []
    if fn in aList:
        aList.remove(fn)
        if trace:
            g.pr(f"forgetOpenFile: {g.shortFileName(fn)}")
        d[tag] = aList
    # elif trace: g.pr(f"forgetOpenFile: did not remove: {fn}")
</t>
<t tx="ekr.20120427064024.10068"></t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    """Handle a Qt onSliderChanged event."""
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20121126102050.10134"></t>
<t tx="ekr.20130927050813.13031"></t>
<t tx="ekr.20131017174814.17480">def shouldBeExpanded(self, p):
    """Return True if the node at position p should be expanded."""
    c, v = self, p.v
    if not p.hasChildren():
        return False
    # Always clear non-existent positions.
    v.expandedPositions = [z for z in v.expandedPositions if c.positionExists(z)]
    if not p.isCloned():
        # Do not call p.isExpanded here! It calls this method.
        return p.v.isExpanded()
    if p.isAncestorOf(c.p):
        return True
    for p2 in v.expandedPositions:
        if p == p2:
            return True
    return False
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131222112420.16371">def contract(self):
    """Contract p.v and clear p.v.expandedPositions list."""
    p, v = self, self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    v.contract()

def expand(self):
    p = self
    v = self.v
    v.expandedPositions = [z for z in v.expandedPositions if z != p]
    for p2 in v.expandedPositions:
        if p == p2:
            break
    else:
        v.expandedPositions.append(p.copy())
    v.expand()

def isExpanded(self):
    p = self
    if p.isCloned():
        c = p.v.context
        return c.shouldBeExpanded(p)
    return p.v.isExpanded()
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    """Return True if the indicated setting comes from a local .leo file."""
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert isinstance(gs, g.GeneralSetting), repr(gs)
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140723122936.17925"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the importer code for all kinds of @auto nodes.
# Each plugin must define a top-level importer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140726091031.18071"># Leo loads these plugins automatically.  Do not add them to @enabled-plugins nodes.

# These plugins now contain the write code for all kinds special @auto nodes.
# Each plugin must define a top-level writer_dict dictionary describing the plugin.
@language python
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140815160132.18835">def createCommandNames(self):
    """
    Create all entries in c.commandsDict.
    Do *not* clear c.commandsDict here.
    """
    for commandName, func in g.global_commands_dict.items():
        self.k.registerCommand(commandName, func)
</t>
<t tx="ekr.20140815160132.18837">def initSettings(self, previousSettings):
    """Init the settings *before* initing the objects."""
    c = self
    import leo.core.leoConfig as leoConfig
    c.config = leoConfig.LocalConfigManager(c, previousSettings)
    g.app.config.setIvarsFromSettings(c)
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.

</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    """Return the presently selected item's text."""
    return self.currentItem().text()
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    """Get the horizontal scrollbar position."""
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    """Set the position of the horizontal scrollbar."""
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    """Handle the 'delete' opcode."""
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    """Handle the 'equal' opcode."""
    x = self
    assert aj - ai == bj - bi and x.a[ai:aj] == x.b[bi:bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    """Handle the 'insert' opcode."""
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    """Handle the 'replace' opcode."""
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi:bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    """Report an unexpected opcode."""
    x = self
    x.error(f"unknown SequenceMatcher opcode: {tag!r}")
</t>
<t tx="ekr.20150207044400.9">"""
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
"""
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    """Dump the given lines."""
    print(f"\n{title}...\n")
    for i, line in enumerate(lines):
        g.pr(f"{i:4} {line!r}")
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    """Dump the argument lines."""
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    """
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    """
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    """Put a plain line to x.results, inserting verbatim lines if necessary."""
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print(f"put {repr(x.verbatim_line)}")
    x.results.append(line)
    if x.trace: print(f"put {line!r}")
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    """
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    """
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    """Put all the sentinels to the results"""
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace(f"{i:3} {sentinels}")
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">@language xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
import leo.core.leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()

</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    """
    Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule.
    """
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)

</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    """Create an entry in d for a string keyword."""
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return None
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)  # Don't require ending word.

    return forth_string_word_rule

</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList

</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule20(colorer, s, i):
        return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.

properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {}  # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}


class extendForth:
    """A helper class to extend the mode tables from @data forth-x settings."""

</t>
<t tx="ekr.20150326145530.4">    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None  # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = []  # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False  # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    """Set our ivars from settings."""
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for (ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for (ivar, setting) in table2:
        self.splitList(ivar, setting)

</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    """Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2."""
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)

</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True,  # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True)  # Require word.

    return forth_bracket_rule

</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2",  # defining word
            word=word,
            kind2="keyword3",  # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule

</t>
<t tx="ekr.20150403063658.1">last_unusual_focus = None
# last_no_focus = False

def trace_idle_focus(self, w):
    """Trace the focus for w, minimizing chatter."""
    from leo.core.leoQt import QtWidgets
    import leo.plugins.qt_frame as qt_frame
    trace = 'focus' in g.app.debug
    trace_known = False
    c = self
    table = (QtWidgets.QWidget, qt_frame.LeoQTreeWidget,)
    count = c.idle_focus_count
    if w:
        w_class = w and w.__class__.__name__
        c.last_no_focus = False
        if self.is_unusual_focus(w):
            if trace:
                g.trace(f"{count} unusual focus: {w_class}")
        else:
            c.last_unusual_focus = None
            if isinstance(w, table):
                if trace and trace_known:
                    g.trace(f"{count} known focus: {w_class}")
            elif trace:
                g.trace(f"{count} unknown focus: {w_class}")
    else:
        if trace:
            g.trace(f"{count:3} no focus")
</t>
<t tx="ekr.20150413091056.1">"""Warn if leoProjects.txt or leoToDo.txt contain any clones."""

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    """Warn if p appears in any @&lt;file&gt; node outside of root's tree."""
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425145248.1">run-pylint
clone-to-at-spot
beautify-tree
cfa-code
sort-lines
# show-data
# test-ptb
check-clones
expand-log-pane
contract-log-pane</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    """Return munged lines of """
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    """Top-level code."""
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    """Create decorators for all items in d in root's tree."""
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    """Return the position of the class enclosing p."""
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    """
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    """
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators:
    """
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    """
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    """Create a dict. keys are method names; values are command names."""
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    """
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    """
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    """Create decorators for all items in d in root's tree."""
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print(f"===== not found: {f_name!r}")
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    """Return munged lines of s. """
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    """Top-level code."""
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    """Called from AbbrevCommands.reload_settings aka reloadSettings."""
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning(f"@data {key}")
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150621062355.1">def runAlreadyOpenDialog(self, c):
    """Warn about possibly already-open files."""
    if g.app.already_open_files:
        aList = sorted(set(g.app.already_open_files))
        g.app.already_open_files = []
        g.app.gui.dismiss_splash_screen()
        message = (
            'The following files may already be open\n'
            'in another copy of Leo:\n\n' +
            '\n'.join(aList))
        g.app.gui.runAskOkDialog(c,
            title='Already Open Files',
            message=message,
            text="Ok")
</t>
<t tx="ekr.20150703061709.1">@language python

"""myLeoSettings.py: save the outline and run the pylint command"""

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160427062131.1">def is_unusual_focus(self, w):
    """Return True if w is not in an expected place."""
    #
    # #270: Leo's keyboard events doesn't work after "Insert"
    #       on headline and Alt+Tab, Alt+Tab
    #
    # #276: Focus lost...in Nav text input
    import leo.plugins.qt_frame as qt_frame
    return isinstance(w, qt_frame.QtTabBarWrapper)
</t>
<t tx="ekr.20160521103254.1">def test_visitors_exist(self):
    """Ensure that visitors for all ast nodes exist."""
    import _ast
    # Compute all fields to BaseTest.
    aList = sorted(dir(_ast))
    remove = [
        'Interactive', 'Suite',  # Not necessary.
        'AST',  # The base class,
        # Constants...
        'PyCF_ALLOW_TOP_LEVEL_AWAIT',
        'PyCF_ONLY_AST',
        'PyCF_TYPE_COMMENTS',
        # New ast nodes for Python 3.8.
        # We can ignore these nodes because:
        # 1. ast.parse does not generate them by default.
        # 2. The type comments are ordinary comments.
        #    They do not need to be specially synced.
        'FunctionType', 'NamedExpr', 'TypeIgnore',
    ]
    aList = [z for z in aList if not z[0].islower()]
        # Remove base classes.
    aList = [z for z in aList
        if not z.startswith('_') and not z in remove]
    # Now test them.
    table = (
        TokenOrderGenerator,
    )
    for class_ in table:
        traverser = class_()
        errors, nodes, ops = 0, 0, 0
        for z in aList:
            if hasattr(traverser, 'do_' + z):
                nodes += 1
            elif _op_names.get(z):
                ops += 1
            else:  # pragma: no cover
                errors += 1
                print(
                    f"Missing visitor: "
                    f"{traverser.__class__.__name__}.{z}")
    msg = f"{nodes} node types, {ops} op types, {errors} errors"
    assert not errors, msg
</t>
<t tx="ekr.20161021084954.1">def runPyflakes(self, root, pyflakes_errors_only):
    """Run pyflakes on the selected node."""
    try:
        import leo.commands.checkerCommands as checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root, pyflakes_errors_only=pyflakes_errors_only)
            return ok
        return True  # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
</t>
<t tx="ekr.20161029103615.1">class Py_Importer(Importer):
    '''A class to store and update scanning state.'''

    def __init__(self, importCommands, language='python', **kwargs):
        '''Py_Importer.ctor.'''
        super().__init__(
            importCommands,
            language=language,
            state_class = Python_ScanState,
            strict=True,
        )
        self.put_decorators = self.c.config.getBool('put-python-decorators-in-imported-headlines')

    @others
</t>
<t tx="ekr.20161108131153.10">def run(self, s, parent, parse_body=False):
    '''The common top-level code for all scanners.'''
    c = self.c
    # Fix #449: Cloned @auto nodes duplicates section references.
    if parent.isCloned() and parent.hasChildren():
        return None
    self.root = root = parent.copy()
    self.file_s = s
    # Init the error/status info.
    self.errors = 0
    self.parse_body = parse_body
    # Check for intermixed blanks and tabs.
    self.tab_width = c.getTabWidth(p=root)
    ws_ok = self.check_blanks_and_tabs(s) # Only issues warnings.
    # Regularize leading whitespace
    if not ws_ok:
        s = self.regularize_whitespace(s)
    # Generate the nodes, including directives and section references.
    # Completely generate all nodes.
    self.generate_nodes(s, parent)
    # Check the generated nodes.
    # Return True if the result is equivalent to the original file.
    if parse_body:
        ok = self.errors == 0 # Work around problems with directives.
    else:
        ok = self.errors == 0 and self.check(s, parent)
    g.app.unitTestDict['result'] = ok
    # Insert an @ignore directive if there were any serious problems.
    if not ok:
        self.insert_ignore_directive(parent)
    # It's always useless for an an import to dirty the outline.
    for p in root.self_and_subtree():
        p.clearDirty()
    # #1451: The caller should be responsible for this.
        # if changed:
            # c.setChanged()
        # else:
            # c.clearChanged()
    return ok
</t>
<t tx="ekr.20161108131153.11">def check_blanks_and_tabs(self, lines):
    '''Check for intermixed blank &amp; tabs.'''
    # Do a quick check for mixed leading tabs/blanks.
    fn = g.shortFileName(self.root.h)
    w = self.tab_width
    blanks = tabs = 0
    for s in g.splitLines(lines):
        lws = self.get_str_lws(s)
        blanks += lws.count(' ')
        tabs += lws.count('\t')
    # Make sure whitespace matches @tabwidth directive.
    if w &lt; 0:
        ok = tabs == 0
        message = 'tabs found with @tabwidth %s in %s' % (w, fn)
    elif w &gt; 0:
        ok = blanks == 0
        message = 'blanks found with @tabwidth %s in %s' % (w, fn)
    if ok:
        ok = (blanks == 0 or tabs == 0)
        message = 'intermixed blanks and tabs in: %s' % (fn)
    if not ok:
        if g.unitTesting:
            self.report(message)
        else:
            g.es(message)
    return ok
</t>
<t tx="ekr.20161108131153.12">def insert_ignore_directive(self, parent):
    c = self.c
    parent.v.b = parent.v.b.rstrip() + '\n@ignore\n'
        # Do *not* update the screen by setting p.b.
    if g.unitTesting:
        g.app.unitTestDict['fail'] = g.callers()
    elif parent.isAnyAtFileNode() and not parent.isAtAutoNode():
        g.warning('inserting @ignore')
        c.import_error_nodes.append(parent.h)
</t>
<t tx="ekr.20161108131153.13">def post_pass(self, parent):
    '''
    Optional Stage 2 of the importer pipeline, consisting of zero or more
    substages. Each substage alters nodes in various ways.

    Subclasses may freely override this method, **provided** that all
    substages use the API for setting body text. Changing p.b directly will
    cause asserts to fail later in i.finish().
    '''
    self.clean_all_headlines(parent)
    if self.add_context:
        self.add_class_names(parent)
    self.clean_all_nodes(parent)
    self.unindent_all_nodes(parent)
    #
    # This sub-pass must follow unindent_all_nodes.
    self.promote_trailing_underindented_lines(parent)
    self.promote_last_lines(parent)
    #
    # This probably should be the last sub-pass.
    self.delete_all_empty_nodes(parent)
</t>
<t tx="ekr.20161108131153.14">def regularize_whitespace(self, s):
    '''
    Regularize leading whitespace in s:
    Convert tabs to blanks or vice versa depending on the @tabwidth in effect.
    '''
    kind = 'tabs' if self.tab_width &gt; 0 else 'blanks'
    kind2 = 'blanks' if self.tab_width &gt; 0 else 'tabs'
    fn = g.shortFileName(self.root.h)
    lines = g.splitLines(s)
    count, result, tab_width = 0, [], self.tab_width
    self.ws_error = False # 2016/11/23
    if tab_width &lt; 0: # Convert tabs to blanks.
        for n, line in enumerate(lines):
            i, w = g.skip_leading_ws_with_indent(line, 0, tab_width)
            s = g.computeLeadingWhitespace(w, -abs(tab_width)) + line[i:]
                # Use negative width.
            if s != line:
                count += 1
            result.append(s)
    elif tab_width &gt; 0: # Convert blanks to tabs.
        for n, line in enumerate(lines):
            s = g.optimizeLeadingWhitespace(line, abs(tab_width))
                # Use positive width.
            if s != line:
                count += 1
            result.append(s)
    if count:
        self.ws_error = True # A flag to check.
        if not g.unitTesting:
            # g.es_print('Warning: Intermixed tabs and blanks in', fn)
            # g.es_print('Perfect import test will ignoring leading whitespace.')
            g.es('changed leading %s to %s in %s line%s in %s' % (
                kind2, kind, count, g.plural(count), fn))
        if g.unitTesting: # Sets flag for unit tests.
            self.report('changed %s lines' % count)
    return ''.join(result)
</t>
<t tx="ekr.20161108131153.15"></t>
<t tx="ekr.20161108131153.17">def get_str_lws(self, s):
    '''Return the characters of the lws of s.'''
    m = re.match(r'([ \t]*)', s)
    return m.group(0) if m else ''
</t>
<t tx="ekr.20161108131153.18">def error(self, s):
    '''Issue an error and cause a unit test to fail.'''
    self.errors += 1
    self.importCommands.errors += 1

def report(self, message):
    if self.strict:
        self.error(message)
    else:
        self.warning(message)

def warning(self, s):
    if not g.unitTesting:
        g.warning('Warning:', s)
</t>
<t tx="ekr.20161108131153.19">def undent(self, p):
    '''Remove maximal leading whitespace from the start of all lines.'''
    if self.is_rst:
        return p.b # Never unindent rst code.
    lines = self.get_lines(p)
    ws = self.common_lws(lines)
    result = []
    for s in lines:
        if s.startswith(ws):
            result.append(s[len(ws):])
        elif s.isspace():
            # Never change blank lines.
            result.append(s)
        else:
            # Indicate that the line is underindented.
            result.append("%s%s.%s" % (
                self.c.atFileCommands.underindentEscapeString,
                g.computeWidth(ws, self.tab_width),
                s.lstrip()))
    return result
</t>
<t tx="ekr.20161108131153.20">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    if not lines:
        return ''
    lws = self.get_str_lws(lines[0])
    for s in lines:
        if not self.is_ws_line(s):
            lws2 = self.get_str_lws(s)
            if lws2.startswith(lws):
                pass
            elif lws.startswith(lws2):
                lws = lws2
            else:
                lws = '' # Nothing in common.
                break
    return lws
</t>
<t tx="ekr.20161108131153.21">def underindented_comment(self, line):
    if self.at_auto_warns_about_leading_whitespace:
        self.warning(
            'underindented python comments.\n' +
            'Extra leading whitespace will be added\n' + line)

def underindented_line(self, line):
    if self.warn_about_underindented_lines:
        self.error(
            'underindented line.\n'
            'Extra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20161108131153.3">def check(self, unused_s, parent):
    '''True if perfect import checks pass.'''
    if g.app.suppressImportChecks:
        g.app.suppressImportChecks = False
        return True
    c = self.c
    sfn = g.shortFileName(self.root.h)
    s1 = g.toUnicode(self.file_s, self.encoding)
    s2 = self.trial_write()
    lines1, lines2 = g.splitLines(s1), g.splitLines(s2)
    if 0: # An excellent trace for debugging.
        g.trace(c.shortFileName())
        g.printObj(lines1, tag='lines1')
        g.printObj(lines2, tag='lines2')
    if self.strict:
        # Ignore blank lines only.
        # Adding nodes may add blank lines.
        lines1 = self.strip_blank_lines(lines1)
        lines2 = self.strip_blank_lines(lines2)
    else:
        # Ignore blank lines and leading whitespace.
        # Importing may regularize whitespace, and that's good.
        lines1 = self.strip_all(lines1)
        lines2 = self.strip_all(lines2)
    # Forgive trailing whitespace problems in the last line.
    # This is not the same as clean_last_lines.
    if lines1 and lines2 and lines1 != lines2:
        lines1[-1] = lines1[-1].rstrip()+'\n'
        lines2[-1] = lines2[-1].rstrip()+'\n'
    # self.trace_lines(lines1, lines2, parent)
    ok = lines1 == lines2
    if not ok and not self.strict:
        # Issue an error only if something *other than* lws is amiss.
        lines1, lines2 = self.strip_lws(lines1), self.strip_lws(lines2)
        ok = lines1 == lines2
        if ok and not g.unitTesting:
            print('warning: leading whitespace changed in:', self.root.h)
    if not ok:
        self.show_failure(lines1, lines2, sfn)
        # self.trace_lines(lines1, lines2, parent)
    # Ensure that the unit tests fail when they should.
    # Unit tests do not generate errors unless the mismatch line does not match.
    if g.app.unitTesting:
        d = g.app.unitTestDict
        d['result'] = ok
        if not ok:
            d['fail'] = g.callers()
            # Used in a unit test.
            c.importCommands.errors += 1
    return ok
</t>
<t tx="ekr.20161108131153.4">def clean_blank_lines(self, lines):
    '''Remove all blanks and tabs in all blank lines.'''
    return [self.lstrip_line(z) if z.isspace() else z for z in lines]
</t>
<t tx="ekr.20161108131153.5">def lstrip_line(self, s):
    '''Delete leading whitespace, *without* deleting the trailing newline!'''
    # This fixes a major bug in strip_lws.
    assert s, g.callers()
    return '\n' if s.isspace() else s.lstrip()

def strip_all(self, lines):
    '''Strip blank lines and leading whitespace from all lines of s.'''
    return self.strip_lws(self.strip_blank_lines(lines))

def strip_blank_lines(self, lines):
    '''Strip all blank lines from s.'''
    return [z for z in lines if not z.isspace()]

def strip_lws(self, lines):
    '''Strip leading whitespace from all lines.'''
    return [self.lstrip_line(z) for z in lines]
    # This also works, but I prefer the "extra" call to lstrip().
    # return ['\n' if z.isspace() else z.lstrip() for z in lines].


</t>
<t tx="ekr.20161108131153.6">def trial_write(self):
    '''Return the trial write for self.root.'''
    at = self.c.atFileCommands
    # Leo 5.6: Allow apparent section refs for *all* languages.
    ivar = 'allow_undefined_refs'
    try:
        setattr(at, ivar, True)
        result = at.atAutoToString(self.root)
    finally:
        if hasattr(at, ivar):
            delattr(at, ivar)
    return g.toUnicode(result, self.encoding)
</t>
<t tx="ekr.20161108131153.7"># These can be overridden in subclasses.
</t>
<t tx="ekr.20161108131153.8">def adjust_parent(self, parent, headline):
    '''Return the effective parent.

    This is overridden by the RstScanner class.'''
    return parent
</t>
<t tx="ekr.20161108131153.9">def clean_headline(self, s, p=None):
    '''
    Return the cleaned version headline s.
    Will typically be overridden in subclasses.
    '''
    return s.strip()
</t>
<t tx="ekr.20161108155143.3">def get_int_lws(self, s):
    '''Return the the lws (a number) of line s.'''
    # Important: use self.tab_width, *not* c.tab_width.
    return g.computeLeadingWhitespaceWidth(s, self.tab_width)
</t>
<t tx="ekr.20161108155143.4">def match(self, s, i, pattern):
    '''Return True if the pattern matches at s[i:]'''
    return s[i:i+len(pattern)] == pattern
</t>
<t tx="ekr.20161108155730.1">class Importer:
    '''
    The new, unified, simplified, interface to Leo's importer code.

    Eventually, all importers will create use this class.
    '''

    @others
</t>
<t tx="ekr.20161108155925.1">def __init__(self,
    importCommands,
    gen_refs=False, # True: generate section references,
    language=None, # For @language directive.
    name=None, # The kind of importer, usually the same as language
    state_class=None, # For i.scan_line
    strict=False,
    **kwargs
):
    '''
    Importer.__init__: New in Leo 6.1.1: ic and c may be None for unit tests.
    '''
    # Copies of args...
    self.importCommands = ic = importCommands
    self.c = c = ic and ic.c
    self.encoding = ic and ic.encoding or 'utf-8'
    self.gen_refs = gen_refs
    self.language = language or name
        # For the @language directive.
    self.name = name or language
    language = self.language
    name = self.name
    assert language and name
    assert self.language and self.name
    self.state_class = state_class
    self.strict = strict
        # True: leading whitespace is significant.
    #
    # Set from ivars...
    self.has_decls = name not in ('xml', 'org-mode', 'vimoutliner')
    self.is_rst = name in ('rst',)
    self.tree_type = ic.treeType if c else None # '@root', '@file', etc.
    #
    # Constants...
    if ic:
        data = g.set_delims_from_language(self.name)
        self.single_comment, self.block1, self.block2 = data
    else:
        self.single_comment, self.block1, self.block2 = '//', '/*', '*/' # Javascript.
    if ic:
        self.escape = c.atFileCommands.underindentEscapeString
        self.escape_string = r'%s([0-9]+)\.' % re.escape(self.escape)
        # m.group(1) is the unindent value.
        self.escape_pattern = re.compile(self.escape_string)
    self.ScanState = ScanState
        # Must be set by subclasses that use general_scan_line.
    self.tab_width = 0 # Must be set in run, using self.root.
    self.ws_pattern = re.compile(r'^\s*$|^\s*%s' % (self.single_comment or ''))
    #
    # Settings...
    self.reloadSettings()
    #
    # State vars.
    self.errors = 0
    if ic:
        ic.errors = 0 # Required.
    self.parse_body = False
    self.refs_dict = {}
        # Keys are headlines. Values are disambiguating number.
    self.skip = 0 # A skip count for x.gen_lines &amp; its helpers.
    self.ws_error = False
    self.root = None

def reloadSettings(self):
    c = self.c
    if not c:
        return
    getBool = c.config.getBool
    c.registerReloadSettings(self)
    # self.at_auto_separate_non_def_nodes = False
    self.add_context = getBool("add-context-to-headlines")
    self.add_file_context = getBool("add-file-context-to-headlines")
    self.at_auto_warns_about_leading_whitespace = getBool('at_auto_warns_about_leading_whitespace')
    self.warn_about_underindented_lines = True
   
</t>
<t tx="ekr.20161108160409.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    trace = False
    tail_p = None
    prev_state = self.state_class()
    target = Target(parent, prev_state)
    stack = [target, target]
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        # g.trace(new_state.level(), f"{new_state.level() &lt; top.state.level():1}", repr(line))
        if trace:
            g.trace('%d %d %s' % (
                self.starts_block(i, lines, new_state, prev_state),
                self.ends_block(line, new_state, prev_state, stack),
                line.rstrip()))
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.is_ws_line(line):
            p = tail_p or top.p
            self.add_line(p, line)
        elif self.starts_block(i, lines, new_state, prev_state):
            tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif self.ends_block(line, new_state, prev_state, stack):
            tail_p = self.end_block(line, new_state, stack)
        else:
            p = tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
</t>
<t tx="ekr.20161108160409.3">def end_block(self, line, new_state, stack):
    # The block is ending. Add tail lines until the start of the next block.
    p = stack[-1].p
    self.add_line(p, line)
    self.cut_stack(new_state, stack)
    tail_p = None if self.gen_refs else p
    return tail_p
</t>
<t tx="ekr.20161108160409.5">def add_root_directives(self, parent):
    '''Return the proper directives for the root node p.'''
    table = [
        '@language %s\n' % self.language,
        '@tabwidth %d\n' % self.tab_width,
    ]
    if self.parse_body:
        pass
    elif self.has_lines(parent):
        # Make sure the last line ends with a newline.
        lines = self.get_lines(parent)
        if lines:
            last_line = lines.pop()
            last_line = last_line.rstrip() + '\n'
            self.add_line(parent, last_line)
        self.extend_lines(parent, table)
    else:
        self.set_lines(parent, table)
</t>
<t tx="ekr.20161108160409.6">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    if hasattr(new_state, 'in_context'):
        assert not new_state.in_context(), ('start_new_block', new_state)
    line = lines[i]
    target=stack[-1]
    # Insert the reference in *this* node.
    h = self.gen_ref(line, target.p, target)
    # Create a new child and associated target.
    child = self.create_child_node(target.p, line, h)
    stack.append(Target(child, new_state))
</t>
<t tx="ekr.20161108160409.7">def create_child_node(self, parent, body, headline):
    '''Create a child node of parent.'''
    child = parent.insertAsLastChild()
    self.inject_lines_ivar(child)
    if body:
        self.add_line(child, body)
    assert isinstance(headline, str), repr(headline)
    child.h = headline.strip()
    return child
</t>
<t tx="ekr.20161108160409.8">def gen_ref(self, line, parent, target):
    '''
    Generate the ref line. Return the headline.
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if self.gen_refs:
        # Fix #441: Make sure all section refs are unique.
        d = self.refs_dict
        n = d.get(h, 0)
        d [h] = n + 1
        if n &gt; 0:
            h = '%s: %s' % (n, h)
        headline = g.angleBrackets(' %s ' % h)
        ref = '%s%s\n' % (
            indent_ws,
            g.angleBrackets(' %s ' % h))
    else:
        if target.ref_flag:
            ref = None
        else:
            ref = '%s@others\n' % indent_ws
            target.at_others_flag = True
        target.ref_flag = True
            # Don't generate another @others in this target.
        headline = h
    if ref:
        self.add_line(parent,ref)
    return headline
</t>
<t tx="ekr.20161108165530.1"></t>
<t tx="ekr.20161108170435.1">def scan_line(self, s, prev_state):
    '''
    A generalized scan-line method.

    SCAN STATE PROTOCOL:

    The Importer class should have a state_class ivar that references a
    **state class**. This class probably should *not* be subclass of the
    ScanState class, but it should observe the following protocol:

    1. The state class's ctor must have the following signature:

        def __init__(self, d)

    2. The state class must have an update method.
    '''
    # This dict allows new data to be added without changing ScanState signatures.
    d = {
        'indent': self.get_int_lws(s),
        'is_ws_line': self.is_ws_line(s),
        'prev':prev_state,
        's':s,
    }
    new_state = self.state_class(d)
    i = 0
    while i &lt; len(s):
        progress = i
        context = new_state.context
        table = self.get_table(context)
        data = self.scan_dict(context, i, s, table)
        i = new_state.update(data)
        assert progress &lt; i
    return new_state
</t>
<t tx="ekr.20161108180655.2">def undent_by(self, s, undent_val):
    '''
    Remove leading whitespace equivalent to undent_val from each line.

    Strict languages: prepend the underindent escape for underindented lines.
    '''
    if self.is_rst:
        return s # Never unindent rst code.
    result = []
    for line in g.splitlines(s):
        lws_s = self.get_str_lws(line)
        lws = g.computeWidth(lws_s, self.tab_width)
        # Add underindentEscapeString only for strict languages.
        if self.strict and not line.isspace() and lws &lt; undent_val:
            # End the underindent count with a period to
            # protect against lines that start with a digit!
            result.append("%s%s.%s" % (
                self.escape, undent_val-lws, line.lstrip()))
        else:
            s = g.removeLeadingWhitespace(line, undent_val, self.tab_width)
            result.append(s)
    return ''.join(result)
</t>
<t tx="ekr.20161109045312.1"></t>
<t tx="ekr.20161109045619.1">def print_lines(self, lines):
    '''Print lines for debugging.'''
    print('[')
    for line in lines:
        print(repr(line))
    print(']')

print_list = print_lines
</t>
<t tx="ekr.20161109052011.1">def is_ws_line(self, s):
    '''Return True if s is nothing but whitespace and single-line comments.'''
    return bool(self.ws_pattern.match(s))
</t>
<t tx="ekr.20161109053143.1">def get_leading_indent(self, lines, i, ignoreComments=True):
    '''
    Return the leading whitespace (an int) of the first significant line.
    Ignore blank and comment lines if ignoreComments is True
    '''
    if ignoreComments:
        while i &lt; len(lines):
            if self.is_ws_line(lines[i]):
                i += 1
            else:
                break
    return self.get_int_lws(lines[i]) if i &lt; len(lines) else 0
</t>
<t tx="ekr.20161109072221.1">def undent_body_lines(self, lines, ignoreComments=True):
    '''
    Remove the first line's leading indentation from all lines.
    Return the resulting string.
    '''
    s = ''.join(lines)
    if self.is_rst:
        return s # Never unindent rst code.
    # Calculate the amount to be removed from each line.
    undent_val = self.get_leading_indent(lines, 0, ignoreComments=ignoreComments)
    if undent_val == 0:
        return s
    result = self.undent_by(s, undent_val)
    return result
</t>
<t tx="ekr.20161110042020.1">def finalize_ivars(self, parent):
    '''
    Update the body text of all nodes in parent's tree using the injected
    v._import_lines lists.
    '''
    for p in parent.self_and_subtree():
        v = p.v
        # Make sure that no code in x.post_pass has mistakenly set p.b.
        assert not v._bodyString, repr(v._bodyString)
        lines = v._import_lines
        if lines:
            if not lines[-1].endswith('\n'):
                lines[-1] += '\n'
        v._bodyString = g.toUnicode(''.join(lines), reportErrors=True)
            # Bug fix: 2017/01/24: must convert to unicode!
            # This was the source of the internal error in the p.b getter.
        delattr(v, '_import_lines')
</t>
<t tx="ekr.20161110042512.1"># All code in passes 1 and 2 *must* use this API to change body text.

def add_line(self, p, s):
    '''Append the line s to p.v._import_lines.'''
    assert s and isinstance(s, str), (repr(s), g.callers())
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (repr(s), g.callers())
    p.v._import_lines.append(s)

def clear_lines(self, p):
    p.v._import_lines = []

def extend_lines(self, p, lines):
    p.v._import_lines.extend(list(lines))

def get_lines(self, p):
    # *Never* change p unexpectedly!
    assert hasattr(p.v, '_import_lines'), (p and p.h, g.callers())
    return p.v._import_lines

def has_lines(self, p):
    return hasattr(p.v, '_import_lines')

def inject_lines_ivar(self, p):
    '''Inject _import_lines into p.v.'''
    # *Never* change p unexpectedly!
    assert not p.v._bodyString, (p and p.h, g.callers(10))
    p.v._import_lines = []

def prepend_lines(self, p, lines):
    p.v._import_lines = list(lines) + p.v._import_lines

def set_lines(self, p, lines):
    p.v._import_lines = list(lines)
</t>
<t tx="ekr.20161110073751.1">def clean_headline(self, s, p=None):
    '''Return a cleaned up headline s.'''
    if p: # Called from clean_all_headlines:
        return self.get_decorator(p) + p.h
    # Handle defs.
    m = re.match(r'\s*def\s+(\w+)', s)
    if m:
        return m.group(1)
    # Handle classes.
    #913: Show base classes in python importer.
    #978: Better regex handles class C(bar.Bar)
    m = re.match(r'\s*class\s+(\w+)\s*(\([\w.]+\))?', s)
    if m:
        return 'class %s%s' % (m.group(1), m.group(2) or '')
    return s.strip()

def get_decorator(self, p):
    if g.unitTesting or self.put_decorators:
        for s in self.get_lines(p):
            if not s.isspace():
                m = re.match(r'\s*@\s*([\w\.]+)', s)
                if m:
                    s = s.strip()
                    if s.endswith('('):
                        s = s[:-1].strip()
                    return s + ' '
                return ''
    return ''
</t>
<t tx="ekr.20161110125940.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Note: i.gen_ref calls clean_headline without knowing p.
        # As a result, the first argument is required.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
    
</t>
<t tx="ekr.20161110130157.1">def clean_all_nodes(self, parent):
    '''Clean the nodes in parent's tree, in a language-dependent way.'''
    # i.clean_nodes does nothing.
    # Subclasses may override as desired.
    # See perl_i.clean_nodes for an example.
    self.clean_nodes(parent)
</t>
<t tx="ekr.20161110130337.1">def unindent_all_nodes(self, parent):
    '''Unindent all nodes in parent's tree.'''
    for p in parent.subtree():
        lines = self.get_lines(p)
        if all([z.isspace() for z in lines]):
            # Somewhat dubious, but i.check covers for us.
            self.clear_lines(p)
        else:
            self.set_lines(p, self.undent(p))
</t>
<t tx="ekr.20161110130709.1">def delete_all_empty_nodes(self, parent):
    '''
    Delete nodes consisting of nothing but whitespace.
    Move the whitespace to the preceding node.
    '''
    c = self.c
    aList = []
    for p in parent.subtree():
        back = p.threadBack()
        if back and back.v != parent.v and back.v != self.root.v and not p.isCloned():
            lines = self.get_lines(p)
            # Move the whitespace from p to back.
            if all([z.isspace() for z in lines]):
                self.extend_lines(back, lines)
                # New in Leo 5.7: empty nodes may have children.
                if p.hasChildren():
                    # Don't delete p.
                    p.h = 'organizer'
                    self.clear_lines(p)
                else:
                    # Do delete p.
                    aList.append(p.copy())
    if aList:
        c.deletePositionsInList(aList, redraw=False)
            # Suppress redraw.
</t>
<t tx="ekr.20161110131509.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.subtree():
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    g.trace(line)
                    # Fix #652 by restoring the line.
                    new_line = line[len(m.group(0)):].lstrip()
                    lines.append(new_line)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            if parent.parent() == self.root:
                parent = parent.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161110173058.1">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20161111023249.1">def finish(self, parent):
    '''
    Stage 3 (the last) stage of the importer pipeline.

    Subclasses should never need to override this method.
    '''
    # Put directives at the end, so as not to interfere with shebang lines, etc.
    self.add_root_directives(parent)
    #
    # Finally, remove all v._import_list temporaries.
    self.finalize_ivars(parent)
</t>
<t tx="ekr.20161111024447.1">def generate_nodes(self, s, parent):
    '''
    A three-stage pipeline to generate all imported nodes.
    '''
    # Stage 1: generate nodes.
    # After this stage, the p.v._import_lines list contains p's future body text.
    self.gen_lines(s, parent)
    #
    # Optional Stage 2, consisting of zero or more sub-stages.
    # Subclasses may freely override this method, **provided**
    # that all substages use the API for setting body text.
    # Changing p.b directly will cause asserts to fail in i.finish().
    self.post_pass(parent)
    #
    # Stage 3: Put directives in the root node and set p.b for all nodes.
    #
    # Subclasses should never need to override this stage.
    self.finish(parent)
</t>
<t tx="ekr.20161113135037.1">@nobeautify
cached_scan_tables = {}

def get_table(self, context):
    '''
    Return the state table for the given context.

    This method handles caching.  x.get_new_table returns the actual table.
    '''
    key = '%s.%s' % (self.name, context)
        # Bug fix: must keep tables separate.
    table = self.cached_scan_tables.get(key)
    if table:
        return table
    table = self.get_new_dict(context)
    self.cached_scan_tables[key] = table
    return table
</t>
<t tx="ekr.20161114012522.1">def all_contexts(self, table):
    '''
    Return a list of all contexts contained in the third column of the given table.

    This is a support method for unit tests.
    '''
    contexts = set()
    d = table
    for key in d:
        aList = d.get(key)
        for data in aList:
            if len(data) == 4:
                # It's an out-of-context entry.
                contexts.add(data[2])
    # Order must not matter, so sorting is ok.
    return sorted(contexts)
</t>
<t tx="ekr.20161114024119.1">def test_scan_state(self, tests, State):
    '''
    Test x.scan_line or i.scan_line.

    `tests` is a list of g.Bunches with 'line' and 'ctx' fields.

    A typical @command test:

        if c.isChanged(): c.save()
        &lt; &lt; imp.reload importers.linescanner and importers.python &gt; &gt;
        importer = py.Py_Importer(c.importCommands)
        importer.test_scan_state(tests, Python_ScanState)
    '''
    assert self.single_comment == '#', self.single_comment
    table = self.get_table(context='')
    contexts = self.all_contexts(table)
    for bunch in tests:
        assert bunch.line is not None
        line = bunch.line
        ctx = getattr(bunch, 'ctx', None)
        if ctx: # Test one transition.
            ctx_in, ctx_out = ctx
            prev_state =  State()
            prev_state.context = ctx_in
            new_state = self.scan_line(line, prev_state)
            new_context = new_state.context
            assert new_context == ctx_out, (
                'FAIL1:\nline: %r\ncontext: %r new_context: %r ctx_out: %r\n%s\n%s' % (
                    line, ctx_in, new_context, ctx_out, prev_state, new_state))
        else: # Test all transitions.
            for context in contexts:
                prev_state =  State()
                prev_state.context = context
                new_state = self.scan_line(line, prev_state)
                assert new_state.context == context, (
                    'FAIL2:\nline: %r\ncontext: %r new_context: %r\n%s\n%s' % (
                        line, context, new_state.context, prev_state, new_state))
</t>
<t tx="ekr.20161116034633.2">def cut_stack(self, new_state, stack, append=False):
    '''Cut back the stack until stack[-1] matches new_state.'''
    # pylint: disable=arguments-differ
    assert len(stack) &gt; 1 # Fail on entry.
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            assert len(stack) &gt; 1, stack # &lt;
            stack.pop()
        elif top_state.level() == new_state.level():
            assert len(stack) &gt; 1, stack # ==
            if append:
                pass # Append line to the previous node.
            else:
                stack.pop() # Create a new node.
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    assert len(stack) &gt; 1 # Fail on exit.
</t>
<t tx="ekr.20161116034633.7">def start_new_block(self, i, lines, new_state, prev_state, stack):
    '''Create a child node and update the stack.'''
    assert not prev_state.in_context(), prev_state
    line = lines[i]
    top = stack[-1]
    # Adjust the stack.
    if new_state.indent &gt; top.state.indent:
        pass
    elif new_state.indent == top.state.indent:
        stack.pop()
    else:
        self.cut_stack(new_state, stack)
    # Create the child.
    top = stack[-1]
    parent = top.p
    self.gen_ref(line, parent, top)
    h = self.clean_headline(line, p=None)
    child = self.create_child_node(parent, line, h)
    self.prepend_lines(child, self.decorator_lines)
    self.decorator_lines = []
    target = PythonTarget(child, new_state)
    target.kind = 'class' if h.startswith('class') else 'def'
    stack.append(target)
</t>
<t tx="ekr.20161116040557.1">starts_pattern = re.compile(r'\s*(class|def)\s+')
    # Matches lines that apparently start a class or def.

def starts_block(self, i, lines, new_state, prev_state, stack):
    '''True if the line startswith class or def outside any context.'''
    # pylint: disable=arguments-differ
    if prev_state.in_context():
        return False
    line = lines[i]
    m = self.starts_pattern.match(line)
    if not m:
        return False
    top = stack[-1]
    prev_indent = top.state.indent
    if top.kind == 'None' and new_state.indent &gt; 0:
        # Underindented top-level class/def.
        return False
    if top.kind == 'def' and new_state.indent &gt; prev_indent:
        # class/def within a def.
        # #1493: Insert decorators.
        p = self.tail_p or top.p
        for line in self.decorator_lines:
            self.add_line(p, line)
        return False
    if top.at_others_flag and new_state.indent &gt; prev_indent:
        return False
    return True
</t>
<t tx="ekr.20161116173901.1">def end_block(self, i, lines, new_state, prev_state, stack):
    '''
    Handle a line that terminates the previous class/def. The line is
    neither a class/def line, and we are not in a multi-line token.

    Skip all lines that are at the same level as the class/def.
    '''
    # pylint: disable=arguments-differ
    top = stack[-1]
    assert new_state.indent &lt; top.state.indent, (
        '\nnew: %s\ntop: %s' % (new_state, top.state))
    assert self.skip == 0, self.skip
    end_indent = new_state.indent
    while i &lt; len(lines):
        progress = i
        self.cut_stack(new_state, stack, append=True)
        top = stack[-1]
        # Add the line.
        line = lines[i]
        self.add_line(top.p, line)
        # Move to the next line.
        i += 1
        if i &gt;= len(lines):
            break
        prev_state = new_state
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
            break
        elif not self.is_ws_line(line) and new_state.indent &lt;= end_indent:
            break
        else:
            self.skip += 1
        assert progress &lt; i, repr(line)
    return top.p
</t>
<t tx="ekr.20161119083054.1">def find_class(self, parent):
    '''
    Find the start and end of a class/def in a node.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    '''
    # Called from Leo's core to implement two minor commands.
    prev_state = Python_ScanState()
    target = Target(parent, prev_state)
    stack = [target, target]
    lines = g.splitlines(parent.b)
    index = 0
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        if self.starts_block(i, lines, new_state, prev_state, stack):
                # Bug fix 2019/06/05: added "stack" arg(!)
            return self.skip_block(i, index, lines, new_state, stack)
        prev_state = new_state
        index += len(line)
    return None, -1, -1
</t>
<t tx="ekr.20161119124217.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    return new_state.level() &gt; prev_state.level()
</t>
<t tx="ekr.20161119130337.1">def cut_stack(self, new_state, stack):
    '''Cut back the stack until stack[-1] matches new_state.'''
    
    def underflow(n):
        g.trace(n)
        g.trace(new_state)
        g.printList(stack)
        
    # assert len(stack) &gt; 1 # Fail on entry.
    if len(stack) &lt;= 1:
        return underflow(0)
    while stack:
        top_state = stack[-1].state
        if new_state.level() &lt; top_state.level():
            if len(stack) &gt; 1:
                stack.pop()
            else:
                return underflow(1)
        elif top_state.level() == new_state.level():
            # assert len(stack) &gt; 1, stack # ==
            # This is the only difference between i.cut_stack and python/cs.cut_stack
            if len(stack) &lt;= 1:
                return underflow(2)
            break
        else:
            # This happens often in valid Python programs.
            break
    # Restore the guard entry if necessary.
    if len(stack) == 1:
        stack.append(stack[-1])
    elif len(stack) &lt;= 1:
        return underflow(3)
    return None
</t>
<t tx="ekr.20161119161953.1">def gen_lines(self, s, parent):
    '''
    Non-recursively parse all lines of s into parent, creating descendant
    nodes as needed.
    '''
    self.tail_p = None
    prev_state = self.state_class()
    target = PythonTarget(parent, prev_state)
    stack = [target, target]
    self.decorator_lines = []
    self.inject_lines_ivar(parent)
    lines = g.splitLines(s)
    self.skip = 0
    first = True
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        top = stack[-1]
        if self.skip &gt; 0:
            self.skip -= 1
        elif self.starts_decorator(i, lines, new_state):
            pass # Sets self.skip and self.decorator_lines.
        elif self.starts_block(i, lines, new_state, prev_state, stack):
            first = False
            self.tail_p = None
            self.start_new_block(i, lines, new_state, prev_state, stack)
        elif first:
            if self.is_ws_line(line):
                p = self.tail_p or top.p
                self.add_line(p, line)
            else:
                first = False
                h = 'Declarations'
                self.gen_ref(line, parent, target)
                p = self.create_child_node(parent, body=line, headline=h)
                stack.append(PythonTarget(p, new_state))
        elif self.ends_block(line, new_state, prev_state, stack):
            first = False
            self.tail_p = self.end_block(i, lines, new_state, prev_state, stack)
        else:
            p = self.tail_p or top.p
            self.add_line(p, line)
        prev_state = new_state
    if self.skip:
        g.trace('can not happen: self.skip &gt; 0', color='red')
    if self.decorator_lines:
        g.trace('can not happen: unused decorator lines...', color='red')
        g.printObj(self.decorator_lines)

</t>
<t tx="ekr.20161119162451.1">def trace_status(self, line, new_state, prev_state, stack, top):
    '''Print everything important in the i.gen_lines loop.'''
    print('')
    try:
        g.trace('===== %r' % line)
    except Exception:
        g.trace('     top.p: %s' % g.toEncodedString(top.p.h))
    # print('len(stack): %s' % len(stack))
    print(' new_state: %s' % new_state)
    print('prev_state: %s' % prev_state)
    # print(' top.state: %s' % top.state)
    g.printList(stack)
</t>
<t tx="ekr.20161120022121.1"></t>
<t tx="ekr.20161123210335.1">def trace_lines(self, lines1, lines2, parent):
    '''Show both s1 and s2.'''
    print('===== s1: %s' % parent.h)
    for i, s in enumerate(lines1):
        g.pr('%3s %r' % (i+1, s))
    print('===== s2')
    for i, s in enumerate(lines2):
        g.pr('%3s %r' % (i+1, s))
</t>
<t tx="ekr.20161123210716.1">def show_failure(self, lines1, lines2, sfn):
    '''Print the failing lines, with surrounding context.'''
    if not g.unitTesting:
        g.es('@auto failed:', sfn, color='red')
    n1, n2 = len(lines1), len(lines2)
    print('\n===== PERFECT IMPORT FAILED =====', sfn)
    print('len(s1): %s len(s2): %s' % (n1, n2))
    for i in range(min(n1, n2)):
        line1, line2 = lines1[i], lines2[i]
        if line1 != line2:
            print('first mismatched line: %s' % (i+1))
            print('s1...')
            print(''.join(self.context_lines(lines1, i)))
            print('s2...')
            print(''.join(self.context_lines(lines2, i)))
            # print(repr(line1))
            # print(repr(line2))
            break
    else:
        print('all common lines match')
</t>
<t tx="ekr.20161124030004.1">def clean_last_lines(self, lines):
    '''Remove blank lines from the end of lines.'''
    while lines and lines[-1].isspace():
        lines.pop()
    return lines
</t>
<t tx="ekr.20161125174423.1">def print_stack(self, stack):
    '''Print a stack of positions.'''
    g.printList([p.h for p in stack])
</t>
<t tx="ekr.20161127102339.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161127184128.4">elisp_clean_pattern = re.compile(r'^\s*\(\s*defun\s+([\w_-]+)')

def clean_headline(self, s, p=None):
    '''Return a cleaned up headline s.'''
    m = self.elisp_clean_pattern.match(s)
    if m and m.group(1):
        return 'defun %s' % m.group(1)
    return s.strip()
</t>
<t tx="ekr.20161127185851.1">def starts_block(self, i, lines, new_state, prev_state):
    '''True if the new state starts a block.'''
    line = lines[i]
    return self.elisp_clean_pattern.match(line)
</t>
<t tx="ekr.20161128025444.1">def scan_dict(self, context, i, s, d):
    '''
    i.scan_dict: Scan at position i of s with the give context and dict.
    Return the 6-tuple: (new_context, i, delta_c, delta_p, delta_s, bs_nl)
    '''
    found = False
    delta_c = delta_p = delta_s = 0
    ch = s[i]
    aList = d.get(ch)
    if aList and context:
        # In context.
        for data in aList:
            kind, pattern, ends = data
            if self.match(s, i, pattern):
                if ends is None:
                    found = True
                    new_context = context
                    break
                elif ends:
                    found = True
                    new_context = ''
                    break
                else:
                    pass # Ignore this match.
    elif aList:
        # Not in context.
        for data in aList:
            kind, pattern, new_context, deltas = data
            if self.match(s, i, pattern):
                found = True
                if deltas:
                    delta_c, delta_p, delta_s = deltas
                break
    if found:
        if kind == 'all':
            i = len(s)
        elif kind == 'len+1':
            i += (len(pattern) + 1)
        else:
            assert kind == 'len', (kind, self.name)
            i += len(pattern)
        bs_nl = pattern == '\\\n'
        return new_context, i, delta_c, delta_p, delta_s, bs_nl
    #
    # No match: stay in present state. All deltas are zero.
    new_context = context
    return new_context, i+1, 0, 0, 0, False
</t>
<t tx="ekr.20161128025508.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, pattern, data):
        key = pattern[0]
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key    kind      pattern  ends?
            '\\':   [('len+1', '\\',    None),],
            '"':    [('len',   '"',     context == '"'),],
            "'":    [('len',   "'",     context == "'"),],
        }
        if block1 and block2:
            add_key(d, block2, ('len', block2, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\':[('len+1', '\\', context, None),],
            '"':    [('len', '"', '"',     None),],
            "'":    [('len', "'", "'",     None),],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment, ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1, ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161128054630.1">@nobeautify

def get_new_dict(self, context):
    '''
    Return a *general* state dictionary for the given context.
    Subclasses may override...
    '''
    comment, block1, block2 = self.single_comment, self.block1, self.block2

    def add_key(d, key, data):
        aList = d.get(key,[])
        aList.append(data)
        d[key] = aList

    if context:
        d = {
            # key   kind    pattern ends?
            '\\':   [('len+1', '\\',None),],
            '"':[
                    ('len', '"""',  context == '"""'),
                    ('len', '"',    context == '"'),
                ],
            "'":[
                    ('len', "'''",  context == "'''"),
                    ('len', "'",    context == "'"),
                ],
        }
        if block1 and block2:
            add_key(d, block2[0], ('len', block1, True))
    else:
        # Not in any context.
        d = {
            # key    kind pattern new-ctx  deltas
            '\\': [('len+1','\\', context, None),],
            '#':  [('all', '#',   context, None),],
            '"':[
                    # order matters.
                    ('len', '"""',  '"""', None),
                    ('len', '"',    '"',   None),
                ],
            "'":[
                    # order matters.
                    ('len', "'''",  "'''", None),
                    ('len', "'",    "'",   None),
                ],
            '{':    [('len', '{', context, (1,0,0)),],
            '}':    [('len', '}', context, (-1,0,0)),],
            '(':    [('len', '(', context, (0,1,0)),],
            ')':    [('len', ')', context, (0,-1,0)),],
            '[':    [('len', '[', context, (0,0,1)),],
            ']':    [('len', ']', context, (0,0,-1)),],
        }
        if comment:
            add_key(d, comment[0], ('all', comment, '', None))
        if block1 and block2:
            add_key(d, block1[0], ('len', block1, block1, None))
    return d
</t>
<t tx="ekr.20161205052712.1">def skip_block(self, i, index, lines, prev_state, stack):
    '''
    Find the end of a class/def starting at index
    on line i of lines.

    Return (kind, i, j), where kind in (None, 'class', 'def')
    .'''
    index1 = index
    line = lines[i]
    kind = 'class' if line.strip().startswith('class') else 'def'
    i += 1
    while i &lt; len(lines):
        progress = i
        line = lines[i]
        index += len(line)
        new_state = self.scan_line(line, prev_state)
        if self.ends_block(line, new_state, prev_state, stack):
            return kind, index1, index
        prev_state = new_state
        i += 1
        assert progress &lt; i
    return None, -1, -1
</t>
<t tx="ekr.20161220064822.1">def gen_ref(self, line, parent, target):
    '''
    Generate the at-others and a flag telling this method whether a previous
    @others
    '''
    indent_ws = self.get_str_lws(line)
    h = self.clean_headline(line, p=None)
    if not target.at_others_flag:
        target.at_others_flag = True
        ref = '%s@others\n' % indent_ws
        self.add_line(parent,ref)
    return h
</t>
<t tx="ekr.20161220073836.1">def ends_block(self, line, new_state, prev_state, stack):
    '''True if line ends the block.'''
    # Comparing new_state against prev_state does not work for python.
    if self.is_ws_line(line) or prev_state.in_context():
        return False
    # *Any* underindented non-blank line ends the class/def.
    top = stack[-1]
    return new_state.level() &lt; top.state.level()
</t>
<t tx="ekr.20161220171728.1">def common_lws(self, lines):
    '''Return the lws (a string) common to all lines.'''
    return self.get_str_lws(lines[0]) if lines else ''
        # We must unindent the class/def line fully.
        # It would be wrong to examine the indentation of other lines.
</t>
<t tx="ekr.20161222112801.1">def promote_trailing_underindented_lines(self, parent):
    '''
    Promote all trailing underindent lines to the node's parent node,
    deleting one tab's worth of indentation. Typically, this will remove
    the underindent escape.
    '''
    pattern = self.escape_pattern # A compiled regex pattern
    for p in parent.children(): # 2018/05/24.
        lines = self.get_lines(p)
        tail = []
        while lines:
            line = lines[-1]
            m = pattern.match(line)
            if m:
                lines.pop()
                n_str = m.group(1)
                try:
                    n = int(n_str)
                except ValueError:
                    break
                if n == abs(self.tab_width):
                    new_line = line[len(m.group(0)):]
                    tail.append(new_line)
                else:
                    g.trace('unexpected unindent value', n)
                    break
            else:
                break
        if tail:
            parent = p.parent()
            self.set_lines(p, lines)
            self.extend_lines(parent, reversed(tail))
</t>
<t tx="ekr.20161222122914.1">def promote_last_lines(self, parent):
    '''A placeholder for python_i.promote_last_lines.'''
</t>
<t tx="ekr.20161222123105.1">def promote_last_lines(self, parent):
    '''python_i.promote_last_lines.'''
    last = parent.lastNode()
    if not last or last.h == 'Declarations':
        return
    if last.parent() != parent:
        return # The indentation would be wrong.
    lines = self.get_lines(last)
    prev_state = self.state_class()
    if_pattern = re.compile(r'^\s*if\b')
    # Scan for a top-level if statement.
    for i, line in enumerate(lines):
        new_state = self.scan_line(line, prev_state)
        m = if_pattern.match(line)
        if m and not prev_state.context and new_state.indent == 0:
            self.set_lines(last, lines[:i])
            self.extend_lines(parent, lines[i:])
            break
        else:
            prev_state = new_state
</t>
<t tx="ekr.20170305105047.1">decorator_pattern = re.compile(r'^\s*@\s*(\w+)')

def starts_decorator(self, i, lines, prev_state):
    '''
    True if the line looks like a decorator outside any context.

    Puts the entire decorator into the self.decorator_lines list,
    and sets self.skip so that the next line to be handled is a class/def line.
    '''
    assert self.skip == 0
    if prev_state.context:
        # Only test for docstrings, not [{(.
        return False
    old_skip = self.skip
    old_decorator_lines = self.decorator_lines[:]
    line = lines[i]
    m = self.decorator_pattern.match(line)
    if m and m.group(1) not in g.globalDirectiveList:
        # Fix #360: allow multiline matches
        # Carefully skip all lines until a class/def.
        self.decorator_lines = [line]
        for i, line in enumerate(lines[i+1:]):
            new_state = self.scan_line(line, prev_state)
            m = self.starts_pattern.match(line)
            if m:
                # 2018/05/24: don't check in_context!
                # The class or def could start a context.
                return True
            self.decorator_lines.append(line)
            self.skip += 1
            prev_state = new_state
    # Recover froma a bare decorator, without a class or def.
    self.skip = old_skip
    self.decorator_lines = old_decorator_lines
    return False
</t>
<t tx="ekr.20170404035138.1">def context_lines(self, aList, i, n=2):
    '''Return a list containing the n lines of surrounding context of aList[i].'''
    result = []
    aList1 = aList[max(0, i-n):i]
    aList2 = aList[i+1:i+n+1]
    result.extend(['  %4s %r\n' % (i + 1 - len(aList1) + j, g.truncate(s,60))
        for j, s in enumerate(aList1)])
    result.append('* %4s %r\n' % (i + 1, g.truncate(aList[i], 60)))
    result.extend(['  %4s %r\n' % (i + 2 + j, g.truncate(s, 60))
        for j, s in enumerate(aList2)])
    return result
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">"""Recursively import all python files in a directory and clean the result."""
g.cls()
# dir_ = r'C:\leo.repo\leointeg\src'
# dir_ = r'C:\apps\Emacs\share\emacs\26.1\lisp\outline.el'
# dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\Pymacs.py'
# dir_ = r'C:\Users\edreamleo\emacs-packages\pymacs.el'
# dir_ = r'C:\leo.repo\pscript'
dir_ = r'C:\Users\edreamleo\Anaconda3\Lib\site-packages\black.py'
c.recursiveImport(
    dir_ = dir_,
    kind = '@clean', # '@clean', #'@nosent','@auto','@file',
    recursive = False,
    safe_at_file = False,
    theTypes = ['.py',] # '.py',],
)
</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170617125213.1">def clean_all_headlines(self, parent):
    '''
    Clean all headlines in parent's tree by calling the language-specific
    clean_headline method.
    '''
    for p in parent.subtree():
        # Important: i.gen_ref does not know p when it calls
        # self.clean_headline.
        h = self.clean_headline(p.h, p=p)
        if h and h != p.h:
            p.h = h
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, f"leo-bundle-all-{stamp}")
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20180225010644.1">@nobeautify</t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180312150559.1">@nobeautify

def addOptionsToParser(self, parser, trace_m):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@&lt;file&gt; type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace',        'add one or more strings to g.app.debug', m=trace_m)
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    add_other('--window-spot',  'initial window position (top x left)', m='SPOT')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
</t>
<t tx="ekr.20180312150805.1">def doGuiOption(self, options):
    gui = options.gui
    if gui:
        gui = gui.lower()
        # #1171: retire non-tabbed qt gui.
        if gui in ('qt', 'qttabs'):
            gui = 'qt'  # For compatibilty with g.UiTypeException
        elif gui.startswith('browser'):
            pass
        elif gui in ('console', 'curses', 'text', 'null'):
            pass
        else:
            print(f"scanOptions: unknown gui: {gui}.  Using qt gui")
            gui = 'qt'
    else:
        gui = 'qt'
    assert gui
    assert gui != 'qttabs'  # For compatibilty with g.UiTypeException
    g.app.qt_use_tabs = gui == 'qt'
    g.app.guiArgName = gui
    return gui
</t>
<t tx="ekr.20180312151544.1">def doSimpleOptions(self, options, trace_m):
    """These args just set g.app ivars."""
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = not options.no_splash and not options.minimized
    # --silent
    g.app.silentMode = options.silent
    # --trace=...
    valid = trace_m.replace(' ', '').replace('\n', '').split(',')
    # g.trace('valid', valid)
    if options.trace:
        values = options.trace.lstrip('(').lstrip('[').rstrip(')').rstrip(']')
        for val in values.split(','):
            if val in valid:
                # g.trace('val', val)
                g.app.debug.append(val)
            else:
                g.es_print(f"unknown --trace value: {val}")
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
</t>
<t tx="ekr.20180312152329.1">def doLoadTypeOption(self, options):

    s = options.load_type
    s = s.lower() if s else 'edit'
    return '@' + s
</t>
<t tx="ekr.20180312152609.1">def doScreenShotOption(self, options):

    # --screen-shot=fn
    s = options.screen_shot
    if s:
        s = s.strip('"')
    return s
</t>
<t tx="ekr.20180312153008.1">def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print(f"script not found: {fn}")
            sys.exit(1)
    else:
        script = None
    return script
</t>
<t tx="ekr.20180312154839.1">def doWindowSizeOption(self, options):

    # --window-size
    windowSize = options.window_size
    if windowSize:
        try:
            h, w = windowSize.split('x')
            windowSize = int(h), int(w)
        except ValueError:
            windowSize = None
            print('scanOptions: bad --window-size:', windowSize)
    return windowSize
</t>
<t tx="ekr.20180324065741.1">"""Copy the selected text to the next node."""
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180504191650.34"></t>
<t tx="ekr.20180504191650.36"></t>
<t tx="ekr.20180504191650.42"></t>
<t tx="ekr.20180504191650.68"></t>
<t tx="ekr.20180504192522.1"></t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.process_time()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.process_time()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line) - len(line.lstrip())
            indent2 = len(g_line) - len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column  # For traces.
                column += abs(indent2 - indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0 - 1 : n0 + 30])
        print(f"can not happen: not found: {line!r}")
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1 + n0 + jedi_line,
                column=column,
                path=g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            )
            completions = script.completions()
            t3 = time.process_time()
        except ValueError:
            t3 = time.process_time()
            completions = None
            g.printObj(source_lines[n0 - 1 : n0 + 30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180524130023.1">file_pattern = re.compile(r'^(([@])+(auto|clean|edit|file|nosent))')
    # Note: this method is never called for @clean trees.

def add_class_names(self, p):
    '''
    Add class names to headlines for all descendant nodes.

    Called only when @bool add-context-to-headlines is True.
    '''
    if g.app.unitTesting:
        return # Don't changes the expected headlines.
    after, fn, class_name = None, None, None
    for p in p.self_and_subtree():
        # Part 1: update the status.
        m = self.file_pattern.match(p.h)
        if m:
            prefix = m.group(1)
            fn = g.shortFileName(p.h[len(prefix):].strip())
            after, class_name = None, None
            continue
        if p.h.startswith('@path '):
            after, fn, class_name = None, None, None
        elif p.h.startswith('class '):
            class_name = p.h[5:].strip()
            if class_name:
                after = p.nodeAfterTree()
                continue
        elif p == after:
            after, class_name = None, None
        # Part 2: update the headline.
        if class_name:
            if not p.h.startswith(class_name):
                p.h = '%s.%s' % (class_name, p.h)
        elif fn and self.add_file_context:
            tag = ' (%s)' % fn
            if not p.h.endswith(tag):
                p.h += tag
</t>
<t tx="ekr.20180524173510.1"></t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    """A hack to match the callers expectations."""
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180604114211.1">@nosearch
</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180810052056.2">def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) &gt; 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) &lt;= 1 and (v.statusBits &amp; v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 &lt; len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 &lt; len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break  # Found: moveToThreadNext()
        else:
            break  # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180816105258.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_branches(
    branch1='bc24e607a5', # '6bd282f', # 'bc24e607a5', # old branch/rev
    branch2='devel', # new branch/rev
    fn='leo/plugins/nested_splitter.py',
    directory=None,
)
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181009072707.1"># -*- coding: utf-8 -*-
import leo.core.leoBridge as leoBridge
import os
import sys
# import pdb ; pdb.set_trace()
import unittest

load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    tm = c.testManager
    g.unitTesting = g.app.unitTesting = True
    suite = unittest.makeSuite(unittest.TestCase)
    aList = tm.findAllUnitTestNodes(all=False, marked=False)
    setup_script = None
    found = False
    for p in aList:
        if tm.isTestSetupNode(p):
            setup_script = p.b
            test = None
        elif tm.isTestNode(p):
            test = tm.makeTestCase(p, setup_script)
        elif tm.isSuiteNode(p):
            test = tm.makeTestSuite(p, setup_script)
        elif tm.isTestClassNode(p):
            test = tm.makeTestClass(p)
        else:
            test = None
        if test:
            suite.addTest(test)
            found = True
    if not found:
        print('No unit tests')
        sys.exit(1)
    runner = unittest.TextTestRunner(failfast=True, verbosity=1)
    try:
        result = runner.run(suite)
        if result.errors or result.failures:
            print(f"errors: {len(result.errors)}, failures: {len(result.failures)}")
            sys.exit(1)
        else:
            print('Travis unit tests all passed.')
            sys.exit(0)
    except Exception:
        print('Unexpected exception')
        g.es_exception()
        sys.exit(1)
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...', color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181030041436.1"></t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20181230071322.1">https://github.com/leo-editor/leo-editor/issues/1032
</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    raise IOError if p's path has changed *and* user forbids the write.
    '''
    at, c = self, self.c
    #
    # Suppress this message during save-as and save-to commands.
    if c.ignoreChangedPaths:
        return
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    try:  # #1367: samefile can throw an exception.
        changed = oldPath and not os.path.samefile(oldPath, newPath)
    except Exception:
        changed = True
    if not changed:
        return
    ok = at.promptForDangerousWrite(
        fileName=None,
        message=(
            f"{g.tr('path changed for %s' % (p.h))}\n"
            f"{g.tr('write this file anyway?')}"
        ),
    )
    if not ok:
        raise IOError
    at.setPathUa(p, newPath)  # Remember that we have changed paths.
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):

    if g.unitTesting:
        return
    if files:
        g.es('finished')
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    """Write an external file to a string, and return its contents."""
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20190111045822.1">def precheck(self, fileName, root):
    """
    Check whether a dirty, potentially dangerous, file should be written.
    
    Return True if so.  Return False *and* issue a warning otherwise.
    """
    at = self
    #
    # #1450: First, check that the directory exists.
    theDir = g.os_path_dirname(fileName)
    if theDir and not g.os_path_exists(theDir):
        at.error(f"Directory not found:\n{theDir}")
        return False
    #
    # Now check the file.
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName)
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    #
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
</t>
<t tx="ekr.20190122185223.1">@language text

Find all kwargs using regex:

^\s*(def\s+\w+\s*\(.*\=.*\))

found 1154 nodes

^\s*(def\s+\w+\s*\(.*\=.*\=.*\))

found 284 nodes
</t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190326034006.1">zoom_dict = {}  # Keys are key::settings_names, values are cumulative font size.

def find_font(self, key, setting_name):
    """
    Return the font for the given setting name.
    """
    c, get = self.c, self.c.config.get
    default_size = c.config.defaultBodyFontSize
    trace = False and not g.unitTesting  # and setting_name.startswith('php')
    for name in (setting_name, setting_name.rstrip('_font')):
        size_error = False
        family = get(name + '_family', 'family')
        size = get(name + '_size', 'size')
        slant = get(name + '_slant', 'slant')
        weight = get(name + '_weight', 'weight')
        if family or slant or weight or size:
            family = family or g.app.config.defaultFontFamily
            key = f"{key}::{setting_name}"
            if key in self.zoom_dict:
                old_size = self.zoom_dict.get(key)
            else:
                # It's a good idea to set size explicitly.
                old_size = size or default_size
                if trace: g.trace(
                    "STARTING SIZE", old_size, repr(size), default_size)
            if isinstance(old_size, str):
                # All settings should be in units of points.
                try:
                    if old_size.endswith(('pt', 'px'),):
                        old_size = int(old_size[:-2])
                    else:
                        old_size = int(old_size)
                except ValueError:
                    size_error = True
            elif not isinstance(old_size, int):
                size_error = True
            if size_error:
                g.trace('bad old_size:', old_size.__class__, old_size)
                size = old_size
            else:
                # #490: Use c.zoom_size if it exists.
                zoom_delta = getattr(c, 'zoom_delta', 0)
                if zoom_delta:
                    size = old_size + zoom_delta
                    self.zoom_dict[key] = size
            slant = slant or 'roman'
            weight = weight or 'normal'
            size = str(size)
            font = g.app.gui.getFontFromParams(family, size, slant, weight)
            # A good trace: the key shows what is happening.
            if font:
                if trace: g.trace(
                    f"key: {key:30} family: {family or 'None'} "
                    f"size: {size or 'None'} {slant} {weight}")
                return font
    return None
</t>
<t tx="ekr.20190402091335.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='4b8320485c0', # first keys commit
    rev2='2507a1fcc70', # Latest devel commit
    directory=None,
)
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190406193429.1" __node_tags="635f5f6275696c74696e5f5f0a7365740a7100285d7101580700000073657474696e677102617471035271042e"># Extra plugins, for this file only.

# Essential...
plugins_menu.py
free_layout.py
    # Now loaded automatically.
    # Disabled for testing bug 882824.
mod_scripting.py
viewrendered.py

# Testing only...
# nodetags.py
# python_terminal.py
# multifile.py
# livecode.py

# Others...
# bookmarks.py
# demo.py
# mod_http.py
# richtext.py

# Standard plugins

# backlink.py
# bigdash.py
# contextmenu.py
# line_numbering.py
# nav_qt.py
# nodetags.py
# quicksearch.py
# screen_capture.py
# todo.py
# valuespace.py
# xdb_pane.py
</t>
<t tx="ekr.20190410171646.1">@first # -*- coding: utf-8 -*-
'''
pyzo_support.py: Will probably be deleted.
'''
&lt;&lt; copyright &gt;&gt;
import leo.core.leoGlobals as g
assert g
@others
</t>
<t tx="ekr.20190410171905.1">def init():
    print('pyzo_support.py is not a real plugin')
    return False
</t>
<t tx="ekr.20190412042616.1">@
This file uses code from pyzo. Here is the pyzo copyright notice:

Copyright (C) 2013-2018, the Pyzo development team

Pyzo is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.

Yoton is distributed under the terms of the (new) BSD License.
The full license can be found in 'license.txt'.
</t>
<t tx="ekr.20190418161712.1">class PyzoInterface:
    '''
    A class representing the singleton running instance of pyzo.
    
    Instantiated in the top-level init() function.
    '''

    @others
</t>
<t tx="ekr.20190505173053.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1132

@language python
</t>
<t tx="ekr.20190506055928.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes
</t>
<t tx="ekr.20190506060857.1"></t>
<t tx="ekr.20190506061636.1"></t>
<t tx="ekr.20190607124533.1"></t>
<t tx="ekr.20190611095758.1"></t>
<t tx="ekr.20190803175344.1">def patch_pyzo(self):
    '''
    Called at the end of pyzo.start to embed Leo into pyzo.
    '''
</t>
<t tx="ekr.20190805022257.1">@first # -*- coding: utf-8 -*-
"""pyzo_file_browser.py: Experimental plugin that adds pyzo's file browser dock to Leo."""
&lt;&lt; pyzo_file_browser imports &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190809093446.1">import leo.core.leoGlobals as g
from leo.core.leoQt import QtCore
#
# Must patch sys.path here.
import sys
plugins_dir = g.os_path_finalize_join(g.app.loadDir, '..', 'plugins')
sys.path.insert(0, plugins_dir)
#
# Start pyzo, de-fanged.
import pyzo
# pylint: disable=no-member

</t>
<t tx="ekr.20190809093459.1"></t>
<t tx="ekr.20190809093459.3">init_warning_given = False

def init(): # pyzo_file_browser.py
    '''Return True if this plugin can be loaded.'''
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print('%s %s' % (__name__, message))
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
     if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    g.plugin_signon(__name__)
    g.registerHandler('after-create-leo-frame', onCreate)
    return True
</t>
<t tx="ekr.20190809093459.4">def onCreate(tag, keys): # pyzo_file_browser.py
    '''Create a pyzo file browser in c's outline.'''
    c = keys.get('c')
    dw = c and c.frame and c.frame.top
    if not dw:
        return
    pyzo.start_pyzo_in_leo(c, pyzo)
    from pyzo.tools.pyzoFileBrowser import PyzoFileBrowser
    make_dock(c,
        name="File Browser",
        widget=PyzoFileBrowser(parent=None),
    )
</t>
<t tx="ekr.20190813161639.1">@first # -*- coding: utf-8 -*-
"""pyzo_in_leo.py: Experimental plugin that adds all of pyzo's features to Leo."""
#
# Easy imports...
import leo.core.leoGlobals as g
from leo.core.leoQt import QtCore, QtGui, QtWidgets
import locale
import os
import sys
import threading

# pylint: disable=import-error
    # pylint doesn't know about the additions to sys.path.
        
# The pyzo global. Set by init()
pyzo = None

# The singleton PyzoController instance.
pyzo_controller = None

@others
@language python
@tabwidth -4
@nobeautify # Indentation of comments is important.
</t>
<t tx="ekr.20190813161639.4">init_warning_given = False

def init(): # pyzo_in_leo.py
    '''Return True if this plugin can be loaded.'''
    global pyzo

    from shutil import which
    
    def oops(message):
        global init_warning_given
        if not init_warning_given:
            init_warning_given = True
            print(f"\npyzo_in_leo not loaded: {message}\n")
            g.es('pyzo_in_leo', message, color='red')
        return False
        
    if g.app.gui.guiName() != "qt":
        return oops('requires Qt gui')
    if not getattr(g.app, 'dock'):
        return oops('requires Qt Docks')
    # #1643: This test will never fail now.
        # if not g.app.use_global_docks:
        #     return oops('requires --global-docks')
    #
    # Fail if can't find pyzo.exe.
    pyzo_exec = which('pyzo')
    if not pyzo_exec:
        return oops('can not find pyzo.exe')
    # Add pyzo/source to sys.path
    pyzo_dir = os.path.dirname(pyzo_exec)
    pyzo_source_dir = os.path.join(pyzo_dir, 'source')
    if pyzo_source_dir not in sys.path:
        sys.path.insert(0, pyzo_source_dir)
    # Fail if still can't import pyzo.
    try:
        import pyzo as local_pyzo
        pyzo = local_pyzo
    except ImportError:
        return oops(f"can not import pyzo from {pyzo_source_dir!r}")
    g.plugin_signon(__name__)
    #
    # This replaces MainWindow.closeEvent.
    g.app.pyzo_close_handler = close_handler
        # LeoApp.finishQuit calls this late in Leo's shutdown logic.
    g.registerHandler('after-create-leo-frame', onCreate) 
    return True
</t>
<t tx="ekr.20190813161921.1">def make_global_dock(self, name, widget):
    """Create a dock with the given name and widget in the global main window."""
    main_window = g.app.gui.main_window
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True, # Implies floatable.
        height=100,
        name=name,
    )
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    main_window.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190814050007.1">def make_dock(c, name, widget): # pyzo_file_browser.py
    """Create a dock with the given name and widget in c's main window."""
    dw = c.frame.top
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=100,
        name=name,
    )
    dw.leo_docks.append(dock)
    dock.setWidget(widget)
    area = QtCore.Qt.LeftDockWidgetArea
    dw.addDockWidget(area, dock)
    widget.show()
</t>
<t tx="ekr.20190814050859.1">def load_all_pyzo_docks(self):
    """
    Load all pyzo docks into the singleton QMainWindow.
    
    This code, included commented-out code, is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    assert pyzo.main == g.app.gui.main_window
    tm = pyzo.toolManager
    table = (
        'PyzoFileBrowser',
        'PyzoHistoryViewer',
        'PyzoInteractiveHelp',
        'PyzoLogger',
        'PyzoSourceStructure',
        'PyzoWebBrowser',
        'PyzoWorkspace',
    )
    for tool_id in table:
        tm.loadTool(tool_id)
        
    # EKR-change: old code.
        # # Load tools
        # if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
            # pyzo.toolManager.loadTool('pyzosourcestructure')
            # pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
        # elif pyzo.config.state.loadedTools:
            # for toolId in pyzo.config.state.loadedTools:
                # pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190816131343.1">def pyzo_start(self):
    """
    A copy of pyzo.start, adapted for Leo.
    
    Called at start2 time.  c is not available.
    
    This code is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    
    # Do some imports
    from pyzo.core import pyzoLogging  # to start logging asap
        # EKK: All print statements after this will appear in the Logger dock.
        # Unless we change pyzoLogging itself, this import will happen soon anyway.
    assert pyzoLogging

    # print('\nBEGIN pyzo_start\n')
    
    # EKR:change.
    # from pyzo.core.main import MainWindow

    # Apply users' preferences w.r.t. date representation etc
    for x in ('', 'C', 'en_US', 'en_US.utf8', 'en_US.UTF-8'):
        try:
            locale.setlocale(locale.LC_ALL, x)
            break
        except locale.Error:
            pass

    # Set to be aware of the systems native colors, fonts, etc.
    QtWidgets.QApplication.setDesktopSettingsAware(True)

    # EKR-change: the only remaining code from my_app_ctor.
    sys.argv = sys.argv[:1]
        # Instantiate the application.
        # QtWidgets.qApp = MyApp(sys.argv)
        # my_app_ctor(sys.argv)

    # EKR:change.
        # # Choose language, get locale
        # appLocale = setLanguage(config.settings.language)
    # EKR:change.
    # Create main window, using the selected locale
        # MainWindow(None, appLocale)
    self.main_window_ctor()

    # EKR:change.
        # Enter the main loop
        # QtWidgets.qApp.exec_()

    # print('END pyzo_start\n')
</t>
<t tx="ekr.20190816131753.1">def main_window_ctor(self):
    """
    Simulate MainWindow.__init__().
    
    This code, included commented-out code, is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """

    # print('\nBEGIN main_window_ctor\n')
    
    # EKR:change. New imports
    import pyzo.core.main as main
    from pyzo.core import commandline
    
    # EKR:change: was self.
    main_window = g.app.gui.main_window
    # EKR:change.
        # QtWidgets.QMainWindow.__init__(self, parent)

    main_window._closeflag = 0  # Used during closing/restarting

    # EKR:change.
        # # Init window title and application icon
        # self.setMainTitle()
    
    # EKR:change.
    main.loadAppIcons()
    pyzo.icon = g.app.gui.appIcon
    # Don't patch this now. It might be a good indicator.
    # pyzo.iconRunning = g.app.gui.appIcon
    
        # loadAppIcons()
    # EKR:change.
        # self.setWindowIcon(pyzo.icon)
    # EKR:change.
        # Restore window geometry.
        # self.resize(800, 600) # default size
        # self.restoreGeometry()
    # EKR:change.
        # Show splash screen (we need to set our color too)
        # w = SplashWidget(self, distro='no distro')
    # EKR:change.
        # self.setCentralWidget(w)
    # EKR:change.
       #  self.setStyleSheet("QMainWindow { background-color: #268bd2;}")

    # Show empty window and disable updates for a while

    # EKR:change.
        # self.show()
        # self.paintNow()
        # self.setUpdatesEnabled(False)
    # EKR:change.
        # Determine timeout for showing splash screen
        # splash_timeout = time.time() + 1.0
    # EKR:change.
        # Set locale of main widget, so that qt strings are translated
        # in the right way
        # if locale:
            # self.setLocale(locale)
  
    # Set pyzo.main.
    pyzo.main = main_window
    
    # EKR:change-Add do-nothing methods.
    pyzo.main.setMainTitle = g.TracingNullObject(tag='pyzo.main.setMainTitle()')
    pyzo.main.restart = g.TracingNullObject(tag='pyzo.main.restart()')

    # Init dockwidget settings
    main_window.setTabPosition(QtCore.Qt.AllDockWidgetAreas,QtWidgets.QTabWidget.South)
    main_window.setDockOptions(
        QtWidgets.QMainWindow.AllowNestedDocks |
        QtWidgets.QMainWindow.AllowTabbedDocks
        #|  QtWidgets.QMainWindow.AnimatedDocks
    )

    # Set window atrributes
    main_window.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips, True)

    # EKR:change.
    # Load icons and fonts
    main.loadIcons()
    main.loadFonts()
        # loadIcons()
        # loadFonts()

    # EKR:change.
        # # Set qt style and test success
        # self.setQtStyle(None) # None means init!
    # EKR:change.
        # # Hold the splash screen if needed
        # while time.time() &lt; splash_timeout:
            # QtWidgets.qApp.flush()
            # QtWidgets.qApp.processEvents()
            # time.sleep(0.05)
    # EKR:change.
    # Populate the window (imports more code)
    self.main_window_populate()
        # self._populate()
        
    # EKR:change: new code.
    self.load_all_pyzo_docks()

    # EKR:change.
    # Revert to normal background, and enable updates
    main_window.setStyleSheet('')
    main_window.setUpdatesEnabled(True)

    # EKR:change. Could this be a problem?
        # # Restore window state, force updating, and restore again
        # self.restoreState()
        # self.paintNow()
        # self.restoreState()

    # EKR:change.
        # Present user with wizard if he/she is new.
        # if pyzo.config.state.newUser:
            # from pyzo.util.pyzowizard import PyzoWizard
            # w = PyzoWizard(self)
            # w.show() # Use show() instead of exec_() so the user can interact with pyzo

    # EKR:change
        # # Create new shell config if there is None
        # if not pyzo.config.shellConfigs2:
            # from pyzo.core.kernelbroker import KernelInfo
            # pyzo.config.shellConfigs2.append( KernelInfo() )
    from pyzo.core.kernelbroker import KernelInfo
        # pyzo.config.shellConfigs2.append( KernelInfo() )
    pyzo.config.shellConfigs2 = [KernelInfo()]

    # EKR:change Set background.
        # bg = getattr(pyzo.config.settings, 'dark_background', '#657b83')
            # # Default: solarized base00
        # try:
            # self.setStyleSheet(f"background: {bg}") 
        # except Exception:
            # g.es_exception()

    # Focus on editor
    e = pyzo.editors.getCurrentEditor()
    if e is not None:
        e.setFocus()

    # Handle any actions
    commandline.handle_cmd_args()
    
    # print('END main_window_ctor\n')
</t>
<t tx="ekr.20190816132847.1">def main_window_populate(self):
    """
    Simulate MainWindow._populate().
    
    This code, included commented-out code, is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    # EKR:change: replaces self in most places.
    main_window = g.app.gui.main_window

    # print('\nBEGIN main_window_populate\n')
    
    # EKR:change-new imports
    from pyzo.core.main import callLater

    # Delayed imports
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager

    # Instantiate tool manager
    pyzo.toolManager = ToolManager()

    # EKR: Disabled in original.
        # Check to install conda now ...
        # from pyzo.util.bootstrapconda import check_for_conda_env
        # check_for_conda_env()

    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()

    # Create editor stack and make the central widget
    # EKR:change. Use None, not self.
    pyzo.editors = EditorTabs(None)
    
    # EKR:change. Create an Editors dock.
    self.make_global_dock('Editors', pyzo.editors)
        # self.setCentralWidget(pyzo.editors)

    # Create floater for shell
    # EKR:change: use a global *Leo* dock
    dock = g.app.gui.create_dock_widget(
        closeable=True,
        moveable=True,
        height=50,
        name='Shells',
    )
    # Old code
        # self._shellDock = dock = QtWidgets.QDockWidget(self)
        # if pyzo.config.settings.allowFloatingShell:
            # dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
        # else:
            # dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
        # dock.setWindowTitle('Shells')
    
    # EKR:change: Make the dock a *global* dock.
    main_window.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
        # self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)

    # Create shell stack
    # EKR:change. Use None, not self.
    
    # A hack: patch _get_interpreters_win
    if 1:
        import pyzo.util.interpreters as interps
        interps._get_interpreters_win = _get_interpreters_win

    pyzo.shells = ShellStackWidget(None)
    dock.setWidget(pyzo.shells)

    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')

    # Create the default shell when returning to the event queue
    callLater(pyzo.shells.addShell)

    # EKR:change.
    pyzo.status = None
    # Create statusbar
        # if pyzo.config.view.showStatusbar:
            # pyzo.status = self.statusBar()
        # else:
            # pyzo.status = None
            # self.setStatusBar(None)
            
    from pyzo.core import menu
    pyzo.keyMapper = menu.KeyMapper()
    
    # EKR:change: Monkey-patch pyzo.keyMapper.setShortcut.
    g.funcToMethod(setShortcut, pyzo.keyMapper.__class__)
    
    # EKR-change: init_pyzo_menu does this later.
        # # Add the context menu to the editor
        # pyzo.editors.addContextMenu()
        # pyzo.shells.addContextMenu()
            
    # print('END main_window_populate\n')
</t>
<t tx="ekr.20190816163728.1">def close_handler(): # pyzo_in_leo.py
    """
    Shut down pyzo.
    
    Called by Leo's shutdown logic when *all* outlines have been closed.
    
    This code is based on MainWindow.closeEvent.
    Copyright (C) 2013-2019 by Almar Klein.
    """

    print('\ng.app.pyzo_close_event\n')
    
    if 1: # EKR: change
    
        def do_nothing(*args, **kwargs):
            pass

        # We must zero this out. pyzo.saveConfig calls this.
        pyzo.main.saveWindowState = do_nothing
    
    # EKR:change-new imports
    from pyzo.core import commandline

    # Are we restaring?
    # restarting = time.time() - self._closeflag &lt; 1.0

    # EKR:change.
    if 1: # As in the original.
        # Save settings
        pyzo.saveConfig()
        pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    pyzo.editors.closeAll()
    
    # EKR:change.
        # # Force the close.
        # if not result:
            # self._closeflag = False
            # event.ignore()
            # return
        # self._closeflag = True

    # Proceed with closing shells
    if 1:
        # pylint: disable=no-member
        pyzo.localKernelManager.terminateAll()
    
    for shell in pyzo.shells:
        shell._context.close()

    if 1: # As in original.
        # Close tools
        for toolname in pyzo.toolManager.getLoadedTools():
            tool = pyzo.toolManager.getTool(toolname)
            tool.close()

    # Stop all threads (this should really only be daemon threads)
        # import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass

    # EKR:change. Not needed.
        # Proceed as normal
        # QtWidgets.QMainWindow.closeEvent(self, event)
    # EKR:change. Don't exit Leo!
        # if sys.version_info &gt;= (3,3,0): # and not restarting:
            # if hasattr(os, '_exit'):
                # os._exit(0)
</t>
<t tx="ekr.20190923170528.1">def doWindowSpotOption(self, options):

    # --window-spot
    spot = options.window_spot
    if spot:
        try:
            top, left = spot.split('x')
            spot = int(top), int(left)
        except ValueError:
            print('scanOptions: bad --window-spot:', spot)
            spot = None

    return spot
</t>
<t tx="ekr.20190928061911.1">def onCreate(tag, keys): # pyzo_in_leo.py
    """
    Init another commander, and pyzo itself if this is the first commander.
    """
    global pyzo_controller
    c = keys.get('c')
    if not c:
        return
    if not pyzo_controller:
        pyzo_controller = PyzoController()
        pyzo_controller.pyzo_start()
        main_window = g.app.gui.main_window
        main_window.setWindowTitle(c.frame.title)
    pyzo_controller.init_pyzo_menu(c)
</t>
<t tx="ekr.20190929180053.1">def init_pyzo_menu(self, c):
    """
    Add a Pyzo menu to c's menu bar.
    
    This code is based on pyzo.
    Copyright (C) 2013-2019 by Almar Klein.
    """
    dw = c.frame.top
    leo_menu_bar = dw.leo_menubar
        # Create the Pyzo menu in *Leo's* per-commander menu bar.
    menuBar = pyzo.main.menuBar()
        # Use *pyzo's* main menuBar to get data.

    # EKR:change-new imports.
    from pyzo import translate
    from pyzo.core.menu import EditMenu, FileMenu, SettingsMenu
        # Testing.
    from pyzo.core.menu import HelpMenu, RunMenu, ShellMenu, ViewMenu
        # Permanent.

    # EKR:change. Create a top-level Pyzo menu.
    pyzoMenu = leo_menu_bar.addMenu("Pyzo")
    menus = [
        # Testing only...
        FileMenu(menuBar, translate("menu", "File")),
        EditMenu(menuBar, translate("menu", "Edit")),
        SettingsMenu(menuBar, translate("menu", "Settings")),
        # Permanent...
        ViewMenu(menuBar, translate("menu", "View")),
        ShellMenu(menuBar, translate("menu", "Shell")),
        RunMenu(menuBar, translate("menu", "Run")),
        RunMenu(menuBar, translate("menu", "Tools")),
        HelpMenu(menuBar, translate("menu", "Help")),
    ]
    menuBar._menumap = {}
    menuBar._menus = menus
    for menu in menuBar._menus:
        pyzoMenu.addMenu(menu)
            # menuBar.addMenu(menu)
        menuName = menu.__class__.__name__.lower().split('menu')[0]
        menuBar._menumap[menuName] = menu

    # Enable tooltips
    def onHover(action):
        # This ugly bit of code makes sure that the tooltip is refreshed
        # (thus raised above the submenu). This happens only once and after
        # ths submenu has become visible.
        if action.menu():
            if not hasattr(menuBar, '_lastAction'):
                menuBar._lastAction = None
                menuBar._haveRaisedTooltip = False
            if action is menuBar._lastAction:
                if ((not menuBar._haveRaisedTooltip) and
                            action.menu().isVisible()):
                    QtWidgets.QToolTip.hideText()
                    menuBar._haveRaisedTooltip = True
            else:
                menuBar._lastAction = action
                menuBar._haveRaisedTooltip = False
        # Set tooltip
        tt = action.statusTip()
        if hasattr(action, '_shortcutsText'):
            tt = tt + ' ({})'.format(action._shortcutsText) # Add shortcuts text in it
        QtWidgets.QToolTip.showText(QtGui.QCursor.pos(), tt)

    menuBar.hovered.connect(onHover)

    if not self.menus_inited:
        self.menus_inited = True
        pyzo.editors.addContextMenu()
        pyzo.shells.addContextMenu()
</t>
<t tx="ekr.20190930051034.1">class PyzoController:
    
    menus_inited = False
    
    @others
</t>
<t tx="ekr.20190930051422.1"></t>
<t tx="ekr.20191001084541.1"></t>
<t tx="ekr.20191001084612.1">def zoom_helper(event, delta):
    """
    Common helper for zoom commands.
    """
    c = event.get('c')
    if not c:
        return
    wrapper = c.frame.body.wrapper
    #
    # For performance, don't c.styleSheetManager.reload_style_sheets().
    # Apply to body widget directly
    c._style_deltas['font-size-body'] += delta
    ssm = c.styleSheetManager
    sheet = ssm.expand_css_constants(c.active_stylesheet)
    wrapper.widget.setStyleSheet(sheet)
    #
    # #490: Honor language-specific settings.
    colorizer = getattr(c.frame.body, 'colorizer', None)
    if not colorizer:
        return
    c.zoom_delta = delta
    colorizer.configure_fonts()
    wrapper.setAllText(wrapper.getAllText())
        # Recolor everything.
</t>
<t tx="ekr.20191001084646.1">@g.command("zoom-out")
def zoom_out(event=None):
    """decrease body font size by one

    @font-size-body must be present in the stylesheet
    """
    # zoom_in(event=event, delta=-1)
    zoom_helper(event=event, delta=-1)
</t>
<t tx="ekr.20191012093236.1">def _get_interpreters_win():  # pyzo_in_leo.py
    """
    Monkey-patch pyzo/util/interpreters._get_interpreters_win.

    This patched code fixes an apparent pyzo bug.
    
    Unlike shutil.which, this function returns all plausible python executables.

    Copyright (C) 2013-2019 by Almar Klein.
    """

    import pyzo.util.interpreters as interps ### EKR
    
    found = []

    # Query from registry
    for v in interps.get_interpreters_in_reg(): ### EKR
        found.append(v.installPath() )

    # Check common locations
    for rootname in ['C:/', '~/',
                     'C:/program files/', 'C:/program files (x86)/', 'C:/ProgramData/',
                     '~/appdata/local/programs/python/',
                     '~/appdata/local/continuum/', '~/appdata/local/anaconda/',
                     ]:
        rootname = os.path.expanduser(rootname)
        if not os.path.isdir(rootname):
            continue
        for dname in os.listdir(rootname):
            if dname.lower().startswith(('python', 'pypy', 'miniconda', 'anaconda')):
                found.append(os.path.join(rootname, dname))

    # Normalize all paths, and remove trailing backslashes
    
    ### found = [os.path.normcase(os.path.abspath(v)).strip('\\') for v in found]
    found = [
        os.path.normcase(os.path.abspath(v)).strip('\\') for v in found
            if v is not None ### EKR: Add guard.
    ]

    # Append "python.exe" and check if that file exists
    found2 = []
    for dname in found:
        for fname in ('python.exe', 'pypy.exe'):
            exename = os.path.join(dname, fname)
            if os.path.isfile(exename):
                found2.append(exename)
                break

    # Returnas set (remove duplicates)
    return set(found2)
</t>
<t tx="ekr.20191012094334.1">def setShortcut(self, action): # pyzo_in_leo.py
    """A do-nothing, monkey-patched, version of KeyMapper.setShortcut."""
    pass
</t>
<t tx="ekr.20191021002252.1">
(base) c:\leo.repo\leo-editor&gt;mypy leo\core\runLeo.py

leo\external\__init__.py:3: error: Need type annotation for '__all__' (hint: "__all__: List[&lt;type&gt;] = ...")

leo\external\codewise.py:100: error: Cannot find module named '__builtin__'
leo\external\codewise.py:100: error: Name 'builtins' already defined (by an import)

leo\core\leoGlobals.py:34: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:39: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:43: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoGlobals.py:309: error: Need type annotation for 'tree_popup_handlers' (hint: "tree_popup_handlers: List[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:310: error: Need type annotation for 'user_dict' (hint: "user_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2088: error: Need type annotation for 'tracing_signatures' (hint: "tracing_signatures: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoGlobals.py:2600: error: No library stub file for module 'PyQt5'
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoGlobals.py:2603: note: (Stub files are from https://github.com/python/typeshed)
leo\core\leoGlobals.py:2603: error: No library stub file for module 'PyQt4'
leo\core\leoGlobals.py:2702: error: No library stub file for module 'pylint'
leo\core\leoGlobals.py:2770: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2771: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:2772: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:5261: error: Need type annotation for 'childrenModifiedSet' (hint: "childrenModifiedSet: Set[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:5262: error: Need type annotation for 'contentModifiedSet' (hint: "contentModifiedSet: Set[&lt;type&gt;] = ...")
leo\core\leoGlobals.py:5767: error: Need type annotation for 'checkUnicode_dict' (hint: "checkUnicode_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:5925: error: Need type annotation for 'unicode_warnings' (hint: "unicode_warnings: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6814: error: Need type annotation for 'init_zodb_failed' (hint: "init_zodb_failed: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6815: error: Need type annotation for 'init_zodb_db' (hint: "init_zodb_db: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoGlobals.py:6829: error: Cannot find module named 'ZODB'
leo\core\leoGlobals.py:6829: note: See https://mypy.readthedocs.io/en/latest/running_mypy.html#missing-imports
leo\core\leoGlobals.py:6964: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[&lt;type&gt;] = ...")

leo\plugins\importers\ipynb.py:7: error: No library stub file for module 'nbformat'

leo\core\leoVim.py:2054: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2058: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2062: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2075: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2080: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2088: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2093: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2097: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2102: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2106: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2110: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2121: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2141: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2147: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2155: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2160: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"
leo\core\leoVim.py:2167: error: Argument 1 to "cmd" has incompatible type "str"; expected "VimCommands"

leo\core\leoUndo.py:1162: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"
leo\core\leoUndo.py:1441: error: Argument 1 to "cmd" has incompatible type "str"; expected "Undoer"

leo\core\leoFind.py:304: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:327: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:489: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:495: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:505: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:517: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:526: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:587: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:600: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:609: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:624: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:639: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:654: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:669: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:865: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:866: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:867: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:894: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:895: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:896: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:924: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:925: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:952: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:961: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:972: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:978: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1083: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1090: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1107: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1115: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1133: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1158: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1259: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1266: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1279: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1287: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1292: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1297: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1302: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1307: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1312: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1317: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1322: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1333: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1343: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1355: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"
leo\core\leoFind.py:1411: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFind"

leo\core\leoFind.py:2211: error: Need type annotation for 'debugIndices' (hint: "debugIndices: List[&lt;type&gt;] = ...")

leo\core\leoDebugger.py:75: error: No library stub file for standard library module 'bdb'

leo\commands\checkerCommands.py:12: error: No library stub file for module 'flake8'
leo\commands\checkerCommands.py:16: error: No library stub file for module 'pyflakes'
leo\commands\checkerCommands.py:487: error: No library stub file for module 'pylint'

leo\core\leoChapters.py:94: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:110: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"
leo\core\leoChapters.py:119: error: Argument 1 to "cmd" has incompatible type "str"; expected "ChapterController"

leo\core\leoBeautify.py:11: error: Cannot find module named 'leoGlobals'
leo\core\leoBeautify.py:11: error: Name 'g' already defined (by an import)
leo\core\leoBeautify.py:18: error: Incompatible types in assignment (expression has type "Callable[[Any], Any]", variable has type "Type[Command]")
leo\core\leoBeautify.py:31: error: Cannot find module named 'black'

leo\core\leoIPython.py:35: error: Cannot find module named 'ipykernel.connect'
leo\core\leoIPython.py:40: error: Cannot find module named 'ipykernel.kernelapp'
leo\core\leoIPython.py:45: error: "None" has no attribute "ipython_inited"

leo\core\leoNodes.py:326: error: Incompatible types in assignment (expression has type "None", base class "object" defined the type as "Callable[[object], int]")

leo\core\leoQt.py:27: error: No library stub file for module 'PyQt5'
leo\core\leoQt.py:31: error: No library stub file for module 'PyQt4'
leo\core\leoQt.py:52: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:53: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:54: error: Name 'QtWidgets' already defined on line 44
leo\core\leoQt.py:55: error: No library stub file for module 'PyQt5.QtCore'
leo\core\leoQt.py:55: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:56: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:57: error: "None" has no attribute "Qt"
leo\core\leoQt.py:65: error: Name 'QtCore' already defined on line 44
leo\core\leoQt.py:66: error: Name 'QtGui' already defined on line 44
leo\core\leoQt.py:67: error: No library stub file for module 'PyQt4.QtCore'
leo\core\leoQt.py:67: error: Name 'QUrl' already defined on line 44
leo\core\leoQt.py:68: error: Name 'Signal' already defined on line 49
leo\core\leoQt.py:82: error: "None" has no attribute "QT_VERSION_STR"
leo\core\leoQt.py:92: error: "None" has no attribute "QString"
leo\core\leoQt.py:96: error: No library stub file for module 'PyQt5.QtDeclarative'
leo\core\leoQt.py:96: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:100: error: No library stub file for module 'PyQt5.phonon'
leo\core\leoQt.py:100: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:101: error: "None" has no attribute "Phonon"
leo\core\leoQt.py:105: error: Name 'QtMultimedia' already defined on line 45
leo\core\leoQt.py:109: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:113: error: No library stub file for module 'PyQt5.QtSvg'
leo\core\leoQt.py:113: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:117: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:121: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:125: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:129: error: No library stub file for module 'PyQt5.QtWebKitWidgets'
leo\core\leoQt.py:129: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:135: error: No library stub file for module 'PyQt5.QtWebEngineWidgets'
leo\core\leoQt.py:135: error: Name 'QtWebKitWidgets' already defined on line 45
leo\core\leoQt.py:136: error: "None" has no attribute "QWebView"
leo\core\leoQt.py:136: error: "None" has no attribute "QWebEngineView"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebSettings"
leo\core\leoQt.py:137: error: "None" has no attribute "QWebEngineSettings"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebPage"
leo\core\leoQt.py:138: error: "None" has no attribute "QWebEnginePage"
leo\core\leoQt.py:143: error: "None" has no attribute "QString"
leo\core\leoQt.py:147: error: No library stub file for module 'PyQt4.QtDeclarative'
leo\core\leoQt.py:147: error: Name 'QtDeclarative' already defined on line 45
leo\core\leoQt.py:153: error: No library stub file for module 'PyQt4.phonon'
leo\core\leoQt.py:153: error: Name 'phonon' already defined on line 46
leo\core\leoQt.py:154: error: Item "None" of "Optional[Any]" has no attribute "Phonon"
leo\core\leoQt.py:158: error: Name 'Qsci' already defined on line 45
leo\core\leoQt.py:162: error: No library stub file for module 'PyQt4.QtSvg'
leo\core\leoQt.py:162: error: Name 'QtSvg' already defined on line 45
leo\core\leoQt.py:166: error: Name 'uic' already defined on line 46
leo\core\leoQt.py:170: error: Name 'QtWebKit' already defined on line 45
leo\core\leoQt.py:174: error: No library stub file for module 'PyQt4.QtWebKit'
leo\core\leoQt.py:174: error: Name 'QtWebKitWidgets' already defined on line 45

leo\core\leoCheck.py:1457: error: Need type annotation for 'assigns_d' (hint: "assigns_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1458: error: Need type annotation for 'calls_d' (hint: "calls_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1459: error: Need type annotation for 'classes_d' (hint: "classes_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1460: error: Need type annotation for 'defs_d' (hint: "defs_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:1461: error: Need type annotation for 'returns_d' (hint: "returns_d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoCheck.py:2047: error: Need type annotation for 'd' (hint: "d: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\nested_splitter.py:9: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\nested_splitter.py:26: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:51: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:108: error: Name 'QtWidgets.QWidget' is not defined
leo\plugins\nested_splitter.py:130: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\nested_splitter.py:391: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\editpane\clicky_splitter.py:13: error: Name 'QtWidgets.QSplitterHandle' is not defined
leo\plugins\editpane\clicky_splitter.py:25: error: Name 'QtWidgets.QSplitter' is not defined

leo\plugins\qt_text.py:416: error: Name 'QtWidgets.QFrame' is not defined
leo\plugins\qt_text.py:454: error: Name 'QtWidgets.QTextBrowser' is not defined
leo\plugins\qt_text.py:485: error: Name 'QtWidgets.QListWidget' is not defined
leo\plugins\qt_text.py:744: error: Name 'QtWidgets.QFrame' is not defined

leo\core\leoColorizer.py:23: error: No library stub file for module 'pygments'
leo\core\leoColorizer.py:339: error: Need type annotation for 'zoom_dict' (hint: "zoom_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2325: error: Name 'QtGui.QSyntaxHighlighter' is not defined
leo\core\leoColorizer.py:2457: error: No library stub file for module 'pygments.styles'
leo\core\leoColorizer.py:2492: error: Name 'Qsci.QsciLexerCustom' is not defined
leo\core\leoColorizer.py:2588: error: Need type annotation for 'traced_dict' (hint: "traced_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2618: error: Need type annotation for 'format_dict' (hint: "format_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2620: error: Need type annotation for 'lexers_dict' (hint: "lexers_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2622: error: Need type annotation for 'state_s_dict' (hint: "state_s_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2624: error: Need type annotation for 'state_n_dict' (hint: "state_n_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoColorizer.py:2690: error: No library stub file for module 'pygments.token'
leo\core\leoColorizer.py:2711: error: No library stub file for module 'pygments.lexers'
leo\core\leoColorizer.py:2730: error: No library stub file for module 'pygments.lexer'
leo\core\leoColorizer.py:3044: error: Name 'QtGui.QTextBlockUserData' is not defined
leo\core\leoColorizer.py:3064: error: Cannot assign to a type
leo\core\leoColorizer.py:3064: error: Incompatible types in assignment (expression has type "Type[NullObject]", variable has type "Type[PygmentsBlockUserData]")

leo\core\leoRst.py:20: error: "None" has no attribute "debug"
leo\core\leoRst.py:25: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:35: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:37: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:40: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:45: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:50: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoRst.py:54: error: Cannot find module named 'SilverCity'
leo\core\leoRst.py:86: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "arguments"
leo\core\leoRst.py:92: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:97: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "content"
leo\core\leoRst.py:101: error: "Callable[[Any, Any, Any, Any, Any, Any, Any, Any, Any], Any]" has no attribute "options"
leo\core\leoRst.py:306: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"
leo\core\leoRst.py:501: error: Argument 1 to "cmd" has incompatible type "str"; expected "RstCommands"

leo\core\leoPrinting.py:97: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:103: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:112: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:118: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:127: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:134: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:145: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:152: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:159: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:165: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:172: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:182: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:188: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:197: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:203: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:212: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:219: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:230: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:237: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:243: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:249: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"
leo\core\leoPrinting.py:258: error: Argument 1 to "cmd" has incompatible type "str"; expected "PrintingController"

leo\core\leoImport.py:16: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoImport.py:22: error: No library stub file for module 'lxml.html'
leo\core\leoImport.py:22: error: No library stub file for module 'lxml'

leo\core\leoFileCommands.py:1802: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1810: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1822: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"
leo\core\leoFileCommands.py:1829: error: Argument 1 to "cmd" has incompatible type "str"; expected "FileCommands"

leo\core\leoKeys.py:196: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:218: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:223: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:229: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:235: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:241: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:247: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:253: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:259: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:274: error: Argument 1 to "cmd" has incompatible type "str"; expected "AutoCompleterClass"
leo\core\leoKeys.py:538: error: Cannot find module named 'jedi'
leo\core\leoKeys.py:2335: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2477: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2551: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2581: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2602: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2623: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2632: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2641: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2650: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:2797: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3935: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"
leo\core\leoKeys.py:3943: error: Argument 1 to "cmd" has incompatible type "str"; expected "KeyHandlerClass"

leo\commands\spellCommands.py:15: error: Cannot find module named 'enchant'
leo\commands\convertCommands.py:1598: error: No library stub file for module 'nbformat'

leo\core\leoAtFile.py:239: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:971: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:979: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:987: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:996: error: Argument 1 to "cmd" has incompatible type "str"; expected "AtFile"
leo\core\leoAtFile.py:2306: error: No library stub file for standard library module 'parser'

leo\core\leoCommands.py:20: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoCommands.py:736: error: Cannot find module named '_pytest.config'
leo\core\leoCommands.py:737: error: Cannot find module named '_pytest.assertion.rewrite'
leo\core\leoCommands.py:1990: error: Need type annotation for 'deprecated_messages' (hint: "deprecated_messages: List[&lt;type&gt;] = ...")

leo\core\leoApp.py:1036: error: Cannot find module named 'flexx'
leo\core\leoApp.py:1443: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1444: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1591: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"
leo\core\leoApp.py:1592: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoApp"

leo\plugins\editpane\editpane.py:10: error: Cannot find module named 'OpenGL'
leo\plugins\editpane\editpane.py:66: error: Name 'QtWidgets.QWidget' is not defined

leo\core\leoFrame.py:905: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:926: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:962: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1030: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"
leo\core\leoFrame.py:1044: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoFrame"

leo\core\runLeo.py:17: error: Argument 1 to "join" has incompatible type "Optional[str]"; expected "Union[str, _PathLike[str]]"
leo\core\runLeo.py:28: error: Incompatible types in assignment (expression has type "LeoApp", variable has type "None")

leo\plugins\mod_scripting.py:459: error: Cannot find module named 'rpdb2'
leo\plugins\mod_scripting.py:504: error: Cannot find module named 'leo.core.leoScriptModule'
leo\plugins\mod_scripting.py:1204: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1240: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1295: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1319: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"
leo\plugins\mod_scripting.py:1338: error: Argument 1 to "cmd" has incompatible type "str"; expected "EvalController"

leo\plugins\qt_events.py:46: error: Name 'QtCore.QObject' is not defined

leo\core\leoTest.py:27: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\core\leoTest.py:1711: error: Need type annotation for 'lastObjectsDict' (hint: "lastObjectsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoTest.py:1712: error: Need type annotation for 'lastTypesDict' (hint: "lastTypesDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoTest.py:1713: error: Need type annotation for 'lastFunctionsDict' (hint: "lastFunctionsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\cursesGui2.py:39: error: Cannot assign to a type
leo\plugins\cursesGui2.py:39: error: Incompatible types in assignment (expression has type "None", variable has type "Type[Tk]")
leo\plugins\cursesGui2.py:48: error: Incompatible types in assignment (expression has type "None", variable has type Module)
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen.utilNotify'
leo\plugins\cursesGui2.py:58: error: Cannot find module named 'npyscreen'
leo\plugins\cursesGui2.py:60: error: Cannot find module named 'npyscreen.wgwidget'
leo\plugins\cursesGui2.py:73: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:208: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:299: error: Name 'npyscreen.TreeData' is not defined
leo\plugins\cursesGui2.py:479: error: Name 'npyscreen.TreeLine' is not defined
leo\plugins\cursesGui2.py:699: error: Name 'npyscreen.MiniButtonPress' is not defined
leo\plugins\cursesGui2.py:1823: error: Need type annotation for 'set_focus_fail' (hint: "set_focus_fail: List[&lt;type&gt;] = ...")
leo\plugins\cursesGui2.py:2328: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreFrame"
leo\plugins\cursesGui2.py:2397: error: Argument 1 to "cmd" has incompatible type "str"; expected "CoreLog"
leo\plugins\cursesGui2.py:2724: error: Name 'npyscreen.NPSApp' is not defined
leo\plugins\cursesGui2.py:2741: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:2955: error: Name 'npyscreen.MultiLineEditable' is not defined
leo\plugins\cursesGui2.py:3103: error: Name 'npyscreen.Form' is not defined
leo\plugins\cursesGui2.py:3117: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3276: error: Name 'npyscreen.Textfield' is not defined
leo\plugins\cursesGui2.py:3290: error: Name 'npyscreen.MLTree' is not defined
leo\plugins\cursesGui2.py:3952: error: Name 'npyscreen.TreeData' is not defined

leo\plugins\qt_frame.py:27: error: Cannot determine type of 'enabled'
leo\plugins\qt_frame.py:31: error: Cannot assign multiple types to name "splitter_class" without an explicit "Type[...]" annotation
leo\plugins\qt_frame.py:31: error: "None" has no attribute "QSplitter"
leo\plugins\qt_frame.py:38: error: Name 'QtWidgets.QMainWindow' is not defined
leo\plugins\qt_frame.py:1503: error: Name 'QtWidgets.QTabWidget' is not defined
leo\plugins\qt_frame.py:1737: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1738: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1793: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:1794: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtBody"
leo\plugins\qt_frame.py:2490: error: Need type annotation for 'styleSheetCache' (hint: "styleSheetCache: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\plugins\qt_frame.py:3010: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3022: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3038: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3047: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3063: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3077: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3093: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtFrame"
leo\plugins\qt_frame.py:3321: error: Argument 1 to "cmd" has incompatible type "str"; expected "LeoQtLog"
leo\plugins\qt_frame.py:3923: error: Name 'QtWidgets.QTreeWidget' is not defined
leo\plugins\qt_frame.py:4632: error: Name 'QtWidgets.QTabBar' is not defined
leo\plugins\qt_frame.py:4647: error: Name 'QtWidgets.QMenu' is not defined

leo\core\leoConfig.py:37: error: Need type annotation for 'settingsDict' (hint: "settingsDict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")
leo\core\leoConfig.py:2043: error: Need type annotation for 'no_menu_dict' (hint: "no_menu_dict: Dict[&lt;type&gt;, &lt;type&gt;] = ...")

leo\plugins\leoflexx.py:39: error: Cannot find module named 'flexx'
leo\plugins\leoflexx.py:40: error: Cannot find module named 'pscript'
leo\plugins\leoflexx.py:1186: error: Need type annotation for 'attributes' (hint: "attributes: Set[&lt;type&gt;] = ...")

leo\plugins\qt_gui.py:618: error: Cannot find module named 'pyzo'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core.menu'
leo\plugins\qt_gui.py:619: error: Cannot find module named 'pyzo.core'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools.pyzoFileBrowser'
leo\plugins\qt_gui.py:622: error: Cannot find module named 'pyzo.tools'
leo\plugins\qt_gui.py:627: error: Cannot find module named 'pyzo.core.main'
leo\plugins\qt_gui.py:989: error: Need type annotation for 'size_warnings' (hint: "size_warnings: List[&lt;type&gt;] = ...")
leo\plugins\qt_gui.py:1349: error: Name 'QtWidgets.QMessageBox' is not defined
leo\plugins\qt_gui.py:1487: error: No library stub file for module 'PyQt5.QtTest'
leo\plugins\qt_gui.py:1491: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1492: error: "None" has no attribute "QObject"
leo\plugins\qt_gui.py:1493: error: "None" has no attribute "QObject"

Found 360 errors in 40 files (checked 1 source file)
</t>
<t tx="ekr.20191029023442.1">@language rest
@wrap

A tutorial: (learn by doing: teacher guides)
    is learning-oriented
    allows the newcomer to get started
    is a lesson
    
A how-to guide: (recipe: users ask questions)
    is goal-oriented
    shows how to solve a specific problem
    is a series of steps

A reference guide:
    is information-oriented
    describes the machinery
    is accurate and complete

An explanation/discussion
    is understanding-oriented
    explains
    provides background and context</t>
<t tx="ekr.20191113063144.1">class TokenOrderGenerator:
    """
    A class that traverses ast (parse) trees in token order.
    
    Overview: https://github.com/leo-editor/leo-editor/issues/1440#issue-522090981
    
    Theory of operation:
    - https://github.com/leo-editor/leo-editor/issues/1440#issuecomment-573661883
    - http://leoeditor.com/appendices.html#tokenorder-classes-theory-of-operation
    
    How to: http://leoeditor.com/appendices.html#tokenorder-class-how-to
    
    Project history: https://github.com/leo-editor/leo-editor/issues/1440#issuecomment-574145510
    """

    n_nodes = 0  # The number of nodes that have been visited.
    @others
</t>
<t tx="ekr.20191113063144.13"></t>
<t tx="ekr.20191113063144.14"></t>
<t tx="ekr.20191113063144.15"># AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_AsyncFunctionDef(self, node):

    if node.decorator_list:
        for z in node.decorator_list:
            # '@%s\n'
            yield from self.gen_op('@')
            yield from self.gen(z)
    # 'asynch def (%s): -&gt; %s\n'
    # 'asynch def %s(%s):\n'
    async_token_type = 'async' if use_async_tokens else 'name'
    yield from self.gen_token(async_token_type, 'async')
    yield from self.gen_name('def')
    yield from self.gen_name(node.name)  # A string
    yield from self.gen_op('(')
    yield from self.gen(node.args)
    yield from self.gen_op(')')
    returns = getattr(node, 'returns', None)
    if returns is not None:
        yield from self.gen_op('-&gt;')
        yield from self.gen(node.returns)
    yield from self.gen_op(':')
    self.level += 1
    yield from self.gen(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.16">def do_ClassDef(self, node, print_body=True):

    for z in node.decorator_list or []:
        # @{z}\n
        yield from self.gen_op('@')
        yield from self.gen(z)
    # class name(bases):\n
    yield from self.gen_name('class')
    yield from self.gen_name(node.name)  # A string.
    if node.bases:
        yield from self.gen_op('(')
        yield from self.gen(node.bases)
        yield from self.gen_op(')')
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.17"># FunctionDef(
#   identifier name, arguments args,
#   stmt* body,
#   expr* decorator_list,
#   expr? returns,
#   string? type_comment)

def do_FunctionDef(self, node):

    # Guards...
    returns = getattr(node, 'returns', None)
    # Decorators...
        # @{z}\n
    for z in node.decorator_list or []:
        yield from self.gen_op('@')
        yield from self.gen(z)
    # Signature...
        # def name(args): -&gt; returns\n
        # def name(args):\n
    yield from self.gen_name('def')
    yield from self.gen_name(node.name)  # A string.
    yield from self.gen_op('(')
    yield from self.gen(node.args)
    yield from self.gen_op(')')
    if returns is not None:
        yield from self.gen_op('-&gt;')
        yield from self.gen(node.returns)
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.18">def do_Interactive(self, node):  # pragma: no cover

    yield from self.gen(node.body)
</t>
<t tx="ekr.20191113063144.19">def do_Module(self, node):

    # Encoding is a non-syncing statement.
    yield from self.gen(node.body)
</t>
<t tx="ekr.20191113063144.20">def do_Lambda(self, node):

    yield from self.gen_name('lambda')
    yield from self.gen(node.args)
    yield from self.gen_op(':')
    yield from self.gen(node.body)
</t>
<t tx="ekr.20191113063144.21"></t>
<t tx="ekr.20191113063144.22">def do_Expr(self, node):
    """An outer expression."""
    # No need to put parentheses.
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.23">def do_Expression(self, node):  # pragma: no cover
    """An inner expression."""
    # No need to put parentheses.
    yield from self.gen(node.body)
</t>
<t tx="ekr.20191113063144.24">def do_GeneratorExp(self, node):

    # '&lt;gen %s for %s&gt;' % (elt, ','.join(gens))
    # No need to put parentheses or commas.
    yield from self.gen(node.elt)
    yield from self.gen_name('for')
    yield from self.gen(node.generators)
</t>
<t tx="ekr.20191113063144.26"></t>
<t tx="ekr.20191113063144.27">#arguments = (
#       arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
#       expr* kw_defaults, arg? kwarg, expr* defaults
#   )

def do_arguments(self, node):

    """Arguments to ast.Function or ast.Lambda, **not** ast.Call."""

    # No need to generate commas anywhere below.
    n_plain = len(node.args) - len(node.defaults)
    # Add the plain arguments.
    i = 0
    while i &lt; n_plain:
        yield from self.gen(node.args[i])
        i += 1
    # Add the arguments with defaults.
    j = 0
    while i &lt; len(node.args) and j &lt; len(node.defaults):
        yield from(self.gen(node.args[i]))
        yield from self.gen_op('=')
        yield from self.gen(node.defaults[j])
        i += 1
        j += 1
    assert i == len(node.args)
    assert j == len(node.defaults)
    # Add the vararg and kwarg expressions.
    vararg = getattr(node, 'vararg', None)
    if vararg is not None:
        yield from self.gen_op('*')
        yield from self.gen(vararg)
    kwarg = getattr(node, 'kwarg', None)
    if kwarg is not None:
        yield from self.gen_op('**')
        yield from self.gen(kwarg)
</t>
<t tx="ekr.20191113063144.28"># arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    """This is one argument of a list of ast.Function or ast.Lambda arguments."""
    yield from self.gen_name(node.arg)
    annotation = getattr(node, 'annotation', None)
    if annotation is not None:
        yield from self.gen_op(':')
        yield from self.gen(node.annotation)
</t>
<t tx="ekr.20191113063144.29"># Attribute(expr value, identifier attr, expr_context ctx)

def do_Attribute(self, node):

    yield from self.gen(node.value)
    yield from self.gen_op('.')
    yield from self.gen_name(node.attr)  # A string.
</t>
<t tx="ekr.20191113063144.3">begin_end_stack = []
node_index = 0  # The index into the node_stack.
node_stack = []  # The stack of parent nodes.

def begin_visitor(self, node):
    """Enter a visitor."""
    # Update the stats.
    self.n_nodes += 1
    # Do this first, *before* updating self.node.
    node.parent = self.node
    if self.node:
        children = getattr(self.node, 'children', [])
        children.append(node)
        self.node.children = children
    # Inject the node_index field.
    assert not hasattr(node, 'node_index'), g.callers()
    node.node_index = self.node_index
    self.node_index += 1
    # begin_visitor and end_visitor must be paired.
    self.begin_end_stack.append(node.__class__.__name__)
    # Push the previous node.
    self.node_stack.append(self.node)
    # Update self.node *last*.
    self.node = node
</t>
<t tx="ekr.20191113063144.30">def do_Bytes(self, node):

    """
    It's invalid to mix bytes and non-bytes literals, so just
    advancing to the next 'string' token suffices.
    """
    token = self.find_next_significant_token()
    yield from self.gen_token('string', token.value)
</t>
<t tx="ekr.20191113063144.31"># Call(expr func, expr* args, keyword* keywords)

# Python 3 ast.Call nodes do not have 'starargs' or 'kwargs' fields.

def do_Call(self, node):

    # The calls to gen_op(')') and gen_op('(') do nothing by default.
    # Subclasses might handle them in an overridden tog.set_links.
    yield from self.gen(node.func)
    yield from self.gen_op('(')
    # No need to generate any commas.
    yield from self.handle_call_arguments(node)
    yield from self.gen_op(')')
</t>
<t tx="ekr.20191113063144.32"># keyword arguments supplied to call (NULL identifier for **kwargs)

# keyword = (identifier? arg, expr value)

def do_keyword(self, node):  # pragma: no cover
    """A keyword arg in an ast.Call."""
    filename = getattr(self, 'filename', '&lt;no file&gt;')
    raise AssignLinksError(
        f"file: {filename}\n"
        f"do_keyword should never be called")

    # if node.arg:
        # yield from self.gen_name(node.arg)
        # yield from self.gen_op('=')
        # yield from self.gen(node.value)
    # else:
        # yield from self.gen_op('**')
        # yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.33"># comprehension = (expr target, expr iter, expr* ifs, int is_async)

def do_comprehension(self, node):

    # No need to put parentheses.
    yield from self.gen(node.target)  # A name
    yield from self.gen_name('in')
    yield from self.gen(node.iter)
    for z in node.ifs or []:
        yield from self.gen_name('if')
        yield from self.gen(z)
</t>
<t tx="ekr.20191113063144.34">def do_Constant(self, node):  # pragma: no cover
    """
    
    https://greentreesnakes.readthedocs.io/en/latest/nodes.html
    
    A constant. The value attribute holds the Python object it represents.
    This can be simple types such as a number, string or None, but also
    immutable container types (tuples and frozensets) if all of their
    elements are constant.
    """
    
    # Support Python 3.8.
    if node.value is None or isinstance(node.value, bool):
        # Weird: return a name!
        yield from self.gen_token('name', repr(node.value))  
    elif node.value == Ellipsis:
        yield from self.gen_op('...')
    elif isinstance(node.value, str):
        yield from self.do_Str(node)
    elif isinstance(node.value, (int, float)):
        yield from self.gen_token('number', repr(node.value))
    elif isinstance(node.value, bytes):
        yield from self.do_Bytes(node)
    elif isinstance(node.value, tuple):
        yield from self.do_Tuple(node)
    elif isinstance(node.value, frozenset):
        yield from self.do_Set(node)
    else:
        # Unknown type.
        g.trace('----- Oops -----', repr(node.value), g.callers())
</t>
<t tx="ekr.20191113063144.35"># Dict(expr* keys, expr* values)

def do_Dict(self, node):

    assert len(node.keys) == len(node.values)
    yield from self.gen_op('{')
    # No need to put commas.
    for i, key in enumerate(node.keys):
        key, value = node.keys[i], node.values[i]
        yield from self.gen(key)  # a Str node.
        yield from self.gen_op(':')
        if value is not None:
            yield from self.gen(value)
    yield from self.gen_op('}')
</t>
<t tx="ekr.20191113063144.36"># DictComp(expr key, expr value, comprehension* generators)

# d2 = {val: key for key, val in d.iteritems()}

def do_DictComp(self, node):

    yield from self.gen_token('op', '{')
    yield from self.gen(node.key)
    yield from self.gen_op(':')
    yield from self.gen(node.value)
    for z in node.generators or []:
        yield from self.gen_name('for')
        yield from self.gen(z)
        yield from self.gen_token('op', '}')
</t>
<t tx="ekr.20191113063144.37">def do_Ellipsis(self, node): # pragma: no cover (Does not exist for python 3.8+)

    yield from self.gen_op('...')
</t>
<t tx="ekr.20191113063144.38"># https://docs.python.org/3/reference/expressions.html#slicings

# ExtSlice(slice* dims)

def do_ExtSlice(self, node):

    # ','.join(node.dims)
    for i, z in enumerate(node.dims):
        yield from self.gen(z)
        if i &lt; len(node.dims) - 1:
            yield from self.gen_op(',')
</t>
<t tx="ekr.20191113063144.39"># FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node):  # pragma: no cover
    """
    This node represents the *components* of a *single* f-string.
    
    Happily, JoinedStr nodes *also* represent *all* f-strings,
    so the TOG should *never visit this node!
    """
    filename = getattr(self, 'filename', '&lt;no file&gt;')
    raise AssignLinksError(
        f"file: {filename}\n"
        f"do_FormattedValue should never be called")

    # This code has no chance of being useful...

        # conv = node.conversion
        # spec = node.format_spec
        # yield from self.gen(node.value)
        # if conv is not None:
            # yield from self.gen_token('number', conv)
        # if spec is not None:
            # yield from self.gen(node.format_spec)
</t>
<t tx="ekr.20191113063144.4">def create_links(self, tokens, tree, file_name=''):
    """
    A generator creates two-way links between the given tokens and ast-tree.
    
    Callers should call this generator with list(tog.create_links(...))
    
    The sync_tokens method creates the links and verifies that the resulting
    tree traversal generates exactly the given tokens in exact order.
    
    tokens: the list of Token instances for the input.
            Created by make_tokens().
    tree:   the ast tree for the input.
            Created by parse_ast().
    """
    #
    # Init all ivars.
    self.file_name = file_name
        # For tests.
    self.level = 0
        # Python indentation level.
    self.node = None
        # The node being visited.
        # The parent of the about-to-be visited node.
    self.tokens = tokens
        # The immutable list of input tokens.
    self.tree = tree
        # The tree of ast.AST nodes.
    #
    # Traverse the tree.
    try:
        while True:
            next(self.visitor(tree))
    except StopIteration:
        pass
    #
    # Ensure that all tokens are patched.
    self.node = tree
    yield from self.gen_token('endmarker', '')
</t>
<t tx="ekr.20191113063144.40">def do_Index(self, node):

    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.41"># JoinedStr(expr* values)

def do_JoinedStr(self, node):
    """
    JoinedStr nodes represent at least one f-string and all other strings
    concatentated to it.
    
    Analyzing JoinedStr.values would be extremely tricky, for reasons that
    need not be explained here.
    
    Instead, we get the tokens *from the token list itself*!
    """
    for z in self.get_concatenated_string_tokens():
        yield from self.gen_token(z.kind, z.value)
</t>
<t tx="ekr.20191113063144.42">def do_List(self, node):

    # No need to put commas.
    yield from self.gen_op('[')
    yield from self.gen(node.elts)
    yield from self.gen_op(']')
</t>
<t tx="ekr.20191113063144.43"># ListComp(expr elt, comprehension* generators)

def do_ListComp(self, node):

    yield from self.gen_op('[')
    yield from self.gen(node.elt)
    for z in node.generators:
        yield from self.gen_name('for')
        yield from self.gen(z)
    yield from self.gen_op(']')
</t>
<t tx="ekr.20191113063144.44">def do_Name(self, node):

    yield from self.gen_name(node.id)

def do_NameConstant(self, node):  # pragma: no cover (Does not exist in Python 3.8+)

    yield from self.gen_name(repr(node.value))

</t>
<t tx="ekr.20191113063144.45">def do_Num(self, node):  # pragma: no cover (Does not exist in Python 3.8+)

    yield from self.gen_token('number', node.n)
</t>
<t tx="ekr.20191113063144.47"># Set(expr* elts)

def do_Set(self, node):

    yield from self.gen_op('{')
    yield from self.gen(node.elts)
    yield from self.gen_op('}')
</t>
<t tx="ekr.20191113063144.48"># SetComp(expr elt, comprehension* generators)

def do_SetComp(self, node):

    yield from self.gen_op('{')
    yield from self.gen(node.elt)
    for z in node.generators or []:
        yield from self.gen_name('for')
        yield from self.gen(z)
    yield from self.gen_op('}')
</t>
<t tx="ekr.20191113063144.49"># slice = Slice(expr? lower, expr? upper, expr? step)

def do_Slice(self, node):

    lower = getattr(node, 'lower', None)
    upper = getattr(node, 'upper', None)
    step = getattr(node, 'step', None)
    if lower is not None:
        yield from self.gen(lower)
    # Always put the colon between upper and lower.
    yield from self.gen_op(':')
    if upper is not None:
        yield from self.gen(upper)
    # Put the second colon if it exists in the token list.
    if step is None:
        token = self.find_next_significant_token()
        if token and token.value == ':':
            yield from self.gen_op(':')
    else:
        yield from self.gen_op(':')
        yield from self.gen(step)
</t>
<t tx="ekr.20191113063144.50">def do_Str(self, node):
    """This node represents a string constant."""
    # This loop is necessary to handle string concatenation.
    for z in self.get_concatenated_string_tokens():
        yield from self.gen_token(z.kind, z.value)
</t>
<t tx="ekr.20191113063144.51"># Subscript(expr value, slice slice, expr_context ctx)

def do_Subscript(self, node):

    yield from self.gen(node.value)
    yield from self.gen_op('[')
    yield from self.gen(node.slice)
    yield from self.gen_op(']')
</t>
<t tx="ekr.20191113063144.52"># Tuple(expr* elts, expr_context ctx)

def do_Tuple(self, node):

    # Do not call gen_op for parens or commas here.
    # They do not necessarily exist in the token list!
    yield from self.gen(node.elts)
</t>
<t tx="ekr.20191113063144.53"></t>
<t tx="ekr.20191113063144.55">def do_BinOp(self, node):

    op_name_ = op_name(node.op)
    yield from self.gen(node.left)
    yield from self.gen_op(op_name_)
    yield from self.gen(node.right)
</t>
<t tx="ekr.20191113063144.56"># BoolOp(boolop op, expr* values)

def do_BoolOp(self, node):

    # op.join(node.values)
    op_name_ = op_name(node.op)
    for i, z in enumerate(node.values):
        yield from self.gen(z)
        if i &lt; len(node.values) - 1:
            yield from self.gen_name(op_name_)
</t>
<t tx="ekr.20191113063144.57"># Compare(expr left, cmpop* ops, expr* comparators)

def do_Compare(self, node):

    assert len(node.ops) == len(node.comparators)
    yield from self.gen(node.left)
    for i, z in enumerate(node.ops):
        op_name_ = op_name(node.ops[i])
        if op_name_ in ('not in', 'is not'):
            for z in op_name_.split(' '):
                yield from self.gen_name(z)
        elif op_name_.isalpha():
            yield from self.gen_name(op_name_)
        else:
            yield from self.gen_op(op_name_)
        yield from self.gen(node.comparators[i])
</t>
<t tx="ekr.20191113063144.58">def do_UnaryOp(self, node):

    op_name_ = op_name(node.op)
    if op_name_.isalpha():
        yield from self.gen_name(op_name_)
    else:
        yield from self.gen_op(op_name_)
    yield from self.gen(node.operand)
</t>
<t tx="ekr.20191113063144.59"># IfExp(expr test, expr body, expr orelse)

def do_IfExp(self, node):

    #'%s if %s else %s'
    yield from self.gen(node.body)
    yield from self.gen_name('if')
    yield from self.gen(node.test)
    yield from self.gen_name('else')
    yield from self.gen(node.orelse)
</t>
<t tx="ekr.20191113063144.60"></t>
<t tx="ekr.20191113063144.61"># AnnAssign(expr target, expr annotation, expr? value, int simple)

def do_AnnAssign(self, node):

    # {node.target}:{node.annotation}={node.value}\n'
    yield from self.gen(node.target)
    yield from self.gen_op(':')
    yield from self.gen(node.annotation)
    yield from self.gen_op('=')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.62"># Assert(expr test, expr? msg)

def do_Assert(self, node):

    # Guards...
    msg = getattr(node, 'msg', None)
    # No need to put parentheses or commas.
    yield from self.gen_name('assert')
    yield from self.gen(node.test)
    if msg is not None:
        yield from self.gen(node.msg)
</t>
<t tx="ekr.20191113063144.63">def do_Assign(self, node):

    for z in node.targets:
        yield from self.gen(z)
        yield from self.gen_op('=')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.64">def do_AsyncFor(self, node):

    # The def line...
    # Py 3.8 changes the kind of token.
    async_token_type = 'async' if use_async_tokens else 'name'
    yield from self.gen_token(async_token_type, 'async')
    yield from self.gen_name('for')
    yield from self.gen(node.target)
    yield from self.gen_name('in')
    yield from self.gen(node.iter)
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    # Else clause...
    if node.orelse:
        yield from self.gen_name('else')
        yield from self.gen_op(':')
        yield from self.gen(node.orelse)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.65">def do_AsyncWith(self, node):

    async_token_type = 'async' if use_async_tokens else 'name'
    yield from self.gen_token(async_token_type, 'async')
    yield from self.do_With(node)
</t>
<t tx="ekr.20191113063144.66"># AugAssign(expr target, operator op, expr value)

def do_AugAssign(self, node):

    # %s%s=%s\n'
    op_name_ = op_name(node.op)
    yield from self.gen(node.target)
    yield from self.gen_op(op_name_ + '=')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.67"># Await(expr value)

def do_Await(self, node):

    #'await %s\n'
    async_token_type = 'await' if use_async_tokens else 'name'
    yield from self.gen_token(async_token_type, 'await')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.68">def do_Break(self, node):

    yield from self.gen_name('break')
</t>
<t tx="ekr.20191113063144.69">def do_Continue(self, node):

    yield from self.gen_name('continue')
</t>
<t tx="ekr.20191113063144.7">px = -1  # Index of the previously synced token.

def sync_token(self, kind, val):
    """
    Sync to a token whose kind &amp; value are given. The token need not be
    significant, but it must be guaranteed to exist in the token list.
    
    The checks in this method constitute a strong, ever-present, unit test.
    
    Scan the tokens *after* px, looking for a token T matching (kind, val).
    raise AssignLinksError if a significant token is found that doesn't match T.
    Otherwise:
    - Create two-way links between all assignable tokens between px and T.
    - Create two-way links between T and self.node.
    - Advance by updating self.px to point to T.
    """
    trace = False
    node, tokens = self.node, self.tokens
    assert isinstance(node, ast.AST), repr(node)
    if trace: g.trace(
        f"px: {self.px:2} "
        f"node: {node.__class__.__name__:&lt;10} "
        f"kind: {kind:&gt;10}: val: {val!r}")
    #
    # Step one: Look for token T.
    old_px = px = self.px + 1
    while px &lt; len(self.tokens):
        token = tokens[px]
        if (kind, val) == (token.kind, token.value):
            break  # Success.
        if kind == token.kind == 'number':
            val = token.value
            break  # Benign: use the token's value, a string, instead of a number.
        if is_significant_token(token):  # pragma: no cover
            line_s = f"line {token.line_number}:"
            raise AssignLinksError(
                f"       file: {self.filename}\n"
                f"{line_s:&gt;12} {token.line.strip()}\n"
                f"Looking for: {kind}.{g.truncate(val, 40)!r}\n"
                f"      found: {token.kind}.{token.value!r}\n"
                f"token.index: {token.index}\n")
        # Skip the insignificant token.
        px += 1
    else:  # pragma: no cover
        raise AssignLinksError(
             f"       file: {self.filename}\n"
             f"Looking for: {kind}.{g.truncate(val, 40)}\n"
             f"      found: end of token list")
    #
    # Step two: Assign *secondary* links only for newline tokens.
    #           Ignore all other non-significant tokens.
    while old_px &lt; px:
        token = tokens[old_px]
        old_px += 1
        if token.kind in ('comment', 'newline', 'nl'):
            self.set_links(node, token)
    #
    # Step three: Set links in the found token.
    token = tokens[px]
    self.set_links(node, token)
    #
    # Step four: Advance.
    self.px = px
</t>
<t tx="ekr.20191113063144.70">def do_Delete(self, node):

    # No need to put commas.
    yield from self.gen_name('del')
    yield from self.gen(node.targets)
</t>
<t tx="ekr.20191113063144.71">def do_ExceptHandler(self, node):

    # Except line...
    yield from self.gen_name('except')
    if getattr(node, 'type', None):
        yield from self.gen(node.type)
    if getattr(node, 'name', None):
        yield from self.gen_name('as')
        yield from self.gen_name(node.name)
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.73">def do_For(self, node):

    # The def line...
    yield from self.gen_name('for')
    yield from self.gen(node.target)
    yield from self.gen_name('in')
    yield from self.gen(node.iter)
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    # Else clause...
    if node.orelse:
        yield from self.gen_name('else')
        yield from self.gen_op(':')
        yield from self.gen(node.orelse)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.74"># Global(identifier* names)

def do_Global(self, node):

    yield from self.gen_name('global')
    for z in node.names:
        yield from self.gen_name(z)
</t>
<t tx="ekr.20191113063144.75"># If(expr test, stmt* body, stmt* orelse)

def do_If(self, node):
    &lt;&lt; do_If docstring &gt;&gt;
    # Use the next significant token to distinguish between 'if' and 'elif'.
    token = self.find_next_significant_token()
    yield from self.gen_name(token.value)
    yield from self.gen(node.test)
    yield from self.gen_op(':')
    #
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    self.level -= 1
    #
    # Else and elif clauses...
    if node.orelse:
        self.level += 1
        token = self.find_next_significant_token()
        if token.value == 'else':
            yield from self.gen_name('else')
            yield from self.gen_op(':')
            yield from self.gen(node.orelse)
        else:
            yield from self.gen(node.orelse)
        self.level -= 1
</t>
<t tx="ekr.20191113063144.76">def do_Import(self, node):

    yield from self.gen_name('import')
    for alias in node.names:
        yield from self.gen_name(alias.name)
        if alias.asname:
            yield from self.gen_name('as')
            yield from self.gen_name(alias.asname)
</t>
<t tx="ekr.20191113063144.77"># ImportFrom(identifier? module, alias* names, int? level)

def do_ImportFrom(self, node):

    yield from self.gen_name('from')
    for i in range(node.level):
        yield from self.gen_op('.')
    if node.module:
        yield from self.gen_name(node.module)
    yield from self.gen_name('import')
    # No need to put commas.
    for alias in node.names:
        yield from self.gen_name(alias.name)
        if alias.asname:
            yield from self.gen_name('as')
            yield from self.gen_name(alias.asname)
</t>
<t tx="ekr.20191113063144.78"># Nonlocal(identifier* names)

def do_Nonlocal(self, node):

    # nonlocal %s\n' % ','.join(node.names))
    # No need to put commas.
    yield from self.gen_name('nonlocal')
    for z in node.names:
        yield from self.gen_name(z)
</t>
<t tx="ekr.20191113063144.79">def do_Pass(self, node):

    yield from self.gen_name('pass')
</t>
<t tx="ekr.20191113063144.81"># Raise(expr? exc, expr? cause)

def do_Raise(self, node):

    # No need to put commas.
    yield from self.gen_name('raise')
    exc = getattr(node, 'exc', None)
    cause = getattr(node, 'cause', None)
    tback = getattr(node, 'tback', None)
    yield from self.gen(exc)
    yield from self.gen(cause)
    yield from self.gen(tback)
</t>
<t tx="ekr.20191113063144.82">def do_Return(self, node):

    yield from self.gen_name('return')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.83"># Starred(expr value, expr_context ctx)

def do_Starred(self, node):
    """A starred argument to an ast.Call"""
    yield from self.gen_op('*')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.85"># Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)

def do_Try(self, node):

    # Try line...
    yield from self.gen_name('try')
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    yield from self.gen(node.handlers)
    # Else...
    if node.orelse:
        yield from self.gen_name('else')
        yield from self.gen_op(':')
        yield from self.gen(node.orelse)
    # Finally...
    if node.finalbody:
        yield from self.gen_name('finally')
        yield from self.gen_op(':')
        yield from self.gen(node.finalbody)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.88">def do_While(self, node):

    # While line...
        # while %s:\n'
    yield from self.gen_name('while')
    yield from self.gen(node.test)
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    # Else clause...
    if node.orelse:
        yield from self.gen_name('else')
        yield from self.gen_op(':')
        yield from self.gen(node.orelse)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.89"># With(withitem* items, stmt* body)

# withitem = (expr context_expr, expr? optional_vars)

def do_With(self, node):

    expr = getattr(node, 'context_expression', None)
    items = getattr(node, 'items', [])
    yield from self.gen_name('with')
    yield from self.gen(expr)
    # No need to put commas.
    for item in items:
        yield from self.gen(item.context_expr)
        optional_vars = getattr(item, 'optional_vars', None)
        if optional_vars is not None:
            yield from self.gen_name('as')
            yield from self.gen(item.optional_vars)
    # End the line.
    yield from self.gen_op(':')
    # Body...
    self.level += 1
    yield from self.gen(node.body)
    self.level -= 1
</t>
<t tx="ekr.20191113063144.90">def do_Yield(self, node):

    yield from self.gen_name('yield')
    if hasattr(node, 'value'):
        yield from self.gen(node.value)
</t>
<t tx="ekr.20191113063144.91"># YieldFrom(expr value)

def do_YieldFrom(self, node):

    yield from self.gen_name('yield')
    yield from self.gen_name('from')
    yield from self.gen(node.value)
</t>
<t tx="ekr.20191113081443.1">def visitor(self, node):
    """Given an ast node, return a *generator* from its visitor."""
    # This saves a lot of tests.
    trace = False
    if node is None:
        return
    if trace:
        # Keep this trace. It's useful.
        cn = node.__class__.__name__ if node else ' '
        caller1, caller2 = g.callers(2).split(',')
        g.trace(f"{caller1:&gt;15} {caller2:&lt;14} {cn}")
    # More general, more convenient.
    if isinstance(node, (list, tuple)):
        for z in node or []:
            if isinstance(z, ast.AST):
                yield from self.visitor(z)
            else:  # pragma: no cover
                # Some fields may contain ints or strings.
                assert isinstance(z, (int, str)), z.__class__.__name__
        return
    # We *do* want to crash if the visitor doesn't exist.
    method = getattr(self, 'do_' + node.__class__.__name__)
    # Allow begin/end visitor to be generators.
    self.begin_visitor(node)
    yield from method(node)
    self.end_visitor(node)
</t>
<t tx="ekr.20191121180100.1"># Useful wrappers...

def gen(self, z):
    yield from self.visitor(z)

def gen_name(self, val):
    yield from self.visitor(self.sync_name(val))

def gen_op(self, val):
    yield from self.visitor(self.sync_op(val))

def gen_token(self, kind, val):
    yield from self.visitor(self.sync_token(kind, val))
</t>
<t tx="ekr.20191122222412.1">"""
The parse trees for the following are identical!

  if 1:            if 1:
      pass             pass
  else:            elif 2:
      if 2:            pass
          pass
          
So there is *no* way for the 'if' visitor to disambiguate the above two
cases from the parse tree alone.

Instead, we scan the tokens list for the next 'if', 'else' or 'elif' token.
"""
</t>
<t tx="ekr.20191124083124.1"># It's valid for these to return None.

def sync_name(self, val):
    aList = val.split('.')
    if len(aList) == 1:
        self.sync_token('name', val)
    else:
        for i, part in enumerate(aList):
            self.sync_token('name', part)
            if i &lt; len(aList) - 1:
                self.sync_op('.')

def sync_op(self, val):
    """
    Sync to the given operator.
    
    val may be '(' or ')' *only* if the parens *will* actually exist in the
    token list.
    """
    self.sync_token('op', val)
</t>
<t tx="ekr.20191125120814.1">last_statement_node = None

def set_links(self, node, token):
    """Make two-way links between token and the given node."""
    # Don't bother assigning comment, comma, parens, ws and endtoken tokens.
    if token.kind == 'comment':
        # Append the comment to node.comment_list.
        comment_list = getattr(node, 'comment_list', [])
        node.comment_list = comment_list + [token]
        return
    if token.kind in ('endmarker', 'ws'):
        return
    if token.kind == 'op' and token.value in ',()':
        return
    # *Always* remember the last statement.
    statement = find_statement_node(node)
    if statement:
        self.last_statement_node = statement
        assert not isinstance(self.last_statement_node, ast.Module)
    if token.node is not None:  # pragma: no cover
        line_s = f"line {token.line_number}:"
        raise AssignLinksError(
                f"       file: {self.filename}\n"
                f"{line_s:&gt;12} {token.line.strip()}\n"
                f"token index: {self.px}\n"
                f"token.node is not None\n"
                f" token.node: {token.node.__class__.__name__}\n"
                f"    callers: {g.callers()}")
    # Assign newlines to the previous statement node, if any.
    if token.kind in ('newline', 'nl'):
        # Set an *auxilliary* link for the split/join logic.
        # Do *not* set token.node!
        token.statement_node = self.last_statement_node
        return
    if is_significant_token(token):
        # Link the token to the ast node.
        token.node = node
        # Add the token to node's token_list.
        add_token_to_token_list(token, node)
</t>
<t tx="ekr.20191204105506.1">def handle_call_arguments(self, node):
    """
    Generate arguments in the correct order.
    
    See https://docs.python.org/3/reference/expressions.html#calls.
    
    This is similar to tog.do_arguments.
    
    At present, this code assumes the standard order:
    
    positional args, then keyword args, then * arg the ** kwargs.
    """
    trace = False
    #
    # Filter the * arg from args.
    args = [z for z in node.args or [] if not isinstance(z, ast.Starred)]
    star_arg = [z for z in node.args or [] if isinstance(z, ast.Starred)]
    #
    # Filter the ** kwarg arg from keywords.
    keywords = [z for z in node.keywords or [] if z.arg]
    kwarg_arg = [z for z in node.keywords or [] if not z.arg]
    if trace:
        &lt;&lt; trace the ast.Call arguments &gt;&gt;
        print('')
    #
    # Add the plain arguments.
    for z in args:
        yield from self.arg_helper(z)
    #
    # Add the keyword args.
    for z in keywords:
        yield from self.arg_helper(z.arg)
        yield from self.gen_op('=')
        yield from self.arg_helper(z.value)
    # Add the * arg.
    if star_arg:
        assert len(star_arg) == 1
        star = star_arg[0]
        assert isinstance(star, ast.Starred)
        yield from self.arg_helper(star)
    # Add the kwarg.
    if kwarg_arg:
        assert len(kwarg_arg) == 1
        kwarg = kwarg_arg[0]
        assert isinstance(kwarg, ast.keyword)
        yield from self.gen_op('**')
        yield from self.gen(kwarg.value)
</t>
<t tx="ekr.20191204113843.1">def show_fields(node):
    class_name = 'None' if node is None else node.__class__.__name__
    return AstDumper().show_fields(class_name, node, 40)

# Let block.

arg_fields = ', '.join([show_fields(z) for z in args])
keyword_fields = ', '.join([show_fields(z) for z in keywords])
star_field = show_fields(star_arg[0]) if star_arg else 'None'
kwarg_field = show_fields(kwarg_arg[0]) if kwarg_arg else 'None'
# Print.
print(
    f"\nhandle_call_args...\n\n"
    f"    args: {arg_fields!s}\n"
    f"keywords: {keyword_fields!s}\n"
    f"    star: {star_field!s}\n"
    f"   kwarg: {kwarg_field!s}")
</t>
<t tx="ekr.20191204114930.1">def arg_helper(self, node):
    """
    Yield the node, with a special case for strings.
    """
    if 0:
        g.trace(AstDumper().show_fields(node.__class__.__name__, node, 40))

    if isinstance(node, str):
        yield from self.gen_token('name', node)
    else:
        yield from self.gen(node)
</t>
<t tx="ekr.20191206073301.1">@language rest
@wrap

@clean and @auto may not always be updated reliably

https://github.com/leo-editor/leo-editor/issues/1451

#1361 may be the culprit
https://github.com/leo-editor/leo-editor/issues/1361

*** --trace=write

@language python
</t>
<t tx="ekr.20191207065251.1"></t>
<t tx="ekr.20191223052749.1"></t>
<t tx="ekr.20191226195813.1">class TokenOrderTraverser:
    """
    Traverse an ast tree using the parent/child links created by the
    TokenOrderInjector class.
    """
    @others
</t>
<t tx="ekr.20191226200154.1">def traverse(self, tree):
    """
    Call visit, in token order, for all nodes in tree.
    
    Recursion is not allowed.
    
    The code follows p.moveToThreadNext exactly.
    """

    def has_next(i, node, stack):
        """Return True if stack[i] is a valid child of node.parent."""
        # g.trace(node.__class__.__name__, stack)
        parent = node.parent
        return parent and parent.children and i &lt; len(parent.children)

    # Update stats

    self.last_node_index = -1  # For visit
    # The stack contains child indices.
    node, stack = tree, [0]
    seen = set()
    while node and stack:
        if False: g.trace(
            f"{node.node_index:&gt;3} "
            f"{node.__class__.__name__:&lt;12} {stack}")
        # Visit the node.
        assert node.node_index not in seen, node.node_index
        seen.add(node.node_index)
        self.visit(node)
        # if p.v.children: p.moveToFirstChild()
        children = getattr(node, 'children', [])
        if children:
            # Move to the first child.
            stack.append(0)
            node = children[0]
            # g.trace(' child:', node.__class__.__name__, stack)
            continue
        # elif p.hasNext(): p.moveToNext()
        stack[-1] += 1
        i = stack[-1]
        if has_next(i, node, stack):
            node = node.parent.children[i]
            continue
        # else...
        # p.moveToParent()
        node = node.parent
        stack.pop()
        # while p:
        while node and stack:
            # if p.hasNext():
            stack[-1] += 1
            i = stack[-1]
            if has_next(i, node, stack):
                # Move to the next sibling.
                node = node.parent.children[i]
                break  # Found.
            # p.moveToParent()
            node = node.parent
            stack.pop()
        # not found.
        else:
            break   # pragma: no cover 
    return self.last_node_index
</t>
<t tx="ekr.20191227160547.1">def visit(self, node):

    self.last_node_index += 1
    assert self.last_node_index == node.node_index, (
        self.last_node_index, node.node_index)
</t>
<t tx="ekr.20191227170628.1"></t>
<t tx="ekr.20191228184647.1">def balance_tokens(self, tokens):
    """
    TOG.balance_tokens.
    
    Insert two-way links between matching paren tokens.
    """
    count, stack = 0, []
    for token in tokens:
        if token.kind == 'op':
            if token.value == '(':
                count += 1
                stack.append(token.index)
            if token.value == ')':
                if stack:
                    index = stack.pop()
                    tokens[index].matching_paren = token.index
                    tokens[token.index].matching_paren = index
                else:
                    g.trace(f"unmatched ')' at index {token.index}")
    # g.trace(f"tokens: {len(tokens)} matched parens: {count}")
    if stack:
        g.trace("unmatched '(' at {','.join(stack)}")
    return count
</t>
<t tx="ekr.20191229071733.1">def init_from_file(self, filename):  # pragma: no cover
    """
    Create the tokens and ast tree for the given file.
    Create links between tokens and the parse tree.
    Return (contents, encoding, tokens, tree).
    """
    self.level = 0
    self.filename = filename
    encoding, contents = read_file_with_encoding(filename)
    if contents is None:
        return None, None, None, None
    self.tokens = tokens = make_tokens(contents)
    self.tree = tree = parse_ast(contents)
    list(self.create_links(tokens, tree))
    return contents, encoding, tokens, tree
</t>
<t tx="ekr.20191229071746.1">def init_from_string(self, contents, filename):  # pragma: no cover
    """
    Tokenize, parse and create links in the contents string.
    
    Return (tokens, tree).
    """
    self.filename = filename
    self.level = 0
    self.tokens = tokens = make_tokens(contents)
    self.tree = tree = parse_ast(contents)
    list(self.create_links(tokens, tree))
    return tokens, tree
</t>
<t tx="ekr.20200103174914.1"></t>
<t tx="ekr.20200104032811.1">def end_visitor(self, node):
    """Leave a visitor."""
    # begin_visitor and end_visitor must be paired.
    entry_name = self.begin_end_stack.pop()
    assert entry_name == node.__class__.__name__, f"{entry_name!r} {node.__class__.__name__}"
    assert self.node == node, (repr(self.node), repr(node))
    # Restore self.node.
    self.node = self.node_stack.pop()
</t>
<t tx="ekr.20200107165250.1">class Orange:
    """
    A flexible and powerful beautifier for Python.
    Orange is the new black.
    
    *Important*: This is a predominantly a *token*-based beautifier.
    However, orange.colon and orange.possible_unary_op use the parse
    tree to provide context that would otherwise be difficult to
    deduce.
    """
    # This switch is really a comment. It will always be false.
    # It marks the code that simulates the operation of the black tool.
    black_mode = False

    # Patterns...
    nobeautify_pat = re.compile(r'\s*#\s*pragma:\s*no\s*beautify\b|#\s*@@nobeautify')

    # Patterns from FastAtRead class, specialized for python delims.
    node_pat = re.compile(r'^(\s*)#@\+node:([^:]+): \*(\d+)?(\*?) (.*)$')  # @node
    start_doc_pat = re.compile(r'^\s*#@\+(at|doc)?(\s.*?)?$')  # @doc or @
    at_others_pat = re.compile(r'^(\s*)#@(\+|-)others\b(.*)$')  # @others

    # Doc parts end with @c or a node sentinel. Specialized for python.
    end_doc_pat = re.compile(r"^\s*#@(@(c(ode)?)|([+]node\b.*))$")
    @others
</t>
<t tx="ekr.20200107165250.13"></t>
<t tx="ekr.20200107165250.14">in_doc_part = False

def do_comment(self):
    """Handle a comment token."""
    val = self.val
    #
    # Leo-specific code...
    if self.node_pat.match(val):
        # Clear per-node state.
        self.in_doc_part = False
        self.verbatim = False
        self.decorator_seen = False
        # Do *not clear other state, which may persist across @others.
            # self.curly_brackets_level = 0
            # self.in_arg_list = 0
            # self.level = 0
            # self.lws = ''
            # self.paren_level = 0
            # self.square_brackets_stack = []
            # self.state_stack = []
    else:
        # Keep track of verbatim mode.
        if self.beautify_pat.match(val):
            self.verbatim = False
        elif self.nobeautify_pat.match(val):
            self.verbatim = True
        # Keep trace of @doc parts, to honor the convention for splitting lines.
        if self.start_doc_pat.match(val):
            self.in_doc_part = True
        if self.end_doc_pat.match(val):
            self.in_doc_part = False
    #
    # General code: Generate the comment.
    self.clean('blank')
    entire_line = self.line.lstrip().startswith('#')
    if entire_line:
        self.clean('hard-blank')
        self.clean('line-indent')
        # #1496: No further munging needed.
        val = self.line.rstrip()
    else:
        # Exactly two spaces before trailing comments.
        val = '  ' + self.val.rstrip()
    self.add_token('comment', val)
</t>
<t tx="ekr.20200107165250.15">def do_encoding(self):
    """
    Handle the encoding token.
    """
    pass
</t>
<t tx="ekr.20200107165250.16">def do_endmarker(self):
    """Handle an endmarker token."""
    # Ensure exactly one blank at the end of the file.
    self.clean_blank_lines()
    self.add_token('line-end', '\n')
</t>
<t tx="ekr.20200107165250.18">def do_dedent(self):
    """Handle dedent token."""
    self.level -= 1
    self.lws = self.level * self.tab_width * ' '
    self.line_indent()
    if self.black_mode:  # pragma: no cover (black)
        state = self.state_stack[-1]
        if state.kind == 'indent' and state.value == self.level:
            self.state_stack.pop()
            state = self.state_stack[-1]
            if state.kind in ('class', 'def'):
                self.state_stack.pop()
                self.handle_dedent_after_class_or_def(state.kind)

def do_indent(self):
    """Handle indent token."""
    new_indent = self.val
    old_indent = self.level * self.tab_width * ' '
    if new_indent &gt; old_indent:
        self.level += 1
    elif new_indent &lt; old_indent:  # pragma: no cover (defensive)
        g.trace('\n===== can not happen', repr(new_indent), repr(old_indent))
    self.lws = new_indent
    self.line_indent()
</t>
<t tx="ekr.20200107165250.2">def __init__(self, settings=None):
    """Ctor for Orange class."""
    if settings is None:
        settings = {}
    valid_keys = (
        'allow_joined_strings',
        'max_join_line_length',
        'max_split_line_length',
        'orange',
        'tab_width',
    )
    # Default settings...
    self.allow_joined_strings = False  # EKR's preference.
    self.max_join_line_length = 88
    self.max_split_line_length = 88
    self.tab_width = 4
    # Override from settings dict...
    for key in settings:  # pragma: no cover
        value = settings.get(key)
        if key in valid_keys and value is not None:
            setattr(self, key, value)
        else:
            g.trace(f"Unexpected setting: {key} = {value!r}")
</t>
<t tx="ekr.20200107165250.20">def do_name(self):
    """Handle a name token."""
    name = self.val
    if self.black_mode and name in ('class', 'def'):  # pragma: no cover (black)
        # Handle newlines before and after 'class' or 'def'
        self.decorator_seen = False
        state = self.state_stack[-1]
        if state.kind == 'decorator':
            # Always do this, regardless of @bool clean-blank-lines.
            self.clean_blank_lines()
            # Suppress split/join.
            self.add_token('hard-newline', '\n')
            self.add_token('line-indent', self.lws)
            self.state_stack.pop()
        else:
            # Always do this, regardless of @bool clean-blank-lines.
            self.blank_lines(2 if name == 'class' else 1)
        self.push_state(name)
        self.push_state('indent', self.level)
            # For trailing lines after inner classes/defs.
        self.word(name)
        return
    #
    # Leo mode...
    if name in ('class', 'def'):
        self.word(name)
    elif name in (
        'and', 'elif', 'else', 'for', 'if', 'in', 'not', 'not in', 'or', 'while'
    ):
        self.word_op(name)
    else:
        self.word(name)
</t>
<t tx="ekr.20200107165250.21">def do_newline(self):
    """Handle a regular newline."""
    self.line_end()

def do_nl(self):
    """Handle a continuation line."""
    self.line_end()
</t>
<t tx="ekr.20200107165250.22">def do_number(self):
    """Handle a number token."""
    self.blank()
    self.add_token('number', self.val)
</t>
<t tx="ekr.20200107165250.23">def do_op(self):
    """Handle an op token."""
    val = self.val
    if val == '.':
        self.clean('blank')
        self.add_token('op-no-blanks', val)
    elif val == '@':
        if self.black_mode:  # pragma: no cover (black)
            if not self.decorator_seen:
                self.blank_lines(1)
                self.decorator_seen = True
        self.clean('blank')
        self.add_token('op-no-blanks', val)
        self.push_state('decorator')
    elif val == ':':
        # Treat slices differently.
        self.colon(val)
    elif val in ',;':
        # Pep 8: Avoid extraneous whitespace immediately before
        # comma, semicolon, or colon.
        self.clean('blank')
        self.add_token('op', val)
        self.blank()
    elif val in '([{':
        # Pep 8: Avoid extraneous whitespace immediately inside
        # parentheses, brackets or braces.
        self.lt(val)
    elif val in ')]}':
        # Ditto.
        self.rt(val)
    elif val == '=':
        # Pep 8: Don't use spaces around the = sign when used to indicate
        # a keyword argument or a default parameter value.
        if self.paren_level:
            self.clean('blank')
            self.add_token('op-no-blanks', val)
        else:
            self.blank()
            self.add_token('op', val)
            self.blank()
    elif val in '~+-':
        self.possible_unary_op(val)
    elif val == '*':
        self.star_op()
    elif val == '**':
        self.star_star_op()
    else:
        # Pep 8: always surround binary operators with a single space.
        # '==','+=','-=','*=','**=','/=','//=','%=','!=','&lt;=','&gt;=','&lt;','&gt;',
        # '^','~','*','**','&amp;','|','/','//',
        # Pep 8: If operators with different priorities are used,
        # consider adding whitespace around the operators with the lowest priority(ies).
        self.blank()
        self.add_token('op', val)
        self.blank()
</t>
<t tx="ekr.20200107165250.24">def do_string(self):
    """Handle a 'string' token."""
    # Careful: continued strings may contain '\r'
    val = regularize_nls(self.val)
    self.add_token('string', val)
    self.blank()
</t>
<t tx="ekr.20200107165250.25">def do_ws(self):
    """
    Handle the "ws" pseudo-token.
    
    Put the whitespace only if if ends with backslash-newline.
    """
    val = self.val
    # Handle backslash-newline.
    if '\\\n' in val:
        self.clean('blank')
        self.add_token('op-no-blanks', val)
        return
    # Handle start-of-line whitespace.
    prev = self.code_list[-1]
    inner = self.paren_level or self.square_brackets_stack or self.curly_brackets_level
    if prev.kind == 'line-indent' and inner:
        # Retain the indent that won't be cleaned away.
        self.clean('line-indent')
        self.add_token('hard-blank', val)
</t>
<t tx="ekr.20200107165250.26"></t>
<t tx="ekr.20200107165250.27">def blank(self):
    """Add a blank request to the code list."""
    prev = self.code_list[-1]
    if prev.kind not in (
        'blank',
        'blank-lines',
        'file-start',
        'hard-blank',  # Unique to orange.
        'line-end',
        'line-indent',
        'lt',
        'op-no-blanks',
        'unary-op',
    ):
        self.add_token('blank', ' ')
</t>
<t tx="ekr.20200107165250.29">def blank_lines(self, n):  # pragma: no cover (black)
    """
    Add a request for n blank lines to the code list.
    Multiple blank-lines request yield at least the maximum of all requests.
    """
    self.clean_blank_lines()
    prev = self.code_list[-1]
    if prev.kind == 'file-start':
        self.add_token('blank-lines', n)
        return
    for i in range(0, n + 1):
        self.add_token('line-end', '\n')
    # Retain the token (intention) for debugging.
    self.add_token('blank-lines', n)
    self.line_indent()
</t>
<t tx="ekr.20200107165250.30">def clean(self, kind):
    """Remove the last item of token list if it has the given kind."""
    prev = self.code_list[-1]
    if prev.kind == kind:
        self.code_list.pop()
</t>
<t tx="ekr.20200107165250.31">def clean_blank_lines(self):
    """
    Remove all vestiges of previous blank lines.
    
    Return True if any of the cleaned 'line-end' tokens represented "hard" newlines.
    """
    cleaned_newline = False
    table = ('blank-lines', 'line-end', 'line-indent')
    while self.code_list[-1].kind in table:
        t = self.code_list.pop()
        if t.kind == 'line-end' and getattr(t, 'newline_kind', None) != 'nl':
            cleaned_newline = True
    return cleaned_newline
</t>
<t tx="ekr.20200107165250.32">def colon(self, val):
    """Handle a colon."""

    def is_expr(node):
        """True if node is any expression other than += number."""
        if isinstance(node, (ast.BinOp, ast.Call, ast.IfExp)):
            return True
        return isinstance(
            node, ast.UnaryOp) and not isinstance(node.operand, ast.Num)

    node = self.token.node
    self.clean('blank')
    if not isinstance(node, ast.Slice):
        self.add_token('op', val)
        self.blank()
        return
    # A slice.
    lower = getattr(node, 'lower', None)
    upper = getattr(node, 'upper', None)
    step = getattr(node, 'step', None)
    if any(is_expr(z) for z in (lower, upper, step)):
        prev = self.code_list[-1]
        if prev.value not in '[:':
            self.blank()
        self.add_token('op', val)
        self.blank()
    else:
        self.add_token('op-no-blanks', val)
</t>
<t tx="ekr.20200107165250.33">def line_end(self):
    """Add a line-end request to the code list."""
    # This should be called only be do_newline and do_nl.
    node, token = self.token.statement_node, self.token
    assert token.kind in ('newline', 'nl'), (token.kind, g.callers())
    # Create the 'line-end' output token.
    self.add_line_end()
    # Attempt to split the line.
    was_split = self.split_line(node, token)
    # Attempt to join the line only if it has not just been split.
    if not was_split and self.max_join_line_length &gt; 0:
        self.join_lines(node, token)
    self.line_indent()
        # Add the indentation for all lines
        # until the next indent or unindent token.
</t>
<t tx="ekr.20200107165250.34">def split_line(self, node, token):
    """
    Split token's line, if possible and enabled.
    
    Return True if the line was broken into two or more lines.
    """
    assert token.kind in ('newline', 'nl'), repr(token)
    # Return if splitting is disabled:
    if self.max_split_line_length &lt;= 0:  # pragma: no cover (user option)
        return False
    # Return if the node can't be split.
    if not is_long_statement(node):
        return False
    # Find the *output* tokens of the previous lines.
    line_tokens = self.find_prev_line()
    line_s = ''.join([z.to_string() for z in line_tokens])
    # Do nothing for short lines.
    if len(line_s) &lt; self.max_split_line_length:
        return False
    # Return if the previous line has no opening delim: (, [ or {.
    if not any(
        [z.kind == 'lt' for z in line_tokens]):  # pragma: no cover (defensive)
        return False
    prefix = self.find_line_prefix(line_tokens)
    # Calculate the tail before cleaning the prefix.
    tail = line_tokens[len(prefix) :]
    # Cut back the token list: subtract 1 for the trailing line-end.
    self.code_list = self.code_list[: len(self.code_list) - len(line_tokens) - 1]
    # Append the tail, splitting it further, as needed.
    self.append_tail(prefix, tail)
    # Add the line-end token deleted by find_line_prefix.
    self.add_token('line-end', '\n')
    return True
</t>
<t tx="ekr.20200107165250.35">def append_tail(self, prefix, tail):
    """Append the tail tokens, splitting the line further as necessary."""
    tail_s = ''.join([z.to_string() for z in tail])
    if len(tail_s) &lt; self.max_split_line_length:
        # Add the prefix.
        self.code_list.extend(prefix)
        # Start a new line and increase the indentation.
        self.add_token('line-end', '\n')
        self.add_token('line-indent', self.lws + ' ' * 4)
        self.code_list.extend(tail)
        return
    # Still too long.  Split the line at commas.
    self.code_list.extend(prefix)
    # Start a new line and increase the indentation.
    self.add_token('line-end', '\n')
    self.add_token('line-indent', self.lws + ' ' * 4)
    open_delim = Token(kind='lt', value=prefix[-1].value)
    value = open_delim.value.replace('(', ')').replace('[', ']').replace('{', '}')
    close_delim = Token(kind='rt', value=value)
    delim_count = 1
    lws = self.lws + ' ' * 4
    for i, t in enumerate(tail):
        if t.kind == 'op' and t.value == ',':
            if delim_count == 1:
                # Start a new line.
                self.add_token('op-no-blanks', ',')
                self.add_token('line-end', '\n')
                self.add_token('line-indent', lws)
                # Kill a following blank.
                if i + 1 &lt; len(tail):
                    next_t = tail[i + 1]
                    if next_t.kind == 'blank':
                        next_t.kind = 'no-op'
                        next_t.value = ''
            else:
                self.code_list.append(t)
        elif t.kind == close_delim.kind and t.value == close_delim.value:
            # Done if the delims match.
            delim_count -= 1
            if delim_count == 0:
                # Start a new line
                self.add_token('op-no-blanks', ',')
                self.add_token('line-end', '\n')
                self.add_token('line-indent', self.lws)
                self.code_list.extend(tail[i:])
                return
            lws = lws[:-4]
            self.code_list.append(t)
        elif t.kind == open_delim.kind and t.value == open_delim.value:
            delim_count += 1
            lws = lws + ' ' * 4
            self.code_list.append(t)
        else:
            self.code_list.append(t)
    g.trace('BAD DELIMS', delim_count)
</t>
<t tx="ekr.20200107165250.36">def find_prev_line(self):
    """Return the previous line, as a list of tokens."""
    line = []
    for t in reversed(self.code_list[:-1]):
        if t.kind in ('hard-newline', 'line-end'):
            break
        line.append(t)
    return list(reversed(line))
</t>
<t tx="ekr.20200107165250.37">def find_line_prefix(self, token_list):
    """
    Return all tokens up to and including the first lt token.
    Also add all lt tokens directly following the first lt token.
    """
    result = []
    for i, t in enumerate(token_list):
        result.append(t)
        if t.kind == 'lt':
            break
    return result
</t>
<t tx="ekr.20200107165250.39">def join_lines(self, node, token):
    """
    Join preceding lines, if possible and enabled.
    token is a line_end token. node is the corresponding ast node.
    """
    if self.max_join_line_length &lt;= 0:  # pragma: no cover (user option)
        return
    assert token.kind in ('newline', 'nl'), repr(token)
    if token.kind == 'nl':
        return
    # Scan backward in the *code* list,
    # looking for 'line-end' tokens with tok.newline_kind == 'nl'
    nls = 0
    i = len(self.code_list) - 1
    t = self.code_list[i]
    assert t.kind == 'line-end', repr(t)
    assert t.newline_kind == 'newline'
    i -= 1
    while i &gt;= 0:
        t = self.code_list[i]
        if t.kind == 'comment':
            # Can't join.
            return
        if t.kind == 'string' and not self.allow_joined_strings:
            # An EKR preference: don't join strings, no matter what black does.
            # This allows "short" f-strings to be aligned.
            return
        if t.kind == 'line-end':
            if getattr(t, 'newline_kind', None) == 'nl':
                nls += 1
            else:
                break  # pragma: no cover
        i -= 1
    # Retain at the file-start token.
    if i &lt;= 0:
        i = 1
    if nls &lt;= 0:  # pragma: no cover (rare)
        return
    # Retain line-end and and any following line-indent.
    # Required, so that the regex below won't eat too much.
    while True:
        t = self.code_list[i]
        if t.kind == 'line-end':
            if getattr(t, 'newline_kind', None) == 'nl':  # pragma: no cover (rare)
                nls -= 1
            i += 1
        elif self.code_list[i].kind == 'line-indent':
            i += 1
        else:
            break  # pragma: no cover (defensive)
    if nls &lt;= 0:  # pragma: no cover (defensive)
        return
    # Calculate the joined line.
    tail = self.code_list[i:]
    tail_s = tokens_to_string(tail)
    tail_s = re.sub(r'\n\s*', ' ', tail_s)
    tail_s = tail_s.replace('( ', '(').replace(' )', ')')
    tail_s = tail_s.rstrip()
    # Don't join the lines if they would be too long.
    if len(tail_s) &gt; self.max_join_line_length:  # pragma: no cover (defensive)
        return
    # Cut back the code list.
    self.code_list = self.code_list[:i]
    # Add the new output tokens.
    self.add_token('string', tail_s)
    self.add_token('line-end', '\n')
</t>
<t tx="ekr.20200107165250.40">def line_indent(self):
    """Add a line-indent token."""
    self.clean('line-indent')
        # Defensive. Should never happen.
    self.add_token('line-indent', self.lws)
</t>
<t tx="ekr.20200107165250.41"></t>
<t tx="ekr.20200107165250.42">def lt(self, val):
    """Generate code for a left paren or curly/square bracket."""
    assert val in '([{', repr(val)
    if val == '(':
        self.paren_level += 1
    elif val == '[':
        self.square_brackets_stack.append(False)
    else:
        self.curly_brackets_level += 1
    self.clean('blank')
    prev = self.code_list[-1]
    if prev.kind in ('op', 'word-op'):
        self.blank()
        self.add_token('lt', val)
    elif prev.kind == 'word':
        # Only suppress blanks before '(' or '[' for non-keyworks.
        if val == '{' or prev.value in ('if', 'else', 'return', 'for'):
            self.blank()
        elif val == '(':
            self.in_arg_list += 1
        self.add_token('lt', val)
    else:
        self.clean('blank')
        self.add_token('op-no-blanks', val)
</t>
<t tx="ekr.20200107165250.43">def rt(self, val):
    """Generate code for a right paren or curly/square bracket."""
    assert val in ')]}', repr(val)
    if val == ')':
        self.paren_level -= 1
        self.in_arg_list = max(0, self.in_arg_list - 1)
    elif val == ']':
        self.square_brackets_stack.pop()
    else:
        self.curly_brackets_level -= 1
    self.clean('blank')
    self.add_token('rt', val)
</t>
<t tx="ekr.20200107165250.45">def possible_unary_op(self, s):
    """Add a unary or binary op to the token list."""
    node = self.token.node
    self.clean('blank')
    if isinstance(node, ast.UnaryOp):
        self.unary_op(s)
    else:
        self.blank()
        self.add_token('op', s)
        self.blank()

def unary_op(self, s):
    """Add an operator request to the code list."""
    assert s and isinstance(s, str), repr(s)
    self.clean('blank')
    prev = self.code_list[-1]
    if prev.kind == 'lt':
        self.add_token('unary-op', s)
    else:
        self.blank()
        self.add_token('unary-op', s)
</t>
<t tx="ekr.20200107165250.46">def star_op(self):
    """Put a '*' op, with special cases for *args."""
    val = '*'
    self.clean('blank')
    if self.paren_level &gt; 0:
        prev = self.code_list[-1]
        if prev.kind == 'lt' or (prev.kind, prev.value) == ('op', ','):
            self.blank()
            self.add_token('op', val)
            return
    self.blank()
    self.add_token('op', val)
    self.blank()
</t>
<t tx="ekr.20200107165250.47">def star_star_op(self):
    """Put a ** operator, with a special case for **kwargs."""
    val = '**'
    self.clean('blank')
    if self.paren_level &gt; 0:
        prev = self.code_list[-1]
        if prev.kind == 'lt' or (prev.kind, prev.value) == ('op', ','):
            self.blank()
            self.add_token('op', val)
            return
    self.blank()
    self.add_token('op', val)
    self.blank()
</t>
<t tx="ekr.20200107165250.48">def word(self, s):
    """Add a word request to the code list."""
    assert s and isinstance(s, str), repr(s)
    if self.square_brackets_stack:
        # A previous 'op-no-blanks' token may cancel this blank.
        self.blank()
        self.add_token('word', s)
    elif self.in_arg_list &gt; 0:
        self.add_token('word', s)
        self.blank()
    else:
        self.blank()
        self.add_token('word', s)
        self.blank()

def word_op(self, s):
    """Add a word-op request to the code list."""
    assert s and isinstance(s, str), repr(s)
    self.blank()
    self.add_token('word-op', s)
    self.blank()
</t>
<t tx="ekr.20200107165250.51">def push_state(self, kind, value=None):
    """Append a state to the state stack."""
    state = ParseState(kind, value)
    self.state_stack.append(state)
</t>
<t tx="ekr.20200107165250.8"></t>
<t tx="ekr.20200107170126.1">class ParseState:
    """
    A class representing items in the parse state stack.
    
    The present states:
        
    'file-start': Ensures the stack stack is never empty.
        
    'decorator': The last '@' was a decorator.
        
        do_op():    push_state('decorator')
        do_name():  pops the stack if state.kind == 'decorator'.
                    
    'indent': The indentation level for 'class' and 'def' names.
    
        do_name():      push_state('indent', self.level)
        do_dendent():   pops the stack once or twice if state.value == self.level.

    """

    def __init__(self, kind, value):
        self.kind = kind
        self.value = value

    def __repr__(self):
        return f"State: {self.kind} {self.value!r}"

    __str__ = __repr__
</t>
<t tx="ekr.20200107170523.1">def add_token(self, kind, value):
    """Add an output token to the code list."""
    tok = Token(kind, value)
    tok.index = self.code_list_index  # For debugging only.
    self.code_list_index += 1
    self.code_list.append(tok)
    return tok
</t>
<t tx="ekr.20200107170847.1">class OrangeSettings:

    pass
</t>
<t tx="ekr.20200107172450.1">def beautify_file(self, filename):  # pragma: no cover
    """
    Orange: Beautify the the given external file.
    
    Return True if the file was changed.
    """
    tag = 'beautify-file'
    self.filename = filename
    tog = TokenOrderGenerator()
    contents, encoding, tokens, tree = tog.init_from_file(filename)
    if not contents or not tokens or not tree:
        print(f"{tag}: Can not beautify: {filename}")
        return False
    # Beautify.
    results = self.beautify(contents, filename, tokens, tree)
    # Something besides newlines must change.
    if regularize_nls(contents) == regularize_nls(results):
        print(f"{tag}: Unchanged: {filename}")
        return False
    if 0:  # This obscures more import error messages.
        # Show the diffs.
        show_diffs(contents, results, filename=filename)
    # Write the results
    print(f"{tag}: Wrote {filename}")
    write_file(filename, results, encoding=encoding)
    return True
</t>
<t tx="ekr.20200107172512.1">def beautify_file_diff(self, filename):  # pragma: no cover
    """
    Orange: Print the diffs that would resulf from the orange-file command.
    
    Return True if the file would be changed.
    """
    tag = 'diff-beautify-file'
    self.filename = filename
    tog = TokenOrderGenerator()
    contents, encoding, tokens, tree = tog.init_from_file(filename)
    if not contents or not tokens or not tree:
        print(f"{tag}: Can not beautify: {filename}")
        return False
    # fstringify.
    results = self.beautify(contents, filename, tokens, tree)
    # Something besides newlines must change.
    if regularize_nls(contents) == regularize_nls(results):
        print(f"{tag}: Unchanged: {filename}")
        return False
    # Show the diffs.
    show_diffs(contents, results, filename=filename)
    return True
</t>
<t tx="ekr.20200107173542.1">def oops(self):
    g.trace(f"Unknown kind: {self.kind}")

def beautify(self, contents, filename, tokens, tree,
    max_join_line_length=None,
    max_split_line_length=None,
):
    """
    The main line. Create output tokens and return the result as a string.
    """
    # Config overrides
    if max_join_line_length is not None:
        self.max_join_line_length = max_join_line_length
    if max_split_line_length is not None:
        self.max_split_line_length = max_split_line_length
    # State vars...
    self.curly_brackets_level = 0  # Number of unmatched '{' tokens.
    self.decorator_seen = False  # Set by do_name for do_op.
    self.in_arg_list = 0  # &gt; 0 if in an arg list of a def.
    self.level = 0  # Set only by do_indent and do_dedent.
    self.lws = ''  # Leading whitespace.
    self.paren_level = 0  # Number of unmatched '(' tokens.
    self.square_brackets_stack = []  # A stack of bools, for self.word().
    self.state_stack = []  # Stack of ParseState objects.
    self.val = None  # The input token's value (a string).
    self.verbatim = False  # True: don't beautify.
    #
    # Init output list and state...
    self.code_list = []  # The list of output tokens.
    self.code_list_index = 0  # The token's index.
    self.tokens = tokens  # The list of input tokens.
    self.tree = tree
    self.add_token('file-start', '')
    self.push_state('file-start')
    for i, token in enumerate(tokens):
        self.token = token
        self.kind, self.val, self.line = token.kind, token.value, token.line
        if self.verbatim:
            self.do_verbatim()
        else:
            func = getattr(self, f"do_{token.kind}", self.oops)
            func()
    # Any post pass would go here.
    return tokens_to_string(self.code_list)
</t>
<t tx="ekr.20200110162044.1">def find_next_significant_token(self):
    """
    Scan from *after* self.tokens[px] looking for the next significant
    token.
    
    Return the token, or None. Never change self.px.
    """
    px = self.px + 1
    while px &lt; len(self.tokens):
        token = self.tokens[px]
        px += 1
        if is_significant_token(token):
            return token
    # This will never happen, because endtoken is significant.
    return None  # pragma: no cover
</t>
<t tx="ekr.20200111083914.1">def get_concatenated_string_tokens(self):
    """
    Return the next 'string' token and all 'string' tokens concatenated to
    it. *Never* update self.px here.
    """
    trace = False
    tag = 'tog.get_concatenated_string_tokens'
    i = self.px
    # First, find the next significant token.  It should be a string.
    i, token = i + 1, None
    while i &lt; len(self.tokens):
        token = self.tokens[i]
        i += 1
        if token.kind == 'string':
            # Rescan the string.
            i -= 1
            break
        # An error.
        if is_significant_token(token):  # pragma: no cover
            break
    # Raise an error if we didn't find the expected 'string' token.
    if not token or token.kind != 'string':  # pragma: no cover
        if not token:
            token = self.tokens[-1]
        filename = getattr(self, 'filename', '&lt;no filename&gt;')
        raise AssignLinksError(
            f"\n"
            f"{tag}...\n"
            f"file: {filename}\n"
            f"line: {token.line_number}\n"
            f"   i: {i}\n"
            f"expected 'string' token, got {token!s}")
    # Accumulate string tokens.
    assert self.tokens[i].kind == 'string'
    results = []
    while i &lt; len(self.tokens):
        token = self.tokens[i]
        i += 1
        if token.kind == 'string':
            results.append(token)
        elif token.kind == 'op' or is_significant_token(token):
            # Any significant token *or* any op will halt string concatenation.
            break
        # 'ws', 'nl', 'newline', 'comment', 'indent', 'dedent', etc.
    # The (significant) 'endmarker' token ensures we will have result.
    assert results
    if trace:
        g.printObj(results, tag=f"{tag}: Results")
    return results
</t>
<t tx="ekr.20200118120049.1"></t>
<t tx="ekr.20200118145044.1">def add_line_end(self):
    """Add a line-end request to the code list."""
    # This may be called from do_name as well as do_newline and do_nl.
    assert self.token.kind in ('newline', 'nl'), self.token.kind
    self.clean('blank')  # Important!
    self.clean('line-indent')
    t = self.add_token('line-end', '\n')
    # Distinguish between kinds of 'line-end' tokens.
    t.newline_kind = self.token.kind
    return t
</t>
<t tx="ekr.20200209081913.1"></t>
<t tx="ekr.20200210175117.1">beautify_pat = re.compile(
    r'#\s*pragma:\s*beautify\b|#\s*@@beautify|#\s*@\+node|#\s*@[+-]others|#\s*@[+-]&lt;&lt;')

def do_verbatim(self):
    """
    Handle one token in verbatim mode.
    End verbatim mode when the appropriate comment is seen.
    """
    kind = self.kind
    #
    # Careful: tokens may contain '\r'
    val = regularize_nls(self.val)
    if kind == 'comment':
        if self.beautify_pat.match(val):
            self.verbatim = False
        val = val.rstrip()
        self.add_token('comment', val)
        return
    if kind == 'indent':
        self.level += 1
        self.lws = self.level * self.tab_width * ' '
    if kind == 'dedent':
        self.level -= 1
        self.lws = self.level * self.tab_width * ' '
    self.add_token('verbatim', val)
</t>
<t tx="ekr.20200212095937.1"></t>
<t tx="ekr.20200212095937.2">True:  allow joined lines to contain strings.
False: (Recommended by EKR): Retain alignment of strings.</t>
<t tx="ekr.20200212095937.3">True: Retain indentation of overindented stand-alone comment lines.</t>
<t tx="ekr.20200212095937.5"># At present I am of the opinion that joining lines is usually a bad idea.

Should be &lt;= beautify-max-split-line-length</t>
<t tx="ekr.20200212095937.6"></t>
<t tx="ekr.20200220054928.1">def handle_dedent_after_class_or_def(self, kind):  # pragma: no cover (black)
    """
    Insert blank lines after a class or def as the result of a 'dedent' token.

    Normal comment lines may precede the 'dedent'.
    Insert the blank lines *before* such comment lines.
    """
    #
    # Compute the tail.
    i, tail = len(self.code_list) - 1, []
    while i &gt; 0:
        t = self.code_list.pop()
        i -= 1
        if t.kind == 'line-indent':
            pass
        elif t.kind == 'line-end':
            tail.insert(0, t)
        elif t.kind == 'comment':
            # Only underindented single-line comments belong in the tail.
            # @+node comments must never be in the tail.
            single_line = self.code_list[i].kind in ('line-end', 'line-indent')
            lws = len(t.value) - len(t.value.lstrip())
            underindent = lws &lt;= len(self.lws)
            if underindent and single_line and not self.node_pat.match(t.value):
                # A single-line comment.
                tail.insert(0, t)
            else:
                self.code_list.append(t)
                break
        else:
            self.code_list.append(t)
            break
    #
    # Remove leading 'line-end' tokens from the tail.
    while tail and tail[0].kind == 'line-end':
        tail = tail[1:]
    #
    # Put the newlines *before* the tail.
    # For Leo, always use 1 blank lines.
    n = 1  # n = 2 if kind == 'class' else 1
    # Retain the token (intention) for debugging.
    self.add_token('blank-lines', n)
    for i in range(0, n + 1):
        self.add_token('line-end', '\n')
    if tail:
        self.code_list.extend(tail)
    self.line_indent()
</t>
<t tx="ekr.20200222083959.1">import logging
rootLogger = logging.getLogger('')
rootLogger.setLevel(logging.DEBUG)
socketHandler = logging.handlers.SocketHandler(
    'localhost',
    logging.handlers.DEFAULT_TCP_LOGGING_PORT,
)
rootLogger.addHandler(socketHandler)
logging.info('-' * 20)
</t>
<t tx="ekr.20200222151754.1">import yoton

# Create another context and a sub channel
ct2 = yoton.Context()
sub = yoton.SubChannel(ct2, 'chat')

# Connect
ct2.connect('publichost:test')

# Receive
while True:
    i = int(sub.recv())
    print(i)
    if i == 10:
        break
</t>
<t tx="ekr.20200304130514.1">def onContextMenu(self, point):
    """LeoQTextBrowser: Callback for customContextMenuRequested events."""
    # #1286.
    c, w = self.leo_c, self
    g.app.gui.onContextMenu(c, w, point)
</t>
<t tx="ekr.20200308193719.1">d = {}  # Keys are gnxs, values is a list of vnodes with that gnx.
for v in c.all_nodes():
    gnx = v.gnx
    aList = d.get(gnx, [])
    if v not in aList:
        aList.append(v)
        d [gnx] = aList
        if len(aList) &gt; 1:
            print(f"gnx clash: {gnx}")
            g.printObj(aList)
print('done')</t>
<t tx="ekr.20200401074555.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1557

Create mypy command?

@language python
</t>
<t tx="ekr.20200503075952.1"></t>
<t tx="ekr.20200522082827.1"></t>
<t tx="ekr.20200727085351.1">- update-leo-py-ref-leo command.
  Based on fc.save_ref.

- design new macro scheme.
- Overall project: huge .leo.db files
    - Fast redraw.
    - Prohibit expand all.

- Exercises on all 12 roots.

Promises: Fix bugs every day.

Poster: Voting Rights Matter

@nosearch
@language rest
@wrap</t>
<t tx="ekr.20200727095246.1"></t>
<t tx="ekr.20200910094121.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1569

The fonts size in body panel changes to original size with clicking the body panel after run zoom-in or zoom-out command.

May be a MacOS bug.

@language python
@nosearch
</t>
<t tx="ekr.20200910122336.1"></t>
<t tx="ekr.20200913074639.1">@language rest
@wrap

In "repaint" branch.

https://github.com/leo-editor/leo-editor/issues/1599

@language python
@nosearch
</t>
<t tx="ekr.20200913074701.1"># in appearance.py
# In effect, this is a subclass of QPlainTextEditor!

def paintEvent(self,event):
    """ paintEvent(event)

    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    super(IndentationGuides, self).paintEvent(event)

    if not self.showIndentationGuides():
        return

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    # Get multiplication factor and indent width
    indentWidth = self.indentWidth()
    if self.indentUsingSpaces():
        factor = 1
    else:
        factor = indentWidth

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    format = self.getStyleElementFormat('editor.IndentationGuides')
    pen = QtGui.QPen(format.fore)
    pen.setStyle(format.linestyle)
    painter.setPen(pen)
    offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        bd = cursor.block().userData()
        if bd and hasattr(bd, 'indentation') and bd.indentation:
            for x in range(indentWidth, bd.indentation * factor, indentWidth):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)

    # Done
    painter.end()
</t>
<t tx="ekr.20200913075121.1">def __init__(self,*args, **kwds):
    super(CodeEditorBase, self).__init__(*args)

    # Set font (always monospace)
    self.__zoom = 0
    self.setFont()

    # Create highlighter class
    self.__highlighter = Highlighter(self, self.document())

    # Set some document options
    option = self.document().defaultTextOption()
    option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
                        option.AddSpaceForLineAndParagraphSeparators )
    self.document().setDefaultTextOption(option)

    # When the cursor position changes, invoke an update, so that
    # the hihghlighting etc will work
    self.cursorPositionChanged.connect(self.viewport().update)

    # Init styles to default values
    self.__style = {}
    for element in self.getStyleElementDescriptions():
        self.__style[element.key] = element.defaultFormat

    # Connext style update
    self.styleChanged.connect(self.__afterSetStyle)
    self.__styleChangedPending = False

    # Init margins
    self._leftmargins = []

    # Init options now.
    # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
    # If an extension has an __init__ in which it first calls the
    # super().__init__, this __initOptions() function will be called,
    # while the extension's init is not yet finished.
    self.__initOptions(kwds)

    # Define colors from Solarized theme
    # NOTE TO PEOPLE WANTING CUSTOM COLORS: ignore this and check the
    # commented lines near the bottom of this method.
    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"  # noqa
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"  # noqa

    if 1: # EKR:patch: use a dark theme.
        back1, back2, back3 = base03, base02, base01
        fore1, fore2, fore3, fore4 = base0, base1, base2, base3  # noqa
    else:
        # Original code.
        #back1, back2, back3 = base3, base2, base1 # real solarised
        back1, back2, back3 = "#fff", base2, base1 # crispier
        fore1, fore2, fore3, fore4 = base00, base01, base02, base03

    # todo: proper testing of syntax style

    # Define style using "Solarized" colors
    S  = {}
    S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
    S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
    S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2

    S["Syntax.builtins"] = "fore:%s, bold:no, italic:no, underline:no" % fore1
    S["Syntax.instance"] = "fore:%s, bold:no, italic:no, underline:no" % fore1

    S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
    S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange

    S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
    S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
    S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue

    S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
    S["Syntax.comment"] = "fore:%s, bold:no, italic:no, underline:no" % yellow
    S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
    S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow

    S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Highlight current line"] = "back:%s" % back2
    S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
    S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)

    # Define style using html color names. All 140 legal HTML colour
    # names can be used (in addition to HEX codes). A full list of
    # recognized colour names is available e.g. here
    # http://www.html-color-names.com/color-chart.php
#         S  = {}
#         S["Editor.text"] = "back: white, fore: black"
#         S['Syntax.identifier'] = "fore: black, bold:no, italic:no, underline:no"
#         S["Syntax.nonidentifier"] = "fore: blue, bold:no, italic:no, underline:no"
#         S["Syntax.keyword"] = "fore: blue, bold:yes, italic:no, underline:no"
#         S["Syntax.functionname"] = "fore: black, bold:yes, italic:no, underline:no"
#         S["Syntax.classname"] = "fore: magenta, bold:yes, italic:no, underline:no"
#         S["Syntax.string"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.unterminatedstring"] = "fore: red, bold:no, italic:no, underline:dotted"
#         S["Syntax.python.multilinestring"] = "fore: red, bold:no, italic:no, underline:no"
#         S["Syntax.number"] = "fore: dark orange, bold:no, italic:no, underline:no"
#         S["Syntax.comment"] ="fore: green, bold:no, italic:yes, underline:no"
#         S["Syntax.todocomment"] = "fore: magenta, bold:no, italic:yes, underline:no"
#         S["Syntax.python.cellcomment"] = "fore: green, bold:yes, italic:no, underline:full"
#         S["Editor.Long line indicator"] = "linestyle:solid, fore: dark grey"
#         S["Editor.Highlight current line"] = "back: light grey"
#         S["Editor.Indentation guides"] = "linestyle:solid, fore: light grey"
#         S["Editor.Line numbers"] = "back: light grey, fore: black"

    # Apply style
    self.setStyle(S)
</t>
<t tx="ekr.20200913075250.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200913082124.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200913082155.1">def doForVisibleBlocks(self, function):
    """ doForVisibleBlocks(function)

    Call the given function(cursor) for all blocks that are currently
    visible. This is used by several appearence extensions that
    paint per block.

    The supplied cursor will be located at the beginning of each block. This
    cursor may be modified by the function as required

    """

    # Start cursor at top line.
    cursor = self.cursorForPosition(QtCore.QPoint(0,0))
    cursor.movePosition(cursor.StartOfBlock)

    if not self.isVisible():
        return

    while True:
        # Call the function with a copy of the cursor
        function(QtGui.QTextCursor(cursor))

        # Go to the next block (or not if we are done)
        y = self.cursorRect(cursor).bottom()
        if y &gt; self.height():
            break #Reached end of the repaint area
        if not cursor.block().next().isValid():
            break #Reached end of the text
        cursor.movePosition(cursor.NextBlock)
</t>
<t tx="ekr.20200914071303.1">def paintEvent(self, event):
    """
    Paint the indentation guides, using the indentation info calculated
    by the highlighter.
    """
    ### super(IndentationGuides, self).paintEvent(event)
    super().paintEvent(event)
    return ###
    c = self.leo_c
    print('===== paintEvent', c.shortFileName())

    # Get doc and viewport
    doc = self.document()
    viewport = self.viewport()

    ###
        # # Get multiplication factor and indent width
        # indentWidth = self.indentWidth()
        # if self.indentUsingSpaces():
            # factor = 1
        # else:
            # factor = indentWidth
    if c.tab_width &gt; 1: # Tabs
        ### editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        ### editor.setIndentUsingSpaces(False)
        factor = 1
    else: # Spaces
        #### editor.setIndentWidth(indentWidth)
        ### editor.setIndentUsingSpaces(True)
        factor = 5 ### self.indentWidth()
    if 0:
        g.trace(factor)

    # Init painter
    painter = QtGui.QPainter()
    painter.begin(viewport)

    # Prepare pen
    if 1:
        pen = QtGui.QPen()
        pen.setWidthF(1)
        # pen.setColor(QtGui.QColor('red'))
        offset = 0 # doc.documentMargin() + self.contentOffset().x()
    else:
        format = self.getStyleElementFormat('editor.IndentationGuides')
        pen = QtGui.QPen(format.fore)
        pen.setStyle(format.linestyle) # QtCore.Qt.PenStyle.SolidLine
        painter.setPen(pen)
        offset = doc.documentMargin() + self.contentOffset().x()

    def paintIndentationGuides(cursor):
        y3=self.cursorRect(cursor).top()
        y4=self.cursorRect(cursor).bottom()

        ### bd = cursor.block().userData()
        ### if bd and hasattr(bd, 'indentation') and bd.indentation:
        if True:
            ### for x in range(indentWidth, bd.indentation * factor, indentWidth):
            ### for x in range(5, 5*factor, 5):
            for x in (5, 10):
                w = self.fontMetrics().width('i'*x) + offset
                w += 1 # Put it more under the block
                if w &gt; 0: # if scrolled horizontally it can become &lt; 0
                    painter.drawLine(QtCore.QLine(w, y3, w, y4))

    self.doForVisibleBlocks(paintIndentationGuides)
    # Done
    painter.end()
</t>
<t tx="ekr.20200920140758.1"></t>
<t tx="ekr.20200926095136.1"></t>
<t tx="ekr.20201012111545.1">@language python
@tabwidth -4
@pagewidth 80
</t>
<t tx="ekr.20201012111649.1">gnx: ekr.20170925083314.1
</t>
<t tx="ekr.20201012111649.3">gnx: ekr.20170925083853.1
</t>
<t tx="ekr.20201012114516.1"></t>
<t tx="ekr.20201012142922.1">gnx: ekr.20201012111338.2
unl: Declarations (leo_cloud.py)
gnx: ekr.20201012111338.3
unl: init (leo_cloud.py)
gnx: ekr.20201012111338.4
unl: onCreate (leo_cloud.py)
gnx: ekr.20201012111338.5
unl: onSave (leo_cloud.py)
gnx: ekr.20201012111338.6
unl: lc_read_current (leo_cloud.py)
gnx: ekr.20201012111338.7
unl: lc_write_current (leo_cloud.py)
gnx: ekr.20201012111338.8
unl: class LeoCloudIOBase
gnx: ekr.20201012111338.9
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.__init__
gnx: ekr.20201012111338.10
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.get_subtree
gnx: ekr.20201012111338.11
unl: class LeoCloudIOBase--&gt;LeoCloudIOBase.put_subtree
gnx: ekr.20201012111338.12
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)
gnx: ekr.20201012111338.13
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.14
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.15
unl: class LeoCloudIOFileSystem(LeoCloudIOBase)--&gt;LeoCloudIOFileSystem(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.16
unl: class LeoCloudIOGit(LeoCloudIOBase)
gnx: ekr.20201012111338.17
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).__init__
gnx: ekr.20201012111338.18
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase)._run_git
gnx: ekr.20201012111338.19
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).get_data
gnx: ekr.20201012111338.20
unl: class LeoCloudIOGit(LeoCloudIOBase)--&gt;LeoCloudIOGit(LeoCloudIOBase).put_data
gnx: ekr.20201012111338.21
unl: class LeoCloud
gnx: ekr.20201012111338.22
unl: class LeoCloud--&gt;LeoCloud.__init__
gnx: ekr.20201012111338.23
unl: class LeoCloud--&gt;LeoCloud.bg_check
gnx: ekr.20201012111338.24
unl: class LeoCloud--&gt;LeoCloud.bg_post_process
gnx: ekr.20201012111338.25
unl: class LeoCloud--&gt;LeoCloud.find_at_leo_cloud
gnx: ekr.20201012111338.26
unl: class LeoCloud--&gt;LeoCloud._find_clouds_recursive
gnx: ekr.20201012111338.27
unl: class LeoCloud--&gt;LeoCloud.find_clouds
gnx: ekr.20201012111338.28
unl: class LeoCloud--&gt;LeoCloud._from_dict_recursive
gnx: ekr.20201012111338.29
unl: class LeoCloud--&gt;LeoCloud.from_dict
gnx: ekr.20201012111338.30
unl: class LeoCloud--&gt;LeoCloud.io_from_node
gnx: ekr.20201012111338.31
unl: class LeoCloud--&gt;LeoCloud.kw_from_node
gnx: ekr.20201012111338.32
unl: class LeoCloud--&gt;LeoCloud.load_clouds
gnx: ekr.20201012111338.33
unl: class LeoCloud--&gt;LeoCloud.read_current
gnx: ekr.20201012111338.34
unl: class LeoCloud--&gt;LeoCloud.recursive_hash
gnx: ekr.20201012111338.35
unl: class LeoCloud--&gt;LeoCloud.save_clouds
gnx: ekr.20201012111338.36
unl: class LeoCloud--&gt;LeoCloud.subtree_changed
gnx: ekr.20201012111338.37
unl: class LeoCloud--&gt;LeoCloud._to_json_serial
gnx: ekr.20201012111338.38
unl: class LeoCloud--&gt;LeoCloud.to_json
gnx: ekr.20201012111338.39
unl: class LeoCloud--&gt;LeoCloud._to_dict_recursive
gnx: ekr.20201012111338.40
unl: class LeoCloud--&gt;LeoCloud.to_dict
gnx: ekr.20201012111338.41
unl: class LeoCloud--&gt;LeoCloud._ua_clean
gnx: ekr.20201012111338.42
unl: class LeoCloud--&gt;LeoCloud.write_current
</t>
<t tx="ekr.20201012142922.2">gnx: ekr.20201012111338.43
unl: Declarations (leo_cloud_server.py)
</t>
<t tx="ekr.20201013034659.1"></t>
<t tx="ekr.20201013034742.1"></t>
<t tx="ekr.20201013034742.10"># These can be overridden in subclasses.
</t>
<t tx="ekr.20201013034742.11">### Define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
if 0: # A more complex example, for the C language.
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        import re
        type1 = r'(static|extern)*'
        type2 = r'(void|int|float|double|char)*'
        class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
        pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
        m = re.match(class_pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            return '%sclass %s' % (prefix1, m.group(2))
        m = re.match(pattern, s)
        if m:
            prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
            prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
            h = m.group(3) or '&lt;no c function name&gt;'
            return '%s%s%s' % (prefix1, prefix2, h)
        else:
            return s
</t>
<t tx="ekr.20201013034742.12">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an examplle.
    '''
    pass
</t>
<t tx="ekr.20201013034742.13">class {{cap_name}}_ScanState:
    '''A class representing the state of the {{name}} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{{cap_name}}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{{cap_name}}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{{cap_name}}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20201013034742.14">def level(self):
    '''{{cap_name}}_ScanState.level.'''
    return {{state_ivar}}

</t>
<t tx="ekr.20201013034742.15">def update(self, data):
    '''
    {{cap_name}}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {{cap_name}}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20201013034742.16">'''Converts the word at the cursor to pep8 style throughout a given tree.'''
# aTestExample notFoundExample.
import re
# clear()
table = (
    # 'BLS.new_scan',
    # 'BLS.Code generation',
    # 'class Importer',
)
@others
Pep8(table, change=True).run()
</t>
<t tx="ekr.20201013034742.17">class Pep8:
    '''
    Convert the word under the cursor to pep8 style in all subtrees in
    table.
    '''
    
    def __init__ (self, table, change=False):
        '''Ctor for Pep8 class.'''
        self.change = change
        self.table = table
        
    @others
</t>
<t tx="ekr.20201013034742.18">def change_all(self, name, new_name, root):
    '''Change name to new_name throughout root's tree.'''
    u = c.undoer
    bunch = u.beforeChangeTree(root)
    found = False
    self.pattern = re.compile(r'\b%s\b' % name)
    for p in root.self_and_subtree():
        found = self.change_headline(name, new_name, p) or found
        found = self.change_body(name, new_name, p) or found
    if found:
        u.afterChangeTree(root, 'pep8', bunch)
    return found
</t>
<t tx="ekr.20201013034742.19">def change_body(self, name, new_name, p):
    indices = []
    for m in self.pattern.finditer(p.b):
        indices.append(str(m.start()))
    if indices:
        n = len(indices)
        g.es_print('%s change%s: %s' % (n, g.plural(n), p.h))
        s = p.b
        for i in reversed(indices):
            i = int(i)
            s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.b = s
            p.setDirty()
        else:
            g.es_print(s)
    return bool(indices)</t>
<t tx="ekr.20201013034742.2">g.cls()
# define constants that describe the new language.
name = 'php'
    # The name of the file, and the prefix for classes.
language = 'php'
    # The name of the language, case doesn't matter.
extensions = ['.php',]
    # A list of file extensions supported by this importer.
strict = False
    # True if leading whitespace is particularly significant.
state_ivar = 'self.curlies'
    # 'self.indent' for python, coffeescript.
    # 'self.curlies' for many other languages
    # '(self, curlies, self.parens)' for more complex comparisons
&lt;&lt; define run &amp; helpers &gt;&gt;
run(extensions, language, name, state_ivar)
</t>
<t tx="ekr.20201013034742.20">def change_headline(self, name, new_name, p):
    m = self.pattern.search(p.h)
    if m:
        i = m.start()
        s = p.h
        s = s[:i] + new_name + s[i+len(name):]
        if self.change:
            p.h = s
            p.setDirty()
            g.es_print('changed headline', s)
        else:
            g.es_print('headline', s)
    return bool(m)
</t>
<t tx="ekr.20201013034742.21">def get_name(self):
    i, j = c.editCommands.extendToWord(event=None, select=False)
    w = c.frame.body.wrapper
    s = w.getAllText()
    name = s[i:j]
    return name
</t>
<t tx="ekr.20201013034742.22">def run(self):
    # self.clear()
    name = self.get_name()
    new_name = self.to_pep8(name)
    if len(name) &lt; 2:
        g.es_print('name too short:', name)
    elif new_name == name:
        g.es_print('already pep8:', name)
    else:
        g.es_print('%s -&gt; %s' % (name, new_name))
        c.findCommands.ftm.setFindText(new_name)
            # Preload the replacement text.
        found = False
        for target in table:
            root = g.findNodeAnywhere(c, target)
            if root:
                found = self.change_all(name, new_name, root) or found
            else:
                g.es_print('not found: %s' % target)
        if found:
            c.redraw()
        else:
            g.es_print('not found:', name)
</t>
<t tx="ekr.20201013034742.23">def to_pep8(self, s):
    
    if len(s) &gt; 1 and s[0].islower() and s.lower() != s:
        result = []
        for ch in s:
            result.append(ch)
            if ch.isupper():
                result.pop()
                result.append('_%s' % (ch.lower()))
        return ''.join(result)
    else:
        return name</t>
<t tx="ekr.20201013034742.24">def clear():
    g.cls()
    c.k.simulateCommand('clear-log')
</t>
<t tx="ekr.20201013034742.25"># g.cls()
import re
import sys
if 1:
    h = 'import-neural-networks.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
else:
    h = 'import-Julia.ipynb'
    fn = r'c:\test\export-julia.ipynb'
p = g.findTopLevelNode(c, h)
assert p, h
@others
Export_IPYNB(c).export_outline(p, fn=fn)
</t>
<t tx="ekr.20201013034742.26">'''Imports c:\prog\Julia.ipynb to the node import-Julia.ipynb'''
import nbformat
@others
g.cls()
if 0:
    # fn = r'c:\test\Julia.ipynb'
    fn = r'c:\test\export-neural-networds.ipynb'
    h = 'import-Julia.ipynb'
else:
    h = fn = r'c:\test\04_Neural_Networks.ipynb'
root = g.findTopLevelNode(c, h)
if root:
    while root.hasChildren():
        root.lastChild().doDelete()
else:
    p = c.lastTopLevel()
    root = p.insertAfter()
    root.h = h
x = Import_IPYNB(c)
x.import_file(fn, root)
if not g.unitTesting:
    # These don't work when running unit tests.
    c.selectPosition(root)
    # c.expandAllSubheads()
    c.redraw() 
    g.es_print('done')
</t>
<t tx="ekr.20201013034742.3">@others</t>
<t tx="ekr.20201013034742.4">def copy_tree(source, root, h):
    '''Copy the source tree to the node after p, with headline h.'''
    p2 = root.insertAfter()
    source.copyTreeFromSelfTo(p2)
    p2.h = h
    return p2
 </t>
<t tx="ekr.20201013034742.5">def make_substitutions(destination, patterns):
    '''Make all substitutions in the destination tree.'''
    for p in destination.self_and_subtree():
        h = substitute(p.h, patterns)
        if p.h != h:
            # g.trace('CHANGED:', p.h, '==&gt;', h)
            p.h = h
        b = substitute(p.b, patterns)
        if p.b != b:
            # g.trace('CHANGED:', p.b, '==&gt;', b)
            p.b = b
</t>
<t tx="ekr.20201013034742.6">def run(extensions, language, name, state_ivar):
    '''The driver for this script.'''
    patterns = {
        'cap_name': name.capitalize(),
        'extensions': '[%s]' % ', '.join(["'%s'" % (z) for z in extensions]),
        'language': language.lower(),
        'name': name.lower(),
        'strict': 'True' if strict else 'False',
        'state_ivar': state_ivar,
    }
    h = '@button make-importer'
    root = g.findNodeAnywhere(c, h)
    assert root, h
    h = '@@file importers/{{name}}.py'
    source = g.findNodeInTree(c, root, h)
    assert source, h
    destination = copy_tree(source, root, h)
    make_substitutions(destination, patterns)
    c.contractAllHeadlines()
    c.redraw()</t>
<t tx="ekr.20201013034742.7">def substitute(s, patterns):
    '''Make all substitutions in s.'''
    for pattern in patterns:
        find = '{{%s}}' % pattern
        replace = patterns.get(pattern)
        i = 0
        while i &lt; len(s):
            progress = i
            j = s.find(find, i)
            if j == -1: break
            s = s[:j] + replace + s[j+len(find):]
            i = j+len(replace)
            assert progress &lt; i
    return s
</t>
<t tx="ekr.20201013034742.8">'''The @auto importer for the {{name}} language.'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {{cap_name}}_Importer,
    'extensions': {{extensions}},
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20201013034742.9">class {{cap_name}}_Importer(Importer):
    '''The importer for the {{name}} lanuage.'''

    def __init__(self, importCommands, atAuto):
        '''{{cap_name}}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            atAuto = atAuto,
            language = '{{language}}',
            state_class = {{cap_name}}_ScanState,
            strict = {{strict}},
        )
        
    @others
</t>
<t tx="ekr.20201014060250.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1694

Undo may clear marked bits, and there have been other reported problems.

A thorough review of marked bits is in order.

@language python
@nosearch</t>
<t tx="ekr.20201015145257.1">import leo.core.leoImport as leoImport
import importlib
importlib.reload(leoImport)
g.cls()
# Change path as necessary.
path = r'c:\users\edreamleo\lsa.py'
assert g.os_path_exists(path)
x = leoImport.LegacyExternalFileImporter(c)
x.import_file(path)
</t>
<t tx="ekr.20201016104917.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1700

pep 484: type hints: https://www.python.org/dev/peps/pep-0484/
pep 526: Syntax for Variable Annotations: https://www.python.org/dev/peps/pep-0526/

To do:
- command-line args to dump various things on failures/success.
- command-line arg to compile with type_comments=True?

pytnon38 -m pip install pytest-cov
python38 -m leo.core.leoAst --py-cov

moz htmlcov/leo_core_leoAst_py.html

@language python
@nosearch
</t>
<t tx="ekr.20201016134944.1">Later:
- Pinned post: I am on sabbatical.
  Link to: https://groups.google.com/d/msg/leo-editor/8IOteylbFbk/8kHnbcg5BQAJ
. Add "delegated" label to most remaining items.
- What about gh-pages?
- threads vs processes.
- Pictures of my art works.
- Google exercises: upper body, cardiac @ home.
- Alternative to macros.
</t>
<t tx="ekr.20201017160354.1"></t>
<t tx="ekr.20201018061241.1"></t>
<t tx="ekr.20201018062305.1">"""Update LeoPyRef.leo from the given list of nodes."""
import os
@others
main(node_list = ['Startup', 'Notes', 'Code'])
</t>
<t tx="ekr.20201018063747.1">def get_content(positions_list):
    """
    Return the desired contents of leoPyRef.leo.
    
    Based on code by Виталије Милошевић.
    """
    # Make only one copy for all calls.
    fc = c.fileCommands
    fc.currentPosition = c.p
    fc.rootPosition = c.rootPosition()
    fc.vnodesDict = {}
    # Put the file
    fc.outputFile = g.FileLikeObject()
    fc.putProlog()
    fc.putHeader()
    fc.putGlobals()
    fc.putPrefs()
    fc.putFindSettings()
    fc.put("&lt;vnodes&gt;\n")
    for p in positions_list:
        # An optimization: Write the next top-level node.
        fc.putVnode(p, isIgnore=p.isAtIgnoreNode())
    fc.put("&lt;/vnodes&gt;\n")
    fc.putTnodes()
    fc.putPostlog()
    return fc.outputFile.getvalue()
</t>
<t tx="ekr.20201018065757.1">def check_file_names():
    """Return True if leoPyRef exists and we are running from leoPy.leo."""
    if not 'leoPy.leo' in c.shortFileName():
        oops('Run this script only from leoPy.leo')
        return None
    fileName = g.os_path_finalize_join(g.app.loadDir, '..', 'core', 'leoPyRef.leo')
    if not os.path.exists(fileName):
        oops(f"Not found: {fileName}")
        return None
    return fileName</t>
<t tx="ekr.20201018065921.1">def check_nodes(node_list):
    """Return True if all nodes are found."""
    result = []
    for node in node_list:
        p = g.findTopLevelNode(c, node, exact=True)
        if p:
            result.append(p.copy())
        else:
            oops(f"Top-level node {node} not found")
            return []
    return result</t>
<t tx="ekr.20201018070822.1">def main(node_list):
    """The main line."""
    c.endEditing()
    fileName = check_file_names()
    if not fileName:
        return
    positions_list = check_nodes(node_list)
    if not positions_list:
        return
    content = get_content(positions_list)
    with open(fileName, 'w', encoding="utf-8", newline='\n') as f:
        f.write(content)
    print('')
    g.es_print(f"Updated {g.shortFileName(fileName)}")
</t>
<t tx="ekr.20201018072911.1">def oops(message):
    """Print an error message"""
    print('')
    g.es_print(message)
    print('')</t>
<t tx="tbnorth.20160510122413.1">def splitter_clicked(self, splitter, handle, event, release, double):
    """
    splitter_clicked - middle click release will zoom adjacent
    body / tree panes

    :param NestedSplitter splitter: splitter containing clicked handle
    :param NestedSplitterHandle handle: clicked handle
    :param QMouseEvent event: mouse event for click
    :param bool release: was it a Press or Release event
    :param bool double: was it a double click event
    """
    if not release or event.button() != QtCore.Qt.MidButton:
        return
    if splitter.root.zoomed:  # unzoom if *any* handle clicked
        splitter.zoom_toggle()
        return
    before = splitter.widget(splitter.indexOf(handle) - 1)
    after = splitter.widget(splitter.indexOf(handle))
    for pane in before, after:
        if pane.objectName() == 'bodyFrame':
            pane.setFocus()
            splitter.zoom_toggle()
            return
        if pane.objectName() == 'outlineFrame':
            pane.setFocus()
            splitter.zoom_toggle(local=True)
            return
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    """Called when user hits tab on an item in the QListWidget."""
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper  # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while (0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    """Handle a wheel event."""
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20130411145310.18857">@g.command("zoom-in")
def zoom_in(event=None, delta=1):
    """increase body font size by one

    @font-size-body must be present in the stylesheet
    """
    zoom_helper(event, delta=1)
</t>
<t tx="tbrown.20140522153032.32656">def zoom_toggle(self, local=False):
    """zoom_toggle - (Un)zoom current pane to be only expanded pane

    :param bool local: just zoom pane within its own splitter
    """
    if self.root.zoomed:
        for ns in self.top().self_and_descendants():
            if hasattr(ns, '_unzoom'):
                # this splitter could have been added since
                ns.setSizes(ns._unzoom)
    else:
        focused = Qt.QApplication.focusWidget()
        parents = []
        parent = focused
        while parent:
            parents.append(parent)
            parent = parent.parent()
        if not focused:
            g.es("Not zoomed, and no focus")
        for ns in (self if local else self.top()).self_and_descendants():
            # FIXME - shouldn't be doing this across windows
            ns._unzoom = ns.sizes()
            for i in range(ns.count()):
                w = ns.widget(i)
                if w in parents:
                    sizes = [0] * len(ns._unzoom)
                    sizes[i] = sum(ns._unzoom)
                    ns.setSizes(sizes)
                    break
    self.root.zoomed = not self.root.zoomed
</t>
<t tx="tbrown.20140522153032.32658">@g.command('free-layout-zoom')
def free_layout_zoom(event):
    """(un)zoom the current pane."""
    c = event.get('c')
    c.free_layout.get_top_splitter().zoom_toggle()
</t>
</tnodes>
</leo_file>
