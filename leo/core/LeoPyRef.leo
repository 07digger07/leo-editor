<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150531102337.1"><vh>@bool tidy-keep-blank-lines = False</vh></v>
<v t="ekr.20150617060607.1"><vh>@bool tidy_autobeautify = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20190406193429.1"><vh>@enabled-plugins</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183832.1"><vh>define_s (@button make-decorators2)</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
<v t="ekr.20190406154306.1"><vh>@button open-pyzo</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh>
<v t="ekr.20170428084123.2"><vh>&lt;&lt; old dir_ settings &gt;&gt;</vh></v>
</v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches</vh></v>
<v t="ekr.20190402091335.1"><vh>script: diff-revs</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20190122185223.1"><vh>regex: find all kwargs</vh></v>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20190116145049.1"><vh>To do</vh>
<v t="ekr.20181008045948.1"><vh>re: Add toggle-gutter command</vh>
<v t="ekr.20110605121601.18163"><vh>dw.createText</vh></v>
<v t="ekr.20110605121601.18143"><vh>dw.createBodyPane</vh></v>
<v t="ekr.20150403094619.1"><vh>class LeoLineTextWidget(QFrame)</vh>
<v t="ekr.20150403094706.9"><vh>__init__(LeoLineTextWidget)</vh></v>
<v t="ekr.20150403094706.10"><vh>eventFilter</vh></v>
</v>
<v t="ekr.20150403094706.2"><vh>class NumberBar(QFrame)</vh>
<v t="ekr.20150403094706.3"><vh>NumberBar.__init__</vh></v>
<v t="ekr.20181005093003.1"><vh>NumberBar.reloadSettings</vh></v>
<v t="ekr.20181005085507.1"><vh>NumberBar.mousePressEvent</vh></v>
<v t="ekr.20150403094706.5"><vh>NumberBar.update</vh></v>
<v t="ekr.20150403094706.6"><vh>NumberBar.paintEvent</vh></v>
<v t="ekr.20150403094706.7"><vh>NumberBar.paintBlock</vh></v>
<v t="ekr.20150403094706.8"><vh>NumberBar.setBold</vh></v>
</v>
<v t="ekr.20181009123539.1"><vh>qt: toggle-gutter</vh></v>
</v>
<v t="ekr.20190116145036.1"><vh>To do: No milestone</vh>
<v t="ekr.20181027151243.1"><vh>#1006: Allow @button and @command only from trusted directories</vh>
<v t="ekr.20181027133311.1"><vh>g.issueSecurityWarning</vh></v>
<v t="ekr.20140114145953.16691"><vh>c.config.isLocalSetting</vh></v>
<v t="ekr.20150514043850.8"><vh>abbrev.init_settings (called from reload_settings)</vh></v>
</v>
<v t="ekr.20180604114211.408"><vh>#388: wikiview.py plugin problem</vh></v>
<v t="ekr.20180604114156.2"><vh>#433: Complete the tables.py plugin</vh>
<v t="ekr.20180604114156.3"><vh>Error running the demo on Windows 10</vh></v>
</v>
<v t="ekr.20180604114211.561"><vh>#678: Graphics version of outline pane</vh></v>
<v t="ekr.20180619063409.1"><vh>#929: Improve FreeMind importer</vh>
<v t="ekr.20160503145550.1"><vh>class FreeMindImporter</vh>
<v t="ekr.20170222084048.1"><vh>freemind.add_children</vh></v>
<v t="ekr.20160503125844.1"><vh>freemind.create_outline</vh></v>
<v t="ekr.20160503191518.4"><vh>freemind.import_file</vh></v>
<v t="ekr.20160503145113.1"><vh>freemind.import_files</vh></v>
<v t="ekr.20160504043823.1"><vh>freemind.prompt_for_files</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20150605175037.1"><vh>@file leoCheck.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810" descendentVnodeUnknownAttributes="7d7100580c000000302e312e31312e322e352e3771017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31382e3171017d71025808000000616e6e6f7461746571037d710473732e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20190330100032.1"><vh>@file ../core/pyzo_shims.py</vh></v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh>
<v t="ekr.20181009084156.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20181009084245.1"><vh>&lt;&lt; compute path &gt;&gt;</vh></v>
<v t="ekr.20181009084323.1"><vh>&lt;&lt; run tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20160124165611.1"><vh>@file ../../launchLeo-unified.spec</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt;</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt;</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt;</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
<v t="ekr.20180604114211.1"><vh>Recent code</vh>
<v t="ekr.20190329040120.1"><vh> Others</vh>
<v t="ekr.20190306105229.1"><vh>6.0: #1032: @clean cleans blank lines</vh>
<v t="ekr.20080708094444.36"><vh>x.propagate_changes</vh></v>
<v t="ekr.20080708094444.38"><vh>x.propagate_changed_lines (main algorithm) &amp; helpers</vh>
<v t="ekr.20150207044400.9"><vh> &lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20150207111757.180"><vh>x.dump_args</vh></v>
<v t="ekr.20150207111757.178"><vh>x.dump_lines</vh></v>
<v t="ekr.20150209044257.6"><vh>x.init_data</vh></v>
<v t="ekr.20080708094444.40"><vh>x.init_ivars</vh></v>
<v t="ekr.20150207044400.16"><vh>x.op_bad</vh></v>
<v t="ekr.20150207044400.12"><vh>x.op_delete</vh></v>
<v t="ekr.20150207044400.13"><vh>x.op_equal</vh></v>
<v t="ekr.20150207044400.14"><vh>x.op_insert</vh></v>
<v t="ekr.20150207044400.15"><vh>x.op_replace</vh></v>
<v t="ekr.20150208060128.7"><vh>x.preprocess</vh></v>
<v t="ekr.20150208223018.4"><vh>x.put_plain_line</vh></v>
<v t="ekr.20150209044257.8"><vh>x.put_sentinels</vh></v>
</v>
<v t="ekr.20190109142026.1"><vh>at.atFileToString</vh></v>
<v t="ekr.20041005105605.157"><vh>at.putFile &amp; helper</vh></v>
<v t="ekr.20041005105605.161"><vh>at.putBody &amp; helper</vh>
<v t="ekr.20041005105605.163"><vh>at.putLine</vh></v>
</v>
<v t="ekr.20041005105605.174"><vh>at.putCodeLine</vh></v>
<v t="ekr.20041005105605.204"><vh>at.os</vh></v>
</v>
<v t="ekr.20190216104815.1"><vh>Maybe: #0525: nested #clean</vh>
<v t="ekr.20190217060648.1"><vh>ref</vh>
<v t="ekr.20190108054317.1"><vh>at.findFilesToRead</vh></v>
<v t="ekr.20190108052043.1"><vh>at.findFilesToWrite</vh></v>
<v t="ekr.20041005105605.174"></v>
<v t="ekr.20041005105605.216"><vh>at.warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20041005105605.144"><vh>at.write &amp; helper</vh></v>
<v t="ekr.20041005105605.147"><vh>at.writeAll &amp; helpers</vh>
<v t="ekr.20190108052043.1"></v>
<v t="ekr.20190108053115.1"><vh>at.internalWriteError</vh></v>
<v t="ekr.20190108112519.1"><vh>at.reportEndOfWrite</vh></v>
<v t="ekr.20140727075002.18108"><vh>at.saveOutlineIfPossible</vh></v>
<v t="ekr.20041005105605.149"><vh>at.writeAllHelper &amp; helper</vh>
<v t="ekr.20150602204757.1"><vh>at.autoBeautify</vh></v>
<v t="ekr.20190108105509.1"><vh>at.writePathChanged</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree</vh></v>
</v>
<v t="ekr.20041005105605.157"></v>
<v t="ekr.20041005105605.161"></v>
<v t="ekr.20041005105605.164"><vh>writing code lines...</vh>
<v t="ekr.20041005105605.165"><vh>at.@all</vh>
<v t="ekr.20041005105605.166"><vh>at.putAtAllLine</vh></v>
<v t="ekr.20041005105605.167"><vh>at.putAtAllBody</vh></v>
<v t="ekr.20041005105605.169"><vh>at.putAtAllChild</vh></v>
</v>
<v t="ekr.20041005105605.170"><vh>at.@others (write)</vh>
<v t="ekr.20041005105605.173"><vh>at.putAtOthersLine &amp; helpers</vh>
<v t="ekr.20041005105605.172"><vh>at.putAtOthersChild</vh></v>
<v t="ekr.20041005105605.171"><vh>at.validInAtOthers (write)</vh></v>
</v>
</v>
<v t="ekr.20041005105605.174"></v>
<v t="ekr.20041005105605.176"><vh>at.putRefLine &amp; helpers</vh>
<v t="ekr.20131224085853.16443"><vh>at.findReference</vh></v>
<v t="ekr.20041005105605.199"><vh>at.findSectionName</vh></v>
<v t="ekr.20041005105605.178"><vh>at.putAfterLastRef</vh></v>
<v t="ekr.20041005105605.179"><vh>at.putAfterMiddleRef</vh></v>
<v t="ekr.20041005105605.177"><vh>at.putRefAt</vh></v>
</v>
</v>
<v t="ekr.20041005105605.173"></v>
<v t="ekr.20041005105605.163"></v>
<v t="ekr.20041005105605.174"></v>
</v>
<v t="ekr.20180824062242.1"><vh>Won't Fix: #0958: freeze in vim mode</vh>
<v t="ekr.20110605121601.18005"><vh>class LeoQTextBrowser (QtWidgets.QTextBrowser)</vh>
<v t="ekr.20110605121601.18006"><vh> lqtb.ctor (** no longer instantiates leo_h)</vh></v>
<v t="ekr.20110605121601.18007"><vh>lqtb. __repr__ &amp; __str__</vh></v>
<v t="ekr.20110605121601.18008"><vh>lqtb.Auto completion</vh>
<v t="ekr.20110605121601.18009"><vh>class LeoQListWidget(QListWidget)</vh>
<v t="ekr.20110605121601.18010"><vh>lqlw.ctor</vh></v>
<v t="ekr.20110605121601.18011"><vh>lqlw.closeEvent</vh></v>
<v t="ekr.20110605121601.18012"><vh>lqlw.end_completer</vh></v>
<v t="ekr.20141024170936.7"><vh>lqlw.get_selection</vh></v>
<v t="ekr.20110605121601.18013"><vh>lqlw.keyPressEvent</vh></v>
<v t="ekr.20110605121601.18014"><vh>lqlw.select_callback</vh></v>
<v t="tbrown.20111011094944.27031"><vh>lqlw.tab_callback</vh></v>
<v t="ekr.20110605121601.18015"><vh>lqlw.set_position</vh></v>
<v t="ekr.20110605121601.18016"><vh>lqlw.show_completions</vh></v>
</v>
<v t="ekr.20110605121601.18017"><vh>lqtb.lqtb.init_completer</vh></v>
<v t="ekr.20110605121601.18018"><vh>lqtb.redirections to LeoQListWidget</vh></v>
</v>
<v t="ekr.20110605121601.18019"><vh>lqtb.leo_dumpButton</vh></v>
<v t="ekr.20141103061944.31"><vh>lqtb.get/setXScrollPosition</vh></v>
<v t="ekr.20111002125540.7021"><vh>lqtb.get/setYScrollPosition</vh></v>
<v t="ekr.20120925061642.13506"><vh>lqtb.onSliderChanged</vh></v>
<v t="tbrown.20130411145310.18855"><vh>lqtb.wheelEvent</vh></v>
</v>
<v t="ekr.20180824062905.1"><vh>lqtb.onFocusIn</vh></v>
</v>
<v t="ekr.20181004060958.1"><vh>re: can not happen in jedi completer</vh>
<v t="ekr.20180519111302.1"><vh>ac.get_jedi_completions &amp; helper</vh>
<v t="ekr.20180526211127.1"><vh>ac.add_prefix</vh></v>
</v>
</v>
</v>
<v t="ekr.20190119062719.1"><vh> Done &amp; documented</vh>
<v t="ekr.20190319150024.1"><vh>#0568: pygments</vh>
<v t="ekr.20190323034724.1"><vh>script: print recolor stats</vh></v>
<v t="ekr.20190324192318.1"><vh>script: make color nodes</vh></v>
<v t="ekr.20190326182642.1"><vh>----- Color settings</vh>
<v t="ekr.20110605121601.18574"><vh>bjc.defineDefaultColorsDict</vh></v>
<v t="ekr.20190324172632.1"><vh>bjc.configure_colors</vh></v>
</v>
<v t="ekr.20190326174530.1"><vh>----- Font settings</vh>
<v t="ekr.20190325053636.1"><vh> leonine styles</vh></v>
<v t="ekr.20041120094940.4"><vh>doFont</vh></v>
<v t="ekr.20041213082558.1"><vh>parseFont &amp; helper</vh>
<v t="ekr.20041213082558.2"><vh>parseFontLine</vh></v>
</v>
<v t="ekr.20110605121601.18575"><vh>bjc.defineDefaultFontDict</vh></v>
<v t="ekr.20190324172242.1"><vh>bjc.configure_fonts &amp; helper</vh>
<v t="ekr.20190326034006.1"><vh>bjc.find_font</vh></v>
</v>
</v>
<v t="ekr.20190326131804.1"><vh>----- Reload-settings</vh>
<v t="ekr.20190327052228.1"><vh>leo_h.reloadSettings</vh></v>
<v t="ekr.20190326183005.1"><vh>jedit.reloadSettings</vh></v>
<v t="ekr.20190324051704.1"><vh>pyg_c.reloadSettings</vh></v>
<v t="ekr.20171114041307.1"><vh>bjc.reloadSettings &amp; helper</vh>
<v t="ekr.20190327053604.1"><vh>bjc.report_changes</vh></v>
</v>
</v>
<v t="ekr.20190327064446.1"><vh>----- trace-coloring</vh>
<v t="ekr.20190327053604.1"></v>
<v t="ekr.20110605121601.18641"><vh>bjc.setTag</vh></v>
<v t="ekr.20110605121601.18637"><vh>jedit.colorRangeWithTag</vh></v>
<v t="ekr.20190326183005.1"></v>
<v t="ekr.20190324051704.1"></v>
</v>
<v t="ekr.20190327072744.1"><vh>----- @language directives</vh>
<v t="ekr.20190323045735.1"><vh>pyg_c.at_language_callback</vh></v>
<v t="ekr.20190322082533.1"><vh>pyg_c.get_lexer</vh></v>
<v t="ekr.20190322094034.1"><vh>pyg_c.patch_lexer</vh></v>
<v t="ekr.20190327111419.1"><vh>Post</vh></v>
</v>
</v>
<v t="ekr.20190121135044.1"><vh>#0926: Organize @outline-data tree-abbreviations</vh></v>
<v t="ekr.20190118130950.1"><vh>#0981 &amp; #0977: File syncing</vh></v>
<v t="ekr.20190119085129.1"><vh>#1047: Tree Window Resizes on Paste Node</vh></v>
<v t="ekr.20190122113449.1"><vh>#1065: refresh-from-disk</vh></v>
<v t="ekr.20190218044303.1"><vh>#1081: @asis</vh></v>
<v t="ekr.20190327143118.1"><vh>#1101: scripting miscellany</vh></v>
<v t="ekr.20190327105736.1"><vh>Added g.get_files_in_directory</vh></v>
<v t="ekr.20190323084212.1"><vh>Added promote-headlines commands</vh></v>
</v>
<v t="ekr.20190329035854.1"><vh> To be documented</vh>
<v t="ekr.20190218071717.1"><vh>#1085: Py3 branch</vh></v>
<v t="ekr.20190327194749.1"><vh>===== #1098: crash in json scanner</vh></v>
<v t="ekr.20190327203238.1"><vh>===== #1090:  --script path</vh>
<v t="ekr.20180312153008.1"><vh>LM.doScriptOption</vh></v>
</v>
<v t="ekr.20190328083346.1"><vh>===== #1018: marks</vh>
<v t="ekr.20031218072017.1579"><vh>fc.putVnodes &amp; helper</vh>
<v t="ekr.20190328160622.1"><vh>fc.setCachedBits</vh></v>
</v>
<v t="ekr.20031218072017.1863"><vh>fc.putVnode &amp; helper</vh>
<v t="ekr.20031218072017.1865"><vh>fc.compute_attribute_bits</vh></v>
</v>
</v>
</v>
<v t="ekr.20190328165019.1"><vh>===== #1100: changes to external files</vh>
<v t="ekr.20150405073203.1"><vh>class ExternalFilesController</vh>
<v t="ekr.20150404083533.1"><vh>efc.ctor</vh></v>
<v t="ekr.20150405105938.1"><vh>efc.entries</vh>
<v t="ekr.20150405194745.1"><vh>efc.check_overwrite (called from c.checkTimeStamp)</vh></v>
<v t="ekr.20031218072017.2613"><vh>efc.destroy_frame</vh></v>
<v t="ekr.20150407141838.1"><vh>efc.find_path_for_node (called from vim.py)</vh></v>
<v t="ekr.20150330033306.1"><vh>efc.on_idle &amp; helpers</vh>
<v t="ekr.20150404045115.1"><vh>efc.idle_check_commander</vh></v>
<v t="ekr.20150403044823.1"><vh>efc.idle_check_at_file_node</vh></v>
<v t="ekr.20150407124259.1"><vh>efc.idle_check_open_with_file &amp; helper</vh>
<v t="ekr.20150407205631.1"><vh>efc.update_open_with_node</vh></v>
</v>
</v>
<v t="ekr.20150404082344.1"><vh>efc.open_with &amp; helpers</vh>
<v t="ekr.20031218072017.2824"><vh>efc.compute_ext</vh></v>
<v t="ekr.20031218072017.2832"><vh>efc.compute_temp_file_path &amp; helpers</vh>
<v t="ekr.20150406055221.2"><vh>efc.clean_file_name</vh></v>
<v t="ekr.20150406055221.3"><vh>efc.legacy_file_name</vh></v>
</v>
<v t="ekr.20100203050306.5937"><vh>efc.create_temp_file</vh></v>
<v t="ekr.20031218072017.2829"><vh>efc.open_file_in_external_editor</vh></v>
<v t="ekr.20190123051253.1"><vh>efc.remove_temp_file</vh></v>
</v>
<v t="ekr.20150404092538.1"><vh>efc.shut_down</vh></v>
</v>
<v t="ekr.20150405110219.1"><vh>efc.utilities</vh>
<v t="ekr.20150405200212.1"><vh>efc.ask</vh></v>
<v t="ekr.20150404052819.1"><vh>efc.checksum</vh></v>
<v t="ekr.20031218072017.2614"><vh>efc.destroy_temp_file</vh></v>
<v t="ekr.20150407204201.1"><vh>efc.get_mtime</vh></v>
<v t="ekr.20150405122428.1"><vh>efc.get_time</vh></v>
<v t="ekr.20150403045207.1"><vh>efc.has_changed</vh></v>
<v t="ekr.20150405104340.1"><vh>efc.is_enabled</vh></v>
<v t="ekr.20150404083049.1"><vh>efc.join</vh></v>
<v t="tbrown.20150904102518.1"><vh>efc.set_time</vh></v>
<v t="ekr.20190218055230.1"><vh>efc.warn</vh></v>
</v>
</v>
<v t="ekr.20150403044823.1"></v>
<v t="ekr.20150403045207.1"></v>
</v>
<v t="ekr.20031218072017.2317"><vh>g.trace</vh></v>
<v t="ekr.20190322082533.1"></v>
<v t="ekr.20190322094034.1"></v>
</v>
<v t="ekr.20180606035619.1"><vh>Recent files</vh>
<v t="ekr.20140907123524.18774"></v>
<v t="ekr.20140907085654.18699"></v>
<v t="ekr.20140907131341.18707"></v>
<v t="ekr.20031218072017.2608"></v>
<v t="ekr.20031218072017.2810" descendentVnodeUnknownAttributes="7d7100580c000000302e312e31312e322e352e3771017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31382e3171017d71025808000000616e6e6f7461746571037d710473732e"></v>
<v t="ekr.20031218072017.3439"></v>
<v t="ekr.20100908125007.6007"><vh>class LeoPluginsController</vh>
<v t="ekr.20100909065501.5954"><vh>plugins.Birth</vh>
<v t="ekr.20100908125007.6034"><vh>plugins.ctor &amp; reloadSettings</vh></v>
<v t="ekr.20100909065501.5974"><vh>plugins.finishCreate &amp; reloadSettings</vh></v>
</v>
<v t="ekr.20100909065501.5952"><vh>plugins.Event handlers</vh>
<v t="ekr.20161029060545.1"><vh>plugins.on_idle</vh></v>
<v t="ekr.20100908125007.6017"><vh>plugins.doHandlersForTag &amp; helper</vh>
<v t="ekr.20100908125007.6016"><vh>plugins.callTagHandler</vh></v>
</v>
<v t="ekr.20100908125007.6018"><vh>plugins.doPlugins (g.app.hookFunction)</vh></v>
</v>
<v t="ekr.20100909065501.5950"><vh>plugins.Information</vh>
<v t="ekr.20100908125007.6019"><vh>plugins.getHandlersForTag</vh></v>
<v t="ekr.20100910075900.10204"><vh>plugins.getLoadedPlugins</vh></v>
<v t="ekr.20100908125007.6020"><vh>plugins.getPluginModule</vh></v>
<v t="ekr.20100908125007.6021"><vh>plugins.isLoaded</vh></v>
<v t="ekr.20100908125007.6025"><vh>plugins.printHandlers</vh></v>
<v t="ekr.20100908125007.6026"><vh>plugins.printPlugins</vh></v>
<v t="ekr.20100908125007.6027"><vh>plugins.printPluginsInfo</vh></v>
<v t="ekr.20100909065501.5949"><vh>plugins.regularizeName</vh></v>
<v t="ekr.20100909104341.5979"><vh>plugins.setLoaded</vh></v>
</v>
<v t="ekr.20100909065501.5953"><vh>plugins.Load &amp; unload</vh>
<v t="ekr.20100908125007.6022"><vh>plugins.loadHandlers</vh></v>
<v t="ekr.20100908125007.6024"><vh>plugins.loadOnePlugin &amp; helper functions</vh>
<v t="ekr.20180528160855.1"><vh>function:callInitFunction</vh></v>
<v t="ekr.20180528162604.1"><vh>function:finishImport</vh></v>
<v t="ekr.20180528160744.1"><vh>function:loadOnePluginHelper</vh></v>
<v t="ekr.20180528162300.1"><vh>function:reportFailedImport</vh></v>
</v>
<v t="ekr.20031218072017.1318"><vh>plugins.plugin_signon</vh></v>
<v t="ekr.20100908125007.6030"><vh>plugins.unloadOnePlugin</vh></v>
</v>
<v t="ekr.20100909065501.5951"><vh>plugins.Registration</vh>
<v t="ekr.20100908125007.6028"><vh>plugins.registerExclusiveHandler</vh></v>
<v t="ekr.20100908125007.6029"><vh>plugins.registerHandler &amp; registerOneHandler</vh></v>
<v t="ekr.20100908125007.6031"><vh>plugins.unregisterHandler</vh></v>
</v>
</v>
</v>
<v t="ekr.20190330100032.1"></v>
<v t="ekr.20190316153545.1"><vh>===== #1096 pyzo</vh>
<v t="ekr.20120212060348.10374"><vh> &lt;&lt; global switches &gt;&gt; (leoGlobals.py)</vh></v>
<v t="ekr.20190402104228.1"><vh>&lt;&lt; MainWindowShim switches &gt;&gt;</vh></v>
<v t="ekr.20031219074948.1"><vh>class g.Tracing/NullObject &amp; helpers</vh>
<v t="ekr.20190330062625.1"><vh>g.null_object_print_attr</vh>
<v t="ekr.20190330072026.1"><vh>&lt;&lt; define suppression lists &gt;&gt;</vh></v>
</v>
<v t="ekr.20190330072832.1"><vh>g.null_object_print</vh></v>
</v>
<v t="ekr.20190404111344.1"><vh>Not used yet</vh>
<v t="ekr.20190401075911.1"><vh>Not used @file ../core/pyzoOutlineTool.py</vh>
<v t="ekr.20190401080432.1"><vh>class PyzoOutlineTool (QWidget)</vh>
<v t="ekr.20190401081245.1"><vh>outline_tool.__init__</vh></v>
</v>
</v>
<v t="ekr.20190404110730.1"><vh> function: createEditor (pyzo_shims.py)</vh>
<v t="ekr.20190404110807.1"><vh>&lt;&lt; createEditor patch &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20190331164202.1"><vh>Done</vh>
<v t="ekr.20190317084039.1"><vh>----- New main window</vh>
<v t="ekr.20110605121601.18141"><vh>dw.createMainWindow &amp; helpers</vh>
<v t="ekr.20110605121601.18142"><vh>dw.top-level</vh>
<v t="ekr.20110605121601.18143"></v>
<v t="ekr.20110605121601.18144"><vh>dw.createCentralWidget</vh></v>
<v t="ekr.20110605121601.18145"><vh>dw.createLogPane &amp; helpers</vh>
<v t="ekr.20131118172620.16858"><vh>dw.finishCreateLogPane (changed)</vh></v>
</v>
<v t="ekr.20110605121601.18146"><vh>dw.createMainLayout</vh></v>
<v t="ekr.20110605121601.18147"><vh>dw.createMenuBar</vh></v>
<v t="ekr.20110605121601.18148"><vh>dw.createMiniBuffer</vh></v>
<v t="ekr.20110605121601.18149"><vh>dw.createOutlinePane</vh></v>
<v t="ekr.20110605121601.18150"><vh>dw.createStatusBar</vh></v>
<v t="ekr.20110605121601.18151"><vh>dw.setMainWindowOptions</vh></v>
</v>
<v t="ekr.20110605121601.18152"><vh>dw.widgets</vh>
<v t="ekr.20110605121601.18153"><vh>dw.createButton</vh></v>
<v t="ekr.20110605121601.18154"><vh>dw.createCheckBox</vh></v>
<v t="ekr.20110605121601.18155"><vh>dw.createFrame</vh></v>
<v t="ekr.20110605121601.18156"><vh>dw.createGrid</vh></v>
<v t="ekr.20110605121601.18157"><vh>dw.createHLayout &amp; createVLayout</vh></v>
<v t="ekr.20110605121601.18158"><vh>dw.createLabel</vh></v>
<v t="ekr.20110605121601.18159"><vh>dw.createLineEdit</vh></v>
<v t="ekr.20110605121601.18160"><vh>dw.createRadioButton</vh></v>
<v t="ekr.20110605121601.18161"><vh>dw.createStackedWidget</vh></v>
<v t="ekr.20110605121601.18162"><vh>dw.createTabWidget</vh></v>
<v t="ekr.20110605121601.18163"></v>
<v t="ekr.20110605121601.18164"><vh>dw.createTreeWidget</vh></v>
</v>
<v t="ekr.20110605121601.18165"><vh>dw.log tabs</vh>
<v t="ekr.20110605121601.18167"><vh>dw.createSpellTab</vh></v>
<v t="ekr.20110605121601.18166"><vh>dw.createFindTab &amp; helpers</vh>
<v t="ekr.20131118152731.16847"><vh>dw.create_find_grid</vh></v>
<v t="ekr.20131118152731.16849"><vh>dw.create_find_header</vh></v>
<v t="ekr.20131118152731.16848"><vh>dw.create_find_findbox</vh></v>
<v t="ekr.20131118152731.16850"><vh>dw.create_find_replacebox</vh></v>
<v t="ekr.20131118152731.16851"><vh>dw.create_find_checkboxes</vh></v>
<v t="ekr.20131118152731.16852"><vh>dw.create_find_buttons</vh></v>
<v t="ekr.20131118152731.16853"><vh>dw.create_help_row</vh></v>
<v t="ekr.20150618072619.1"><vh>dw.create_find_status</vh></v>
<v t="ekr.20131118172620.16891"><vh>dw.override_events</vh>
<v t="ekr.20131118172620.16892"><vh>class EventWrapper</vh>
<v t="ekr.20131120054058.16281"><vh>create_d</vh></v>
<v t="ekr.20131118172620.16893"><vh>wrapper</vh></v>
<v t="ekr.20131118172620.16894"><vh>keyPress (EventWrapper)</vh></v>
<v t="ekr.20131118172620.16895"><vh>keyRelease</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20110605121601.18168"><vh>dw.utils</vh>
<v t="ekr.20110605121601.18169"><vh>dw.setName</vh></v>
<v t="ekr.20110605121601.18170"><vh>dw.setSizePolicy</vh></v>
<v t="ekr.20110605121601.18171"><vh>dw.tr</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18139"><vh>dw.construct &amp; helpers (9 shims)</vh>
<v t="ekr.20140915062551.19519"><vh>dw.set_icon_bar_orientation</vh></v>
</v>
<v t="ekr.20190317084000.1"><vh>dw.createPyzoMainWindow (4 shims)</vh></v>
</v>
<v t="ekr.20190331032906.1"><vh>----- Removed duplicate top-level window</vh>
<v t="ekr.20110605121601.18250"><vh>qtFrame.finishCreate &amp; helpers (5 shims)</vh>
<v t="ekr.20110605121601.18251"><vh>qtFrame.createSplitterComponents</vh></v>
</v>
<v t="ekr.20110605121601.18466"><vh>createFrame (TabbedFrameFactory) </vh></v>
<v t="ekr.20110605121601.18468"><vh>createMaster (TabbedFrameFactory) (1 shim)</vh></v>
<v t="ekr.20190331040800.42"><vh>setTabForCommander (TabbedFrameFactory)</vh>
<v t="ekr.20190331040800.43"><vh>Old:setTabForCommander (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18469"><vh>setTabForCommander (TabbedFrameFactory)</vh></v>
</v>
</v>
<v t="ekr.20190331182937.1"><vh>----- Startup logic</vh>
<v t="ekr.20031218072017.3098"><vh>class g.Bunch (Python Cookbook)</vh></v>
<v t="ekr.20190317084647.3"><vh>MainWindowShim._populate (5 shims)</vh></v>
<v t="ekr.20190317084647.2"><vh>MainWindowShim.__init__</vh></v>
</v>
<v t="ekr.20190329035816.1"><vh>----- Two-step enabling</vh>
<v t="ekr.20180312150559.1"><vh>LM.addOptionsToParser</vh></v>
<v t="ekr.20180312151544.1"><vh>LM.doSimpleOptions</vh></v>
</v>
<v t="ekr.20190402102243.1"><vh>----- Disentable shells &amp; menus</vh>
<v t="ekr.20190402104228.1"></v>
<v t="ekr.20190317084647.2"></v>
<v t="ekr.20190317084647.3"></v>
</v>
</v>
<v t="ekr.20190402143146.1"><vh>No longer used</vh>
<v t="ekr.20190317082435.1"><vh>class SplashShim (QtWidgets.QWidget)</vh></v>
</v>
<v t="ekr.20190329040602.1"><vh>Ref</vh>
<v t="ekr.20190319024244.1"><vh>checkin: DynamicWindow is just an object</vh></v>
<v t="ekr.20190317083529.1"><vh>----- Changed &amp; new</vh>
<v t="ekr.20090717112235.6007"><vh>app.computeSignon &amp; printSignon</vh></v>
<v t="ekr.20120215072959.12539"><vh>c.config.getShortcut (changed)</vh></v>
<v t="ekr.20031219074948.1"></v>
<v t="ekr.20131118172620.16858"></v>
<v t="tbrown.20110621120042.22914"><vh>flc.get_top_splitter (changed)</vh></v>
<v t="ekr.20070626132332"><vh>g.es (changed)</vh></v>
<v t="ekr.20061119120006"><vh>LeoFrame.Icon area convenience methods</vh></v>
<v t="ekr.20130921043420.21175"><vh>qt_gui.setFilter (changed)</vh></v>
<v t="ekr.20110605121601.18421"><vh>qtree.createTreeItem (shim: tree item)</vh></v>
</v>
<v t="ekr.20190319022339.1"><vh>----- Startup logic, in call order</vh>
<v t="ekr.20110605121601.18250"></v>
<v t="ekr.20110605121601.18466"></v>
<v t="ekr.20110605121601.18139"></v>
<v t="ekr.20190317084000.1"></v>
<v t="ekr.20190317084647.2"></v>
<v t="ekr.20190317082603.12"><vh>LeoMainWindow._populate (unchanged)</vh></v>
</v>
<v t="ekr.20190331044953.1"><vh>----- Fixed three hangnails</vh>
<v t="ekr.20190317084647.2"></v>
<v t="ekr.20190317084647.3"></v>
<v t="ekr.20190317084000.1"></v>
</v>
<v t="ekr.20190405080153.1"><vh>----- startup</vh>
<v t="ekr.20120219154958.10487"><vh>LM.doPostPluginsInit &amp; helpers</vh>
<v t="ekr.20120219154958.10489"><vh>LM.make_screen_shot</vh></v>
<v t="ekr.20131028155339.17098"><vh>LM.openEmptyWorkBook</vh></v>
</v>
<v t="ekr.20130930062914.16000"><vh>qt_gui.runMainLoop</vh></v>
<v t="ekr.20100908125007.6022"></v>
</v>
</v>
<v t="ekr.20190401072835.1"><vh>To do</vh>
<v t="ekr.20190329082417.1"><vh>To do: ----- Shutdown logic</vh>
<v t="ekr.20190317084647.5"><vh>MainWindowShim.closeEvent (traces)</vh></v>
</v>
<v t="ekr.20190331165128.1"><vh>To do: ----- Improve tracing in g.Bunch</vh>
<v t="ekr.20031218072017.3098"></v>
</v>
<v t="ekr.20190330115531.1"><vh>To do: ----- rewrite ConfigShim</vh>
<v t="ekr.20190317082751.1"><vh>class ConfigShim</vh>
<v t="ekr.20190331082353.1"><vh>&lt;&lt; define bunch settings &gt;&gt;</vh>
<v t="ekr.20190331082549.1"><vh>&lt;&lt; define bunch shortcuts2 &gt;&gt;</vh></v>
<v t="ekr.20190331082353.2"><vh>&lt;&lt; define editorState2 &gt;&gt;</vh></v>
</v>
<v t="ekr.20190331052308.1"><vh>&lt;&lt; new config methods &gt;&gt;</vh>
<v t="ekr.20190331052308.2"><vh>ConfigShim.__repr__</vh></v>
<v t="ekr.20190331052308.3"><vh>ConfigShim.__getattribute__ </vh></v>
<v t="ekr.20190331052308.4"><vh>ConfigShim.__setattr__ (not used)</vh></v>
</v>
<v t="ekr.20190331052251.1"><vh>&lt;&lt; old config methods &gt;&gt;</vh>
<v t="ekr.20190317082751.2"><vh>ConfigShim.__repr__</vh></v>
<v t="ekr.20190317082751.3"><vh>ConfigShim.__getattribute__</vh></v>
<v t="ekr.20190317082751.4"><vh>ConfigShim.__setattr__</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20190405164143.1"><vh>----- Create working Leo window in pyzo</vh>
<v t="ekr.20190406175538.1"><vh>dir.printObj(dir(self))</vh></v>
<v t="ekr.20190406160609.1"><vh>--- classes</vh>
<v t="ekr.20110605121601.18137"><vh>class  DynamicWindow (QMainWindow)</vh>
<v t="ekr.20110605121601.18138"><vh> ctor &amp; reloadSettings (DynamicWindow)</vh></v>
<v t="ekr.20110605121601.18172"><vh>do_leo_spell_btn_*</vh></v>
<v t="ekr.20110605121601.18139"></v>
<v t="ekr.20110605121601.18141"></v>
<v t="ekr.20190317084000.1"></v>
<v t="ekr.20110605121601.18179"><vh>dw.Event handlers</vh>
<v t="ekr.20110605121601.18140"><vh>dw.closeEvent</vh></v>
</v>
<v t="ekr.20110605121601.18173"><vh>dw.select</vh></v>
<v t="ekr.20110605121601.18178"><vh>dw.setGeometry</vh></v>
<v t="ekr.20110605121601.18177"><vh>dw.setLeoWindowIcon</vh></v>
<v t="ekr.20110605121601.18174"><vh>dw.setSplitDirection</vh></v>
<v t="ekr.20130804061744.12425"><vh>dw.setWindowTitle</vh></v>
</v>
<v t="ekr.20110605121601.18180"><vh>class LeoQtBody(leoFrame.LeoBody)</vh>
<v t="ekr.20150521061618.1"><vh>LeoQtBody.cmd (decorator)</vh></v>
<v t="ekr.20110605121601.18182"><vh>LeoQtBody.ctor &amp; helpers</vh>
<v t="ekr.20110605121601.18185"><vh>LeoQtBody.get_name</vh></v>
<v t="ekr.20140901062324.18562"><vh>LeoQtBody.reloadSettings</vh></v>
<v t="ekr.20160309074124.1"><vh>LeoQtBody.set_invisibles</vh></v>
<v t="ekr.20140901062324.18563"><vh>LeoQtBody.set_widget</vh></v>
<v t="ekr.20110605121601.18183"><vh>LeoQtBody.setWrap</vh></v>
</v>
<v t="ekr.20110605121601.18193"><vh>LeoQtBody.Editors</vh>
<v t="ekr.20110605121601.18194"><vh>LeoQtBody.entries</vh>
<v t="ekr.20110605121601.18195"><vh>LeoQtBody.addEditor &amp; helper</vh>
<v t="ekr.20190118150859.10"><vh>LeoQtBody.createEditor</vh></v>
</v>
<v t="ekr.20110605121601.18197"><vh>LeoQtBody.assignPositionToEditor</vh></v>
<v t="ekr.20110605121601.18198"><vh>LeoQtBody.cycleEditorFocus</vh></v>
<v t="ekr.20110605121601.18199"><vh>LeoQtBody.deleteEditor</vh></v>
<v t="ekr.20110605121601.18200"><vh>LeoQtBody.findEditorForChapter</vh></v>
<v t="ekr.20110605121601.18201"><vh>LeoQtBody.select/unselectLabel</vh></v>
<v t="ekr.20110605121601.18202"><vh>LeoQtBody.selectEditor &amp; helpers</vh>
<v t="ekr.20110605121601.18203"><vh>LeoQtBody.selectEditorHelper</vh></v>
</v>
<v t="ekr.20110605121601.18205"><vh>LeoQtBody.updateEditors</vh></v>
</v>
<v t="ekr.20110605121601.18206"><vh>LeoQtBody.utils</vh>
<v t="ekr.20110605121601.18207"><vh>LeoQtBody.computeLabel</vh></v>
<v t="ekr.20110605121601.18208"><vh>LeoQtBody.createChapterIvar</vh></v>
<v t="ekr.20110605121601.18209"><vh>LeoQtBody.deactivateEditors</vh></v>
<v t="ekr.20110605121601.18210"><vh>LeoQtBody.ensurePositionExists</vh></v>
<v t="ekr.20110605121601.18211"><vh>LeoQtBody.injectIvars</vh></v>
<v t="ekr.20110605121601.18212"><vh>LeoQtBody.packLabel</vh></v>
<v t="ekr.20110605121601.18213"><vh>LeoQtBody.recolorWidget (QScintilla only)</vh></v>
<v t="ekr.20110605121601.18214"><vh>LeoQtBody.switchToChapter</vh></v>
<v t="ekr.20110605121601.18216"><vh>LeoQtBody.unpackWidget</vh></v>
<v t="ekr.20110605121601.18215"><vh>LeoQtBody.updateInjectedIvars</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18223"><vh>LeoQtBody.Event handlers</vh>
<v t="ekr.20110930174206.15472"><vh>LeoQtBody.onFocusIn</vh></v>
<v t="ekr.20110930174206.15473"><vh>LeoQtBody.onFocusOut</vh></v>
<v t="ekr.20110605121601.18224"><vh>LeoQtBody.qtBody.onFocusColorHelper (revised)</vh></v>
</v>
<v t="ekr.20110605121601.18217"><vh>LeoQtBody.Renderer panes</vh>
<v t="ekr.20110605121601.18218"><vh>LeoQtBody.hideCanvasRenderer</vh></v>
<v t="ekr.20110605121601.18219"><vh>LeoQtBody.hideTextRenderer</vh></v>
<v t="ekr.20110605121601.18220"><vh>LeoQtBody.packRenderer</vh></v>
<v t="ekr.20110605121601.18221"><vh>LeoQtBody.showCanvasRenderer</vh></v>
<v t="ekr.20110605121601.18222"><vh>LeoQtBody.showTextRenderer</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18005"></v>
<v t="ekr.20110605121601.18245"><vh>class LeoQtFrame (leoFrame)</vh>
<v t="ekr.20110605121601.18246"><vh> qtFrame.Birth &amp; Death</vh>
<v t="ekr.20110605121601.18247"><vh>qtFrame.__init__ &amp; reloadSettings</vh>
<v t="ekr.20110605121601.18248"><vh>qtFrame.setIvars</vh></v>
</v>
<v t="ekr.20110605121601.18249"><vh>qtFrame.__repr__</vh></v>
<v t="ekr.20150509040227.1"><vh>qtFrame.cmd (decorator)</vh></v>
<v t="ekr.20110605121601.18250"></v>
<v t="ekr.20110605121601.18252"><vh>qtFrame.initCompleteHint</vh></v>
<v t="ekr.20110605121601.18253"><vh>Destroying the qtFrame</vh>
<v t="ekr.20110605121601.18254"><vh>qtFrame.destroyAllObjects (not used)</vh>
<v t="ekr.20110605121601.18255"><vh>&lt;&lt; clear all vnodes in the tree&gt;&gt; (qtFrame)</vh></v>
</v>
<v t="ekr.20110605121601.18256"><vh>qtFrame.destroySelf</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18257"><vh>qtFrame.class QtStatusLineClass</vh>
<v t="ekr.20110605121601.18258"><vh>QtStatusLineClass.ctor</vh></v>
<v t="ekr.20110605121601.18260"><vh>QtStatusLineClass.clear, get &amp; put/1</vh></v>
<v t="chris.20180320072817.1"><vh>QtStatusLineClass.update &amp; helpers</vh>
<v t="ekr.20190118082646.1"><vh>qstatus.compute_columns</vh></v>
<v t="chris.20180320072817.2"><vh>qstatus.file_line (not used)</vh></v>
<v t="ekr.20190118082047.1"><vh>qstatus.put_status_line</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18262"><vh>qtFrame.class QtIconBarClass (object)</vh>
<v t="ekr.20110605121601.18263"><vh> ctor &amp; reloadSettings (QtIconBarClass)</vh></v>
<v t="ekr.20110605121601.18264"><vh> do-nothings (QtIconBarClass)</vh></v>
<v t="ekr.20110605121601.18265"><vh>add (QtIconBarClass)</vh></v>
<v t="ekr.20110605121601.18266"><vh>addRowIfNeeded</vh></v>
<v t="ekr.20110605121601.18267"><vh>addWidget</vh></v>
<v t="ekr.20110605121601.18268"><vh>clear (QtIconBarClass)</vh></v>
<v t="ekr.20110605121601.18269"><vh>createChaptersIcon</vh></v>
<v t="ekr.20110605121601.18270"><vh>deleteButton</vh></v>
<v t="ekr.20141031053508.14"><vh>goto_command (QtIconBarClass)</vh></v>
<v t="ekr.20110605121601.18271"><vh>setCommandForButton (@rclick nodes) &amp; helper</vh>
<v t="ekr.20141031053508.15"><vh>add_rclick_menu (QtIconBarClass)</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18274"><vh>qtFrame.Configuration</vh>
<v t="ekr.20110605121601.18275"><vh>qtFrame.configureBar</vh></v>
<v t="ekr.20110605121601.18276"><vh>qtFrame.configureBarsFromConfig</vh></v>
<v t="ekr.20110605121601.18277"><vh>qtFrame.reconfigureFromConfig</vh></v>
<v t="ekr.20110605121601.18278"><vh>qtFrame.setInitialWindowGeometry</vh></v>
<v t="ekr.20110605121601.18279"><vh>qtFrame.setTabWidth</vh></v>
<v t="ekr.20110605121601.18280"><vh>qtFrame.setWrap</vh></v>
<v t="ekr.20110605121601.18281"><vh>qtFrame.reconfigurePanes</vh></v>
<v t="ekr.20110605121601.18282"><vh>qtFrame.resizePanesToRatio</vh></v>
<v t="ekr.20110605121601.18283"><vh>qtFrame.divideLeoSplitter1/2</vh></v>
<v t="ekr.20110605121601.18284"><vh>qtFrame.divideAnySplitter</vh></v>
</v>
<v t="ekr.20110605121601.18285"><vh>qtFrame.Event handlers</vh>
<v t="ekr.20110605121601.18286"><vh>qtFrame.OnCloseLeoEvent</vh></v>
<v t="ekr.20110605121601.18287"><vh>qtFrame.OnControlKeyUp/Down</vh></v>
<v t="ekr.20110605121601.18290"><vh>qtFrame.OnActivateTree</vh></v>
<v t="ekr.20110605121601.18291"><vh>qtFrame.OnBodyClick, OnBodyRClick (not used)</vh></v>
<v t="ekr.20110605121601.18292"><vh>qtFrame.OnBodyDoubleClick (Events) (not used)</vh></v>
</v>
<v t="ekr.20110605121601.18293"><vh>qtFrame.Gui-dependent commands</vh>
<v t="ekr.20110605121601.18294"><vh>qtFrame.Minibuffer commands...</vh>
<v t="ekr.20110605121601.18295"><vh>qtFrame.contractPane</vh></v>
<v t="ekr.20110605121601.18296"><vh>qtFrame.expandPane</vh></v>
<v t="ekr.20110605121601.18297"><vh>qtFrame.fullyExpandPane</vh></v>
<v t="ekr.20110605121601.18298"><vh>qtFrame.hidePane</vh></v>
<v t="ekr.20110605121601.18299"><vh>qtFrame.expand/contract/hide...Pane</vh></v>
<v t="ekr.20110605121601.18300"><vh>qtFrame.fullyExpand/hide...Pane</vh></v>
</v>
<v t="ekr.20110605121601.18301"><vh>qtFrame.Window Menu...</vh>
<v t="ekr.20110605121601.18302"><vh>qtFrame.toggleActivePane</vh></v>
<v t="ekr.20110605121601.18303"><vh>qtFrame.cascade</vh></v>
<v t="ekr.20110605121601.18304"><vh>qtFrame.equalSizedPanes</vh></v>
<v t="ekr.20110605121601.18305"><vh>qtFrame.hideLogWindow</vh></v>
<v t="ekr.20110605121601.18306"><vh>qtFrame.minimizeAll</vh></v>
<v t="ekr.20110605121601.18307"><vh>qtFrame.toggleSplitDirection</vh></v>
<v t="ekr.20110605121601.18308"><vh>qtFrame.resizeToScreen</vh></v>
</v>
<v t="ekr.20110605121601.18309"><vh>qtFrame.Help Menu...</vh>
<v t="ekr.20110605121601.18310"><vh>qtFrame.leoHelp</vh></v>
</v>
</v>
<v t="ekr.20160424080647.1"><vh>qtFrame.Properties (new)</vh>
<v t="ekr.20160424080815.2"><vh>qtFrame.ratio property</vh></v>
<v t="ekr.20160424080815.3"><vh>qtFrame.secondary_ratio property</vh></v>
</v>
<v t="ekr.20110605121601.18311"><vh>qtFrame.Qt bindings...</vh></v>
</v>
<v t="ekr.20110605121601.18312"><vh>class LeoQtLog (LeoLog)</vh>
<v t="ekr.20150717102609.1"><vh>LeoQtLog.cmd (decorator)</vh></v>
<v t="ekr.20110605121601.18313"><vh>LeoQtLog.Birth</vh>
<v t="ekr.20110605121601.18314"><vh>LeoQtLog.__init__ &amp; reloadSettings</vh></v>
<v t="ekr.20110605121601.18315"><vh>LeoQtLog.finishCreate</vh></v>
<v t="ekr.20110605121601.18316"><vh>LeoQtLog.getName</vh></v>
</v>
<v t="ekr.20150717102728.1"><vh>LeoQtLog.Commands</vh></v>
<v t="ekr.20110605121601.18333"><vh>LeoQtLog.color tab stuff</vh></v>
<v t="ekr.20110605121601.18334"><vh>LeoQtLog.font tab stuff</vh>
<v t="ekr.20110605121601.18335"><vh>LeoQtLog.createFontPicker</vh></v>
<v t="ekr.20110605121601.18339"><vh>LeoQtLog.hideFontTab</vh></v>
</v>
<v t="ekr.20111120124732.10184"><vh>LeoQtLog.isLogWidget</vh></v>
<v t="tbnorth.20171220123648.1"><vh>LeoQtLog.linkClicked</vh></v>
<v t="ekr.20120304214900.9940"><vh>LeoQtLog.onCurrentChanged</vh></v>
<v t="ekr.20110605121601.18321"><vh>LeoQtLog.put &amp; putnl</vh>
<v t="ekr.20110605121601.18322"><vh>LeoQtLog.put</vh></v>
<v t="ekr.20110605121601.18323"><vh>LeoQtLog.putnl</vh></v>
<v t="ekr.20150205181818.5"><vh>LeoQtLog.scrollToEnd</vh></v>
</v>
<v t="ekr.20120913110135.10613"><vh>LeoQtLog.putImage</vh></v>
<v t="ekr.20110605121601.18324"><vh>LeoQtLog.Tab</vh>
<v t="ekr.20110605121601.18325"><vh>LeoQtLog.clearTab</vh></v>
<v t="ekr.20110605121601.18326"><vh>LeoQtLog.createTab</vh></v>
<v t="ekr.20110605121601.18327"><vh>LeoQtLog.cycleTabFocus</vh></v>
<v t="ekr.20110605121601.18328"><vh>LeoQtLog.deleteTab</vh></v>
<v t="ekr.20110605121601.18329"><vh>LeoQtLog.hideTab</vh></v>
<v t="ekr.20111122080923.10185"><vh>LeoQtLog.orderedTabNames</vh></v>
<v t="ekr.20110605121601.18330"><vh>LeoQtLog.numberOfVisibleTabs</vh></v>
<v t="ekr.20110605121601.18331"><vh>LeoQtLog.selectTab &amp; helper</vh>
<v t="ekr.20110605121601.18332"><vh>LeoQtLog.selectHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20160514120051.1"><vh>class LeoQtTree</vh>
<v t="ekr.20110605121601.18404"><vh>qtree.Birth</vh>
<v t="ekr.20110605121601.18405"><vh>qtree.__init__</vh></v>
<v t="ekr.20110605121601.17866"><vh>qtree.get_name</vh></v>
<v t="ekr.20110605121601.18406"><vh>qtree.initAfterLoad</vh></v>
<v t="ekr.20110605121601.17871"><vh>qtree.reloadSettings</vh></v>
<v t="ekr.20110605121601.17940"><vh>qtree.wrapQLineEdit</vh></v>
</v>
<v t="ekr.20110605121601.17868"><vh>qtree.Debugging &amp; tracing</vh></v>
<v t="ekr.20110605121601.17872"><vh>qtree.Drawing</vh>
<v t="ekr.20110605121601.18408"><vh>qtree.clear</vh></v>
<v t="ekr.20180810052056.1"><vh>qtree.drawVisible &amp; helpers (not used)</vh>
<v t="ekr.20180810052056.2"><vh>qtree.yieldVisible</vh></v>
<v t="ekr.20180810052056.3"><vh>qtree.slowYieldVisible</vh></v>
</v>
<v t="ekr.20110605121601.17873"><vh>qtree.full_redraw &amp; helpers</vh>
<v t="tbrown.20150807093655.1"><vh>qtree.clear_visual_icons</vh></v>
<v t="tbrown.20150807090639.1"><vh>qtree.declutter_node &amp; helpers</vh>
<v t="ekr.20171122064635.1"><vh>qtree.declutter_replace</vh></v>
<v t="ekr.20171122055719.1"><vh>qtree.declutter_style</vh></v>
</v>
<v t="ekr.20110605121601.17874"><vh>qtree.drawChildren</vh></v>
<v t="ekr.20110605121601.17875"><vh>qtree.drawNode</vh></v>
<v t="ekr.20110605121601.17876"><vh>qtree.drawTopTree</vh></v>
<v t="ekr.20110605121601.17877"><vh>qtree.drawTree</vh></v>
<v t="ekr.20110605121601.17878"><vh>qtree.initData</vh></v>
<v t="tbrown.20150808075906.1"><vh>qtree.update_appearance (no longer used)</vh></v>
<v t="tbrown.20150808082111.1"><vh>qtree.update_appearance_idle (no longer used)</vh></v>
</v>
<v t="ekr.20110605121601.17880"><vh>qtree.redraw_after_contract</vh></v>
<v t="ekr.20110605121601.17881"><vh>qtree.redraw_after_expand</vh></v>
<v t="ekr.20110605121601.17882"><vh>qtree.redraw_after_head_changed</vh></v>
<v t="ekr.20110605121601.17883"><vh>qtree.redraw_after_icons_changed</vh></v>
<v t="ekr.20110605121601.17884"><vh>qtree.redraw_after_select</vh></v>
<v t="ekr.20140907201613.18986"><vh>qtree.repaint (not used)</vh></v>
<v t="ekr.20180817043619.1"><vh>qtree.update_expansion</vh></v>
</v>
<v t="ekr.20110605121601.17885"><vh>qtree.Event handlers</vh>
<v t="ekr.20110605121601.17887"><vh> qtree.Click Box</vh>
<v t="ekr.20110605121601.17888"><vh>qtree.onClickBoxClick</vh></v>
<v t="ekr.20110605121601.17889"><vh>qtree.onClickBoxRightClick</vh></v>
<v t="ekr.20110605121601.17890"><vh>qtree.onPlusBoxRightClick</vh></v>
</v>
<v t="ekr.20110605121601.17891"><vh> qtree.Icon Box</vh>
<v t="ekr.20110605121601.17892"><vh>qtree.onIconBoxClick</vh></v>
<v t="ekr.20110605121601.17893"><vh>qtree.onIconBoxRightClick</vh></v>
<v t="ekr.20110605121601.17894"><vh>qtree.onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20110605121601.18437"><vh>qtree.onContextMenu</vh></v>
<v t="ekr.20110605121601.17912"><vh>qtree.onHeadChanged</vh>
<v t="ekr.20120409185504.10028"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20110605121601.17896"><vh>qtree.onItemClicked</vh></v>
<v t="ekr.20110605121601.17895"><vh>qtree.onItemCollapsed</vh></v>
<v t="ekr.20110605121601.17897"><vh>qtree.onItemDoubleClicked</vh></v>
<v t="ekr.20110605121601.17898"><vh>qtree.onItemExpanded</vh></v>
<v t="ekr.20110605121601.17899"><vh>qtree.onTreeSelect</vh></v>
<v t="ekr.20110605121601.17900"><vh>qtree.OnPopup &amp; allies</vh>
<v t="ekr.20110605121601.17901"><vh>qtree.OnPopupFocusLost</vh></v>
<v t="ekr.20110605121601.17902"><vh>qtree.createPopupMenu</vh></v>
<v t="ekr.20110605121601.17903"><vh>qtree.enablePopupMenuItems</vh></v>
<v t="ekr.20110605121601.17904"><vh>qtree.showPopupMenu</vh></v>
</v>
</v>
<v t="ekr.20110605121601.17944"><vh>qtree.Focus</vh></v>
<v t="ekr.20110605121601.18409"><vh>qtree.Icons</vh>
<v t="ekr.20110605121601.18410"><vh>qtree.drawIcon</vh></v>
<v t="ekr.20110605121601.17946"><vh>qtree.drawItemIcon</vh></v>
<v t="ekr.20110605121601.18411"><vh>qtree.getIcon &amp; helper</vh>
<v t="ekr.20110605121601.18412"><vh>qtree.getCompositeIconImage</vh></v>
</v>
<v t="ekr.20110605121601.17947"><vh>qtree.getIconImage</vh></v>
<v t="ekr.20110605121601.17948"><vh>qtree.getStatusIconImage</vh></v>
<v t="ekr.20110605121601.17949"><vh>qtree.getVnodeIcon</vh></v>
<v t="ekr.20110605121601.17950"><vh>qtree.setItemIcon</vh></v>
<v t="ekr.20110605121601.18413"><vh>qtree.setItemIconHelper</vh></v>
<v t="ekr.20110605121601.17951"><vh>qtree.updateIcon</vh></v>
<v t="ekr.20110605121601.17952"><vh>qtree.updateVisibleIcons</vh></v>
</v>
<v t="ekr.20110605121601.18414"><vh>qtree.Items</vh>
<v t="ekr.20110605121601.17943"><vh> qtree.item dict getters</vh></v>
<v t="ekr.20110605121601.18415"><vh>qtree.childIndexOfItem</vh></v>
<v t="ekr.20110605121601.18416"><vh>qtree.childItems</vh></v>
<v t="ekr.20110605121601.18417"><vh>qtree.closeEditorHelper</vh></v>
<v t="ekr.20110605121601.18418"><vh>qtree.connectEditorWidget &amp; helper</vh></v>
<v t="ekr.20110605121601.18419"><vh>qtree.contractItem &amp; expandItem</vh></v>
<v t="ekr.20110605121601.18420"><vh>qtree.createTreeEditorForItem</vh></v>
<v t="ekr.20110605121601.18421"></v>
<v t="ekr.20110605121601.18422"><vh>qtree.editLabelHelper</vh></v>
<v t="ekr.20110605121601.18423"><vh>qtree.getCurrentItem</vh></v>
<v t="ekr.20110605121601.18424"><vh>qtree.getItemText</vh></v>
<v t="ekr.20110605121601.18425"><vh>qtree.getParentItem</vh></v>
<v t="ekr.20110605121601.18426"><vh>qtree.getSelectedItems</vh></v>
<v t="ekr.20110605121601.18427"><vh>qtree.getTreeEditorForItem</vh></v>
<v t="ekr.20110605121601.18428"><vh>qtree.getWrapper</vh></v>
<v t="ekr.20110605121601.18429"><vh>qtree.nthChildItem</vh></v>
<v t="ekr.20110605121601.18430"><vh>qtree.scrollToItem</vh></v>
<v t="ekr.20110605121601.18431"><vh>qtree.setCurrentItemHelper</vh></v>
<v t="ekr.20110605121601.18432"><vh>qtree.setItemText</vh></v>
<v t="tbrown.20160406221505.1"><vh>qtree.sizeTreeEditor</vh></v>
</v>
<v t="ekr.20110605121601.18433"><vh>qtree.Scroll bars</vh>
<v t="ekr.20110605121601.18434"><vh>qtree.getSCroll</vh></v>
<v t="btheado.20111110215920.7164"><vh>qtree.scrollDelegate</vh></v>
<v t="ekr.20110605121601.18435"><vh>qtree.setH/VScroll</vh></v>
</v>
<v t="ekr.20110605121601.17905"><vh>qtree.Selecting &amp; editing</vh>
<v t="ekr.20110605121601.17908"><vh>qtree.edit_widget</vh></v>
<v t="ekr.20110605121601.17909"><vh>qtree.editLabel</vh></v>
<v t="ekr.20110605121601.17910"><vh>qtree.editPosition (no longer used)</vh></v>
<v t="ekr.20110605121601.17911"><vh>qtree.endEditLabel</vh></v>
<v t="ekr.20110605121601.17915"><vh>qtree.getSelectedPositions</vh></v>
<v t="ekr.20110605121601.17914"><vh>qtree.setHeadline</vh></v>
<v t="ekr.20110605121601.17913"><vh>qtree.setItemForCurrentPosition</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18262"></v>
</v>
<v t="ekr.20031218072017.2188"><vh>app.newCommander</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helpers</vh>
<v t="ekr.20140815160132.18835"><vh>c.createCommandNames</vh></v>
<v t="ekr.20051007143620"><vh>c.printCommandsDict</vh></v>
</v>
<v t="ekr.20110605121601.18250"></v>
</v>
<v t="ekr.20110605121601.18251"></v>
<v t="ekr.20140901062324.18563"></v>
<v t="ekr.20190401085747.1"><vh>class OutlineEditorShim (QFrame)</vh>
<v t="ekr.20190406194351.1"><vh>&lt;&lt; shim classes for OutlineEditorShim &gt;&gt;</vh></v>
<v t="ekr.20190405075322.1"><vh>OutlineEditorShim.__init__</vh></v>
<v t="ekr.20190405075440.1"><vh>OutlineEditorShim.createOutlineFrame (REWRITE)</vh></v>
<v t="ekr.20190405075412.1"><vh>OutlineEditorShim:do-nothings</vh></v>
<v t="ekr.20190406165302.1"><vh>OutlineEditorShim:set_style</vh></v>
</v>
<v t="ekr.20190405075440.1"></v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="btheado.20111110215920.7164">def scrollDelegate(self, kind):
    '''Scroll a QTreeWidget up or down or right or left.
    kind is in ('down-line','down-page','up-line','up-page', 'right', 'left')
    '''
    c = self.c; w = self.treeWidget
    if kind in ('left', 'right'):
        hScroll = w.horizontalScrollBar()
        if kind == 'right':
            delta = hScroll.pageStep()
        else:
            delta = -hScroll.pageStep()
        hScroll.setValue(hScroll.value() + delta)
    else:
        vScroll = w.verticalScrollBar()
        h = w.size().height()
        lineSpacing = w.fontMetrics().lineSpacing()
        n = h / lineSpacing
        if kind == 'down-half-page': delta = n / 2
        elif kind == 'down-line': delta = 1
        elif kind == 'down-page': delta = n
        elif kind == 'up-half-page': delta = -n / 2
        elif kind == 'up-line': delta = -1
        elif kind == 'up-page': delta = -n
        else:
            delta = 0
            g.trace('bad kind:', kind)
        val = vScroll.value()
        vScroll.setValue(val + delta)
    c.treeWantsFocus()
</t>
<t tx="chris.20180320072817.1">def update(self):
    if g.app.killed: return
    c, body = self.c, self.c.frame.body
    if not c.p:
        return
    te = body.widget
    if not isinstance(te, QtWidgets.QTextEdit):
        return
    cursor = te.textCursor()
    block = cursor.block()
    row = block.blockNumber() + 1
    col, fcol = self.compute_columns(block, cursor)
    words = len(c.p.b.split(None))
    self.put_status_line(col, fcol, row, words)
    self.lastRow = row
    self.lastCol = col
    self.lastFcol = fcol
</t>
<t tx="chris.20180320072817.2">def file_line(self):
    '''
    Return the line of the first line of c.p in its external file.
    Return None if c.p is not part of an external file.
    '''
    c, p = self.c, self.c.p
    if p:
        goto = gotoCommands.GoToCommands(c)
        return goto.find_node_start(p)
    else:
        return None
</t>
<t tx="ekr.20031218072017.1318">def plugin_signon(self, module_name, verbose=False):
    '''Print the plugin signon.'''
    # This is called from as the result of the imports
    # in self.loadOnePlugin
    m = self.signonModule
    if verbose:
        g.es('', "...%s.py v%s: %s" % (
            m.__name__, m.__version__, g.plugin_date(m)))
        g.pr(m.__name__, m.__version__)
    self.signonModule = None # Prevent double signons.
</t>
<t tx="ekr.20031218072017.1579">new = True

def putVnodes(self, p=None):
    """Puts all &lt;v&gt; elements in the order in which they appear in the outline."""
    c = self.c
    c.clearAllVisited()
    self.put("&lt;vnodes&gt;\n")
    # Make only one copy for all calls.
    self.currentPosition = p or c.p
    self.rootPosition = c.rootPosition()
    self.vnodesDict = {}
    if self.usingClipboard:
        self.expanded_gnxs, self.marked_gnxs = set(), set()
            # These will be ignored.
        self.putVnode(self.currentPosition)
            # Write only current tree.
    else:
        for p in c.rootPosition().self_and_siblings():
            self.putVnode(p, isIgnore=p.isAtIgnoreNode())
        # Fix #1018: scan *all* nodes.
        self.setCachedBits()
    self.put("&lt;/vnodes&gt;\n")
</t>
<t tx="ekr.20031218072017.1863">def putVnode(self, p, isIgnore=False):
    """Write a &lt;v&gt; element corresponding to a VNode."""
    fc = self
    v = p.v
    #
    # Precompute constants.
    isAuto = p.isAtAutoNode() and p.atAutoNodeName().strip()
    isEdit = p.isAtEditNode() and p.atEditNodeName().strip() and not p.hasChildren()
        # Write the entire @edit tree if it has children.
    isFile = p.isAtFileNode()
    isShadow = p.isAtShadowFileNode()
    isThin = p.isAtThinFileNode()
    #
    # Set forcewrite.
    if isIgnore or p.isAtIgnoreNode():
        forceWrite = True
    elif isAuto or isEdit or isFile or isShadow or isThin:
        forceWrite = False
    else:
        forceWrite = True
    #
    # Set the write bit if necessary.
    gnx = v.fileIndex
    if forceWrite or self.usingClipboard:
        v.setWriteBit() # 4.2: Indicate we wrote the body text.

    attrs = fc.compute_attribute_bits(forceWrite, p)
    #
    # Write the node.
    v_head = '&lt;v t="%s"%s&gt;' % (gnx, attrs)
    if gnx in fc.vnodesDict:
        fc.put(v_head + '&lt;/v&gt;\n')
    else:
        fc.vnodesDict[gnx] = True
        v_head += '&lt;vh&gt;%s&lt;/vh&gt;' % (xml.sax.saxutils.escape(p.v.headString() or ''))
        # New in 4.2: don't write child nodes of @file-thin trees
        # (except when writing to clipboard)
        if p.hasChildren() and (forceWrite or self.usingClipboard):
            fc.put('%s\n' % v_head)
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p, isIgnore)
                if p.hasNext(): p.moveToNext()
                else: break
            p.moveToParent() # Restore p in the caller.
            fc.put('&lt;/v&gt;\n')
        else:
            fc.put('%s&lt;/v&gt;\n' % v_head) # Call put only once.
</t>
<t tx="ekr.20031218072017.1865">def compute_attribute_bits(self, forceWrite, p):
    '''Return the initial values of v's attributes.'''
    attrs = []
    if p.hasChildren() and not forceWrite and not self.usingClipboard:
        # Fix #526: do this for @auto nodes as well.
        attrs.append(self.putDescendentVnodeUas(p))
        # Fix #1023: never put marked/expanded bits.
            # attrs.append(self.putDescendentAttributes(p))
    return ''.join(attrs)
</t>
<t tx="ekr.20031218072017.2188">def newCommander(self, fileName, relativeFileName=None, gui=None, previousSettings=None):
    """Create a commander and its view frame for the Leo main window."""
    # Create the commander and its subcommanders.
    # This takes about 3/4 sec when called by the leoBridge module.
    import leo.core.leoCommands as leoCommands
    if g.pyzo:
        g.pr('----- app.newCommander', g.shortFileName(fileName))
    return leoCommands.Commands(fileName, relativeFileName, gui, previousSettings)
</t>
<t tx="ekr.20031218072017.2317">def trace(*args, **keys):
    '''Print a tracing message.'''
    # Don't use g here: in standalone mode g is a NullObject!
    # Compute the effective args.
    d = {'align': 0, 'before': '', 'newline': True, 'caller_level': 1, 'noname': False}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    align = d.get('align', 0)
    caller_level = d.get('caller_level', 1)
    noname = d.get('noname')
    # Compute the caller name.
    if noname:
        name = ''
    else:
        try: # get the function name from the call stack.
            f1 = sys._getframe(caller_level) # The stack frame, one level up.
            code1 = f1.f_code # The code object
            name = code1.co_name # The code name
        except Exception:
            name = g.shortFileName(__file__)
        if name == '&lt;module&gt;':
            name = g.shortFileName(__file__)
        if name.endswith('.pyc'):
            name = name[: -1]
    # Pad the caller name.
    if align != 0 and len(name) &lt; abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align &gt; 0: name = name + pad
        else: name = pad + name
    # Munge *args into s.
    result = [name] if name else []
    #
    # Put leading newlines into the prefix.
    if isinstance(args, tuple):
        args = list(args)
    if args and isString(args[0]):
        prefix = ''
        while args[0].startswith('\n'):
            prefix += '\n'
            args[0] = args[0][1:]
    else:
        prefix = ''
    for arg in args:
        if isString(arg):
            pass
        elif isBytes(arg):
            arg = toUnicode(arg)
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = d.get('before') + ''.join(result)
    if prefix:
        prefix = prefix[1:] # One less newline.
        pr(prefix)
    pr(s, newline=newline)
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.
# See the "About this file" node for important notes.
@language python
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2613">def destroy_frame(self, frame):
    """
    Close all "Open With" files associated with frame.
    Called by g.app.destroyWindow.
    """
    files = [ef for ef in self.files if ef.c.frame == frame]
    paths = [ef.path for ef in files]
    for ef in files:
        self.destroy_temp_file(ef)
    self.files = [z for z in self.files if z.path not in paths]
</t>
<t tx="ekr.20031218072017.2614">def destroy_temp_file(self, ef):
    '''Destroy the *temp* file corresponding to ef, an ExternalFile instance.'''
    # Do not use g.trace here.
    if ef.path and g.os_path_exists(ef.path):
        try:
            os.remove(ef.path)
        except Exception:
            pass
</t>
<t tx="ekr.20031218072017.2824">def compute_ext(self, c, p, ext):
    '''Return the file extension to be used in the temp file.'''
    if ext:
        for ch in ("'", '"'):
            if ext.startswith(ch): ext = ext.strip(ch)
    if not ext:
        # if node is part of @&lt;file&gt; tree, get ext from file name
        for p2 in p.self_and_parents(copy=False):
            if p2.isAnyAtFileNode():
                fn = p2.h.split(None, 1)[1]
                ext = g.os_path_splitext(fn)[1]
                break
    if not ext:
        theDict = c.scanAllDirectives()
        language = theDict.get('language')
        ext = g.app.language_extension_dict.get(language)
    if not ext:
        ext = '.txt'
    if ext[0] != '.':
        ext = '.' + ext
    return ext
</t>
<t tx="ekr.20031218072017.2829">def open_file_in_external_editor(self, c, d, fn, testing=False):
    '''
    Open a file fn in an external editor.

    This will be an entire external file, or a temp file for a single node.

    d is a dictionary created from an @openwith settings node.

        'args':     the command-line arguments to be used to open the file.
        'ext':      the file extension.
        'kind':     the method used to open the file, such as subprocess.Popen.
        'name':     menu label (used only by the menu code).
        'p':        the nearest @&lt;file&gt; node, or None.
        'shortcut': menu shortcut (used only by the menu code).
    '''
    testing = testing or g.unitTesting
    arg_tuple = d.get('args', [])
    arg = ' '.join(arg_tuple)
    kind = d.get('kind')
    try:
        # All of these must be supported because they
        # could exist in @open-with nodes.
        command = '&lt;no command&gt;'
        if kind in ('os.system', 'os.startfile'):
            # New in Leo 5.7: 
            # Use subProcess.Popen(..., shell=True)
            c_arg = self.join(arg, fn)
            if not testing:
                try:
                    subprocess.Popen(c_arg, shell=True)
                except OSError:
                    g.es_print('c_arg', repr(c_arg))
                    g.es_exception()
        elif kind == 'exec':
            g.es_print('open-with exec no longer valid.')
        elif kind == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg, filename, fn)
            if not testing: os.spawnl(os.P_NOWAIT, arg, filename, fn)
        elif kind == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0])
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s)' % (vtuple)
            if not testing:
                os.spawnv(os.P_NOWAIT, arg[0], vtuple) #???
        elif kind == 'subprocess.Popen':
            c_arg = self.join(arg, fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if not testing:
                try:
                    subprocess.Popen(c_arg, shell=True)
                except OSError:
                    g.es_print('c_arg', repr(c_arg))
                    g.es_exception()
        elif g.isCallable(kind):
            # Invoke openWith like this:
            # c.openWith(data=[func,None,None])
            # func will be called with one arg, the filename
            command = '%s(%s)' % (kind, fn)
            if not testing: kind(fn)
        else:
            command = 'bad command:' + str(kind)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:', command)
        g.es_exception()
        return 'oops: %s' % command
</t>
<t tx="ekr.20031218072017.2832">def compute_temp_file_path(self, c, p, ext):
    '''Return the path to the temp file for p and ext.'''
    if c.config.getBool('open-with-clean-filenames'):
        path = self.clean_file_name(c, ext, p)
    else:
        path = self.legacy_file_name(c, ext, p)
    if not path:
        g.error('c.temp_file_path failed')
    return path
</t>
<t tx="ekr.20031218072017.3098">@
From The Python Cookbook: 

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others,
del some of them, etc:
    if point.squared &gt; threshold:
        point.isok = True
@c

class Bunch(object):
    """A class that represents a colection of things.

    Especially useful for representing a collection of related variables."""

    def __init__(self, **keywords):
        self.__dict__.update(keywords)

    def __repr__(self):
        return self.toString()

    def ivars(self):
        return sorted(self.__dict__)

    def keys(self):
        return sorted(self.__dict__)

    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key, str(self.__dict__.get(key)) or repr(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        result = ['g.Bunch(%s)' % (tag or '')]
        result.extend(entries)
        return '\n    '.join(result) + '\n'
    # Used by new undo code.

    def __setitem__(self, key, value):
        '''Support aBunch[key] = val'''
        return operator.setitem(self.__dict__, key, value)

    def __getitem__(self, key):
        '''Support aBunch[key]'''
        # g.pr('g.Bunch.__getitem__', key)
        return operator.getitem(self.__dict__, key)

    def get(self, key, theDefault=None):
        return self.__dict__.get(key, theDefault)
        
    def __contains__(self, key): # New.
        # g.pr('g.Bunch.__contains__', key in self.__dict__, key)
        return key in self.__dict__

bunch = Bunch
</t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree(self):
    for p in self.self_and_subtree(copy=False):
        p.v.clearVisited()
        p.v.clearWriteBit()
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031219074948.1">@nobeautify

class NullObject(object):
    """An object that does nothing, and does it very well."""
    def __init__(self, *args, **keys): pass
    def __call__(self, *args, **keys): return self
    def __repr__(self): return "NullObject"
    def __str__(self): return "NullObject"
    # Attribute access...
    def __delattr__(self, attr): return self
    def __getattr__(self, attr): return self
    def __setattr__(self, attr, val): return self
    # Container methods..
    def __bool__(self): return False
    def __contains__(self, item): return False
    def __getitem__(self, key): raise KeyError
    def __iter__(self): return self
    def __len__(self): return 0
    # Iteration methods: 
    def __next__(self): raise StopIteration
    
tracing_tags = {}
    # Keys are id's, values are tags.
    
tracing_signatures = {}
    # Keys are signatures: '%s.%s:%s' % (tag, attr, callers). Values not important.

class TracingNullObject(object):
    '''Tracing NullObject.'''
    def __init__(self, tag, *args, **kwargs):
        tracing_tags [id(self)] = tag
        if 0:
            suppress = ('tree item',)
            if tag not in suppress:
                print('='*10, 'NullObject.__init__:', id(self), tag)
    def __call__(self, *args, **kwargs):
        if 0:
            suppress = ('PyQt5.QtGui.QIcon', 'LeoQtTree.onItemCollapsed',)
            for z in suppress:
                if z not in repr(args):
                    print('%30s' % 'NullObject.__call__:', args, kwargs)
        return self
    def __repr__(self):
        return 'NullObject: %s' % tracing_tags.get(id(self), "&lt;NO TAG&gt;")
    def __str__(self):
        return 'NullObject: %s' % tracing_tags.get(id(self), "&lt;NO TAG&gt;")
    #
    # Attribute access...
    def __delattr__(self, attr):
        return self
    def __getattr__(self, attr):
        null_object_print_attr(id(self), attr)
        return self
    def __setattr__(self, attr, val):
        g.null_object_print(id(self), '__setattr__')
        return self
    #
    # All other methods...
    def __bool__(self):
        if 0: ### To do: print only once.
            suppress = ('getShortcut','on_idle', 'setItemText')
            callers = g.callers(2)
            if not callers.endswith(suppress):
                g.null_object_print(id(self), '__bool__')
        return False
    def __contains__(self, item):
        g.null_object_print(id(self), '__contains__')
        return False
    def __getitem__(self, key):
        g.null_object_print(id(self), '__getitem__')
        return None
        ### raise KeyError
    def __iter__(self):
        g.null_object_print(id(self), '__iter__')
        return self
    def __len__(self):
        # g.null_object_print(id(self), '__len__')
        return 0
    def __next__(self):
        g.null_object_print(id(self), '__next__')
        raise StopIteration
    def __setitem__(self, key, val):
        g.null_object_print(id(self), '__setitem__')
        return None
</t>
<t tx="ekr.20041005105605.144">def write(self, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.anyAtFileNodeName(), sentinels=sentinels)
        if not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.147">def writeAll(self, all=False, dirty=False):
    """Write @file nodes in all or part of the outline"""
    at, c = self, self.c
    at.sameFiles = 0
    # This is the *only* place where these are set.
    # promptForDangerousWrite sets cancelFlag only if canCancelFlag is True.
    at.canCancelFlag = True
    at.cancelFlag = False
    at.yesToAll = False
    files, root = at.findFilesToWrite(all)
    for p in files:
        try:
            at.writeAllHelper(p, root)
        except Exception:
            at.internalWriteError(p)
    # Make *sure* these flags are cleared for other commands.
    at.canCancelFlag = False
    at.cancelFlag = False
    at.yesToAll = False
    # Say the command is finished.
    at.reportEndOfWrite(files, all, dirty)
    if c.isChanged():
        # Save the outline if only persistence data nodes are dirty.
        at.saveOutlineIfPossible()
</t>
<t tx="ekr.20041005105605.149">def writeAllHelper(self, p, root):
    '''
    Write one file for the at.writeAll.
    Do *not* write @auto files unless p == root.
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    at = self
    at.root = root
    try:
        at.writePathChanged(p)
    except IOError:
        return
    if p.isDirty():
        at.autoBeautify(p)
    # Tricky: @ignore not recognised in @asis nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtIgnoreNode():
        return # Handled in caller.
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p)
        # Do *not* clear the dirty bits the entries in @persistence tree here!
    elif p.isAtCleanNode() or p.isAtNoSentFileNode():
        at.write(p, sentinels=False)
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p)
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p)
    elif p.isAtThinFileNode() or p.isAtFileNode():
        at.write(p)
    #
    # Clear the dirty bits in all descendant nodes.
    # The persistence data may still have to be written.
    for p2 in p.self_and_subtree(copy=False):
        p2.v.clearDirty()
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen = False,
        at_delims_seen = False,
        at_warning_given = False,
        has_at_others = False,
        in_code = True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error('@all not valid in: %s' % (p.h))
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error('multiple @others in: %s' % (p.h))
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error('unmatched @end_raw directive: %s' % p.h)
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error('@verbatim is not a Leo directive: %s' % p.h)
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error('@comment and @delims in node %s' % p.h)
        at.putDirective(s, i)
    else:
        at.error('putBody: can not happen: unknown directive kind: %s' % kind)
</t>
<t tx="ekr.20041005105605.164"></t>
<t tx="ekr.20041005105605.165"></t>
<t tx="ekr.20041005105605.166">def putAtAllLine(self, s, i, p):
    """Put the expansion of @all."""
    at = self
    j, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    k = g.skip_to_end_of_line(s,i)
    at.putLeadInSentinel(s, i, j, delta)
    at.indent += delta
    at.putSentinel("@+" + s[j+1:k].strip())
        # s[j:k] starts with '@all'
    for child in p.children():
        at.putAtAllChild(child)
    at.putSentinel("@-all")
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.167">def putAtAllBody(self, p):
    """ Generate the body enclosed in sentinel lines."""
    at = self
    s = p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if at.sentinels and s and s[-1] != '\n':
        s = s + '\n'
    i, inCode = 0, True
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
        i = next_i
    if not inCode:
        at.putEndDocLine()
</t>
<t tx="ekr.20041005105605.169">def putAtAllChild(self, p):
    '''
    This code puts only the first of two or more cloned siblings, preceding
    the clone with an @clone n sentinel.
    
    This is a debatable choice: the cloned tree appears only once in the
    external file. This should be benign; the text created by @all is
    likely to be used only for recreating the outline in Leo. The
    representation in the derived file doesn't matter much.
    '''
    at = self
    at.putOpenNodeSentinel(p, inAtAll=True)
        # Suppress warnings about @file nodes.
    at.putAtAllBody(p)
    for child in p.children():
        at.putAtAllChild(child)
    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20041005105605.170"></t>
<t tx="ekr.20041005105605.171">def validInAtOthers(self, p):
    """
    Return True if p should be included in the expansion of the @others
    directive in the body text of p's parent.
    """
    at = self
    i = g.skip_ws(p.h, 0)
    isSection, junk = at.isSectionName(p.h, i)
    if isSection:
        return False # A section definition node.
    elif at.sentinels:
        # @ignore must not stop expansion here!
        return True
    elif p.isAtIgnoreNode():
        g.error('did not write @ignore node', p.v.h)
        return False
    elif p.isAtCleanNode():
        p.v.setVisited()
            # # 525: Nested @clean.
            # Suppress a future error. Requires other changes.
        return False
    else:
        return True
</t>
<t tx="ekr.20041005105605.172">def putAtOthersChild(self, p):
    at = self
    at.putOpenNodeSentinel(p)
    at.putBody(p)
    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20041005105605.173">def putAtOthersLine(self, s, i, p):
    """Put the expansion of @others."""
    at = self
    j, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    k = g.skip_to_end_of_line(s,i)
    at.putLeadInSentinel(s, i, j, delta)
    at.indent += delta
    at.putSentinel("@+" + s[j+1:k].strip())
        # s[j:k] starts with '@others'
        # Never write lws in new sentinels.
    for child in p.children():
        p = child.copy()
        after = p.nodeAfterTree()
        while p and p != after:
            if at.validInAtOthers(p):
                at.putOpenNodeSentinel(p)
                at_others_flag = at.putBody(p)
                at.putCloseNodeSentinel(p)
                if at_others_flag:
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
            else:
                p.moveToNodeAfterTree()
    # This is the same in both old and new sentinels.
    at.putSentinel("@-others")
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i: j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1: # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[: -1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line) # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.176">def putRefLine(self, s, i, n1, n2, name, p):
    """Put a line containing one or more references."""
    at = self
    ref = at.findReference(name, p)
    if not ref:
        if hasattr(at, 'allow_undefined_refs'):
            # Allow apparent section reference: just write the line.
            at.putCodeLine(s, i)
        return
    # Compute delta only once.
    junk, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    # Write the lead-in sentinel only once.
    at.putLeadInSentinel(s, i, n1, delta)
    self.putRefAt(name, ref, delta)
    while 1:
        progress = i
        i = n2
        name, n1, n2 = at.findSectionName(s, i)
        if name:
            ref = at.findReference(name, p)
                # Issues error if not found.
            if ref:
                middle_s = s[i:n1]
                self.putAfterMiddleRef(middle_s, delta)
                self.putRefAt(name, ref, delta)
        else: break
        assert progress &lt; i
    self.putAfterLastRef(s, i, delta)
</t>
<t tx="ekr.20041005105605.177">def putRefAt(self, name, ref, delta):
    at = self
    # Fix #132: Section Reference causes clone...
    # https://github.com/leo-editor/leo-editor/issues/132
    # Never put any @+middle or @-middle sentinels.
    at.indent += delta
    at.putSentinel("@+" + name)
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    at.putSentinel("@-" + name)
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.178">def putAfterLastRef(self, s, start, delta):
    """Handle whatever follows the last ref of a line."""
    at = self
    j = g.skip_ws(s, start)
    if j &lt; len(s) and s[j] != '\n':
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        end = g.skip_line(s, start)
        after = s[start: end]
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.179">def putAfterMiddleRef(self, s, delta):
    """Handle whatever follows a ref that is not the last ref of a line."""
    at = self
    if s:
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(s)
        at.onl_sent() # Not a real newline.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.199">def findSectionName(self, s, i):
    '''
    Return n1, n2 representing a section name.
    The section name, *including* brackes is s[n1:n2]
    '''
    end = s.find('\n', i)
    if end == -1:
        n1 = s.find("&lt;&lt;", i)
        n2 = s.find("&gt;&gt;", i)
    else:
        n1 = s.find("&lt;&lt;", i, end)
        n2 = s.find("&gt;&gt;", i, end)
    ok = -1 &lt; n1 &lt; n2
    if ok:
        # Warn on extra brackets.
        for ch, j in (('&lt;', n1 + 2), ('&gt;', n2 + 2)):
            if g.match(s, j, ch):
                line = g.get_line(s, i)
                g.es('dubious brackets in', line)
                break
        name = s[n1:n2+2]
        return name, n1, n2+2
    else:
        return None, n1, len(s)
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Write a string to the output file or stream.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    if not g.isUnicode(s):
        s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041005105605.216"># Called from putFile.

def warnAboutOrphandAndIgnoredNodes(self):
    # Always warn, even when language=="cweb"
    at, root = self, self.root
    if at.errors:
        return # No need to repeat this.
    for p in root.self_and_subtree(copy=False):
        if not p.v.isVisited():
            at.writeError("Orphan node:  " + p.h)
            if p.hasParent():
                g.blue("parent node:", p.parent().h)
    p = root.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtAllNode():
            p.moveToNodeAfterTree()
        else:
            # #1050: test orphan bit.
            if p.isOrphan():
                at.writeError("Orphan node: " + p.h)
                if p.hasParent():
                    g.blue("parent node:", p.parent().h)
            p.moveToThreadNext()
</t>
<t tx="ekr.20041120094940.4">def doFont(self, p, kind, name, val):
    '''Handle an @font node. Such nodes affect syntax coloring *only*.'''
    d = self.parseFont(p)
    # Set individual settings.
    for key in ('family', 'size', 'slant', 'weight'):
        data = d.get(key)
        if data is not None:
            name, val = data
            setKind = key
            self.set(p, setKind, name, val)
</t>
<t tx="ekr.20041213082558.1">def parseFont(self, p):
    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }
    s = p.b
    lines = g.splitLines(s)
    for line in lines:
        self.parseFontLine(line, d)
    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)
    return d
</t>
<t tx="ekr.20041213082558.2">def parseFontLine(self, line, d):
    s = line.strip()
    if not s: return
    try:
        s = str(s)
    except UnicodeError:
        pass
    if g.match(s, 0, '#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
        return
    # name is everything up to '='
    i = s.find('=')
    if i == -1:
        name = s
        val = None
    else:
        name = s[: i].strip()
        val = s[i + 1:].strip().strip('"').strip("'")
    for tag in ('_family', '_size', '_slant', '_weight'):
        if name.endswith(tag):
            kind = tag[1:]
            d[kind] = name, val # Used only by doFont.
            return
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050920093543">def finishCreate(self):
    '''
    Finish creating the commander and all sub-objects.
    This is the last step in the startup process.
    '''
    c, k = self, self.k
    assert c.gui
    assert k
    c.frame.finishCreate()
    c.miniBufferWidget = c.frame.miniBufferWidget
        # Will be None for nullGui.
    # Only c.abbrevCommands needs a finishCreate method.
    c.abbrevCommands.finishCreate()
    # Finish other objects...
    c.createCommandNames()
    k.finishCreate()
    c.findCommands.finishCreate()
    if not c.gui.isNullGui:
        g.registerHandler('idle', c.idle_focus_helper)
    if c.frame.menu:
        c.frame.menu.finishCreate()
    if c.frame.log:
        c.frame.log.finishCreate()
    c.undoer.clearUndoState()
    if c.vimCommands and c.vim_mode:
        c.vimCommands.finishCreate()
        # Menus must exist at this point.
    # Do not call chapterController.finishCreate here:
    # It must be called after the first real redraw.
    g.check_cmd_instance_dict(c, g)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20051007143620">def printCommandsDict(self):
    c = self
    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print('%30s = %s' % (
            key, command.__name__ if command else '&lt;None&gt;'))
    print('')
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20061119120006">def addIconButton(self, *args, **keys):
    if self.iconBar: return self.iconBar.add(*args, **keys)
    else: return None

def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

def addIconWidget(self, w):
    if self.iconBar: return self.iconBar.addWidget(w)

def clearIconBar(self):
    if self.iconBar: self.iconBar.clear()

def createIconBar(self):
    if g.pyzo:
        return g.TracingNullObject(tag='c.frame.createIconBar')
    c = self.c
    if not self.iconBar:
        self.iconBar = self.iconBarClass(c, self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if g.pyzo:
        return g.TracingNullObject(tag='c.frame.getIconBar')
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c, self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c, self.outerFrame)
    return self.iconBar.getNewFrame()

def hideIconBar(self):
    if self.iconBar: self.iconBar.hide()

def showIconBar(self):
    if self.iconBar: self.iconBar.show()
</t>
<t tx="ekr.20070626132332">def es(*args, **keys):
    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    if g.pyzo:
        return ###
    if not app or app.killed:
        return
    if app.gui and app.gui.consoleOnly:
        return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return # New in 4.3.
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            g.pr(s, newline=newline)
    elif log and app.logInited:
        if newline:
            s += '\n'
        log.put(s, color=color, tabName=tabName, nodeLink=d['nodeLink'])
        # Count the number of *trailing* newlines.
        for ch in s:
            if ch == '\n': log.newlines += 1
            else: log.newlines = 0
    else:
        app.logWaiting.append((s, color, newline, d),)
        
log = es

</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    '''
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    '''
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s)
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace('can not happen: encoding mismatch: %s %s' % (
            at.encoding, self.encoding))
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace('\nprivate lines...%s' % old_private_file)
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace('\npublic lines...%s' % old_public_file)
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    '''Init all ivars used by propagate_changed_lines &amp; its helpers.'''
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = '%s@verbatim%s\n' % (x.delim1, x.delim2)
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20090717112235.6007">def computeSignon(self):
    import leo.core.leoVersion as leoVersion
    app = self
    build, date = leoVersion.build, leoVersion.date
    guiVersion = ', ' + app.gui.getFullVersion() if app.gui else ''
    leoVer = leoVersion.version
    n1, n2, n3, junk, junk = sys.version_info
    if sys.platform.startswith('win'):
        sysVersion = 'Windows '
        try:
            # peckj 20140416: determine true OS architecture
            # the following code should return the proper architecture
            # regardless of whether or not the python architecture matches
            # the OS architecture (i.e. python 32-bit on windows 64-bit will return 64-bit)
            v = platform.win32_ver()
            release, winbuild, sp, ptype = v
            true_platform = os.environ['PROCESSOR_ARCHITECTURE']
            try:
                true_platform = os.environ['PROCESSOR_ARCHITEw6432']
            except KeyError:
                pass
            sysVersion = 'Windows %s %s (build %s) %s' % (
                release, true_platform, winbuild, sp)
        except Exception:
            pass
    else: sysVersion = sys.platform
    branch, commit = g.gitInfo()
    if not commit:
        app.signon1 = 'Not running from a git repo'
    else:
        app.signon1 = 'Git repo info: branch = %s, commit = %s' % (
            branch or '(none)', commit)
    app.signon = 'Leo %s' % leoVer
    if build:
        app.signon += ', build '+build
    if date:
        app.signon += ', '+date
    app.signon2 = 'Python %s.%s.%s%s\n%s' % (
        n1, n2, n3, guiVersion, sysVersion)
        
def printSignon(self, verbose=False):
    '''Print a minimal sigon to the log.'''
    app = self
    if app.silentMode:
        return
    if g.pyzo:
        pass
    else:
        if sys.stdout.encoding and sys.stdout.encoding.lower() != 'utf-8':
            print('Note: sys.stdout.encoding is not UTF-8')
            print('Encoding is: %r' % sys.stdout.encoding)
            print('See: https://stackoverflow.com/questions/14109024')
            print('')
    print(app.signon)
    if verbose:
        print(app.signon1)
        print(app.signon2)
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20100203050306.5937">def create_temp_file(self, c, ext, p):
    '''
    Create the file used by open-with if necessary.
    Add the corresponding ExternalFile instance to self.files
    '''
    path = self.compute_temp_file_path(c, p, ext)
    exists = g.os_path_exists(path)
    # Compute encoding and s.
    d2 = c.scanAllDirectives(p)
    encoding = d2.get('encoding', None)
    if encoding is None:
        encoding = c.config.default_derived_file_encoding
    s = g.toEncodedString(p.b, encoding, reportErrors=True)
    # Write the file *only* if it doesn't exist.
    # No need to read the file: recomputing s above suffices.
    if not exists:
        try:
            with open(path, 'wb') as f:
                f.write(s)
                f.flush()
        except IOError:
            g.error('exception creating temp file: %s' % path)
            g.es_exception()
            return None
    # Add or update the external file entry.
    time = self.get_mtime(path)
    self.files = [z for z in self.files if z.path != path]
    self.files.append(ExternalFile(c, ext, p, path, time))
    return path
</t>
<t tx="ekr.20100908125007.6007">class LeoPluginsController(object):
    '''The global plugins controller, g.app.pluginsController'''
    @others
</t>
<t tx="ekr.20100908125007.6016">def callTagHandler(self, bunch, tag, keywords):
    '''Call the event handler.'''
    handler, moduleName = bunch.fn, bunch.moduleName
    # Make sure the new commander exists.
    for key in ('c', 'new_c'):
        c = keywords.get(key)
        if c:
            # Make sure c exists and has a frame.
            if not c.exists or not hasattr(c, 'frame'):
                # g.pr('skipping tag %s: c does not exist or does not have a frame.' % tag)
                return None
    # Calls to registerHandler from inside the handler belong to moduleName.
    self.loadingModuleNameStack.append(moduleName)
    try:
        result = handler(tag, keywords)
    except Exception:
        g.es("hook failed: %s, %s, %s" % (tag, handler, moduleName))
        g.es_exception()
        result = None
    self.loadingModuleNameStack.pop()
    return result
</t>
<t tx="ekr.20100908125007.6017">def doHandlersForTag(self, tag, keywords):
    """
    Execute all handlers for a given tag, in alphabetical order.
    The caller, doHook, catches all exceptions.
    """
    if g.app.killed:
        return None
    #
    # Execute hooks in some random order.
    # Return if one of them returns a non-None result.
    for bunch in self.handlers.get(tag, []):
        val = self.callTagHandler(bunch, tag, keywords)
        if val is not None:
            return val
    if 'all' in self.handlers:
        bunches = self.handlers.get('all')
        for bunch in bunches:
            self.callTagHandler(bunch, tag, keywords)
    return None
</t>
<t tx="ekr.20100908125007.6018">def doPlugins(self, tag, keywords):
    '''The default g.app.hookFunction.'''
    if g.app.killed:
        return
    if tag in ('start1', 'open0'):
        self.loadHandlers(tag, keywords)
    return self.doHandlersForTag(tag, keywords)
</t>
<t tx="ekr.20100908125007.6019">def getHandlersForTag(self, tags):
    if isinstance(tags, (list, tuple)):
        result = []
        for tag in tags:
            aList = self.getHandlersForOneTag(tag)
            result.extend(aList)
        return result
    else:
        return self.getHandlersForOneTag(tags)

def getHandlersForOneTag(self, tag):
    aList = self.handlers.get(tag, [])
    return aList
</t>
<t tx="ekr.20100908125007.6020">def getPluginModule(self, moduleName):
    return self.loadedModules.get(moduleName)
</t>
<t tx="ekr.20100908125007.6021">def isLoaded(self, fn):
    return self.regularizeName(fn) in self.loadedModules
</t>
<t tx="ekr.20100908125007.6022">def loadHandlers(self, tag, keys):
    '''
    Load all enabled plugins.

    Using a module name (without the trailing .py) allows a plugin to
    be loaded from outside the leo/plugins directory.
    '''

    def pr(*args, **keys):
        if not g.app.unitTesting:
            g.es_print(*args, **keys)
            
    if g.pyzo:
        g.trace('DISABLE plugins: g.pyzo is True')
        return

    s = g.app.config.getEnabledPlugins()
    if not s: return
    if tag == 'open0' and not g.app.silentMode and not g.app.batchMode:
        if 0:
            s2 = '@enabled-plugins found in %s' % (
                g.app.config.enabledPluginsFileName)
            g.blue(s2)
    for plugin in s.splitlines():
        if plugin.strip() and not plugin.lstrip().startswith('#'):
            self.loadOnePlugin(plugin.strip(), tag=tag)
</t>
<t tx="ekr.20100908125007.6024">def loadOnePlugin(self, moduleOrFileName, tag='open0', verbose=False):
    '''
    Load one plugin from a file name or module.
    Use extensive tracing if --trace-plugins is in effect.

    Using a module name allows plugins to be loaded from outside the leo/plugins directory.
    '''
    global optional_modules
    trace = 'plugins' in g.app.debug

    def report(message):
        if trace and not g.unitTesting:
            g.es_print('loadOnePlugin: %s' % message)
            
    # Define local helper functions.
    @others

    if not g.app.enablePlugins:
        report('plugins disabled: %s' % moduleOrFileName)
        return None
    if moduleOrFileName.startswith('@'):
        report('ignoring Leo directive: %s' % moduleOrFileName)
        return None
            # Return None, not False, to keep pylint happy.
            # Allow Leo directives in @enabled-plugins nodes.
    moduleName = self.regularizeName(moduleOrFileName)
    if self.isLoaded(moduleName):
        module = self.loadedModules.get(moduleName)
        return module
    assert g.app.loadDir
    moduleName = g.toUnicode(moduleName)
    #
    # Try to load the plugin.
    try:
        self.loadingModuleNameStack.append(moduleName)
        result = loadOnePluginHelper(moduleName)
    finally:
        self.loadingModuleNameStack.pop()
    if not result:
        if trace:
            reportFailedImport()
        return None
    #
    # Last-minute checks.
    try:
        self.loadingModuleNameStack.append(moduleName)
        result = finishImport(result)
    finally:
        self.loadingModuleNameStack.pop()
    if result:
        report('loaded: %s' % moduleName)
    self.signonModule = result # for self.plugin_signon.
    return result
</t>
<t tx="ekr.20100908125007.6025">def printHandlers(self, c, moduleName=None):
    '''Print the handlers for each plugin.'''
    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)
    if moduleName:
        s = 'handlers for %s...\n' % (moduleName)
    else:
        s = 'all plugin handlers...\n'
    g.es(s + '\n', tabName=tabName)
    data = []
    modules = {}
    for tag in self.handlers:
        bunches = self.handlers.get(tag)
        for bunch in bunches:
            name = bunch.moduleName
            tags = modules.get(name, [])
            tags.append(tag)
            modules[name] = tags
    n = 4
    for key in sorted(modules):
        tags = modules.get(key)
        if moduleName in (None, key):
            for tag in tags:
                n = max(n, len(tag))
                data.append((tag, key),)
    lines = ['%*s %s\n' % (-n, s1, s2) for(s1, s2) in data]
    g.es('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20100908125007.6026">def printPlugins(self, c):
    '''Print all enabled plugins.'''
    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)
    data = []
    data.append('enabled plugins...\n')
    for z in sorted(self.loadedModules):
        data.append(z)
    lines = ['%s\n' % (s) for s in data]
    g.es('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20100908125007.6027">def printPluginsInfo(self, c):
    '''Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.'''
    d = self.loadedModulesFilesDict
    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)
    data = []; n = 4
    for moduleName in d:
        fileName = d.get(moduleName)
        n = max(n, len(moduleName))
        data.append((moduleName, fileName),)
    lines = ['%*s %s\n' % (-n, s1, s2) for(s1, s2) in data]
    g.es('', ''.join(lines), tabName=tabName)
</t>
<t tx="ekr.20100908125007.6028">def registerExclusiveHandler(self, tags, fn):
    """ Register one or more exclusive handlers"""
    if isinstance(tags, (list, tuple)):
        for tag in tags:
            self.registerOneExclusiveHandler(tag, fn)
    else:
        self.registerOneExclusiveHandler(tags, fn)

def registerOneExclusiveHandler(self, tag, fn):
    """Register one exclusive handler"""
    try:
        moduleName = self.loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '&lt;no module&gt;'
    if 0:
        if g.app.unitTesting: g.pr('')
        g.pr('%6s %15s %25s %s' % (g.app.unitTesting, moduleName, tag, fn.__name__))
    if g.app.unitTesting: return
    if tag in self.handlers:
        g.es("*** Two exclusive handlers for", "'%s'" % (tag))
    else:
        bunch = g.Bunch(fn=fn, moduleName=moduleName, tag='handler')
        self.handlers[tag] = [bunch] # Vitalije
</t>
<t tx="ekr.20100908125007.6029">def registerHandler(self, tags, fn):
    """ Register one or more handlers"""
    if isinstance(tags, (list, tuple)):
        for tag in tags:
            self.registerOneHandler(tag, fn)
    else:
        self.registerOneHandler(tags, fn)

def registerOneHandler(self, tag, fn):
    """Register one handler"""
    try:
        moduleName = self.loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '&lt;no module&gt;'
    if 0:
        if g.app.unitTesting: g.pr('')
        g.pr('%6s %15s %25s %s' % (g.app.unitTesting, moduleName, tag, fn.__name__))
    items = self.handlers.get(tag, [])
    functions = [z.fn for z in items]
    if fn not in functions: # Vitalije
        bunch = g.Bunch(fn=fn, moduleName=moduleName, tag='handler')
        items.append(bunch)
    self.handlers[tag] = items
</t>
<t tx="ekr.20100908125007.6030">def unloadOnePlugin(self, moduleOrFileName, verbose=False):
    moduleName = self.regularizeName(moduleOrFileName)
    if self.isLoaded(moduleName):
        if verbose:
            g.pr('unloading', moduleName)
        del self.loadedModules[moduleName]
    for tag in self.handlers:
        bunches = self.handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.moduleName != moduleName]
        self.handlers[tag] = bunches
</t>
<t tx="ekr.20100908125007.6031">def unregisterHandler(self, tags, fn):
    if isinstance(tags, (list, tuple)):
        for tag in tags:
            self.unregisterOneHandler(tag, fn)
    else:
        self.unregisterOneHandler(tags, fn)

def unregisterOneHandler(self, tag, fn):
    bunches = self.handlers.get(tag)
    bunches = [bunch for bunch in bunches if bunch and bunch.fn != fn]
    self.handlers[tag] = bunches
</t>
<t tx="ekr.20100908125007.6034">def __init__(self):

    self.handlers = {}
    self.loadedModulesFilesDict = {}
        # Keys are regularized module names, values are the names of .leo files
        # containing @enabled-plugins nodes that caused the plugin to be loaded
    self.loadedModules = {}
        # Keys are regularized module names, values are modules.
    self.loadingModuleNameStack = []
        # The stack of module names.
        # The top is the module being loaded.
    self.signonModule = None # A hack for plugin_signon.
    # Settings.  Set these here in case finishCreate is never called.
    self.warn_on_failure = True
    assert(g)
    g.act_on_node = CommandChainDispatcher()
    g.visit_tree_item = CommandChainDispatcher()
    g.tree_popup_handlers = []
</t>
<t tx="ekr.20100909065501.5949">def regularizeName(self, fn):
    '''Return the name used as a key to this modules dictionaries.'''
    if not fn.endswith('.py'):
        return fn
    #
    # Allow .leo/plugins
    path = g.os_path_finalize_join('~', '.leo', 'plugins', fn)
    if g.os_path_exists(path):
        return fn[: -3]
    # Return the default module for leo plugins.
    return "leo.plugins." + fn[: -3]
</t>
<t tx="ekr.20100909065501.5950"></t>
<t tx="ekr.20100909065501.5951"></t>
<t tx="ekr.20100909065501.5952"></t>
<t tx="ekr.20100909065501.5953"></t>
<t tx="ekr.20100909065501.5954"></t>
<t tx="ekr.20100909065501.5974">def finishCreate(self):
    self.reloadSettings()

def reloadSettings(self):
    self.warn_on_failure = \
        g.app.config.getBool('warn_when_plugins_fail_to_load', default=True)
</t>
<t tx="ekr.20100909104341.5979">def setLoaded(self, fn, m):
    self.loadedModules[self.regularizeName(fn)] = m
</t>
<t tx="ekr.20100910075900.10204">def getLoadedPlugins(self):
    return list(self.loadedModules.keys())
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17866">def getName(self):
    '''Return the name of this widget: must start with "canvas".'''
    return 'canvas(tree)'
</t>
<t tx="ekr.20110605121601.17868">def error(self, s):
    if not g.app.unitTesting:
        g.trace('LeoQtTree Error: %s' % (s), g.callers())

def traceItem(self, item):
    if item:
        # A QTreeWidgetItem.
        return 'item %s: %s' % (id(item), self.getItemText(item))
    else:
        return '&lt;no item&gt;'

def traceCallers(self):
    if self.traceCallersFlag:
        return g.callers(5, excludeCaller=True)
    else:
        return ''
</t>
<t tx="ekr.20110605121601.17871">def reloadSettings(self):
    '''LeoQtTree.'''
    c = self.c
    self.auto_edit = c.config.getBool('single-click-auto-edits-headline', False)
    self.enable_drag_messages = c.config.getBool("enable-drag-messages")
    self.select_all_text_when_editing_headlines = \
        c.config.getBool('select_all_text_when_editing_headlines')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_declutter = c.config.getBool('tree-declutter', default=False)

</t>
<t tx="ekr.20110605121601.17872"></t>
<t tx="ekr.20110605121601.17873">def full_redraw(self, p=None):
    '''
    Redraw all visible nodes of the tree.
    Preserve the vertical scrolling unless scroll is True.
    '''
    c = self.c
    if g.app.disable_redraw:
        return
    if self.busy:
        return
    # Cancel the delayed redraw request.
    c.requestLaterRedraw = False
    if not p:
        p = c.currentPosition()
    elif c.hoistStack and p.h.startswith('@chapter') and p.hasChildren():
        # Make sure the current position is visible.
        # Part of fix of bug 875323: Hoist an @chapter node leaves a non-visible node selected.
        p = p.firstChild()
        c.frame.tree.select(p)
        c.setCurrentPosition(p)
    else:
        c.setCurrentPosition(p)
    assert not self.busy, g.callers()
    self.redrawCount += 1
    self.initData()
    try:
        self.busy = True
        self.drawTopTree(p)
    finally:
        self.busy = False
    self.setItemForCurrentPosition()
    return p # Return the position, which may have changed.

# Compatibility
redraw = full_redraw
redraw_now = full_redraw
</t>
<t tx="ekr.20110605121601.17874">def drawChildren(self, p, parent_item):
    '''Draw the children of p if they should be expanded.'''
    if not p:
        return g.trace('can not happen: no p')
    if p.hasChildren():
        if p.isExpanded():
            self.expandItem(parent_item)
            child = p.firstChild()
            while child:
                self.drawTree(child, parent_item)
                child.moveToNext()
        else:
            # Draw the hidden children.
            child = p.firstChild()
            while child:
                self.drawNode(child, parent_item)
                child.moveToNext()
            self.contractItem(parent_item)
    else:
        self.contractItem(parent_item)
</t>
<t tx="ekr.20110605121601.17875">def drawNode(self, p, parent_item):
    '''Draw the node p.'''
    c = self.c
    v = p.v
    # Allocate the item.
    item = self.createTreeItem(p, parent_item)
    #
    # Update the data structures.
    itemHash = self.itemHash(item)
    self.position2itemDict[p.key()] = item
    self.item2positionDict[itemHash] = p.copy() # was item
    self.item2vnodeDict[itemHash] = v # was item
    d = self.vnode2itemsDict
    aList = d.get(v, [])
    if item not in aList:
        aList.append(item)
    d[v] = aList
    # Set the headline and maybe the icon.
    self.setItemText(item, p.h)
    if self.use_declutter:
        self.declutter_node(c, p, item)
    # Draw the icon.
    if p:
        # Expand self.drawItemIcon(p, item).
        v.iconVal = v.computeIcon()
        icon = self.getCompositeIconImage(p, v.iconVal)
            # **Slow**, but allows per-vnode icons.
        if icon:
            item.setIcon(0, icon)
    return item
</t>
<t tx="ekr.20110605121601.17876">def drawTopTree(self, p):
    '''Draw the tree rooted at p.'''
    trace = 'drawing' in g.app.debug and not g.unitTesting
    if trace:
        t1 = time.clock()
    c = self.c
    self.clear()
    # Draw all top-level nodes and their visible descendants.
    if c.hoistStack:
        bunch = c.hoistStack[-1]
        p = bunch.p; h = p.h
        if len(c.hoistStack) == 1 and h.startswith('@chapter') and p.hasChildren():
            p = p.firstChild()
            while p:
                self.drawTree(p)
                p.moveToNext()
        else:
            self.drawTree(p)
    else:
        p = c.rootPosition()
        while p:
            self.drawTree(p)
            p.moveToNext()
    if trace:
        t2 = time.clock()
        g.trace('%5.2f sec.' % (t2-t1), g.callers(5))
</t>
<t tx="ekr.20110605121601.17877">def drawTree(self, p, parent_item=None):
    if g.app.gui.isNullGui:
        return
    # Draw the (visible) parent node.
    item = self.drawNode(p, parent_item)
    # Draw all the visible children.
    self.drawChildren(p, parent_item=item)
</t>
<t tx="ekr.20110605121601.17878">def initData(self):
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {}
    self.editWidgetsDict = {}
</t>
<t tx="ekr.20110605121601.17880">def redraw_after_contract(self, p):

    if self.busy:
        return
    self.update_expansion(p)
</t>
<t tx="ekr.20110605121601.17881">def redraw_after_expand(self, p):
    
    if 0: # Does not work. Newly visible nodes do not show children correctly.
        c = self.c
        c.selectPosition(p)
        self.update_expansion(p)
    else:
        self.full_redraw(p)
            # Don't try to shortcut this!
</t>
<t tx="ekr.20110605121601.17882">def redraw_after_head_changed(self):

    if self.busy:
        return
    p = self.c.p
    if p:
        h = p.h # 2010/02/09: Fix bug 518823.
        for item in self.vnode2items(p.v):
            if self.isValidItem(item):
                self.setItemText(item, h)
    # Bug fix: 2009/10/06
    self.redraw_after_icons_changed()
</t>
<t tx="ekr.20110605121601.17883">def redraw_after_icons_changed(self):

    if self.busy:
        return
    self.redrawCount += 1 # To keep a unit test happy.
    c = self.c
    try:
        self.busy = True
            # Suppress call to setHeadString in onItemChanged!
        self.getCurrentItem()
        for p in c.rootPosition().self_and_siblings(copy=False):
            # Updates icons in p and all visible descendants of p.
            self.updateVisibleIcons(p)
    finally:
        self.busy = False
</t>
<t tx="ekr.20110605121601.17884">def redraw_after_select(self, p=None):
    '''Redraw the entire tree when an invisible node is selected.'''
    if self.busy:
        return
    self.full_redraw(p)
    # c.redraw_after_select calls tree.select indirectly.
    # Do not call it again here.
</t>
<t tx="ekr.20110605121601.17885"></t>
<t tx="ekr.20110605121601.17887"></t>
<t tx="ekr.20110605121601.17888">def onClickBoxClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook("boxclick1", c=c, p=p, event=event)
    g.doHook("boxclick2", c=c, p=p, event=event)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17889">def onClickBoxRightClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook("boxrclick1", c=c, p=p, event=event)
    g.doHook("boxrclick2", c=c, p=p, event=event)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17890">def onPlusBoxRightClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook('rclick-popup', c=c, p=p, event=event, context_menu='plusbox')
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17891"># For Qt, there seems to be no way to trigger these events.
</t>
<t tx="ekr.20110605121601.17892">def onIconBoxClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    g.doHook("iconclick1", c=c, p=p, event=event)
    g.doHook("iconclick2", c=c, p=p, event=event)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17893">def onIconBoxRightClick(self, event, p=None):
    """Handle a right click in any outline widget."""
    if self.busy:
        return
    c = self.c
    g.doHook("iconrclick1", c=c, p=p, event=event)
    g.doHook("iconrclick2", c=c, p=p, event=event)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17894">def onIconBoxDoubleClick(self, event, p=None):
    if self.busy:
        return
    c = self.c
    if not p: p = c.p
    if not g.doHook("icondclick1", c=c, p=p, event=event):
        self.endEditLabel()
        self.OnIconDoubleClick(p) # Call the method in the base class.
    g.doHook("icondclick2", c=c, p=p, event=event)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17895">def onItemCollapsed(self, item):

    if self.busy:
        return
    c = self.c
    p = self.item2position(item)
    if not p:
        self.error('no p')
        return
    # Do **not** set lockouts here.
    # Only methods that actually generate events should set lockouts.
    if p.isExpanded():
        p.contract()
        c.redraw_after_contract(p)
    self.select(p)
    c.outerUpdate()
   
</t>
<t tx="ekr.20110605121601.17896">def onItemClicked(self, item, col, auto_edit=False):
    '''Handle a click in a BaseNativeTree widget item.'''
    # This is called after an item is selected.
    if self.busy:
        return
    c = self.c
    try:
        self.busy = True
        p = self.item2position(item)
        if p:
            auto_edit = self.prev_v == p.v
                # Fix #1049.
            self.prev_v = p.v
            event = None
            mods = g.app.gui.qtApp.keyboardModifiers()
            isCtrl = bool(mods &amp; QtConst.ControlModifier)
            # We could also add support for QtConst.ShiftModifier, QtConst.AltModifier	&amp; QtConst.MetaModifier.
            if isCtrl:
                if g.doHook("iconctrlclick1", c=c, p=p, event=event) is None:
                    c.frame.tree.OnIconCtrlClick(p) # Call the base class method.
                g.doHook("iconctrlclick2", c=c, p=p, event=event)
            else:
                # 2014/02/21: generate headclick1/2 instead of iconclick1/2
                g.doHook("headclick1", c=c, p=p, event=event)
                g.doHook("headclick2", c=c, p=p, event=event)
        else:
            auto_edit = None
            g.trace('*** no p')
        # 2011/05/27: click here is like ctrl-g.
        c.k.keyboardQuit(setFocus=False)
        c.treeWantsFocus() # 2011/05/08: Focus must stay in the tree!
        c.outerUpdate()
        # 2011/06/01: A second *single* click on a selected node
        # enters editing state.
        if auto_edit and self.auto_edit:
            e, wrapper = self.createTreeEditorForItem(item)
        # 2014/10/26: Reset find vars.
        c.findCommands.reset_state_ivars()
    finally:
        self.busy = False
</t>
<t tx="ekr.20110605121601.17897">def onItemDoubleClicked(self, item, col):
    '''Handle a double click in a BaseNativeTree widget item.'''
    if self.busy: # Required.
        return
    c = self.c
    try:
        self.busy = True
        e, wrapper = self.createTreeEditorForItem(item)
        if not e:
            g.trace('*** no e')
        p = self.item2position(item)
    # 2011/07/28: End the lockout here, not at the end.
    finally:
        self.busy = False
    if not p:
        self.error('no p')
        return
    # 2014/02/21: generate headddlick1/2 instead of icondclick1/2.
    if g.doHook("headdclick1", c=c, p=p, event=None) is None:
        c.frame.tree.OnIconDoubleClick(p) # Call the base class method.
    g.doHook("headclick2", c=c, p=p, event=None)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17898">def onItemExpanded(self, item):
    '''Handle and tree-expansion event.'''
    if self.busy: # Required
        return
    c = self.c
    p = self.item2position(item)
    if not p:
        self.error('no p')
        return
    # Do **not** set lockouts here.
    # Only methods that actually generate events should set lockouts.
    if not p.isExpanded():
        p.expand()
        c.redraw_after_expand(p)
    self.select(p)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17899">def onTreeSelect(self):
    '''Select the proper position when a tree node is selected.'''
    if self.busy: # Required
        return
    c = self.c
    item = self.getCurrentItem()
    p = self.item2position(item)
    if not p:
        self.error('no p for item: %s' % item)
        return
    # Do **not** set lockouts here.
    # Only methods that actually generate events should set lockouts.
    self.select(p)
        # This is a call to LeoTree.select(!!)
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17900">def OnPopup(self, p, event):
    """Handle right-clicks in the outline.

    This is *not* an event handler: it is called from other event handlers."""
    # Note: "headrclick" hooks handled by VNode callback routine.
    if event:
        c = self.c
        c.setLog()
        if not g.doHook("create-popup-menu", c=c, p=p, event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items", c=c, p=p, event=event):
            self.enablePopupMenuItems(p, event)
        if not g.doHook("show-popup-menu", c=c, p=p, event=event):
            self.showPopupMenu(event)
    return "break"
</t>
<t tx="ekr.20110605121601.17901">@
On Linux we must do something special to make the popup menu "unpost" if the
mouse is clicked elsewhere. So we have to catch the &lt;FocusOut&gt; event and
explicitly unpost. In order to process the &lt;FocusOut&gt; event, we need to be able
to find the reference to the popup window again, so this needs to be an
attribute of the tree object; hence, "self.popupMenu".

Aside: though Qt tries to be muli-platform, the interaction with different
window managers does cause small differences that will need to be compensated by
system specific application code. :-(
@c
# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self, event=None):
    # self.popupMenu.unpost()
    pass
</t>
<t tx="ekr.20110605121601.17902">def createPopupMenu(self, event):
    '''This might be a placeholder for plugins.  Or not :-)'''
</t>
<t tx="ekr.20110605121601.17903">def enablePopupMenuItems(self, p, event):
    """Enable and disable items in the popup menu."""
</t>
<t tx="ekr.20110605121601.17904">def showPopupMenu(self, event):
    """Show a popup menu."""
</t>
<t tx="ekr.20110605121601.17905"></t>
<t tx="ekr.20110605121601.17908">def edit_widget(self, p):
    """Returns the edit widget for position p."""
    item = self.position2item(p)
    if item:
        e = self.getTreeEditorForItem(item)
        if e:
            # Create a wrapper widget for Leo's core.
            w = self.getWrapper(e, item)
            return w
        else:
            # This is not an error
            # But warning: calling this method twice might not work!
            return None
    else:
        return None
</t>
<t tx="ekr.20110605121601.17909">def editLabel(self, p, selectAll=False, selection=None):
    """Start editing p's headline."""
    if self.busy:
        return
    c = self.c
    c.outerUpdate()
        # Do any scheduled redraw.
        # This won't do anything in the new redraw scheme.
    item = self.position2item(p)
    if item:
        if self.use_declutter:
            item.setText(0, item._real_text)
        e, wrapper = self.editLabelHelper(item, selectAll, selection)
    else:
        e, wrapper = None, None
        self.error('no item for %s' % p)
    if e:
        self.sizeTreeEditor(c, e)
        # A nice hack: just set the focus request.
        c.requestedFocusWidget = e
    return e, wrapper
</t>
<t tx="ekr.20110605121601.17910"># def editPosition(self):
    # c = self.c
    # p = c.currentPosition()
    # ew = self.edit_widget(p)
    # return p if ew else None
</t>
<t tx="ekr.20110605121601.17911">def endEditLabel(self):
    '''Override LeoTree.endEditLabel.

    End editing of the presently-selected headline.'''
    c = self.c; p = c.currentPosition()
    self.onHeadChanged(p)
</t>
<t tx="ekr.20110605121601.17912"># Tricky code: do not change without careful thought and testing.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None):
    '''Officially change a headline.'''
    c = self.c; u = c.undoer
    if not p:
        return
    item = self.getCurrentItem()
    if not item:
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        return
    s = e.text()
    self.closeEditorHelper(e, item)
    oldHead = p.h
    changed = s != oldHead
    if g.doHook("headkey1", c=c, p=c.p, v=c.p, s=s, changed=changed):
        return
    if changed:
        # New in Leo 4.10.1.
        &lt;&lt; truncate s if it has multiple lines &gt;&gt;
        p.initHeadString(s)
        item.setText(0, s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p, oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData,
            dirtyVnodeList=dirtyVnodeList, inHead=True) # 2013/08/26.
    g.doHook("headkey2", c=c, p=c.p, v=c.p, s=s, changed=changed)
    # This is a crucial shortcut.
    if g.unitTesting: return
    if changed:
        self.redraw_after_head_changed()
    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    p.v.contentModified()
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.17913">def setItemForCurrentPosition(self):
    '''Select the item for c.p'''
    c = self.c; p = c.currentPosition()
    if self.busy:
        return None
    if not p:
        return None
    item = self.position2item(p)
    if not item:
        # This is not necessarily an error.
        # We often attempt to select an item before redrawing it.
        return None
    item2 = self.getCurrentItem()
    if item == item2:
        return item
    try:
        self.busy = True
        self.treeWidget.setCurrentItem(item)
            # This generates gui events, so we must use a lockout.
    finally:
        self.busy = False
    return item
</t>
<t tx="ekr.20110605121601.17914">def setHeadline(self, p, s):
    '''Force the actual text of the headline widget to p.h.'''
    # This is used by unit tests to force the headline and p into alignment.
    if not p:
        return
    # Don't do this here: the caller should do it.
    # p.setHeadString(s)
    e = self.edit_widget(p)
    if e:
        e.setAllText(s)
    else:
        item = self.position2item(p)
        if item:
            self.setItemText(item, s)
</t>
<t tx="ekr.20110605121601.17915">def getSelectedPositions(self):
    items = self.getSelectedItems()
    pl = leoNodes.PosList(self.item2position(it) for it in items)
    return pl
</t>
<t tx="ekr.20110605121601.17940">def wrapQLineEdit(self, w):
    '''A wretched kludge for MacOs k.masterMenuHandler.'''
    c = self.c
    if isinstance(w, QtWidgets.QLineEdit):
        wrapper = self.edit_widget(c.p)
    else:
        wrapper = w
    return wrapper
</t>
<t tx="ekr.20110605121601.17943">def itemHash(self, item):
    return '%s at %s' % (repr(item), str(id(item)))

def item2position(self, item):
    itemHash = self.itemHash(item)
    p = self.item2positionDict.get(itemHash) # was item
    return p

def item2vnode(self, item):
    itemHash = self.itemHash(item)
    return self.item2vnodeDict.get(itemHash) # was item

def position2item(self, p):
    item = self.position2itemDict.get(p.key())
    return item

def vnode2items(self, v):
    return self.vnode2itemsDict.get(v, [])

def isValidItem(self, item):
    itemHash = self.itemHash(item)
    return itemHash in self.item2vnodeDict # was item.
</t>
<t tx="ekr.20110605121601.17944">def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30

findFocus = getFocus

def setFocus(self):
    g.app.gui.set_focus(self.c, self.treeWidget)
</t>
<t tx="ekr.20110605121601.17946">def drawItemIcon(self, p, item):
    '''Set the item's icon to p's icon.'''
    icon = self.getIcon(p)
    if icon:
        self.setItemIcon(item, icon)
</t>
<t tx="ekr.20110605121601.17947">def getIconImage(self, p):
    # User icons are not supported in the base class.
    if g.app.gui.isNullGui:
        return None
    else:
        return self.getStatusIconImage(p)
</t>
<t tx="ekr.20110605121601.17948">def getStatusIconImage(self, p):
    val = p.v.computeIcon()
    r = g.app.gui.getIconImage(
        "box%02d.png" % val)
    return r
</t>
<t tx="ekr.20110605121601.17949">def getVnodeIcon(self, p):
    '''Return the proper icon for position p.'''
    return self.getIcon(p)
</t>
<t tx="ekr.20110605121601.17950">def setItemIcon(self, item, icon):

    valid = item and self.isValidItem(item)
    if icon and valid:
        # Important: do not set lockouts here.
        # This will generate changed events,
        # but there is no itemChanged event handler.
        self.setItemIconHelper(item, icon)
</t>
<t tx="ekr.20110605121601.17951">def updateIcon(self, p, force=False):
    '''Update p's icon.'''
    if not p: return
    val = p.v.computeIcon()
    # The force arg is needed:
    # Leo's core may have updated p.v.iconVal.
    if p.v.iconVal == val and not force:
        return
    icon = self.getIcon(p) # sets p.v.iconVal
    # Update all cloned items.
    items = self.vnode2items(p.v)
    for item in items:
        self.setItemIcon(item, icon)
</t>
<t tx="ekr.20110605121601.17952">def updateVisibleIcons(self, p):
    '''Update the icon for p and the icons
    for all visible descendants of p.'''
    self.updateIcon(p, force=True)
    if p.hasChildren() and p.isExpanded():
        for child in p.children():
            self.updateVisibleIcons(child)
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:

    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        '''A subclass of QTextBrowser that overrides the mouse event handlers.'''
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    '''ctor for LeoQTextBrowser class.'''
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = '' # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    QtWidgets.QTextBrowser.__init__(self, parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0: # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return '(LeoQTextBrowser) %s' % id(self)

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    '''ctor for LeoQListWidget class'''
    QtWidgets.QListWidget.__init__(self)
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    '''Kill completion and close the window.'''
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    '''End completion.'''
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    '''Handle a key event from QListWidget.'''
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    '''Called when user selects an item in the QListWidget.'''
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper # 2014/09/19
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged(True)
        w.setInsertPoint(j)
        c.frame.body.onBodyChanged('Typing')
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    '''Set the position of the QListWidget.'''

    def glob(obj, pt):
        '''Convert pt from obj's local coordinates to global coordinates.'''
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry() # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace('Error: geom.topLeft: %s, geom2.topLeft: %s' % (
                    geom2.topLeft(), glob(w, r.topLeft())))
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace('Error 2: geom.topLeft: %s, geom2.topLeft: %s' % (
                    glob(vp, geom2.topLeft()), glob(w, r.topLeft())))
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    '''Set the QListView contents to aList.'''
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    '''Connect a QCompleter.'''
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = 'unknown: %s' % repr(button)
    return kind
</t>
<t tx="ekr.20110605121601.18137">dw_base = QtWidgets.QFrame if g.pyzo else QtWidgets.QMainWindow

class DynamicWindow(dw_base):
    '''
    A class representing all parts of the main Qt window.

    **Important**: when using tabs, the LeoTabbedTopLevel widget
    is the top-level window, **not** this QMainWindow!

    c.frame.top is a DynamicWindow object.

    For --gui==qttabs:
        c.frame.top.parent is a TabbedFrameFactory
        c.frame.top.leo_master is a LeoTabbedTopLevel

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''
    @others
</t>
<t tx="ekr.20110605121601.18138">def __init__(self, c, parent=None):
    '''Ctor for the DynamicWindow class.  The main window is c.frame.top'''
        # Called from LeoQtFrame.finishCreate.
        # For qttabs gui, parent is a LeoTabbedTopLevel.
    if g.pyzo:
        QtWidgets.QFrame.__init__(self, parent)
    else:
        QtWidgets.QMainWindow.__init__(self, parent) # pylint: disable=non-parent-init-called
    self.leo_c = c
    self.leo_master = None # Set in construct.
    self.leo_menubar = None # Set in createMenuBar.
    self.leo_ui = None # Set in construct.
    c._style_deltas = defaultdict(lambda: 0) # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
</t>
<t tx="ekr.20110605121601.18139">def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    if g.pyzo:
        g.pr('DynamicWindow.contruct: master:', repr(master))
        assert False, g.callers()
    self.leo_master = master or g.TracingNullObject(tag='dw.leo_master')
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    # Init the base class.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    if g.pyzo:
        g.app.forgetOpenFile(c.fileName(), force=True)
            ### Temp hack.
        c.frame.body = g.TracingNullObject(tag='c.frame.body')
        c.frame.log = g.TracingNullObject(tag='c.frame.log')
            ###
        self.findScrollArea = g.TracingNullObject(tag='dw.findScrollArea')
        self.findTab = g.TracingNullObject(tag='dw.findTab')
        self.iconBar = g.TracingNullObject(tag='dw.iconBar')
        self.leo_menubar = g.TracingNullObject(tag='dw.leo_menuBar')
        self.statusBar = g.TracingNullObject(tag='dw.statusBar')
        self.lineEdit = g.TracingNullObject(tag='dw.lineEdit')
        self.createPyzoMainWindow()
    else: # legacy code.
        main_splitter, secondary_splitter = self.createMainWindow()
        self.iconBar = self.addToolBar("IconBar")
        self.set_icon_bar_orientation(c)
        # #266 A setting to hide the icon bar.
        # Calling reloadSettings again would also work.
        if not self.show_iconbar:
            self.iconBar.hide()
        self.leo_menubar = self.menuBar()
        self.statusBar = QtWidgets.QStatusBar()
        self.setStatusBar(self.statusBar)
        orientation = c.config.getString('initial-split-orientation')
        self.setSplitDirection(main_splitter, secondary_splitter, orientation)
        if hasattr(c, 'styleSheetManager'):
            c.styleSheetManager.set_style_sheets(top=self, all=True)
</t>
<t tx="ekr.20110605121601.18140">def closeEvent(self, event):
    '''Handle a close event in the Leo window.'''
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        event.accept()
    elif c.inCommand:
        c.requestCloseWindow = True
    else:
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
</t>
<t tx="ekr.20110605121601.18141">def createMainWindow(self):
    '''
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    '''
    dw = self
    self.leo_ui = self
    self.setMainWindowOptions()
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(dw)
    # Signals
    QtCore.QMetaObject.connectSlotsByName(dw)
    return main_splitter, secondary_splitter
</t>
<t tx="ekr.20110605121601.18142"></t>
<t tx="ekr.20110605121601.18143">def createBodyPane(self, parent):
    '''Create the body pane.'''
    # Create widgets.
    c = self.leo_c
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame',
        hPolicy=QtWidgets.QSizePolicy.Expanding)
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget')
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit') # A LeoQTextBrowser
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=6)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
</t>
<t tx="ekr.20110605121601.18144">def createCentralWidget(self):
    '''Create the central widget.'''
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
</t>
<t tx="ekr.20110605121601.18145">def createLogPane(self, parent):
    '''Create all parts of Leo's log pane.'''
    # Create widgets.
    c = self.leo_c
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    # Embed the Find tab in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    # Fix #516:
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if not use_minibuffer and not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Do this later, in LeoFind.finishCreate
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    # Official ivars
    self.tabWidget = tabWidget # Used by LeoQtLog.
</t>
<t tx="ekr.20110605121601.18146">def createMainLayout(self, parent):
    '''Create the layout for Leo's main window.'''
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
</t>
<t tx="ekr.20110605121601.18147">def createMenuBar(self):
    '''Create Leo's menu bar.'''
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
</t>
<t tx="ekr.20110605121601.18148">def createMiniBuffer(self, parent):
    '''Create the widgets for Leo's minibuffer area.'''
    # Create widgets.
    frame = self.createFrame(self.centralwidget, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')

    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            QtWidgets.QLineEdit.focusInEvent(self, event)
                # EKR: 2014/06/28: Call the base class method.
        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins &lt; j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def focusOutEvent(self, event):
            self.store_selection()
            QtWidgets.QLineEdit.focusOutEvent(self, event)
        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit') # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
</t>
<t tx="ekr.20110605121601.18149">def createOutlinePane(self, parent):
    '''Create the widgets and ivars for Leo's outline.'''
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
</t>
<t tx="ekr.20110605121601.18150">def createStatusBar(self, parent):
    '''Create the widgets and ivars for Leo's status area.'''
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
</t>
<t tx="ekr.20110605121601.18151">def setMainWindowOptions(self):
    '''Set default options for Leo's main window.'''
    if g.pyzo:
        return
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
    dw.setDockNestingEnabled(False)
    dw.setDockOptions(
        QtWidgets.QMainWindow.AllowTabbedDocks |
        QtWidgets.QMainWindow.AnimatedDocks)
</t>
<t tx="ekr.20110605121601.18152"></t>
<t tx="ekr.20110605121601.18153">def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18154">def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18155">def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    '''Create a Qt Frame.'''
    if g.pyzo:
        g.trace('(DynamicWindow)', name)
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18156">def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
        # 2014/08/24: honor margin argument.
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18157">def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
</t>
<t tx="ekr.20110605121601.18158">def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18159">def createLineEdit(self, parent, name, disabled=True):

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled # Inject the ivar.
    return w
</t>
<t tx="ekr.20110605121601.18160">def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18161">def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18162">def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18163">def createText(self, parent, name,
    # hPolicy=None,vPolicy=None,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        # self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18164">def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18165"></t>
<t tx="ekr.20110605121601.18166">def createFindTab(self, parent, tab_widget):
    '''Create a Find Tab in the given parent.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0 # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    # Status row
    dw.create_find_status(grid, parent, row)
    row += 1
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget # A scrollArea.
    ftm.init_widgets()
</t>
<t tx="ekr.20110605121601.18167">def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for(ivar, label, row, col) in table:
        name = 'spell_%s_button' % label
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, 'do_leo_spell_btn_%s' % ivar)
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, 'leo_spell_btn_%s' % (ivar), button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox # Must exist
    self.leo_spell_label = lab # Must exist (!!)
</t>
<t tx="ekr.20110605121601.18168"></t>
<t tx="ekr.20110605121601.18169">def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
</t>
<t tx="ekr.20110605121601.18170">def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(
        widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
</t>
<t tx="ekr.20110605121601.18171">def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    else:
        return QtWidgets.QApplication.translate(
            'MainWindow',
            s,
            None,
            QtWidgets.QApplication.UnicodeUTF8)
</t>
<t tx="ekr.20110605121601.18172">def doSpellBtn(self, btn):
    getattr(self.leo_c.spellCommands.handler.tab, btn)()

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
</t>
<t tx="ekr.20110605121601.18173">def select(self, c):
    '''Select the window or tab for c. self is c.frame.top.'''
    if self.leo_master:
        # A LeoTabbedTopLevel.
        self.leo_master.select(c)
    else:
        w = c.frame.body.wrapper
        g.app.gui.set_focus(c, w)
</t>
<t tx="ekr.20110605121601.18174">def setSplitDirection(self, main_splitter, secondary_splitter, orientation):
    '''Set the orientations of the splitters in the Leo main window.'''
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    h, v = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
</t>
<t tx="ekr.20110605121601.18177">def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
    g.app.gui.attachLeoIcon(self)
</t>
<t tx="ekr.20110605121601.18178">def setGeometry(self, rect):
    '''Set the window geometry, but only once when using the qttabs gui.'''
    if g.pyzo:
        return
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
        # Only set the geometry once, even for new files.
        if not hasattr(m, 'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            QtWidgets.QMainWindow.setGeometry(self, rect)
    else:
        QtWidgets.QMainWindow.setGeometry(self, rect)
</t>
<t tx="ekr.20110605121601.18179"></t>
<t tx="ekr.20110605121601.18180">class LeoQtBody(leoFrame.LeoBody):
    """A class that represents the body pane of a Qt window."""
    @others
</t>
<t tx="ekr.20110605121601.18182">def __init__(self, frame, parentFrame):
    '''Ctor for LeoQtBody class.'''
    # Call the base class constructor.
    leoFrame.LeoBody.__init__(self, frame, parentFrame)
    c = self.c
    assert c.frame == frame and frame.c == c
    self.reloadSettings()
    self.set_widget()
        # Sets self.widget and self.wrapper.
    self.setWrap(c.p)
    # For multiple body editors.
    self.editor_name = None
    self.editor_v = None
    self.numberOfEditors = 1
    self.totalNumberOfEditors = 1
    # For renderer panes.
    self.canvasRenderer = None
    self.canvasRendererLabel = None
    self.canvasRendererVisible = False
    self.textRenderer = None
    self.textRendererLabel = None
    self.textRendererVisible = False
    self.textRendererWrapper = None
</t>
<t tx="ekr.20110605121601.18183">def setWrap(self, p=None, force=False):
    '''Set **only** the wrap bits in the body.'''
    if not p or self.useScintilla:
        return
    c = self.c
    w = c.frame.body.wrapper.widget
    option, qt = QtGui.QTextOption, QtCore.Qt
    if force:
        wrap = option.WrapAtWordBoundaryOrAnywhere
    else:
        wrap = g.scanAllAtWrapDirectives(c, p)
        w.setHorizontalScrollBarPolicy(
            qt.ScrollBarAlwaysOff if wrap else qt.ScrollBarAsNeeded)
        wrap = option.WrapAtWordBoundaryOrAnywhere if wrap else option.NoWrap
            # was option WordWrap
    w.setWordWrapMode(wrap)
</t>
<t tx="ekr.20110605121601.18185">def getName(self):
    return 'body-widget'
</t>
<t tx="ekr.20110605121601.18193"></t>
<t tx="ekr.20110605121601.18194"></t>
<t tx="ekr.20110605121601.18195"># An override of leoFrame.addEditor.

@cmd('editor-add')
@cmd('add-editor')
def addEditor(self, event=None):
    '''Add another editor to the body pane.'''
    c, p = self.c, self.c.p
    d = self.editorWidgets
    wrapper = c.frame.body.wrapper # A QTextEditWrapper
    widget = wrapper.widget
    self.totalNumberOfEditors += 1
    self.numberOfEditors += 1
    if self.totalNumberOfEditors == 2:
        self.editorWidgets['1'] = wrapper
        # Pack the original body editor.
        # Fix #1021: Pack differently depending on whether the gutter exists.
        if self.use_gutter:
            self.packLabel(widget.parent(), n=1)
            widget.leo_label = widget.parent().leo_label
        else:
            self.packLabel(widget, n=1)
    name = '%d' % self.totalNumberOfEditors
    f, wrapper = self.createEditor(name)
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(widget), widget
    assert isinstance(f, QtWidgets.QFrame), f
    d[name] = wrapper
    if self.numberOfEditors == 2:
        # Inject the ivars into the first editor.
        # The name of the last editor need not be '1'
        d = self.editorWidgets
        keys = list(d.keys())
        old_name = keys[0]
        old_wrapper = d.get(old_name)
        old_w = old_wrapper.widget
        self.injectIvars(f, old_name, p, old_wrapper)
        self.updateInjectedIvars(old_w, p)
        self.selectLabel(old_wrapper) # Immediately create the label in the old editor.
    # Switch editors.
    c.frame.body.wrapper = wrapper
    self.selectLabel(wrapper)
    self.selectEditor(wrapper)
    self.updateEditors()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18197">def assignPositionToEditor(self, p):
    '''Called *only* from tree.select to select the present body editor.'''
    c = self.c
    wrapper = c.frame.body.wrapper
    w = wrapper and wrapper.widget
        # Careful: w may not exist during unit testing.
    if w:
        self.updateInjectedIvars(w, p)
        self.selectLabel(wrapper)
</t>
<t tx="ekr.20110605121601.18198"># Use the base class method.
</t>
<t tx="ekr.20110605121601.18199">@cmd('delete-editor')
@cmd('editor-delete')
def deleteEditor(self, event=None):
    '''Delete the presently selected body text editor.'''
    c, d = self.c, self.editorWidgets
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    # This seems not to be a valid assertion.
        # assert wrapper == d.get(name),'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) &lt;= 1: return
    name = w.leo_name if hasattr(w, 'leo_name') else '1'
        # Defensive programming.
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    # Fix bug 228: make *sure* the old text is saved.
    c.p.b = wrapper.getAllText()
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z:
            self.unpackWidget(layout, z)
    w.leo_label = None # 2011/11/12
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        # if w.leo_label:  # 2011/11/12
        if getattr(w, 'leo_label', None): # 2018/02/23
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None # 2011/11/12
    self.selectEditor(new_wrapper)
</t>
<t tx="ekr.20110605121601.18200">def findEditorForChapter(self, chapter, p):
    '''Return an editor to be assigned to chapter.'''
    c = self.c; d = self.editorWidgets
    values = list(d.values())
    # First, try to match both the chapter and position.
    if p:
        for w in values:
            if (
                hasattr(w, 'leo_chapter') and w.leo_chapter == chapter and
                hasattr(w, 'leo_p') and w.leo_p and w.leo_p == p
            ):
                return w
    # Next, try to match just the chapter.
    for w in values:
        if hasattr(w, 'leo_chapter') and w.leo_chapter == chapter:
            return w
    # As a last resort, return the present editor widget.
    return c.frame.body.wrapper
</t>
<t tx="ekr.20110605121601.18201">def unselectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    pass
    # self.createChapterIvar(wrapper)

def selectLabel(self, wrapper):
    # pylint: disable=arguments-differ
    c = self.c
    w = wrapper.widget
    lab = hasattr(w, 'leo_label') and w.leo_label
    if lab:
        lab.setEnabled(True)
        lab.setText(c.p.h)
        lab.setEnabled(False)
</t>
<t tx="ekr.20110605121601.18202">selectEditorLockout = False

def selectEditor(self, wrapper):
    '''Select editor w and node w.leo_p.'''
    # pylint: disable=arguments-differ
    c = self.c
    if not wrapper:
        return c.frame.body.wrapper
    if self.selectEditorLockout:
        return
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w

    def report(s):
        g.trace('*** %9s wrapper %s w %s %s' % (
            s, id(wrapper), id(w), c.p.h))

    if wrapper and wrapper == c.frame.body.wrapper:
        self.deactivateEditors(wrapper)
        if hasattr(w, 'leo_p') and w.leo_p and w.leo_p != c.p:
            c.selectPosition(w.leo_p)
            c.bodyWantsFocus()
        return
    try:
        val = None
        self.selectEditorLockout = True
        val = self.selectEditorHelper(wrapper)
    finally:
        self.selectEditorLockout = False
    return val # Don't put a return in a finally clause.
</t>
<t tx="ekr.20110605121601.18203">def selectEditorHelper(self, wrapper):

    c = self.c
    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if not w.leo_p:
        g.trace('no w.leo_p')
        return 'break'
    # The actual switch.
    self.deactivateEditors(wrapper)
    self.recolorWidget(w.leo_p, wrapper) # switches colorizers.
    c.frame.body.wrapper = wrapper
    # 2014/09/04: Must set both wrapper.widget and body.widget.
    c.frame.body.wrapper.widget = w
    c.frame.body.widget = w
    w.leo_active = True
    self.switchToChapter(wrapper)
    self.selectLabel(wrapper)
    if not self.ensurePositionExists(w):
        return g.trace('***** no position editor!')
    if not (hasattr(w, 'leo_p') and w.leo_p):
        return g.trace('***** no w.leo_p', w)
    p = w.leo_p
    assert p, p
    c.expandAllAncestors(p)
    c.selectPosition(p)
        # Calls assignPositionToEditor.
        # Calls p.v.restoreCursorAndScroll.
    c.redraw()
    c.recolor()
    c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18205"># Called from addEditor and assignPositionToEditor

def updateEditors(self):
    c = self.c; p = c.p; body = p.b
    d = self.editorWidgets
    if len(list(d.keys())) &lt; 2: return # There is only the main widget
    w0 = c.frame.body.wrapper
    i, j = w0.getSelectionRange()
    ins = w0.getInsertPoint()
    sb0 = w0.widget.verticalScrollBar()
    pos0 = sb0.sliderPosition()
    for key in d:
        wrapper = d.get(key)
        w = wrapper.widget
        v = hasattr(w, 'leo_p') and w.leo_p.v
        if v and v == p.v and w != w0:
            sb = w.verticalScrollBar()
            pos = sb.sliderPosition()
            wrapper.setAllText(body)
            self.recolorWidget(p, wrapper)
            sb.setSliderPosition(pos)
    c.bodyWantsFocus()
    w0.setSelectionRange(i, j, insert=ins)
    sb0.setSliderPosition(pos0)
</t>
<t tx="ekr.20110605121601.18206"></t>
<t tx="ekr.20110605121601.18207">def computeLabel(self, w):
    if hasattr(w, 'leo_label') and w.leo_label: # 2011/11/12
        s = w.leo_label.text()
    else:
        s = ''
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        s = '%s: %s' % (w.leo_chapter, s)
    return s
</t>
<t tx="ekr.20110605121601.18208">def createChapterIvar(self, w):
    c = self.c; cc = c.chapterController
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        pass
    elif cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
</t>
<t tx="ekr.20110605121601.18209">def deactivateEditors(self, wrapper):
    '''Deactivate all editors except wrapper's editor.'''
    d = self.editorWidgets
    # Don't capture ivars here! assignPositionToEditor keeps them up-to-date. (??)
    for key in d:
        wrapper2 = d.get(key)
        w2 = wrapper2.widget
        if hasattr(w2, 'leo_active'):
            active = w2.leo_active
        else:
            active = True
        if wrapper2 != wrapper and active:
            w2.leo_active = False
            self.unselectLabel(wrapper2)
            self.onFocusOut(w2)
</t>
<t tx="ekr.20110605121601.18210">def ensurePositionExists(self, w):
    '''Return True if w.leo_p exists or can be reconstituted.'''
    c = self.c
    if c.positionExists(w.leo_p):
        return True
    for p2 in c.all_unique_positions():
        if p2.v and p2.v == w.leo_p.v:
            w.leo_p = p2.copy()
            return True
    # This *can* happen when selecting a deleted node.
    w.leo_p = c.p.copy()
    return False
</t>
<t tx="ekr.20110605121601.18211">def injectIvars(self, parentFrame, name, p, wrapper):

    w = wrapper.widget
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    # Inject ivars
    if name == '1':
        w.leo_p = None # Will be set when the second editor is created.
    else:
        w.leo_p = p and p.copy()
    w.leo_active = True
    w.leo_bodyBar = None
    w.leo_bodyXBar = None
    w.leo_chapter = None
    # w.leo_colorizer = None # Set in JEditColorizer ctor.
    w.leo_frame = parentFrame
    # w.leo_label = None # Injected by packLabel.
    w.leo_name = name
    w.leo_wrapper = wrapper
</t>
<t tx="ekr.20110605121601.18212">def packLabel(self, w, n=None):

    c = self.c
    f = c.frame.top.leo_ui.leo_body_inner_frame
    if n is None: n = self.numberOfEditors
    layout = f.layout()
    f.setObjectName('editorFrame')
    # Create the text: to do: use stylesheet to set font, height.
    lab = QtWidgets.QLineEdit(f)
    lab.setObjectName('editorLabel')
    lab.setText(c.p.h)
    # Pack the label and the text widget.
    # layout.setHorizontalSpacing(4)
    layout.addWidget(lab, 0, max(0, n - 1), QtCore.Qt.AlignVCenter)
    layout.addWidget(w, 1, max(0, n - 1))
    layout.setRowStretch(0, 0)
    layout.setRowStretch(1, 1) # Give row 1 as much as possible.
    w.leo_label = lab # Inject the ivar.
</t>
<t tx="ekr.20110605121601.18213">def recolorWidget(self, p, wrapper):
    '''Support QScintillaColorizer.colorize.'''
    # pylint: disable=arguments-differ
    c = self.c
    colorizer = c.frame.body.colorizer
    if p and colorizer and hasattr(colorizer, 'colorize'):
        g.trace('=====', hasattr(colorizer, 'colorize'), p.h, g.callers())
        old_wrapper = c.frame.body.wrapper
        c.frame.body.wrapper = wrapper
        try:
            colorizer.colorize(p)
        finally:
            # Restore.
            c.frame.body.wrapper = old_wrapper
</t>
<t tx="ekr.20110605121601.18214">def switchToChapter(self, w):
    '''select w.leo_chapter.'''
    c = self.c; cc = c.chapterController
    if hasattr(w, 'leo_chapter') and w.leo_chapter:
        chapter = w.leo_chapter
        name = chapter and chapter.name
        oldChapter = cc.getSelectedChapter()
        if chapter != oldChapter:
            cc.selectChapterByName(name)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18215">def updateInjectedIvars(self, w, p):

    c = self.c
    cc = c.chapterController
    assert g.isTextWidget(w), w
    if cc and self.use_chapters:
        w.leo_chapter = cc.getSelectedChapter()
    else:
        w.leo_chapter = None
    w.leo_p = p.copy()
</t>
<t tx="ekr.20110605121601.18216">def unpackWidget(self, layout, w):

    index = layout.indexOf(w)
    item = layout.itemAt(index)
    item.setGeometry(QtCore.QRect(0, 0, 0, 0))
    layout.removeItem(item)
</t>
<t tx="ekr.20110605121601.18217"></t>
<t tx="ekr.20110605121601.18218">def hideCanvasRenderer(self, event=None):
    '''Hide canvas pane.'''
    c = self.c; d = self.editorWidgets
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name), 'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) &lt;= 1: return
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z: # 2011/11/12
            self.unpackWidget(layout, z)
    w.leo_label = None # 2011/11/12
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label: # 2011/11/12
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None # 2011/11/12
    self.selectEditor(new_wrapper)
</t>
<t tx="ekr.20110605121601.18219">def hideCanvas(self, event=None):
    '''Hide canvas pane.'''
    c = self.c; d = self.editorWidgets
    wrapper = c.frame.body.wrapper
    w = wrapper.widget
    name = w.leo_name
    assert name
    assert wrapper == d.get(name), 'wrong wrapper'
    assert g.isTextWrapper(wrapper), wrapper
    assert g.isTextWidget(w), w
    if len(list(d.keys())) &lt;= 1: return
    # At present, can not delete the first column.
    if name == '1':
        g.warning('can not delete leftmost editor')
        return
    # Actually delete the widget.
    del d[name]
    f = c.frame.top.leo_ui.leo_body_inner_frame
    layout = f.layout()
    for z in (w, w.leo_label):
        if z: # 2011/11/12
            self.unpackWidget(layout, z)
    w.leo_label = None # 2011/11/12
    # Select another editor.
    new_wrapper = list(d.values())[0]
    self.numberOfEditors -= 1
    if self.numberOfEditors == 1:
        w = new_wrapper.widget
        if w.leo_label: # 2011/11/12
            self.unpackWidget(layout, w.leo_label)
            w.leo_label = None # 2011/11/1
    self.selectEditor(new_wrapper)
</t>
<t tx="ekr.20110605121601.18220">def packRenderer(self, f, name, w):
    n = max(1, self.numberOfEditors)
    assert isinstance(f, QtWidgets.QFrame), f
    layout = f.layout()
    f.setObjectName('%s Frame' % name)
    # Create the text: to do: use stylesheet to set font, height.
    lab = QtWidgets.QLineEdit(f)
    lab.setObjectName('%s Label' % name)
    lab.setText(name)
    # Pack the label and the widget.
    layout.addWidget(lab, 0, max(0, n - 1), QtCore.Qt.AlignVCenter)
    layout.addWidget(w, 1, max(0, n - 1))
    layout.setRowStretch(0, 0)
    layout.setRowStretch(1, 1) # Give row 1 as much as possible.
    return lab
</t>
<t tx="ekr.20110605121601.18221"># An override of leoFrame.addEditor.

def showCanvasRenderer(self, event=None):
    '''Show the canvas area in the body pane, creating it if necessary.'''
    c = self.c
    f = c.frame.top.leo_ui.leo_body_inner_frame
    assert isinstance(f, QtWidgets.QFrame), f
    if not self.canvasRenderer:
        name = 'Graphics Renderer'
        self.canvasRenderer = w = QtWidgets.QGraphicsView(f)
        w.setObjectName(name)
    if not self.canvasRendererVisible:
        self.canvasRendererLabel = self.packRenderer(f, name, w)
        self.canvasRendererVisible = True
</t>
<t tx="ekr.20110605121601.18222"># An override of leoFrame.addEditor.

def showTextRenderer(self, event=None):
    '''Show the canvas area in the body pane, creating it if necessary.'''
    c = self.c
    f = c.frame.top.leo_ui.leo_body_inner_frame
    assert isinstance(f, QtWidgets.QFrame), f
    if not self.textRenderer:
        name = 'Text Renderer'
        self.textRenderer = w = qt_text.LeoQTextBrowser(f, c, self)
        w.setObjectName(name)
        self.textRendererWrapper = qt_text.QTextEditWrapper(
            w, name='text-renderer', c=c)
    if not self.textRendererVisible:
        self.textRendererLabel = self.packRenderer(f, name, w)
        self.textRendererVisible = True
</t>
<t tx="ekr.20110605121601.18223"></t>
<t tx="ekr.20110605121601.18224"># badFocusColors = []

def onFocusColorHelper(self, kind, obj):
    '''Handle changes of style when focus changes.'''
    c, vc = self.c, self.c.vimCommands
    if vc and c.vim_mode:
        try:
            assert kind in ('focus-in', 'focus-out')
            w = c.frame.body.wrapper.widget
            vc.set_border(w=w, activeFlag=kind == 'focus-in')
        except Exception:
            # g.es_exception()
            pass
</t>
<t tx="ekr.20110605121601.18245">class LeoQtFrame(leoFrame.LeoFrame):
    """A class that represents a Leo window rendered in qt."""
    @others
</t>
<t tx="ekr.20110605121601.18246"></t>
<t tx="ekr.20110605121601.18247">def __init__(self, c, title, gui):
    # Init the base class.
    leoFrame.LeoFrame.__init__(self, c, gui)
    assert self.c == c
    leoFrame.LeoFrame.instances += 1 # Increment the class var.
    # Official ivars...
    self.iconBar = None
    self.iconBarClass = self.QtIconBarClass
    self.initComplete = False # Set by initCompleteHint().
    self.minibufferVisible = True
    self.statusLineClass = self.QtStatusLineClass
    self.title = title
    self.setIvars()
    self.reloadSettings()
    
def reloadSettings(self):
    c = self.c
    self.cursorStay = c.config.getBool("cursor-stay-on-paste", default=True)
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_chapter_tabs = c.config.getBool('use-chapter-tabs')
</t>
<t tx="ekr.20110605121601.18248">def setIvars(self):
    # "Official ivars created in createLeoFrame and its allies.
    self.bar1 = None
    self.bar2 = None
    self.body = None
    self.f1 = self.f2 = None
    self.findPanel = None # Inited when first opened.
    self.iconBarComponentName = 'iconBar'
    self.iconFrame = None
    self.log = None
    self.canvas = None
    self.outerFrame = None
    self.statusFrame = None
    self.statusLineComponentName = 'statusLine'
    self.statusText = None
    self.statusLabel = None
    self.top = None # This will be a class Window object.
    self.tree = None
    # Used by event handlers...
    self.controlKeyIsDown = False # For control-drags
    self.isActive = True
    self.redrawCount = 0
    self.wantedWidget = None
    self.wantedCallbackScheduled = False
    self.scrollWay = None
</t>
<t tx="ekr.20110605121601.18249">def __repr__(self):
    return "&lt;LeoQtFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20110605121601.18250">def finishCreate(self):

    f = self
    c = self.c
    assert c
    # returns DynamicWindow
    if g.pyzo:
        # A hack: use dummies until later, when real  
        g.pr('----- QtFrame.finishCreate', c.shortFileName())
        assert isinstance(c.frame, LeoQtFrame), repr(c.frame)
        import leo.core.leoFrame as leoFrame
        import leo.core.leoMenu as leoMenu
        #
        f.tree = leoFrame.NullTree(f)
        f.body = leoFrame.NullBody(f)
        f.log = leoFrame.NullLog(f)
        f.menu = leoMenu.NullMenu(f) ### g.TracingNullObject(tag='c.frame.menu')
        f.miniBufferWidget = g.TracingNullObject(tag='c.frame.miniBufferWidget')
        # g.app.windowList.append(f)
        # c.bodyWantsFocus()
        return
    # Old code.
    f.top = g.app.gui.frameFactory.createFrame(f)
        # f.top is a DynamicWindow.
    f.createIconBar() # A base class method.
    f.tree = qt_tree.LeoQtTree(c, f)
    f.createSplitterComponents()
    f.createStatusLine() # A base class method.
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = LeoQtMenu(c, f, label='top-level-menu')
    g.app.windowList.append(f)
    f.miniBufferWidget = qt_text.QMinibufferWrapper(c)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18251">def createSplitterComponents(self):
    c, f = self.c, self
    f.tree = qt_tree.LeoQtTree(c, f)
    f.log = LeoQtLog(f, None)
    f.body = LeoQtBody(f, None)
    f.splitVerticalFlag, ratio, secondary_ratio = f.initialRatios()
    f.resizePanesToRatio(ratio, secondary_ratio)

</t>
<t tx="ekr.20110605121601.18252">def initCompleteHint(self):
    '''A kludge: called to enable text changed events.'''
    self.initComplete = True

</t>
<t tx="ekr.20110605121601.18253"></t>
<t tx="ekr.20110605121601.18254">def destroyAllObjects(self):
    """Clear all links to objects in a Leo window."""
    frame = self; c = self.c
    # g.printGcAll()
    # Do this first.
    &lt;&lt; clear all vnodes in the tree &gt;&gt;
    if 1:
        # Destroy all ivars in subcommanders.
        g.clearAllIvars(c.atFileCommands)
        if c.chapterController: # New in Leo 4.4.3 b1.
            g.clearAllIvars(c.chapterController)
        g.clearAllIvars(c.fileCommands)
        g.clearAllIvars(c.keyHandler) # New in Leo 4.4.3 b1.
        g.clearAllIvars(c.importCommands)
        g.clearAllIvars(c.tangleCommands)
        g.clearAllIvars(c.undoer)
        g.clearAllIvars(c)
    if 0: # No need.
        tree = frame.tree; body = self.body
        g.clearAllIvars(body.colorizer)
        g.clearAllIvars(body)
        g.clearAllIvars(tree)
</t>
<t tx="ekr.20110605121601.18255">vList = [z for z in c.all_unique_nodes()]
for v in vList:
    g.clearAllIvars(v)
vList = [] # Remove these references immediately.
</t>
<t tx="ekr.20110605121601.18256">def destroySelf(self):
    # Remember these: we are about to destroy all of our ivars!
    c, top = self.c, self.top
    if hasattr(g.app.gui, 'frameFactory'):
        g.app.gui.frameFactory.deleteFrame(top)
    # Indicate that the commander is no longer valid.
    c.exists = False
    if 0: # We can't do this unless we unhook the event filter.
        # Destroys all the objects of the commander.
        self.destroyAllObjects()
    c.exists = False # Make sure this one ivar has not been destroyed.
    # print('destroySelf: qtFrame: %s' % c,g.callers(4))
    top.close()
</t>
<t tx="ekr.20110605121601.18257">class QtStatusLineClass(object):
    '''A class representing the status line.'''
    @others
</t>
<t tx="ekr.20110605121601.18258">def __init__(self, c, parentFrame):
    '''Ctor for LeoQtFrame class.'''
    self.c = c
    self.statusBar = c.frame.top.statusBar
    self.lastFcol = 0
    self.lastRow = 0
    self.lastCol = 0
    # Create the text widgets.
    self.textWidget1 = w1 = QtWidgets.QLineEdit(self.statusBar)
    self.textWidget2 = w2 = QtWidgets.QLineEdit(self.statusBar)
    w1.setObjectName('status1')
    w2.setObjectName('status2')
    w1.setReadOnly(True)
    w2.setReadOnly(True)
    splitter = QtWidgets.QSplitter()
    self.statusBar.addWidget(splitter, True)
    sizes = c.config.getString('status-line-split-sizes') or '1 2'
    sizes = [int(i) for i in sizes.replace(',', ' ').split()]
    # pylint: disable=consider-using-ternary
    for n, i in enumerate(sizes):
        w = [w1, w2][n]
        policy = w.sizePolicy()
        policy.setHorizontalStretch(i)
        policy.setHorizontalPolicy(policy.Minimum)
        w.setSizePolicy(policy)
    splitter.addWidget(w1)
    splitter.addWidget(w2)
    c.status_line_unl_mode = 'original'

    def cycle_unl_mode():
        if c.status_line_unl_mode == 'original':
            c.status_line_unl_mode = 'canonical'
        else:
            c.status_line_unl_mode = 'original'
        verbose = c.status_line_unl_mode == 'canonical'
        w2.setText(c.p.get_UNL(with_proto=verbose, with_index=verbose))

    def add_item(event, w2=w2):
        menu = w2.createStandardContextMenu()
        menu.addSeparator()
        menu.addAction("Toggle UNL mode", cycle_unl_mode)
        menu.exec_(event.globalPos())

    w2.contextMenuEvent = add_item
    self.put('')
    self.update()
</t>
<t tx="ekr.20110605121601.18260">def clear(self):
    self.put('')

def get(self):
    return self.textWidget2.text()

def put(self, s, bg=None, fg=None):
    self.put_helper(s, self.textWidget2, bg, fg)

def put1(self, s, bg=None, fg=None):
    self.put_helper(s, self.textWidget1, bg, fg)

styleSheetCache = {}
    # Keys are widgets, values are stylesheets.

def put_helper(self, s, w, bg=None, fg=None):
    '''Put string s in the indicated widget, with proper colors.'''
    c = self.c
    bg = bg or c.config.getColor('status-bg') or 'white'
    fg = fg or c.config.getColor('status-fg') or 'black'
    if True:
        # Work around #804. w is a QLineEdit.
        w.setStyleSheet('background: %s; color: %s;' % (bg, fg))
    else:
        # Rather than put(msg, explicit_color, explicit_color) we should use
        # put(msg, status) where status is None, 'info', or 'fail'.
        # Just as a quick hack to avoid dealing with propagating those changes
        # back upstream, infer status like this:
        if (fg == c.config.getColor('find-found-fg') and
            bg == c.config.getColor('find-found-bg')
        ):
            status = 'info'
        elif (fg == c.config.getColor('find-not-found-fg') and
            bg == c.config.getColor('find-not-found-bg')
        ):
            status = 'fail'
        else:
            status = None
        d = self.styleSheetCache
        if status != d.get(w, '__undefined__'):
            d[w] = status
            c.styleSheetManager.mng.remove_sclass(w, ['info', 'fail'])
            c.styleSheetManager.mng.add_sclass(w, status)
            c.styleSheetManager.mng.update_view(w)  # force appearance update
    w.setText(s)
</t>
<t tx="ekr.20110605121601.18262">class QtIconBarClass(object):
    '''A class representing the singleton Icon bar'''
    @others
</t>
<t tx="ekr.20110605121601.18263">def __init__(self, c, parentFrame):
    '''Ctor for QtIconBarClass.'''
    # Copy ivars
    self.c = c
    self.parentFrame = parentFrame
    # Status ivars.
    self.actions = []
    self.chapterController = None
    self.toolbar = self
    self.w = c.frame.top.iconBar # A QToolBar.
    self.reloadSettings()

def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.buttonColor = c.config.getString('qt-button-color')
    self.toolbar_orientation = c.config.getString('qt-toolbar-location')
</t>
<t tx="ekr.20110605121601.18264"># These *are* called from Leo's core.

def addRow(self, height=None):
    pass # To do.

def getNewFrame(self):
    return None # To do
</t>
<t tx="ekr.20110605121601.18265">def add(self, *args, **keys):
    '''Add a button to the icon bar.'''
    c = self.c
    if not self.w: return
    command = keys.get('command')
    text = keys.get('text')
    # able to specify low-level QAction directly (QPushButton not forced)
    qaction = keys.get('qaction')
    if not text and not qaction:
        g.es('bad toolbar item')
    kind = keys.get('kind') or 'generic-button'
    # imagefile = keys.get('imagefile')
    # image = keys.get('image')

    class leoIconBarButton(QtWidgets.QWidgetAction):

        def __init__(self, parent, text, toolbar):
            QtWidgets.QWidgetAction.__init__(self, parent)
            self.button = None # set below
            self.text = text
            self.toolbar = toolbar

        def createWidget(self, parent):
            self.button = b = QtWidgets.QPushButton(self.text, parent)
            self.button.setProperty('button_kind', kind) # for styling
            return b

    if qaction is None:
        action = leoIconBarButton(parent=self.w, text=text, toolbar=self)
        button_name = text
    else:
        action = qaction
        button_name = action.text()
    self.w.addAction(action)
    self.actions.append(action)
    b = self.w.widgetForAction(action)
    # Set the button's object name so we can use the stylesheet to color it.
    if not button_name: button_name = 'unnamed'
    button_name = button_name + '-button'
    b.setObjectName(button_name)
    b.setContextMenuPolicy(QtCore.Qt.ActionsContextMenu)

    def delete_callback(checked, action=action,):
        self.w.removeAction(action)

    b.leo_removeAction = rb = QtWidgets.QAction('Remove Button', b)
    b.addAction(rb)
    rb.triggered.connect(delete_callback)
    if command:

        def button_callback(event, c=c, command=command):
            val = command()
            if c.exists:
                # c.bodyWantsFocus()
                c.outerUpdate()
            return val

        b.clicked.connect(button_callback)
    return action
</t>
<t tx="ekr.20110605121601.18266">def addRowIfNeeded(self):
    '''Add a new icon row if there are too many widgets.'''
    # n = g.app.iconWidgetCount
    # if n &gt;= self.widgets_per_row:
        # g.app.iconWidgetCount = 0
        # self.addRow()
    # g.app.iconWidgetCount += 1
</t>
<t tx="ekr.20110605121601.18267">def addWidget(self, w):
    self.w.addWidget(w)
</t>
<t tx="ekr.20110605121601.18268">def clear(self):
    """Destroy all the widgets in the icon bar"""
    self.w.clear()
    self.actions = []
    g.app.iconWidgetCount = 0
</t>
<t tx="ekr.20110605121601.18269">def createChaptersIcon(self):

    c = self.c
    f = c.frame
    if f.use_chapters and f.use_chapter_tabs:
        return LeoQtTreeTab(c, f.iconBar)
    else:
        return None
</t>
<t tx="ekr.20110605121601.18270">def deleteButton(self, w):
    """ w is button """
    self.w.removeAction(w)
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
</t>
<t tx="ekr.20110605121601.18271"># qtFrame.QtIconBarClass.setCommandForButton

def setCommandForButton(self, button, command, command_p, controller, gnx, script):
    '''
    Set the "Goto Script" rlick item of an @button button.
    Called from mod_scripting.py plugin.

    button is a leoIconBarButton.
    command is a callback, defined in mod_scripting.py.
    command_p exists only if the @button node exists in the local .leo file.
    gnx is the gnx of the @button node.
    script is a static script for common @button nodes.
    '''
    if not command:
        return
    # Fix bug 74: use the controller and gnx arguments.
    b = button.button
    b.clicked.connect(command)

    def goto_callback(checked, controller=controller, gnx=gnx):
        self.goto_command(controller, gnx)

    b.goto_script = gts = QtWidgets.QAction('Goto Script', b)
    b.addAction(gts)
    gts.triggered.connect(goto_callback)
    rclicks = build_rclick_tree(command_p, top_level=True)
    self.add_rclick_menu(b, rclicks, controller, script=script)
</t>
<t tx="ekr.20110605121601.18274"></t>
<t tx="ekr.20110605121601.18275">def configureBar(self, bar, verticalFlag):
    c = self.c
    # Get configuration settings.
    w = c.config.getInt("split-bar-width")
    if not w or w &lt; 1: w = 7
    relief = c.config.get("split_bar_relief", "relief")
    if not relief: relief = "flat"
    color = c.config.getColor("split-bar-color")
    if not color: color = "LightSteelBlue2"
    try:
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(relief=relief, height=w, bg=color, cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(relief=relief, width=w, bg=color, cursor="sb_h_double_arrow")
    except Exception:
        # Could be a user error. Use all defaults
        g.es("exception in user configuration for splitbar")
        g.es_exception()
        if verticalFlag:
            # Panes arranged vertically; horizontal splitter bar
            bar.configure(height=7, cursor="sb_v_double_arrow")
        else:
            # Panes arranged horizontally; vertical splitter bar
            bar.configure(width=7, cursor="sb_h_double_arrow")
</t>
<t tx="ekr.20110605121601.18276">def configureBarsFromConfig(self):
    c = self.c
    w = c.config.getInt("split-bar-width")
    if not w or w &lt; 1: w = 7
    relief = c.config.get("split_bar_relief", "relief")
    if not relief or relief == "": relief = "flat"
    color = c.config.getColor("split-bar-color")
    if not color or color == "": color = "LightSteelBlue2"
    if self.splitVerticalFlag:
        bar1, bar2 = self.bar1, self.bar2
    else:
        bar1, bar2 = self.bar2, self.bar1
    try:
        bar1.configure(relief=relief, height=w, bg=color)
        bar2.configure(relief=relief, width=w, bg=color)
    except Exception:
        # Could be a user error.
        g.es("exception in user configuration for splitbar")
        g.es_exception()
</t>
<t tx="ekr.20110605121601.18277">def reconfigureFromConfig(self):
    '''Init the configuration of the Qt frame from settings.'''
    c, frame = self.c, self
    frame.configureBarsFromConfig()
    frame.setTabWidth(c.tab_width)
    c.redraw()
</t>
<t tx="ekr.20110605121601.18278">def setInitialWindowGeometry(self):
    """Set the position and size of the frame to config params."""
    c = self.c
    h = c.config.getInt("initial-window-height") or 500
    w = c.config.getInt("initial-window-width") or 600
    x = c.config.getInt("initial-window-left") or 10
    y = c.config.getInt("initial-window-top") or 10
    if h and w and x and y:
        self.setTopGeometry(w, h, x, y)
</t>
<t tx="ekr.20110605121601.18279">def setTabWidth(self, w):
    # A do-nothing because tab width is set automatically.
    # It *is* called from Leo's core.
    pass
</t>
<t tx="ekr.20110605121601.18280">def setWrap(self, p=None, force=False):
    return self.c.frame.body.setWrap(p, force)
</t>
<t tx="ekr.20110605121601.18281">def reconfigurePanes(self):
    c, f = self.c, self
    if f.splitVerticalFlag:
        r = c.config.getRatio("initial-vertical-ratio")
        if r is None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial-vertical-secondary-ratio")
        if r2 is None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial-horizontal-ratio")
        if r is None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial-horizontal-secondary-ratio")
        if r2 is None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    f.resizePanesToRatio(r, r2)
</t>
<t tx="ekr.20110605121601.18282">def resizePanesToRatio(self, ratio, ratio2):
    '''Resize splitter1 and splitter2 using the given ratios.'''
    # pylint: disable=arguments-differ
    if g.pyzo:
        return
    self.divideLeoSplitter1(ratio)
    self.divideLeoSplitter2(ratio2)
</t>
<t tx="ekr.20110605121601.18283">def divideLeoSplitter1(self, frac):
    '''Divide the main splitter.'''
    layout = self.c and self.c.free_layout
    if not layout:
        return
    w = layout.get_main_splitter()
    if w:
        self.divideAnySplitter(frac, w)

def divideLeoSplitter2(self, frac):
    '''Divide the secondary splitter.'''
    layout = self.c and self.c.free_layout
    if not layout:
        return
    w = layout.get_secondary_splitter()
    if w:
        self.divideAnySplitter(frac, w)
</t>
<t tx="ekr.20110605121601.18284"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter(self, frac, splitter):
    '''Set the splitter sizes.'''
    sizes = splitter.sizes()
    if len(sizes) != 2:
        g.trace('%s widget(s) in %s' % (len(sizes), id(splitter)))
        return
    if frac &gt; 1 or frac &lt; 0:
        g.trace('split ratio [%s] out of range 0 &lt;= frac &lt;= 1' % frac)
        return
    s1, s2 = sizes
    s = s1 + s2
    s1 = int(s * frac + 0.5)
    s2 = s - s1
    # g.trace("%2d %2d %5.2f =&gt; %2d %2d" % (sizes[0], sizes[1], frac, s1, s2))
    splitter.setSizes([s1, s2])
</t>
<t tx="ekr.20110605121601.18285"></t>
<t tx="ekr.20110605121601.18286"># Called from quit logic and when user closes the window.
# Returns True if the close happened.

def OnCloseLeoEvent(self):
    f = self; c = f.c
    if c.inCommand:
        c.requestCloseWindow = True
    else:
        g.app.closeLeoWindow(self)
</t>
<t tx="ekr.20110605121601.18287">def OnControlKeyDown(self, event=None):
    self.controlKeyIsDown = True

def OnControlKeyUp(self, event=None):
    self.controlKeyIsDown = False
</t>
<t tx="ekr.20110605121601.18290">def OnActivateTree(self, event=None):
    pass
</t>
<t tx="ekr.20110605121601.18291"># At present, these are not called,
# but they could be called by LeoQTextBrowser.

def OnBodyClick(self, event=None):
    g.trace()
    try:
        c = self.c; p = c.currentPosition()
        if g.doHook("bodyclick1", c=c, p=p, event=event):
            g.doHook("bodyclick2", c=c, p=p, event=event)
            return
        else:
            c.k.showStateAndMode(w=c.frame.body.wrapper)
            g.doHook("bodyclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self, event=None):
    try:
        c = self.c; p = c.currentPosition()
        if g.doHook("bodyrclick1", c=c, p=p, event=event):
            g.doHook("bodyrclick2", c=c, p=p, event=event)
            return
        else:
            c.k.showStateAndMode(w=c.frame.body.wrapper)
            g.doHook("bodyrclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("iconrclick")
</t>
<t tx="ekr.20110605121601.18292"># Not called

def OnBodyDoubleClick(self, event=None):
    try:
        c = self.c; p = c.currentPosition()
        if event and not g.doHook("bodydclick1", c=c, p=p, event=event):
            c.editCommands.extendToWord(event) # Handles unicode properly.
            c.k.showStateAndMode(w=c.frame.body.wrapper)
        g.doHook("bodydclick2", c=c, p=p, event=event)
    except Exception:
        g.es_event_exception("bodydclick")
    return "break" # Restore this to handle proper double-click logic.
</t>
<t tx="ekr.20110605121601.18293"></t>
<t tx="ekr.20110605121601.18294"></t>
<t tx="ekr.20110605121601.18295">@cmd('contract-pane')
def contractPane(self, event=None):
    '''Contract the selected pane.'''
    f = self; c = f.c
    w = c.get_requested_focus() or g.app.gui.get_focus(c)
    wname = c.widget_name(w)
    if not w: return
    if wname.startswith('body'):
        f.contractBodyPane()
        c.bodyWantsFocus()
    elif wname.startswith('log'):
        f.contractLogPane()
        c.logWantsFocus()
    else:
        for z in ('head', 'canvas', 'tree'):
            if wname.startswith(z):
                f.contractOutlinePane()
                c.treeWantsFocus()
                break
</t>
<t tx="ekr.20110605121601.18296">@cmd('expand-pane')
def expandPane(self, event=None):
    '''Expand the selected pane.'''
    f = self; c = f.c
    w = c.get_requested_focus() or g.app.gui.get_focus(c)
    wname = c.widget_name(w)
    if not w: return
    if wname.startswith('body'):
        f.expandBodyPane()
        c.bodyWantsFocus()
    elif wname.startswith('log'):
        f.expandLogPane()
        c.logWantsFocus()
    else:
        for z in ('head', 'canvas', 'tree'):
            if wname.startswith(z):
                f.expandOutlinePane()
                c.treeWantsFocus()
                break
</t>
<t tx="ekr.20110605121601.18297">@cmd('fully-expand-pane')
def fullyExpandPane(self, event=None):
    '''Fully expand the selected pane.'''
    f = self; c = f.c
    w = c.get_requested_focus() or g.app.gui.get_focus(c)
    wname = c.widget_name(w)
    if not w: return
    if wname.startswith('body'):
        f.fullyExpandBodyPane()
        c.treeWantsFocus()
    elif wname.startswith('log'):
        f.fullyExpandLogPane()
        c.bodyWantsFocus()
    else:
        for z in ('head', 'canvas', 'tree'):
            if wname.startswith(z):
                f.fullyExpandOutlinePane()
                c.bodyWantsFocus()
                break
</t>
<t tx="ekr.20110605121601.18298">@cmd('hide-pane')
def hidePane(self, event=None):
    '''Completely contract the selected pane.'''
    f = self; c = f.c
    w = c.get_requested_focus() or g.app.gui.get_focus(c)
    wname = c.widget_name(w)
    if not w: return
    if wname.startswith('body'):
        f.hideBodyPane()
        c.treeWantsFocus()
    elif wname.startswith('log'):
        f.hideLogPane()
        c.bodyWantsFocus()
    else:
        for z in ('head', 'canvas', 'tree'):
            if wname.startswith(z):
                f.hideOutlinePane()
                c.bodyWantsFocus()
                break
</t>
<t tx="ekr.20110605121601.18299">@cmd('contract-body-pane')
@cmd('expand-outline-pane')
def contractBodyPane(self, event=None):
    '''Contract the body pane.'''
    r = min(1.0, self.ratio + 0.1)
    self.divideLeoSplitter1(r)

expandOutlinePane = contractBodyPane

@cmd('contract-outline-pane')
@cmd('expand-body-pane')
def contractOutlinePane(self, event=None):
    '''Contract the outline pane.'''
    r = max(0.0, self.ratio - 0.1)
    self.divideLeoSplitter1(r)

expandBodyPane = contractOutlinePane

@cmd('contract-log-pane')
def contractLogPane(self, event=None):
    '''Contract the log pane.'''
    r = min(1.0, self.secondary_ratio + 0.1)
    self.divideLeoSplitter2(r)

@cmd('expand-log-pane')
def expandLogPane(self, event=None):
    '''Expand the log pane.'''
    r = max(0.0, self.secondary_ratio - 0.1)
    self.divideLeoSplitter2(r)
</t>
<t tx="ekr.20110605121601.18300">@cmd('fully-expand-body-pane')
@cmd('hide-outline-pane')
def fullyExpandBodyPane(self, event=None):
    '''Fully expand the body pane.'''
    self.divideLeoSplitter1(0.0)

@cmd('fully-expand-outline-pane')
@cmd('hide-body-pane')
def fullyExpandOutlinePane(self, event=None):
    '''Fully expand the outline pane.'''
    self.divideLeoSplitter1(1.0)

@cmd('fully-expand-log-pane')
def fullyExpandLogPane(self, event=None):
    '''Fully expand the log pane.'''
    self.divideLeoSplitter2(0.0)

@cmd('hide-log-pane')
def hideLogPane(self, event=None):
    '''Completely contract the log pane.'''
    self.divideLeoSplitter2(1.0)
</t>
<t tx="ekr.20110605121601.18301"></t>
<t tx="ekr.20110605121601.18302">@cmd('toggle-active-pane')
def toggleActivePane(self, event=None):
    '''Toggle the focus between the outline and body panes.'''
    frame = self; c = frame.c
    w = c.get_focus()
    w_name = g.app.gui.widget_name(w)
    if w_name in ('canvas', 'tree', 'treeWidget'):
        c.endEditing()
        c.bodyWantsFocus()
    else:
        c.treeWantsFocus()
</t>
<t tx="ekr.20110605121601.18303">@cmd('cascade-windows')
def cascade(self, event=None):
    '''Cascade all Leo windows.'''
    x, y, delta = 50, 50, 50
    for frame in g.app.windowList:
        w = frame and frame.top
        if w:
            r = w.geometry() # a Qt.Rect
            # 2011/10/26: Fix bug 823601: cascade-windows fails.
            w.setGeometry(QtCore.QRect(x, y, r.width(), r.height()))
            # Compute the new offsets.
            x += 30; y += 30
            if x &gt; 200:
                x = 10 + delta; y = 40 + delta
                delta += 10
</t>
<t tx="ekr.20110605121601.18304">@cmd('equal-sized-panes')
def equalSizedPanes(self, event=None):
    '''Make the outline and body panes have the same size.'''
    self.resizePanesToRatio(0.5, self.secondary_ratio)
</t>
<t tx="ekr.20110605121601.18305">def hideLogWindow(self, event=None):
    '''Hide the log pane.'''
    self.divideLeoSplitter2(0.99)
</t>
<t tx="ekr.20110605121601.18306">@cmd('minimize-all')
def minimizeAll(self, event=None):
    '''Minimize all Leo's windows.'''
    for frame in g.app.windowList:
        self.minimize(frame)

def minimize(self, frame):
    # This unit test will fail when run externally.
    if frame and frame.top:
        # For --gui=qttabs, frame.top.leo_master is a LeoTabbedTopLevel.
        # For --gui=qt,     frame.top is a DynamicWindow.
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['minimize-all'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMinimized)
</t>
<t tx="ekr.20110605121601.18307">@cmd('toggle-split-direction')
def toggleSplitDirection(self, event=None):
    '''Toggle the split direction in the present Leo window.'''
    if hasattr(self.c, 'free_layout'):
        self.c.free_layout.get_top_splitter().rotate()
</t>
<t tx="ekr.20110605121601.18308">@cmd('resize-to-screen')
def resizeToScreen(self, event=None):
    '''Resize the Leo window so it fill the entire screen.'''
    frame = self
    # This unit test will fail when run externally.
    if frame and frame.top:
        # For --gui=qttabs, frame.top.leo_master is a LeoTabbedTopLevel.
        # For --gui=qt,     frame.top is a DynamicWindow.
        w = frame.top.leo_master or frame.top
        if g.unitTesting:
            g.app.unitTestDict['resize-to-screen'] = True
            assert hasattr(w, 'setWindowState'), w
        else:
            w.setWindowState(QtCore.Qt.WindowMaximized)
</t>
<t tx="ekr.20110605121601.18309"></t>
<t tx="ekr.20110605121601.18310">@cmd('open-offline-tutorial')
def leoHelp(self, event=None):
    '''Open Leo's offline tutorial.'''
    frame = self; c = frame.c
    theFile = g.os_path_join(g.app.loadDir, "..", "doc", "sbooks.chm")
    if g.os_path_exists(theFile) and sys.platform.startswith('win'):
        # pylint: disable=no-member
        os.startfile(theFile)
    else:
        answer = g.app.gui.runAskYesNoDialog(c,
            "Download Tutorial?",
            "Download tutorial (sbooks.chm) from SourceForge?")
        if answer == "yes":
            try:
                url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
                import webbrowser
                os.chdir(g.app.loadDir)
                webbrowser.open_new(url)
            except Exception:
                if 0:
                    g.es("exception downloading", "sbooks.chm")
                    g.es_exception()
</t>
<t tx="ekr.20110605121601.18311">def bringToFront(self):
    self.lift()

def deiconify(self):
    if g.pyzo:
        return
    if self.top and self.top.isMinimized(): # Bug fix: 400739.
        self.lift()

def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.

def get_window_info(self):
    if hasattr(self.top, 'leo_master') and self.top.leo_master:
        f = self.top.leo_master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x, y = topLeft.x(), topLeft.y()
    w, h = rect.width(), rect.height()
    return w, h, x, y

def iconify(self):
    if self.top: self.top.showMinimized()

def lift(self):
    if not self.top: return
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()

def getTitle(self):
    # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
    # When using tabs, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
    w = self.top.leo_master if g.app.qt_use_tabs else self.top
    return w.windowTitle()

def setTitle(self, s):
    # pylint: disable=arguments-differ
    if self.top:
        # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
        # When using tabs, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
        w = self.top.leo_master if g.app.qt_use_tabs else self.top
        w.setWindowTitle(s)

def setTopGeometry(self, w, h, x, y, adjustSize=True):
    # self.top is a DynamicWindow.
    if self.top:
        self.top.setGeometry(QtCore.QRect(x, y, w, h))

def update(self, *args, **keys):
    self.top.update()
</t>
<t tx="ekr.20110605121601.18312">class LeoQtLog(leoFrame.LeoLog):
    '''A class that represents the log pane of a Qt window.'''
    @others
</t>
<t tx="ekr.20110605121601.18313"></t>
<t tx="ekr.20110605121601.18314">def __init__(self, frame, parentFrame):
    '''Ctor for LeoQtLog class.'''
    leoFrame.LeoLog.__init__(self, frame, parentFrame)
        # Init the base class. Calls createControl.
    assert self.logCtrl is None, self.logCtrl # Set in finishCreate.
        # Important: depeding on the log *tab*,
        # logCtrl may be either a wrapper or a widget.
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    self.contentsDict = {} # Keys are tab names.  Values are widgets.
    self.eventFilters = [] # Apparently needed to make filters work!
    self.logDict = {} # Keys are tab names text widgets.  Values are the widgets.
    self.logWidget = None # Set in finishCreate.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.
    if g.pyzo:
        self.tabWidget = tw = frame
    else:
        self.tabWidget = tw = c.frame.top.leo_ui.tabWidget
        # The Qt.QTabWidget that holds all the tabs.
        # Fixes bug 917814: Switching Log Pane tabs is done incompletely.
        tw.currentChanged.connect(self.onCurrentChanged)
    if 0: # Not needed to make onActivateEvent work.
        # Works only for .tabWidget, *not* the individual tabs!
        theFilter = qt_events.LeoQtEventFilter(c, w=tw, tag='tabWidget')
        tw.installEventFilter(theFilter)
    # 2013/11/15: Partial fix for bug 1251755: Log-pane refinements
    if g.pyzo:
        pass
    else:
        tw.setMovable(True)
    self.reloadSettings()
    
def reloadSettings(self):
    c = self.c
    self.wrap = bool(c.config.getBool('log-pane-wraps'))
</t>
<t tx="ekr.20110605121601.18315">def finishCreate(self):
    '''Finish creating the LeoQtLog class.'''
    c, log, w = self.c, self, self.tabWidget
    # Remove unneeded tabs.
    for name in ('Tab 1', 'Page'):
        for i in range(w.count()):
            if name == w.tabText(i):
                w.removeTab(i)
                break
    # Rename the 'Tab 2' tab to 'Find'.
    for i in range(w.count()):
        if w.tabText(i) in ('Find', 'Tab 2'):
            w.setTabText(i, 'Find')
            self.contentsDict['Find'] = w.currentWidget()
            break
    # Create the log tab as the leftmost tab.
    # log.selectTab('Log')
    log.createTab('Log')
    self.logWidget = logWidget = self.contentsDict.get('Log')
    option = QtGui.QTextOption
    logWidget.setWordWrapMode(
        option.WordWrap if self.wrap else option.NoWrap)
    for i in range(w.count()):
        if w.tabText(i) == 'Log':
            w.removeTab(i)
    w.insertTab(0, logWidget, 'Log')
    c.spellCommands.openSpellTab()
    # set up links in log handling
    logWidget.setTextInteractionFlags(
        QtCore.Qt.LinksAccessibleByMouse |
        QtCore.Qt.TextEditable |
        QtCore.Qt.TextSelectableByMouse
    )
    logWidget.setOpenLinks(False)
    logWidget.setOpenExternalLinks(False)
    logWidget.anchorClicked.connect(self.linkClicked)
    #794: Clicking Find Tab should do exactly what pushing Ctrl-F does
    
    def tab_callback(index):
        name = w.tabText(index)
        if name == 'Find':
            c.findCommands.startSearch(event=None)

    w.currentChanged.connect(tab_callback)
</t>
<t tx="ekr.20110605121601.18316">def getName(self):
    return 'log' # Required for proper pane bindings.
</t>
<t tx="ekr.20110605121601.18321"></t>
<t tx="ekr.20110605121601.18322">def put(self, s, color=None, tabName='Log', from_redirect=False, nodeLink=None):
    '''
    Put s to the Qt Log widget, converting to html.
    All output to the log stream eventually comes here.

    The from_redirect keyword argument is no longer used.
    '''
    c = self.c
    if g.app.quitting or not c or not c.exists:
        return
    # Note: g.actualColor does all color translation.
    if color:
        color = leoColor.getColor(color)
    if not color:
        # #788: First, fall back to 'log_black_color', not 'black.
        color = c.config.getColor('log-black-color')
        if not color:
            # Should never be necessary.
            color = 'black'
    self.selectTab(tabName or 'Log')
    # Must be done after the call to selectTab.
    w = self.logCtrl.widget # w is a QTextBrowser
    if w:
        sb = w.horizontalScrollBar()
        s = s.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;')
        # #884: Always convert leading blanks and tabs to &amp;nbsp.
        n = len(s) - len(s.lstrip())
        if n &gt; 0 and s.strip():
            s = '&amp;nbsp;' * (n+1) + s[n:]
        if not self.wrap:
            # Convert all other blanks to &amp;nbsp;
            s = s.replace(' ', '&amp;nbsp;')
        s = s.replace('\n', '&lt;br&gt;')
            # The caller is responsible for newlines!
        s = '&lt;font color="%s"&gt;%s&lt;/font&gt;' % (color, s)
        if nodeLink:
            url = nodeLink
            for scheme in 'file', 'unl':
                # QUrl requires paths start with '/'
                if url.startswith(scheme+'://') and not url.startswith(scheme+':///'):
                    url = url.replace('://', ':///', 1)
            s = '&lt;a href="%s" title="%s"&gt;%s&lt;/a&gt;' % (url, nodeLink, s)
        w.insertHtml(s)
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(0) # Force the slider to the initial position.
        w.repaint() # Slow, but essential.
</t>
<t tx="ekr.20110605121601.18323">def putnl(self, tabName='Log'):
    '''Put a newline to the Qt log.'''
    # 
    # This is not called normally.
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    w = self.logCtrl.widget
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        # Not needed!
            # contents = w.toHtml()
            # w.setHtml(contents + '\n')
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
    else:
        # put s to logWaiting and print  a newline
        g.app.logWaiting.append(('\n', 'black', True),)
</t>
<t tx="ekr.20110605121601.18324"></t>
<t tx="ekr.20110605121601.18325">def clearTab(self, tabName, wrap='none'):
    w = self.logDict.get(tabName)
    if w:
        w.clear() # w is a QTextBrowser.
</t>
<t tx="ekr.20110605121601.18326">def createTab(self, tabName, createText=True, widget=None, wrap='none'):
    """
    Create a new tab in tab widget
    if widget is None, Create a QTextBrowser,
    suitable for log functionality.
    """
    c = self.c
    if widget is None:
        widget = qt_text.LeoQTextBrowser(parent=None, c=c, wrapper=self)
            # widget is subclass of QTextBrowser.
        contents = qt_text.QTextEditWrapper(widget=widget, name='log', c=c)
            # contents a wrapper.
        widget.leo_log_wrapper = contents
            # Inject an ivar into the QTextBrowser that points to the wrapper.
        option = QtGui.QTextOption
        widget.setWordWrapMode(option.WordWrap if self.wrap else option.NoWrap)
        widget.setReadOnly(False) # Allow edits.
        self.logDict[tabName] = widget
        if tabName == 'Log':
            self.logCtrl = contents
            widget.setObjectName('log-widget')
        # Set binding on all log pane widgets.
        g.app.gui.setFilter(c, widget, self, tag='log')
        self.contentsDict[tabName] = widget
        self.tabWidget.addTab(widget, tabName)
    else:
        contents = widget
            # Unlike text widgets, contents is the actual widget.
        widget.leo_log_wrapper = contents
            # The leo_log_wrapper is the widget itself.
        g.app.gui.setFilter(c, widget, contents, 'tabWidget')
        self.contentsDict[tabName] = contents
        self.tabWidget.addTab(contents, tabName)
    return contents
</t>
<t tx="ekr.20110605121601.18327">@cmd('cycle-tab-focus')
def cycleTabFocus(self, event=None):
    '''Cycle keyboard focus between the tabs in the log pane.'''
    w = self.tabWidget
    i = w.currentIndex()
    i += 1
    if i &gt;= w.count():
        i = 0
    tabName = w.tabText(i)
    self.selectTab(tabName, createText=False)
    return i
</t>
<t tx="ekr.20110605121601.18328">def deleteTab(self, tabName, force=False):
    '''Delete the tab if it exists.  Otherwise do *nothing*.'''
    c = self.c
    w = self.tabWidget
    if force or tabName not in ('Log', 'Find', 'Spell'):
        for i in range(w.count()):
            if tabName == w.tabText(i):
                w.removeTab(i)
                self.selectTab('Log')
                c.invalidateFocus()
                c.bodyWantsFocus()
                return
</t>
<t tx="ekr.20110605121601.18329">def hideTab(self, tabName):
    self.selectTab('Log')
</t>
<t tx="ekr.20110605121601.18330">def numberOfVisibleTabs(self):
    return len([val for val in self.contentsDict.values() if val is not None])
        # **Note**: the base-class version of this uses frameDict.
</t>
<t tx="ekr.20110605121601.18331"># createText is used by LeoLog.selectTab.

def selectTab(self, tabName, createText=True, widget=None, wrap='none'):
    '''Create the tab if necessary and make it active.'''
    if not self.selectHelper(tabName):
        self.createTab(tabName, widget=widget, wrap=wrap)
        self.selectHelper(tabName)
</t>
<t tx="ekr.20110605121601.18332">def selectHelper(self, tabName):

    c, w = self.c, self.tabWidget
    for i in range(w.count()):
        if tabName == w.tabText(i):
            w.setCurrentIndex(i)
            widget = w.widget(i)
            #
            # Set the .widget ivar only if there is a wrapper.
            wrapper = hasattr(widget, 'leo_log_wrapper') and widget.leo_log_wrapper
            if wrapper:
                self.logCtrl = wrapper
            #
            # Do *not* set focus here!
                # c.widgetWantsFocus(tab_widget)
            if tabName == 'Find':
                # Fix bug 1254861: Ctrl-f doesn't ensure find input field visible.
                if c.config.getBool('auto-scroll-find-tab', default=True):
                    # This is the cause of unwanted scrolling.
                    findbox = c.findCommands.ftm.find_findbox
                    if hasattr(widget, 'ensureWidgetVisible'):
                        widget.ensureWidgetVisible(findbox)
                    else:
                        findbox.setFocus()
            elif tabName == 'Spell':
                #
                # the base class uses this as a flag to see if the spell system needs initing
                self.frameDict['Spell'] = widget
            self.tabName = tabName
            return True
    #
    # General case.
    self.tabName = None
    return False
</t>
<t tx="ekr.20110605121601.18333">def createColorPicker(self, tabName):
    g.warning('color picker not ready for qt')
</t>
<t tx="ekr.20110605121601.18334"></t>
<t tx="ekr.20110605121601.18335">def createFontPicker(self, tabName):
    # log = self
    QFont = QtGui.QFont
    font, ok = QtWidgets.QFontDialog.getFont()
    if not (font and ok): return
    style = font.style()
    table = (
        (QFont.StyleNormal, 'normal'),
        (QFont.StyleItalic, 'italic'),
        (QFont.StyleOblique, 'oblique'))
    for val, name in table:
        if style == val:
            style = name
            break
    else:
        style = ''
    weight = font.weight()
    table = (
        (QFont.Light, 'light'),
        (QFont.Normal, 'normal'),
        (QFont.DemiBold, 'demibold'),
        (QFont.Bold, 'bold'),
        (QFont.Black, 'black'))
    for val, name in table:
        if weight == val:
            weight = name
            break
    else:
        weight = ''
    table = (
        ('family', str(font.family())),
        ('size  ', font.pointSize()),
        ('style ', style),
        ('weight', weight),
    )
    for key, val in table:
        if val: g.es(key, val, tabName='Fonts')
</t>
<t tx="ekr.20110605121601.18339">def hideFontTab(self, event=None):
    c = self.c
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18404"></t>
<t tx="ekr.20110605121601.18405">def __init__(self, c, frame):
    '''Ctor for the LeoQtTree class.'''
    leoFrame.LeoTree.__init__(self, frame)
        # Init the base class.
    self.c = c
    # Widget independent status ivars...
    self.prev_v = None
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.busy = False
    # Debugging...
    self.traceCallersFlag = False # Enable traceCallers method.
    # Associating items with position and vnodes...
    self.items = []
    self.item2positionDict = {}
    self.item2vnodeDict = {}
    self.position2itemDict = {}
    self.vnode2itemsDict = {} # values are lists of items.
    self.editWidgetsDict = {} # keys are native edit widgets, values are wrappers.
    self.reloadSettings()
    # Components.
    self.canvas = self # An official ivar used by Leo's core.
    self.headlineWrapper = qt_text.QHeadlineWrapper # This is a class.
    if g.pyzo:
        self.treeWidget = w = frame
        ### self.treeWidget = w = frame.top.leo_ui.treeWidget
    else:
        self.treeWidget = w = frame.top.leo_ui.treeWidget # An internal ivar.
        # w is a LeoQTreeWidget, a subclass of QTreeWidget.
    # "declutter", node appearance tweaking
    self.declutter_patterns = None  # list of pairs of patterns for decluttering
    self.declutter_update = False  # true when update on idle needed
    if 0: # EKR: This looks like a bad idea.
        g.registerHandler('save1', self.clear_visual_icons)
        g.registerHandler('headkey2', self.update_appearance)
        g.registerHandler('idle', self.update_appearance_idle)

    if 0: # Drag and drop
        w.setDragEnabled(True)
        w.viewport().setAcceptDrops(True)
        w.showDropIndicator = True
        w.setAcceptDrops(True)
        w.setDragDropMode(w.InternalMove)
        if 1: # Does not work

            def dropMimeData(self, data, action, row, col, parent):
                g.trace()
            # w.dropMimeData = dropMimeData

            def mimeData(self, indexes):
                g.trace()
    # Early inits...
    if g.pyzo:
        return
    try:
        w.headerItem().setHidden(True)
    except Exception:
        pass
    n = c.config.getInt('icon-height') or 16
    w.setIconSize(QtCore.QSize(160, n))
</t>
<t tx="ekr.20110605121601.18406">def initAfterLoad(self):
    '''Do late-state inits.'''
    # Called by Leo's core.
    c = self.c
    # w = c.frame.top
    tw = self.treeWidget
    if not LeoQtTree.callbacksInjected:
        LeoQtTree.callbacksInjected = True
        self.injectCallbacks() # A base class method.
    tw.itemDoubleClicked.connect(self.onItemDoubleClicked)
    tw.itemClicked.connect(self.onItemClicked)
    tw.itemSelectionChanged.connect(self.onTreeSelect)
    tw.itemCollapsed.connect(self.onItemCollapsed)
    tw.itemExpanded.connect(self.onItemExpanded)
    tw.customContextMenuRequested.connect(self.onContextMenu)
    # tw.onItemChanged.connect(self.onItemChanged)
    g.app.gui.setFilter(c, tw, self, tag='tree')
    # 2010/01/24: Do not set this here.
    # The read logic sets c.changed to indicate nodes have changed.
    # c.setChanged(False)
</t>
<t tx="ekr.20110605121601.18408">def clear(self):
    '''Clear all widgets in the tree.'''
    w = self.treeWidget
    w.clear()
</t>
<t tx="ekr.20110605121601.18409"></t>
<t tx="ekr.20110605121601.18410">def drawIcon(self, p):
    '''Redraw the icon at p.'''
    w = self.treeWidget
    itemOrTree = self.position2item(p) or w
    item = QtWidgets.QTreeWidgetItem(itemOrTree)
    icon = self.getIcon(p)
    self.setItemIcon(item, icon)
</t>
<t tx="ekr.20110605121601.18411">def getIcon(self, p):
    '''Return the proper icon for position p.'''
    p.v.iconVal = val = p.v.computeIcon()
    return self.getCompositeIconImage(p, val)
</t>
<t tx="ekr.20110605121601.18412">def getCompositeIconImage(self, p, val):
    '''Get the icon at position p.'''
    userIcons = self.c.editCommands.getIconList(p)
    # Don't take this shortcut - not theme aware, see getImageImage()
    # which is called below - TNB 20130313
        # if not userIcons:
        #     return self.getStatusIconImage(p)
    hash = [i['file'] for i in userIcons if i['where'] == 'beforeIcon']
    hash.append(str(val))
    hash.extend([i['file'] for i in userIcons if i['where'] == 'beforeHeadline'])
    hash = ':'.join(hash)
    if hash in g.app.gui.iconimages:
        icon = g.app.gui.iconimages[hash]
        return icon
    images = [g.app.gui.getImageImage(i['file']) for i in userIcons
             if i['where'] == 'beforeIcon']
    images.append(g.app.gui.getImageImage("box%02d.png" % val))
    images.extend([g.app.gui.getImageImage(i['file']) for i in userIcons
                  if i['where'] == 'beforeHeadline'])
    images = [z for z in images if z] # 2013/12/23: Remove missing images.
    if not images:
        return None
    hsep = self.c.config.getInt('tree-icon-separation') or 0
    width = sum([i.width() for i in images]) + hsep * (len(images)-1)
    height = max([i.height() for i in images])
    pix = QtGui.QImage(width, height, QtGui.QImage.Format_ARGB32_Premultiplied)
    pix.fill(QtGui.QColor(0, 0, 0, 0).rgba()) # transparent fill, rgbA
    # .rgba() call required for Qt4.7, later versions work with straight color
    painter = QtGui.QPainter()
    if not painter.begin(pix):
        print("Failed to init. painter for icon")
        # don't return, the code still makes an icon for the cache
        # which stops this being called again and again
    x = 0
    for i in images:
        painter.drawPixmap(x, (height - i.height()) // 2, i)
        x += i.width() + hsep
    painter.end()
    icon = QtGui.QIcon(QtGui.QPixmap.fromImage(pix))
    g.app.gui.iconimages[hash] = icon
    return icon
</t>
<t tx="ekr.20110605121601.18413">def setItemIconHelper(self, item, icon):
    # Generates an item-changed event.
    if item:
        item.setIcon(0, icon)
</t>
<t tx="ekr.20110605121601.18414"></t>
<t tx="ekr.20110605121601.18415">def childIndexOfItem(self, item):
    parent = item and item.parent()
    if parent:
        n = parent.indexOfChild(item)
    else:
        w = self.treeWidget
        n = w.indexOfTopLevelItem(item)
    return n
</t>
<t tx="ekr.20110605121601.18416">def childItems(self, parent_item):
    '''Return the list of child items of the parent item,
    or the top-level items if parent_item is None.'''
    if parent_item:
        n = parent_item.childCount()
        items = [parent_item.child(z) for z in range(n)]
    else:
        w = self.treeWidget
        n = w.topLevelItemCount()
        items = [w.topLevelItem(z) for z in range(n)]
    return items
</t>
<t tx="ekr.20110605121601.18417">def closeEditorHelper(self, e, item):
    'End editing of the underlying QLineEdit widget for the headline.' ''
    w = self.treeWidget
    if e:
        w.closeEditor(e, QtWidgets.QAbstractItemDelegate.NoHint)
        try:
            # work around https://bugs.launchpad.net/leo-editor/+bug/1041906
            # underlying C/C++ object has been deleted
            w.setItemWidget(item, 0, None)
                # Make sure e is never referenced again.
            w.setCurrentItem(item)
        except RuntimeError:
            if 1: # Testing.
                g.es_exception()
            else:
                # Recover silently even if there is a problem.
                pass
</t>
<t tx="ekr.20110605121601.18418">def connectEditorWidget(self, e, item):
    if not e:
        return g.trace('can not happen: no e')
    # Hook up the widget.
    wrapper = self.getWrapper(e, item)

    def editingFinishedCallback(e=e, item=item, self=self, wrapper=wrapper):
        c = self.c
        w = self.treeWidget
        self.onHeadChanged(p=c.p, e=e)
        w.setCurrentItem(item)

    e.editingFinished.connect(editingFinishedCallback)
    return wrapper # 2011/02/12
</t>
<t tx="ekr.20110605121601.18419">def contractItem(self, item):
    self.treeWidget.collapseItem(item)

def expandItem(self, item):
    self.treeWidget.expandItem(item)
</t>
<t tx="ekr.20110605121601.18420">def createTreeEditorForItem(self, item):

    w = self.treeWidget
    w.setCurrentItem(item) # Must do this first.
    if self.use_declutter:
        item.setText(0, item._real_text)
    w.editItem(item)
    e = w.itemWidget(item, 0)
    e.setObjectName('headline')
    wrapper = self.connectEditorWidget(e, item)
    self.sizeTreeEditor(self.c, e)
    return e, wrapper
</t>
<t tx="ekr.20110605121601.18421">def createTreeItem(self, p, parent_item):
    
    if g.pyzo:
        return g.TracingNullObject(tag='tree item')

    w = self.treeWidget
    itemOrTree = parent_item or w
    item = QtWidgets.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
    try:
        g.visit_tree_item(self.c, p, item)
    except leoPlugins.TryNext:
        pass
    #print "item",item
    return item
</t>
<t tx="ekr.20110605121601.18422">def editLabelHelper(self, item, selectAll=False, selection=None):
    '''
    Help nativeTree.editLabel do gui-specific stuff.
    '''
    c, vc = self.c, self.c.vimCommands
    w = self.treeWidget
    w.setCurrentItem(item)
        # Must do this first.
        # This generates a call to onTreeSelect.
    w.editItem(item)
        # Generates focus-in event that tree doesn't report.
    e = w.itemWidget(item, 0) # A QLineEdit.
    if e:
        s = e.text(); len_s = len(s)
        if s == 'newHeadline': selectAll = True
        if selection:
            # pylint: disable=unpacking-non-sequence
            # Fix bug https://groups.google.com/d/msg/leo-editor/RAzVPihqmkI/-tgTQw0-LtwJ
            # Note: negative lengths are allowed.
            i, j, ins = selection
            if ins is None:
                start, n = i, abs(i - j)
                # This case doesn't happen for searches.
            elif ins == j:
                start, n = i, j - i
            else:
                start = start, n = j, i - j
        elif selectAll: start, n, ins = 0, len_s, len_s
        else: start, n, ins = len_s, 0, len_s
        e.setObjectName('headline')
        e.setSelection(start, n)
        # e.setCursorPosition(ins) # Does not work.
        e.setFocus()
        wrapper = self.connectEditorWidget(e, item) # Hook up the widget.
        if vc and c.vim_mode: #  and selectAll
            # For now, *always* enter insert mode.
            if vc.is_text_wrapper(wrapper):
                vc.begin_insert_mode(w=wrapper)
            else:
                g.trace('not a text widget!', wrapper)
    return e, wrapper
</t>
<t tx="ekr.20110605121601.18423">def getCurrentItem(self):
    w = self.treeWidget
    return w.currentItem()
</t>
<t tx="ekr.20110605121601.18424">def getItemText(self, item):
    '''Return the text of the item.'''
    if item:
        return item.text(0)
    else:
        return '&lt;no item&gt;'
</t>
<t tx="ekr.20110605121601.18425">def getParentItem(self, item):
    return item and item.parent()
</t>
<t tx="ekr.20110605121601.18426">def getSelectedItems(self):
    w = self.treeWidget
    return w.selectedItems()
</t>
<t tx="ekr.20110605121601.18427">def getTreeEditorForItem(self, item):
    '''Return the edit widget if it exists.
    Do *not* create one if it does not exist.
    '''
    w = self.treeWidget
    e = w.itemWidget(item, 0)
    return e
</t>
<t tx="ekr.20110605121601.18428">def getWrapper(self, e, item):
    '''Return headlineWrapper that wraps e (a QLineEdit).'''
    c = self.c
    if e:
        wrapper = self.editWidgetsDict.get(e)
        if wrapper:
            pass
        else:
            if item:
                # 2011/02/12: item can be None.
                wrapper = self.headlineWrapper(c, item, name='head', widget=e)
                self.editWidgetsDict[e] = wrapper
        return wrapper
    else:
        g.trace('no e')
        return None
</t>
<t tx="ekr.20110605121601.18429">def nthChildItem(self, n, parent_item):
    children = self.childItems(parent_item)
    if n &lt; len(children):
        item = children[n]
    else:
        # This is **not* an error.
        # It simply means that we need to redraw the tree.
        item = None
    return item
</t>
<t tx="ekr.20110605121601.18430">def scrollToItem(self, item):
    '''
    Scroll the tree widget so that item is visible.
    Leo's core no longer calls this method.
    '''
    w = self.treeWidget
    hPos, vPos = self.getScroll()
    w.scrollToItem(item, w.EnsureVisible)
        # Fix #265: Erratic scrolling bug.
        # w.PositionAtCenter causes unwanted scrolling.
    self.setHScroll(0)
        # Necessary
</t>
<t tx="ekr.20110605121601.18431">def setCurrentItemHelper(self, item):
    w = self.treeWidget
    w.setCurrentItem(item)
</t>
<t tx="ekr.20110605121601.18432">def setItemText(self, item, s):
    if item:
        item.setText(0, s)
        if self.use_declutter:
            item._real_text = s
</t>
<t tx="ekr.20110605121601.18433"></t>
<t tx="ekr.20110605121601.18434">def getScroll(self):
    '''Return the hPos,vPos for the tree's scrollbars.'''
    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    vScroll = w.verticalScrollBar()
    hPos = hScroll.sliderPosition()
    vPos = vScroll.sliderPosition()
    return hPos, vPos
</t>
<t tx="ekr.20110605121601.18435">def setHScroll(self, hPos):

    w = self.treeWidget
    hScroll = w.horizontalScrollBar()
    hScroll.setValue(hPos)

def setVScroll(self, vPos):

    w = self.treeWidget
    vScroll = w.verticalScrollBar()
    vScroll.setValue(vPos)
</t>
<t tx="ekr.20110605121601.18437">def onContextMenu(self, point):
    c = self.c
    w = self.treeWidget
    handlers = g.tree_popup_handlers
    menu = QtWidgets.QMenu()
    menuPos = w.mapToGlobal(point)
    if not handlers:
        menu.addAction("No popup handlers")
    p = c.p.copy()
    done = set()
    for handler in handlers:
        # every handler has to add it's QActions by itself
        if handler in done:
            # do not run the same handler twice
            continue
        try:
            handler(c, p, menu)
        except Exception:
            g.es_print('Exception executing right-click handler')
            g.es_exception()
    menu.popup(menuPos)
    self._contextmenu = menu
</t>
<t tx="ekr.20110605121601.18466">def createFrame(self, leoFrame):

    c = leoFrame.c
    assert not g.pyzo, g.callers()
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c, tabw)
    self.leoFrames[dw] = leoFrame
    # Shorten the title.
    title = os.path.basename(c.mFileName) if c.mFileName else leoFrame.title
    tip = leoFrame.title
    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)
    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    g.app.gui.setFilter(c, dw, dw, tag='tabbed-frame')
    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() &gt; 1)
    tabw.setTabsClosable(c.config.getBool('outline-tabs-show-close', True))
    dw.show()
    tabw.show()
    return dw
</t>
<t tx="ekr.20110605121601.18468">def createMaster(self):
    if g.pyzo:
        self.masterFrame = g.TracingNullObject(tag='LeoTabbedTopLevel')
            # Could be None. No need for a real shim.
        return
    mf = self.masterFrame = LeoTabbedTopLevel(factory=self)
    g.app.gui.attachLeoIcon(mf)
    tabbar = mf.tabBar()
    try:
        tabbar.setTabsClosable(True)
        tabbar.tabCloseRequested.connect(self.slotCloseRequest)
    except AttributeError:
        pass # Qt 4.4 does not support setTabsClosable
    mf.currentChanged.connect(self.slotCurrentChanged)
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
</t>
<t tx="ekr.20110605121601.18469">def setTabForCommander(self, c):
    
    tabw = self.masterFrame # a QTabWidget
    if not tabw:
        return ### pyzo support.
    for dw in self.leoFrames: # A dict whose keys are DynamicWindows.
        if dw.leo_c == c:
            for i in range(tabw.count()):
                if tabw.widget(i) == dw:
                    tabw.setCurrentIndex(i)
                    break
            break
</t>
<t tx="ekr.20110605121601.18574">@nobeautify

def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {
        #
        # Used in Leo rules...
        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),
        #
        # Pygments tags.  Non-default values are taken from 'default' style.
        #
        # Top-level...
        # tag name          :( option name,         default color),
        'error'             :('error',              '#FF0000'), # border
        'other'             :('other',              'white'),
        'punctuation'       :('punctuation',        'white'),
        'whitespace'        :('whitespace',         '#bbbbbb'),
        'xt'                :('xt',                 '#bbbbbb'),
        #
        # Comment...
        # tag name          :( option name,         default color),
        'comment'           :('comment',            '#408080'), # italic
        'comment.hashbang'  :('comment.hashbang',   '#408080'),
        'comment.multiline' :('comment.multiline',  '#408080'),
        'comment.special'   :('comment.special',    '#408080'),
        'comment.preproc'   :('comment.preproc',    '#BC7A00'), # noitalic
        'comment.single'    :('comment.single',     '#BC7A00'), # italic
        #
        # Generic...
        # tag name          :( option name,         default color),
        'generic'           :('generic',            '#A00000'),
        'generic.deleted'   :('generic.deleted',    '#A00000'),
        'generic.emph'      :('generic.emph',       '#000080'), # italic
        'generic.error'     :('generic.error',      '#FF0000'),
        'generic.heading'   :('generic.heading',    '#000080'), # bold
        'generic.inserted'  :('generic.inserted',   '#00A000'),
        'generic.output'    :('generic.output',     '#888'),
        'generic.prompt'    :('generic.prompt',     '#000080'), # bold
        'generic.strong'    :('generic.strong',     '#000080'), # bold
        'generic.subheading':('generic.subheading', '#800080'), # bold
        'generic.traceback' :('generic.traceback',  '#04D'),
        #
        # Keyword...
        # tag name              :( option name,             default color),
        'keyword'               :('keyword',                '#008000'), # bold
        'keyword.constant'      :('keyword.constant',       '#008000'),
        'keyword.declaration'   :('keyword.declaration',    '#008000'),
        'keyword.namespace'     :('keyword.namespace',      '#008000'),
        'keyword.pseudo'        :('keyword.pseudo',         '#008000'), # nobold
        'keyword.reserved'      :('keyword.reserved',       '#008000'),
        'keyword.type'          :('keyword.type',           '#B00040'),
        #
        # Literal...
        # tag name              :( option name,         default color),
        'literal'               :('literal',            'white'),
        'literal.date'          :('literal.date',       'white'),
        #
        # Name...
        # tag name              :( option name,         default color
        # 'name' defined below.
        'name.attribute'        :('name.attribute',     '#7D9029'), # bold
        'name.builtin'          :('name.builtin',       '#008000'),
        'name.builtin.pseudo'   :('name.builtin.pseudo','#008000'),
        'name.class'            :('name.class',         '#0000FF'), # bold
        'name.constant'         :('name.constant',      '#880000'),
        'name.decorator'        :('name.decorator',     '#AA22FF'),
        'name.entity'           :('name.entity',        '#999999'), # bold
        'name.exception'        :('name.exception',     '#D2413A'), # bold
        'name.function'         :('name.function',      '#0000FF'),
        'name.function.magic'   :('name.function.magic','#0000FF'),
        'name.label'            :('name.label',         '#A0A000'),
        'name.namespace'        :('name.namespace',     '#0000FF'), # bold
        'name.other'            :('name.other',         'red'),
        'name.pygments'         :('name.pygments',      'white'),
            # A hack: getLegacyFormat returns name.pygments instead of name.
        'name.tag'              :('name.tag',               '#008000'), # bold
        'name.variable'         :('name.variable',          '#19177C'),
        'name.variable.class'   :('name.variable.class',    '#19177C'),
        'name.variable.global'  :('name.variable.global',   '#19177C'),
        'name.variable.instance':('name.variable.instance', '#19177C'),
        'name.variable.magic'   :('name.variable.magic',    '#19177C'),
        #
        # Number...
        # tag name              :( option name,         default color
        'number'                :('number',             '#666666'),
        'number.bin'            :('number.bin',         '#666666'),
        'number.float'          :('number.float',       '#666666'),
        'number.hex'            :('number.hex',         '#666666'),
        'number.integer'        :('number.integer',     '#666666'),
        'number.integer.long'   :('number.integer.long','#666666'),
        'number.oct'            :('number.oct',         '#666666'),
        #
        # Operator...
        # tag name          :( option name,         default color
        # 'operator' defined below.
        'operator.word'     :('operator.Word',      '#AA22FF'), # bold
        #
        # String...
        # tag name          :( option name,         default color
        'string'            :('string',             '#BA2121'),
        'string.affix'      :('string.affix',       '#BA2121'),
        'string.backtick'   :('string.backtick',    '#BA2121'),
        'string.char'       :('string.char',        '#BA2121'),
        'string.delimiter'  :('string.delimiter',   '#BA2121'),
        'string.doc'        :('string.doc',         '#BA2121'), # italic
        'string.double'     :('string.double',      '#BA2121'),
        'string.escape'     :('string.escape',      '#BB6622'), # bold
        'string.heredoc'    :('string.heredoc',     '#BA2121'),
        'string.interpol'   :('string.interpol',    '#BB6688'), # bold
        'string.other'      :('string.other',       '#008000'),
        'string.regex'      :('string.regex',       '#BB6688'),
        'string.single'     :('string.single',      '#BA2121'),
        'string.symbol'     :('string.symbol',      '#19177C'),
        #
        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', 'black'),
        'trailing_whitespace': ('trailing_whitespace_color', '#808080'),
    }
</t>
<t tx="ekr.20110605121601.18575">@nobeautify

def defineDefaultFontDict (self):

    self.default_font_dict = {
        #
        # Used in Leo rules...
        # tag name      : option name
        'blank'         :'show_invisibles_space_font', # 2011/10/24.
        'docpart'       :'doc_part_font',
        'leokeyword'    :'leo_keyword_font',
        'link'          :'section_name_font',
        'name'          :'undefined_section_name_font',
        'namebrackets'  :'section_name_brackets_font',
        'tab'           :'show_invisibles_tab_font', # 2011/10/24.
        'url'           :'url_font',
        #
        # Pygments tags (lower case)...
        # tag name          : option name
        "comment"           :'comment1_font',
        "comment.preproc"   :'comment2_font',
        "comment.single"    :'comment1_font',
        "error"             :'null_font',
        "generic.deleted"   :'literal4_font',
        "generic.emph"      :'literal4_font',
        "generic.error"     :'literal4_font',
        "generic.heading"   :'literal4_font',
        "generic.inserted"  :'literal4_font',
        "generic.output"    :'literal4_font',
        "generic.prompt"    :'literal4_font',
        "generic.strong"    :'literal4_font',
        "generic.subheading":'literal4_font',
        "generic.traceback" :'literal4_font',
        "keyword"           :'keyword1_font',
        "keyword.pseudo"    :'keyword2_font',
        "keyword.type"      :'keyword3_font',
        "name.attribute"    :'null_font',
        "name.builtin"      :'null_font',
        "name.class"        :'null_font',
        "name.constant"     :'null_font',
        "name.decorator"    :'null_font',
        "name.entity"       :'null_font',
        "name.exception"    :'null_font',
        "name.function"     :'null_font',
        "name.label"        :'null_font',
        "name.namespace"    :'null_font',
        "name.tag"          :'null_font',
        "name.variable"     :'null_font',
        "number"            :'null_font',
        "operator.word"     :'keyword4_font',
        "string"            :'literal1_font',
        "string.doc"        :'literal1_font',
        "string.escape"     :'literal1_font',
        "string.interpol"   :'literal1_font',
        "string.other"      :'literal1_font',
        "string.regex"      :'literal1_font',
        "string.single"     :'literal1_font',
        "string.symbol"     :'literal1_font',
        'xt'                :'text_font',
        "whitespace"        :'text_font',
        #
        # jEdit tags.
        # tag name     : option name
        'comment1'      :'comment1_font',
        'comment2'      :'comment2_font',
        'comment3'      :'comment3_font',
        'comment4'      :'comment4_font',
        #'default'       :'default_font',
        'function'      :'function_font',
        'keyword1'      :'keyword1_font',
        'keyword2'      :'keyword2_font',
        'keyword3'      :'keyword3_font',
        'keyword4'      :'keyword4_font',
        'keyword5'      :'keyword5_font',
        'label'         :'label_font',
        'literal1'      :'literal1_font',
        'literal2'      :'literal2_font',
        'literal3'      :'literal3_font',
        'literal4'      :'literal4_font',
        'markup'        :'markup_font',
        # 'nocolor' This tag is used, but never generates code.
        'null'          :'null_font',
        'operator'      :'operator_font',
        'trailing_whitespace' :'trailing_whitespace_font',
    }
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''
    trace = 'coloring' in g.app.debug and not g.unitTesting
        # setTag does most tracing.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    if delegate:
        if trace:
            if len(repr(s[i: j])) &lt;= 20:
                s2 = repr(s[i: j])
            else:
                s2 = repr(s[i: i + 17 - 2] + '...')
            print('--trace-coloring: %25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate, tag)), i, j, s2, g.callers(2)))
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    i += n; break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        # if trace:
            # s2 = repr(s[i: j]) if len(repr(s[i: j])) &lt;= 20 else repr(s[i: i + 17 - 2] + '...')
            # g.trace('%25s %3s %3s %-20s %s' % (
                # ('%s.%s' % (self.language, tag)), i, j, s2, g.callers(2)))
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh': # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18641">last_v = None

def setTag(self, tag, s, i, j):
    '''Set the tag in the highlighter.'''
    trace = 'coloring' in g.app.debug and not g.unitTesting
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper # A QTextEditWrapper
    if not tag.strip():
        return
    tag = tag.lower().strip()
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots'):]
    colorName = wrapper.configDict.get(tag)
        # This color name should already be valid.
    if not colorName:
        return
    #
    # New in Leo 5.8.1: allow symbolic color names here.
    # This now works because all keys in leo_color_database are normalized.
    colorName = colorName.replace(' ', '').replace('-','').replace('_','').lower().strip()
    colorName = leo_color_database.get(colorName, colorName)
    # This is weird, so I'll leave it here.
        # if colorName[-1].isdigit() and colorName[0] != '#':
            # colorName = colorName[: -1]
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name', colorName, g.callers())
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    if trace:
        # A superb trace.
        p = self.c and self.c.p
        if p and p.v != self.last_v:
            print('\n%s\n' % p.h)
            self.last_v = p.v
        if len(repr(s[i: j])) &lt;= 20:
            s2 = repr(s[i: j])
        else:
            s2 = repr(s[i: i + 17 - 2] + '...')
        print('--trace-coloring: %25s %3s %3s %-20s %s' % (
            ('%s.%s' % (self.language, tag)), i, j, s2, g.callers(2)))
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20110930174206.15472">def onFocusIn(self, obj):
    '''Handle a focus-in event in the body pane.'''
    # Update history only in leoframe.tree.select.
    # c.nodeHistory.update(c.p)
    if obj.objectName() == 'richTextEdit':
        wrapper = hasattr(obj, 'leo_wrapper') and obj.leo_wrapper
        if wrapper and wrapper != self.wrapper:
            self.selectEditor(wrapper)
        self.onFocusColorHelper('focus-in', obj)
        if hasattr(obj, 'leo_copy_button') and obj.leo_copy_button:
            obj.setReadOnly(True)
        else:
            obj.setReadOnly(False)
        obj.setFocus() # Weird, but apparently necessary.
</t>
<t tx="ekr.20110930174206.15473">def onFocusOut(self, obj):
    '''Handle a focus-out event in the body pane.'''
    # Apparently benign.
    if obj.objectName() == 'richTextEdit':
        self.onFocusColorHelper('focus-out', obj)
        obj.setReadOnly(True)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    '''Get the vertical scrollbar position.'''
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    '''Set the position of the vertical scrollbar.'''
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20111120124732.10184">def isLogWidget(self, w):
    val = w == self or w in list(self.contentsDict.values())
    return val
</t>
<t tx="ekr.20111122080923.10185">def orderedTabNames(self, LeoLog=None): # Unused: LeoLog
    '''Return a list of tab names in the order in which they appear in the QTabbedWidget.'''
    w = self.tabWidget
    return [w.tabText(i) for i in range(w.count())]
</t>
<t tx="ekr.20120212060348.10374">in_bridge = False
    # Set to True in leoBridge.py just before importing leo.core.leoApp.
    # This tells leoApp to load a null Gui.
pyzo = True
    # It's now safe to enable this permanently,
    # because LM.scanOptions clears it unless --pyzo is in effect.
pyzo_patch = True
    # True: allow patches to pyzo itself.
pyzo_outline_tab = True
    # True: OutlineEditorShim for .leo files.
    # Patches createEditor function in pzyo/core/editor.py
pyzo_trace = False
    # True: enable traces in pyzo itself.
pyzo_trace_imports = True
    # True: enable traces of imports in pyzo itself.
SQLITE = True
    # True: Enable SQLite DB.
</t>
<t tx="ekr.20120215072959.12539">def getShortcut(self, commandName):
    '''Return rawKey,accel for shortcutName'''
    c = self.c
    d = self.shortcutsDict
    if not c.frame.menu:
        if g.pyzo:
            pass
        else:
            g.trace('no menu: %s' % (commandName))
        return None, []
    if d:
        assert g.isTypedDictOfLists(d), d
        key = c.frame.menu.canonicalizeMenuName(commandName)
        key = key.replace('&amp;', '') # Allow '&amp;' in names.
        aList = d.get(commandName, [])
        if aList: # A list of g.BindingIndo objects.
            # It's important to filter empty strokes here.
            aList = [z for z in aList
                if z.stroke and z.stroke.lower() != 'none']
        return key, aList
    else:
        # lm.readGlobalSettingsFiles is opening a settings file.
        # lm.readGlobalSettingsFiles has not yet set lm.globalSettingsDict.
        return None, []
</t>
<t tx="ekr.20120219154958.10487">def doPostPluginsInit(self):
    '''Create a Leo window for each file in the lm.files list.'''
    # Clear g.app.initing _before_ creating commanders.
    lm = self
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    new = True and g.pyzo
    c = c1 = None
    if new:
        pass
    else:
        if lm.files:
            for n, fn in enumerate(lm.files):
                lm.more_cmdline_files = n &lt; len(lm.files) - 1
                c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
                    # Returns None if the file is open in another instance of Leo.
                if not c1: c1 = c
        if g.app.restore_session:
            m = g.app.sessionManager
            if m:
                aList = m.load_snapshot()
                if aList:
                    m.load_session(c1, aList)
                    # tag:#659.
                    if g.app.windowList:
                        c = c1 = g.app.windowList[0].c
                    else:
                        c = c1 = None
    # Enable redraws.
    g.app.disable_redraw = False
    if new:
        c = None
        fileName = None ###
        g.app.log = g.TracingNullObject(tag='g.app.log')
        # Import *all* of the pyzo packages.
        import leo.core.pyzo_shims as pyzo_shims
        pyzo_shims.MainWindowShim()
    else:
        if not c1 or not g.app.windowList:
            c1 = lm.openEmptyWorkBook()
        # Fix bug #199.
        g.app.runAlreadyOpenDialog(c1)
        # Put the focus in the first-opened file.
        fileName = lm.files[0] if lm.files else None
        c = c1
        # For qttabs gui, select the first-loaded tab.
        if hasattr(g.app.gui, 'frameFactory'):
            factory = g.app.gui.frameFactory
            if factory and hasattr(factory, 'setTabForCommander'):
                factory.setTabForCommander(c)
        if not c:
            return False # Force an immediate exit.
    # Fix bug 844953: tell Unity which menu to use.
        # if c: c.enableMenuBar()
    # Do the final inits.
    g.app.logInited = True
    g.app.initComplete = True
    if c:
        c.setLog()
        c.redraw()
    p = c.p if c else None
    g.doHook("start2", c=c, p=p, fileName=fileName)
    if c:
        c.initialFocusHelper()
    screenshot_fn = lm.options.get('screenshot_fn')
    if screenshot_fn:
        lm.make_screen_shot(screenshot_fn)
        return False # Force an immediate exit.
    else:
        return True
</t>
<t tx="ekr.20120219154958.10489">def make_screen_shot(self, fn):
    '''Create a screenshot of the present Leo outline and save it to path.'''
    if g.app.gui.guiName() == 'qt':
        m = g.loadOnePlugin('screenshots')
        m.make_screen_shot(fn)
</t>
<t tx="ekr.20120304214900.9940">def onCurrentChanged(self, idx):

    tabw = self.tabWidget
    w = tabw.widget(idx)
    # Fixes bug 917814: Switching Log Pane tabs is done incompletely
    wrapper = hasattr(w, 'leo_log_wrapper') and w.leo_log_wrapper
    if wrapper:
        self.logCtrl = wrapper
</t>
<t tx="ekr.20120409185504.10028"># Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    s = s[: i]
    if s != oldHead:
        g.warning("truncating headline to one line")
limit = 1000
if len(s) &gt; limit:
    s = s[: limit]
    if s != oldHead:
        g.warning("truncating headline to", limit, "characters")
</t>
<t tx="ekr.20120913110135.10613"></t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    '''Handle a Qt onSliderChanged event.'''
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20130804061744.12425">if 0: # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
</t>
<t tx="ekr.20130921043420.21175"># w's type is in (DynamicWindow,QMinibufferWrapper,LeoQtLog,LeoQtTree,
# QTextEditWrapper,LeoQTextBrowser,LeoQuickSearchWidget,cleoQtUI)

def setFilter(self, c, obj, w, tag):
    '''
    Create an event filter in obj.
    w is a wrapper object, not necessarily a QWidget.
    '''
    # gui = self
    if g.pyzo:
        return
    assert isinstance(obj, QtWidgets.QWidget), obj
    theFilter = qt_events.LeoQtEventFilter(c, w=w, tag=tag)
    obj.installEventFilter(theFilter)
    w.ev_filter = theFilter
        # Set the official ivar in w.
</t>
<t tx="ekr.20130930062914.16000">def runMainLoop(self):
    '''Start the Qt main loop.'''
    if g.pyzo:
        g.trace('START MAIN LOOP')
    g.app.gui.dismiss_splash_screen()
    g.app.gui.show_tips()
    if self.script:
        log = g.app.log
        if log:
            g.pr('Start of batch script...\n')
            log.c.executeScript(script=self.script)
            g.pr('End of batch script')
        else:
            g.pr('no log, no commander for executeScript in LeoQtGui.runMainLoop')
    elif g.app.useIpython and g.app.ipython_inited:
        self.runWithIpythonKernel()
    else:
        # This can be alarming when using Python's -i option.
        sys.exit(self.qtApp.exec_())
</t>
<t tx="ekr.20131028155339.17098">def openEmptyWorkBook(self):
    '''Open an empty frame and paste the contents of CheatSheet.leo into it.'''
    lm = self
    # Create an empty frame.
    fn = lm.computeWorkbookFileName()
    c = lm.loadLocalFile(fn, gui=g.app.gui, old_c=None)
    # Open the cheatsheet, but not in batch mode.
    if not g.app.batchMode and not g.os_path_exists(fn):
        # #933: Save clipboard.
        old_clipboard = g.app.gui.getTextFromClipboard()
        # Paste the contents of CheetSheet.leo into c.
        c2 = c.openCheatSheet(redraw=False)
        if c2:
            for p2 in c2.rootPosition().self_and_siblings():
                c2.selectPosition(p2)
                c2.copyOutline()
                p = c.pasteOutline()
                c.selectPosition(p)
                p.contract()
                p.clearDirty()
            c2.close(new_c=c)
            root = c.rootPosition()
            if root.h == g.shortFileName(fn):
                root.doDelete(newNode=root.next())
            p = g.findNodeAnywhere(c, "Leo's cheat sheet")
            if p:
                c.selectPosition(p)
                p.expand()
            c.target_language = 'rest'
                # Settings not parsed the first time.
            c.setChanged(False)
            c.redraw()
        # #933: Restore clipboard
        g.app.gui.replaceClipboardWith(old_clipboard)
    return c
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131118152731.16847">def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
</t>
<t tx="ekr.20131118152731.16848">def create_find_findbox(self, grid, parent, row):
    '''Create the Find: label and text area.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
</t>
<t tx="ekr.20131118152731.16849">def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
</t>
<t tx="ekr.20131118152731.16850">def create_find_replacebox(self, grid, parent, row):
    '''Create the Replace: label and text area.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:') # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
</t>
<t tx="ekr.20131118152731.16851">def create_find_checkboxes(self, grid, parent, max_row2, row):
    '''Create check boxes and radio buttons.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&amp;', '').lower()
        return '%s%s' % (kind, name)
    # Rows for check boxes, radio buttons &amp; execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &amp;Word', 0, 0),
        ('rb', '&amp;Entire outline', 0, 1),
        # Second row.
        ('box', '&amp;Ignore case', 1, 0),
        ('rb', '&amp;Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &amp;Around', 2, 0),
        ('rb', '&amp;Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&amp;Xp', 3, 0),
        ('box', 'search &amp;Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &amp;Finds', 4, 0),
        ('box', 'search &amp;Body', 4, 1),
        # Sixth row.
        ('box', 'mark &amp;Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&amp;', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
</t>
<t tx="ekr.20131118152731.16852">def create_find_buttons(self, grid, parent, max_row2, row):
    c, dw = self.leo_c, self
    k = c.k
    ftm = c.findCommands.ftm

    def mungeName(label):
        kind = 'push-button'
        name = label.replace(' ', '').replace('&amp;', '')
        return '%s%s' % (kind, name)
    # Create Buttons in column 2 (Leo 4.11.1.)

    table = (
        (0, 2, 'findButton', 'Find Next', 'find-next'),
        (1, 2, 'findPreviousButton', 'Find Previous', 'find-prev'),
        (2, 2, 'findAllButton', 'Find All', 'find-all'),
        (3, 2, 'changeButton', 'Replace', 'replace'),
        (4, 2, 'changeThenFindButton', 'Replace Then Find', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'Replace All', 'replace-all'),
        # (6,2,'helpForFindCommands','Help','help-for-find-commands'),
    )
    # findTabHandler does not exist yet.
    for row2, col, func_name, label, cmd_name in table:

        def find_tab_button_callback(event, c=c, func_name=func_name):
            # h will exist when the Find Tab is open.
            fc = c.findCommands
            func = getattr(fc, func_name, None)
            if func: func()
            else:
                g.trace('* does not exist:', func_name)

        name = mungeName(label)
        # Prepend the shortcut if it exists:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = '%s:  %s' % (label, k.prettyPrintKey(stroke))
        if 1: # Not bad.
            w = dw.createButton(parent, name, label)
            grid.addWidget(w, row + row2, col)
        else:
            # grid.addLayout(layout,row+row2,col)
            # layout = dw.createHLayout(frame,name='button_layout',margin=0,spacing=0)
            # frame.setLayout(layout)
            frame = dw.createFrame(parent, name='button:%s' % label)
            w = dw.createButton(frame, name, label)
            grid.addWidget(frame, row + row2, col)
        # Connect the button with the command.
        w.clicked.connect(find_tab_button_callback)
        # Set the ivar.
        ivar = '%s-%s' % (cmd_name, 'button')
        ivar = ivar.replace('-', '_')
        assert getattr(ftm, ivar) is None
        setattr(ftm, ivar, w)
    row += max_row2
    row += 2
    return row
</t>
<t tx="ekr.20131118152731.16853">def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: &lt;alt-x&gt;help-for-find-commands&lt;return&gt;')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
</t>
<t tx="ekr.20131118172620.16858">def finishCreateLogPane(self):
    '''It's useful to create this late, because c.config is now valid.'''
    # self.findTab exists even if there is not Find tab in the Log pane.
    if g.pyzo:
        return
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
</t>
<t tx="ekr.20131118172620.16891">def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)
    table = (
        ('findNextCommand', 'find-next'),
        ('findPrevCommand', 'find-prev'),
        ('findAll', 'find-all'),
        ('changeCommand', 'replace'),
        ('changeThenFind', 'replace-then-find'),
        ('changeAll', 'replace-all'),
    )
    for func_name, cmd_name in table:
        ivar = '%s-%s' % (cmd_name, 'button')
        ivar = ivar.replace('-', '_')
        w = getattr(ftm, ivar, None)
        func = getattr(fc, func_name, None)
        if w and func:
            next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
            EventWrapper(c, w=w, next_w=next_w, func=func)
        else:
            g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
</t>
<t tx="ekr.20131118172620.16892">class EventWrapper(object):
    
    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper

    @others
</t>
<t tx="ekr.20131118172620.16893">def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    elif type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16894">def keyPress(self, event):

    s = event.text()
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if  binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16895">def keyRelease(self, event):
    return self.oldEvent(event)
</t>
<t tx="ekr.20131120054058.16281">def create_d(self):
    '''Create self.d dictionary.'''
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131224085853.16443">def findReference(self, name, p):
    '''Find a reference to name.  Raise an error if not found.'''
    at = self
    ref = g.findReference(name, p)
    if not ref and not hasattr(at, 'allow_undefined_refs'):
        # Do give this error even if unit testing.
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" % (
                g.truncate(name, 60), g.truncate(p.h, 60)))
    return ref
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    '''Return True if the indicated setting comes from a local .leo file.'''
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert g.isGeneralSetting(gs), gs
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140727075002.18108">def saveOutlineIfPossible(self):
    '''Save the outline if only persistence data nodes are dirty.'''
    c = self.c
    changed_positions = [p for p in c.all_unique_positions() if p.v.isDirty()]
    at_persistence = c.persistenceController and c.persistenceController.has_at_persistence_node()
    if at_persistence:
        changed_positions = [p for p in changed_positions
            if not at_persistence.isAncestorOf(p)]
    if not changed_positions:
        # g.warning('auto-saving @persistence tree.')
        c.setChanged(False)
        c.redraw()
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140815160132.18835">def createCommandNames(self):
    '''
    Create all entries in c.commandsDict.
    Do *not* clear c.commandsDict here.
    '''
    for commandName, func in g.global_commands_dict.items():
        self.k.registerCommand(commandName, func)
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140901062324.18562">def reloadSettings(self):
    c = self.c
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.use_chapters = c.config.getBool('use-chapters')
    self.use_gutter = c.config.getBool('use-gutter', default=False)
</t>
<t tx="ekr.20140901062324.18563">def set_widget(self):
    '''Set the actual gui widget.'''
    c = self.c
    if g.pyzo:
        pass
    else:
        top = c.frame.top
        sw = top.leo_ui.stackedWidget
        sw.setCurrentIndex(1)
    if self.useScintilla and not Qsci:
        g.trace('Can not import Qsci: ignoring @bool qt-use-scintilla')
    if self.useScintilla and Qsci:
        self.widget = c.frame.top.scintilla_widget
            # A Qsci.QsciSintilla object.
            # dw.createText sets self.scintilla_widget
        self.wrapper = qt_text.QScintillaWrapper(self.widget, name='body', c=c)
        self.colorizer = leoColorizer.QScintillaColorizer(c, self.widget, self.wrapper)
    else:
        if g.pyzo:
            self.widget = qt_text.LeoQTextBrowser(c.frame, c, None)
        else:
            self.widget = top.leo_ui.richTextEdit # A LeoQTextBrowser
        self.wrapper = qt_text.QTextEditWrapper(self.widget, name='body', c=c)
        self.widget.setAcceptRichText(False)
        self.colorizer = leoColorizer.JEditColorizer(c, self.widget, self.wrapper)
</t>
<t tx="ekr.20140902032918.18591">@
@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.
@c
</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140907201613.18986">def repaint(self):
    '''Repaint the widget.'''
    w = self.treeWidget
    w.repaint()
    w.resizeColumnToContents(0) # 2009/12/22
</t>
<t tx="ekr.20140915062551.19519">def set_icon_bar_orientation(self, c):
    '''Set the orientation of the icon bar based on settings.'''
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    '''Return the presently selected item's text.'''
    return self.currentItem().text()
</t>
<t tx="ekr.20141031053508.14">def goto_command(self, controller, gnx):
    '''
    Select the node corresponding to the given gnx.
    controller is a ScriptingController instance.
    '''
    # Fix bug 74: command_p may be in another outline.
    c = self.c
    c2, p = controller.open_gnx(c, gnx)
    if p:
        assert c2.positionExists(p)
        if c == c2:
            c2.selectPosition(p)
        else:
            # Fix #367: complete the selection at idle time.
            g.app.selectLeoWindow(c2)

            def handler(timer, c=c2, p=p):
                c2.selectPosition(p)
                timer.stop()

            timer = g.IdleTime(handler, delay=0, tag='goto-script-button')
            if timer: timer.start()
    else:
        g.trace('not found', gnx)
</t>
<t tx="ekr.20141031053508.15">def add_rclick_menu(self, action_container, rclicks, controller,
    top_level=True,
    button=None,
    script=None
):
    c = controller.c
    top_offset = -2 # insert before the remove button and goto script items
    if top_level:
        button = action_container
    for rc in rclicks:
        # pylint: disable=cell-var-from-loop
        headline = rc.position.h[8:].strip()
        act = QtWidgets.QAction(headline, action_container)
        if '---' in headline and headline.strip().strip('-') == '':
            act.setSeparator(True)
        elif rc.position.b.strip():

            def cb(checked, p=rc.position, button=button):
                controller.executeScriptFromButton(
                    b=button,
                    buttonText=p.h[8:].strip(),
                    p=p,
                    script=script,
                )
                if c.exists:
                    c.outerUpdate()

            act.triggered.connect(cb)
        else: # recurse submenu
            sub_menu = QtWidgets.QMenu(action_container)
            act.setMenu(sub_menu)
            self.add_rclick_menu(sub_menu, rc.children, controller,
                top_level=False, button=button)
        if top_level:
            # insert act before Remove Button
            action_container.insertAction(
                action_container.actions()[top_offset], act)
        else:
            action_container.addAction(act)
    if top_level and rclicks:
        act = QtWidgets.QAction('---', action_container)
        act.setSeparator(True)
        action_container.insertAction(
            action_container.actions()[top_offset], act)
        action_container.setText(
            action_container.text() +
            (c.config.getString('mod-scripting-subtext') or '')
        )
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    '''Get the horizontal scrollbar position.'''
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    '''Set the position of the horizontal scrollbar.'''
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20150205181818.5">def scrollToEnd(self, tabName='Log'):
    '''Scroll the log to the end.'''
    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    w = self.logCtrl.widget
    if w:
        sb = w.horizontalScrollBar()
        pos = sb.sliderPosition()
        w.moveCursor(QtGui.QTextCursor.End)
        sb.setSliderPosition(pos)
        w.repaint() # Slow, but essential.
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    '''Handle the 'delete' opcode.'''
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    '''Handle the 'equal' opcode.'''
    x = self
    assert aj - ai == bj - bi and x.a[ai: aj] == x.b[bi: bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    '''Handle the 'insert' opcode.'''
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    '''Handle the 'replace' opcode.'''
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi: bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    '''Report an unexpected opcode.'''
    x = self
    x.error('unknown SequenceMatcher opcode: %s' % repr(tag))
</t>
<t tx="ekr.20150207044400.9">'''
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
'''
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    '''Dump the given lines.'''
    print('\n%s...\n' % title)
    for i, line in enumerate(lines):
        g.pr('%4s %s' % (i, repr(line)))
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    '''Dump the argument lines.'''
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    '''
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    '''
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    '''Put a plain line to x.results, inserting verbatim lines if necessary.'''
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print('put %s' % repr(x.verbatim_line))
    x.results.append(line)
    if x.trace: print('put %s' % repr(line))
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    '''
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    '''
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    '''Put all the sentinels to the results'''
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace('%3s %s' % (i, sentinels))
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
import leo.core.leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()
</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    '''Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule'''
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)
</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    '''Create an entry in d for a string keyword.'''
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False) # Don't require ending word.

    return forth_string_word_rule
</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList
</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule20(colorer, s, i):
        return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.
properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {} # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}
</t>
<t tx="ekr.20150326145530.4">class extendForth(object):
    '''A helper class to extend the mode tables from @data forth-x settings.'''
    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = [] # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    '''Set our ivars from settings.'''
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for(ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for(ivar, setting) in table2:
        self.splitList(ivar, setting)
</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    '''Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2.'''
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)
</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True) # Require word.

    return forth_bracket_rule
</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2", # defining word
            word=word,
            kind2="keyword3", # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule
</t>
<t tx="ekr.20150330033306.1">on_idle_count = 0

def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    if not g.app or g.app.killed:
        return
    self.on_idle_count += 1
    # New in Leo 5.7: always handle delayed requests.
    if g.app.windowList:
        c = g.app.log and g.app.log.c
        if c:
            c.outerUpdate()
    if 1:
        # Fix #262: Improve performance when @bool check-for-changed-external-files is True.
        if self.unchecked_files:
            # Check all external files.
            for ef in self.unchecked_files:
                self.idle_check_open_with_file(ef)
            self.unchecked_files = []
        elif self.unchecked_commanders:
            # Check the next commander for which
            # @bool check_for_changed_external_file is True.
            c = self.unchecked_commanders.pop()
            self.idle_check_commander(c)
        else:
            # Add all commanders for which
            # @bool check_for_changed_external_file is True.
            self.unchecked_commanders = [
                z for z in g.app.commanders() if self.is_enabled(z)
            ]
            self.unchecked_files = [z for z in self.files if z.exists()]
    else:
        # First, check all existing open-with files.
        for ef in self.files: # A list of ExternalFile instances.
            if ef.exists():
                self.idle_check_open_with_file(ef)
        # Next, check all commanders for which
        # @bool check_for_changed_external_file is True.
        for c in g.app.commanders():
            if self.is_enabled(c):
                self.idle_check_commander(c)
</t>
<t tx="ekr.20150403044823.1">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    trace = False
        # Matt, set this to True, but only for the file that interests you.\
        # trace = p.h == '@file unregister-leo.leox'
    path = g.fullPath(c, p)
    has_changed = self.has_changed(c, path)
    if trace:
        g.trace('changed', has_changed, p.h)
    if has_changed:
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            c.redraw(p=p)
            c.refreshFromDisk(p)
            c.redraw()
        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)
</t>
<t tx="ekr.20150403045207.1">def has_changed(self, c, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not g.os_path_exists(path):
        return False
    if g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    else:
        # The file has really changed.
        assert old_time, path
        if 0: # Fix bug 208: external change overwrite protection only works once
            # https://github.com/leo-editor/leo-editor/issues/208
            # These next two lines mean that if the Leo version
            # is changed (dirtied) again, overwrite will occur without warning.
            self.set_time(path, new_time)
            self.checksum_d[path] = new_sum
        return True
</t>
<t tx="ekr.20150403094619.1">class LeoLineTextWidget(QtWidgets.QFrame):
    '''
    A QFrame supporting gutter line numbers.
    
    This class *has* a QTextEdit.
    '''
    @others
</t>
<t tx="ekr.20150403094706.10">def eventFilter(self, obj, event):
    '''
    Update the line numbers for all events on the text edit and the viewport.
    This is easier than connecting all necessary signals.
    '''
    if obj in (self.edit, self.edit.viewport()):
        self.number_bar.update()
        return False
    else:
        return QtWidgets.QFrame.eventFilter(obj, event)
</t>
<t tx="ekr.20150403094706.2">class NumberBar(QtWidgets.QFrame):
    @others
</t>
<t tx="ekr.20150403094706.3">def __init__(self, c, e, *args):
    '''Ctor for NumberBar class.'''
    QtWidgets.QFrame.__init__(self, *args)
        # Init the base class.
    self.c = c
    self.edit = e
        # A QTextEdit.
    self.d = e.document()
        # A QTextDocument.
    self.fm = self.fontMetrics()
        # A QFontMetrics
    self.image = QtGui.QImage(g.app.gui.getImageImage(
        g.os_path_finalize_join(g.app.loadDir,
            '..', 'Icons', 'Tango','16x16', 'actions', 'stop.png')))
    self.highest_line = 0
        # The highest line that is currently visibile.
    # Set the name to gutter so that the QFrame#gutter style sheet applies.
    self.offsets = []
    self.setObjectName('gutter')
    self.reloadSettings()
</t>
<t tx="ekr.20150403094706.5">def update(self, *args):
    '''
    Updates the number bar to display the current set of numbers.
    Also, adjusts the width of the number bar if necessary.
    '''
    # w_adjust is used to compensate for the current line being bold.
    # Always allocate room for 2 columns
    width = self.fm.width(str(max(1000, self.highest_line))) + self.w_adjust
    if self.width() != width:
        self.setFixedWidth(width)
    QtWidgets.QWidget.update(self, *args)
</t>
<t tx="ekr.20150403094706.6">def paintEvent(self, event):
    '''
    Enhance QFrame.paintEvent.
    Paint all visible text blocks in the editor's document.
    '''
    e = self.edit
    d = self.d
    layout = d.documentLayout()
    # Compute constants.
    current_block = d.findBlock(e.textCursor().position())
    scroll_y = e.verticalScrollBar().value()
    page_bottom = scroll_y + e.viewport().height()
    # Paint each visible block.
    painter = QtGui.QPainter(self)
    block = d.begin()
    n = i = 0
    c = self.c
    translation = c.user_dict.get('line_number_translation', [])
    self.offsets = []
    while block.isValid():
        i = translation[n] if n &lt; len(translation) else n + 1
        n += 1
        top_left = layout.blockBoundingRect(block).topLeft()
        if top_left.y() &gt; page_bottom:
            break # Outside the visible area.
        bold = block == current_block
        self.paintBlock(bold, i, painter, top_left, scroll_y)
        block = block.next()
    self.highest_line = i
    painter.end()
    QtWidgets.QWidget.paintEvent(self, event)
        # Propagate the event.
</t>
<t tx="ekr.20150403094706.7">def paintBlock(self, bold, n, painter, top_left, scroll_y):
    '''Paint n, right justified in the line number field.'''
    c = self.c
    if bold:
        self.setBold(painter, True)
    s = str(n)
    pad = max(4, len(str(self.highest_line))) - len(s)
    s = ' '*pad + s
    # x = self.width() - self.fm.width(s) - self.w_adjust
    x = 0
    y = round(top_left.y()) - scroll_y + self.fm.ascent() + self.y_adjust
    self.offsets.append((n, y),)
    painter.drawText(x, y, s)
    if bold:
        self.setBold(painter, False)
    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    if not xdb.has_breakpoints():
        return
    path = g.fullPath(c, c.p)
    if xdb.has_breakpoint(path, n):
        target_r = QtCore.QRect(
            self.fm.width(s) + 16,
            top_left.y() + self.y_adjust - 2,
            16.0, 16.0)
        if self.image:
            source_r = QtCore.QRect(0.0, 0.0, 16.0, 16.0)
            painter.drawImage(target_r, self.image, source_r)
        else:
            painter.drawEllipse(target_r)
</t>
<t tx="ekr.20150403094706.8">def setBold(self, painter, flag):
    '''Set or clear bold facing in the painter, depending on flag.'''
    font = painter.font()
    font.setBold(flag)
    painter.setFont(font)
</t>
<t tx="ekr.20150403094706.9">def __init__(self, c, e, *args):
    '''Ctor for LineTextWidget.'''
    QtWidgets.QFrame.__init__(self, *args)
        # Init the base class.
    self.c = c
    self.setFrameStyle(self.StyledPanel | self.Sunken)
    self.edit = e # A QTextEdit
    e.setFrameStyle(self.NoFrame)
    # e.setAcceptRichText(False)
    self.number_bar = NumberBar(c, e)
    hbox = QtWidgets.QHBoxLayout(self)
    hbox.setSpacing(0)
    hbox.setContentsMargins(0, 0, 0, 0)
    hbox.addWidget(self.number_bar)
    hbox.addWidget(e)
    e.installEventFilter(self)
    e.viewport().installEventFilter(self)
</t>
<t tx="ekr.20150404045115.1">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    p = c.rootPosition()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtCleanNode():
            # Fix #1074: nested @clean nodes.
            seen.add(p.v)
            self.idle_check_at_file_node(c, p)
            p.moveToThreadNext()
        elif p.isAnyAtFileNode():
            seen.add(p.v)
            self.idle_check_at_file_node(c, p)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20150404052819.1">def checksum(self, path):
    '''Return the checksum of the file at the given path.'''
    import hashlib
    return hashlib.md5(open(path, 'rb').read()).hexdigest()
</t>
<t tx="ekr.20150404082344.1">def open_with(self, c, d):
    '''
    Called by c.openWith to handle items in the Open With... menu.

    'd' a dict created from an @openwith settings node with these keys:

        'args':     the command-line arguments to be used to open the file.
        'ext':      the file extension.
        'kind':     the method used to open the file, such as subprocess.Popen.
        'name':     menu label (used only by the menu code).
        'p':        the nearest @&lt;file&gt; node, or None.
        'shortcut': menu shortcut (used only by the menu code).
    '''
    try:
        ext = d.get('ext')
        if not g.doHook('openwith1', c=c, p=c.p, v=c.p.v, d=d):
            root = d.get('p')
            if root:
                # Open the external file itself.
                directory = g.setDefaultDirectory(c, root)
                path = c.os_path_finalize_join(directory, root.anyAtFileNodeName())
                self.open_file_in_external_editor(c, d, path)
            else:
                # Open a temp file containing just the node.
                p = c.p
                ext = self.compute_ext(c, p, ext)
                path = self.compute_temp_file_path(c, p, ext)
                if path:
                    self.remove_temp_file(p, path)
                    self.create_temp_file(c, ext, p)
                    self.open_file_in_external_editor(c, d, path)
        g.doHook('openwith2', c=c, p=c.p, v=c.p.v, d=d)
    except Exception:
        g.es('unexpected exception in c.openWith')
        g.es_exception()
</t>
<t tx="ekr.20150404083049.1">def join(self, s1, s2):
    '''Return s1 + ' ' + s2'''
    return '%s %s' % (s1, s2)
</t>
<t tx="ekr.20150404083533.1">def __init__(self, c=None):
    '''Ctor for ExternalFiles class.'''
    self.checksum_d = {}
        # Keys are full paths, values are file checksums.
    self.enabled_d = {}
        # For efc.on_idle.
        # Keys are commanders.
        # Values are cached @bool check-for-changed-external-file settings.
    self.files = []
        # List of ExternalFile instances created by self.open_with.
    self.has_changed_d = {}
        # Keys are commanders. Values are bools.
        # Used only to limit traces.
    self.unchecked_commanders = []
        # Copy of g.app.commanders()
    self.unchecked_files = []
        # Copy of self file. Only one files is checked at idle time.
    self._time_d = {}
        # Keys are full paths, values are modification times.
        # DO NOT alter directly, use set_time(path) and
        # get_time(path), see set_time() for notes.
    self.yesno_all_time = 0  # previous yes/no to all answer, time of answer
    self.yesno_all_answer = None  # answer, 'yes-all', or 'no-all'
    g.app.idleTimeManager.add_callback(self.on_idle)
</t>
<t tx="ekr.20150404092538.1">def shut_down(self):
    '''
    Destroy all temporary open-with files.
    This may fail if the files are still open.

    Called by g.app.finishQuit.
    '''
    # Dont call g.es or g.trace! The log stream no longer exists.
    for ef in self.files[:]:
        self.destroy_temp_file(ef)
    self.files = []
</t>
<t tx="ekr.20150405073203.1">class ExternalFilesController(object):
    '''
    A class tracking changes to external files:

    - temp files created by open-with commands.
    - external files corresponding to @file nodes.

    This class raises a dialog when a file changes outside of Leo.

    **Naming conventions**:

    - d is always a dict created by the @open-with logic.
      This dict describes *only* how to open the file.

    - ef is always an ExternalFiles instance.
    '''
    @others
</t>
<t tx="ekr.20150405104340.1">def is_enabled(self, c):
    '''Return the cached @bool check_for_changed_external_file setting.'''
    d = self.enabled_d
    val = d.get(c)
    if val is None:
        val = c.config.getBool('check-for-changed-external-files', default=False)
        d[c] = val
    return val
</t>
<t tx="ekr.20150405105938.1"></t>
<t tx="ekr.20150405110219.1"># pylint: disable=no-value-for-parameter
</t>
<t tx="ekr.20150405122428.1">def get_time(self, path):
    '''
    return timestamp for path

    see set_time() for notes
    '''
    return self._time_d.get(g.os_path_realpath(path))
</t>
<t tx="ekr.20150405194745.1">def check_overwrite(self, c, path):
    '''
    Implements c.checkTimeStamp.

    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''
    if c.sqlite_connection and c.mFileName == path:
        # sqlite database file is never actually overwriten by Leo
        # so no need to check its timestamp. It is modified through
        # sqlite methods.
        return True
    if self.has_changed(c, path):
        return self.ask(c, path)
    else:
        return True
</t>
<t tx="ekr.20150405200212.1">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    if g.unitTesting:
        return False
    if c not in g.app.commanders():
        return False
    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        return bool('yes' in self.yesno_all_answer.lower())
    if not p:
        for ef in self.files:
            if ef.path == path:
                where = ef.p.h
                break
        else:
            where = 'the outline node'
    else:
        where = p.h
    _is_leo = path.endswith(('.leo', '.db'))
    if _is_leo:
        s = '\n'.join([
            '%s has changed outside Leo.' %(g.splitLongFileName(path)),
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            '%s has changed outside Leo.' % (g.splitLongFileName(path)),
            'Reload %s in Leo?' % (where),
        ])
    result = g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
        yes_all=not _is_leo, no_all=not _is_leo)
    if result and "-all" in result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = result.lower()
    return bool(result and 'yes' in result.lower())
        # Careful: may be unit testing.
</t>
<t tx="ekr.20150406055221.2">def clean_file_name(self, c, ext, p):
    '''Compute the file name when subdirectories mirror the node's hierarchy in Leo.'''
    use_extentions = c.config.getBool('open-with-uses-derived-file-extensions')
    ancestors, found = [], False
    for p2 in p.self_and_parents(copy=False):
        h = p2.anyAtFileNodeName()
        if not h:
            h = p2.h # Not an @file node: use the entire header
        elif use_extentions and not found:
            # Found the nearest ancestor @&lt;file&gt; node.
            found = True
            base, ext2 = g.os_path_splitext(h)
            if p2 == p: h = base
            if ext2: ext = ext2
        ancestors.append(g.sanitize_filename(h))
    # The base directory is &lt;tempdir&gt;/Leo&lt;id(v)&gt;.
    ancestors.append("Leo" + str(id(p.v)))
    # Build temporary directories.
    td = os.path.abspath(tempfile.gettempdir())
    while len(ancestors) &gt; 1:
        td = os.path.join(td, ancestors.pop())
        if not os.path.exists(td):
            os.mkdir(td)
    # Compute the full path.
    name = ancestors.pop() + ext
    path = os.path.join(td, name)
    return path
</t>
<t tx="ekr.20150406055221.3">def legacy_file_name(self, c, ext, p):
    '''Compute a legacy file name for unsupported operating systems.'''
    try:
        leoTempDir = getpass.getuser() + "_" + "Leo"
    except Exception:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es("Temporary files will be stored in: %s" % leoTempDir)
    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)
    name = g.sanitize_filename(p.h) + '_' + str(id(p.v)) + ext
    path = os.path.join(td, name)
    return path
</t>
<t tx="ekr.20150407124259.1">def idle_check_open_with_file(self, ef):
    '''Update the open-with node given by ef.'''
    assert isinstance(ef, ExternalFile), ef
    if ef.path and os.path.exists(ef.path):
        time = self.get_mtime(ef.path)
        if time and time != ef.time:
            ef.time = time # inhibit endless dialog loop.
            self.update_open_with_node(ef)
</t>
<t tx="ekr.20150407141838.1">def find_path_for_node(self, p):
    '''
    Find the path corresponding to node p.
    called from vim.py.
    '''
    for ef in self.files:
        if ef.p and ef.p.v == p.v:
            path = ef.path
            break
    else:
        path = None
    return path
</t>
<t tx="ekr.20150407204201.1">def get_mtime(self, path):
    '''Return the modification time for the path.'''
    return g.os_path_getmtime(g.os_path_realpath(path))
</t>
<t tx="ekr.20150407205631.1">def update_open_with_node(self, ef):
    '''Update the body text of ef.p to the contents of ef.path.'''
    assert isinstance(ef, ExternalFile), ef
    c, p = ef.c, ef.p.copy()
    # Ask the user how to resolve the conflict.
    if self.ask(c, ef.path, p=p):
        g.blue('updated %s' % p.h)
        s, e = g.readFileIntoString(ef.path)
        p.b = s
        if c.config.getBool('open-with-goto-node-on-update'):
            c.selectPosition(p)
        if c.config.getBool('open-with-save-on-update'):
            c.save()
        else:
            p.setDirty()
            c.setChanged(True)
</t>
<t tx="ekr.20150413091056.1">'''Warn if leoProjects.txt or leoToDo.txt contain any clones.'''

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    '''Warn if p appears in any @&lt;file&gt; node outside of root's tree.'''
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425145248.1">run-pylint
clone-to-at-spot
beautify-tree
cfa-code
sort-lines
# show-data
# test-ptb
check-clones
expand-log-pane
contract-log-pane</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators(object):
    '''
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    '''
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    '''Return munged lines of '''
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    '''Top-level code.'''
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    '''Create decorators for all items in d in root's tree.'''
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    if trace:
        g.trace('\n', publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    '''Return the position of the class enclosing p.'''
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    '''
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    '''
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509040227.1">def cmd(name):
    '''Command decorator for the LeoQtFrame class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame',])
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators(object):
    '''
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    '''
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    '''Create decorators for all items in d in root's tree.'''
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %s' % (f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    '''Return munged lines of s. '''
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    '''Top-level code.'''
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150509183832.1"># 'check-all-python-code':      c.checkAllPythonCode,
# 'check-python-code':          c.checkPythonCode,
# 'extract-python-method':        c.extractPythonMethod,
# 'extract-section':              c.extractSection,
# 'import-at-file':               c.importAtFile,
# 'import-at-root':               c.importAtRoot,
# 'import-cweb-files':            c.importCWEBFiles,
# 'import-derived-file':          c.importDerivedFile,
# 'import-flattened-outline':     c.importFlattenedOutline,
# 'import-noweb-files':           c.importNowebFiles,
# 'mark-changed-roots':           c.markChangedRoots,
# 'mark-clones':                c.markClones,
# 'open-compare-window':        c.openCompareWindow,
# 'open-online-tutorial':       c.leoTutorial,
# 'reformat-body':              c.reformatBody, # 2013/10/02.
def define_s(self):
    return '''
'abort-edit-headline':          f.abortEditLabelCommand,
'about-leo':                    c.about,
'add-comments':                 c.addComments,     
'beautify':                     c.beautifyPythonCode,
'beautify-all':                 c.beautifyAllPythonCode,
'beautify-c':                   c.beautifyCCode,
'beautify-tree':                c.beautifyPythonTree,
'cascade-windows':              f.cascade,
'check-derived-file':           c.atFileCommands.checkDerivedFile,
'check-leo-file':               c.fileCommands.checkLeoFile,
'check-outline':                c.fullCheckOutline,
'clean-recent-files':           c.cleanRecentFiles,
'clear-recent-files':           c.clearRecentFiles,
'clone-node':                   c.clone,
'clone-node-to-last-node':      c.cloneToLastNode,
'close-window':                 c.close,
'contract-all':                 c.contractAllHeadlines,
'contract-all-other-nodes':     c.contractAllOtherNodes,
'contract-node':                c.contractNode,
'contract-or-go-left':          c.contractNodeOrGoToParent,
'contract-parent':              c.contractParent,
'convert-all-blanks':           c.convertAllBlanks,
'convert-all-tabs':             c.convertAllTabs,
'convert-blanks':               c.convertBlanks,
'convert-tabs':                 c.convertTabs,
'copy-node':                    c.copyOutline,
'copy-text':                    f.copyText,
'cut-node':                     c.cutOutline,
'cut-text':                     f.cutText,
'de-hoist':                     c.dehoist,
'delete-comments':              c.deleteComments,
'delete-node':                  c.deleteOutline,
'demote':                       c.demote,
'dump-outline':                 c.dumpOutline,
'edit-headline':                c.editHeadline,
'end-edit-headline':            f.endEditLabelCommand,
'equal-sized-panes':            f.equalSizedPanes,
'execute-script':               c.executeScript,
'exit-leo':                     g.app.onQuit,
'expand-all':                   c.expandAllHeadlines,
'expand-all-subheads':          c.expandAllSubheads,
'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
'expand-next-level':            c.expandNextLevel,
'expand-node':                  c.expandNode,
'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
'expand-prev-level':            c.expandPrevLevel,
'expand-to-level-1':            c.expandLevel1,
'expand-to-level-2':            c.expandLevel2,
'expand-to-level-3':            c.expandLevel3,
'expand-to-level-4':            c.expandLevel4,
'expand-to-level-5':            c.expandLevel5,
'expand-to-level-6':            c.expandLevel6,
'expand-to-level-7':            c.expandLevel7,
'expand-to-level-8':            c.expandLevel8,
'expand-to-level-9':            c.expandLevel9,
'export-headlines':             c.exportHeadlines,
'extract':                      c.extract,
'extract-names':                c.extractSectionNames,
'find-next-clone':              c.findNextClone,
'flatten-outline':              c.flattenOutline,
'flatten-outline-to-node':      c.flattenOutlineToNode,
'go-back':                      c.goPrevVisitedNode,
'go-forward':                   c.goNextVisitedNode,
'goto-first-node':              c.goToFirstNode,
'goto-first-sibling':           c.goToFirstSibling,
'goto-first-visible-node':      c.goToFirstVisibleNode,
'goto-last-node':               c.goToLastNode,
'goto-last-sibling':            c.goToLastSibling,
'goto-last-visible-node':       c.goToLastVisibleNode,
'goto-next-changed':            c.goToNextDirtyHeadline,
'goto-next-clone':              c.goToNextClone,
'goto-next-history-node':       c.goToNextHistory,
'goto-next-marked':             c.goToNextMarkedHeadline,
'goto-next-node':               c.selectThreadNext,
'goto-next-sibling':            c.goToNextSibling,
'goto-next-visible':            c.selectVisNext,
'goto-parent':                  c.goToParent,
'goto-prev-history-node':       c.goToPrevHistory,
'goto-prev-node':               c.selectThreadBack,
'goto-prev-sibling':            c.goToPrevSibling,
'goto-prev-visible':            c.selectVisBack,
'hide-invisibles':              c.hideInvisibles,
'hoist':                        c.hoist,
'import-file':                  c.importAnyFile,
'indent-region':                c.indentBody,
'insert-body-time':             c.insertBodyTime,
'insert-child':                 c.insertChild,
'insert-node':                  c.insertHeadline,
'insert-node-before':           c.insertHeadlineBefore,
'mark':                         c.markHeadline,
'mark-changed-items':           c.markChangedHeadlines,
'mark-subheads':                c.markSubheads,
'match-brackets':               c.findMatchingBracket,
'minimize-all':                 f.minimizeAll,
'move-outline-down':            c.moveOutlineDown,
'move-outline-left':            c.moveOutlineLeft,
'move-outline-right':           c.moveOutlineRight,
'move-outline-up':              c.moveOutlineUp,
'new':                          c.new,
'open-cheat-sheet-leo':         c.openCheatSheet,
'open-leoDocs-leo':             c.leoDocumentation,
'open-leoPlugins-leo':          c.openLeoPlugins,
'open-leoSettings-leo':         c.openLeoSettings,
'open-local-settings':          c.selectAtSettingsNode,
'open-myLeoSettings-leo':       c.openMyLeoSettings,
'open-offline-tutorial':        f.leoHelp,
'open-online-home':             c.leoHome,
'open-online-toc':              c.openLeoTOC,
'open-online-tutorials':        c.openLeoTutorials,
'open-online-videos':           c.openLeoVideos,
'open-outline':                 c.open,
'open-python-window':           c.openPythonWindow,
'open-quickstart-leo':          c.leoQuickStart,
'open-scripts-leo':             c.openLeoScripts,
'open-users-guide':             c.openLeoUsersGuide,
'open-with':                    c.openWith,
'outline-to-cweb':              c.outlineToCWEB,
'outline-to-noweb':             c.outlineToNoweb,
'paste-node':                   c.pasteOutline,
'paste-retaining-clones':       c.pasteOutlineRetainingClones,
'paste-text':                   f.pasteText,
'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
'pretty-print-python-code':     c.prettyPrintPythonCode,
'promote':                      c.promote,
'read-at-auto-nodes':           c.readAtAutoNodes,
'read-at-file-nodes':           c.readAtFileNodes,
'read-at-shadow-nodes':         c.readAtShadowNodes,
'read-file-into-node':          c.readFileIntoNode,
'read-outline-only':            c.readOutlineOnly,
'redo':                         c.undoer.redo,
'reformat-paragraph':           c.reformatParagraph,
'refresh-from-disk':            c.refreshFromDisk,
'remove-sentinels':             c.removeSentinels,
'resize-to-screen':             f.resizeToScreen,
'revert':                       c.revert,
'save-all':                     c.saveAll,
'save-file':                    c.save,
'save-file-as':                 c.saveAs,
'save-file-as-unzipped':        c.saveAsUnzipped,
'save-file-as-zipped':          c.saveAsZipped,
'save-file-to':                 c.saveTo,
'set-colors':                   c.colorPanel,
'set-font':                     c.fontPanel,
'settings':                     c.preferences,
'show-invisibles':              c.showInvisibles,
'sort-children':                c.sortChildren,
'sort-recent-files':            c.sortRecentFiles,
'sort-siblings':                c.sortSiblings,
'tangle':                       c.tangle,
'tangle-all':                   c.tangleAll,
'tangle-marked':                c.tangleMarked,
'toggle-active-pane':           f.toggleActivePane,
'toggle-angle-brackets':        c.toggleAngleBrackets,
'toggle-invisibles':            c.toggleShowInvisibles,
'toggle-sparse-move':           c.toggleSparseMove,
'toggle-split-direction':       f.toggleSplitDirection,
'undo':                         c.undoer.undo,
'unformat-paragraph':           c.unformatParagraph,
'unindent-region':              c.dedentBody,
'unmark-all':                   c.unmarkAll,
'untangle':                     c.untangle,
'untangle-all':                 c.untangleAll,
'untangle-marked':              c.untangleMarked,
'weave':                        c.weave,
'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
'write-file-from-node':         c.writeFileFromNode,
'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
'write-outline-only':           c.fileCommands.writeOutlineOnly,
'''
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    '''Called from AbbrevCommands.reload_settings aka reloadSettings.'''
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    # Init these here for k.masterCommand.
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning('@data %s' % key)
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150521061618.1">def cmd(name):
    '''Command decorator for the c.frame.body class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'body'])
</t>
<t tx="ekr.20150531102337.1"></t>
<t tx="ekr.20150602204757.1">def autoBeautify(self, p):
    '''Auto beautify p's tree if allowed by settings and directives.'''
    c = self.c
    try:
        if not p.isDirty():
            return
        if leoBeautify.should_kill_beautify(p):
            return
        if c.config.getBool('tidy-autobeautify'):
            leoBeautify.beautifyPythonTree(event={'c': c, 'p0': p.copy()})
    except Exception:
        g.es('unexpected exception')
        g.es_exception()
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150617060607.1"></t>
<t tx="ekr.20150618072619.1">def create_find_status(self, grid, parent, row):
    '''Create the status line.'''
    dw = self
    status_label = dw.createLabel(parent, 'status-label', 'Status')
    status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
    grid.addWidget(status_label, row, 0)
    grid.addWidget(status_line, row, 1, 1, 2)
    # Official ivars.
    dw.find_status_label = status_label
    dw.find_status_edit = status_line
</t>
<t tx="ekr.20150703061709.1">@language python

'''myLeoSettings.py: save the outline and run the pylint command'''

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20150717102609.1">def cmd(name):
    '''Command decorator for the c.frame.log class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'frame', 'log'])
</t>
<t tx="ekr.20150717102728.1">@cmd('clear-log')
def clearLog(self, event=None):
    '''Clear the log pane.'''
    w = self.logCtrl.widget # w is a QTextBrowser
    if w:
        w.clear()
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160309074124.1">def set_invisibles(self, c):
    '''Set the show-invisibles bit in the document.'''
    d = c.frame.body.wrapper.widget.document()
    option = QtGui.QTextOption()
    if c.frame.body.colorizer.showInvisibles:
        option.setFlags(QtGui.QTextOption.ShowTabsAndSpaces)
    d.setDefaultTextOption(option)
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160424080647.1"># The ratio and secondary_ratio properties are read-only.
</t>
<t tx="ekr.20160424080815.2">def __get_ratio(self):
    '''Return splitter ratio of the main splitter.'''
    if g.pyzo:
        return 0.5
    c = self.c
    free_layout = c.free_layout
    if free_layout:
        w = free_layout.get_main_splitter()
        if w:
            aList = w.sizes()
            if len(aList) == 2:
                n1, n2 = aList
                # 2017/06/07: guard against division by zero.
                ratio = 0.5 if n1 + n2 == 0 else float(n1) / float(n1 + n2)
                return ratio
    return 0.5

ratio = property(
    __get_ratio, # No setter.
    doc="qtFrame.ratio property")
</t>
<t tx="ekr.20160424080815.3">def __get_secondary_ratio(self):
    '''Return the splitter ratio of the secondary splitter.'''
    if g.pyzo:
        return 0.5
    c = self.c
    free_layout = c.free_layout
    if free_layout:
        w = free_layout.get_secondary_splitter()
        if w:
            aList = w.sizes()
            if len(aList) == 2:
                n1, n2 = aList
                ratio = float(n1) / float(n1 + n2)
                return ratio
    return 0.5

secondary_ratio = property(
    __get_secondary_ratio, # no setter.
    doc="qtFrame.secondary_ratio property")
</t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160503125844.1">def create_outline(self, path):
    '''Create a tree of nodes from a FreeMind file.'''
    c = self.c
    junk, fileName = g.os_path_split(path)
    undoData = c.undoer.beforeInsertNode(c.p)
    try:
        self.import_file(path)
        c.undoer.afterInsertNode(c.p, 'Import', undoData)
    except Exception:
        g.es_print('Exception importing FreeMind file', g.shortFileName(path))
        g.es_exception()
    return c.p
</t>
<t tx="ekr.20160503145113.1">def import_files(self, files):
    '''Import a list of FreeMind (.mmap) files.'''
    c = self.c
    if files:
        self.tab_width = c.getTabWidth(c.p)
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            p = self.create_outline(fileName)
            p.contract()
            p.setDirty()
            c.setChanged(True)
        c.redraw(p)
</t>
<t tx="ekr.20160503145550.1">class FreeMindImporter(object):
    '''Importer class for FreeMind (.mmap) files.'''

    def __init__(self, c):
        '''ctor for FreeMind Importer class.'''
        self.c = c
        self.count = 0
        self.d = {}

    @others
</t>
<t tx="ekr.20160503191518.4">def import_file(self, path):
    '''The main line of the FreeMindImporter class.'''
    c = self.c
    sfn = g.shortFileName(path)
    if g.os_path_exists(path):
        htmltree = lxml.html.parse(path)
        root = htmltree.getroot()
        body = root.findall('body')[0]
        if body is None:
            g.error('no body in: %s' % sfn)
        else:
            root_p = c.lastTopLevel().insertAfter()
            root_p.h = g.shortFileName(path)
            for child in body:
                if child != body:
                    self.add_children(root_p, child)
            c.selectPosition(root_p)
            c.redraw()
    else:
        g.error('file not found: %s' % sfn)
</t>
<t tx="ekr.20160504043823.1">def prompt_for_files(self):
    '''Prompt for a list of FreeMind (.mm.html) files and import them.'''
    c = self.c
    types = [
        ("FreeMind files", "*.mm.html"),
        ("All files", "*"),
    ]
    names = g.app.gui.runOpenFileDialog(c,
        title="Import FreeMind File",
        filetypes=types,
        defaultextension=".html",
        multiple=True)
    c.bringToFront()
    if names:
        g.chdir(names[0])
        self.import_files(names)
</t>
<t tx="ekr.20160514120051.1">class LeoQtTree(leoFrame.LeoTree):
    '''Leo Qt tree class'''
    callbacksInjected = False # A class var.
    @others
</t>
<t tx="ekr.20161029060545.1">def on_idle(self):
    '''Call all idle-time hooks.'''
    if g.app.idle_time_hooks_enabled:
        for frame in g.app.windowList:
            c = frame.c
            # Do NOT compute c.currentPosition.
            # This would be a MAJOR leak of positions.
            g.doHook("idle", c=c)
</t>
<t tx="ekr.20170222084048.1">def add_children(self, parent, element):
    '''
    parent is the parent position, element is the parent element.
    Recursively add all the child elements as descendants of parent_p.
    '''
    p = parent.insertAsLastChild()
    attrib_text = element.attrib.get('text','').strip()
    tag = element.tag if g.isString(element.tag) else ''
    text = element.text or ''
    if not tag: text = text.strip()
    p.h = attrib_text or tag or 'Comment'
    p.b = text if text.strip() else ''
    for child in element:
        self.add_children(p, child)
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428084123.1">'''Recursively import all python files in a directory and clean the result.'''
if 0:
    &lt;&lt; old dir_ settings &gt;&gt;
g.cls()
dir_ = r'C:\leo.repo\leo-editor\leo\core\editpane'
# dir_ = r'C:\leo.repo\leo-editor\leo\external\npyscreen'
c.recursiveImport(
    dir_ = dir_,
    kind = '@file', # '@clean', #'@nosent','@auto','@file',
    recursive = True,
    safe_at_file = False,
    theTypes = ['.py',],
)
</t>
<t tx="ekr.20170428084123.2">dir_ = r'C:\prog\yoton',
dir_ = r'c:\leo.repo\ace\lib'
# Tests: 2017/04/07
dir_ = r'c:\leo.repo\ace\demo\kitchen-sink\dev_util.js' # pass.
dir_ = r'c:\leo.repo\ace\demo\static-highlighter\server.js' # Perfect import fails.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\asciidoc_highlight_rules.js' # undefined sections.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\abap.js' # pass.
dir_ = r'c:\leo.repo\ace\lib\ace\lib\event.js' # pass.
dir_ = r'c:\leo.repo\ace\lib\ace\lib' # pass.
dir_ = r'c:\leo.repo\ace\demo' # All pass except server.js
dir_ = r'c:\test\js-import-test.js' # pass.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\coffee\coffee.js'
# Perfect import fails. Compressed code. Maybe will never pass.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\behaviour' # All pass
dir_ = r'c:\leo.repo\ace\lib\ace\mode' # One failure.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\xquery\xqlint.js' # perfect import fails.
dir_ = r'c:\prog\brython-home.html'</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, 'leo-bundle-all-%s' % (stamp))
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171114041307.1">@nobeautify
def reloadSettings(self):
    c, getBool = self.c, self.c.config.getBool
    #
    # Init all settings ivars.
    self.color_tags_list = []
    self.showInvisibles      = getBool("show-invisibles-by-default")
    self.underline_undefined = getBool("underline-undefined-section-names")
    self.use_hyperlinks      = getBool("use-hyperlinks")
    self.use_pygments        = None # Set in report_changes.
    self.use_pygments_styles = getBool('use-pygments-styles', default=True)
    #
    # Report changes to pygments settings.
    self.report_changes()
    #
    # Init the default fonts.
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
</t>
<t tx="ekr.20171122055719.1">def declutter_style(self, arg, c, cmd, item, new_icons):
    '''Handle style options.'''
    arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
    if cmd == 'ICON':
        new_icons.append(arg)
    elif cmd == 'BG':
        item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FG':
        item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FONT':
        item.setFont(0, QtGui.QFont(arg))
    elif cmd == 'ITALIC':
        font = item.font(0)
        font.setItalic(bool(int(arg)))
        item.setFont(0, font)
    elif cmd == 'WEIGHT':
        arg = getattr(QtGui.QFont, arg, 75)
        font = item.font(0)
        font.setWeight(arg)
        item.setFont(0, font)
    elif cmd == 'PX':
        font = item.font(0)
        font.setPixelSize(int(arg))
        item.setFont(0, font)
    elif cmd == 'PT':
        font = item.font(0)
        font.setPointSize(int(arg))
        item.setFont(0, font)
</t>
<t tx="ekr.20171122064635.1">def declutter_replace(self, arg, cmd, item, m, pattern, text):
    '''
    Execute cmd and return True if cmd is any replace command.
    '''
    if cmd == 'REPLACE':
        text = pattern.sub(arg, text)
        item.setText(0, text)
        return True
    elif cmd == 'REPLACE-HEAD':
        s = text[:m.start()]
        item.setText(0, s.rstrip())
        return True
    elif cmd == 'REPLACE-TAIL':
        s = text[m.end():]
        item.setText(0, s.lstrip())
        return True
    elif cmd == 'REPLACE-REST':
        s = text[:m.start] + text[m.end():]
        item.setText(0, s.strip())
        return True
    else:
        return False
    
</t>
<t tx="ekr.20180225010644.1"></t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180312150559.1">@nobeautify

def addOptionsToParser(self, parser):
    
    add = parser.add_option
    
    def add_bool(option, help, dest=None):
        add(option, action='store_true', dest=dest, help=help)

    def add_other(option, help, dest=None, m=None):
        add(option, dest=dest, help=help, metavar=m)

    add_bool('--diff',          'use Leo as an external git diff')
    add_bool('--fullscreen',    'start fullscreen')
    add_bool('--ipython',       'enable ipython support')
    add_bool('--fail-fast',     'stop unit tests after the first failure')
    add_other('--gui',          'gui to use (qt/qttabs/console/null)')
    add_bool('--listen-to-log', 'start log_listener.py on startup')
    add_other('--load-type',    '@&lt;file&gt; type for non-outlines', m='TYPE')
    add_bool('--maximized',     'start maximized')
    add_bool('--minimized',     'start minimized')
    add_bool('--no-plugins',    'disable all plugins')
    add_bool('--no-splash',     'disable the splash screen')
    if g.pyzo:
        add_bool('--pyzo',      'enable experimental pyzo code')
    add_other('--screen-shot',  'take a screen shot and then exit', m='PATH')
    add_other('--script',       'execute a script and then exit', m="PATH")
    add_bool('--script-window', 'execute script using default gui')
    add_other('--select',       'headline or gnx of node to select', m='ID')
    add_bool('--session-restore','restore session tabs at startup')
    add_bool('--session-save',  'save session tabs on exit')
    add_bool('--silent',        'disable all log messages')
    add_other('--theme',        'use the named theme file', m='NAME')
    add_other('--trace-binding', 'trace commands bound to a key', m='KEY')
    add_bool('--trace-coloring', 'trace syntax coloring')
    add_bool('--trace-drawing', 'trace outline redraws')
    add_bool('--trace-events',  'trace non-key events')
    add_bool('--trace-focus',   'trace changes of focus')
    add_bool('--trace-gnx',     'trace gnx logic')
    add_bool('--trace-ipython', 'trace ipython bridge')
    add_bool('--trace-keys',    'trace key events')
    add_bool('--trace-plugins', 'trace imports of plugins')
    add_other('--trace-setting', 'trace where named setting is set', m="NAME")
    add_bool('--trace-shutdown', 'trace shutdown logic')
    add_bool('--trace-startup',  'trace startup logic')
    add_bool('--trace-themes',  'trace theme init logic')
    add_other('--window-size',  'initial window size (height x width)', m='SIZE')
    # Multiple bool values.
    add('-v', '--version', action='store_true',
        help='print version number and exit')
</t>
<t tx="ekr.20180312151544.1">def doSimpleOptions(self, options):
    '''These args just set g.app ivars.'''
    # --fail-fast
    g.app.failFast = options.fail_fast
    # --fullscreen
    g.app.start_fullscreen = options.fullscreen
    # --git-diff
    g.app.diff = options.diff
    # --listen-to-log
    g.app.listen_to_log_flag = options.listen_to_log
    # --ipython
    g.app.useIpython = options.ipython
    # --maximized
    g.app.start_maximized = options.maximized
    # --minimized
    g.app.start_minimized = options.minimized
    # --no-plugins
    if options.no_plugins:
        g.app.enablePlugins = False
    # --no-splash: --minimized disables the splash screen
    g.app.use_splash_screen = (
        not options.no_splash and
        not options.minimized)
    # --pyzo
    g.pyzo = g.pyzo and options.pyzo
    g.pr('\n===== py3.pyzo branch: --pyzo:', bool(g.pyzo))
    # --session-restore &amp; --session-save
    g.app.restore_session = bool(options.session_restore)
    g.app.save_session = bool(options.session_save)
    # --silent
    g.app.silentMode = options.silent
    #
    # Most --trace- options append items to g.app.debug.
    table = (
        # ('cache', options.trace_cache),
        ('coloring', options.trace_coloring),
        ('drawing', options.trace_drawing),
        ('events', options.trace_events), # New
        ('focus', options.trace_focus),
        ('gnx', options.trace_gnx), # New.
        ('keys', options.trace_keys), # New
        ('ipython', options.trace_ipython), # New
        ('plugins', options.trace_plugins),
        ('shutdown', options.trace_shutdown),
        ('startup', options.trace_startup), # New
        ('themes', options.trace_themes),
    )
    for val, option in table:
        if option:
            g.app.debug.append(val)
    #
    # These are not bool options.
    # --trace-binding
    g.app.trace_binding = options.trace_binding
        # g.app.config does not exist yet.
    #
    # --trace-setting=setting
    g.app.trace_setting = options.trace_setting
        # g.app.config does not exist yet.
    
</t>
<t tx="ekr.20180312153008.1">def doScriptOption(self, options, parser):

    # --script
    script = options.script
    if script:
        # #1090: use cwd, not g.app.loadDir, to find scripts.
        fn = g.os_path_finalize_join(os.getcwd(), script)
        script, e = g.readFileIntoString(fn, kind='script:', verbose=False)
        if not script:
            print('script not found:%s' % fn)
            sys.exit(1)
    else:
        script = None
    return script
</t>
<t tx="ekr.20180324065741.1">'''Copy the selected text to the next node.'''
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.clock()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.clock()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line)-len(line.lstrip())
            indent2 = len(g_line)-len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column # For traces.
                column += abs(indent2-indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0-1:n0+30])
        print('can not happen: not found: %r' % line)
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1+n0+jedi_line,
                column=column,
                path = g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            ) 
            completions = script.completions()
            t3 = time.clock()
        except ValueError:
            t3 = time.clock()
            completions = None
            g.printObj(source_lines[n0-1:n0+30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None  
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    '''A hack to match the callers expectations.'''
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180528160744.1">def loadOnePluginHelper(moduleName):
    result = None
    try:
        __import__(moduleName)
        # Look up through sys.modules, __import__ returns toplevel package
        result = sys.modules[moduleName]
    except g.UiTypeException:
        report('plugin %s does not support %s gui' % (moduleName, g.app.gui.guiName()))
    except ImportError:
        report('error importing plugin: %s' % moduleName)
    # except ModuleNotFoundError:
        # report('module not found: %s' % moduleName)
    except SyntaxError:
        report('syntax error importing plugin: %s' % moduleName)
    except Exception:
        report('exception importing plugin: %s' % moduleName)
        g.es_exception()
    return result
</t>
<t tx="ekr.20180528160855.1">def callInitFunction(result):
    '''True to call the top-level init function.'''
    try:
        # Indicate success only if init_result is True.
        init_result = result.init()
            # Careful: this may throw an exception.
        if init_result not in (True, False):
            report('%s.init() did not return a bool' % moduleName)
        if init_result:
            self.loadedModules[moduleName] = result
            self.loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
        else:
            report('%s.init() returned False' % moduleName)
            result = None
    except Exception:
        report('exception loading plugin: %s' % moduleName)
        g.es_exception()
        result = None
    return result
</t>
<t tx="ekr.20180528162300.1">def reportFailedImport():
    '''Report a failed import.'''
    if g.app.batchMode or g.app.inBridge or g.unitTesting:
        return
    if (
        self.warn_on_failure and
        tag == 'open0' and
        not g.app.gui.guiName().startswith('curses') and
        moduleName not in optional_modules
    ):
        report('can not load enabled plugin: %s' % moduleName)
</t>
<t tx="ekr.20180528162604.1">def finishImport(result):
    '''Handle last-minute checks.'''
    if tag == 'unit-test-load':
        return result # Keep the result, but do no more.
    if hasattr(result, 'init'):
        return callInitFunction(result)
    #
    # No top-level init function.
    if g.app.unitTesting:
        # Do *not* load the module.
        self.loadedModules[moduleName] = None
        return None
    # Guess that the module was loaded correctly.
    report('fyi: no top-level init() function in %s' % moduleName)
    self.loadedModules[moduleName] = result
    return result
</t>
<t tx="ekr.20180604114156.2">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/433

- Report error: see child node.
- Ask: Do I need to accept Terry's work?

Terry's code is in plugins/editpane/editpane.py

@language python
</t>
<t tx="ekr.20180604114156.3">@language rest
@wrap

LEP: __init__ LEP
LEP: Loaded module: plaintextedit
LEP: Loaded module: plaintextview
LEP: Loaded module: __init__
LEP: Loaded module: clicky_splitter
LEP: Loaded module: csvedit
LEP: Loaded module: editpane
LEP: Loaded module: leotextedit
LEP: Loaded module: markdownview
LEP: Module not loaded (unmet dependencies?): pandownview
LEP: Module not loaded (unmet dependencies?): vanillascintilla
LEP: Module not loaded (unmet dependencies?): webengineview
LEP: Loaded module: webkitview
LEP: build layout
LEP: new edit position
LEP: text changed, NOT focused
LEP: new view position
LEP: update edit position
LEP: update editor text
LEP: text changed, NOT focused
LEP: update view position
LEP:
register handlers
LEP: unregister handlers</t>
<t tx="ekr.20180604114211.1">@nosearch
</t>
<t tx="ekr.20180604114211.408">@language rest
@wrap
wikiview.py plugin problem with new colorizing code
https://github.com/leo-editor/leo-editor/issues/388

@language python
</t>
<t tx="ekr.20180604114211.561">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/678

10 years ago:
http://leo.zwiki.org/GraphsInTrees

@language python
</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180619063409.1">@language rest
@wrap

The freemind importer should use ElementTree, not lxml
https://github.com/leo-editor/leo-editor/issues/929
ElementTree is more widely available.

@language python
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180810052056.1">def drawVisible(self, p):
    '''
    Add only the visible nodes to the outline.
    
    Not used, as this causes scrolling issues.
    '''
    t1 = time.clock()
    c = self.c
    parents = []
    # Clear the widget.
    w = self.treeWidget
    w.clear()
    # Clear the dicts.
    self.initData()
    if c.hoistStack:
        first_p = c.hoistStack[-1].p
        target_p = first_p.nodeAfterTree().visBack(c)
    else:
        first_p = c.rootPosition()
        target_p = None
    n = 0
    for p in self.yieldVisible(first_p, target_p):
        n += 1
        level = p.level()
        parent_item = w if level == 0 else parents[level-1]
        item = QtWidgets.QTreeWidgetItem(parent_item)
        item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
        item.setChildIndicatorPolicy(
            item.ShowIndicator if p.hasChildren()
            else item.DontShowIndicator)
        item.setExpanded(bool(p.hasChildren() and p.isExpanded()))
        self.items.append(item)
        # Update parents.
        parents = [] if level == 0 else parents[:level]
        parents.append(item)
        # Update the dicts.
        itemHash = self.itemHash(item)
        self.item2positionDict[itemHash] = p.copy()
        self.item2vnodeDict[itemHash] = p.v
        self.position2itemDict[p.key()] = item
        d = self.vnode2itemsDict
        v = p.v
        aList = d.get(v, [])
        aList.append(item)
        d[v] = aList
        # Enter the headline.
        item.setText(0, p.h)
        if self.use_declutter:
            item._real_text = p.h
        # Draw the icon.
        v.iconVal = v.computeIcon()
        icon = self.getCompositeIconImage(p, v.iconVal)
        if icon:
            self.setItemIcon(item, icon)
        # Set current item.
        if p == c.p:
            w.setCurrentItem(item)
    # Useful, for now.
    t2 = time.clock()
    if t2-t1 &gt; 0.1:
        g.trace('%s nodes, %5.3f sec' % (n, t2-t1))
</t>
<t tx="ekr.20180810052056.2">def yieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    yield p
    while p:
        if p == target_p:
            return
        v = p.v
        if (v.children and (
            # Use slower test for clones:
            len(v.parents) &gt; 1 and p in v.expandedPositions or
            # Use a quick test for non-clones:
            len(v.parents) &lt;= 1  and (v.statusBits &amp; v.expandedBit) != 0
        )):
            # p.moveToFirstChild()
            p.stack.append((v, p._childIndex),)
            p.v = v.children[0]
            p._childIndex = 0
            yield p
            continue
        # if p.hasNext():
        parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
        if p._childIndex + 1 &lt; len(parent_v.children):
            # p.moveToNext()
            p._childIndex += 1
            p.v = parent_v.children[p._childIndex]
            yield p
            continue
        #
        # A fast version of p.moveToThreadNext().
        # We look for a parent with a following sibling.
        while p.stack:
            # p.moveToParent()
            p.v, p._childIndex = p.stack.pop()
            # if p.hasNext():
            parent_v = p.stack[-1][0] if p.stack else c.hiddenRootNode
            if p._childIndex + 1 &lt; len(parent_v.children):
                # p.moveToNext()
                p._childIndex += 1
                p.v = parent_v.children[p._childIndex]
                break # Found: moveToThreadNext()
        else:
            break # Not found.
        # Found moveToThreadNext()
        yield p
        continue
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180810052056.3">def slowYieldVisible(self, first_p, target_p=None):
    """
    A generator yielding positions from first_p to target_p.
    """
    c = self.c
    p = first_p.copy()
    while p:
        yield p
        if p == target_p:
            return
        p.moveToVisNext(c)
    if target_p:
        g.trace('NOT FOUND:', target_p.h)
</t>
<t tx="ekr.20180816105258.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_branches(
    branch1='devel', # old branch
    branch2='py3', # new branch
    fn='leo/core/leoApp.py',
    directory=None,
)
</t>
<t tx="ekr.20180817043619.1">def update_expansion(self, p):
    '''Update expansion bits for p, including all clones.'''
    c = self.c
    w = self.treeWidget
    expand = c.shouldBeExpanded(p)
    if 'drawing' in g.app.debug:
        g.trace('expand' if expand else 'contract')
    item = self.position2itemDict.get(p.key())
    if p:
        try:
            # These generate events, which would trigger a full redraw.
            self.busy = True
            if expand:
                w.expandItem(item)
            else:
                w.collapseItem(item)
        finally:
            self.busy = False
        w.repaint()
    else:
        g.trace('NO P')
        c.redraw()
</t>
<t tx="ekr.20180824062242.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/958

Leo 5.7 freezes with Python2 and PyQt4 in vim-mode.

I can't fix this if I can't duplicate it.

@language python
</t>
<t tx="ekr.20180824062905.1"># Apparently only necessary on some platforms, with some versions of Qt.

leo_changing_focus = False

def onFocusIn(self, event):
    '''Override QTextBrowser.focusInEvent.'''
    if self.leo_changing_focus:
        return
    try:
        if 'events' in g.app.debug:
            g.trace(g.callers())
        self.leo_changing_focus = True
        QtWidgets.QTextBrowser.focusInEvent(self, event)
    finally:
        self.leo_changing_focus = False
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181004060958.1"></t>
<t tx="ekr.20181005085507.1">def mousePressEvent(self, event):
    
    c = self.c

    def find_line(y):
        n, last_y = 0, 0
        for n, y2 in self.offsets:
            if last_y &lt;= y &lt; y2:
                return n
            last_y = y2
        return n if self.offsets else 0
        
    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    path = xdb.canonic(g.fullPath(c, c.p))
    if not path:
        return
    n = find_line(event.y())
    if not xdb.checkline(path, n):
        g.trace('FAIL checkline', path, n)
        return
    if xdb.has_breakpoint(path, n):
        xdb.qc.put('clear %s:%s' % (path, n))
    else:
        xdb.qc.put('b %s:%s' % (path, n))
</t>
<t tx="ekr.20181005093003.1">def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.w_adjust = c.config.getInt('gutter-w-adjust') or 12
        # Extra width for column.
    self.y_adjust = c.config.getInt('gutter-y-adjust') or 10
        # The y offset of the first line of the gutter.
</t>
<t tx="ekr.20181008045948.1"></t>
<t tx="ekr.20181009072707.1">@first # -*- coding: utf-8 -*-
&lt;&lt; imports &gt;&gt;
&lt;&lt; compute path &gt;&gt;
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    &lt;&lt; run tests &gt;&gt;
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181009084156.1">import leo.core.leoBridge as leoBridge
import os
import sys
# import pdb ; pdb.set_trace()
import unittest

</t>
<t tx="ekr.20181009084245.1">load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
</t>
<t tx="ekr.20181009084323.1">tm = c.testManager
g.unitTesting = g.app.unitTesting = True
suite = unittest.makeSuite(unittest.TestCase)
aList = tm.findAllUnitTestNodes(all=False, marked=False)
setup_script = None
found = False
for p in aList:
    if tm.isTestSetupNode(p):
        setup_script = p.b
        test = None
    elif tm.isTestNode(p):
        test = tm.makeTestCase(p, setup_script)
    elif tm.isSuiteNode(p):
        test = tm.makeTestSuite(p, setup_script)
    elif tm.isTestClassNode(p):
        test = tm.makeTestClass(p)
    else:
        test = None
    if test:
        suite.addTest(test)
        found = True
if not found:
    print('No unit tests')
    sys.exit(1)
runner = unittest.TextTestRunner(
    failfast=True, verbosity=1)
try:
    result = runner.run(suite)
    if result.errors or result.failures:
        print('errors: %s, failures: %s' % (
            len(result.errors), len(result.failures)))
        sys.exit(1)
    else:
        print('Travis unit tests all passed.')
        sys.exit(0)
except Exception:
    print('Unexpected exception')
    g.es_exception()
    sys.exit(1)
</t>
<t tx="ekr.20181009123539.1">@g.command('toggle-gutter')
def add_gutter(event):
    '''Add the gutter area showing line numbers.'''
    c = event.get('c')
    if not c:
        return
    dw = c.frame.top
    gutter = dw.gutter
    glayout = dw.gutter_layout
    if gutter.using_gutter:
        # NumberBar has a reference to gutter.edit.
        # Apparently, this causes problems.
        glayout.removeWidget(gutter.edit)
        glayout.removeWidget(gutter.number_bar)
        # glayout.invalidate()
        # glayout.parent().layout().invalidate()
        glayout.addWidget(dw.gutter.edit)
        gutter.using_gutter = False
    else:
        glayout.removeWidget(gutter.edit)
        glayout.addWidget(gutter.number_bar)
        glayout.addWidget(gutter.edit)
        gutter.using_gutter = True
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...',color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20190108052043.1">def findFilesToWrite(self, force):
    '''
    Return a list of files to write.
    We must do this in a prepass, so as to avoid errors later.
    '''
    c = self.c
    if force:
        # The Write @&lt;file&gt; Nodes command.
        # Write all nodes in the selected tree.
        root = c.p
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        root = c.rootPosition()
        p = c.rootPosition()
        after = None
    seen = set()
    files = []
    while p and p != after:
        if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            # Note: @ignore not honored in @asis nodes.
            p.moveToNodeAfterTree() # 2011/10/08: Honor @ignore!
        elif p.isAnyAtFileNode():
            data = p.v, g.fullPath(c, p)
            if data not in seen:
                seen.add(data)
                files.append(p.copy())
            p.moveToThreadNext()
                #525: Scan for nested @&lt;file&gt; nodes
        else:
            p.moveToThreadNext()
    if not force:
        files = [z for z in files if z.isDirty()]
    return files, root
</t>
<t tx="ekr.20190108053115.1">def internalWriteError(self, p):
    '''
    Fix bug 1260415: https://bugs.launchpad.net/leo-editor/+bug/1260415
    Give a more urgent, more specific, more helpful message.
    '''
    g.es_exception()
    g.es('Internal error writing: %s' % (p.h), color='red')
    g.es('Please report this error to:', color='blue')
    g.es('https://groups.google.com/forum/#!forum/leo-editor', color='blue')
    g.es('Warning: changes to this file will be lost', color='red')
    g.es('unless you can save the file successfully.', color='red')
</t>
<t tx="ekr.20190108054317.1">def findFilesToRead(self, force, root):

    c = self.c
    p = root.copy()
    scanned_tnodes = set()
    files = []
    after = p.nodeAfterTree() if force else None
    while p and p != after:
        data = (p.gnx, g.fullPath(c, p))
        # skip clones referring to exactly the same paths.
        if data in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(data)
        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            p.moveToNodeAfterTree()
        elif (
            p.isAtThinFileNode() or
            p.isAtAutoNode() or
            p.isAtEditNode() or
            p.isAtShadowFileNode() or
            p.isAtFileNode()
        ):
            files.append(p.copy())
            p.moveToNodeAfterTree()
        elif p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Note (see #1081): @asis and @nosent can *not* be updated automatically.
            # Doing so using refresh-from-disk will delete all child nodes.
            p.moveToNodeAfterTree()
        elif p.isAtCleanNode():
            files.append(p.copy())
            p.moveToThreadNext()
                # #525: Nested nodes.
        else:
            p.moveToThreadNext()
    return files
</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    Return True if the path has changed and the user allows it.
    raise IOError if the user forbids the write.
    Return False if the path has not changed.
    '''
    at, c = self, self.c
    if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
        return False
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    pathChanged = oldPath and oldPath != newPath
    # 2010/01/27: suppress this message during save-as and save-to commands.
    if pathChanged and not c.ignoreChangedPaths:
        ok = at.promptForDangerousWrite(
            fileName=None,
            kind=None,
            message='%s\n%s' % (
                g.tr('path changed for %s' % (p.h)),
                g.tr('write this file anyway?')))
        if not ok:
            raise IOError
        at.setPathUa(p, newPath) # Remember that we have changed paths.
    return pathChanged
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):
    
    at, c = self, self.c
    if g.unitTesting:
        return
    if files:
        report = c.config.getBool('report-unchanged-files', default=True)
        if report:
            g.es("finished")
        elif at.sameFiles:
            g.es('finished. %s unchanged files' % at.sameFiles)
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
        # g.es("to write an unchanged @auto node,\nselect it directly.")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    '''Write an external file to a string, and return its contents.'''
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return ''
</t>
<t tx="ekr.20190116145036.1"></t>
<t tx="ekr.20190116145049.1">@language rest
@wrap

*** Add *real* vim emulation to Leo.
    Use nvim-python: https://github.com/neovim/pynvim
*** Add *real* org mode emulation to Leo

@language python
</t>
<t tx="ekr.20190118082047.1">def put_status_line(self, col, fcol, row, words):
    
    if 1:
        fcol_part = '' if fcol is None else ' fcol: %d' % (fcol)
        # For now, it seems to0 difficult to get alignment *exactly* right.
        self.put1("line: %d col: %d %s words: %s" % (row, col, fcol_part, words))
    else:
        # #283 is not ready yet, and probably will never be.
        fline = self.file_line()
        fline = '' if fline is None else fline + row
        self.put1(
            "fline: %2s line: %2d col: %2s fcol: %2s" % (fline, row, col, fcol))
</t>
<t tx="ekr.20190118082646.1">def compute_columns(self, block, cursor):
    
    c = self.c
    line = block.text()
    col = cursor.columnNumber()
    offset = c.p.textOffset()
    fcol_offset = 0
    s2 = line[0: col]
    col = g.computeWidth(s2, c.tab_width)
    #
    # Fix bug #195: fcol when using @first directive is inaccurate
    # https://github.com/leo-editor/leo-editor/issues/195
    i = line.find('&lt;&lt;')
    j = line.find('&gt;&gt;')
    if -1 &lt; i &lt; j or g.match_word(line.strip(), 0, '@others'):
        offset = None
    else:
        for tag in ('@first ', '@last '):
            if line.startswith(tag):
                fcol_offset = len(tag)
                break
    #
    # fcol is '' if there is no ancestor @&lt;file&gt; node.
    fcol = None if offset is None else max(0, col + offset - fcol_offset)
    return col, fcol
</t>
<t tx="ekr.20190118130950.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/981
https://github.com/leo-editor/leo-editor/issues/977

The only real change was to efc.open_with. It deletes temp files before reopening them.

@language python
@nosearch
</t>
<t tx="ekr.20190118150859.10">def createEditor(self, name):
    '''Create a new body editor.'''
    c, p = self.c, self.c.p
    parent_frame = c.frame.top.leo_ui.leo_body_inner_frame
    # To do: #1061: Create a frame for line numbers, if necessary
    #
    # Step 1: create the editor.
    w = widget = qt_text.LeoQTextBrowser(parent_frame, c, self)
    w.setObjectName('richTextEdit') # Will be changed later.
    wrapper = qt_text.QTextEditWrapper(w, name='body', c=c)
    self.packLabel(w)
    #
    # Step 2: inject ivars, set bindings, etc.
    self.injectIvars(parent_frame, name, p, wrapper)
    self.updateInjectedIvars(w, p)
    wrapper.setAllText(p.b)
    wrapper.see(0)
    c.k.completeAllBindingsForWidget(wrapper)
    if isinstance(w, QtWidgets.QTextEdit):
        colorizer = leoColorizer.JEditColorizer(c, widget, wrapper)
        colorizer.highlighter.setDocument(widget.document())
    else:
        # Scintilla only.
        self.recolorWidget(p, wrapper)
    return parent_frame, wrapper
</t>
<t tx="ekr.20190119062719.1">@language rest
@wrap
@nosearch

# for reference only.
# This can be deleted at any time.
</t>
<t tx="ekr.20190119085129.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1047

The following call FastRead().readFileFromClipboard:
    
- fc.getLeoOutlineFromClipBoard.
- fc.getLeoOutlineFromClipBoardRetainingClones.
- fc.getPos/VnodeFromClipboard.

@language python
</t>
<t tx="ekr.20190121135044.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/926

The change was to abbrev.init_tree_abbrev_helper.

@language python
</t>
<t tx="ekr.20190122113449.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1065

@language python
</t>
<t tx="ekr.20190122185223.1">@language text

Find all kwargs using regex:

^\s*(def\s+\w+\s*\(.*\=.*\))

found 1154 nodes

^\s*(def\s+\w+\s*\(.*\=.*\=.*\))

found 284 nodes
</t>
<t tx="ekr.20190123051253.1">def remove_temp_file(self, p, path):
    '''
    Remove any existing *temp* file for p and path, updating self.files.
    '''
    for ef in self.files:
        if path and path == ef.path and p.v == ef.p.v:
            self.destroy_temp_file(ef)
            self.files = [z for z in self.files if z != ef]
            return
</t>
<t tx="ekr.20190216104815.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/525

@language python
</t>
<t tx="ekr.20190217060648.1"></t>
<t tx="ekr.20190218044303.1">https://github.com/leo-editor/leo-editor/issues/1081

Added warning when @asis or @nosent files change outside of Leo.
</t>
<t tx="ekr.20190218055230.1">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.
    
    There is *no way* to update the tree automatically.
    '''
    if g.unitTesting or c not in g.app.commanders():
        return
    if not p:
        g.trace('NO P')
        return
    g.app.gui.runAskOkDialog(
        c=c,
        message='\n'.join([
            '%s has changed outside Leo.\n' % g.splitLongFileName(path),
            'Leo can not update this file automatically.\n',
            'This file was created from %s.\n' % p.h,
            'Warning: refresh-from-disk will destroy all children.'
        ]),
        title='External file changed',
    )
</t>
<t tx="ekr.20190218071717.1">@language rest

https://github.com/leo-editor/leo-editor/issues/1085

- Removed isPython3 switches.
- Removed g.u.
- Removed g.ue.

These are **NOT** necessary:
- Replace isBytes, isCallable, isInt, isList, isString
</t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190316153545.1">@language rest
@wrap
@nosearch

https://github.com/leo-editor/leo-editor/issues/1096
https://github.com/pyzo/pyzo/issues/599

*** Put *entire* Leo outline in outline shim.

*** Learn about Signals.

Next:
- Use Pyzo editor for the body pane(!!)
- Finish ConfigShim.
- Finish MenuShim.
- Create LoggerShim (just send to the console?)

Maybe:
- Move monkey patch editor.py:createEditor back into Leo.
- Disable pyzo painters during startup?
- Use g.app.window_list to init.

Study:
- How does Pyzo separate Window code from tool code?
- How can Leo windows *be* QWidget's?

Later:
- Modify pyzo shutdown logic (after putting outlines in MainWindow).
- Make pyzo tool panes for outline, body panes, log pane &amp; sub-panes, and VR pane.
  g.app.forgetOpenFile(c.fileName(), force=True)
- Finish ConfigShim:
  - Improve tracing in g.Bunch.
  - Use the pyzo config code, **unless** the settings are Leonine! 
  - Does Leo need detailed knowledge of pyzo settings?
- Convert Plugins to be Tool windows.
- Re-enable disabled plugin.
  
Notes:
- Work started at rev d9f7bc359db, Thursday, 2019-03-28 07:39:41
- To find shims:  cff shim, case significant, headline only.
  
@language python
</t>
<t tx="ekr.20190317082435.1">class SplashShim(QtWidgets.QWidget):
    '''A do-nothing splash widget.'''
    
    def __init__(self, parent, **kwargs):
        # This ctor is required, because it is called with kwargs.
        QtWidgets.QWidget.__init__(self, parent)
</t>
<t tx="ekr.20190317082603.12">def _populate(self):
    
    g.pr('----- LeoMainWindow._populate')

    # Delayed imports
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager

    # Instantiate tool manager
    pyzo.toolManager = ToolManager()

    # Check to install conda now ...
    #from pyzo.util.bootstrapconda import check_for_conda_env
    #check_for_conda_env()

    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()

    # Create editor stack and make the central widget
    pyzo.editors = EditorTabs(self)
    self.setCentralWidget(pyzo.editors)
        # EKR: QMainWindow.setCentralWidget

    # Create floater for shell
    self._shellDock = dock = QtWidgets.QDockWidget(self)
    if pyzo.config.settings.allowFloatingShell:
        dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
    else:
        dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
    dock.setWindowTitle('Shells')
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)

    # Create shell stack
    pyzo.shells = ShellStackWidget(self)
    dock.setWidget(pyzo.shells)

    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')

    # Create the default shell when returning to the event queue
    pyzo.core.main.callLater(pyzo.shells.addShell)

    # Create statusbar
    if pyzo.config.view.showStatusbar:
        pyzo.status = self.statusBar()
    else:
        pyzo.status = None
        self.setStatusBar(None)

    # Create menu
    from pyzo.core import menu
    pyzo.keyMapper = menu.KeyMapper()
    menu.buildMenus(self.menuBar())

    # Add the context menu to the editor
    pyzo.editors.addContextMenu()
    pyzo.shells.addContextMenu()

    # Load tools
    if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
        pyzo.toolManager.loadTool('pyzosourcestructure')
        pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
    elif pyzo.config.state.loadedTools:
        for toolId in pyzo.config.state.loadedTools:
            pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190317082751.1">new_config = True
    # Works when False.
    
config_shim_seen = {}
    # Keys are bunches.

try:  # pragma: no cover
    from collections import OrderedDict as _dict
except ImportError:
    _dict = dict
    
from pyzo.util.zon import Dict

# config_base = _dict if new_config else Dict

config_base = _dict if new_config else Dict
    # The old code needs _dict, not dict.

class ConfigShim(config_base):
    
    def __init__(self):
        config_base.__init__(self)
        g.pr('\n===== ConfigShim: new_config: %s\n' % new_config)
    
    if new_config:
        &lt;&lt; define bunch settings &gt;&gt;
        &lt;&lt; new config methods &gt;&gt;
    else:
        &lt;&lt; old config methods &gt;&gt;

    @others
</t>
<t tx="ekr.20190317082751.2">def __repr__(self):

    from pyzo.util.zon import isidentifier
        # Changed import.
    identifier_items = []
    nonidentifier_items = []
    for key, val in self.items():
        if isidentifier(key):
            identifier_items.append('%s=%r' % (key, val))
        else:
            nonidentifier_items.append('(%r, %r)' % (key, val))
    if nonidentifier_items:
        return 'Dict([%s], %s)' % (', '.join(nonidentifier_items),
                                   ', '.join(identifier_items))
    else:
        return 'Dict(%s)' % (', '.join(identifier_items))
</t>
<t tx="ekr.20190317082751.3">def __getattribute__(self, key):
    try:
        ### return object.__getattribute__(self, key)
        val = object.__getattribute__(self, key)
        if False and key not in ('advanced', 'shortcuts2', 'settings'):
            # g.pr('===== LeoPyzoConfig 1: %r: %r' % (key, val))
            g.pr('===== LeoPyzoConfig 1: %r' % key)
        return val
    except AttributeError:
        if key in self:
            if False and key not in ('advanced', 'shortcuts2', 'settings'):
                # g.pr('===== LeoPyzoConfig 1: %r: %r' % (key, g.truncate(self[key], 50)))
                g.pr('===== LeoPyzoConfig 2: %r' % key)
            return self[key]
        else:
            raise
</t>
<t tx="ekr.20190317082751.4">def __setattr__(self, key, val):
    if key in Dict.__reserved_names__:
        # Either let OrderedDict do its work, or disallow
        if key not in Dict.__pure_names__:
            return _dict.__setattr__(self, key, val)
        else:
            raise AttributeError('Reserved name, this key can only ' +
                                 'be set via ``d[%r] = X``' % key)
    else:
        # if isinstance(val, dict): val = Dict(val) -&gt; no, makes a copy!
        self[key] = val
</t>
<t tx="ekr.20190317083529.1"></t>
<t tx="ekr.20190317084000.1">def createPyzoMainWindow(self):
    '''
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    '''
    dw = self
    dw.leo_ui = self
    dw.richTextEdit = g.TracingNullObject(tag='dw.richTextEdit')
    dw.stackedWidget = g.TracingNullObject(tag='dw.stackedWidget')
    dw.treeWidget = g.TracingNullObject(tag='dw.treeWidget')
    dw.tabWidget = g.TracingNullObject(tag='dw.tabWidet')
    #
    # Import *all* of the pyzo packages.
    import leo.core.pyzo_shims as pyzo_shims
    pyzo_shims.MainWindowShim()
</t>
<t tx="ekr.20190317084039.1"></t>
<t tx="ekr.20190317084647.2">def __init__(self, parent=None, locale=None):
    '''
    Important: do *all* inits here.  Do *not* call MainWindow.__init__.
    
    This allows us complete control over all aspects of the startup process.

    This method is based on pyzo code
    Copyright (C) 2013-2018 by Almar Klein.
    
    '''
    #
    # pylint: disable=non-parent-init-called, super-init-not-called
    QtWidgets.QMainWindow.__init__(self, parent)
        #
        # Do **not** call MainWindow.__init__: it calls _populate!
        #
    self.monkey_patch_leo()
    pyzo.loadConfig()
        # To be replaced by LeoPyzoConfig.loadConfig.
    self._closeflag = 0
        # Used during closing/restarting
    #
    # Init window title and application icon
    # Set title to something nice. On Ubuntu 12.10 this text is what
    # is being shown at the fancy title bar (since it's not properly
    # updated)
    self.setWindowTitle('Leo Main Window')
    pyzo.core.main.loadAppIcons()
    g.app.gui.attachLeoIcon(self)
    #
    # Restore window geometry before drawing for the first time.
    self.resize(800, 600) # default size
    self.restoreGeometry()
    #
    # This just slows down the initial draw.
        # self.setCentralWidget(SplashShim(parent))
    #
    # These do nothing, even when use_shell is True.
        # self.setStyleSheet("QMainWindow { background-color: #268bd2;}")
        # self.setStyleSheet("QMainWindow { background-color: red;}")
    #
    # Show empty window and disable updates for a while
    if self.initial_draw:
        self.show()
        self.paintNow()
    self.setUpdatesEnabled(False)
    #
    # Set locale of main widget, for translate.
    if locale:
        self.setLocale(locale)
    #
    # Store myself
    pyzo.main = self
    #
    # Init dockwidget settings
    self.setTabPosition(QtCore.Qt.AllDockWidgetAreas, QtWidgets.QTabWidget.South)
    self.setDockOptions(
            QtWidgets.QMainWindow.AllowNestedDocks |
            QtWidgets.QMainWindow.AllowTabbedDocks
            #|  QtWidgets.QMainWindow.AnimatedDocks
        )
    #
    # Set window atrributes
    self.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips, True)
    #
    # Load pyzo icons and fonts.
    pyzo.core.main.loadIcons()
    pyzo.core.main.loadFonts()
    #
    # Set qt style and test success
    self.setQtStyle(None) # None means init!
    #    
    # Populate the window (imports more code)
    self._populate()
    #
    # Revert to normal background, and enable updates
    self.setStyleSheet('')
        # Required.
    self.setUpdatesEnabled(True)
    #
    # Restore window state, force updating, and restore again
    self.restoreState()
    if not self.initial_draw:
        self.show()
    self.paintNow()
    self.restoreState()
    #
    # Create new shell config if there is None
    if not pyzo.config.shellConfigs2:
        from pyzo.core.kernelbroker import KernelInfo
        pyzo.config.shellConfigs2.append( KernelInfo() )
    #
    # EKR: Set background.
    if getattr(pyzo.config.settings, 'dark_theme', None):
        bg = getattr(pyzo.config.settings, 'dark_background', '#657b83')
            # Default: solarized base00
        try:
            self.setStyleSheet("background: %s" % bg) 
        except Exception:
            g.pr('oops: MainWindow.__init__')
    #
    # Put the focus on editor
    e = pyzo.editors.getCurrentEditor()
    if e is not None:
        e.setFocus()
    #
    # Handle any actions
    pyzo.core.commandline.handle_cmd_args()
</t>
<t tx="ekr.20190317084647.3">def _populate(self):
    '''
    This method is based on pyzo code
    Copyright (C) 2013-2018 by Almar Klein.
    '''
    
    trace = False and g.pyzo_trace_imports

    # Delayed imports, exactly as in MainWindow._populate.
    if trace:
        g.pr('\n===== MainWindowShim._populate\n')
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager
    if trace:
        g.pr('\n===== MainWindowShim._populate: end of delayed imports\n')
        g.pr('initial_draw:', self.initial_draw)
        g.pr('    use_menu:', self.use_menu)
        g.pr('   use_shell:', self.use_shell)
    #
    # Instantiate tool manager
    pyzo.toolManager = ToolManager()
    #
    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()
    #
    # Create editor stack and make the central widget
    pyzo.editors = EditorTabs(self)
    self.setCentralWidget(pyzo.editors)
    #
    # Create floater for shell
    self._shellDock = dock = QtWidgets.QDockWidget(self)
    if pyzo.config.settings.allowFloatingShell:
        dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
    else:
        dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
    dock.setWindowTitle('Shells')
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)
    #
    # Create shell stack
    if self.use_shell:
        # Disabling the shell works.
        pyzo.shells = ShellStackWidget(self)
        dock.setWidget(pyzo.shells)
        pyzo.shells.menu = g.TracingNullObject(tag='pyzo.shells.menu')
            # To suppress menu events.
    else:
        pyzo.shells = g.TracingNullObject(tag='pyzo.shells')
    #
    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')
    #
    # Create the default shell when returning to the event queue
    if self.use_shell:
        pyzo.core.main.callLater(pyzo.shells.addShell)
    #
    # Create statusbar
    if pyzo.config.view.showStatusbar:
        pyzo.status = self.statusBar()
    else:
        pyzo.status = None
        self.setStatusBar(None)
    #
    # Create the menu.
    if self.use_menu:
        from pyzo.core import menu
        pyzo.keyMapper = menu.KeyMapper()
        assert not isinstance(pyzo.keyMapper, (g.TracingNullObject, g.NullObject))
            # This should not be a Shim.
        menu.buildMenus(self.menuBar())
        pyzo.editors.addContextMenu()
        pyzo.shells.addContextMenu()
    else:
        # Shim:
        pyzo.shells = g.TracingNullObject(tag='pyzo.shells')
        pyzo.keyMapper = g.TracingNullObject(tag='pyzo.keyMapper')
        
        from pyzo.core.shellStack import ShellStackWidget
        
        def null_menu_callback(*args, **kwargs):
            pass # g.trace(args, kwargs)
            
        # Apparently, doing nothing prevents the Shell from warming up.
        # For now, use_shell sets use_menu.
        assert not self.use_shell
        g.funcToMethod(null_menu_callback, ShellStackWidget, name='onShellStateChange')
        g.funcToMethod(null_menu_callback, ShellStackWidget, name='onShellDebugStateChange')
    #
    # Load tools
    if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
        pyzo.toolManager.loadTool('pyzosourcestructure')
        pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
    elif pyzo.config.state.loadedTools:
        for toolId in pyzo.config.state.loadedTools:
            pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190317084647.5">def closeEvent(self, event):
    """ Override close event handler. """
    import pyzo.core.commandline as commandline
    
    g.pr('\nMainWindowShim.closeEvent 1')
    
    t1 = time.clock()

    # Are we restaring?
    ### restarting = time.time() - self._closeflag &lt; 1.0

    # Save settings
    pyzo.saveConfig()
    pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    result = pyzo.editors.closeAll()
    if not result:
        self._closeflag = False
        event.ignore()
        return
    else:
        self._closeflag = True
        
    t2 = time.clock()

    # Proceed with closing shells
    pyzo.localKernelManager.terminateAll() # pylint: disable=no-member
    for shell in pyzo.shells:
        shell._context.close()
        
    t3 = time.clock()

    # Close tools
    for toolname in pyzo.toolManager.getLoadedTools():
        tool = pyzo.toolManager.getTool(toolname)
        tool.close()
        
    t4 = time.clock()

    # Stop all threads (this should really only be daemon threads)
    import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass
                
    t5 = time.clock()

    if 1: # EKR
        g.pr('\nMainWindowShim.closeEvent 2')
        g.pr('stage 1:          %5.2f' % (t2-t1))
        g.pr('stage 2: shells:  %5.2f' % (t3-t2))
        g.pr('stage 3: tools:   %5.2f' % (t4-t3))
        g.pr('stage 4: threads: %5.2f' % (t5-t4))

    # Proceed as normal
    QtWidgets.QMainWindow.closeEvent(self, event)

    # Harder exit to prevent segfault. Not really a solution,
    # but it does the job until Pyside gets fixed.
    if sys.version_info &gt;= (3,3,0): # and not restarting:
        if hasattr(os, '_exit'):
            os._exit(0)
</t>
<t tx="ekr.20190319022339.1"></t>
<t tx="ekr.20190319024244.1">@language rest
@wrap
@nosearch

Leo starts up with only one main window. All changes marked with g.pyzo:

- DynamicWindow is an Object, not a QMainWindow.
- Disabled some code in dw.createPyzoWindow.
- Disabled dw.setMainWindowOptions.

The following changes are experimental:
- Set dw.leo_master to a g.TracingNullObject.
- Disabled c.frame.top logic.
- Disabled LeoQtFrame.deiconify
- Removed most code in TabbedFrameFactory.createFrame.

The various frame ratios will probably go away:
- Disabled the LeoQtFrame ratio and secondary_ratio properties.
- Disabled qtFrame.resizePanesToRatio.
- Disabled dw.setGeometry.

All of the free_layout plugin will probably go away:
- Disabled FreeLayoutController.get_top_splitter.
</t>
<t tx="ekr.20190319150024.1">@language rest

https://github.com/leo-editor/leo-editor/issues/568

@language python
@nosearch
</t>
<t tx="ekr.20190322082533.1">def get_lexer(self, language):
    '''Return the lexer for self.language, creating it if necessary.'''
    import pygments.lexers as lexers
    trace = 'coloring' in g.app.debug and not g.unitTesting
    try:
        if language == 'python':
            lexer_language = 'python3'
        lexer = lexers.get_lexer_by_name(lexer_language)
    except Exception:
        # pylint: disable=no-member
            # One of the lexer's will not exist.
        if trace:
            ('--trace-coloring: no lexer for %r' % language)
        lexer = lexers.Python3Lexer()
        if trace and 'python' not in self.lexers_dict:
            g.trace('--trace-coloring: default lexer for python: %r' % lexer)
    return lexer
</t>
<t tx="ekr.20190322094034.1">def patch_lexer(self, language, lexer):
    
    from pygments.token import Comment
    from pygments.lexer import inherit
    
    class PatchedLexer(lexer.__class__):

        wimpy_regex = sys.version_info &lt; (3, 6, 0)
        
        leo_sec_ref_pat = r'\&lt;\&lt;(.*?)\&gt;\&gt;' if wimpy_regex else r'(?-m:\&lt;\&lt;(.*?)\&gt;\&gt;)'
            # Multiline for Python 2, and less than 3.6, but that can't be helped.

        tokens = {
            'root': [
                (r'^@(color|nocolor|killcolor)\b', self.at_color_callback),
                (r'^(@language)\s+(\w+)', self.at_language_callback),
                (leo_sec_ref_pat, self.section_ref_callback),
                    # Single-line, non-greedy match.
                (r'(^\s*@doc|@)(\s+|\n)(.|\n)*?^@c', Comment.Leo.DocPart),
                    # Multi-line, non-greedy match.
               inherit,
            ],
        }

    try:
        return PatchedLexer()
    except Exception:
        g.trace('can not patch %r' % language)
        g.es_exception()
        return lexer
</t>
<t tx="ekr.20190323034724.1">g.cls()
import leo.core.leoColorizer as leoColorizer
print('       has pygments:', bool(leoColorizer.pygments))
print('       use-pygments:', c.config.getBool('use-pygments'))
print('use-pygments-styles:', c.config.getBool('use-pygments-styles'))
print('pygments-style-name:', c.config.getString('pygments-style-name'))
if 0:
    # The performance bug was in pyg_c.recolor.
    # It was calling updateSyntaxColorer(p) for each line!!!
    colorizer = c.frame.body.colorizer
    print('recolorCount:', colorizer.recolorCount)
    print('tot_time: %5.2f' % colorizer.tot_time)
    colorizer.recolorCount = 0
</t>
<t tx="ekr.20190323045735.1">def at_language_callback(self, lexer, match):
    from pygments.token import Name
    language = match.group(2)
    ok = self.init_mode(language)
    if ok:
        self.language = language
        yield match.start(), Name.Decorator, match.group(0)
    else:
        yield match.start(), Name.Decorator, match.group(1)
            # Color only the @language, indicating an unknown language.
</t>
<t tx="ekr.20190323084212.1"></t>
<t tx="ekr.20190324051704.1">def reloadSettings(self):
    '''Reload the base settings, plus pygments settings.'''
    if 'coloring' in g.app.debug and not g.unitTesting:
        print('reloading pygments settings.')
    # Do basic inits.
    BaseJEditColorizer.reloadSettings(self)
    # Bind methods.
    if self.use_pygments_styles:
        self.getDefaultFormat = QtGui.QTextCharFormat
        self.getFormat = self.getPygmentsFormat
        self.setFormat = self.setPygmentsFormat
    else:
        self.getDefaultFormat = self.getLegacyDefaultFormat
        self.getFormat = self.getLegacyFormat
        self.setFormat = self.setLegacyFormat
    # Init everything else.
    self.init_style_ivars()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
    self.init()
</t>
<t tx="ekr.20190324172242.1">def configure_fonts(self):
    '''Configure all fonts in the default fonts dict.'''
    c = self.c
    isQt = g.app.gui.guiName().startswith('qt')
    wrapper = self.wrapper
    #
    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant", "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont
    #
    # Set all fonts.
    for key in sorted(self.default_font_dict.keys()):
        option_name = self.default_font_dict[key]
        # Find language specific setting before general setting.
        table = (
            '%s_%s' % (self.language, option_name), 
            option_name,
        )
        for name in table:
            font = self.fonts.get(name)
            if font:
                break
            font = self.find_font(key, name)
            if font:
                self.fonts[key] = font
                wrapper.tag_configure(key, font=font)
                if isQt and key == 'url':
                    font.setUnderline(True)
                break
        else:
            # Neither setting exists.
            self.fonts[key] = None # Essential
            wrapper.tag_configure(key, font=defaultBodyfont)
</t>
<t tx="ekr.20190324172632.1">def configure_colors(self):
    '''Configure all colors in the default colors dict.'''
    c, wrapper = self.c, self.wrapper
    getColor = c.config.getColor
        # getColor puts the color name in standard form:
        # color = color.replace(' ', '').lower().strip()
    for key in sorted(self.default_colors_dict.keys()):
        option_name, default_color = self.default_colors_dict[key]
        color = (
            getColor('%s_%s' % (self.language, option_name)) or
            getColor(option_name) or default_color)
        # Must use foreground, not fg.
        try:
            wrapper.tag_configure(key, foreground=color)
        except Exception: # Recover after a user settings error.
            g.es_exception()
            wrapper.tag_configure(key, foreground=default_color)

</t>
<t tx="ekr.20190324192318.1">from  leo.core.leoColor import leo_color_database as color_d

d = {
    'Comment':            'solarized-orange',
    'Comment.Single':     'solarized-orange',
    'Generic.Deleted':    'solarized-red',
    'Generic.Emph':       'solarized-blue',
    'Generic.Heading':    'solarized-magenta',
    'Generic.Inserted':   'alt-solarized-green',
    'Generic.Strong':     'solarized-blue',
    'Generic.Subheading': 'solarized-magenta',
    'Keyword':            'solarized-blue',
    'Name':               'white',
    'Name.Class':         'white',
    'Name.Decorator':     'solarized-orange',
    'Name.Entity':        'solarized-blue',
    'Name.Function':      'white',
    'Name.Other':         'solarized-red',
    'Name.Tag':           'solarized-magenta',
    'String':             'alt-solarized-green',
    'String.Doc':         'solarized-orange', # docstring.
    'String.Interpol':    'alt-solarized-green',
    'String.Single':      'alt-solarized-green',
}
root = p.copy()
for key, val in d.items():
    p = root.insertAsLastChild()
    p.h = '@color %s = %s' % (key.lower(), color_d.get(val, 'white'))
    p.b = val
c.redraw()
    </t>
<t tx="ekr.20190325053636.1">Comment:            'italic'
Name.Other:         'underline'
Generic.Emph:       'italic '
Generic.Heading:    'underline ' 
Generic.Strong:     'bold '
Name.Tag:           'italic '
</t>
<t tx="ekr.20190326034006.1">def find_font(self, key, setting_name):
    '''
    Return the font for the given setting name.
    Key is for debugging only.
    '''
    c, get = self.c, self.c.config.get
    for name in (setting_name, setting_name.rstrip('_font')):
        family = get(name + '_family', 'family')
        size   = get(name + '_size', 'size')
        slant  = get(name + '_slant', 'slant')
        weight = get(name + '_weight', 'weight')
        if family or slant or weight or size:
            family = family or g.app.config.defaultFontFamily
            size = size or c.config.defaultBodyFontSize
                # It's almost certainly a good idea to set size explicitly.
            slant = slant or 'roman'
            weight = weight or 'normal'
            font = g.app.gui.getFontFromParams(family, size, slant, weight)
            # A good trace: the key shows what is happening.
                # g.trace('%20s %5s %20s %10s %5s %6s %s' % (
                    # key, bool(font), setting_name, family, size, slant, weight))
            return font
    return None
</t>
<t tx="ekr.20190326131804.1">@language rest
@wrap

- Define jedit.reloadSettings.
  jedit.__init__ should call it to do last inits.
  
- jpg_c sould call reloadSettings.</t>
<t tx="ekr.20190326174530.1"></t>
<t tx="ekr.20190326182642.1"></t>
<t tx="ekr.20190326183005.1">def reloadSettings(self):
    '''Complete the initialization of all settings.'''
    if 'coloring' in g.app.debug and not g.unitTesting:
        print('reloading jEdit settings.')
    # Do the basic inits.
    BaseJEditColorizer.reloadSettings(self)
    # Init everything else.
    self.init_style_ivars()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
    self.init()
    
</t>
<t tx="ekr.20190327052228.1">def reloadSettings(self):
    '''Reload all reloadable settings.'''
    c, document = self.c, self.leo_document
    if not pygments:
        return
    if not c.config.getBool('use-pygments', default=False):
        return
    #
    # Init pygments ivars.
    self._brushes = {}
    self._document = document
    self._formats = {}
    self.colorizer.style_name = 'default'
    style_name = c.config.getString('pygments-style-name') or 'default'
        # Style gallery: https://help.farbox.com/pygments.html
        # Dark styles: fruity, monokai, native, vim
        # https://github.com/gthank/solarized-dark-pygments
    if not c.config.getBool('use-pygments-styles', default=True):
        return
    #
    # Init pygments style.
    try:
        self.setStyle(style_name)
        # print('using %r pygments style in %r' % (style_name, c.shortFileName()))
    except Exception:
        print('pygments %r style not found. Using "default" style' % style_name)
        self.setStyle('default')
        style_name = 'default'
    self.colorizer.style_name = style_name
    assert self._style
</t>
<t tx="ekr.20190327053604.1">prev_use_pygments = None
prev_use_styles = None
prev_style = None

def report_changes(self):
    '''Report changes to pygments settings'''
    c = self.c
    trace = 'coloring' in g.app.debug and not g.unitTesting
    if trace:
        g.es_print('\n--trace-coloring...')
        
    def show(setting, val):
        if trace:
            g.es_print('%35s: %s' % (setting, val))
    #
    # Set self.use_pygments only once: it can't be changed later.
    # There is no easy way to re-instantiate classes created by make_colorizer.
    use_pygments = c.config.getBool('use-pygments', default=False)
    if self.prev_use_pygments is None:
        self.use_pygments = self.prev_use_pygments = use_pygments
        show('@bool use-pygments', use_pygments)
    elif use_pygments == self.prev_use_pygments:
        show('@bool use-pygments', use_pygments)
    else:
        g.es_print('%35s: %s' % (
                'Can not change @bool use-pygments',
                self.prev_use_pygments),
            color='red')
    #
    # Report everything if we are tracing.
    style_name = c.config.getString('pygments-style-name') or 'default'
        # Don't set an ivar. It's not used in this class.
        # This setting is used only in the LeoHighlighter class
    show('@bool use-pytments-styles', self.use_pygments_styles)
    show('@string pygments-style-name', style_name)
    #
    # Report other changes only if we are using pygments.
    if not use_pygments:
        if trace: print('')
        return
    #
    # Report changes to @bool use-pygments-style
    if self.prev_use_styles is None:
        self.prev_use_styles = self.use_pygments_styles
    elif self.use_pygments_styles != self.prev_use_styles:
        g.es_print('using pygments styles: %s' % self.use_pygments_styles)
    #
    # Report @string pygments-style-name only if we are using styles.
    if not self.use_pygments_styles:
        return
    #
    # Report changes to @string pygments-style-name
    if self.prev_style is None:
        self.prev_style = style_name
    elif style_name != self.prev_style:
        g.es_print('New pygments style: %s' % style_name)
        self.prev_style = style_name
</t>
<t tx="ekr.20190327064446.1">@nosearch
</t>
<t tx="ekr.20190327072744.1">@language python
</t>
<t tx="ekr.20190327105736.1">def get_files_in_directory(directory, kinds=None, recursive=True):
    '''
    Return a list of all files of the given file extensions in the directory.
    Default kinds: ['*.py'].
    '''
    files, sep = [], os.path.sep
    if not g.os.path.exists(directory):
        g.es_print('does not exist', directory)
        return files
    try:
        if kinds:
            kinds = [z if z.startswith('*') else '*'+z for z in kinds]
        else:
            kinds = ['*.py']
        if recursive:
            # Works for all versions of Python.
            import fnmatch
            for root, dirnames, filenames in os.walk(directory):
                for kind in kinds:
                    for filename in fnmatch.filter(filenames, kind):
                        files.append(os.path.join(root, filename))
        else:
            for kind in kinds:
                files.extend(glob.glob(directory + sep + kind))
        return list(set(sorted(files)))
    except Exception:
        g.es_exception()
        return []
</t>
<t tx="ekr.20190327111419.1">On Wednesday, March 27, 2019 at 9:02:20 AM UTC-5, Arjan wrote:
 

    My notes are organized in various sections -- but often I have items that belong to multiple sections, so I'd place them in both using clones.

...

    Now with over a dozen top-level sections and many more subsections and subsubsections for each, switching between different sections becomes unwieldy.


Imo, the best way to deal with this problem is to create organizer nodes for your projects and sub-projects.  I do this all the time.  There is no limit to Leo's organizational abilities, as I shall now attempt to explain.

    The solution to your clone problems is to use more clones.  No kidding.

Here is an example taken from the recent pygments work. You should be able to adapt it to any organizational task whatever.  Here are the big ideas

Organizer nodes create views of your data

For large projects, you definitely should create an organizer node any time you are going to be spending more than a few minutes of a task.  For the pygments project, the outer organizer node is:

Top level node: #0568: pygments
The body text contained my to-do list and links to #568.

Use inner organizer nodes to further organize you work

The inner organizers for my pygments project have these headlines:

----- Color settings
----- Font settings
----- Reload-settings
----- trace-coloring
----- @language directives

Each inner organizer node contains notes to myself in the body text.  Its children of clones of all nodes relating to the task.

Within organizers, clones can be "redundant"

This is something I probably haven't ever explained before.  It's a really important idea, and it's why clone problems can be solved using more clones.

Let me try to explain.  Within a programming sub-project I often want to focus on a class.  But within that class, I further want to focus on organizer nodes of the class, or individual methods of that class.

In theory, just cloning the class gives access to all the methods (and organizer nodes) within that class.  Why?  Because clones contain all their children.

So creating clones (focusing on the clones) could be called redundant.  In practice, though, these "redundant" clones are useful.

Similarly, the clone-find-all-flattened command creates "redundant" top-level nodes.  You could just use the clone-find-all command instead, but I find cff almost always to be more useful.

Two levels of organizer nodes should suffice

I have never need more levels, even for large projects such as creating a new gui for Leo.  Three levels would likely suffice for truly stupendous projects.

Organizer nodes are valuable, but not precious

Ultimately, they are temporary.  I make copies of data that should be retained indefinitely.  For example, I'll move cool new scripts to scripts.leo, and documentation to LeoDocs.leo.

Summary

Creating lots of clones can create organizational problems. The solution to those problems is to create organizer node containing more clones.

Don't be afraid of creating "redundant" clones.

Two levels of organizer nodes should suffice for even large, complex tasks.  Three levels should suffice for truly huge tasks.

Organizer nodes are valuable, but not redundant.

To make all this work, you must be adept with using clones.  In particular, you must know when deleting a clone will actually delete data.  This will quickly become second nature, but only if you give clones a chance.

Edward</t>
<t tx="ekr.20190327143118.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1101

from leo.core.leoQt import QtWidgets
log = c.frame.log
w = log.createTab('My Tab', createText=False, widget=QtWidgets.QFrame())
log.selectTab('My Tab')

@language python
</t>
<t tx="ekr.20190327194749.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1098

@language python
</t>
<t tx="ekr.20190327203238.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1090

command line--script relative path is relative to `leo/core` instead of file-system

@language python
</t>
<t tx="ekr.20190328083346.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1018

fc.setCachedBits scans *all* nodes for cached data.
This simplifies fc.compute_attribute_bits.

@language python
</t>
<t tx="ekr.20190328160622.1">def setCachedBits(self):
    '''
    Set the cached expanded and marked bits for *all* nodes.
    Also cache the current position.
    '''
    c = self.c
    current = [str(z) for z in self.currentPosition.archivedPosition()]
    expanded = [v.gnx for v in c.all_unique_nodes() if v.isExpanded()]
    marked = [v.gnx for v in c.all_unique_nodes() if v.isMarked()]
    c.db ['expanded'] = ','.join(expanded)
    c.db ['marked'] = ','.join(marked)
    c.db ['current_position'] = ','.join(current)
</t>
<t tx="ekr.20190328165019.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1100

@language python
</t>
<t tx="ekr.20190329035816.1"></t>
<t tx="ekr.20190329035854.1"></t>
<t tx="ekr.20190329040120.1"></t>
<t tx="ekr.20190329040602.1"></t>
<t tx="ekr.20190329082417.1"></t>
<t tx="ekr.20190330062625.1">def null_object_print_attr(id_, attr):
    &lt;&lt; define suppression lists &gt;&gt;
    if 0:
        tag = tracing_tags.get(id_, "&lt;NO TAG&gt;")
        callers = g.callers(3).split(',')
        callers = ','.join(callers[:-1])
        in_callers = any([z in callers for z in suppress_callers])
        s = '%s.%s' % (tag, attr)
        if 1:
            signature = '%s.%s:%s' % (tag, attr, callers)
            # Print each signature once.  No need to filter!
            if signature not in tracing_signatures:
                tracing_signatures [signature] = True
                g.pr('%40s %s' % (s, callers))
        else:
            # Filter traces.
            if not in_callers and s not in suppress_attrs:
                g.pr('%40s %s' % (s, callers))
</t>
<t tx="ekr.20190330072026.1">suppress_callers = (
    'drawNode', 'drawTopTree', 'drawTree',
    'contractItem', 'getCurrentItem',
    'declutter_node',
    'finishCreate',
    'initAfterLoad',
    'show_tips',
    'writeWaitingLog',
    # 'set_focus', 'show_tips',
)
suppress_attrs = (
    # Leo...
    'c.frame.body.wrapper',
    'c.frame.getIconBar.add',
    'c.frame.log.createTab',
    'c.frame.log.enable',
    'c.frame.log.finishCreate',
    'c.frame.menu.createMenuBar',
    'c.frame.menu.finishCreate',
    'c.frame.menu.getMenu',
    'currentItem',
    'dw.leo_master.windowTitle',
    # Pyzo...
    'pyzo.keyMapper.connect',
    'pyzo.keyMapper.keyMappingChanged',
    'pyzo.keyMapper.setShortcut',
)
</t>
<t tx="ekr.20190330072832.1">def null_object_print(id_, kind):
    tag = tracing_tags.get(id_, "&lt;NO TAG&gt;")
    callers = g.callers(3).split(',')
    callers = ','.join(callers[:-1])
    s = '%s.%s' % (kind, tag)
    signature = '%s:%s' % (s, callers)
    if 0:
        # Always print:
        g.pr('%40s %s' % (s, callers))
    elif signature not in tracing_signatures:
        # Print each signature once.
        tracing_signatures [signature] = True
        g.pr('%40s %s' % (s, callers))
</t>
<t tx="ekr.20190330115531.1"># It probably should not be a zon dict!
</t>
<t tx="ekr.20190331032906.1">@language rest
@wrap

- TabbedFrameFactory.createMaster created the duplicate frame.
  It sets self.masterFrame to None when g.pyzo is True

- Added a guard to TabbedFrameFactory.setTabForCommander.

@language python
@nosearch</t>
<t tx="ekr.20190331040800.42">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -1,5 +1,8 @@
 def setTabForCommander(self, c):
+    
     tabw = self.masterFrame # a QTabWidget
+    if not tabw:
+        return ### pyzo support.
     for dw in self.leoFrames: # A dict whose keys are DynamicWindows.
         if dw.leo_c == c:
             for i in range(tabw.count()):
@language python
</t>
<t tx="ekr.20190331040800.43">def setTabForCommander(self, c):
    tabw = self.masterFrame # a QTabWidget
    for dw in self.leoFrames: # A dict whose keys are DynamicWindows.
        if dw.leo_c == c:
            for i in range(tabw.count()):
                if tabw.widget(i) == dw:
                    tabw.setCurrentIndex(i)
                    break
            break
</t>
<t tx="ekr.20190331044953.1">@language rest
@wrap

Fixed three hangnails, which were actually serious worries:

- duplicate imports of pyzo.tools.pyzoFileBrowser
- Very annoying flash in the pyzo window,
- Duplicate uplicate calls to MainWindowShim._populate.

Calling the base MainWindow.__init__ from MainWindowShim.__init__ is WRONG,
because MainWindowShim.__init__ contains a *copy* of the MainWindow.__init__ code!

So everything happened twice.

@language python
</t>
<t tx="ekr.20190331052251.1">@others
</t>
<t tx="ekr.20190331052308.1">@others
</t>
<t tx="ekr.20190331052308.2">def __repr__(self):
    
    return 'ConfigShim'
    # return g.obj2string(self)
        # Can't do this: it calls repr!
</t>
<t tx="ekr.20190331052308.3">def __getattribute__(self, key):
    '''The usual shinanigans...'''
    ### return object.__getattribute__(self, key)
    try:
        val = object.__getattribute__(self, key)
    except AttributeError:
        if key in self:
            val = self[key]
        else:
            raise
    if key not in config_shim_seen:
        config_shim_seen [key] = True
        g.pr('\n===== ConfigShim.__getattribute__', key, val)
    return val
</t>
<t tx="ekr.20190331052308.4"># def __setattr__(self, key, val):
    # if key in Dict.__reserved_names__:
        # # Either let OrderedDict do its work, or disallow
        # if key not in Dict.__pure_names__:
            # return _dict.__setattr__(self, key, val)
        # else:
            # raise AttributeError('Reserved name, this key can only ' +
                                 # 'be set via ``d[%r] = X``' % key)
    # else:
        # # if isinstance(val, dict): val = Dict(val) -&gt; no, makes a copy!
        # self[key] = val
</t>
<t tx="ekr.20190331082353.1"># '(\w+)': With: \1 = 

advanced = g.Bunch(
    autoCompDelay=200,
    fileExtensionsToLoadFromDir='py,pyw,pyx,txt,bat',
    find_autoHide_timeout=10,
    homeAndEndWorkOnDisplayedLine=0,
    shellMaxLines=10000,
    titleText='{fileName} ({fullPath}) - Interactive Editor for Python',
)

settings = g.Bunch(   
    allowFloatingShell=0,
    autoCallTip=1,
    autoClose_Brackets=1,
    autoClose_Quotes=1,
    autoComplete=1,
    autoComplete_acceptKeys='Tab',
    autoComplete_caseSensitive=0,
    autoComplete_fillups='\n',
    autoComplete_keywords=1,
    autoIndent=1,
    changeDirOnFileExec=0,
    defaultIndentUsingSpaces=1,
    defaultIndentWidth=4,
    defaultLineEndings='CRLF',
    defaultStyle='python',
    justificationWidth=70,
    language='English (US)',
    removeTrailingWhitespaceWhenSaving=0,
)

shellConfigs2 = [
    g.Bunch(
        argv = '',
        environ = '',
        exe = 'c:\\anaconda3\\python.exe',
        gui = 'auto',
        ipython = 'yes',
        name = 'Python',
        projectPath = '',
        pythonPath = '',
        scriptFile = '',
        startDir = '',
        startupScript = '',
        )
]

shortcuts2 = g.bunch(
    &lt;&lt; define bunch shortcuts2 &gt;&gt;
)

state = g.Bunch(
    editorState2=[
        &lt;&lt; define editorState2 &gt;&gt;
    ],
    find_autoHide=1,
    find_matchCase=0,
    find_regExp=0,
    find_show=0,
    find_wholeWord=1,
    loadedTools=['pyzofilebrowser', 'pyzologger', 'pyzosourcestructure'],
    newUser=1,
    windowGeometry='AdnQywACAAAAAAGjAAAA2AAABv0AAANWAAABqwAAAPcAAAb1AAADTgAAAAAAAAAAB4A=\n',
    windowState=(
        'AAAA/wAAAAD9AAAAAgAAAAAAAACeAAACRPwCAAAAAfwAAAAUAAACRAAAAYgA/////AIAAAAC+wAA\n'
        'AB4AcAB5AHoAbwBmAGkAbABlAGIAcgBvAHcAcwBlAHIBAAAAFAAAAWEAAAEIAP////sAAAAmAHAA\n'
        'eQB6AG8AcwBvAHUAcgBjAGUAcwB0AHIAdQBjAHQAdQByAGUBAAABewAAAN0AAAB6AP///wAAAAEA\n'
        'AAGEAAACRPwCAAAABvsAAAAMAHMAaABlAGwAbABzAQAAABQAAAD/AAAAcwD////7AAAAFABwAHkA\n'
        'egBvAGwAbwBnAGcAZQByAQAAARkAAAE/AAAAWQD////7AAAAGgBwAHkAegBvAHcAbwByAGsAcwBw\n'
        'AGEAYwBlAAAAAT4AAAEaAAAAAAAAAAD7AAAAJgBwAHkAegBvAGkAbgB0AGUAcgBhAGMAdABpAHYA\n'
        'ZQBoAGUAbABwAAAAAnkAAAB6AAAAAAAAAAD7AAAAIgBwAHkAegBvAGgAaQBzAHQAbwByAHkAdgBp\n'
        'AGUAdwBlAHIAAAACGgAAAVsAAAAAAAAAAPsAAAAcAHAAeQB6AG8AdwBlAGIAYgByAG8AdwBzAGUA\n'
        'cgAAAAKwAAAAxQAAAAAAAAAAAAADHQAAAkQAAAAEAAAABAAAAAgAAAAI/AAAAAA=\n'
    )
)

tools = g.Bunch(
    pyzofilebrowser = g.Bunch(),
    pyzofilebrowser2 = g.Bunch(
        expandedDirs = ['c:\\apps\\pyzo\\source\\pyzo'],
        nameFilter = '!*.pyc',
        path = 'c:\\apps\\pyzo\\source\\pyzo',
        searchMatchCase = 0,
        searchRegExp = 0,
        searchSubDirs = 1,
        starredDirs =[
            g.Bunch(
                addToPythonpath = 0,
                name = 'Pyzo sources',
                path = 'c:\\apps\\pyzo\\source',
            )
        ]
    ),
    pyzohistoryviewer = g.Bunch(),
    pyzointeractivehelp = g.Bunch(
        fontSize = 14,
        noNewlines = 1,
        smartNewlines = 1
    ),
    pyzologger = g.Bunch(),
    pyzosourcestructure = g.Bunch(
        level = 1,
        showTypes = ['class', 'def', 'cell', 'todo'],
    ),
    pyzowebbrowser = g.Bunch(
        bookMarks = [
            'docs.python.org',
            'scipy.org',
            'doc.qt.nokia.com/4.5/',
            'pyzo.org',
        ],
        zoomFactor = 1.0,
    ),
    pyzoworkspace = g.Bunch(
        hideTypes = [],
        typeTranslation = g.Bunch(
            builtin_function_or_method = 'function',
            method = 'function'
        )
    )
) 

view = g.Bunch(
    autoComplete_popupSize=[300, 100],
    codeFolding=0,
    doBraceMatch=1,
    edgeColumn=80,
    fontname='DejaVu Sans Mono',
    highlightCurrentLine=1,
    highlightMatchingBracket=1,
    qtstyle='fusion',
    showIndentationGuides=1,
    showLineEndings=0,
    showStatusbar=0,
    showWhitespace=0,
    showWrapSymbols=0,
    tabWidth=4,
    wrap=1,
    zoom=2
)
</t>
<t tx="ekr.20190331082353.2">[
    'C:\\apps\\pyzo\\source\\pyzo\\codeeditor\\highlighter.py',
    3279,
    96
],
[
    'C:\\apps\\pyzo\\source\\pyzo\\core\\editorTabs.py',
    22913,
    693
],
[
    'C:\\apps\\pyzo\\source\\pyzo\\codeeditor\\highlighter.py',
    'hist'
],
[
    'C:\\apps\\pyzo\\source\\pyzo\\core\\editorTabs.py',
    'hist'
]
</t>
<t tx="ekr.20190331082549.1">edit__comment = 'Ctrl+R,',
edit__copy = 'Ctrl+C,Ctrl+Insert',
edit__cut = 'Ctrl+X,Shift+Delete',
edit__dedent = 'Shift+Tab,',
edit__delete_line = 'Ctrl+D,',
edit__duplicate_line = 'Ctrl+Shift+D,',
edit__find_next = 'Ctrl+G,F3',
edit__find_or_replace = 'Ctrl+F,',
edit__find_previous = 'Ctrl+Shift+G,Shift+F3',
edit__find_selection = 'Ctrl+F3,',
edit__find_selection_backward = 'Ctrl+Shift+F3,',
edit__indent = 'Tab,',
edit__justify_commentdocstring = 'Ctrl+J,',
edit__paste = 'Ctrl+V,Shift+Insert',
edit__paste_and_select = 'Ctrl+Shift+V',
edit__redo = 'Ctrl+Y,',
edit__select_all = 'Ctrl+A,',
edit__toggle_breakpoint = 'Ctrl+B,',
edit__uncomment = 'Ctrl+T,',
edit__undo = 'Ctrl+Z,',
file__close = 'Ctrl+W,',
file__new = 'Ctrl+N,',
file__open = 'Ctrl+O,',
file__save = 'Ctrl+S,',
run__execute_cell = 'Ctrl+Return,Ctrl+Enter',
run__execute_cell_and_advance = 'Ctrl+Shift+Return,Ctrl+Shift+Enter',
run__execute_file = 'Ctrl+E,F5',
run__execute_main_file = 'Ctrl+M,F6',
run__execute_selection = 'Alt+Return,F9',
run__execute_selection_and_advance = 'Shift+F9,Shift+Alt+Return',
run__run_file_as_script = 'Ctrl+Shift+E,Ctrl+F5',
run__run_main_file_as_script = 'Ctrl+Shift+M,Ctrl+F6',
shell__clear_screen = 'Ctrl+L,',
shell__close = 'Alt+K,',
shell__create_shell_1_ = 'Ctrl+1,',
shell__create_shell_2_ = 'Ctrl+2,',
shell__create_shell_3_ = 'Ctrl+3,',
shell__create_shell_4_ = 'Ctrl+4,',
shell__create_shell_5_ = 'Ctrl+5,',
shell__create_shell_6_ = 'Ctrl+6,',
shell__create_shell_7_ = 'Ctrl+7,',
shell__create_shell_8_ = 'Ctrl+8,',
shell__interrupt = 'Ctrl+I,Meta+C',
shell__postmortem_debug_from_last_traceback = 'Ctrl+P,',
shell__restart = 'Ctrl+K,',
shell__terminate = 'Ctrl+Shift+K,',
view__select_editor = 'Ctrl+9,F2',
view__select_previous_file = 'Ctrl+Tab,',
view__select_shell = 'Ctrl+0,F1',
view__zooming__zoom_in = 'Ctrl+=,Ctrl++',
view__zooming__zoom_out = 'Ctrl+-,',
view__zooming__zoom_reset = 'Ctrl+\\,'
</t>
<t tx="ekr.20190331164202.1"></t>
<t tx="ekr.20190331165128.1"></t>
<t tx="ekr.20190331182937.1"></t>
<t tx="ekr.20190401072835.1"></t>
<t tx="ekr.20190401075911.1">@first # -*- coding: utf-8 -*-

'''A pyzo-compatible tool widget containing Leo's outline.'''

tool_name = 'Leo Outline'
tool_summary = 'Leo Outline'

from leo.core.leoQt import QtWidgets

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20190401080432.1">class PyzoOutlineTool(QtWidgets.QWidget):
    pass
</t>
<t tx="ekr.20190401081245.1">def __init__(self, parent):
    '''Create the Outline Tool pane.'''
    
    super().__init__(parent)
    
    if 0: # From PyzoHistoryViewer
        # To keep pyflakes happy...
        Menu = None
        pyzo = None 
        QtCore = None
        translate = None

        # Widgets
        self._search = QtWidgets.QLineEdit(self)
        self._list = QtWidgets.QListWidget(self)
    
        # Set monospace
        font = self._list.font()
        font.setFamily(pyzo.config.view.fontname)
        self._list.setFont(font)
    
        # Layout
        layout = QtWidgets.QVBoxLayout(self)
        self.setLayout(layout)
        layout.addWidget(self._search, 0)
        layout.addWidget(self._list, 1)
    
        # Customize line edit
        self._search.setPlaceholderText(translate('menu', 'Search'))
        self._search.textChanged.connect(self._on_search)
    
        # Drag/drop
        self._list.setSelectionMode(self._list.ExtendedSelection)
        self._list.setDragEnabled(True)
        self._list.doubleClicked.connect(self._onDoubleClicked)
    
        # Context menu
        self._menu = Menu(self, translate("menu", "History"))
        self._menu.addItem(translate("menu", "Copy ::: Copy selected lines"),
            pyzo.icons.page_white_copy, self.copy, "copy")
        self._menu.addItem(translate("menu", "Run ::: Run selected lines in current shell"),
            pyzo.icons.run_lines, self.runSelection, "run")
        self._menu.addItem(translate("menu", "Remove ::: Remove selected history items(s)"),
            pyzo.icons.delete, self.removeSelection, "remove")
    
        self._list.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self._list.customContextMenuRequested.connect(self._onCustomContextMenuRequested)
    
        # Populate
        for command in pyzo.command_history.get_commands():
            self._list.addItem(command)
    
        # Scroll to end of list on start up
        self._list.setCurrentRow(self._list.count()-1)
        item = self._list.currentItem()
        self._list.scrollToItem(item)
    
        # Keep up to date ...
        pyzo.command_history.command_added.connect(self._on_command_added)
        pyzo.command_history.command_removed.connect(self._on_command_removed)
        pyzo.command_history.commands_reset.connect(self._on_commands_reset)
</t>
<t tx="ekr.20190401085747.1">&lt;&lt; shim classes for OutlineEditorShim &gt;&gt;

from pyzo.codeeditor import CodeEditorBase
assert CodeEditorBase
QAbstractScrollArea = QtWidgets.QAbstractScrollArea

class OutlineEditorShim(QtWidgets.QFrame):
    # QtWidgets.QAbstractScrollArea: placed properly?
    # QtWidgets.QFrame isn't placed properly!
    # Was pyzo.core.editor.PyzoEditor

    somethingChanged = Signal()
    blockCountChanged = Signal()
    breakPointsChanged = Signal()
    
    @others
    
</t>
<t tx="ekr.20190402091335.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_revs(
    rev1='263fcc0bcc20ef5', # good
    rev2='2a307cf4a625105a', # bad, present rev.
    directory=None,
)
</t>
<t tx="ekr.20190402102243.1"># The shell never warms up if there are no menus.
# So for now just force use_menu to True.
</t>
<t tx="ekr.20190402104228.1">initial_draw = False
    # True: do an initial draw. Works either way.
use_shell = False
    # There is no great flash when use_shell is True.
use_menu = False
#
# The shell never warms up if there are no menus.
# So for now just force use_menu to True.
if use_shell and not use_menu:
    g.pr('\nMainWindowShim: use_shell sets use_menu = True\n')
    use_menu = True
</t>
<t tx="ekr.20190402143146.1"></t>
<t tx="ekr.20190404110730.1"># Monkey-patch pyzo.core.editor.createEditor

from pyzo.codeeditor import Manager
from pyzo.core.menu import EditorContextMenu
from pyzo.core.baseTextCtrl import BaseTextCtrl, normalizePath
from pyzo.core.pyzoLogging import print  # noqa
import pyzo

def createEditor(parent, filename=None):
    """
    Tries to load the file given by the filename and
    if succesful, creates an editor instance to put it in,
    which is returned.

    If filename is None, an new/unsaved/temp file is created.
    """
    
    g.trace('pyzo_shims.py: %s\n' % filename)

    if filename is None:
        # Increase counter
        global newFileCounter
        newFileCounter  += 1
        # Create editor
        editor = PyzoEditor(parent)
        editor.document().setModified(True)
        # Set name
        editor._name = "&lt;tmp {}&gt;".format(newFileCounter)
    elif g.pyzo and g.pyzo_patch and filename.endswith('.leo'):
        from leo.core.pyzo_shims import OutlineEditorShim
        &lt;&lt; createEditor patch &gt;&gt;
        return editor
    else:
        # check and normalize
        if not os.path.isfile(filename):
            raise IOError("File does not exist '%s'." % filename)
        # load file (as bytes)
        with open(filename, 'rb') as f:
            bb = f.read()
            f.close()
        # convert to text, be gentle with files not encoded with utf-8
        encoding = determineEncoding(bb)
        text = bb.decode(encoding,'replace')

        # process line endings
        lineEndings = determineLineEnding(text)

        # if we got here safely ...

        # create editor and set text
        editor = PyzoEditor(parent)
        editor.setPlainText(text)
        editor.lineEndings = lineEndings
        editor.encoding = encoding
        editor.document().setModified(False)

        # store name and filename
        editor._filename = filename
        editor._name = os.path.split(filename)[1]

        # process indentation
        indentWidth = determineIndentation(text)
        if indentWidth == -1: #Tabs
            editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
            editor.setIndentUsingSpaces(False)
        elif indentWidth:
            editor.setIndentWidth(indentWidth)
            editor.setIndentUsingSpaces(True)

    if editor._filename:
        editor._modifyTime = os.path.getmtime(editor._filename)

    # Set parser
    if editor._filename:
        ext = os.path.splitext(editor._filename)[1]
        parser = Manager.suggestParser(ext, text)
        editor.setParser(parser)
    else:
        # todo: rename style -&gt; parser
        editor.setParser(pyzo.config.settings.defaultStyle)

    # return
    return editor
</t>
<t tx="ekr.20190404110807.1"># check and normalize
if not os.path.isfile(filename):
    raise IOError("File does not exist '%s'." % filename)
#
# load file (as bytes)
with open(filename, 'rb') as f:
    bb = f.read()
    f.close()
    
# convert to text, be gentle with files not encoded with utf-8
encoding = determineEncoding(bb)
text = bb.decode(encoding,'replace')

# process line endings
lineEndings = determineLineEnding(text)

# if we got here safely ...

# create editor and set text
### editor = PyzoEditor(parent)
editor = OutlineEditorShim(parent) 

editor.setPlainText(text)
editor.lineEndings = lineEndings
editor.encoding = encoding
editor.document().setModified(False)

# store name and filename
editor._filename = filename
editor._name = os.path.split(filename)[1]

# process indentation
###
    # indentWidth = determineIndentation(text)
    # if indentWidth == -1: #Tabs
        # editor.setIndentWidth(pyzo.config.settings.defaultIndentWidth)
        # editor.setIndentUsingSpaces(False)
    # elif indentWidth:
        # editor.setIndentWidth(indentWidth)
        # editor.setIndentUsingSpaces(True)

if editor._filename:
    editor._modifyTime = os.path.getmtime(editor._filename)

# Set parser
###
    # if editor._filename:
        # ext = os.path.splitext(editor._filename)[1]
        # parser = Manager.suggestParser(ext, text)
        # editor.setParser(parser)
    # else:
        # # todo: rename style -&gt; parser
        # editor.setParser(pyzo.config.settings.defaultStyle)
</t>
<t tx="ekr.20190404111344.1"></t>
<t tx="ekr.20190405075322.1">def __init__(self, filename, parent, **kwargs):
    
    assert g.pyzo, g.callers()
    g.pr('\nOutlineEditorShim.__init__', g.shortFileName(filename))
    # g.printObj(g.callers(30).split(','), tag='OutlineEditorShim.__init__')
    # if filename.endswith('.leo'): g.pdb()
    super().__init__(parent, **kwargs)
        # CodeEditorBase only passes args to *its* base class.
    self.c = None # Set in createOutlineFrame.
    self._filename = self.filename = filename
        # Essential, so the tab will close properly.
    self._name = self.name = os.path.split(filename)[1]
        # To set the tab's name properly.
    if not isinstance(self, CodeEditorBase):
        g.pr('\nOutlineEditorShim: using shims')
        #
        # Needed if this is just a QWidget.
        self._breakPoints = {}
        # self.breakPointsChanged.emit(self)
        # self.__breakPointArea.update()
        self.lineEndingsHumanReadable = 'CRLF'
        self.document = DocumentShim
        self.horizontalScrollBar = ScrollBarShim
        self.parser = g.TracingNullObject(tag='OutlineEditorShim.parser')
        self.textCursor = TextCursorShim
        self.verticalScrollBar = ScrollBarShim
    # Create the outline!
    self.createOutlineFrame()
</t>
<t tx="ekr.20190405075412.1">def blockCount(self):
    return 0

def breakPoints(self):
    return list(sorted(self._breakPoints))

def id(self):
    return self._filename or self._name

def indentUsingSpaces(self):
    return True

def indentWidth(self):
    return 4

def save(self, filename=None):
    pass

def setIndentUsingSpaces(self, style):
    pass

def setCheckedOption(self, val):
    pass

def setDebugLineIndicator(self, val):
    pass

def setIndentWidth(self, width):
    pass

def setParser(self, val):
    pass

def setPlainText(self, text):
    pass

def setTextCursor(self, obj):
    pass

def setTitleInMainWindow(self):
    pass
</t>
<t tx="ekr.20190405075440.1">def createOutlineFrame(self):
    '''Create the outline frame.'''
    #
    # Like createFrame TabbedFrameFactory.createFrame.
    assert g.pyzo, g.callers()
    self.c = c = g.app.newCommander(fileName = self.filename)
    g.pr('----- OutlineEditorShim.createOutlineFrame', c.shortFileName())
    f = c.frame
        # f is a LeoFrame, *not* a QWidget.
    if 0:
        ### Works. Just use dummies.
        import leo.core.leoFrame as leoFrame
        f.tree = leoFrame.NullTree(f)
        f.body = leoFrame.NullBody(f)
        f.log = leoFrame.NullLog(f)
        f.menu = g.TracingNullObject(tag='c.frame.menu')
        f.miniBufferWidget = g.TracingNullObject(tag='c.frame.miniBufferWidget')
        g.app.windowList.append(f)
        c.bodyWantsFocus()
        return
    
    import leo.plugins.qt_frame as qt_frame
    import leo.plugins.qt_text as qt_text
    import leo.plugins.qt_tree as qt_tree
    assert isinstance(c.frame, qt_frame.LeoQtFrame), repr(c.frame)
    ### f.top = g.app.gui.frameFactory.createFrame(f)
    ### f.top = qt_frame.DynamicWindow(c, f)
        # f.top is a DynamicWindow.
        ### dw.leo_ui = dw ### weird
        ### self.leoFrames[dw] = leoFrame
    ### f.top = QtWidgets.QFrame(parent = ???)
    ### f.createIconBar() # A base class method.
    parent = self.parent()
        # A EditorTabs, a QWidget.
    if 1:
        self.setStyleSheet('background: red')
    
    # f.top.iconBar = QtWidgets.QToolBar('toolbar', parent)
    ### f.iconBar = f.iconBarClass(c, parent)
    # f.iconBar = f.QtIconBarClass(c, parent)
    
    ### f.createSplitterComponents()
    if 0:
        f.tree = qt_tree.LeoQtTree(c, parent)
        f.log = qt_text.LeoQtLog(parent, None)
        f.body = qt_text.LeoQtBody(parent, None)
        f.splitVerticalFlag, ratio, secondary_ratio = f.initialRatios()
        f.resizePanesToRatio(ratio, secondary_ratio)
    if 0:
        f.createStatusLine() # A base class method.
        f.createFirstTreeNode() # Call the base-class method.
        f.menu = qt_frame.LeoQtMenu(c, f, label='top-level-menu')
        g.app.windowList.append(f)
        f.miniBufferWidget = qt_text.QMinibufferWrapper(c)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20190405080153.1"></t>
<t tx="ekr.20190405164143.1">@language rest
@wrap


@language python
</t>
<t tx="ekr.20190406154306.1">g.openWithFileName(r'C:\apps\pyzo\pyzo.leo')</t>
<t tx="ekr.20190406160609.1"></t>
<t tx="ekr.20190406165302.1">def setStyle(self, style):
    
    suppress = (
        'Editor.Highlight current line',
        'Editor.Indentation guides',
        'Editor.Line numbers',
        'Editor.Long line indicator',
    )
    
    def use_style(key):
        return key not in suppress and not key.startswith('Syntax')

    super().setStyle({
        z: style.get(z) for z in style.keys() if use_style(z)
    })
</t>
<t tx="ekr.20190406175538.1"># QPlainTextEdit
(Pdb) g.printObj(dir(self))
[
    'AdjustIgnored',
    'AdjustToContents',
    'AdjustToContentsOnFirstShow',
    'Box',
    'DrawChildren',
    'DrawWindowBackground',
    'HLine',
    'IgnoreMask',
    'LineWrapMode',
    'NoFrame',
    'NoWrap',
    'PaintDeviceMetric',
    'Panel',
    'PdmDepth',
    'PdmDevicePixelRatio',
    'PdmDevicePixelRatioScaled',
    'PdmDpiX',
    'PdmDpiY',
    'PdmHeight',
    'PdmHeightMM',
    'PdmNumColors',
    'PdmPhysicalDpiX',
    'PdmPhysicalDpiY',
    'PdmWidth',
    'PdmWidthMM',
    'Plain',
    'Raised',
    'RenderFlag',
    'RenderFlags',
    'Shadow',
    'Shadow_Mask',
    'Shape',
    'Shape_Mask',
    'SizeAdjustPolicy',
    'StyleMask',
    'StyledPanel',
    'Sunken',
    'VLine',
    'WidgetWidth',
    'WinPanel',
    '_CodeEditorBase__afterSetStyle',
    '_CodeEditorBase__getOptionSetters',
    '_CodeEditorBase__initOptions',
    '_CodeEditorBase__setOptions',
    '__class__',
    '__delattr__',
    '__dict__',
    '__dir__',
    '__doc__',
    '__eq__',
    '__format__',
    '__ge__',
    '__getattr__',
    '__getattribute__',
    '__gt__',
    '__hash__',
    '__init__',
    '__init_subclass__',
    '__le__',
    '__lt__',
    '__module__',
    '__ne__',
    '__new__',
    '__reduce__',
    '__reduce_ex__',
    '__repr__',
    '__setattr__',
    '__sizeof__',
    '__str__',
    '__subclasshook__',
    '__weakref__',
    '_setHighlighter',
    '_styleElements',
    'acceptDrops',
    'accessibleDescription',
    'accessibleName',
    'actionEvent',
    'actions',
    'activateWindow',
    'addAction',
    'addActions',
    'addLeftMargin',
    'addScrollBarWidget',
    'adjustSize',
    'anchorAt',
    'appendHtml',
    'appendPlainText',
    'autoFillBackground',
    'backgroundRole',
    'backgroundVisible',
    'baseSize',
    'blockBoundingGeometry',
    'blockBoundingRect',
    'blockCount',
    'blockCountChanged',
    'blockSignals',
    'breakPoints',
    'breakPointsChanged',
    'canInsertFromMimeData',
    'canPaste',
    'centerCursor',
    'centerOnScroll',
    'changeEvent',
    'childAt',
    'childEvent',
    'children',
    'childrenRect',
    'childrenRegion',
    'clear',
    'clearFocus',
    'clearMask',
    'close',
    'closeEvent',
    'colorCount',
    'connectNotify',
    'contentOffset',
    'contentsMargins',
    'contentsRect',
    'contextMenuEvent',
    'contextMenuPolicy',
    'copy',
    'copyAvailable',
    'cornerWidget',
    'create',
    'createMimeDataFromSelection',
    'createOutlineFrame',
    'createStandardContextMenu',
    'createWindowContainer',
    'currentCharFormat',
    'cursor',
    'cursorForPosition',
    'cursorPositionChanged',
    'cursorRect',
    'cursorWidth',
    'customContextMenuRequested',
    'customEvent',
    'cut',
    'dedentBlock',
    'dedentSelection',
    'deleteLater',
    'depth',
    'destroy',
    'destroyed',
    'devType',
    'devicePixelRatio',
    'devicePixelRatioF',
    'devicePixelRatioFScale',
    'disconnect',
    'disconnectNotify',
    'doForSelectedBlocks',
    'doForVisibleBlocks',
    'document',
    'documentTitle',
    'dragEnterEvent',
    'dragLeaveEvent',
    'dragMoveEvent',
    'drawFrame',
    'dropEvent',
    'dumpObjectInfo',
    'dumpObjectTree',
    'dynamicPropertyNames',
    'effectiveWinId',
    'ensureCursorVisible',
    'ensurePolished',
    'enterEvent',
    'event',
    'eventFilter',
    'extraSelections',
    'find',
    'findChild',
    'findChildren',
    'firstVisibleBlock',
    'focusInEvent',
    'focusNextChild',
    'focusNextPrevChild',
    'focusOutEvent',
    'focusPolicy',
    'focusPreviousChild',
    'focusProxy',
    'focusWidget',
    'font',
    'fontChanged',
    'fontInfo',
    'fontMetrics',
    'foregroundRole',
    'frameGeometry',
    'frameRect',
    'frameShadow',
    'frameShape',
    'frameSize',
    'frameStyle',
    'frameWidth',
    'geometry',
    'getContentsMargins',
    'getLeftMargin',
    'getPaintContext',
    'getStyleElementDescriptions',
    'getStyleElementFormat',
    'gotoBlock',
    'gotoLine',
    'grab',
    'grabGesture',
    'grabKeyboard',
    'grabMouse',
    'grabShortcut',
    'graphicsEffect',
    'graphicsProxyWidget',
    'hasFocus',
    'hasHeightForWidth',
    'hasMouseTracking',
    'height',
    'heightForWidth',
    'heightMM',
    'hide',
    'hideEvent',
    'horizontalScrollBar',
    'horizontalScrollBarPolicy',
    'id',
    'indentBlock',
    'indentSelection',
    'indentUsingSpaces',
    'indentWidth',
    'inherits',
    'initPainter',
    'initStyleOption',
    'inputMethodEvent',
    'inputMethodHints',
    'inputMethodQuery',
    'insertAction',
    'insertActions',
    'insertFromMimeData',
    'insertPlainText',
    'installEventFilter',
    'isActiveWindow',
    'isAncestorOf',
    'isEnabled',
    'isEnabledTo',
    'isFullScreen',
    'isHidden',
    'isLeftToRight',
    'isMaximized',
    'isMinimized',
    'isModal',
    'isReadOnly',
    'isRightToLeft',
    'isSignalConnected',
    'isUndoRedoEnabled',
    'isVisible',
    'isVisibleTo',
    'isWidgetType',
    'isWindow',
    'isWindowModified',
    'isWindowType',
    'justifyText',
    'keyPressEvent',
    'keyReleaseEvent',
    'keyboardGrabber',
    'killTimer',
    'layout',
    'layoutDirection',
    'leaveEvent',
    'lineWidth',
    'lineWrapMode',
    'loadResource',
    'locale',
    'logicalDpiX',
    'logicalDpiY',
    'lower',
    'mapFrom',
    'mapFromGlobal',
    'mapFromParent',
    'mapTo',
    'mapToGlobal',
    'mapToParent',
    'mask',
    'maximumBlockCount',
    'maximumHeight',
    'maximumSize',
    'maximumViewportSize',
    'maximumWidth',
    'mergeCurrentCharFormat',
    'metaObject',
    'metric',
    'midLineWidth',
    'minimumHeight',
    'minimumSize',
    'minimumSizeHint',
    'minimumWidth',
    'modificationChanged',
    'mouseDoubleClickEvent',
    'mouseGrabber',
    'mouseMoveEvent',
    'mousePressEvent',
    'mouseReleaseEvent',
    'move',
    'moveCursor',
    'moveEvent',
    'moveToThread',
    'nativeEvent',
    'nativeParentWidget',
    'nextInFocusChain',
    'normalGeometry',
    'objectName',
    'objectNameChanged',
    'overrideWindowFlags',
    'overrideWindowState',
    'overwriteMode',
    'paintEngine',
    'paintEvent',
    'paintingActive',
    'palette',
    'parent',
    'parentWidget',
    'paste',
    'physicalDpiX',
    'physicalDpiY',
    'placeholderText',
    'pos',
    'previousInFocusChain',
    'print',
    'print_',
    'property',
    'pyqtConfigure',
    'raise_',
    'receivers',
    'rect',
    'redo',
    'redoAvailable',
    'releaseKeyboard',
    'releaseMouse',
    'releaseShortcut',
    'removeAction',
    'removeEventFilter',
    'render',
    'repaint',
    'resize',
    'resizeEvent',
    'restoreGeometry',
    'save',
    'saveGeometry',
    'scroll',
    'scrollBarWidgets',
    'scrollContentsBy',
    'selectAll',
    'selectionChanged',
    'sender',
    'senderSignalIndex',
    'setAcceptDrops',
    'setAccessibleDescription',
    'setAccessibleName',
    'setAttribute',
    'setAutoFillBackground',
    'setBackgroundRole',
    'setBackgroundVisible',
    'setBaseSize',
    'setCenterOnScroll',
    'setCheckedOption',
    'setContentsMargins',
    'setContextMenuPolicy',
    'setCornerWidget',
    'setCurrentCharFormat',
    'setCursor',
    'setCursorWidth',
    'setDebugLineIndicator',
    'setDisabled',
    'setDocument',
    'setDocumentTitle',
    'setEnabled',
    'setExtraSelections',
    'setFixedHeight',
    'setFixedSize',
    'setFixedWidth',
    'setFocus',
    'setFocusPolicy',
    'setFocusProxy',
    'setFont',
    'setForegroundRole',
    'setFrameRect',
    'setFrameShadow',
    'setFrameShape',
    'setFrameStyle',
    'setGeometry',
    'setGraphicsEffect',
    'setHidden',
    'setHorizontalScrollBar',
    'setHorizontalScrollBarPolicy',
    'setIndentUsingSpaces',
    'setIndentWidth',
    'setInputMethodHints',
    'setLayout',
    'setLayoutDirection',
    'setLineWidth',
    'setLineWrapMode',
    'setLocale',
    'setMask',
    'setMaximumBlockCount',
    'setMaximumHeight',
    'setMaximumSize',
    'setMaximumWidth',
    'setMidLineWidth',
    'setMinimumHeight',
    'setMinimumSize',
    'setMinimumWidth',
    'setMouseTracking',
    'setObjectName',
    'setOptions',
    'setOverwriteMode',
    'setPalette',
    'setParent',
    'setParser',
    'setPlaceholderText',
    'setPlainText',
    'setProperty',
    'setReadOnly',
    'setShortcutAutoRepeat',
    'setShortcutEnabled',
    'setSizeAdjustPolicy',
    'setSizeIncrement',
    'setSizePolicy',
    'setStatusTip',
    'setStyle',
    'setStyleSheet',
    'setTabChangesFocus',
    'setTabOrder',
    'setTabStopWidth',
    'setTextCursor',
    'setTextInteractionFlags',
    'setTitleInMainWindow',
    'setToolTip',
    'setToolTipDuration',
    'setUndoRedoEnabled',
    'setUpdatesEnabled',
    'setVerticalScrollBar',
    'setVerticalScrollBarPolicy',
    'setViewport',
    'setViewportMargins',
    'setVisible',
    'setWhatsThis',
    'setWindowFilePath',
    'setWindowFlags',
    'setWindowIcon',
    'setWindowIconText',
    'setWindowModality',
    'setWindowModified',
    'setWindowOpacity',
    'setWindowRole',
    'setWindowState',
    'setWindowTitle',
    'setWordWrapMode',
    'setZoom',
    'setupViewport',
    'sharedPainter',
    'show',
    'showEvent',
    'showFullScreen',
    'showMaximized',
    'showMinimized',
    'showNormal',
    'signalsBlocked',
    'size',
    'sizeAdjustPolicy',
    'sizeHint',
    'sizeIncrement',
    'sizePolicy',
    'somethingChanged',
    'stackUnder',
    'startTimer',
    'staticMetaObject',
    'statusTip',
    'style',
    'styleChanged',
    'styleSheet',
    'tabChangesFocus',
    'tabStopWidth',
    'tabletEvent',
    'testAttribute',
    'textChanged',
    'textCursor',
    'textInteractionFlags',
    'thread',
    'timerEvent',
    'toPlainText',
    'toggleCase',
    'toolTip',
    'toolTipDuration',
    'tr',
    'underMouse',
    'undo',
    'undoAvailable',
    'ungrabGesture',
    'unsetCursor',
    'unsetLayoutDirection',
    'unsetLocale',
    'update',
    'updateGeometry',
    'updateMargins',
    'updateMicroFocus',
    'updateRequest',
    'updatesEnabled',
    'verticalScrollBar',
    'verticalScrollBarPolicy',
    'viewport',
    'viewportEvent',
    'viewportMargins',
    'viewportSizeHint',
    'visibleRegion',
    'whatsThis',
    'wheelEvent',
    'width',
    'widthMM',
    'winId',
    'window',
    'windowFilePath',
    'windowFlags',
    'windowHandle',
    'windowIcon',
    'windowIconChanged',
    'windowIconText',
    'windowIconTextChanged',
    'windowModality',
    'windowOpacity',
    'windowRole',
    'windowState',
    'windowTitle',
    'windowTitleChanged',
    'windowType',
    'wordWrapMode',
    'x',
    'y',
    'zoomIn',
    'zoomOut'
]
</t>
<t tx="ekr.20190406193429.1" __node_tags="635f5f6275696c74696e5f5f0a7365740a7100285d7101580700000073657474696e677102617471035271042e"># Extra plugins, for this file only.

# Essential...
plugins_menu.py
free_layout.py
    # Now loaded automatically.
    # Disabled for testing bug 882824.
mod_scripting.py
viewrendered.py

# Testing only...
# nodetags.py
# python_terminal.py
# multifile.py
# livecode.py

# Others...
# bookmarks.py
# demo.py
# mod_http.py
# richtext.py

# Standard plugins

# backlink.py
# bigdash.py
# contextmenu.py
# line_numbering.py
# nav_qt.py
# nodetags.py
# quicksearch.py
# screen_capture.py
# todo.py
# valuespace.py
# xdb_pane.py
</t>
<t tx="ekr.20190406194351.1">class DocumentShim(object):
    modified = False
    def isModified(self):
        return self.modified
    def setModified(self, aBool):
        self.modified = aBool

class ScrollBarShim(object):
    def setValue(self, value):
        pass
    def value(self):
        return 0

class TextCursorShim(object):
    def position(self):
        return 0
    def setPosition(self, pos):
        pass</t>
<t tx="tbnorth.20171220123648.1">def linkClicked(self, link):
    """linkClicked - link clicked in log

    :param QUrl link: link that was clicked
    """
    # see addition of '/' in LeoQtLog.put()
    url = s = g.toUnicode(link.toString())
    if platform.system() == 'Windows':
        for scheme in 'file', 'unl':
            if s.startswith(scheme+':///') and s[len(scheme)+5] == ':':
                url = s.replace(':///', '://', 1)
                break
    g.handleUrl(url, c=self.c)
</t>
<t tx="tbrown.20110621120042.22914">def get_top_splitter(self):
    '''Return the top splitter of c.frame.top.'''
    # Careful: we could be unit testing.
    if g.pyzo:
        return None
    f = self.c.frame
    if hasattr(f, 'top') and f.top:
        ### return f.top.findChild(NestedSplitter).top()
        child = f.top.findChild(NestedSplitter)
        return child and child.top()
    else:
        return None
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    '''Called when user hits tab on an item in the QListWidget.'''
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper # 2014/09/19
    if w is None:
        return
    # Replace the tail of the prefix with the completion.
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while(0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    '''Handle a wheel event.'''
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20150807090639.1">def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    """
    if self.declutter_patterns is None:
        self.declutter_patterns = []
        warned = False
        lines = c.config.getData("tree-declutter-patterns")
        for line in lines:
            try:
                cmd, arg = line.split(None, 1)
            except ValueError:
                # Allow empty arg, and guard against user errors.
                cmd = line.strip()
                arg = ''
            if cmd.startswith('#'):
                pass
            elif cmd == 'RULE':
                self.declutter_patterns.append((re.compile(arg), []))
            else:
                if self.declutter_patterns:
                    self.declutter_patterns[-1][1].append((cmd, arg))
                elif not warned:
                    warned = True
                    g.log('Declutter patterns must start with RULE*',
                        color='error')
    text = str(item.text(0))
    new_icons = []
    for pattern, cmds in self.declutter_patterns:
        for func in (pattern.match, pattern.search):
            m = func(text)
            if m:
                for cmd, arg in cmds:
                    if self.declutter_replace(arg, cmd, item, m, pattern, text):
                        pass
                    else:
                        self.declutter_style(arg, c, cmd, item, new_icons)
                break # Don't try pattern.search if pattern.match succeeds.
    com = c.editCommands
    allIcons = com.getIconList(p)
    icons = [i for i in allIcons if 'visualIcon' not in i]
    if len(allIcons) != len(icons) or new_icons:
        for icon in new_icons:
            com.appendImageDictToList(
                icons, icon, 2, on='vnode', visualIcon='1'
            )
        com.setIconList(p, icons, False)
</t>
<t tx="tbrown.20150807093655.1">def clear_visual_icons(self, tag, keywords):
    """clear_visual_icons - remove 'declutter' icons before save

    this method must return None to tell Leo to continue normal processing

    :param str tag: 'save1'
    :param dict keywords: Leo hook keywords
    """

    if not self.use_declutter:
        return None

    c = keywords['c']
    if c != self.c:
        return None

    if c.config.getBool('tree-declutter', default=False):
        com = c.editCommands
        for nd in c.all_unique_positions():
            icons = [i for i in com.getIconList(nd) if 'visualIcon' not in i]
            com.setIconList(nd, icons, False)

    self.declutter_update = True

    return None
</t>
<t tx="tbrown.20150808075906.1">def update_appearance(self, tag, keywords):
    """clear_visual_icons - update appearance, but can't call
    self.full_redraw() now, so just set a flag to do it on idle.

    :param str tag: 'headkey2'
    :param dict keywords: Leo hook keywords
    """
    if not self.use_declutter:
        return None
    c = keywords['c']
    if c != self.c:
        return None
    self.declutter_update = True
    return None
</t>
<t tx="tbrown.20150808082111.1">def update_appearance_idle(self, tag, keywords):
    """clear_visual_icons - update appearance now we're safely out of
    the redraw loop.

    :param str tag: 'idle'
    :param dict keywords: Leo hook keywords
    """
    if not self.use_declutter:
        return None
    c = keywords['c']
    if c != self.c:
        return None

    if isinstance(QtWidgets.QApplication.focusWidget(), QtWidgets.QLineEdit):
        # when search results are found in headlines headkey2 fires
        # (on the second search hit in a headline), and full_redraw()
        # below takes the headline out of edit mode, and Leo crashes,
        # probably because the find code didn't expect to leave edit
        # mode.  So don't update when a QLineEdit has focus
        return None

    if self.declutter_update:
        self.declutter_update = False
        c.redraw_later()
    return None
</t>
<t tx="tbrown.20150904102518.1">def set_time(self, path, new_time=None):
    '''
    Implements c.setTimeStamp.

    Update the timestamp for path.

    NOTE: file paths with symbolic links occur with and without those links
    resolved depending on the code call path.  This inconsistency is
    probably not Leo's fault but an underlying Python issue.
    Hence the need to call realpath() here.
    '''
    t = new_time or self.get_mtime(path)
    self._time_d[g.os_path_realpath(path)] = t
</t>
<t tx="tbrown.20160406221505.1">@staticmethod
def sizeTreeEditor(c, editor):
    """Size a QLineEdit in a tree headline so scrolling occurs"""
    # space available in tree widget
    space = c.frame.tree.treeWidget.size().width()
    # left hand edge of editor within tree widget
    used = editor.geometry().x() + 4  # + 4 for edit cursor
    # limit width to available space
    editor.resize(space - used, editor.size().height())
</t>
</tnodes>
</leo_file>
