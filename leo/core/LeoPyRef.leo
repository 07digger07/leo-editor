<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo (http://leoeditor.com/leo_toc.html) -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://www.leo-editor.org/2011/leo" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20131121084830.16362"><vh>@button toggle-debug</vh></v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18036"><vh>@data:@auto ../test/qtui_generate.py</vh>
<v t="ekr.20140817075533.18314"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20140817075533.18315"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20140817075533.18316"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20140817075533.18317"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20140817075533.18318"><vh>@gnxs</vh></v>
</v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20140818145250.18237"><vh>Stash</vh>
<v t="ekr.20140820162445.18326"><vh>** improved command recognition</vh>
<v t="ekr.20140818074502.18221"><vh>ga.is_command</vh></v>
<v t="ekr.20140818074502.18222"><vh>ga.get_command</vh></v>
</v>
<v t="ekr.20061031131434" a="O"><vh>@file leoKeys.py</vh>
<v t="ekr.20061031131434.1"><vh>&lt;&lt; imports &gt;&gt; (leoKeys)</vh></v>
<v t="ekr.20130920121326.11281"><vh>&lt;&lt; Key bindings, an overview &gt;&gt;</vh></v>
<v t="ekr.20061031131434.2"><vh>&lt;&lt; about 'internal' bindings &gt;&gt;</vh></v>
<v t="ekr.20061031131434.3"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20061031131434.4"><vh>class AutoCompleterClass</vh>
<v t="ekr.20061031131434.5"><vh> ctor (autocompleter)</vh></v>
<v t="ekr.20061031131434.8"><vh>Top level (autocompleter)</vh>
<v t="ekr.20061031131434.9"><vh>autoComplete</vh></v>
<v t="ekr.20061031131434.10"><vh>autoCompleteForce</vh></v>
<v t="ekr.20061031131434.12"><vh>enable/disable/toggleAutocompleter/Calltips</vh></v>
<v t="ekr.20061031131434.13"><vh>showCalltips</vh></v>
<v t="ekr.20061031131434.14"><vh>showCalltipsForce</vh></v>
<v t="ekr.20061031131434.15"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20061031131434.16"><vh>Helpers</vh>
<v t="ekr.20110512212836.14469"><vh>exit</vh></v>
<v t="ekr.20061031131434.18"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20110509064011.14556"><vh>attr_matches</vh></v>
<v t="ekr.20061031131434.11"><vh>auto_completer_state_handler</vh></v>
<v t="ekr.20061031131434.20"><vh>calltip &amp; helpers</vh>
<v t="ekr.20110512090917.14468"><vh>calltip_fail</vh></v>
<v t="ekr.20110512090917.14469"><vh>calltip_success</vh></v>
</v>
<v t="ekr.20061031131434.28"><vh>compute_completion_list &amp; helper</vh>
<v t="ekr.20110514051607.14524"><vh>get_cached_options</vh></v>
</v>
<v t="ekr.20061031131434.29"><vh>do_backspace</vh></v>
<v t="ekr.20110510133719.14548"><vh>do_qcompleter_tab</vh></v>
<v t="ekr.20110509064011.14561"><vh>get_autocompleter_prefix</vh></v>
<v t="ekr.20110512212836.14471"><vh>get_completions &amp; helpers</vh>
<v t="ekr.20110510120621.14539"><vh>get_codewise_completions &amp; helpers</vh>
<v t="ekr.20110510120621.14540"><vh>clean</vh></v>
<v t="ekr.20110512232915.14481"><vh>clean_for_display (not used)</vh></v>
<v t="ekr.20110510120621.14542"><vh>guess_class</vh></v>
<v t="ekr.20110510120621.14543"><vh>lookup_functions/methods/modules</vh></v>
</v>
<v t="ekr.20110509064011.14557"><vh>get_leo_completions</vh></v>
</v>
<v t="ekr.20110512090917.14466"><vh>get_leo_namespace</vh></v>
<v t="ekr.20110512170111.14472"><vh>get_object</vh></v>
<v t="ekr.20061031131434.38"><vh>info</vh></v>
<v t="ekr.20110510071925.14586"><vh>init_qcompleter</vh></v>
<v t="ekr.20110511133940.14552"><vh>init_tabcompleter</vh></v>
<v t="ekr.20061031131434.39"><vh>insert_general_char</vh></v>
<v t="ekr.20061031131434.31"><vh>insert_string</vh></v>
<v t="ekr.20110314115639.14269"><vh>is_leo_source_file</vh></v>
<v t="ekr.20101101175644.5891"><vh>put</vh></v>
<v t="ekr.20110511133940.14561"><vh>show_completion_list &amp; helpers</vh>
<v t="ekr.20110513104728.14453"><vh>clean_completion_list</vh></v>
<v t="ekr.20110513104728.14454"><vh>get_summary_list</vh></v>
</v>
<v t="ekr.20061031131434.46"><vh>start</vh></v>
<v t="ekr.20110512170111.14471"><vh>strip_brackets</vh></v>
</v>
</v>
<v t="ekr.20110312162243.14260"><vh>class ContextSniffer</vh>
<v t="ekr.20110312162243.14261"><vh>get_classes</vh></v>
<v t="ekr.20110312162243.14262"><vh>set_small_context</vh></v>
<v t="ekr.20110312162243.14263"><vh>push_declarations &amp; helper</vh>
<v t="ekr.20110312162243.14264"><vh>declare</vh></v>
</v>
</v>
<v t="ekr.20140813052702.18194"><vh>class FileNameChooser</vh>
<v t="ekr.20140813052702.18195"><vh>fnc.__init__</vh></v>
<v t="ekr.20140813052702.18196"><vh>fnc.compute_tab_list</vh></v>
<v t="ekr.20140813052702.18197"><vh>fnc.do_back_space</vh></v>
<v t="ekr.20140813052702.18198"><vh>fnc.do_char</vh></v>
<v t="ekr.20140813052702.18199"><vh>fnc.do_tab</vh></v>
<v t="ekr.20140813052702.18200"><vh>fnc.get_file_name (entry)</vh></v>
<v t="ekr.20140813052702.18201"><vh>fnc.extend/get/set_label</vh></v>
<v t="ekr.20140813052702.18202"><vh>fnc.show_tab_list</vh></v>
</v>
<v t="ekr.20140816165728.18940"><vh>class GetArg</vh>
<v t="ekr.20140818052417.18241"><vh>ga.birth</vh>
<v t="ekr.20140816165728.18952"><vh>ga.__init__</vh></v>
</v>
<v t="ekr.20140817110228.18321"><vh>ga.compute_tab_list</vh></v>
<v t="ekr.20140816165728.18965"><vh>ga.do_back_space (entry)</vh></v>
<v t="ekr.20140817110228.18323"><vh>ga.do_tab (entry) &amp; helpers</vh>
<v t="ekr.20140818145250.18235"><vh>ga.do_tab_callback</vh></v>
<v t="ekr.20140819050118.18317"><vh>ga.do_tab_cycling</vh></v>
<v t="ekr.20140819050118.18318"><vh>ga.reset_tab_cycling</vh></v>
</v>
<v t="ekr.20140816165728.18958"><vh>ga.extend/get/set_label</vh></v>
<v t="ekr.20140816165728.18941"><vh>ga.get_arg (entry) &amp; helpers</vh>
<v t="ekr.20140816165728.18955"><vh>ga.do_char</vh></v>
<v t="ekr.20140817110228.18316"><vh>ga.do_end</vh></v>
<v t="ekr.20140817110228.18317"><vh>ga.do_state_zero</vh></v>
<v t="ekr.20140818103808.18234"><vh>ga.should_end</vh></v>
<v t="ekr.20140818103808.18235"><vh>ga.trace_state</vh></v>
</v>
<v t="ekr.20140818074502.18222"></v>
<v t="ekr.20140818085719.18227"><vh>ga.get_minibuffer_command_name</vh></v>
<v t="ekr.20140818074502.18221"></v>
<v t="ekr.20140816165728.18959"><vh>ga.show_tab_list</vh></v>
</v>
<v t="ekr.20061031131434.74"><vh>class KeyHandlerClass</vh>
<v t="ekr.20061031131434.75"><vh> k.Birth</vh>
<v t="ekr.20061031131434.76"><vh>k.__init__&amp; helpers</vh>
<v t="ekr.20061031131434.78"><vh>k.defineExternallyVisibleIvars</vh></v>
<v t="ekr.20061031131434.79"><vh>k.defineInternalIvars</vh></v>
<v t="ekr.20080509064108.7"><vh>k.defineMultiLineCommands</vh></v>
<v t="ekr.20120217070122.10479"><vh>k.defineSettingIvars</vh></v>
<v t="ekr.20080509064108.6"><vh>k.defineSingleLineCommands</vh></v>
<v t="ekr.20070123085931"><vh>k.defineSpecialKeys</vh></v>
<v t="ekr.20070123143428"><vh>k.defineTkNames</vh></v>
</v>
<v t="ekr.20061031131434.80"><vh>k.finishCreate &amp; helpers</vh></v>
<v t="ekr.20061101071425"><vh>k.oops</vh></v>
<v t="ekr.20110209093958.15413"><vh>k.setDefaultEditingKeyAction (New)</vh></v>
<v t="ekr.20061031131434.82"><vh>k.setDefaultUnboundKeyAction</vh></v>
</v>
<v t="ekr.20061031131434.88"><vh>k.Binding</vh>
<v t="ekr.20061031131434.89"><vh>k.bindKey &amp; helpers</vh>
<v t="ekr.20120130074511.10228"><vh>k.check_bind_key</vh></v>
<v t="ekr.20120130074511.10227"><vh>k.kill_one_shortcut</vh></v>
<v t="ekr.20061031131434.92"><vh>k.remove_conflicting_definitions</vh></v>
<v t="ekr.20061031131434.93"><vh>k.bindKeyToDict</vh></v>
<v t="ekr.20061031131434.94"><vh>k.bindOpenWith</vh></v>
</v>
<v t="ekr.20061031131434.95"><vh>k.checkBindings</vh></v>
<v t="ekr.20061031131434.97"><vh>k.completeAllBindings</vh></v>
<v t="ekr.20061031131434.96"><vh>k.completeAllBindingsForWidget</vh></v>
<v t="ekr.20070218130238"><vh>k.dumpMasterBindingsDict</vh></v>
<v t="ekr.20061031131434.99"><vh>k.initAbbrev &amp; helper</vh>
<v t="ekr.20130924035029.12741"><vh>k.initOneAbbrev</vh></v>
</v>
<v t="ekr.20061031131434.101"><vh>k.initSpecialIvars</vh></v>
<v t="ekr.20061031131434.98"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20061031131434.102"><vh>k.makeBindingsFromCommandsDict &amp; helper</vh></v>
<v t="ekr.20061031131434.103"><vh>k.makeMasterGuiBinding</vh></v>
</v>
<v t="ekr.20061031131434.104"><vh>k.Dispatching</vh>
<v t="ekr.20061031131434.111"><vh>k.fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20061031131434.112"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20061031131434.113"><vh>k.endCommand</vh></v>
</v>
<v t="ekr.20061031131434.114"><vh>k.Externally visible commands</vh>
<v t="ekr.20061031131434.115"><vh>k.digitArgument &amp; universalArgument</vh></v>
<v t="ekr.20070613133500"><vh>k.menuCommandKey</vh></v>
<v t="ekr.20061031131434.117"><vh>k.negativeArgument (redo?)</vh></v>
<v t="ekr.20061031131434.118"><vh>k.numberCommand</vh></v>
<v t="ekr.20061031131434.119"><vh>k.printBindings &amp; helper</vh>
<v t="ekr.20061031131434.120"><vh>printBindingsHelper</vh></v>
</v>
<v t="ekr.20120520174745.9867"><vh>k.printButtons</vh></v>
<v t="ekr.20061031131434.121"><vh>k.printCommands</vh></v>
<v t="ekr.20061031131434.122"><vh>k.repeatComplexCommand &amp; helper</vh>
<v t="ekr.20131017100903.16689"><vh>repeatComplexCommandHelper</vh></v>
</v>
<v t="ekr.20061031131434.123"><vh>k.set-xxx-State</vh></v>
<v t="ekr.20061031131434.124"><vh>k.toggle-input-state</vh></v>
</v>
<v t="ekr.20061031131434.125"><vh>k.Externally visible helpers</vh>
<v t="ekr.20140816165728.18968"><vh>Wrappers for GetArg methods</vh></v>
<v t="ekr.20061031131434.130"><vh>k.keyboardQuit</vh></v>
<v t="ekr.20061031131434.126"><vh>k.manufactureKeyPressForCommandName (changed)</vh></v>
<v t="ekr.20071212104050"><vh>k.overrideCommand</vh></v>
<v t="ekr.20061031131434.131"><vh>k.registerCommand</vh></v>
<v t="ekr.20061031131434.127"><vh>k.simulateCommand</vh></v>
<v t="ekr.20140813052702.18203"><vh>k.getFileName</vh></v>
</v>
<v t="ekr.20061031131434.145"><vh>k.Master event handlers</vh>
<v t="ekr.20061031131434.105"><vh>k.masterCommand &amp; helpers</vh>
<v t="ekr.20061031131434.106"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20061031131434.110"><vh>k.handleDefaultChar</vh></v>
</v>
<v t="ekr.20061031131434.146"><vh>k.masterKeyHandler &amp; helpers</vh>
<v t="ekr.20061031131434.147"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20061031131434.108"><vh>k.callStateFunction</vh></v>
<v t="ekr.20091230094319.6244"><vh>k.doMode</vh></v>
<v t="ekr.20091230094319.6240"><vh>k.getPaneBinding</vh></v>
<v t="ekr.20061031131434.152"><vh>k.handleMiniBindings</vh></v>
<v t="ekr.20080510095819.1"><vh>k.handleUnboundKeys</vh></v>
<v t="ekr.20110209083917.16004"><vh>k.isAutoCompleteChar</vh></v>
</v>
</v>
<v t="ekr.20061031170011.3"><vh>k.Minibuffer</vh>
<v t="ekr.20061031131434.135"><vh>k.minibufferWantsFocus</vh></v>
<v t="ekr.20061031170011.5"><vh>k.getLabel</vh></v>
<v t="ekr.20080408060320.791"><vh>k.killLine</vh></v>
<v t="ekr.20061031170011.6"><vh>k.protectLabel</vh></v>
<v t="ekr.20061031170011.7"><vh>k.resetLabel</vh></v>
<v t="ekr.20061031170011.8"><vh>k.setLabel</vh></v>
<v t="ekr.20061031170011.9"><vh>k.extendLabel</vh></v>
<v t="ekr.20080408060320.790"><vh>k.selectAll</vh></v>
<v t="ekr.20061031170011.10"><vh>k.setLabelBlue</vh></v>
<v t="ekr.20061031170011.11"><vh>k.setLabelGrey</vh></v>
<v t="ekr.20080510153327.2"><vh>k.setLabelRed</vh></v>
<v t="ekr.20061031170011.12"><vh>k.updateLabel</vh></v>
<v t="ekr.20061031170011.13"><vh>k.getEditableTextRange</vh></v>
</v>
<v t="ekr.20120208064440.10190"><vh>k.Modes (no change)</vh>
<v t="ekr.20061031131434.100"><vh>k.addModeCommands (enterModeCallback)</vh></v>
<v t="ekr.20061031131434.157"><vh>k.badMode</vh></v>
<v t="ekr.20061031131434.158"><vh>k.createModeBindings</vh></v>
<v t="ekr.20120208064440.10179"><vh>k.endMode</vh></v>
<v t="ekr.20061031131434.160"><vh>k.enterNamedMode</vh></v>
<v t="ekr.20061031131434.161"><vh>k.exitNamedMode</vh></v>
<v t="ekr.20061031131434.165"><vh>k.modeHelp &amp; helper (revise helper)</vh>
<v t="ekr.20061031131434.166"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20061031131434.164"><vh>k.reinitMode (call k.createModeBindings???)</vh></v>
<v t="ekr.20120208064440.10199"><vh>k.generalModeHandler (OLD)</vh></v>
</v>
<v t="ekr.20061031131434.156"><vh>k.Modes (changed)</vh>
<v t="ekr.20061031131434.163"><vh>k.initMode (changed)</vh></v>
<v t="ekr.20120208064440.10201"><vh>k.NEWgeneralModeHandler (NEW MODES)</vh></v>
</v>
<v t="ekr.20061031131434.181"><vh>k.Shortcuts &amp; bindings</vh>
<v t="ekr.20061031131434.176"><vh>k.computeInverseBindingDict</vh></v>
<v t="ekr.20061031131434.179"><vh>k.getShortcutForCommand/Name</vh></v>
<v t="ekr.20090518072506.8494"><vh>k.isFKey</vh></v>
<v t="ekr.20061031131434.182"><vh>k.isPlainKey</vh></v>
<v t="ekr.20061031131434.191"><vh>k.prettyPrintKey</vh></v>
<v t="ekr.20110609161752.16459"><vh>k.setLossage</vh></v>
<v t="ekr.20110606004638.16929"><vh>k.stroke2char</vh></v>
<v t="ekr.20061031131434.184"><vh>k.strokeFromSetting</vh>
<v t="ekr.20061031131434.185"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20061031131434.186"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20061031131434.187"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20061031131434.188"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20061031131434.189"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20061031131434.180"><vh>k.traceBinding (not used)</vh></v>
</v>
<v t="ekr.20061031131434.193"><vh>k.States</vh>
<v t="ekr.20061031131434.194"><vh>k.clearState</vh></v>
<v t="ekr.20061031131434.196"><vh>k.getState</vh></v>
<v t="ekr.20061031131434.195"><vh>k.getStateHandler</vh></v>
<v t="ekr.20061031131434.197"><vh>k.getStateKind</vh></v>
<v t="ekr.20061031131434.198"><vh>k.inState</vh></v>
<v t="ekr.20080511122507.4"><vh>k.setDefaultInputState</vh></v>
<v t="ekr.20110209093958.15411"><vh>k.setEditingState</vh></v>
<v t="ekr.20061031131434.133"><vh>k.setInputState</vh></v>
<v t="ekr.20061031131434.199"><vh>k.setState</vh></v>
<v t="ekr.20061031131434.192"><vh>k.showStateAndMode</vh></v>
<v t="ekr.20110202111105.15439"><vh>k.showStateCursor</vh></v>
</v>
<v t="ekr.20061031131434.200"><vh>k.universalDispatcher &amp; helpers</vh>
<v t="ekr.20061031131434.201"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20061031131434.202"><vh>k.executeNTimes</vh></v>
<v t="ekr.20061031131434.203"><vh>doControlU</vh></v>
</v>
</v>
<v t="ekr.20120208064440.10148"><vh>class ModeController</vh>
<v t="ekr.20120208064440.10161"><vh>addModeCommands (ModeController)</vh></v>
<v t="ekr.20120208064440.10163"><vh>getMode (ModeController)</vh></v>
<v t="ekr.20120208064440.10164"><vh>makeMode (ModeController)</vh></v>
</v>
<v t="ekr.20120208064440.10150"><vh>class ModeInfo</vh>
<v t="ekr.20120208064440.10193"><vh> ctor (ModeInfo)</vh></v>
<v t="ekr.20120208064440.10152"><vh>computeModeName (ModeInfo)</vh></v>
<v t="ekr.20120208064440.10156"><vh>computeModePrompt (ModeInfo)</vh></v>
<v t="ekr.20120208064440.10160"><vh>createModeBindings (ModeInfo) (NOT USED)</vh></v>
<v t="ekr.20120208064440.10195"><vh>createModeCommand (ModeInfo)</vh></v>
<v t="ekr.20120208064440.10180"><vh>enterMode (ModeInfo)</vh></v>
<v t="ekr.20120208064440.10153"><vh>init (ModeInfo) (Can we check command names here??)</vh></v>
<v t="ekr.20120208064440.10158"><vh>initMode (ModeInfo)</vh></v>
</v>
</v>
<v t="ekr.20131109170017.16504" a="O"><vh>@file leoVim.py</vh>
<v t="ekr.20140802183521.17997"><vh>show_stroke</vh></v>
<v t="ekr.20140802183521.17996"><vh>class VimEvent</vh></v>
<v t="ekr.20131113045621.16547"><vh>class VimCommands</vh>
<v t="ekr.20131109170017.16507"><vh> vc.ctor &amp; helpers</vh>
<v t="ekr.20140815160132.18834"><vh>vc.getPublicCommands</vh></v>
<v t="ekr.20140805130800.18157"><vh>dispatch dicts...</vh>
<v t="ekr.20140805130800.18162"><vh>vc.create_dispatch_dicts</vh></v>
<v t="ekr.20140222064735.16702"><vh>vc.create_motion_dispatch_d</vh></v>
<v t="ekr.20131111061547.16460"><vh>vc.create_normal_dispatch_d</vh></v>
<v t="ekr.20140222064735.16630"><vh>vc.create_vis_dispatch_d</vh></v>
<v t="ekr.20140805130800.18161"><vh>vc.create_arrow_d</vh></v>
</v>
<v t="ekr.20140804222959.18930"><vh>vc.finishCreate</vh></v>
<v t="ekr.20140803220119.18103"><vh>vc.init helpers</vh>
<v t="ekr.20140803220119.18104"><vh>vc.init_dot_ivars</vh></v>
<v t="ekr.20140803220119.18109"><vh>vc.init_constant_ivars</vh></v>
<v t="ekr.20140803220119.18106"><vh>vc.init_state_ivars</vh></v>
<v t="ekr.20140803220119.18107"><vh>vc.init_persistent_ivars</vh></v>
</v>
<v t="ekr.20140803220119.18102"><vh>vc.top-level inits</vh></v>
</v>
<v t="ekr.20140802225657.18023"><vh>vc.acceptance methods</vh>
<v t="ekr.20140803220119.18097"><vh>direct acceptance methods</vh>
<v t="ekr.20140802225657.18031"><vh>vc.accept</vh></v>
<v t="ekr.20140802225657.18024"><vh>vc.delegate</vh></v>
<v t="ekr.20140222064735.16631"><vh>vc.done</vh></v>
<v t="ekr.20140802225657.18025"><vh>vc.ignore</vh></v>
<v t="ekr.20140806204042.18115"><vh>vc.not_ready</vh></v>
<v t="ekr.20140802120757.17999"><vh>vc.quit</vh></v>
<v t="ekr.20140807070500.18163"><vh>vc.reset</vh></v>
</v>
<v t="ekr.20140802225657.18034"><vh>indirect acceptance methods</vh>
<v t="ekr.20140222064735.16709"><vh>vc.begin_insert_mode</vh></v>
<v t="ekr.20140222064735.16706"><vh>vc.begin_motion</vh></v>
<v t="ekr.20140801121720.18076"><vh>vc.end_insert_mode</vh></v>
<v t="ekr.20140222064735.16629"><vh>vc.vim_digits</vh></v>
</v>
</v>
<v t="ekr.20131111061547.16467"><vh>vc.commands</vh>
<v t="ekr.20140805130800.18158"><vh>vc.arrow...</vh></v>
<v t="ekr.20140806075456.18152"><vh>vc.vim_return</vh></v>
<v t="ekr.20140222064735.16634"><vh>vc.vim...(normal mode)</vh>
<v t="ekr.20140810181832.18220"><vh>vc.update_dot_before_search</vh></v>
<v t="ekr.20140811044942.18243"><vh>vc.update_selection_after_search</vh></v>
<v t="ekr.20140221085636.16691"><vh>vc.vim_0</vh></v>
<v t="ekr.20140220134748.16614"><vh>vc.vim_a</vh></v>
<v t="ekr.20140730175636.17981"><vh>vc.vim_A</vh></v>
<v t="ekr.20140220134748.16618"><vh>vc.vim_b</vh></v>
<v t="ekr.20140220134748.16619"><vh>vc.vim_c (to do)</vh></v>
<v t="ekr.20140807152406.18128"><vh>vc.vim_caret</vh></v>
<v t="ekr.20140730175636.17983"><vh>vc.vim_colon</vh></v>
<v t="ekr.20140806123540.18159"><vh>vc.vim_comma (not used)</vh></v>
<v t="ekr.20140730175636.17992"><vh>vc.vim_ctrl_r</vh></v>
<v t="ekr.20131111171616.16498"><vh>vc.vim_d &amp; helpers</vh>
<v t="ekr.20140811175537.18146"><vh>vc.vim_d2</vh></v>
<v t="ekr.20140811175537.18147"><vh>vc.vim_d3</vh></v>
<v t="ekr.20140811175537.18145"><vh>vc.vim_di</vh></v>
</v>
<v t="ekr.20140730175636.17991"><vh>vc.vim_dollar</vh></v>
<v t="ekr.20131111105746.16544"><vh>vc.vim_dot</vh></v>
<v t="ekr.20140222064735.16623"><vh>vc.vim_e</vh></v>
<v t="ekr.20140222064735.16632"><vh>vc.vim_esc</vh></v>
<v t="ekr.20140222064735.16687"><vh>vc.vim_F</vh></v>
<v t="ekr.20140220134748.16620"><vh>vc.vim_f</vh></v>
<v t="ekr.20140803220119.18112"><vh>vc.vim_G</vh></v>
<v t="ekr.20140220134748.16621"><vh>vc.vim_g</vh></v>
<v t="ekr.20131111061547.16468"><vh>vc.vim_h</vh></v>
<v t="ekr.20140222064735.16618"><vh>vc.vim_i</vh></v>
<v t="ekr.20140220134748.16617"><vh>vc.vim_j</vh></v>
<v t="ekr.20140222064735.16628"><vh>vc.vim_k</vh></v>
<v t="ekr.20140222064735.16627"><vh>vc.vim_l</vh></v>
<v t="ekr.20131111171616.16497"><vh>vc.vim_m (to do)</vh></v>
<v t="ekr.20140220134748.16625"><vh>vc.vim_n</vh></v>
<v t="ekr.20140222064735.16692"><vh>vc.vim_O</vh></v>
<v t="ekr.20140222064735.16619"><vh>vc.vim_o</vh></v>
<v t="ekr.20140220134748.16622"><vh>vc.vim_p</vh></v>
<v t="ekr.20140807152406.18125"><vh>vc.vim_P</vh></v>
<v t="ekr.20140808173212.18070"><vh>vc.vim_pound</vh></v>
<v t="ekr.20140220134748.16623"><vh>vc.vim_q (registers)</vh></v>
<v t="ekr.20140807152406.18127"><vh>vc.vim_question</vh></v>
<v t="ekr.20140220134748.16624"><vh>vc.vim_r (to do)</vh></v>
<v t="ekr.20140222064735.16625"><vh>vc.vim_redo (to do)</vh></v>
<v t="ekr.20140222064735.16626"><vh>vc.vim_s (to do)</vh></v>
<v t="ekr.20140222064735.16622"><vh>vc.vim_slash</vh></v>
<v t="ekr.20140810210411.18239"><vh>vc.vim_star</vh></v>
<v t="ekr.20140222064735.16620"><vh>vc.vim_t</vh></v>
<v t="ekr.20140222064735.16686"><vh>vc.vim_T</vh></v>
<v t="ekr.20140220134748.16626"><vh>vc.vim_u</vh></v>
<v t="ekr.20140220134748.16627"><vh>vc.vim_v</vh></v>
<v t="ekr.20140811110221.18250"><vh>vc.vim_V</vh></v>
<v t="ekr.20140222064735.16624"><vh>vc.vim_w</vh></v>
<v t="ekr.20140220134748.16629"><vh>vc.vim_x</vh></v>
<v t="ekr.20140220134748.16630"><vh>vc.vim_y</vh></v>
<v t="ekr.20140807152406.18126"><vh>vc.vim_Y</vh></v>
<v t="ekr.20140220134748.16631"><vh>vc.vim_z (to do)</vh></v>
</v>
<v t="ekr.20140222064735.16658"><vh>vc.vis_...(motions) (just notes)</vh>
<v t="ekr.20140801121720.18071"><vh> Notes</vh></v>
<v t="ekr.20140222064735.16635"><vh>motion non-letters (to do)</vh>
<v t="ekr.20140222064735.16655"><vh>vis_minus</vh></v>
<v t="ekr.20140222064735.16654"><vh>vis_plus</vh></v>
</v>
</v>
<v t="ekr.20140222064735.16647"><vh>vc.vis_...(terminators)</vh>
<v t="ekr.20140222064735.16684"><vh>vis_escape</vh></v>
<v t="ekr.20140222064735.16661"><vh>vis_J</vh></v>
<v t="ekr.20140222064735.16656"><vh>vis_c (to do)</vh></v>
<v t="ekr.20140222064735.16657"><vh>vis_d</vh></v>
<v t="ekr.20140222064735.16659"><vh>vis_u</vh></v>
<v t="ekr.20140222064735.16681"><vh>vis_v</vh></v>
<v t="ekr.20140222064735.16660"><vh>vis_y</vh></v>
</v>
</v>
<v t="ekr.20140221085636.16685"><vh>vc.do_key &amp; helpers</vh>
<v t="ekr.20140802225657.18021"><vh>vc.handle_specials</vh></v>
<v t="ekr.20140802120757.18003"><vh>vc.init_scanner_vars</vh></v>
</v>
<v t="ekr.20140815160132.18821"><vh>vc.external commands</vh>
<v t="ekr.20140815160132.18823"><vh>class vc.LoadFileAtCursor (:r)</vh>
<v t="ekr.20140820034724.18316"><vh>:r.__call__ </vh></v>
<v t="ekr.20140820034724.18317"><vh>:r.load_file_at_cursor</vh></v>
<v t="ekr.20140820034724.18318"><vh>:r.tab_callback</vh></v>
</v>
<v t="ekr.20140815160132.18828"><vh>class vc.Substitution (:%)</vh>
<v t="ekr.20140820063930.18321"><vh>:%.__call__</vh></v>
<v t="ekr.20140820063930.18323"><vh>:%.tab_callback</vh></v>
</v>
<v t="ekr.20140815160132.18829"><vh>class vc.Tabnew (:tabnew)</vh>
<v t="ekr.20140820034724.18313"><vh>:tabnew.__call__</vh></v>
<v t="ekr.20140820034724.18315"><vh>:tabnew.open_file_by_name</vh></v>
<v t="ekr.20140820034724.18314"><vh>:tabnew.tab_callback</vh></v>
</v>
<v t="ekr.20140815160132.18822"><vh>vc.cycle_focus &amp; cycle_all_focus (:gt &amp; :gT)</vh></v>
<v t="ekr.20140815160132.18824"><vh>vc.print_dot (:print-dot)</vh></v>
<v t="ekr.20140815160132.18825"><vh>vc.q_command &amp; qa_command (:q &amp; :qa)</vh></v>
<v t="ekr.20140815160132.18826"><vh>vc.revert (:e!)</vh></v>
<v t="ekr.20140815160132.18827"><vh>vc.shell_command (:!)</vh></v>
<v t="ekr.20140815160132.18830"><vh>vc.toggle_vim_mode</vh></v>
<v t="ekr.20140815160132.18831"><vh>vc.toggle_vim_trainer_mode</vh></v>
<v t="ekr.20140815160132.18832"><vh>w/xa/wz_command (:w &amp; :xa &amp; wq)</vh></v>
</v>
<v t="ekr.20140802225657.18026"><vh>vc.state handlers</vh>
<v t="ekr.20140803220119.18089"><vh>vc.do_inner_motion</vh></v>
<v t="ekr.20140803220119.18090"><vh>vc.do_insert_mode &amp; helper</vh>
<v t="ekr.20140807112800.18122"><vh>vc.test_for_insert_escape</vh></v>
</v>
<v t="ekr.20140803220119.18091"><vh>vc.do_normal_mode</vh></v>
<v t="ekr.20140802225657.18029"><vh>vc.do_state</vh></v>
<v t="ekr.20140803220119.18092"><vh>vc.do_visual_mode</vh></v>
</v>
<v t="ekr.20140222064735.16682"><vh>vc.Utilities</vh>
<v t="ekr.20140802142132.17981"><vh>show_dot &amp; show_list</vh></v>
<v t="ekr.20140802183521.17998"><vh>vc.add_to_dot</vh></v>
<v t="ekr.20140802120757.18002"><vh>vc.compute_dot</vh></v>
<v t="ekr.20140810214537.18241"><vh>vc.do</vh></v>
<v t="ekr.20140802183521.17999"><vh>vc.in_headline &amp; vc.in_tree</vh></v>
<v t="ekr.20140806081828.18157"><vh>vc.is_body &amp; is_head</vh></v>
<v t="ekr.20140801121720.18083"><vh>vc.is_plain_key &amp; is_text_widget</vh></v>
<v t="ekr.20140805064952.18153"><vh>vc.on_idle (no longer used)</vh></v>
<v t="ekr.20140801121720.18079"><vh>vc.on_same_line</vh></v>
<v t="ekr.20140802225657.18022"><vh>vc.oops</vh></v>
<v t="ekr.20140802120757.18001"><vh>vc.save_body (handles undo)</vh></v>
<v t="ekr.20140804123147.18929"><vh>vc.set_border &amp; helper</vh>
<v t="ekr.20140807070500.18161"><vh>vc.set_property</vh></v>
</v>
<v t="ekr.20140222064735.16615"><vh>vc.show_status</vh></v>
<v t="ekr.20140801121720.18080"><vh>vc.to_bol &amp; vc.eol</vh></v>
<v t="ekr.20140805064952.18152"><vh>vc.widget_name</vh></v>
</v>
</v>
</v>
<v t="ekr.20140816165728.18940"></v>
<v t="ekr.20140815160132.18828"></v>
<v t="ekr.20131113045621.16547"></v>
<v t="ekr.20140818201021.18301"><vh>Found: (flattened) .getArg</vh>
<v t="ekr.20070317085437.50"><vh>cc.cloneNodeToChapter &amp; helper</vh>
<v t="ekr.20070604155815.1"><vh>cc.cloneToChapterHelper</vh></v>
</v>
<v t="ekr.20070608072116"><vh>cc.convertNodeToChapter</vh></v>
<v t="ekr.20070317085437.51"><vh>cc.copyNodeToChapter &amp; helper</vh>
<v t="ekr.20070604155815.2"><vh>cc.copyNodeToChapterHelper</vh></v>
</v>
<v t="ekr.20070317085437.31"><vh>cc.createChapter</vh></v>
<v t="ekr.20070607092909"><vh>cc.createChapterFromNode</vh></v>
<v t="ekr.20070604155815.3"><vh>cc.moveNodeToChapter &amp; helper</vh>
<v t="ekr.20070317085437.52"><vh>cc.moveNodeToChapterHelper (works)</vh></v>
</v>
<v t="ekr.20070317085437.41"><vh>cc.renameChapter &amp; helper</vh>
<v t="ekr.20110608135633.16553"><vh>cc.renameChapterByName</vh></v>
</v>
<v t="ekr.20070604165126"><vh>cc.selectChapter &amp; helper</vh>
<v t="ekr.20070317130250"><vh>cc.selectChapterByName &amp; helper</vh>
<v t="ekr.20090306060344.2"><vh>selectChapterByNameHelper</vh></v>
</v>
</v>
<v t="ekr.20070605110441"><vh>dynamicExpandHelper (added event arg)</vh></v>
<v t="ekr.20050920084036.25"><vh>addAbbreviation</vh></v>
<v t="ekr.20051004080550"><vh>addInverseAbbreviation</vh></v>
<v t="ekr.20050927093851"><vh>getBufferName (added event arg)</vh></v>
<v t="ekr.20050920084036.158"><vh>shellCommand</vh></v>
<v t="ekr.20050920084036.65"><vh>evalExpression</vh></v>
<v t="ekr.20050920084036.68"><vh>setFillColumn</vh></v>
<v t="ekr.20060417194232.1"><vh>findCharacterHelper</vh></v>
<v t="ekr.20080408060320.1"><vh>findWordHelper</vh></v>
<v t="ekr.20050929115226"><vh>gotoCharacter</vh></v>
<v t="ekr.20060417181052"><vh>gotoGlobalLine</vh></v>
<v t="ekr.20050929124234"><vh>gotoLine</vh></v>
<v t="ekr.20050920084036.80"><vh>howMany</vh></v>
<v t="ekr.20110530082209.18248"><vh>replaceCurrentCharacter</vh></v>
<v t="ekr.20050920084036.90"><vh>flushLines</vh></v>
<v t="ekr.20051002095724"><vh>keepLines</vh></v>
<v t="ekr.20110527105255.18386"><vh>setUa</vh></v>
<v t="ekr.20050920084036.164"><vh>deleteFile (changed)</vh></v>
<v t="ekr.20050920084036.168"><vh>makeDirectory</vh></v>
<v t="ekr.20050920084036.169"><vh>removeDirectory</vh></v>
<v t="ekr.20060602154458"><vh>pythonHelp</vh></v>
<v t="ekr.20050920084036.194"><vh>callNamedMacro</vh></v>
<v t="ekr.20050920084036.198"><vh>nameLastMacro</vh></v>
<v t="ekr.20050920084036.232"><vh>stringRectangle</vh></v>
<v t="ekr.20140815160132.18823"></v>
<v t="ekr.20140815160132.18829"></v>
<v t="ekr.20131117164142.17002"><vh>find.setReplaceString</vh></v>
<v t="ekr.20131117164142.17007"><vh>find.stateZeroHelper</vh></v>
<v t="ekr.20140816165728.18940"></v>
<v t="ekr.20140817110228.18317"></v>
<v t="ekr.20061031131434.78"></v>
<v t="ekr.20140816165728.18939"><vh>k.getArg (OLD)</vh>
<v t="ekr.20061031131434.129"><vh>&lt;&lt; init altX vars &gt;&gt; old k.getArg</vh></v>
</v>
<v t="ekr.20091230094319.6244"></v>
<v t="ekr.20061031131434.152"></v>
</v>
<v t="ekr.20140819042405.18307"><vh>Found: (flattened) .setLabel</vh>
<v t="ekr.20050920084036.63"><vh>watchEscape</vh></v>
<v t="ekr.20050920084036.64"><vh>escEvaluate (Revise)</vh></v>
<v t="ekr.20050920084036.84"><vh>whatLine</vh></v>
<v t="ekr.20050920084036.164"></v>
<v t="ekr.20050920084036.168"></v>
<v t="ekr.20050920084036.169"></v>
<v t="ekr.20140813052702.18201"></v>
<v t="ekr.20140816165728.18958"></v>
<v t="ekr.20061031131434.112"></v>
<v t="ekr.20061031131434.175"><vh>k.computeCompletionList</vh></v>
<v t="ekr.20061031131434.178"><vh>k.doTabCompletion</vh></v>
<v t="ekr.20061031170011.8"></v>
<v t="ekr.20061031170011.10"></v>
<v t="ekr.20061031170011.11"></v>
<v t="ekr.20080510153327.2"></v>
</v>
<v t="ekr.20140818145250.18238"><vh>Found: k.setLabelBlue</vh>
<v t="ekr.20050920084036.25"></v>
<v t="ekr.20051004080550"></v>
<v t="ekr.20050920084036.35"><vh>appendToBuffer</vh></v>
<v t="ekr.20050920084036.238"><vh>appendToRegister</vh></v>
<v t="ekr.20050920084036.194"></v>
<v t="ekr.20070317085437.50"></v>
<v t="ekr.20070608072116"></v>
<v t="ekr.20070317085437.51"></v>
<v t="ekr.20070317085437.31"></v>
<v t="ekr.20070607092909"></v>
<v t="ekr.20070604155815.3"></v>
<v t="ekr.20070317085437.41"></v>
<v t="ekr.20070604165126"></v>
<v t="ekr.20050920084036.239"><vh>copyRectangleToRegister</vh></v>
<v t="ekr.20050920084036.36"><vh>copyToBuffer</vh></v>
<v t="ekr.20050920084036.240"><vh>copyToRegister</vh></v>
<v t="ekr.20050920084036.164"></v>
<v t="ekr.20061031131434.203"></v>
<v t="ekr.20070605110441"></v>
<v t="ekr.20050920084036.206"><vh>endMacro</vh></v>
<v t="ekr.20050920084036.65"></v>
<v t="ekr.20131117164142.17002"></v>
<v t="ekr.20131117164142.16955"><vh>find.startIncremental</vh></v>
<v t="ekr.20131117164142.17007"></v>
<v t="ekr.20060417194232.1"></v>
<v t="ekr.20080408060320.1"></v>
<v t="ekr.20050920084036.90"></v>
<v t="ekr.20050929115226"></v>
<v t="ekr.20060417181052"></v>
<v t="ekr.20050929124234"></v>
<v t="ekr.20050920084036.80"></v>
<v t="ekr.20050920084036.241"><vh>incrementRegister</vh></v>
<v t="ekr.20050920084036.242"><vh>insertRegister</vh></v>
<v t="ekr.20050920084036.37"><vh>insertToBuffer</vh></v>
<v t="ekr.20050920084036.243"><vh>jumpToRegister</vh></v>
<v t="ekr.20061031131434.115"></v>
<v t="ekr.20061031131434.111"></v>
<v t="ekr.20061031131434.117"></v>
<v t="ekr.20061031131434.164"></v>
<v t="ekr.20061031131434.122"></v>
<v t="ekr.20061031170011.7"></v>
<v t="ekr.20061031170011.10"></v>
<v t="ekr.20061031131434.192"></v>
<v t="ekr.20051002095724"></v>
<v t="ekr.20050920084036.38"><vh>killBuffer</vh></v>
<v t="ekr.20050920084036.168"></v>
<v t="ekr.20050920084036.198"></v>
<v t="ekr.20050920084036.244"><vh>numberToRegister (not used)</vh></v>
<v t="ekr.20060419123128"><vh>openOutlineByName (EditFileCommandsClass)</vh></v>
<v t="ekr.20050920084036.245"><vh>pointToRegister</vh></v>
<v t="ekr.20050920084036.39"><vh>prependToBuffer</vh></v>
<v t="ekr.20050920084036.237"><vh>prependToRegister</vh></v>
<v t="ekr.20060602154458"></v>
<v t="ekr.20050920084036.169"></v>
<v t="ekr.20050920084036.43"><vh>renameBuffer</vh></v>
<v t="ekr.20110530082209.18248"></v>
<v t="ekr.20050920084036.68"></v>
<v t="ekr.20110527105255.18386"></v>
<v t="ekr.20050920084036.158"></v>
<v t="ekr.20050920084036.204"><vh>startRecordingMacro</vh></v>
<v t="ekr.20050920084036.232"></v>
<v t="ekr.20050920084036.40"><vh>switchToBuffer</vh></v>
<v t="ekr.20140222064735.16615"></v>
<v t="ekr.20050920084036.246"><vh>viewRegister</vh></v>
<v t="ekr.20050920084036.63"></v>
<v t="ekr.20050920084036.128"><vh>zapToCharacter</vh></v>
</v>
<v t="ekr.20140808182202.18184"><vh>Set dot in f,F,t,T commands</vh>
<v t="ekr.20140802183521.17998"></v>
<v t="ekr.20140222064735.16631"></v>
<v t="ekr.20140220134748.16620"></v>
<v t="ekr.20140222064735.16687"></v>
<v t="ekr.20140222064735.16620"></v>
<v t="ekr.20140222064735.16686"></v>
<v t="ekr.20140802183521.17998"></v>
<v t="ekr.20140802225657.18031"></v>
<v t="ekr.20140222064735.16615"></v>
<v t="ekr.20140222064735.16631"></v>
<v t="ekr.20140220134748.16627"></v>
</v>
<v t="ekr.20140730175636.17982"><vh>** Vim to-do</vh>
<v t="ekr.20140814105040.18408"><vh>New vim bugs from Kent</vh></v>
<v t="ekr.20140816165728.18937"><vh>Maybe from Kent</vh></v>
<v t="ekr.20140808182202.18183"><vh>Maybe</vh></v>
</v>
<v t="ekr.20140821050318.18324"><vh>** document GetArg and remove prefix &amp; new_arg</vh>
<v t="ekr.20140816165728.18968"></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@file leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005506302e31352e3071017d71025808000000616e6e6f7461746571037d710473732e"
marks="ekr.20130111185820.10194,"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20111116103733.9817"><vh>@file leoInspect.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821054212.25844"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285505302e332e3271017d71022858090000007374725f6374696d657103580c000000313331393436303438332e30710458090000007374725f6d74696d657105580d000000313331393436373035302e3438710658090000007374725f6174696d657107580d000000313331393436373035302e34387108755505302e332e3371097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313332303432323639302e3534710e58090000007374725f6174696d65710f580d000000313332303433343235372e33367110755505302e332e3071117d71122858090000007374725f6374696d657113580c000000313331393439313330362e30711458090000007374725f6d74696d657115580d000000313331393439323330312e3532711658090000007374725f6174696d657117580d000000313331393534393339302e38397118755505302e332e3171197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313331393436373033382e3235711e58090000007374725f6174696d65711f580c000000313332303432323637302e397120755505302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755505302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20140526082700.17153"><vh>@file leoSTC.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131230090121.16504"><vh>@file leoViews.py</vh></v>
<v t="ekr.20131109170017.16504" a="O"></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434" a="O"></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20110605121601.17863"><vh>@file ../plugins/baseNativeTree.py</vh></v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qtframecommands.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20130701072841.12673"><vh>@file qsyntaxhighlighter.py</vh></v>
<v t="ekr.20110605121601.18695"><vh>QDesigner files</vh>
<v t="ekr.20110605121601.18696"><vh>@auto ../test/qtui_generate.py</vh></v>
<v t="ekr.20110605121601.18698"><vh>@auto ../plugins/qt_main.py</vh></v>
<v t="ekr.20110605121601.18703"><vh>@auto ../plugins/qt_main.ui</vh></v>
<v t="ekr.20110605121601.18704"><vh>@auto ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20110605121601.18709"><vh>@auto ../plugins/qt_quicksearch.ui</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py </vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e">@tabwidth -4
@pagewidth 70

@ 
This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:
    
si: a g.ShortcutInfo object.
ks: a g.KeyStroke object
stroke: a KeyStroke object.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2604">
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily. 

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass. 

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.
  
- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction. 
</t>
<t tx="ekr.20050920084036.128">def zapToCharacter (self,event):

    '''Kill characters from the insertion point to a given character.'''

    k = self.k ; w = self.editWidget(event)
    if not w: return

    state = k.getState('zap-to-char')
    if state == 0:
        k.setLabelBlue('Zap To Character: ')
        k.setState('zap-to-char',1,handler=self.zapToCharacter)
    else:
        ch = event and event.char or ' '
        k.resetLabel()
        k.clearState()
        s = w.getAllText()
        ins = w.getInsertPoint()
        i = s.find(ch,ins)
        if i == -1: return
        self.beginCommand(undoType='zap-to-char')
        self.addToKillBuffer(s[ins:i])
        g.app.gui.replaceClipboardWith(s[ins:i]) # Support for proper yank.
        w.setAllText(s[:ins] + s[i:])
        w.setInsertPoint(ins)
        self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20050920084036.158">def shellCommand (self,event):
    '''Execute a shell command.'''
    k = self.k
    state = k.getState('shell-command')
    if state == 0:
        k.setLabelBlue('shell-command: ')
        k.getArg(event,'shell-command',1,self.shellCommand)
    else:
        command = k.arg
        # k.commandName = 'shell-command: %s' % command
        # k.clearState()
        self.executeSubprocess(event,command)
</t>
<t tx="ekr.20050920084036.164">def deleteFile (self,event):

    '''Prompt for the name of a file and delete it.'''

    k = self.k ; state = k.getState('delete_file')

    if state == 0:
        k.setLabelBlue('Delete File: ')
        k.extendLabel(os.getcwd() + os.sep)
        k.getArg(event,'delete_file',1,self.deleteFile)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.remove(k.arg)
            k.setLabel('Deleted: %s' % k.arg)
            # g.es('Deleted: %s' % k.arg)
        except Exception:
            k.setLabel('Not Deleted: %s' % k.arg)
            # g.es('Not Deleted: %s' % k.arg)
</t>
<t tx="ekr.20050920084036.168">def makeDirectory (self,event):
    '''Prompt for the name of a directory and create it.'''
    k = self.k
    state = k.getState('make_directory')
    if state == 0:
        k.setLabelBlue('Make Directory: ')
        k.extendLabel(os.getcwd() + os.sep)
        k.getArg(event,'make_directory',1,self.makeDirectory)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.mkdir(k.arg)
            k.setLabel("Created: %s" % k.arg)
            # g.es("Created: %s" % k.arg)
        except Exception:
            k.setLabel("Not Create: %s" % k.arg)
            # g.es("Not Created: %s" % k.arg)
</t>
<t tx="ekr.20050920084036.169">def removeDirectory (self,event):

    '''Prompt for the name of a directory and delete it.'''

    k = self.k ; state = k.getState('remove_directory')

    if state == 0:
        k.setLabelBlue('Remove Directory: ')
        k.extendLabel(os.getcwd() + os.sep)
        k.getArg(event,'remove_directory',1,self.removeDirectory)
    else:
        k.keyboardQuit()
        k.clearState()
        try:
            os.rmdir(k.arg)
            k.setLabel('Removed: %s' % k.arg)
            # g.es('Removed: %s' % k.arg)
        except Exception:
            k.setLabel('Not Removed: %s' % k.arg)
            # g.es('Not Removed: %s' % k.arg)
</t>
<t tx="ekr.20050920084036.194">def callNamedMacro (self,event):

    '''Prompts for a macro name, then executes it.'''

    k = self.k ; tag = 'macro-name'
    state = k.getState(tag)
    prompt = 'Call macro named: '

    if state == 0:
        k.setLabelBlue(prompt)
        k.getArg(event,tag,1,self.callNamedMacro)
    else:
        macro = self.namedMacros.get(k.arg)
        # Must do this first!
        k.clearState()
        if macro:
            self.executeMacro(macro)
        else:
            g.es('no macro named %s' % k.arg)
        k.resetLabel()

</t>
<t tx="ekr.20050920084036.198">def nameLastMacro (self,event):

    '''Prompts for the name to be given to the last recorded macro.'''

    k = self.k ; state = k.getState('name-macro')

    if state == 0:
        k.setLabelBlue('Name of macro: ')
        k.getArg(event,'name-macro',1,self.nameLastMacro)
    else:
        k.clearState()
        name = k.arg
        self.completeMacroDef(name,self.lastMacro)
        k.setLabelGrey('Macro defined: %s' % name)
</t>
<t tx="ekr.20050920084036.204">def startRecordingMacro (self,event):

    '''Start recording or continue to record a macro.'''

    trace = False and not g.unitTesting
    k = self.k

    if event:
        if self.recordingMacro:
            if trace: g.trace('stroke',event.stroke)
            self.macro.append(event)
        else:
            self.recordingMacro = True
            k.setLabelBlue('Recording macro. ctrl-g to end...',protect=True)
            # g.es('Recording macro. ctrl-g to end...')
    else:
        g.trace('can not happen: no event')
</t>
<t tx="ekr.20050920084036.206">def endMacro (self,event=None):
    '''Stops recording a macro.'''
    k = self.k
    self.recordingMacro = False
        # Tell k.masterKeyHandler and k.masterCommandHandler we are done.
    if self.macro:
        # self.macro = self.macro [: -4]
        self.macros.insert(0,self.macro)
        self.lastMacro = self.macro[:]
        self.macro = []
        k.setLabelBlue('Keyboard macro defined, not named')
        # g.es('Keyboard macro defined, not named')
    else:
        k.setLabelBlue('Empty keyboard macro')
        # g.es('Empty keyboard macro')
</t>
<t tx="ekr.20050920084036.232">def stringRectangle (self,event):

    '''Prompt for a string, then replace the contents of a rectangle
    with a string on each line.'''

    c = self.c ; k = self.k ; state = k.getState('string-rect')
    if g.app.unitTesting:
        state = 1 ; k.arg = 's...s' # This string is known to the unit test.
        w = self.editWidget(event)
        self.stringRect = self.getRectanglePoints(w)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w or not self.check(event): return
        self.stringRect = self.getRectanglePoints(w)
        k.setLabelBlue('String rectangle: ')
        k.getArg(event,'string-rect',1,self.stringRectangle)
    else:
        k.clearState()
        k.resetLabel()
        c.bodyWantsFocus()
        w = self.w
        self.beginCommand('string-rectangle')
        # pylint: disable=unpacking-non-sequence
        r1,r2,r3,r4 = self.stringRect
        s = w.getAllText()
        for r in range(r1,r3+1):
            i = g.convertRowColToPythonIndex(s,r-1,r2)
            j = g.convertRowColToPythonIndex(s,r-1,r4)
            s = s[:i] + k.arg + s[j:]
        w.setAllText(s)
        i = g.convertRowColToPythonIndex(s,r1-1,r2)
        j = g.convertRowColToPythonIndex(s,r3-1,r2+len(k.arg))
        w.setSelectionRange(i,j)
        self.endCommand()
        # 2010/1/1: Fix bug 480422:
        # string-rectangle kills syntax highlighting.
        c.frame.body.recolor(c.p,incremental=False)

</t>
<t tx="ekr.20050920084036.237">def prependToRegister (self,event):

    '''Prompt for a register name and prepend the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'prepend-to-register' ; state = k.getState(tag)

    char = event and event.char or ''

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Prepend to Register: ')
        k.setState(tag,1,self.prependToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if char.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = char.lower()
                val = self.registers.get(key,'')
                val = w.getSelectedText() + val
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.238">def appendToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'append-to-register' ; state = k.getState(tag)

    char = event and event.char or ''

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Append to Register: ')
        k.setState(tag,1,self.appendToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if char.isalpha():
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                key = char.lower()
                val = self.registers.get(key,'')
                val = val + w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.239">def copyRectangleToRegister (self,event):

    '''Prompt for a register name and append the rectangle defined by selected
    text to the register's contents.'''

    c = self.c ; k = self.k ; state = k.getState('copy-rect-to-reg')

    char = event and event.char or ''

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        k.commandName = 'copy-rectangle-to-register'
        k.setLabelBlue('Copy Rectangle To Register: ')
        k.setState('copy-rect-to-reg',1,self.copyRectangleToRegister)
    elif self.checkBodySelection('No rectangle selected'):
        k.clearState()
        if char.isalpha():
            key = char.lower()
            w = self.w
            c.widgetWantsFocusNow(w)
            r1, r2, r3, r4 = self.getRectanglePoints(w)
            rect = []
            while r1 &lt;= r3:
                txt = w.get('%s.%s' % (r1,r2),'%s.%s' % (r1,r4))
                rect.append(txt)
                r1 = r1 + 1
            self.registers [key] = rect
            k.setLabelGrey('Register %s = %s' % (key,repr(rect)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.240">def copyToRegister (self,event):

    '''Prompt for a register name and append the selected text to the register's contents.'''

    c = self.c ; k = self.k
    tag = 'copy-to-register' ; state = k.getState(tag)

    char = event and event.char or ''

    if state == 0:
        k.commandName = tag
        k.setLabelBlue('Copy to Register: ')
        k.setState(tag,1,self.copyToRegister)
    else:
        k.clearState()
        if self.checkBodySelection():
            if char.isalpha():
                key = char.lower()
                w = c.frame.body.bodyCtrl
                c.bodyWantsFocus()
                val = w.getSelectedText()
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            else:
                k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.241">def incrementRegister (self,event):

    '''Prompt for a register name and increment its value if it has a numeric value.'''

    c = self.c ; k = self.k ; state = k.getState('increment-reg')

    char = event and event.char or ''

    if state == 0:
        k.setLabelBlue('Increment register: ')
        k.setState('increment-reg',1,self.incrementRegister)
    else:
        k.clearState()
        if self._checkIfRectangle(event):
            pass # Error message is in the label.
        elif char.isalpha():
            key = char.lower()
            val = self.registers.get(key,0)
            try:
                val = str(int(val)+1)
                self.registers[key] = val
                k.setLabelGrey('Register %s = %s' % (key,repr(val)))
            except ValueError:
                k.setLabelGrey("Can't increment register %s = %s" % (key,val))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.242">def insertRegister (self,event):

    '''Prompt for a register name and and insert the value of another register into its contents.'''

    c = self.c ; k = self.k ; state = k.getState('insert-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'insert-register'
        k.setLabelBlue('Insert register: ')
        k.setState('insert-reg',1,self.insertRegister)
    else:
        k.clearState()
        if char.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = char.lower()
            val = self.registers.get(key)
            if val:
                if type(val)==type([]):
                    c.recTangleCommands.yankRectangle(val)
                else:
                    i = w.getInsertPoint()
                    w.insert(i,val)
                k.setLabelGrey('Inserted register %s' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.243">def jumpToRegister (self,event):

    '''Prompt for a register name and set the insert point to the value in its register.'''

    c = self.c ; k = self.k ; state = k.getState('jump-to-reg')

    char = event and event.char or ''

    if state == 0:
        k.setLabelBlue('Jump to register: ')
        k.setState('jump-to-reg',1,self.jumpToRegister)
    else:
        k.clearState()
        if char.isalpha():
            if self._checkIfRectangle(event): return
            key = char.lower()
            val = self.registers.get(key)
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            if val:
                try:
                    w.setInsertPoint(val)
                    k.setLabelGrey('At %s' % repr(val))
                except Exception:
                    k.setLabelGrey('Register %s is not a valid location' % key)
            else:
                k.setLabelGrey('Register %s is empty' % key)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.244">@
C-u number C-x r n reg
    Store number into register reg (number-to-register).
C-u number C-x r + reg
    Increment the number in register reg by number (increment-register).
C-x r g reg
    Insert the number from register reg into the buffer.
@c

def numberToRegister (self,event):

    c,k = self.c,self.k
    state = k.getState('number-to-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'number-to-register'
        k.setLabelBlue('Number to register: ')
        k.setState('number-to-reg',1,self.numberToRegister)
    else:
        k.clearState()
        if char.isalpha():
            # self.registers[char.lower()] = str(0)
            k.setLabelGrey('number-to-register not ready yet.')
        else:
            k.setLabelGrey('Register must be a letter')
</t>
<t tx="ekr.20050920084036.245">def pointToRegister (self,event):

    '''Prompt for a register name and put a value indicating the insert point in the register.'''

    c = self.c ; k = self.k ; state = k.getState('point-to-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'point-to-register'
        k.setLabelBlue('Point to register: ')
        k.setState('point-to-reg',1,self.pointToRegister)
    else:
        k.clearState()
        if char.isalpha():
            w = c.frame.body.bodyCtrl
            c.bodyWantsFocus()
            key = char.lower()
            val = w.getInsertPoint()
            self.registers[key] = val
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.246">def viewRegister (self,event):

    '''Prompt for a register name and print its contents.'''

    c = self.c ; k = self.k ; state = k.getState('view-reg')

    char = event and event.char or ''

    if state == 0:
        k.commandName = 'view-register'
        k.setLabelBlue('View register: ')
        k.setState('view-reg',1,self.viewRegister)
    else:
        k.clearState()
        if char.isalpha():
            key = char.lower()
            val = self.registers.get(key)
            k.setLabelGrey('Register %s = %s' % (key,repr(val)))
        else:
            k.setLabelGrey('Register must be a letter')
    c.bodyWantsFocus()
</t>
<t tx="ekr.20050920084036.25">def addAbbreviation (self,event):

    '''Add an abbreviation:
    The selected text is the abbreviation;
    the minibuffer prompts you for the name of the abbreviation.
    Also sets abbreviations on.'''

    k = self.k ; state = k.getState('add-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Abbreviation: ')
        k.getArg(event,'add-abbr',1,self.addAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        value = k.argSelectedText # 2010/09/01.
        if k.arg.strip():
            self.abbrevs [k.arg] = value,'dynamic'
            k.abbrevOn = True
            k.setLabelGrey(
                "Abbreviation (on): '%s' = '%s'" % (
                    k.arg,value))
</t>
<t tx="ekr.20050920084036.35">def appendToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Append to buffer: ')
        self.getBufferName(event,self.appendToBufferFinisher)

def appendToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        w = self.w
        c.selectPosition(p)
        self.beginCommand('append-to-buffer: %s' % p.h)
        w.insert('end',s)
        w.setInsertPoint('end')
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
</t>
<t tx="ekr.20050920084036.36">def copyToBuffer (self,event):

    '''Add the selected body text to the end of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Copy to buffer: ')
        self.getBufferName(event,self.copyToBufferFinisher)

def copyToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('copy-to-buffer: %s' % p.h)
        w.insert('end',s)
        w.setInsertPoint('end')
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
</t>
<t tx="ekr.20050920084036.37">def insertToBuffer (self,event):

    '''Add the selected body text at the insert point of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Insert to buffer: ')
        self.getBufferName(event,self.insertToBufferFinisher)

def insertToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('insert-to-buffer: %s' % p.h)
        i = w.getInsertPoint()
        w.insert(i,s)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
</t>
<t tx="ekr.20050920084036.38">def killBuffer (self,event):

    '''Delete a buffer (node) and all its descendants.'''

    w = self.editWidget(event) # Sets self.w
    if not w: return

    self.k.setLabelBlue('Kill buffer: ')
    self.getBufferName(event,self.killBufferFinisher)

def killBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        h = p.h
        current = c.p
        c.selectPosition(p)
        c.deleteOutline (op_name='kill-buffer: %s' % h)
        c.selectPosition(current)
        self.k.setLabelBlue('Killed buffer: %s' % h)
        c.redraw(current)
</t>
<t tx="ekr.20050920084036.39">def prependToBuffer (self,event):

    '''Add the selected body text to the start of the body text of a named buffer (node).'''

    w = self.editWidget(event) # Sets self.w
    if w:
        self.k.setLabelBlue('Prepend to buffer: ')
        self.getBufferName(event,self.prependToBufferFinisher)

def prependToBufferFinisher (self,name):

    c,w = self.c,self.w
    s = w.getSelectedText()
    p = self.findBuffer(name)
    if s and p:
        c.selectPosition(p)
        self.beginCommand('prepend-to-buffer: %s' % p.h)
        w.insert(0,s)
        w.setInsertPoint(0)
        w.seeInsertPoint()
        self.endCommand()
        c.redraw_after_icons_changed()
        c.recolor()
</t>
<t tx="ekr.20050920084036.40">def switchToBuffer (self,event):

    '''Select a buffer (node) by its name (headline).'''

    self.k.setLabelBlue('Switch to buffer: ')
    self.getBufferName(event,self.switchToBufferFinisher)

def switchToBufferFinisher (self,name):

    c = self.c ; p = self.findBuffer(name)
    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

</t>
<t tx="ekr.20050920084036.43">def renameBuffer (self,event):

    '''Rename a buffer, i.e., change a node's headline.'''

    g.es('rename-buffer not ready yet')
    if 0:
        self.k.setLabelBlue('Rename buffer from: ')
        self.getBufferName(event,self.renameBufferFinisher1)

def renameBufferFinisher1 (self,name):

    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    event = None
    self.getBufferName(event,self.renameBufferFinisher2)

def renameBufferFinisher2 (self,name):

    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.endEditing()
        c.setHeadString(p,name)
        c.redraw(p)
</t>
<t tx="ekr.20050920084036.63">def watchEscape (self,event):

    '''Enter watch escape mode.'''

    c,k = self.c,self.k

    char = event and event.char or ''

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        # hi1 = k.keysymHistory [0]
        # hi2 = k.keysymHistory [1]
        data1 = g.app.lossage[0]
        data2 = g.app.lossage[1]
        ch1, stroke1 = data1
        ch2, stroke2 = data2

        if state == 'esc esc' and char == ':':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        # elif hi1 == hi2 == 'Escape':
        elif stroke1 == 'Escape' and stroke2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif char not in ('Shift_L','Shift_R'):
            k.keyboardQuit()
</t>
<t tx="ekr.20050920084036.64">def escEvaluate (self,event):

    c,k = self.c,self.k

    w = self.editWidget(event)
    if not w: return

    char = event and event.char or ''

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if char in ('\n','Return'):
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            i = w.getInsertPoint()
            w.insert(i,result)
            ok = True
        finally:
            k.keyboardQuit()
            if not ok:
                k.setLabel('Error: Invalid Expression')
                # g.es('Error: Invalid Expression')
    else:
        k.updateLabel(event)
</t>
<t tx="ekr.20050920084036.65">def evalExpression (self,event):
    '''Evaluate a Python Expression entered in the minibuffer.'''
    k = self.k ; state = k.getState('eval-expression')
    if state == 0:
        k.setLabelBlue('Eval: ')
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)
</t>
<t tx="ekr.20050920084036.68">def setFillColumn (self,event):

    '''Set the fill column used by the center-line and center-region commands.'''

    k = self.k ; state = k.getState('set-fill-column')

    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            # Bug fix: 2011/05/23: set the fillColumn ivar!
            self.fillColumn = n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()
</t>
<t tx="ekr.20050920084036.80">def howMany (self,event):

    '''Print how many occurances of a regular expression are found
    in the body text of the presently selected node.'''

    k = self.k
    w = self.editWidget(event)
    if not w: return

    state = k.getState('how-many')
    if state == 0:
        k.setLabelBlue('How many: ')
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.getAllText()
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))
</t>
<t tx="ekr.20050920084036.84">def whatLine (self,event):
    '''Print the line number of the line containing the cursor.'''
    k = self.k ; w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    i = w.getInsertPoint()
    row,col = g.convertPythonIndexToRowCol(s,i)
    k.keyboardQuit()
    k.setLabel("Line %s" % row)
    # g.es("Line %s" % row)
</t>
<t tx="ekr.20050920084036.90">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')

    if state == 0:
        k.setLabelBlue('Flush lines regexp: ')
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg
</t>
<t tx="ekr.20050927093851">def getBufferName (self,event,finisher):

    '''Get a buffer name into k.arg and call k.setState(kind,n,handler).'''

    c,k = self.c,self.k
    state = k.getState('getBufferName')

    if state == 0:
        self.computeData()
        self.getBufferNameFinisher = finisher
        prefix = k.getLabel()
        k.getArg(event,'getBufferName',1,self.getBufferName,
            prefix=prefix,tabList=self.nameList)
    else:
        k.resetLabel()
        k.clearState()
        finisher = self.getBufferNameFinisher
        self.getBufferNameFinisher = None
        finisher(k.arg)
</t>
<t tx="ekr.20050929115226">def gotoCharacter (self,event):

    '''Put the cursor at the n'th character of the buffer.'''

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue("Goto n'th character: ")
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.w ; ok = False
        if n.isdigit():
            n = int(n)
            if n &gt;= 0:
                w.setInsertPoint(n)
                w.seeInsertPoint()
                ok = True
        if not ok:
            g.warning('goto-char takes non-negative integer argument')
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20050929124234">def gotoLine (self,event):

    '''Put the cursor at the n'th line of the buffer.'''

    k = self.k ; state = k.getState('goto-line')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.w
        if n.isdigit():
            s = w.getAllText()
            i = g.convertRowColToPythonIndex(s,n,0)
            w.setInsertPoint(i)
            w.seeInsertPoint()
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20051002095724">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')

    if state == 0:
        k.setLabelBlue('Keep lines regexp: ')
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg
</t>
<t tx="ekr.20051004080550">def addInverseAbbreviation (self,event):

    '''Add an inverse abbreviation:
    The selected text is the abbreviation name;
    the minibuffer prompts you for the value of the abbreviation.'''

    k = self.k ; state = k.getState('add-inverse-abbr')

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Add Inverse Abbreviation: ')
        k.getArg(event,'add-inverse-abbr',1,self.addInverseAbbreviation)
    else:
        w = self.w
        k.clearState()
        k.resetLabel()
        s = w.getAllText()
        i = w.getInsertPoint()
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        if word:
            self.abbrevs [word] = k.arg,'add-inverse-abbr'
</t>
<t tx="ekr.20051031040240">def relink(self):
    '''Relink all unlinked clones.'''
    d = self.d
    # Find original cloned nodes.
    for key in sorted(d.keys()):
        g.trace(key,d.get(key))</t>
<t tx="ekr.20060417181052">def gotoGlobalLine (self,event):

    '''Put the cursor at the n'th line of a file or script.
    This is a minibuffer interface to Leo's legacy Go To Line number command.'''

    c = self.c
    k = self.k ; tag = 'goto-global-line' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        k.setLabelBlue('Goto global line: ')
        k.getArg(event,tag,1,self.gotoGlobalLine)
    else:
        n = k.arg
        k.resetLabel()
        k.clearState()
        if n.isdigit():
            c.GoToLineNumber(c).go(n=int(n))
</t>
<t tx="ekr.20060417194232.1">def findCharacterHelper (self,event,backward,extend):
    '''Put the cursor at the next occurance of a character on a line.'''
    c = self.c ; k = c.k ; tag = 'find-char' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.event = event
        self.backward = backward
        self.extend = extend or self.extendMode # Bug fix: 2010/01/19
        self.insert = w.getInsertPoint()
        s = '%s character%s: ' % (
            'Backward find' if backward else 'Find',
            ' &amp; extend' if extend else '')
        k.setLabelBlue(s)
        # Get the arg without touching the focus.
        k.getArg(event,tag,1,self.findCharacter,oneCharacter=True,useMinibuffer=False)
    else:
        event = self.event ; w = self.w
        backward = self.backward
        extend = self.extend or self.extendMode
        ch = k.arg ; s = w.getAllText()
        ins = w.toPythonIndex(self.insert)
        i = ins + -1 if backward else +1 # skip the present character.
        if backward:
            start = 0
            j = s.rfind(ch,start,max(start,i)) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        else:
            end = len(s)
            j = s.find(ch,min(i,end),end) # Skip the character at the cursor.
            if j &gt; -1: self.moveToHelper(event,j,extend)
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20060419123128">def openOutlineByName (self,event):
    '''file-open-by-name: Prompt for the name of a Leo outline and open it.'''
    c = self.c ; k = self.k ; fileName = ''.join(k.givenArgs)
    # Bug fix: 2012/04/09: only call g.openWithFileName if the file exists.
    if fileName and g.os_path_exists(fileName):
        g.openWithFileName(fileName,old_c=c)
    else:
        k.setLabelBlue('Open Leo Outline: ')
        k.getFileName(event,callback=self.openOutlineByNameFinisher)

def openOutlineByNameFinisher (self,fn):
    c = self.c
    if fn and g.os_path_exists(fn) and not g.os_path_isdir(fn):
        c2 = g.openWithFileName(fn,old_c=c)
        try:
            g.app.gui.runAtIdle(c2.treeWantsFocusNow)
        except Exception:
            pass
    else:
        g.es('ignoring: %s' % fn)
</t>
<t tx="ekr.20060602154458">def pythonHelp (self,event=None):

    '''Prompt for a arg for Python's help function, and put it to the log pane.'''

    c = self.c ; k = c.k ; tag = 'python-help' ; state = k.getState(tag)

    if state == 0:
        c.minibufferWantsFocus()
        k.setLabelBlue('Python help: ')
        k.getArg(event,tag,1,self.pythonHelp)
    else:
        k.clearState()
        k.resetLabel()
        s = k.arg.strip()
        if s:
            # Capture the output of Python's help command.
            old = sys.stdout
            try:
                sys.stdout = stdout = g.FileLikeObject()
                help(str(s))
                s2 = stdout.read()
            finally:
                sys.stdout = old
            # Send it to the vr pane as a &lt;pre&gt; block
            s2 = '&lt;pre&gt;' + s2 + '&lt;/pre&gt;'
            c.putHelpFor(s2)
</t>
<t tx="ekr.20061031131434">"""Gui-independent keystroke handling for Leo.""" 
# pylint: disable=eval-used
@language python
@tabwidth -4
@pagewidth 70
&lt;&lt; imports &gt;&gt;
&lt;&lt; Key bindings, an overview &gt;&gt;
&lt;&lt; about 'internal' bindings &gt;&gt;
&lt;&lt; about key dicts &gt;&gt;
@others
</t>
<t tx="ekr.20061031131434.1">import leo.core.leoGlobals as g

import leo.external.codewise as codewise

import glob
import inspect
import os
import re
import string
import sys
import time
</t>
<t tx="ekr.20061031131434.10">def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
</t>
<t tx="ekr.20061031131434.100">def addModeCommands (self):
    '''
    Add commands created by @mode settings to c.commandsDict and
    k.inverseCommandsDict.
    '''
    trace = False and not g.unitTesting
    if trace: g.trace('(k)')
    k = self ; c = k.c
    d = g.app.config.modeCommandsDict # Keys are command names: enter-x-mode.
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():
        # pylint: disable=cell-var-from-loop
        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)
        c.commandsDict[key] = f = enterModeCallback
        c.inverseCommandsDict [f.__name__] = key
        if trace: g.trace(f.__name__,key,
            'len(c.commandsDict.keys())',
            len(list(c.commandsDict.keys())))
</t>
<t tx="ekr.20061031131434.101">def initSpecialIvars (self):

    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c
    trace = False or c.config.getBool('trace_bindings_verbose')
    warn  = c.config.getBool('warn_about_missing_settings')

    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
        ('autoCompleteForceKey','auto-complete-force'),
    ):
        junk, aList = c.config.getShortcut(commandName)
        aList,found = aList or [], False
        for pane in ('text','all'):
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.pane == pane:
                    if trace: g.trace(commandName,si.stroke)
                    setattr(k,ivar,si.stroke)
                    found = True; break
        if not found and warn:
            g.trace('no setting for %s' % commandName)
</t>
<t tx="ekr.20061031131434.102">def makeBindingsFromCommandsDict (self):

    '''Add bindings for all entries in c.commandsDict.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    if trace:
        g.trace('makeBindingsFromCommandsDict entry')
        t1 = time.time()

    # Step 1: Create d2.
    # Keys are strokes. Values are lists of si with si.stroke == stroke.
    d = c.commandsDict
    d2 = g.TypedDictOfLists(
        name='makeBindingsFromCommandsDict helper dict',
        keyType=g.KeyStroke,valType=g.ShortcutInfo)

    for commandName in sorted(d.keys()):
        command = d.get(commandName)
        key, aList = c.config.getShortcut(commandName)
        for si in aList:
            assert isinstance(si,g.ShortcutInfo)
            # Important: si.stroke is already canonicalized.
            stroke = si.stroke
            si.commandName = commandName
            if stroke:
                assert g.isStroke(stroke)
                d2.add(stroke,si)

    # Step 2: make the bindings.
    if trace: t2 = time.time()

    for stroke in sorted(d2.keys()):
        aList2 = d2.get(stroke)
        for si in aList2:
            assert isinstance(si,g.ShortcutInfo)
            commandName = si.commandName
            command = c.commandsDict.get(commandName)
            tag = si.kind
            pane = si.pane
            if stroke and not pane.endswith('-mode'):
                k.bindKey(pane,stroke,command,commandName,tag=tag)

    if trace:
        t3 = time.time()
        g.trace('%0.2fsec' % (t2-t1))
        g.trace('%0.2fsec' % (t3-t2))
</t>
<t tx="ekr.20061031131434.103">def makeMasterGuiBinding (self,stroke,w=None):

    '''Make a master gui binding for stroke in pane w, or in all the standard widgets.'''

    k = self ; c = k.c ; f = c.frame
    if w:
        widgets = [w]
    else:
        # New in Leo 4.5: we *must* make the binding in the binding widget.
        bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
        bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
        canvas = f.tree and hasattr(f.tree,'canvas') and f.tree.canvas   or None
        widgets = (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget)

    for w in widgets:
        if not w: continue
        # Make the binding only if no binding for the stroke exists in the widget.
        aList = k.masterGuiBindingsDict.get(stroke,[])
        if w not in aList:
            aList.append(w)
            k.masterGuiBindingsDict [stroke] = aList
</t>
<t tx="ekr.20061031131434.104"></t>
<t tx="ekr.20061031131434.105">def masterCommand (self,commandName=None,event=None,func=None,stroke=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.
    This returns None, but may set k.funcReturn.
    '''
    k = self ; c = k.c
    trace = False and not g.unitTesting
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')
    if event: c.check_event(event)
    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    char = ch = event and event.char or ''
    # 2011/10/28: compute func if not given.
    if commandName and not func:
        func = c.commandsDict.get(commandName)
    # Important: it is *not* an error for func to be None.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    k.funcReturn = None # For unit testing.
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = char in specialKeysyms
    inserted = not special
    if trace: # Useful.
        g.trace('stroke: %s ch: %s func: %s' % (
            stroke,repr(ch),func and func.__name__))
    if inserted:
        k.setLossage(ch,stroke)
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startRecordingMacro(event)
        # 2011/06/06: Show the key, if possible.
    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit()
        k.endCommand(commandName)
        return
    if special: # Don't pass these on.
        return
    # if k.regx.iter:
        # try:
            # k.regXKey = char
            # k.regx.iter.next() # EKR: next() may throw StopIteration.
        # except StopIteration:
            # pass
        # return
    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event,stroke)
        if expanded: return
    if func: # Func is an argument.
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace:
                g.trace('calling command directly',commandName)
                g.trace(g.callers())
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
    elif k.inState():
        pass #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
</t>
<t tx="ekr.20061031131434.106">specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
</t>
<t tx="ekr.20061031131434.108">def callStateFunction (self,event):

    trace = False and not g.unitTesting
    k = self ; val = None 
    ch = event and event.char or ''
    stroke = event and event.stroke or ''
    if trace: g.trace(k.state.kind,'ch',ch,'stroke',stroke,
        'ignore_unbound_non_ascii_keys',k.ignore_unbound_non_ascii_keys)
    if k.state.kind == 'auto-complete':
        # 2011/06/17.
        # k.auto_completer_state_handler returns 'do-standard-keys' for control keys.
        val = k.state.handler(event)
        if trace: g.trace('auto-complete returns',repr(val))
        return val
    elif k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            len(ch) == 1 and # 2011/04/01
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) &lt; 32 or ord(ch) &gt; 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(k.commandName)
        else:
            g.error('callStateFunction: no state function for',k.state.kind)
    return val
</t>
<t tx="ekr.20061031131434.11">def auto_completer_state_handler (self,event):

    trace = False and not g.app.unitTesting
    c = self.c ; k = self.k
    tag = 'auto-complete' ; state = k.getState(tag)
    ch = event and event.char or ''
    stroke = event and event.stroke or None
    is_plain = k.isPlainKey(stroke)
    if trace: g.trace('state: %s, ch: %s, stroke: %s' % (
        state,repr(ch),repr(stroke)))

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        common_prefix,prefix,tabList = self.compute_completion_list()
        if tabList:
            k.setState(tag,1,handler=self.auto_completer_state_handler)
        else:
            if trace: g.trace('abort: not tabList')
            self.exit()
    elif ch in ('\n','Return'):
        self.exit()
    elif ch == 'Escape':
        self.exit()
    elif ch in ('\t','Tab'):
        self.compute_completion_list()
    elif ch in ('\b','BackSpace'):
        self.do_backspace()
    elif ch == '.':
        self.insert_string('.')
        self.compute_completion_list()
    elif ch == '?':
        self.info()
    elif ch == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        kind = 'ON' if self.verbose else 'OFF'
        c.frame.putStatusLine('verbose completions %s' % (
            kind),color='red')
        self.compute_completion_list()
    # elif ch == 'Down' and hasattr(self,'onDown'):
        # self.onDown()
    # elif ch == 'Up' and hasattr(self,'onUp'):
        # self.onUp()
    elif is_plain and ch and ch in string.printable:
        self.insert_general_char(ch)
    else:
        if stroke == k.autoCompleteForceKey:
            # This is probably redundant because completions will exist.
            # However, it doesn't hurt, and it may be useful rarely.
            if trace: g.trace('auto-complete-force',repr(stroke))
            common_prefix,prefix,tabList = self.compute_completion_list()
            if tabList:
                self.show_completion_list(common_prefix,prefix,tabList)
            else:
                g.warning('No completions')
                self.exit()
            return None
        else:
            if trace: g.trace('ignore non plain key',repr(stroke),g.callers())
            self.abort() # 2011/06/17.
            return 'do-standard-keys'
</t>
<t tx="ekr.20061031131434.110">def handleDefaultChar(self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting
    verbose = False
    if trace and verbose:
        g.trace('widget_name',name,'stroke',stroke,
        'enable alt-ctrl',self.enable_alt_ctrl_bindings)
    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        # not k.enable_alt_ctrl_bindings and # Old code: this isn't an alt-ctrl key!
        k.ignore_unbound_non_ascii_keys and # Bug fix: 2011/11/23
        (stroke.find('Ctrl') &gt; -1 or stroke.find('Alt') &gt; -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        g.app.unitTestDict['handleUnboundChar-ignore-alt-or-ctrl'] = True
    elif name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
    elif name.startswith('log'):
        # Bug fix: 2011/11/21: Because of universal bindings
        # we may not be able to insert anything into w.
        import leo.core.leoFrame as leoFrame
        if issubclass(w.__class__,leoFrame.HighLevelInterface):
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event and event.stroke
            if stroke:
                s = stroke.toGuiChar()
                w.logCtrl.insert(i,s)
        elif trace: g.trace('Not a HighLevelInterface object',w)
    else:
        pass # Ignore the event
</t>
<t tx="ekr.20061031131434.111">def fullCommand (self,event,specialStroke=None,specialFunc=None,help=False,helpHandler=None):
    '''Handle 'full-command' (alt-x) mode.'''
    trace = False and not g.unitTesting
    verbose = False
    k = self ; c = k.c
    recording = c.macroCommands.recordingMacro
    state = k.getState('full-command')
    helpPrompt = 'Help for command: '
    c.check_event(event)
    ch = char = event and event.char or ''
    stroke = event and event.stroke or None
    if trace and verbose: g.trace(g.callers())
    if trace:
        g.trace('recording',recording,'state',state,char)
    if recording:
        c.macroCommands.startRecordingMacro(event)
    if state &gt; 0:
        k.setLossage(char,stroke)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand)
        prompt = helpPrompt if help else k.altX_prompt
        k.setLabelBlue(prompt)
        k.mb_help = help
        k.mb_helpHandler = helpHandler
        c.minibufferWantsFocus()
    elif char == 'Ins' or k.isFKey(char):
        pass
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        if trace and verbose: g.trace('***Return')
        c.frame.log.deleteTab('Completion')
        if k.mb_help:
            s = k.getLabel()
            commandName = s[len(helpPrompt):].strip()
            k.clearState()
            k.resetLabel()
            if k.mb_helpHandler: k.mb_helpHandler(commandName)
        else:
            k.callAltXFunction(k.mb_event)
    elif char in ('\t','Tab'):
        if trace and verbose: g.trace('***Tab')
        k.doTabCompletion(list(c.commandsDict.keys()),allow_empty_completion=True)
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        if trace and verbose: g.trace('***BackSpace')
        k.doBackSpace(list(c.commandsDict.keys()))
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)
</t>
<t tx="ekr.20061031131434.112">def callAltXFunction (self,event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName,tail = k.getMinibufferCommandName()
    if trace: g.trace('command:',commandName,'tail:',tail)
    k.functionTail = tail
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            g.es('Can not execute commands from headlines')
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setLabel('Command does not exist: %s' % commandName)
            # g.es('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061031131434.113">def endCommand (self,commandName):

    '''Make sure Leo updates the widget following a command.

    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        if not k.inState():
            k.commandName = None
            c.editCommandsManager.initAllEditCommanders()
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')
        if k.newMinibufferWidget:
            c.widgetWantsFocusNow(k.newMinibufferWidget)
            # g.pr('endCommand', g.app.gui.widget_name(k.newMinibufferWidget),g.callers())
            k.newMinibufferWidget = None
</t>
<t tx="ekr.20061031131434.114"></t>
<t tx="ekr.20061031131434.115">def universalArgument (self,event):
    '''Prompt for a universal argument.'''
    k = self
    k.setLabelBlue('Universal Argument: ')
    k.universalDispatcher(event)

def digitArgument (self,event):
    '''Prompt for a digit argument.'''
    k = self
    k.setLabelBlue('Digit Argument: ')
    k.universalDispatcher(event)
</t>
<t tx="ekr.20061031131434.117">def negativeArgument (self,event):

    '''Prompt for a negative digit argument.'''

    g.trace('not ready yet')

    # k = self ; state = k.getState('neg-arg')

    # if state == 0:
        # k.setLabelBlue('Negative Argument: ')
        # k.setState('neg-arg',1,k.negativeArgument)
    # else:
        # k.clearState()
        # k.resetLabel()
        # func = k.negArgFunctions.get(k.stroke)
        # if func:
            # func(event)
</t>
<t tx="ekr.20061031131434.118">def numberCommand (self,event,stroke,number):

    '''Enter a number prefix for commands.'''

    k = self ; c = self.c
    k.stroke = stroke
    w = event and event.widget
    k.universalDispatcher(event)
    g.app.gui.event_generate(c,chr(number),chr(number),w)
    return

def numberCommand0 (self,event):
    '''Execute command number 0.'''
    return self.numberCommand (event,None,0)

def numberCommand1 (self,event):
    '''Execute command number 1.'''
    return self.numberCommand (event,None,1)

def numberCommand2 (self,event):
    '''Execute command number 2.'''
    return self.numberCommand (event,None,2)

def numberCommand3 (self,event):
    '''Execute command number 3.'''
    return self.numberCommand (event,None,3)

def numberCommand4 (self,event):
    '''Execute command number 4.'''
    return self.numberCommand (event,None,4)

def numberCommand5 (self,event):
    '''Execute command number 5.'''
    return self.numberCommand (event,None,5)

def numberCommand6 (self,event):
    '''Execute command number 6.'''
    return self.numberCommand (event,None,6)

def numberCommand7 (self,event):
    '''Execute command number 7.'''
    return self.numberCommand (event,None,7)

def numberCommand8 (self,event):
    '''Execute command number 8.'''
    return self.numberCommand (event,None,8)

def numberCommand9 (self,event):
    '''Execute command number 9.'''
    return self.numberCommand (event,None,9)
</t>
<t tx="ekr.20061031131434.119">def printBindings (self,event=None):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    c.frame.log.clearTab(tabName)
    legend = '''\
legend:
[ ] leoSettings.leo
[D] default binding
[F] loaded .leo File
[M] myLeoSettings.leo
[@] mode

'''

    if not d: return g.es('no bindings')
    legend = g.adjustTripleString(legend,c.tab_width)
    data = []
    for stroke in sorted(d):
        assert g.isStroke(stroke),stroke
        aList = d.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            s1 = '' if si.pane=='all' else si.pane
            s2 = k.prettyPrintKey(stroke)
            s3 = si.commandName
            s4 = si.kind or '&lt;no hash&gt;'
            data.append((s1,s2,s3,s4),)

    # Print keys by type:
    result = []
    result.append('\n'+legend)
    for prefix in (
        'Alt+Ctrl+Shift','Alt+Ctrl','Alt+Shift','Alt', # 'Alt+Key': done by Alt.
        'Ctrl+Meta+Shift','Ctrl+Meta','Ctrl+Shift','Ctrl', # Ctrl+Key: done by Ctrl.
        'Meta+Key','Meta+Shift','Meta',
        'Shift',
        # Careful: longer prefixes must come before shorter prefixes.
    ):
        data2 = []
        for item in data:
            s1,s2,s3,s4 = item
            if s2.startswith(prefix):
                data2.append(item)
        result.append('***** %s...\n' % prefix)
        self.printBindingsHelper(result,data2,prefix=prefix)
        # Remove all the items in data2 from data.
        # This must be done outside the iterator on data.
        for item in data2:
            data.remove(item)
    # Print all plain bindings.
    result.append('***** Plain Keys...\n')
    self.printBindingsHelper(result,data,prefix=None)
    if not g.unitTesting:
        g.es('',''.join(result),tabName=tabName)
    k.showStateAndMode()
    return result # for unit test.
</t>
<t tx="ekr.20061031131434.12">def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20061031131434.120">def printBindingsHelper (self,result,data,prefix):

    lm = g.app.loadManager

    data.sort(key=lambda x: x[1])

    data2,n = [],0
    for pane,key,commandName,kind in data:
        key = key.replace('+Key','')
        # g.trace(key,kind)
        letter = lm.computeBindingLetter(kind)
        pane = '%s: ' % (pane) if pane else ''
        left = pane+key # pane and shortcut fields
        n = max(n,len(left))
        data2.append((letter,left,commandName),)

    for z in data2:
        letter,left,commandName = z
        result.append('%s %*s %s\n' % (letter,-n,left,commandName))

    if data:
        result.append('\n')
</t>
<t tx="ekr.20061031131434.121">def printCommands (self,event=None):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'

    c.frame.log.clearTab(tabName)

    inverseBindingDict = k.computeInverseBindingDict()
    data,n = [],0
    for commandName in sorted(c.commandsDict):
        dataList = inverseBindingDict.get(commandName,[('',''),])
        for z in dataList:
            pane, key = z
            pane = '%s ' % (pane) if pane != 'all:' else ''
            key = k.prettyPrintKey(key).replace('+Key','')
            s1 = pane + key
            s2 = commandName
            n = max(n,len(s1))
            data.append((s1,s2),)

    # This isn't perfect in variable-width fonts.
    lines = ['%*s %s\n' % (-n,s1,s2) for s1,s2 in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20061031131434.122">def repeatComplexCommand (self,event):

    '''Repeat the previously executed minibuffer command.'''
    k = self
    if k.mb_history:
        k.setState('last-full-command',1,handler=k.repeatComplexCommandHelper)
        k.setLabelBlue("Redo: %s" % str(k.mb_history[0]))
    else:
        g.warning('no previous command')

</t>
<t tx="ekr.20061031131434.123">def setCommandState (self,event):
    '''Enter the 'command' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('command',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setInsertState (self,event):
    '''Enter the 'insert' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('insert',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()

def setOverwriteState (self,event):
    '''Enter the 'overwrite' editing state.'''
    # g.trace(g.callers())
    k = self
    k.setInputState('overwrite',set_border=True)
    # This command is also valid in headlines.
    # k.c.bodyWantsFocus()
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.124">def toggleInputState (self,event=None):

    '''The toggle-input-state command.'''

    k = self ; c = k.c
    default = c.config.getString('top_level_unbound_key_action') or 'insert'
    state = k.unboundKeyAction

    if default == 'insert':
        state = 'command' if state=='insert' else 'insert'
    elif default == 'overwrite':
        state = 'command' if state=='overwrite' else 'overwrite'
    else:
        state = 'insert' if state=='command' else 'command' # prefer insert to overwrite.

    k.setInputState(state)
    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.125"></t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName (self,w,commandName):

    '''Implement a command by passing a keypress to the gui.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c

    stroke = k.getShortcutForCommandName(commandName)
    if not stroke:
        shortcut = None
    elif g.isStroke(stroke):
        shortcut = stroke.s
    else:
        stroke = k.strokeFromSetting(stroke)
        shortcut = stroke.s

    assert g.isString(shortcut)

    if trace and shortcut: g.trace(
        'shortcut',repr(shortcut),'commandName',commandName)

    if shortcut and w:
        # g.trace(stroke)
        g.app.gui.set_focus(c,w)
        g.app.gui.event_generate(c,None,shortcut,w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
</t>
<t tx="ekr.20061031131434.127">def simulateCommand (self,commandName,event=None):
    '''Execute a Leo command by name.'''
    k = self ; c = k.c
    commandName = commandName.strip()
    if not commandName: return
    aList = commandName.split(None)
    if len(aList) == 1:
        k.givenArgs = []
    else:
        commandName = aList[0]
        k.givenArgs = aList[1:]
    # g.trace(commandName,k.givenArgs)
    func = c.commandsDict.get(commandName)
    if func:
        # g.trace(commandName,func.__name__)
        if event:
            pass
        elif commandName.startswith('specialCallback'):
            event = None # A legacy function.
        else: # Create a dummy event as a signal.
            event = g.app.gui.create_key_event(c,None,None,None)
        k.masterCommand(event=event,func=func)
        if c.exists:
            return k.funcReturn
        else:
            return None
    else:
        if g.app.unitTesting:
            raise AttributeError
        else:
            g.error('simulateCommand: no command for %s' % (commandName))
            return None
</t>
<t tx="ekr.20061031131434.129"># Set global ivars.
k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    # 2010/09/01: remember the selected text for abbreviations.
k.oneCharacterArg = oneCharacter

k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)
k.mb_prefix = prefix or k.getLabel()
    # if prefix is not given, we expect k.mb_prefix to be k.getLabel aleady.
    # if not, something unusual is going on.  Probably should be fixed.
k.mb_prompt = prefix or ''
k.mb_tabList = []
# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
</t>
<t tx="ekr.20061031131434.13">def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k
    w = event and event.w
    if not w: return
    is_headline = c.widget_name(w).startswith('head')

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not is_headline:
        self.w = w
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event=event)
</t>
<t tx="ekr.20061031131434.130">def keyboardQuit (self,event=None,setFocus=True,mouseClick=False):
    '''
    This method clears the state and the minibuffer label.

    k.endCommand handles all other end-of-command chores.
    '''
    trace = False and not g.unitTesting
    k = self ; c = k.c
    if trace: g.trace(g.callers())
    if g.app.quitting:
        return
    # 2011/05/30: We may be called from Qt event handlers.
    # Make sure to end editing!
    c.endEditing() 
    # Completely clear the mode.
    if setFocus:
        c.frame.log.deleteTab('Mode')
        c.frame.log.hideTab('Completion')
    if k.inputModeName:
        k.endMode()
    # Complete clear the state.
    k.state.kind = None
    k.state.n = None
    k.clearState()
    k.resetLabel()
    if setFocus:
        c.bodyWantsFocus()
    # At present, only the auto-completer suppresses this.
    k.setDefaultInputState()
    if c.vim_mode and c.vimCommands:
        c.vimCommands.reset(setFocus=setFocus)
    else:
        # This was what caused the unwanted scrolling.
        k.showStateAndMode(setFocus=setFocus)
</t>
<t tx="ekr.20061031131434.131">def registerCommand (self,commandName,shortcut,func,
    pane='all',verbose=False, wrap=True):

    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.

    You can wrap any method in a callback function, so the
    restriction to functions is not significant.

    If wrap is True then func will be wrapped with c.universalCallback.

    '''
    trace = False and not g.unitTesting and commandName.startswith(':')
    verbose = False
    k = self ; c = k.c
    if trace: g.trace(commandName,shortcut)
    if wrap:
        func = c.universalCallback(func)
    f = c.commandsDict.get(commandName)
    if f and f.__name__ != 'dummyCallback' and trace and verbose:
        g.error('redefining',commandName)
    assert not g.isStroke(shortcut)
    c.commandsDict [commandName] = func
    fname = func.__name__
    c.inverseCommandsDict [fname] = commandName
    if trace and fname != 'minibufferCallback':
        g.trace('leoCommands %24s = %s' % (fname,commandName))
    if shortcut:
        if trace: g.trace('shortcut',shortcut)
        stroke = k.strokeFromSetting(shortcut)
    elif commandName.lower() == 'shortcut': # Causes problems.
        stroke = None
    else:
        # Try to get a stroke from leoSettings.leo.
        stroke = None
        junk,aList = c.config.getShortcut(commandName)
        for si in aList:
            assert g.isShortcutInfo(si),si
            assert g.isStrokeOrNone(si.stroke)
            if si.stroke and not si.pane.endswith('-mode'):
                # if trace: g.trace('*** found',si)
                stroke = si.stroke
                break
    if stroke:
        if trace: g.trace('stroke',stroke,'pane',pane,commandName)
        ok = k.bindKey (pane,stroke,func,commandName,tag='register-command')
            # Must be a stroke.
        k.makeMasterGuiBinding(stroke) # Must be a stroke.
        if trace and verbose and ok and not g.app.silentMode:
            g.blue('','@command: %s = %s' % (
                commandName,k.prettyPrintKey(stroke)))
            if 0:
                d = k.masterBindingsDict.get('button',{})
                g.print_dict(d)
    elif trace and verbose and not g.app.silentMode:
        g.blue('','@command: %s' % (commandName))
    # Fixup any previous abbreviation to press-x-button commands.
    if commandName.startswith('press-') and commandName.endswith('-button'):
        d = c.config.getAbbrevDict()
            # Keys are full command names, values are abbreviations.
        if commandName in list(d.values()):
            for key in d:
                if d.get(key) == commandName:
                    c.commandsDict [key] = c.commandsDict.get(commandName)
                    break
</t>
<t tx="ekr.20061031131434.133">def setInputState (self,state,set_border=False):

    c,k = self.c,self
    k.unboundKeyAction = state

    if set_border and c.frame and c.frame.body:
        w = c.frame.body.bodyCtrl
        if hasattr(w,'widget'):
            g.app.gui.add_border(c,w.widget)
</t>
<t tx="ekr.20061031131434.135"># def minibufferWantsFocus(self):

    # c = self.c
    # c.widgetWantsFocus(c.miniBufferWidget)
</t>
<t tx="ekr.20061031131434.14">def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
</t>
<t tx="ekr.20061031131434.145"></t>
<t tx="ekr.20061031131434.146">master_key_count = 0

def masterKeyHandler (self,event):
    '''The master key handler for almost all key bindings.'''
    trace = False and not g.app.unitTesting
    traceGC = False and not g.app.unitTesting
    verbose = True
    k,c = self,self.c
    c.check_event(event)
    &lt;&lt; define vars &gt;&gt;
    assert g.isStrokeOrNone(stroke)
    if char in special_keys:
        if trace and verbose: g.trace('char',char)
        return
    if traceGC: g.printNewObjects('masterKey 1')
    if trace and verbose: g.trace('stroke:',repr(stroke),'char:',
        repr(event and event.char),
        'ch:',repr(event and event.char),
        'state',state,'state2',k.unboundKeyAction)
    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        if hasattr(c,'screenCastController') and c.screenCastController:
            c.screenCastController.quit()
        if c.macroCommands.recordingMacro:
            c.macroCommands.endMacro()
        else:
            k.masterCommand(commandName='keyboard-quit',
                event=event,func=k.keyboardQuit,stroke=stroke)
        return
    # Always handle modes regardless of vim.
    if k.inState():
        if trace: g.trace('   state %-15s %s' % (state,stroke))
        done = k.doMode(event,state,stroke)
        if done: return
    # Handle vim keys only if not in a state.
    if c.vim_mode and c.vimCommands:
        ok = c.vimCommands.do_key(event)
        if trace: g.trace('vc.do_key returns',ok)
        if ok: return
    if traceGC: g.printNewObjects('masterKey 2')
    # 2011/02/08: An important simplification.
    if isPlain and k.unboundKeyAction != 'command':
        if self.isAutoCompleteChar(stroke):
            if trace: g.trace('autocomplete key',stroke)
        else:
            if trace: g.trace('inserted %-10s (insert/overwrite mode)' % (stroke))
            k.handleUnboundKeys(event,char,stroke)
            return
    # 2011/02/08: Use getPandBindings for *all* keys.
    si = k.getPaneBinding(stroke,w)
    if si:
        assert g.isShortcutInfo(si),si
        if traceGC: g.printNewObjects('masterKey 3')
        if trace: g.trace('   bound',stroke,si.func.__name__)
        k.masterCommand(event=event,
            commandName=si.commandName,func=si.func,stroke=si.stroke)
    else:
        if traceGC: g.printNewObjects('masterKey 4')
        if trace: g.trace(' unbound',stroke)
        k.handleUnboundKeys(event,char,stroke)
</t>
<t tx="ekr.20061031131434.147">w = event and event.widget
char = event and event.char or ''
stroke = event and event.stroke or None
# w_name = c.widget_name(w)
state = k.state.kind
special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1
isPlain =  k.isPlainKey(stroke)
</t>
<t tx="ekr.20061031131434.15">def showAutocompleterStatus (self):
    '''Show the autocompleter status.'''

    k = self.k
    if not g.unitTesting:
        s = 'autocompleter %s' % (
            'On' if k.enable_autocompleter else 'Off')
        g.red(s)

def showCalltipsStatus (self):
    '''Show the autocompleter status.'''
    k = self.k
    if not g.unitTesting:
        s = 'calltips %s' % 'On' if k.enable_calltips else 'Off'
        g.red(s)
</t>
<t tx="ekr.20061031131434.152">def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False and not g.app.unitTesting
    # Special case for bindings handled in k.getArg:
    assert g.isStroke(stroke),repr(stroke)
    if state in ('getArg','full-command'):
        if stroke in ('\b','BackSpace','\r','Linefeed','\n','Return','\t','Tab','Escape',):
            return False
        if k.isFKey(stroke):
            return False
    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif si.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (
                            pane),si.commandName,stroke)
                        k.keyboardQuit()
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',si.commandName)
                        c.minibufferWantsFocus() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(commandName=si.commandName,event=event,func=si.func,stroke=stroke)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True
    return False
</t>
<t tx="ekr.20061031131434.156"></t>
<t tx="ekr.20061031131434.157">def badMode(self,modeName):

    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)
</t>
<t tx="ekr.20061031131434.158">def createModeBindings (self,modeName,d,w):

    '''Create mode bindings for the named mode using dictionary d for w, a text widget.'''

    trace = False and not g.unitTesting
    k = self ; c = k.c
    assert d.name().endswith('-mode')
    for commandName in d.keys():
        if commandName in ('*entry-commands*','*command-prompt*'):
            # These are special-purpose dictionary entries.
            continue
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command:',commandName,'Referenced from',modeName)
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)

                assert g.isStroke(stroke)

                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode&lt;%s&gt;' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict [ modeName ] = d2
</t>
<t tx="ekr.20061031131434.16"></t>
<t tx="ekr.20061031131434.160">def enterNamedMode (self,event,commandName):

    k = self ; c = k.c
    modeName = commandName[6:]
    c.inCommand = False # Allow inner commands in the mode.
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20061031131434.161">def exitNamedMode (self,event=None):

    '''Exit an input mode.'''

    k = self

    if k.inState():
        k.endMode()

    k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.163">def initMode (self,event,modeName):

    k = self ; c = k.c
    trace = (False or g.trace_modes) and not g.unitTesting

    if not modeName:
        g.trace('oops: no modeName')
        return

    if g.new_modes:
        mode = k.modeController.getMode(modeName)
        if mode:
            mode.initMode()
        else:
            g.trace('***** oops: no mode',modeName)
    else:
        d = g.app.config.modeCommandsDict.get('enter-'+modeName)
        if not d:
            self.badMode(modeName)
            return
        else:
            k.modeBindingsDict = d
            si = d.get('*command-prompt*')
            if si:
                prompt = si.kind # A kludge.
            else:
                prompt = modeName
            if trace: g.trace('modeName: %s prompt: %s d.keys(): %s' % (
                modeName,prompt,sorted(list(d.keys()))))

        k.inputModeName = modeName
        k.silentMode = False

        aList = d.get('*entry-commands*',[])
        if aList:
            for si in aList:
                assert g.isShortcutInfo(si),si
                commandName = si.commandName
                if trace: g.trace('entry command:',commandName)
                k.simulateCommand(commandName)
                # Careful, the command can kill the commander.
                if g.app.quitting or not c.exists: return
                # New in Leo 4.5: a startup command can immediately transfer to another mode.
                if commandName.startswith('enter-'):
                    if trace: g.trace('redirect to mode',commandName)
                    return

        # Create bindings after we know whether we are in silent mode.
        w = k.modeWidget if k.silentMode else k.w
        k.createModeBindings(modeName,d,w)
        k.showStateAndMode(prompt=prompt)
</t>
<t tx="ekr.20061031131434.164">def reinitMode (self,modeName):

    k = self
    d = k.modeBindingsDict
    k.inputModeName = modeName
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(modeName,d,w)
    if k.silentMode:
        k.showStateAndMode()
    else:
        # Do not set the status line here.
        k.setLabelBlue(modeName+': ') # ,protect=True)
</t>
<t tx="ekr.20061031131434.165">def modeHelp (self,event):

    '''The mode-help command.

    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''

    k = self ; c = k.c
    c.endEditing()
    # g.trace(k.inputModeName)
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    if not k.silentMode:
        c.minibufferWantsFocus()
</t>
<t tx="ekr.20061031131434.166">def modeHelpHelper (self,d):

    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    data,n = [],0
    for key in sorted(d.keys()):
        if key in ('*entry-commands*','*command-prompt*'):
            pass
        else:
            aList = d.get(key)
            for si in aList:
                assert g.isShortcutInfo(si),si
                stroke = si.stroke
                if stroke not in (None,'None'):
                    s1 = key
                    s2 = k.prettyPrintKey(stroke)
                    n = max(n,len(s1))
                    data.append((s1,s2),)

    data.sort()
    modeName = k.inputModeName.replace('-',' ')
    if modeName.endswith('mode'):
        modeName = modeName[:-4].strip()

    prompt = d.get('*command-prompt*')
    if prompt:
        g.es('','%s\n\n' % (prompt.kind.strip()),tabName=tabName)
    else:
        g.es('','%s mode\n\n' % modeName,tabName=tabName)

    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('','%*s %s' % (n,s1,s2),tabName=tabName)
</t>
<t tx="ekr.20061031131434.175"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

# Called from doTabCompletion: with defaultTabList = list(c.commandsDict.keys())

def computeCompletionList (self,defaultTabList,backspace,allow_empty_completion=False):

    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if trace:
        g.trace('command',command,g.callers())
        g.trace('defaultTabList',len(defaultTabList) if defaultTabList else 'None')
        g.trace('common_prefix',common_prefix)
        g.trace('k.mb_tabList',k.mb_tabList)

    if not k.mb_tabList and allow_empty_completion:
        if command:
            # 2012/05/20: Put up an *empty* list as a visual cue.
            k.mb_tabList = []
            g.es('','\n',tabName=tabName)
        else:
            # 2012/05/20: Return *all* completions if the command is empty.
            k.mb_tabList = sorted(defaultTabList)
            common_prefix = ''

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.
        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data,n = [],0
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1a = '%s ' % (pane) if pane != 'all:' else ''
                s1b = k.prettyPrintKey(key)
                s1 = s1a + s1b
                s2 = commandName
                data.append((s1,s2),)
                n = max(n,len(s1))
        aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
        g.es('','\n'.join(aList),tabName=tabName)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20061031131434.176">def computeInverseBindingDict (self):

    k = self ; d = {}

    # keys are minibuffer command names, values are shortcuts.
    for stroke in k.bindingsDict.keys():
        assert g.isStroke(stroke),repr(stroke)
        aList = k.bindingsDict.get(stroke,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            shortcutList = d.get(si.commandName,[])

            # The shortcutList consists of tuples (pane,stroke).
            # k.inverseBindingDict has values consisting of these tuples.
            aList = k.bindingsDict.get(stroke,g.ShortcutInfo(kind='dummy',pane='all'))
                    # Important: only si.pane is required below.
            for si in aList:
                assert g.isShortcutInfo(si),si
                pane = '%s:' % (si.pane)
                data = (pane,stroke)
                if data not in shortcutList:
                    shortcutList.append(data)

            d [si.commandName] = shortcutList

    return d
</t>
<t tx="ekr.20061031131434.178"># Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList,redraw=True,allow_empty_completion=False):
    '''Handle tab completion when the user hits a tab.'''
    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel().strip()
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        if trace: g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex &gt;= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        if redraw:
            if trace: g.trace('** recomputing default completions')
            k.computeCompletionList(defaultTabList,
                backspace=False,
                allow_empty_completion=allow_empty_completion)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20061031131434.179">def getShortcutForCommandName (self,commandName):

    k = self ; c = k.c
    command = c.commandsDict.get(commandName)
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == commandName:
                    return stroke
    return None

def getShortcutForCommand (self,command):

    k = self
    if command:
        for stroke in k.bindingsDict:
            assert g.isStroke(stroke),repr(stroke)
            aList = k.bindingsDict.get(stroke,[])
            for si in aList:
                assert g.isShortcutInfo(si),si
                if si.commandName == command.__name__:
                    return stroke
    return None
</t>
<t tx="ekr.20061031131434.18">def appendTabName (self,word):

    self.setTabName(self.tabName + '.' + word)

def beginTabName (self,word):

    self.setTabName('AutoComplete ' + word)

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20061031131434.180">def traceBinding (self,si,shortcut,w):

    k = self ; c = k.c ; gui = g.app.gui
    if not c.config.getBool('trace_bindings'): return

    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return

    pane_filter = c.config.getString('trace_bindings_pane_filter')
    if not pane_filter or pane_filter.lower() == si.pane:
        g.trace(si.pane,shortcut,si.commandName,gui.widget_name(w))
</t>
<t tx="ekr.20061031131434.181"></t>
<t tx="ekr.20061031131434.182">def isPlainKey (self,stroke):
    '''Return true if the shortcut refers to a plain (non-Alt,non-Ctl) key.'''
    k = self
    if not stroke:
        return False
    assert g.isString(stroke) or g.isStroke(stroke)
    shortcut = stroke.s if g.isStroke(stroke) else stroke
    # altgr combos (Alt+Ctrl) are always plain keys
    if shortcut.startswith('Alt+Ctrl+') and not self.enable_alt_ctrl_bindings:
        return True
    for z in ('Alt','Ctrl','Command','Meta'):
        if shortcut.find(z) != -1:            
            return False
    # Careful, allow bare angle brackets for unit tests.
    if shortcut.startswith('&lt;') and shortcut.endswith('&gt;'):
        shortcut = shortcut[1:-1]
    isPlain = (
        len(shortcut) == 1 or
        len(k.guiBindNamesInverseDict.get(shortcut,'')) == 1 or
        # A hack: allow Return to be bound to command.
        shortcut in ('Tab','\t')
    )
    # g.trace(isPlain,repr(shortcut))
    return isPlain and not self.isFKey(shortcut)
</t>
<t tx="ekr.20061031131434.184">def strokeFromSetting (self,setting,addKey=True):

    k = self

    trace = False and not g.unitTesting # and setting.lower().find('ctrl-x') &gt; -1
    verbose = False
    if not setting:
        return None

    assert g.isString(setting)

    s = g.stripBrackets(setting.strip())
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;

    if trace and verbose:
        g.trace('%20s %s' % (setting,shortcut),g.callers())

    return g.KeyStroke(shortcut) if shortcut else None

canonicalizeShortcut = strokeFromSetting # For compatibility.
</t>
<t tx="ekr.20061031131434.185">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0
meta  = s2.find("meta") &gt;= 0
</t>
<t tx="ekr.20061031131434.186">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False
</t>
<t tx="ekr.20061031131434.187"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')
</t>
<t tx="ekr.20061031131434.188">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            g.pr("bad shortcut specifier:", repr(s),repr(setting))
            g.trace(g.callers())
        return None

if len(last) == 1:
    last2 = k.guiBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2
    else:
        if last.isalpha():
            if shift:
                last = last.upper()
                shift = False # It is Ctrl-A, not Ctrl-Shift-A.
            else:
                last = last.lower()
        # New in Leo 4.4.2: Alt-2 is not a key event!
        if addKey and last.isdigit():
            last = 'Key-' + last
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = k.settingsNameDict
    last = d.get(last.lower(),last)
</t>
<t tx="ekr.20061031131434.189">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (meta,'Meta+'),
    (shift,'Shift+'),
    (True, last),
)

# new in 4.4b3: convert all characters to unicode first.
shortcut = ''.join([g.toUnicode(val) for flag,val in table if flag])
</t>
<t tx="ekr.20061031131434.191">def prettyPrintKey (self,stroke,brief=False):

    trace = False and not g.unitTesting
    k = self
    if not stroke:
        s = ''
    elif g.isStroke(stroke):
        s = stroke.s
    else:
        s = stroke

    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0

    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]
    if trace: g.trace('fields',fields)
    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = last.upper()
                else:
                    s = prev + last.upper()
    else:
        last = k.guiBindNamesInverseDict.get(last,last)
        if fields and fields[:-1]:
            s = '%s+%s' % ('+'.join(fields[:-1]),last)
        else:
            s = last
    if s.endswith(' '):
        s = s[:-1]+'Space' # 2010/11/06

    return s
</t>
<t tx="ekr.20061031131434.192">def showStateAndMode(self,w=None,prompt=None,setFocus=True):
    '''Show the state and mode at the start of the minibuffer.'''
    trace = False and not g.unitTesting
    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return
    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return
    isText = g.app.gui.isTextWidget(w)
    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return
    wname = g.app.gui.widget_name(w).lower()
    # Get the wrapper for the headline widget.
    if wname.startswith('head'):
        if hasattr(c.frame.tree,'getWrapper'):
            if hasattr(w,'widget'): w2 = w.widget
            else: w2 = w
            w = c.frame.tree.getWrapper(w2,item=None)
            isText = bool(w) # A benign hack.
    if trace: g.trace('state: %s, text?: %s, w: %s' % (state,isText,w))
    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif c.vim_mode and c.vimCommands:
        c.vimCommands.show_status()
        return
    else:
        s = '%s State' % state.capitalize()
        if c.editCommands.extendMode:
            s = s + ' (Extend Mode)'
    # if trace: g.trace('w',w,'s',s)
    if trace: g.trace(g.callers())
    if s:
        k.setLabelBlue(s)
    if w and isText:
        # k.showStateColors(inOutline,w)
        k.showStateCursor(state,w)
</t>
<t tx="ekr.20061031131434.193"></t>
<t tx="ekr.20061031131434.194">def clearState (self):
    '''Clear the key handler state.'''
    k = self
    k.state.kind = None
    k.state.n = None
    k.state.handler = None
</t>
<t tx="ekr.20061031131434.195">def getStateHandler (self):

    return self.state.handler
</t>
<t tx="ekr.20061031131434.196">def getState (self,kind):

    k = self
    val = k.state.n if k.state.kind == kind else 0
    # g.trace(state,'returns',val)
    return val
</t>
<t tx="ekr.20061031131434.197">def getStateKind (self):

    return self.state.kind
</t>
<t tx="ekr.20061031131434.198">def inState (self,kind=None):

    k = self

    if kind:
        return k.state.kind == kind and k.state.n != None
    else:
        return k.state.kind and k.state.n != None
</t>
<t tx="ekr.20061031131434.199">def setState (self,kind,n,handler=None):

    trace = False and not g.unitTesting
    k = self
    if kind and n != None:
        if trace: g.trace('**** setting %s %s %s' % (
            kind,n,handler and handler.__name__),g.callers())
        k.state.kind = kind
        k.state.n = n
        if handler:
            k.state.handler = handler
    else:
        if trace: g.trace('clearing')
        k.clearState()
    # k.showStateAndMode()
</t>
<t tx="ekr.20061031131434.2">@nocolor
@

Here are the rules for translating key bindings (in leoSettings.leo)
into keys for k.bindingsDict:

1. The case of plain letters is significant: a is not A.

2. The Shift- prefix can be applied *only* to letters. Leo will ignore
   (with a warning) the shift prefix applied to any other binding,
   e.g., Ctrl-Shift-(

3. The case of letters prefixed by Ctrl-, Alt-, Key- or Shift- is
   *not* significant. Thus, the Shift- prefix is required if you want
   an upper-case letter (with the exception of 'bare' uppercase
   letters.)

The following table illustrates these rules. In each row, the first
entry is the key (for k.bindingsDict) and the other entries are
equivalents that the user may specify in leoSettings.leo:

a, Key-a, Key-A
A, Shift-A
Alt-a, Alt-A
Alt-A, Alt-Shift-a, Alt-Shift-A
Ctrl-a, Ctrl-A
Ctrl-A, Ctrl-Shift-a, Ctrl-Shift-A
!, Key-!,Key-exclam,exclam

This table is consistent with how Leo already works (because it is
consistent with Tk's key-event specifiers). It is also, I think, the
least confusing set of rules.
</t>
<t tx="ekr.20061031131434.20">def calltip (self):

    '''Show the calltips for the present prefix.
    ch is '(' if the user has just typed it.
    '''

    obj,prefix = self.get_object()
    if obj:
        self.calltip_success(prefix,obj)
    else:
        self.calltip_fail(prefix)
    self.exit()
</t>
<t tx="ekr.20061031131434.200">def universalDispatcher (self,event):

    '''Handle accumulation of universal argument.'''

    &lt;&lt; about repeat counts &gt;&gt;
    c,k = self.c,self
    state = k.getState('u-arg')
    stroke = event and event.stroke or None

    if state == 0:
        k.dispatchEvent = event
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        # stroke = k.stroke # Warning: k.stroke is always Alt-u
        char = event and event.char or ''
        # g.trace(state,char)
        if char == 'Escape':
            k.keyboardQuit()
        elif char == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif char.isdigit() or char == '-':
            k.updateLabel(event)
        elif char in (
            'Alt_L','Alt_R',
            'Control_L','Control_R',
            'Meta_L','Meta_R',
            'Shift_L','Shift_R',
        ):
            k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            k.clearState()
            event = k.dispatchEvent
            k.executeNTimes(event,n)
            k.keyboardQuit()
    elif state == 2:
        k.doControlU(event,stroke)
</t>
<t tx="ekr.20061031131434.201">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
</t>
<t tx="ekr.20061031131434.202">def executeNTimes (self,event,n):

    trace = False and not g.unitTesting
    c,k = self.c,self

    w = event and event.widget

    stroke = event and event.stroke or None
    if not stroke: return

    if stroke == k.fullCommandKey:
        for z in range(n):
            k.fullCommand(event)
    else:
        si = k.getPaneBinding(stroke,event and event.widget)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('repeat',n,'method',si.func.__name__,
                'stroke',stroke,'widget',w)
            for z in range(n):
                event = g.app.gui.create_key_event(c,None,event,stroke,w)
                k.masterCommand(commandName=None,event=event,func=si.func,stroke=stroke)
        else:
            for z in range(n):
                k.masterKeyHandler(event)
</t>
<t tx="ekr.20061031131434.203">def doControlU (self,event,stroke):

    k = self ; c = k.c

    ch = event and event.char or ''

    k.setLabelBlue('Control-u %s' % g.stripBrackets(stroke))

    if ch == '(':
        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
</t>
<t tx="ekr.20061031131434.28">def compute_completion_list (self):

    trace = False and not g.unitTesting
    verbose = False
        # True: report hits and misses.
        # False: report misses.

    if self.klass:
        prefix = ''
        # something later on eats the first char, not sure what
        options = ['^'+i for i in self.lookup_methods([str(self.klass)],None)]
        g.es("%s: %d options" % (self.klass, len(options)))
        self.klass = None
    else:
        prefix = self.get_autocompleter_prefix()
        key,options = self.get_cached_options(prefix)
        if options:
            if trace and verbose: g.trace('**prefix hit: %s, %s' % (prefix,key))
        else:
            if trace: g.trace('**prefix miss: %s, %s' % (prefix,key))
            options = self.get_completions(prefix)

    tabList,common_prefix = g.itemsMatchingPrefixInList(
        prefix,options,matchEmptyPrefix=False)

    if not common_prefix:
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            prefix,options,matchEmptyPrefix=True)

    if trace and verbose:
        g.trace('prefix: %s, common: %s, len(tabList): %s' % (
            repr(prefix),repr(common_prefix),len(tabList)))
        # if verbose: g.trace('options[:10]...\n',
            # g.listToString(options[:10],sort=True))

    if tabList:
        self.show_completion_list(common_prefix,prefix,tabList)

    return common_prefix,prefix,tabList
</t>
<t tx="ekr.20061031131434.29">def do_backspace (self):

    '''Delete the character and recompute the completion list.'''

    c,w = self.c,self.w
    c.bodyWantsFocusNow()

    i = w.getInsertPoint()
    if i &lt;= 0:
        self.exit()
        return

    w.delete(i-1,i)
    w.setInsertPoint(i-1)

    if i &lt;= 1:
        self.exit()
    else:
        # Update the list. Abort if there is no prefix.
        common_prefix,prefix,tabList = self.compute_completion_list()
        if not prefix:
            self.exit()
</t>
<t tx="ekr.20061031131434.3">@nocolor
@

ivar                    Keys                Values
----                    ----                ------
c.commandsDict          command names (1)   functions
c.inverseCommandsDict   func.__name__       command names
k.bindingsDict          shortcuts           lists of ShortcutInfo objects
k.masterBindingsDict    scope names (2)     Interior masterBindingDicts (3)
k.masterGuiBindingsDict strokes             list of widgets in which stoke is bound
k.settingsNameDict (4)  settings.lower()    "Real" Tk specifiers
inverseBindingDict (5)  command names       lists of tuples (pane,key)
modeCommandsDict (6)    command name (7)    inner modeCommandsDicts (8)

Notes:

(1) Command names are minibuffer names (strings)
(2) Scope names are 'all','text',etc.
(3) Interior masterBindingDicts: Keys are strokes; values are ShortcutInfo objects.
(4) k.settingsNameDict has no inverse.
(5) inverseBindingDict is **not** an ivar: it is computed by k.computeInverseBindingDict.
(6) A global dict: g.app.gui.modeCommandsDict
(7) enter-x-command
(8) Keys are command names, values are lists of ShortcutInfo objects.
</t>
<t tx="ekr.20061031131434.31">def insert_string (self,s,select=False):

    '''Insert s at the insertion point.'''

    c = self.c ; w = self.w

    c.widgetWantsFocusNow(w)
    i = w.getInsertPoint()
    w.insert(i,s)
    if select:
        j = i + len(s)
        w.setSelectionRange(i,j,insert=j)

    c.frame.body.onBodyChanged('Typing')

    if self.use_qcompleter:
        # g.trace(self.qw.leo_qc)
        if self.qw:
            c.widgetWantsFocusNow(self.qw.leo_qc)
</t>
<t tx="ekr.20061031131434.38">def info (self):

    c = self.c

    obj,prefix = self.get_object()

    c.frame.log.clearTab('Info',wrap='word')
    
    put = lambda s: self.put('', s, tabName='Info')
    
    put(prefix)
    
    
    try:
        argspec = inspect.getargspec(obj)
        
        # uses None instead of empty list
        argn = argspec.args and len(argspec.args) or 0
        defn = argspec.defaults and len(argspec.defaults) or 0
        
        put("args:")
        simple_args = argspec.args[:argn - defn]
        if not simple_args:
            put('    (none)')
        else:
            put('    '+', '.join(' '+i for i in simple_args))
        put("keyword args:")

        if not argspec.defaults:
            put('    (none)')
        for i in range(defn):
            arg = argspec.args[-defn+i]
            put("    %s = %s" % 
                     (arg, repr(argspec.defaults[i])))
                     
        if argspec.varargs:
            put("varargs: *"+argspec.varargs)
        if argspec.keywords:
            put("keywords: **"+argspec.keywords)
                     
        put('\n')  # separate docstring
    except TypeError:    
        put('\n')  # not a callable
    
    doc = inspect.getdoc(obj)

    if doc:
        put(doc)
    else:
        put("No docstring for "+repr(prefix))
</t>
<t tx="ekr.20061031131434.39">def insert_general_char (self,ch):

    trace = False and not g.unitTesting
    c,k = self.c,self.k ; w = self.w

    if trace: g.trace(repr(ch))

    if g.isWordChar(ch):
        self.insert_string(ch)
        common_prefix,prefix,aList = self.compute_completion_list()
        if trace: g.trace('ch',repr(ch),'prefix',repr(prefix),'len(aList)',len(aList))
        if not aList:
            if self.forbid_invalid: # 2011/06/17.
                # Delete the character we just inserted.
                self.do_backspace()
        elif self.auto_tab and len(common_prefix) &gt; len(prefix):
            extend = common_prefix[len(prefix):]
            if trace: g.trace('*** extend',extend)
            ins = w.getInsertPoint()
            w.insert(ins,extend)
    else:
        if ch == '(' and k.enable_calltips:
            # This calls self.exit if the '(' is valid.
            self.calltip()
        else:
            if trace: g.trace('ch',repr(ch),'calling exit')
            self.insert_string(ch)
            self.exit()
</t>
<t tx="ekr.20061031131434.4">class AutoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
</t>
<t tx="ekr.20061031131434.46">def start (self,event):

    # We don't need to clear this now that we don't use ContextSniffer.
    # self.completionsDict = {}

    if self.use_qcompleter:
        self.init_qcompleter(event)
    else:
        self.init_tabcompleter(event)
</t>
<t tx="ekr.20061031131434.5">def __init__ (self,k):

    # Ivars...
    self.c = c = k.c
    self.k = k
    self.force = None
    self.language = None
    self.qw = None # The object that supports qcompletion methods.
    self.tabName = None # The name of the main completion tab.
    self.verbose = False # True: print all members, regardless of how many there are.
    self.w = None # The widget that gets focus after autocomplete is done.
    self.warnings = {} # Keys are language names.
    self.klass = None
    self.namespaces = [] # additional namespaces to search for objects, other code
                         # can append namespaces to this to extend scope of search

    # Codewise pre-computes...
    self.codewiseSelfList = []
        # The (global) completions for "self."
    self.completionsDict = {}
        # Keys are prefixes, values are completion lists.

    # Options...
    self.auto_tab       = c.config.getBool('auto_tab_complete',False)
    self.forbid_invalid = c.config.getBool('forbid_invalid_completions',False)
    self.use_qcompleter = c.config.getBool('use_qcompleter',False)
        # True: show results in autocompleter tab.
        # False: show results in a QCompleter widget.
</t>
<t tx="ekr.20061031131434.74">class KeyHandlerClass:

    '''A class to support emacs-style commands.'''

    @others
</t>
<t tx="ekr.20061031131434.75"></t>
<t tx="ekr.20061031131434.76">def __init__ (self,c):
    '''Create a key handler for c.'''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: print('k.__init__')
    self.c = c
    self.dispatchEvent = None
    self.fnc = None
        # A singleton defined in k.finishCreate.
    self.getArgInstance = None
        # A singleton defined in k.finishCreate.
    self.inited = False
        # Set at end of finishCreate.
    self.swap_mac_keys = False
        ### How to init this ????
    self.w = None
        # Note: will be None for NullGui.
    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']
    self.altX_prompt = 'full-command: '
    # Access to data types defined in leoKeys.py
    self.KeyStroke = g.KeyStroke
    # Define all ivars...
    self.defineExternallyVisibleIvars()
    self.defineInternalIvars()
    self.defineSettingsIvars()
    if g.new_modes:
        self.modeController = ModeController(c)
    self.defineTkNames()
    self.defineSpecialKeys()
    self.defineSingleLineCommands()
    self.defineMultiLineCommands()
    self.autoCompleter = AutoCompleterClass(self)
    self.qcompleter = None # Set by AutoCompleter.start.
    self.setDefaultUnboundKeyAction()
    self.setDefaultEditingAction()
</t>
<t tx="ekr.20061031131434.78">def defineExternallyVisibleIvars(self):

    self.abbrevOn = False
        # True: abbreviations are on.
    self.arg = ''
        # The value returned by k.getArg.
    self.argSelectedText = '' # The selected text in state 0.
    self.commandName = None # The name of the command being executed.
    self.funcReturn = None # For k.simulateCommand
    self.functionTail = None # For commands that take minibuffer arguments.
    # These are true globals
    self.getArgEscapes = []
    self.getArgEscapeFlag = False # A signal that the user escaped getArg in an unusual way.
    self.givenArgs = [] # New in Leo 4.4.8: arguments specified after the command name in k.simulateCommand.
    self.inputModeBindings = {}
    self.inputModeName = '' # The name of the input mode, or None.
    self.modePrompt = '' # The mode promopt.
    self.negativeArg = False
    self.newMinibufferWidget = None # Usually the minibuffer restores focus.  This overrides this default.
    # self.regx = g.bunch(iter=None,key=None)
    self.repeatCount = None
    self.state = g.bunch(kind=None,n=None,handler=None)
</t>
<t tx="ekr.20061031131434.79">def defineInternalIvars(self):
    '''Define internal ivars of the KeyHandlerClass class.'''
    self.abbreviationsDict = {}
        # Abbreviations created by @alias nodes.
    # Previously defined bindings...
    self.bindingsDict = {}
        # Keys are Tk key names, values are lists of ShortcutInfo's.
    # Previously defined binding tags.
    self.bindtagsDict = {}
        # Keys are strings (the tag), values are 'True'
    self.masterBindingsDict = {}
        # Keys are scope names: 'all','text',etc. or mode names.
        # Values are dicts: keys are strokes, values are ShortcutInfo's.
    self.masterGuiBindingsDict = {}
        # Keys are strokes; value is True;
    # Special bindings for k.fullCommand...
    self.mb_copyKey = None
    self.mb_pasteKey = None
    self.mb_cutKey = None
    # Keys whose bindings are computed by initSpecialIvars...
    self.abortAllModesKey = None
    self.autoCompleteForceKey = None
    self.fullCommandKey = None
    self.universalArgKey = None
    # Used by k.masterKeyHandler...
    self.stroke = None
    self.mb_event = None
    self.mb_history = []
    self.mb_help = False
    self.mb_helpHandler = None
    # Important: these are defined in k.defineExternallyVisibleIvars...
        # self.getArgEscapes = []
        # self.getArgEscapeFlag 
    # For onIdleTime...
    self.idleCount = 0
    # For modes...
    self.modeBindingsDict = {}
    self.modeWidget = None
    self.silentMode = False
</t>
<t tx="ekr.20061031131434.8"></t>
<t tx="ekr.20061031131434.80">def finishCreate (self):
    '''
    Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.
    '''
    trace = (False or g.trace_startup) and not g.unitTesting
    if trace: g.trace('k.finishCreate',self.c)
    c,k = self.c,self
    k.w = c.frame.miniBufferWidget
        # Will be None for NullGui.
    k.fnc = FileNameChooser(c)
        # A singleton. Defined here so that c.k will exist.
    k.getArgInstance = GetArg(c)
        # a singleton. Defined here so that c.k will exist.
    k.makeAllBindings()
    k.inited = True
    k.setDefaultInputState()
    k.resetLabel()
</t>
<t tx="ekr.20061031131434.82">def setDefaultUnboundKeyAction (self,allowCommandState=True):

    k = self ; c = k.c

    # g.trace(g.callers())

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()

    if defaultAction == 'command' and not allowCommandState:
        self.unboundKeyAction = 'insert'
    elif defaultAction in ('command','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % (defaultAction))
        self.unboundKeyAction = 'insert'

    # g.trace(self.unboundKeyAction)

    self.defaultUnboundKeyAction = self.unboundKeyAction

    k.setInputState(self.defaultUnboundKeyAction)
</t>
<t tx="ekr.20061031131434.88"></t>
<t tx="ekr.20061031131434.89">def bindKey (self,pane,shortcut,callback,commandName,modeFlag=False,tag=None):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.

    No actual gui bindings are made: only entries in k.masterBindingsDict.

    tag gives the source of the binding.

    '''

    trace = False and not g.unitTesting
    k = self
    if not k.check_bind_key(commandName,pane,shortcut):
        return False
    aList = k.bindingsDict.get(shortcut,[])
    if trace: #  or shortcut == 'Ctrl+q':
        g.trace('%7s %20s %17s %s' % (pane,shortcut,tag,commandName))
    try:
        if not shortcut:
            stroke = None
        elif g.isStroke(shortcut):
            stroke = shortcut
            assert stroke.s,stroke
        else:
            stroke = k.strokeFromSetting(shortcut)

        si = g.ShortcutInfo(kind=tag,pane=pane,
            func=callback,commandName=commandName,stroke=stroke)

        if shortcut:
            k.bindKeyToDict(pane,shortcut,si)
        if shortcut and not modeFlag:
            aList = k.remove_conflicting_definitions(
                aList,commandName,pane,shortcut)
            # 2013/03/02: a real bug fix.
        aList.append(si)
        if shortcut:
            assert stroke
            k.bindingsDict [stroke] = aList
            if trace: g.trace(shortcut,aList)
        return True
    except Exception: # Could be a user error.
        if g.unitTesting or not g.app.menuWarningsGiven:
            g.es_print('exception binding',shortcut,'to',commandName)
            g.es_print_exception()
            g.app.menuWarningsGiven = True
        return False

bindShortcut = bindKey # For compatibility
</t>
<t tx="ekr.20061031131434.9">def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    trace = False and not g.unitTesting
    c,k = self.c,self.k
    state = k.unboundKeyAction
    w = event and event.w or c.get_focus()
    self.force = force
    self.klass = None
    if not state in ('insert','overwrite'):
        if trace: g.trace('not in insert/overwrite mode')
        return

    # First, handle the invocation character as usual.
    if not force:
        # Ctrl-period does *not* insert a period.
        if trace: g.trace('not force')
        k.masterCommand(event=event)

    # Allow autocompletion only in the body pane.
    if not c.widget_name(w).lower().startswith('body'):
        if trace: g.trace('not body')
        return

    self.language = g.scanForAtLanguage(c,c.p)
    if w and (k.enable_autocompleter or force): # self.language == 'python':
        if trace: g.trace('starting')
        self.w = w
        self.start(event)
    else:
        if trace: g.trace('autocompletion not enabled')
</t>
<t tx="ekr.20061031131434.92">def remove_conflicting_definitions (self,aList,commandName,pane,shortcut):

    trace = False and not g.unitTesting
    k = self
    result = []
    for si in aList:
        assert g.isShortcutInfo(si),si
        if pane in ('button','all',si.pane):
            if trace:
                # This is too annoying to report here. See bug 951921.
                g.es_print('c for %s in %s' % (
                    si.stroke,k.c.shortFileName()))
                g.es_print('previous: %s new: %s' % (si.commandName,commandName))
            k.kill_one_shortcut(shortcut)
        else:
            result.append(si)
    return result
</t>
<t tx="ekr.20061031131434.93">def bindKeyToDict (self,pane,stroke,si):

    '''Update k.masterBindingsDict for the stroke.'''

    # New in Leo 4.4.1: Allow redefintions.
    k = self
    assert g.isStroke(stroke),stroke
    d = k.masterBindingsDict.get(pane,{})
    d[stroke] = si
    k.masterBindingsDict [pane] = d
</t>
<t tx="ekr.20061031131434.94">def bindOpenWith (self,d):

    '''Register an open-with command.'''

    k = self ; c = k.c

    shortcut = d.get('shortcut')
    name = d.get('name')

    # g.trace(d)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,c=c,d=d):
        return c.openWith(d=d)

    # Use k.registerCommand to set the shortcuts in the various binding dicts.
    commandName = 'open-with-%s' % name.lower()
    k.registerCommand(commandName,shortcut,openWithCallback,pane='all',verbose=False)
</t>
<t tx="ekr.20061031131434.95">def checkBindings (self):

    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''

    k = self ; c = k.c

    if not c.config.getBool('warn_about_missing_settings'): return

    for name in sorted(c.commandsDict):
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not c.config.exists(key,'shortcut'):
            if abbrev:
                g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))
</t>
<t tx="ekr.20061031131434.96">def completeAllBindingsForWidget (self,w):
    
    '''Make all a master gui binding for widget w.'''

    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke),repr(stroke)
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20061031131434.97">def completeAllBindings (self,w=None):

    '''New in 4.4b3: make an actual binding in *all* the standard places.

    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''

    # g.trace(w)

    k = self
    for stroke in k.bindingsDict:
        assert g.isStroke(stroke),repr(stroke)
        k.makeMasterGuiBinding(stroke,w=w)
</t>
<t tx="ekr.20061031131434.98">def makeAllBindings (self):
    
    '''Make all key bindings in all of Leo's panes.'''

    k = self ; c = k.c
    k.bindingsDict = {}
    if g.new_modes:
        k.modeController.addModeCommands()
    else:
        k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    k.initAbbrev()
    k.completeAllBindings()
    k.checkBindings()
</t>
<t tx="ekr.20061031131434.99">def initAbbrev (self):

    k = self ; c = k.c ; d = c.config.getAbbrevDict()
    if d:
        for key in d:
            commandName = d.get(key)
            if commandName.startswith('press-') and commandName.endswith('-button'):
                pass # Must be done later in k.registerCommand.
            else:
                self.initOneAbbrev(commandName,key)

</t>
<t tx="ekr.20061031170011.10">def setLabelBlue (self,label):
    '''Set the minibuffer label.'''
    trace = False and not g.unitTesting
    k = self ; w = k.w
    if trace: g.trace('label:',label,g.callers())
    if w:
        w.setStyleClass('')  # normal state, not warning or error
        if label is not None:
            k.setLabel(label,protect=True)
    elif trace:
        g.trace('*** no w ***')
</t>
<t tx="ekr.20061031170011.11">def setLabelGrey (self,label=None):

    k = self ; w = self.w
    if not w: return

    w.setStyleClass( 'minibuffer_warning')

    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey
</t>
<t tx="ekr.20061031170011.12">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or g.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.w
    ch = (event and event.char) or ''
    if trace: g.trace('ch',ch,'k.stroke',k.stroke)

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1
</t>
<t tx="ekr.20061031170011.13">def getEditableTextRange (self):

    k = self ; w = self.w
    s = w.getAllText()
    i = len(k.mb_prefix)
    j = len(s)
    return i,j
</t>
<t tx="ekr.20061031170011.3"># These may be overridden, but this code is now gui-independent.
</t>
<t tx="ekr.20061031170011.5">def getLabel (self,ignorePrompt=False):

    k = self ; w = self.w
    if not w: return ''

    s = w.getAllText()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''
</t>
<t tx="ekr.20061031170011.6">def protectLabel (self):

    k = self ; w = self.w
    if not w: return

    k.mb_prefix = w.getAllText()

</t>
<t tx="ekr.20061031170011.7">def resetLabel (self):
    '''Reset the minibuffer label.'''
    k = self
    c,w = k.c,k.w
    k.setLabelGrey('')
    k.mb_prefix = ''
    if w:    
        w.setSelectionRange(0,0,insert=0)
        state = k.unboundKeyAction
        if c.vim_mode and c.vimCommands:
            c.vimCommands.show_status()
        else:
            k.setLabelBlue(label='%s State' % (state.capitalize()))
</t>
<t tx="ekr.20061031170011.8">def setLabel (self,s,protect=False):
    '''Set the label of the minibuffer.'''
    trace = False and not g.app.unitTesting
    k,w = self,self.w
    if w:
        if trace: g.trace(repr(s),g.callers())
        w.setAllText(s)
        n = len(s)
        w.setSelectionRange(n,n,insert=n)
        if protect:
            k.mb_prefix = s
    elif trace:
        g.trace('*** no w ***')
</t>
<t tx="ekr.20061031170011.9">def extendLabel(self,s,select=False,protect=False):

    trace = False and not g.unitTesting

    k = self ; c = k.c ; w = self.w
    if not (w and s): return

    if trace: g.trace(s)

    c.widgetWantsFocusNow(w)

    w.insert('end',s)

    if select:
        i,j = k.getEditableTextRange()
        w.setSelectionRange(i,j,insert=j)

    if protect:
        k.protectLabel()
</t>
<t tx="ekr.20061101071425">def oops (self):

    g.trace('Should be defined in subclass:',g.callers(4))
</t>
<t tx="ekr.20070123085931">def defineSpecialKeys (self):

    '''Define k.guiBindNamesDict and k.guiBindNamesInverseDict.

    Important: all gui's use these dictionaries because bindings in
    leoSettings.leo use these representations.'''

    k = self

    # These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    # Important: only the inverse dict is actually used in the new key binding scheme.
    # Tk may return the *values* of this dict in event.keysym fields.
    # Leo will warn if it gets a event whose keysym not in values of this table.
    k.guiBindNamesDict = {
        "&amp;" : "ampersand",
        "^" : "asciicircum",
        "~" : "asciitilde",
        "*" : "asterisk",
        "@" : "at",
        "\\": "backslash",
        "|" : "bar",
        "{" : "braceleft",
        "}" : "braceright",
        "[" : "bracketleft",
        "]" : "bracketright",
        ":" : "colon",      # removed from code.
        "," : "comma",
        "$" : "dollar",
        "=" : "equal",
        "!" : "exclam",     # removed from code.
        "&gt;" : "greater",
        "&lt;" : "less",
        "-" : "minus",
        "#" : "numbersign",
        '"' : "quotedbl",
        "'" : "quoteright",
        "(" : "parenleft",
        ")" : "parenright", # removed from code.
        "%" : "percent",
        "." : "period",     # removed from code.
        "+" : "plus",
        "?" : "question",
        "`" : "quoteleft",
        ";" : "semicolon",
        "/" : "slash",
        " " : "space",      # removed from code.
        "_" : "underscore",
    }

    # No translation.
    for s in k.tkNamesList:
        k.guiBindNamesDict[s] = s

    # Create the inverse dict.
    k.guiBindNamesInverseDict = {}
    for key in k.guiBindNamesDict:
        k.guiBindNamesInverseDict [k.guiBindNamesDict.get(key)] = key
</t>
<t tx="ekr.20070123143428">def defineTkNames (self):

    k = self

    # These are the key names used in Leo's core *regardless* of the gui actually in effect.
    # The gui is responsible for translating gui-dependent keycodes into these values.
    k.tkNamesList = (
        # Arrow keys.
        'Left','Right','Up','Down',
        # Page up/down keys.
        'Next','Prior',
        # Home end keys.
        'Home','End'
        # Modifier keys.
        'Caps_Lock','Num_Lock',
        # F-keys.
        'F1','F2','F3','F4','F5','F6','F7','F8','F9','F10','F11','F12',
        # All others.
        'Begin','Break','Clear','Delete','Escape',
        # Dubious: these are ascii characters!
        # But there is no harm in retaining these in Leo's core.
        'BackSpace','Linefeed','Return','Tab',
    )

    # These keys settings that may be specied in leoSettings.leo.
    # Keys are lowercase, so that case is not significant *for these items only* in leoSettings.leo.
    k.settingsNameDict = {
        'bksp'    : 'BackSpace', # Dubious: should be '\b'
        'dnarrow' : 'Down',
        'esc'     : 'Escape',
        'ltarrow' : 'Left',
        'pageup'  : 'Prior',
        'pagedn'  : 'Next',
        'rtarrow' : 'Right',
        'uparrow' : 'Up',
    }

    # Add lowercase version of special keys.
    for s in k.tkNamesList:
        k.settingsNameDict [s.lower()] = s

@
The following are not translated, so what appears in the menu is the
same as what is passed to the gui. Case is significant. Note: the Tk
documentation states that not all of these may be available on all
platforms.

Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9,
Insert
</t>
<t tx="ekr.20070218130238">def dumpMasterBindingsDict (self):
    
    '''Dump k.masterBindingsDict.'''

    k = self ; d = k.masterBindingsDict

    g.pr('\nk.masterBindingsDict...\n')

    for key in sorted(d):
        g.pr(key, '-' * 40)
        d2 = d.get(key)
        for key2 in sorted(d2):
            si = d2.get(key2)
            assert g.isShortcutInfo(si),si
            g.pr('%20s %s' % (key2,si.commandName))
</t>
<t tx="ekr.20070317085437.31">def createChapter (self,event=None):

    '''create-chapter command.

    Create a chapter with a dummy first node.
    
    '''
    cc,k,tag = self,self.c.k,'create-chapter'
    state = k.getState(tag)
    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter: ')
        k.getArg(event,tag,1,self.createChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=None,undoType='Create Chapter')
</t>
<t tx="ekr.20070317085437.41">def renameChapter (self,event=None,newName=None): # newName is for unitTesting.

    '''Use the minibuffer to get a new name for the present chapter.'''

    cc,c,k,tag = self,self.c,self.c.k,'rename-chapter'
    state = k.getState(tag)
    if state == 0 and not newName:
        chapter = cc.selectedChapter
        if not chapter: return
        if chapter.name == 'main':
            return cc.note('can not rename the main chapter')
        else:
            names = list(cc.chaptersDict.keys())
            k.setLabelBlue('Rename this chapter: ')
            k.getArg(event,tag,1,self.renameChapter,tabList=names) # prefix=prefix,
    else:
        k.clearState()
        k.resetLabel()
        chapter = cc.selectedChapter
        if newName: k.arg = newName # A hack for unit testing.
        if chapter and k.arg and k.arg != chapter.name:
            cc.renameChapterByName(k.arg)
</t>
<t tx="ekr.20070317085437.50">def cloneNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then clone the selected node to the chapter.'''

    cc,k,tag = self,self.c.k,'clone-node-to-chapter'
    state = k.getState(tag)
    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Clone node to chapter: '
        k.setLabelBlue(prefix)
        k.getArg(event,tag,1,self.cloneNodeToChapter,prefix=prefix,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.cloneNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070317085437.51">def copyNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then copy the selected node to the chapter.'''

    cc,k,tag = self,self.c.k,'copy-node-to-chapter'
    state = k.getState(tag)
    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        prefix = 'Copy node to chapter: '
        k.setLabelBlue(prefix)
        k.getArg(event,tag,1,self.copyNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.copyNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070317085437.52">def moveNodeToChapterHelper (self,toChapterName):

    cc,c,p,u = self,self.c,self.c.p,self.c.undoer
    undoType = 'Move Node To Chapter'
    if g.match_word(p.h,0,'@chapter'):
        return cc.note('can not move @chapter node to another chapter')
    # Get the chapter objects.
    fromChapter = cc.getSelectedChapter()
    toChapter = cc.getChapter(toChapterName)
    if not fromChapter:
        return cc.note('no selected chapter')
    if not fromChapter:
        return cc.note('no chapter: %s' % (toChapterName))
    # Get the roots
    fromRoot,toRoot = fromChapter.findRootNode(),toChapter.findRootNode()
    if not fromRoot:
        return cc.note('no @chapter %s' % (fromChapter.name))
    if not toRoot:
        return cc.note('no @chapter %s' % (toChapter.name))
    if toChapter.name == 'main':
        sel = (p.threadBack() != fromRoot and p.threadBack()) or p.nodeAfterTree()
    else:
        sel = p.threadBack() or p.nodeAfterTree()
    if sel:
        # Get 'before' undo data.
        inAtIgnoreRange = p.inAtIgnoreRange()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        # Do the move.
        if toChapter.name == 'main':
            p.moveAfter(toChapter.p)
        else:
            p.moveToLastChildOf(toRoot)
        c.redraw(sel)
        c.setChanged(True)
        # Do the 'after' undo operation.
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
    if sel:
        toChapter.p = p.copy()
        toChapter.select()
        fromChapter.p = sel.copy()
    else:
        cc.note('can not move the last remaining node of a chapter.')
</t>
<t tx="ekr.20070317130250">def selectChapterByName (self,name,collapse=True,create=True):

    '''Select a chapter.  Return True if a redraw is needed.'''

    trace = False and not g.unitTesting
    cc,c = self,self.c
    if type(name) == type(9):
        return cc.note('PyQt5 chapaters not supported')
    chapter = cc.chaptersDict.get(name)
    if chapter:
        cc.selectChapterByNameHelper(chapter,collapse=collapse)
    elif create:
        # There is an @chapter node, but no actual chapter.
        if trace: g.trace('*** creating',name)
        cc.createChapterByName(name,p=c.p,undoType='Create Chapter')
    else:
        # create is False if called from the minibuffer.
        # do nothing if the user mis-types.
        cc.note('no such chapter: %s' % name)
        chapter = cc.chaptersDict.get('main')
        if chapter:
            self.selectChapterByNameHelper(chapter,collapse=collapse)
        else:
            g.trace(g.callers())
            cc.error('no main chapter!')
</t>
<t tx="ekr.20070604155815.1">def cloneNodeToChapterHelper (self,toChapterName):

    cc,c,p,u,undoType = self,self.c,self.c.p,self.c.undoer,'Clone Node To Chapter'
    # Find the @chapter nodes and related chapter objects.
    fromChapter = cc.getSelectedChapter()
    if not fromChapter:
        return cc.note('no @chapter %s' % (fromChapter and fromChapter.name))
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.note('no @chapter %s' % (toChapter.name))
    # Find the root of each chapter.
    toRoot = toChapter.findRootNode()
    assert toRoot
    if g.match_word(p.h,0,'@chapter'):
        return cc.note('can not clone @chapter node')
    # Open the group undo.
    c.undoer.beforeChangeGroup(toRoot,undoType)
    # Do the clone.  c.clone handles the inner undo.
    clone = c.clone()
    # Do the move.
    undoData2 = u.beforeMoveNode(clone)
    if toChapter.name == 'main':
        clone.moveAfter(toChapter.p)
    else:
        clone.moveToLastChildOf(toRoot)
    u.afterMoveNode(clone,'Move Node',undoData2,dirtyVnodeList=[])
    c.redraw(clone)
    c.setChanged(True)
    # Close the group undo.
    # Only the ancestors of the moved node get set dirty.
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.undoer.afterChangeGroup(clone,undoType,reportFlag=False,dirtyVnodeList=dirtyVnodeList)
    toChapter.p = clone.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070604155815.2">def copyNodeToChapterHelper (self,toChapterName):

    cc,c,p,u,undoType = self,self.c,self.c.p,self.c.undoer,'Copy Node To Chapter'
    if g.match_word(p.h,0,'@chapter'):
        return cc.note('can not copy @chapter node')
    # Get the chapter objects.
    fromChapter = cc.getSelectedChapter()
    if not fromChapter:
        return cc.note('no @chapter %s' % (toChapterName))
    toChapter = cc.getChapter(toChapterName)
    if not toChapter:
        return cc.note('no such chapter: %s' % toChapterName)
    toRoot = toChapter.findRootNode()
    assert toRoot
    # For undo, we treat the copy like a pasted (inserted) node.
    undoData = u.beforeInsertNode(toRoot,pasteAsClone=False,copiedBunchList=[])
    s = c.fileCommands.putLeoOutline()
    p2 = c.fileCommands.getLeoOutline(s)
    p2.moveToLastChildOf(toRoot)
    c.redraw(p2)
    u.afterInsertNode(p2,undoType,undoData)
    c.setChanged(True)
    toChapter.p = p2.copy()
    toChapter.select()
    fromChapter.p = p.copy()
</t>
<t tx="ekr.20070604155815.3">def moveNodeToChapter (self,event=None):

    '''Prompt for a chapter name,
    then move the selected node to the chapter.'''

    cc,k,tag = self,self.c.k,'move-node-to-chapter'
    state = k.getState(tag)
    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        k.setLabelBlue('Move node to chapter: ')
        k.getArg(event,tag,1,self.moveNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.moveNodeToChapterHelper(k.arg)
</t>
<t tx="ekr.20070604165126">def selectChapter (self,event=None):

    '''Use the minibuffer to get a chapter name,
    then create the chapter.'''

    cc,k,tag = self,self.c.k,'select-chapter'
    state = k.getState(tag)
    if state == 0:
        names = list(cc.chaptersDict.keys())
        g.es('Chapters:\n' + '\n'.join(names))
        k.setLabelBlue('Select chapter: ')
        k.getArg(event,tag,1,self.selectChapter,tabList=names) # prefix=prefix,
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.selectChapterByName(k.arg,create=False)
</t>
<t tx="ekr.20070605110441">def dynamicExpandHelper (self,event,prefix=None,aList=None,w=None):

    c = self.c ; k = c.k ; p = c.p
    tag = 'dabbrev-expand'
    state = k.getState(tag)
    if state == 0:
        self.w = w
        prefix2 = 'dabbrev-expand: '
        c.frame.log.deleteTab('Completion')
        g.es('','\n'.join(aList),tabName='Completion')
        k.setLabelBlue(prefix2+prefix)
        k.getArg(event,tag,1,self.dynamicExpandHelper,tabList=aList)
    else:
        c.frame.log.deleteTab('Completion')
        k.clearState()
        k.resetLabel()
        if k.arg:
            w = self.w
            s = w.getAllText()
            ypos = w.getYScrollPosition()
            b = c.undoer.beforeChangeNodeContents(p,oldYScroll=ypos)
            ins = w.getInsertPoint()
            if 0 &lt; ins &lt; len(s) and not g.isWordChar(s[ins]): ins -= 1
            i,j = g.getWord(s,ins)
            p.b = p.b[:i] + k.arg + p.b[j:]
            w.setAllText(p.b)
            w.setInsertPoint(i+len(k.arg))
            w.setYScrollPosition(ypos)
            c.undoer.afterChangeNodeContents(p,
                command=tag,bunch=b,dirtyVnodeList=[]) 
</t>
<t tx="ekr.20070607092909">def createChapterFromNode (self,event=None):

    '''create-chapter-from-node command.

    Create a chapter whose first node is a clone of the presently selected node.'''

    cc,c,k,p,tag = self,self.c,self.c.k,self.c.p,'create-chapter-from-node'
    state = k.getState(tag)
    if p.h.startswith('@chapter'):
        cc.note('can not create a new chapter from from an @chapter or @chapters node.')
        return
    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Create chapter from node: ')
        k.getArg(event,tag,1,self.createChapterFromNode,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,undoType='Create Chapter From Node')
</t>
<t tx="ekr.20070608072116">def convertNodeToChapter (self,event=None):

    '''convert-node-to-chapter command.

    Make the selected node into a new chapter, 'in place'.
    That is, create the new @chapter node as the next sibling of the node,
    then move the node as the first child of the new @chapter node.'''

    cc,c,k,p,tag = self,self.c,self.c.k,self.c.p,'convert-node-to-chapter'
    state = k.getState(tag)
    if p.h.startswith('@chapter'):
        cc.note('can not create a new chapter from from an @chapter or @chapters node.')
        return
    if state == 0:
        names = list(cc.chaptersDict.keys())
        k.setLabelBlue('Convert node to chapter: ')
        k.getArg(event,tag,1,self.convertNodeToChapter,tabList=names)
    else:
        k.clearState()
        k.resetLabel()
        if k.arg:
            cc.createChapterByName(k.arg,p=p,undoType='Convert Node To Chapter')
</t>
<t tx="ekr.20070613133500">def menuCommandKey (self,event=None):

    # This method must exist, but it never gets called.
    pass 
</t>
<t tx="ekr.20071212104050">def overrideCommand (self,commandName,func):

    # Override entries in c.k.masterBindingsDict
    k = self
    d = k.masterBindingsDict
    for key in d:
        d2 = d.get(key)
        for key2 in d2:
            si = d2.get(key2)
            assert g.isShortcutInfo(si),si
            if si.commandName == commandName:
                si.func=func
                d2[key2] = si
</t>
<t tx="ekr.20080408060320.1">def findWordHelper (self,event,oneLine):

    k = self.k ; tag = 'find-word' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # Sets self.w
        if not w: return
        self.oneLineFlag = oneLine
        k.setLabelBlue('Find word %sstarting with: ' % (
            'in line ' if oneLine else ''))
        k.getArg(event,tag,1,self.findWord,oneCharacter=True)
    else:        
        ch = k.arg
        if ch:
            w = self.w
            i = w.getInsertPoint()
            s = w.getAllText()
            end = len(s)
            if self.oneLineFlag:
                end = s.find('\n',i) # Limit searches to this line.
                if end == -1: end = len(s)
            while i &lt; end:
                i = s.find(ch,i+1,end) # Ensure progress and i &gt; 0.
                if i == -1:
                    break
                elif not g.isWordChar(s[i-1]):
                    w.setSelectionRange(i,i,insert=i)
                    break
        k.resetLabel()
        k.clearState()
</t>
<t tx="ekr.20080408060320.790">def selectAll (self):

    '''Select all the user-editable text of the minibuffer.'''

    w = self.w
    i,j = self.getEditableTextRange()
    w.setSelectionRange(i,j,insert=j)


</t>
<t tx="ekr.20080408060320.791">def killLine (self,protect=True):

    k = self
    w = k.w
    s = w.getAllText()
    s = s[:len(k.mb_prefix)]
    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)
    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20080412053100.5">
























@language python</t>
<t tx="ekr.20080509064108.6">def defineSingleLineCommands (self):

    k = self

    # These commands can be executed in the minibuffer.
    k.singleLineCommandList = [
        # EditCommandsClass
        'back-to-indentation',
        'back-to-home', # 2010/02/01
        'back-char',
        'back-char-extend-selection',
        'back-word',
        'back-word-extend-selection',
        'backward-delete-char',
        'backward-find-character',
        'backward-find-character-extend-selection',
        'beginning-of-line',
        'beginning-of-line-extend-selection',
        'capitalize-word',
        'delete-char',
        'delete-indentation',
        'delete-spaces',
        'downcase-word',
        'end-of-line',
        'end-of-line-extend-selection',
        'escape',
        'exchange-point-mark',
        'extend-to-line',
        'extend-to-word',
        'find-character',
        'find-character-extend-selection',
        'find-word',
        'find-word-in-line',
        'forward-char',
        'forward-char-extend-selection',
        'forward-end-word',
        'forward-end-word-extend-selection',
        'forward-word',
        'forward-word-extend-selection',
        'insert-newline',
        'insert-parentheses',
        'move-past-close',
        'move-past-close-extend-selection',
        'newline-and-indent',
        'select-all',
        'transpose-chars',
        'transpose-words',
        'upcase-word',
        # KeyHandlerCommandsClass
        # 'auto-complete',
        'negative-argument',
        'number-command',
        'number-command-0',
        'number-command-1',
        'number-command-2',
        'number-command-3',
        'number-command-4',
        'number-command-5',
        'number-command-6',
        'number-command-7',
        'number-command-8',
        'universal-argument',
        # KillBufferCommandsClass
        'backward-kill-word',
        'kill-line',
        'kill-word',
        'kill-ws',
        'yank',
        'yank-pop',
        'zap-to-character',
        # leoCommands
        'cut-text',
        'copy-text',
        'paste-text',
        # MacroCommandsClass
        'call-last-kbd-macro',
        # search commands
        # 'replace-string', # A special case so Shift-Ctrl-r will work after Ctrl-f.
        'set-find-everywhere',              # 2011/06/07
        'set-find-node-only',               # 2011/06/07
        'set-find-suboutline-only',         # 2011/06/07
        'toggle-find-collapses_nodes',
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-reverse-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # RegisterCommandsClass
        'append-to-register',
        'copy-to-register',
        'insert-register',
        'prepend-to-register',
    ]
</t>
<t tx="ekr.20080509064108.7">def defineMultiLineCommands (self):

    k = self

    k.multiLineCommandList = [
        # EditCommandsClass
        'add-space-to-lines',
        'add-tab-to-lines',
        'back-page',
        'back-page-extend-selection',
        'back-paragraph',
        'back-paragraph-extend-selection',
        'back-sentence',
        'back-sentence-extend-selection',
        'backward-kill-paragraph',
        'beginning-of-buffer',
        'beginning-of-buffer-extend-selection',
        'center-line',
        'center-region',
        'clean-all-lines',
        'clean-lines',
        'downcase-region',
        'end-of-buffer',
        'end-of-buffer-extend-selection',
        'extend-to-paragraph',
        'extend-to-sentence',
        'fill-paragraph',
        'fill-region',
        'fill-region-as-paragraph',
        'flush-lines',
        'forward-page',
        'forward-page-extend-selection',
        'forward-paragraph',
        'forward-paragraph-extend-selection',
        'forward-sentence',
        'forward-sentence-extend-selection',
        'indent-relative',
        'indent-rigidly',
        'indent-to-comment-column',
        'move-lines-down',
        'move-lines-up',
        'next-line',
        'next-line-extend-selection',
        'previous-line',
        'previous-line-extend-selection',
        'remove-blank-lines',
        'remove-space-from-lines',
        'remove-tab-from-lines',
        'reverse-region',
        'reverse-sort-lines',
        'reverse-sort-lines-ignoring-case',
        'scroll-down-half-page',
        'scroll-down-line',
        'scroll-down-page',
        'scroll-up-half-page',
        'scroll-up-line',
        'scroll-up-page',
        'simulate-begin-drag',
        'simulate-end-drag',
        'sort-columns',
        'sort-fields',
        'sort-lines',
        'sort-lines-ignoring-case',
        'split-line',
        'tabify',
        'transpose-lines',
        'untabify',
        'upcase-region',
        # KeyHandlerCommandsClass
        'repeat-complex-command',
        # KillBufferCommandsClass
        'backward-kill-sentence',
        'kill-sentence',
        'kill-region',
        'kill-region-save',
        # QueryReplaceCommandsClass
        'query-replace',
        'query-replace-regex',
        # RecTangleCommandsClass
        'clear-rectangle',
        'close-rectangle',
        'delete-rectangle',
        'kill-rectangle',
        'open-rectangle',
        'string-rectangle',
        'yank-rectangle',
        # RegisterCommandsClass
        'jump-to-register',
        'point-to-register',
        # SearchCommandsClass
        'change',
        'change-then-find',
        'find-next',
        'find-prev',
    ]
</t>
<t tx="ekr.20080510095819.1">def handleUnboundKeys (self,event,char,stroke):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; c = k.c
    modesTuple = ('insert','overwrite')
    # g.trace('self.enable_alt_ctrl_bindings',self.enable_alt_ctrl_bindings)
    assert g.isStroke(stroke)
    if trace and verbose: g.trace('ch: %s, stroke %s' % (
        repr(event and event.char),repr(stroke)))
    # g.trace('stroke',repr(stroke),'isFKey',k.isFKey(stroke))
    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        if trace: g.trace('ignoring unbound character in command mode',stroke)
        return
    elif stroke.isFKey():
        if trace: g.trace('ignoring F-key',stroke)
        return
    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        k.masterCommand(event=event,stroke=stroke)
        return
    elif (not self.enable_alt_ctrl_bindings and
        (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)
    ):
        # 2011/02/11: Always ignore unbound Alt/Ctrl keys.
        if trace: g.trace('ignoring unbound Alt/Ctrl key',
            repr(char),repr(stroke))
        return
    elif k.ignore_unbound_non_ascii_keys and (
        len(char) &gt; 1 or
        char not in string.printable # 2011/06/10: risky test?
    ):
        if trace: g.trace('ignoring unbound non-ascii key',
            repr(char),repr(stroke))
        return
    elif (
        stroke and stroke.find('Escape') != -1 or
        stroke and stroke.find('Insert') != -1
    ):
        # Never insert escape or insert characters.
        if trace: g.trace('ignore Escape/Ignore',stroke)
        return
    else:
        if trace: g.trace('no func',repr(char),repr(stroke))
        k.masterCommand(event=event,stroke=stroke)
        return
</t>
<t tx="ekr.20080510153327.2">def setLabelRed (self,label=None,protect=False):

    k = self ; w = self.w
    if not w: return

    w.setStyleClass('minibuffer_error')

    if label is not None:
        k.setLabel(label,protect)
</t>
<t tx="ekr.20080511122507.4">def setDefaultInputState (self):

    k = self ; state = k.defaultUnboundKeyAction

    # g.trace(state)

    k.setInputState(state)
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20090306060344.2">def selectChapterByNameHelper (self,chapter,collapse=True):

    trace = False and not g.unitTesting
    cc,c = self,self.c
    if trace:
        g.trace('old: %s, new: %s' % (
            cc.selectedChapter and cc.selectedChapter.name,
            chapter and chapter.name))
    if chapter == cc.selectedChapter:
        if trace: g.trace('already selected')
        return
    if cc.selectedChapter:
        cc.selectedChapter.unselect()
    p = chapter.p
    if p and not c.positionExists(p):
        if trace: g.trace('*** switching to root node for',chapter.name)
        chapter.p = chapter.findRootNode()
    chapter.select()
    c.setCurrentPosition(chapter.p)
    cc.selectedChapter = chapter
    # Clean up, but not initially.
    if collapse and chapter.name == 'main':
        for p in c.all_positions():
            # Compare vnodes, not positions.
            if p.v != c.p.v:
                p.contract()
    # New in Leo 4.6 b2: *do* call c.redraw.
    c.redraw()
</t>
<t tx="ekr.20090518072506.8494">def isFKey (self,stroke):

    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20091230094319.6240">def getPaneBinding (self,stroke,w):

    trace = False and not g.unitTesting
    verbose = True
    k = self ; w_name = k.c.widget_name(w)
    # keyStatesTuple = ('command','insert','overwrite')
    state = k.unboundKeyAction
    assert g.isStroke(stroke)
    if trace: g.trace('w_name',repr(w_name),'stroke',stroke,'w',w,
        'isTextWidget(w)',g.app.gui.isTextWidget(w))
    for key,name in (
        # Order here is similar to bindtags order.
        ('command',None),
        ('insert',None),
        ('overwrite',None),
        ('button',None),
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None),
        ('all',None),
    ):
        if (
            # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
            name and w_name.startswith(name) or
            key in ('command','insert','overwrite') and state == key or # 2010/02/09
            key in ('text','all') and g.app.gui.isTextWidget(w) or
            key in ('button','all')
        ):
            d = k.masterBindingsDict.get(key,{})
            if trace and verbose:
                # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
                g.trace('key: %7s name: %6s stroke: %10s in keys: %s' %
                    (key,name,stroke,stroke in d))
                # g.trace(key,'keys',g.listToString(list(d.keys()),sort=True)) # [:5])
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                        # masterBindingsDict: keys are KeyStrokes
                    assert g.isShortcutInfo(si),si
                    table = ('previous-line','next-line',)
                    if key == 'text' and name == 'head' and si.commandName in table:
                        if trace: g.trace('***** special case',si.commandName)
                    else:
                        if trace: g.trace('key: %7s name: %6s  found %s = %s' % (
                            key,name,repr(si.stroke),si.commandName))
                        return si
    return None
</t>
<t tx="ekr.20091230094319.6244">def doMode (self,event,state,stroke):

    trace = False and not g.unitTesting
    k = self
    # First, honor minibuffer bindings for all except user modes.
    if state in ('getArg','getFileName','full-command','auto-complete','vim-mode'):
        if k.handleMiniBindings(event,state,stroke):
            return True
    # Second, honor general modes.
    if state == 'getArg':
        k.getArg(event,stroke=stroke)
        return True
    elif state in ('getFileName','get-file-name'):
        if trace: g.trace(event,state,stroke)
        k.getFileName(event)
        return True
    elif state in ('full-command','auto-complete'):
        # Do the default state action.
        if trace: g.trace('calling state function',k.state.kind)
        val = k.callStateFunction(event) # Calls end-command.
        if trace: g.trace('state function returns',repr(val))
        return val != 'do-standard-keys'
    # Third, pass keys to user modes.
    d =  k.masterBindingsDict.get(state)
    if d:
        assert g.isStrokeOrNone(stroke)
        si = d.get(stroke)
        if si:
            assert g.isShortcutInfo(si),si
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=si.commandName,func=si.func,
                modeName=state,nextMode=si.nextMode)
            return True
        else:
            # New in Leo 4.5: unbound keys end mode.
            # if trace: g.trace('unbound key ends mode',stroke,state)
            if 0: # 2012/05/20: I dislike this warning.
                g.warning('unbound key ends mode',stroke) # 2011/02/02
            k.endMode()
            return False
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            if trace: g.trace('handler',handler)
            handler(event)
        else:
            if trace: g.trace('No state handler for %s' % state)
        return True
</t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20101101175644.5891">def put (self,*args,**keys):

    '''Put s to the given tab.

    May be overridden in subclasses.'''

    # print('autoCompleter.put',args,keys)

    if g.unitTesting:
        pass
    else:
        g.es(*args,**keys)
</t>
<t tx="ekr.20110202111105.15439">def showStateCursor (self,state,w):

    # g.trace(state,w)

    pass


</t>
<t tx="ekr.20110209083917.16004">def isAutoCompleteChar (self,stroke):

    '''Return True if stroke is bound to the auto-complete in
    the insert or overwrite state.'''

    k = self ; state = k.unboundKeyAction

    assert g.isStrokeOrNone(stroke)

    if stroke and state in ('insert','overwrite'):
        for key in (state,'body','log','text','all'):
            d = k.masterBindingsDict.get(key,{})
            if d:
                si = d.get(stroke)
                if si:
                    assert si.stroke == stroke,'si: %s stroke: %s' % (si,stroke)
                    assert g.isShortcutInfo(si),si
                    if si.commandName == 'auto-complete':
                        return True
    return False
</t>
<t tx="ekr.20110209093958.15411">def setEditingState (self):

    k = self ; state = k.defaultEditingAction

    # g.trace(state)

    k.setInputState(state)
</t>
<t tx="ekr.20110209093958.15413">def setDefaultEditingAction (self):

    k = self ; c = k.c

    action = c.config.getString('default_editing_state') or 'insert'
    action.lower()

    if action not in ('command','insert','overwrite'):
        g.trace('ignoring default_editing_state: %s' % (action))
        action = 'insert'

    self.defaultEditingAction = action
</t>
<t tx="ekr.20110312162243.14260">class ContextSniffer:

    """ Class to analyze surrounding context and guess class

    For simple dynamic code completion engines.
    """

    def __init__(self):

        self.vars = {}
            # Keys are var names; values are list of classes

    @others
</t>
<t tx="ekr.20110312162243.14261">def get_classes (self,s,varname):

    '''Return a list of classes for string s.'''

    self.push_declarations(s)

    aList = self.vars.get(varname,[])   

    return aList
</t>
<t tx="ekr.20110312162243.14262"># def set_small_context(self, body):

    # """ Set immediate function """

    # self.push_declarations(body)
</t>
<t tx="ekr.20110312162243.14263">def push_declarations(self,s):

    for line in s.splitlines():
        line = line.lstrip()
        if line.startswith('#'):
            line = line.lstrip('#')
            parts = line.split(':')
            if len(parts) == 2:
                a,b = parts
                self.declare(a.strip(),b.strip())
</t>
<t tx="ekr.20110312162243.14264">def declare(self, var, klass):

    # g.trace(var,klass) # Very large trace.

    vars = self.vars.get(var, [])
    if not vars:
        self.vars[var] = vars

    vars.append(klass)
</t>
<t tx="ekr.20110314115639.14269">def is_leo_source_file (self):

    '''Return True if this is one of Leo's source files.'''

    c = self.c

    table = (z.lower() for z in (
        'leoDocs.leo',
        'LeoGui.leo',       'LeoGuiPluginsRef.leo',
        'leoPlugins.leo',   'leoPluginsRef.leo',
        'leoPy.leo',        'leoPyRef.leo',
        'myLeoSettings.leo', 'leoSettings.leo',
        'ekr.leo',
        # 'test.leo',
    ))

    return c.shortFileName().lower() in table
</t>
<t tx="ekr.20110509064011.14556">def attr_matches(self,s,namespace):

    """Compute matches when string s is of the form name.name....name.

    Evaluates s using eval(s,namespace) 

    Assuming the text is of the form NAME.NAME....[NAME], and is evaluatable in
    the namespace, it will be evaluated and its attributes (as revealed by
    dir()) are used as possible completions.

    For class instances, class members are are also considered.)

    **Warning**: this can still invoke arbitrary C code, if an object
    with a __getattr__ hook is evaluated.

    """

    trace = False and not g.unitTesting
    verbose = False

    # Seems to work great. Catches things like ''.&lt;tab&gt;
    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$",s)
    if not m:
        return []

    expr,attr = m.group(1,3)

    try:
        safe_expr = self.strip_brackets(expr)
        obj = eval(safe_expr,namespace)
    except Exception:
        return []

    # Build the result.
    words = dir(obj)
    n = len(attr)
    result = ["%s.%s" % (expr,w) for w in words if w[:n] == attr]

    if trace:
        if verbose:
            g.trace(s,result)
        else:
            g.trace(repr(s))
    return result
</t>
<t tx="ekr.20110509064011.14557">def get_leo_completions(self,prefix):

    '''Return completions in an environment defining c, g and p.'''

    trace = False and not g.unitTesting
    verbose = False

    aList = []
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        if trace: g.trace(list(d.keys()))
        aList.extend(self.attr_matches(prefix,d))
    
    aList.sort()

    if trace:
        if verbose:
            g.trace('prefix',repr(prefix),'aList...\n',g.listToString(aList))
        else:
            g.trace('len(aList): %3s, prefix: %s' % (len(aList),repr(prefix)))

    return aList
</t>
<t tx="ekr.20110509064011.14561">def get_autocompleter_prefix (self):

    trace = False and not g.unitTesting

    # Only the body pane supports auto-completion.
    w = self.c.frame.body
    s = w.getAllText()
    if not s: return ''
    i = w.getInsertPoint() - 1
    i1 = i = j = max(0,i)
    while i &gt;= 0 and (s[i].isalnum() or s[i] in '._'):
        i -= 1
    i += 1
    j += 1
    prefix = s[i:j]
    if trace: g.trace(repr(prefix),'ins',s[i1:])
    return prefix
</t>
<t tx="ekr.20110510071925.14586">def init_qcompleter (self,event=None):

    trace = False and not g.unitTesting

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)

    if trace: g.trace('prefix: %s, len(options): %s' % (repr(prefix),len(options)))

    w = self.c.frame.body.bodyCtrl.widget
        # A LeoQTextBrowser.  May be none for unit tests.

    if w and options:
        self.qw = w
        self.qcompleter = w.init_completer(options)
        self.auto_completer_state_handler(event)
    else:
        if not g.unitTesting:
            g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110510120621.14539">def get_codewise_completions(self,prefix):

    '''Use codewise to generate a list of hits.'''

    trace = False and not g.unitTesting
    c = self.c

    m = re.match(r"(\S+(\.\w+)*)\.(\w*)$", prefix)
    if m:
        varname = m.group(1)
        ivar = m.group(3)
        kind,aList = self.guess_class(c,varname)
    else:
        kind,aList = 'none',[]
        varname,ivar = None,None

    if aList:
        if kind == 'class':
            hits = self.lookup_methods(aList,ivar)
            hits.extend(self.codewiseSelfList)
        elif kind == 'module':
            hits = self.lookup_modules(aList,ivar)
    else:
        aList2 = prefix.split('.')
        if aList2:
            func = aList2[-1]
            hits = self.lookup_functions(func)
        else:
            hits = []

    if 1: # A kludge: add the prefix to each hit.
        hits = ['%s.%s' % (varname,z) for z in hits]

    if trace:
        g.trace('kind',kind,'varname',varname,'ivar',ivar,'prefix',prefix)
        # g.trace('prefix',prefix,'kind',kind,'varname',varname,'ivar',ivar,'len(hits)',len(hits))
        # g.trace('hits[:10]',g.listToString(hits[:10],sort=False))

    return hits
</t>
<t tx="ekr.20110510120621.14540">def clean (self,hits):

    '''Clean up hits, a list of ctags patterns, for use in completion lists.'''

    trace = False and not g.unitTesting

    # Just take the function name: ignore the signature &amp; file.
    aList = list(set([z[0] for z in hits]))
    aList.sort()

    if trace:
        # g.trace('hits[:50]',g.listToString(hits[:50],sort=False))
        g.trace('aList[:50]',g.listToString(aList[:50],sort=False))

    return aList
</t>
<t tx="ekr.20110510120621.14542">def guess_class(self,c,varname):

    '''Return kind, class_list'''

    # if varname == 'g':
        # return 'module',['leoGlobals']
    if varname == 'p':
        return 'class',['position']
    if varname == 'c':
        return 'class',['Commands']
    if varname == 'self':
        # Return the nearest enclosing class.
        for p in c.p.parents():
            h = p.h
            # pylint: disable=anomalous-backslash-in-string
            m = re.search('class\s+(\w+)', h)
            if m:
                return 'class',[m.group(1)]
    if 1:
        aList = []
    else:
        # This is not needed now that we add the completions for 'self'.
        aList = ContextSniffer().get_classes(c.p.b,varname)

    return 'class',aList
</t>
<t tx="ekr.20110510120621.14543">def lookup_functions(self,prefix):

    aList = codewise.cmd_functions([prefix])
    hits = [z.split(None,1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_methods(self,aList,prefix): # prefix not used, only aList[0] used.

    aList = codewise.cmd_members([aList[0]])
    hits = [z.split(None,1) for z in aList if z.strip()]
    return self.clean(hits)

def lookup_modules (self,aList,prefix): # prefix not used, only aList[0] used.

    aList = codewise.cmd_functions([aList[0]])
    hits = [z.split(None,1) for z in aList if z.strip()]
    return self.clean(hits)
</t>
<t tx="ekr.20110510133719.14548">def do_qcompleter_tab(self,prefix,options):

    '''Return the longest common prefix of all the options.'''

    trace = False and not g.unitTesting

    matches,common_prefix = g.itemsMatchingPrefixInList(
        prefix,options,matchEmptyPrefix=False)

    if trace: g.trace(repr(common_prefix))

    return common_prefix
</t>
<t tx="ekr.20110511133940.14552">def init_tabcompleter (self,event=None):

    # Compute the prefix and the list of options.
    prefix = self.get_autocompleter_prefix()
    options = self.get_completions(prefix)
    if options:
        self.clearTabName() # Creates the tabbed pane.
        self.auto_completer_state_handler(event)
    else:
        g.warning('No completions')
        self.exit()
</t>
<t tx="ekr.20110511133940.14561">def show_completion_list (self,common_prefix,prefix,tabList):

    c = self.c

    aList = common_prefix.split('.')
    header = '.'.join(aList[:-1])

    # g.trace(self.use_qcompleter,len(tabList))

    if self.verbose or self.use_qcompleter or len(tabList) &lt; 20:
        tabList = self.clean_completion_list(header,tabList,)
    else:
        tabList = self.get_summary_list(header,tabList)

    if self.use_qcompleter:
        # Put the completions in the QListView.
        if self.qw:
            self.qw.show_completions(tabList)
    else:
        # Update the tab name, creating the tab if necessary.
        c.widgetWantsFocus(self.w)
        c.frame.log.clearTab(self.tabName)
        self.beginTabName(header+'.' if header else '')
        s = '\n'.join(tabList)
        self.put('',s,tabName=self.tabName)
</t>
<t tx="ekr.20110512090917.14466">def get_leo_namespace (self,prefix):
    '''
    Return an environment in which to evaluate prefix.
    Add some common standard library modules as needed.
    '''
    trace = False and not g.unitTesting
    k = self.k
    d = {'c':k.c, 'p':k.c.p, 'g':g}
    aList = prefix.split('.')
    if len(aList) &gt; 1:
        name = aList[0]
        m = sys.modules.get(name)
        if m:
            d[name]= m
    if trace:
        g.trace('prefix',prefix,'aList',aList)
        for key in sorted(d.keys()):
            g.trace(key,d.get(key))
    return d
</t>
<t tx="ekr.20110512090917.14468">def calltip_fail(self,prefix):

    '''Evaluation of prefix failed.'''

    trace = False and not g.unitTesting

    if trace:
        g.es('eval failed for "%s"' % repr(prefix))

    self.insert_string('(')
</t>
<t tx="ekr.20110512090917.14469">def calltip_success(self,prefix,obj):

    trace = False and not g.unitTesting

    try:
        # Get the parenthesized argument list.
        s1,s2,s3,s4 = inspect.getargspec(obj)
        s = inspect.formatargspec(s1,s2,s3,s4)
        if trace: g.trace(obj,repr(s))
    except Exception:
        if trace: g.trace('inspect failed. obj: %s' % (obj))
        self.insert_string('(')
        return

    # Clean s and insert it: don't include the opening "(".
    if g.match(s,1,'self,'):
        s = s[6:].strip()
    elif g.match_word(s,1,'self'):
        s = s[5:].strip()
    else:
        s = s[1:].strip()

    self.insert_string("(",select=False)
    self.insert_string(s,select=True)
</t>
<t tx="ekr.20110512170111.14471">def strip_brackets(self,s):

    '''Return s with all brackets removed.

    This (mostly) ensures that eval will not execute function calls, etc.
    '''

    for ch in '[]{}()':
        s = s.replace(ch,'')

    return s
</t>
<t tx="ekr.20110512170111.14472">def get_object (self):

    '''Return the object corresponding to the current prefix.'''

    trace = False and not g.unitTesting

    common_prefix,prefix1,aList = self.compute_completion_list()

    if len(aList) == 0:
        if trace: g.trace('no completion list for: %s' % (prefix1))
        return None,prefix1
    elif len(aList) == 1:
        prefix = aList[0]
    else:
        prefix = common_prefix

    if trace: g.trace(repr(prefix))

    safe_prefix = self.strip_brackets(prefix)
    for d in self.namespaces + [self.get_leo_namespace(prefix)]:
        try:
            obj = eval(safe_prefix,d)
            break  # only reached if none of the exceptions below occur
        except AttributeError:
            obj = None
        except NameError:
            obj = None
        except SyntaxError:
            obj = None
        except Exception:
            g.es_exception()
            obj = None

    return obj,prefix
</t>
<t tx="ekr.20110512212836.14469">def exit (self):

    trace = False and not g.unitTesting
    if trace: g.trace(g.callers())

    c = self.c
    w = self.w or c.frame.body.bodyCtrl

    if trace: g.trace(g.callers())

    c.k.keyboardQuit()

    if self.use_qcompleter:
        if self.qw:
            self.qw.end_completer()
            self.qw = None # Bug fix: 2013/09/24.
    else:
        for name in (self.tabName,'Modules','Info'):
            c.frame.log.deleteTab(name)

    # Restore the selection range that may have been destroyed by changing tabs.
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    w.setSelectionRange(i,j,insert=j)

    # Was in finish.
    c.frame.body.onBodyChanged('Typing')
    c.recolor()

finish = exit
abort = exit
</t>
<t tx="ekr.20110512212836.14471">def get_completions(self,prefix):

    trace = False and not g.unitTesting
    verbose = False # True: report hits and misses.  False: report misses.
    d = self.completionsDict

    # Precompute the codewise completions for '.self'.
    if not self.codewiseSelfList:
        aList = self.get_codewise_completions('self.')
        self.codewiseSelfList = [z[5:] for z in aList]
        d ['self.'] = self.codewiseSelfList

    # Use the cached list if it exists.
    aList = d.get(prefix)
    if aList:
        if trace and verbose: g.trace('**cache hit: %s' % (prefix))
        return aList

    # elif self.use_codewise:
        # aList = self.get_codewise_completions(prefix)
    # else:
        # aList = self.get_leo_completions(prefix)

    # Always try the Leo completions first.
    # Fall back to the codewise completions.
    aList = (
        self.get_leo_completions(prefix) or
        self.get_codewise_completions(prefix)
    )

    if trace: g.trace('**cash miss: %s' % (prefix))
    d [prefix] = aList
    return aList
</t>
<t tx="ekr.20110512232915.14481">def clean_for_display(self,hits):

    '''Clean up hits, a list of ctags patterns, for display purposes.'''

    trace = False and not g.unitTesting
    aList = []
    for h in hits:
        s = h[0]
        # Display oriented: no good for completion list.
        fn = h[1].strip()
        if fn.startswith('/'):
            sig = fn[2:-4].strip()
        else:
            sig = fn
        aList.append('%s: %s' % (s,sig))

    aList = list(set(aList))
    aList.sort()
    if trace:
        # g.trace('hits[:50]',g.listToString(hits[:50],sort=False))
        g.trace('aList[:50]',g.listToString(aList[:50],sort=False))
    return aList
</t>
<t tx="ekr.20110513104728.14453">def clean_completion_list(self,header,tabList):

    '''Return aList with header removed from the start of each list item.'''

    return [
        z[len(header)+1:] if z.startswith(header) else z
            for z in tabList]
</t>
<t tx="ekr.20110513104728.14454">def get_summary_list (self,header,tabList):

    '''Show the possible starting letters,
    but only if there are more than one.
    '''

    d = {}
    for z in tabList:
        tail = z and z[len(header):] or ''
        if tail.startswith('.'): tail = tail[1:]
        ch = tail and tail[0] or ''
        if ch:
            n = d.get(ch,0)
            d[ch] = n + 1
    aList = ['%s %d' % (ch,d.get(ch)) for ch in sorted(d)]
    if len(aList) &gt; 1:
        tabList = aList
    else:
        tabList = self.clean_completion_list(header,tabList)
    return tabList
</t>
<t tx="ekr.20110514051607.14524">def get_cached_options(self,prefix):

    trace = False and not g.unitTesting
    d = self.completionsDict

    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)

    while i &gt; 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            if trace: g.trace('== period: %s' % (key))
            return key,[]
        options = d.get(key)
        if options:
            if trace: g.trace('== hit: %s len: %s' % (
                key,len(options)))
            return key,options
        else:
            if trace: g.trace('== miss: %s' % (key))

    return None,[]
</t>
<t tx="ekr.20110527105255.18386">def setUa (self,event):

    '''Prompt for the name and value of a uA, then set the uA in the present node.'''

    c,k = self.c,self.k
    tag = 'set-ua' ; state = k.getState(tag)
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Set uA: ')
            k.getArg(event,tag,1,self.setUa)
    elif state == 1:
        self.uaName = k.arg
        s = 'Set uA: %s To: ' % (self.uaName)
        k.setLabelBlue(s)
        k.getArg(event,tag,2,self.setUa,completion=False)
    else:
        assert state == 2,state
        val = k.arg
        d = c.p.v.u
        d[self.uaName] = val
        self.printUas()
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
</t>
<t tx="ekr.20110530082209.18248">def replaceCurrentCharacter (self,event):

    '''Replace the current character with the next character typed.'''

    k = self.k ; tag = 'replace-current-character'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if w:
            k.setLabelBlue('Replace Character: ')
            k.getArg(event,tag,1,self.replaceCurrentCharacter)
    else:
        w = self.w
        ch = k.arg
        if ch:
            i,j = w.getSelectionRange()
            if i &gt; j: i,j = j,i
            # Use raw insert/delete to retain the coloring.
            if i == j:
                i = max(0,i-1)
                w.delete(i)
            else:
                w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.</t>
<t tx="ekr.20110605121601.18695"></t>
<t tx="ekr.20110606004638.16929">def stroke2char (self,stroke):
    '''
    Convert a stroke to an (insertable) char.
    This method allows Leo to use strokes everywhere.
    '''
    trace = False and not g.unitTesting
    k = self
    if not stroke: return ''
    s = stroke.s if g.isStroke(stroke) else stroke
    # Allow bare angle brackets for unit tests.
    if s.startswith('&lt;') and s.endswith('&gt;'):
        s = s[1:-1]
    if len(s) == 0: return ''
    if len(s) == 1: return s
    for z in ('Alt','Ctrl','Command','Meta'):
        if s.find(z) != -1:            
            return ''
            # This is not accurate: LeoQtEventFilter retains
            # the spelling of Alt-Ctrl keys because of the
            # @bool enable_alt_ctrl_bindings setting.
    # Special case the gang of four, plus 'Escape',
    d = {
        'BackSpace':'\b',
        'Escape':'Escape',
        'Linefeed':'\r',
        'Return':'\n',
        'Tab':'\t',
    }
    ch = d.get(s)
    if ch: return ch
    # First, do the common translations.
    ch = k.guiBindNamesInverseDict.get(s)
    if ch:
        if trace: g.trace(repr(stroke),repr(ch))
        return ch
    # A much-simplified form of code in k.strokeFromSetting.
    shift = s.find('Shift+') &gt; -1 or s.find('Shift-') &gt; -1
    s = s.replace('Shift+','').replace('Shift-','')
    last = s #  Everything should have been stripped.
    if len(s) == 1 and s.isalpha():
        if shift:
            s = last.upper()
        else:
            s = last.lower()
    val = s if len(s)==1 else ''
    if trace: g.trace(repr(stroke),repr(val)) # 'shift',shift,
    return val
</t>
<t tx="ekr.20110608135633.16553">def renameChapterByName (self,newName):

    cc,c,d,tt = self,self.c,self.chaptersDict,self.tt
    chapter = cc.selectedChapter
    oldName = chapter.name
    del d [oldName]
    d [newName] = chapter
    chapter.name = newName
    root = cc.findChapterNode(oldName)
    if root:
        root.initHeadString('@chapter %s' % newName)
        if tt:
            try:
                tt.lockout = True
                tt.destroyTab(oldName)
                tt.createTab(newName)
                tt.setTabLabel(newName)
            finally:
                tt.lockout = False
        cc.selectChapterByName(newName) # Necessary.
        # cc.note('renamed "%s" to "%s"' % (oldName,newName))
    else:
        cc.note('no @chapter %s' % (oldName))
</t>
<t tx="ekr.20110609161752.16459">def setLossage (self,ch,stroke):

    trace = False and not g.unitTesting
    # k = self
    if trace: g.trace(repr(stroke),g.callers())
    if ch or stroke:
        if len(g.app.lossage) &gt; 99:
            g.app.lossage.pop()
    # This looks like a memory leak, but isn't.
    g.app.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20120130074511.10227">def kill_one_shortcut (self,stroke):

    '''Update the dicts so that c.config.getShortcut(name) will return None
    for all names *presently* bound to the stroke.'''

    k = self ; c = k.c
    lm = g.app.loadManager
    # A crucial shortcut: inverting and uninverting dictionaries is slow.
    # Important: the comparison is valid regardless of the type of stroke.
    if stroke in (None,'None','none'):
        return
    assert g.isStroke(stroke),stroke
    d = c.config.shortcutsDict
    if d is None:
        d = g.TypedDictOfLists(
            name='empty shortcuts dict',
            keyType=type('commandName'),
            valType=g.ShortcutInfo)
    inv_d = lm.invert(d)
    # aList = inv_d.get(stroke,[])
    inv_d[stroke] = []
    c.config.shortcutsDict = lm.uninvert(inv_d)
</t>
<t tx="ekr.20120130074511.10228">def check_bind_key(self,commandName,pane,shortcut):

     #k = self
    if not shortcut:
        return False
    assert g.isStroke(shortcut)

    # Give warning and return if we try to bind to Enter or Leave.
    for s in ('enter','leave'):
        if shortcut.lower().find(s) &gt; -1:
            g.warning('ignoring invalid key binding:','%s = %s' % (
                commandName,shortcut))
            return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    else:
        return True
</t>
<t tx="ekr.20120208064440.10148">class ModeController:

    def __init__ (self,c):
        self.c = c
        self.d = {} # Keys are command names, values are modes.
        self.k = c.k
        g.trace(self)

    def __repr__(self):
        return '&lt;ModeController %s&gt;' % self.c.shortFileName()

    __str__ = __repr__

    @others
</t>
<t tx="ekr.20120208064440.10150">class ModeInfo:

    def __repr__(self):
        return '&lt;ModeInfo %s&gt;' % self.name

    __str__ = __repr__

    @others

</t>
<t tx="ekr.20120208064440.10152">def computeModeName (self,name):

    s = name.strip().lower()
    j = s.find(' ')
    if j &gt; -1: s = s[:j]
    if s.endswith('mode'):
        s = s[:-4].strip()
    if s.endswith('-'):
        s = s[:-1]

    i = s.find('::')
    if i &gt; -1:
        # The actual mode name is everything up to the "::"
        # The prompt is everything after the prompt.
        s = s[:i]

    return s + '-mode'
</t>
<t tx="ekr.20120208064440.10153">def init (self,name,dataList):

    '''aList is a list of tuples (commandName,si).'''

    trace = False and not g.unitTesting
    c,d,k,modeName = self.c,self.d,self.c.k,self.name
    for name,si in dataList:

        assert g.isShortcutInfo(si),si
        if not name:
            if trace: g.trace('entry command',si)
            #### An entry command: put it in the special *entry-commands* key.
            #### d.add('*entry-commands*',si)
            self.entryCommands.append(si)
        elif si is not None:
            # A regular shortcut.
            si.pane = modeName
            aList = d.get(name,[])
            for z in aList:
                assert g.isShortcutInfo(z),z
            # Important: use previous bindings if possible.
            key2,aList2 = c.config.getShortcut(name)
            for z in aList2:
                assert g.isShortcutInfo(z),z
            aList3 = [z for z in aList2 if z.pane != modeName]
            if aList3:
                if trace: g.trace('inheriting',[si.val for si in aList3])
                aList.extend(aList3)
            aList.append(si)
            d[name] = aList
</t>
<t tx="ekr.20120208064440.10156">def computeModePrompt (self,name):

    assert name == self.name
    s = 'enter-' + name.replace(' ','-')
    i = s.find('::')
    if i &gt; -1:
        # The prompt is everything after the '::'
        prompt = s[i+2:].strip()
    else:
        prompt = s

    return prompt
</t>
<t tx="ekr.20120208064440.10158">def initMode (self):

    trace = False and not g.unitTesting
    c,k = self.c,self.c.k
    k.inputModeName = self.name
    k.silentMode = False
    for si in self.entryCommands:
        assert g.isShortcutInfo(si),si
        commandName = si.commandName
        if trace: g.trace('entry command:',commandName)
        k.simulateCommand(commandName)
        # Careful, the command can kill the commander.
        if g.app.quitting or not c.exists: return
        # New in Leo 4.5: a startup command can immediately transfer to another mode.
        if commandName.startswith('enter-'):
            if trace: g.trace('redirect to mode',commandName)
            return
    # Create bindings after we know whether we are in silent mode.
    w = k.modeWidget if k.silentMode else k.w
    k.createModeBindings(self.name,self.d,w)
    k.showStateAndMode(prompt=self.name)
</t>
<t tx="ekr.20120208064440.10160">### k.createModeBindings is used instead????

def createModeBindings (self,w):

    '''Create mode bindings for w, a text widget.'''

    trace = False and not g.unitTesting
    c,d,k,modeName = self.c,self.d,self.k,self.name
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if not func:
            g.es_print('no such command: %s Referenced from %s' % (
                commandName,modeName))
            continue
        aList = d.get(commandName,[])
        for si in aList:
            assert g.isShortcutInfo(si),si
            if trace: g.trace(si)
            stroke = si.stroke
            # Important: si.val is canonicalized.
            if stroke and stroke not in ('None','none',None):
                if trace:
                    g.trace(
                        g.app.gui.widget_name(w), modeName,
                        '%10s' % (stroke),
                        '%20s' % (commandName),
                        si.nextMode)

                assert g.isStroke(stroke)
                k.makeMasterGuiBinding(stroke)

                # Create the entry for the mode in k.masterBindingsDict.
                # Important: this is similar, but not the same as k.bindKeyToDict.
                # Thus, we should **not** call k.bindKey here!
                d2 = k.masterBindingsDict.get(modeName,{})
                d2 [stroke] = g.ShortcutInfo(
                    kind = 'mode&lt;%s&gt;' % (modeName), # 2012/01/23
                    commandName=commandName,
                    func=func,
                    nextMode=si.nextMode,
                    stroke=stroke)
                k.masterBindingsDict[modeName] = d2
                if trace: g.trace(modeName,d2)
</t>
<t tx="ekr.20120208064440.10161">def addModeCommands(self):

    g.trace(self,self.d)

    for mode in self.d.values():
        mode.createModeCommand()
</t>
<t tx="ekr.20120208064440.10163">def getMode (self,modeName):

    g.trace(self)

    mode = self.d.get(modeName)
    g.trace(modeName,mode)
    return mode

</t>
<t tx="ekr.20120208064440.10164">def makeMode (self,name,aList):


    mode = ModeInfo(self.c,name,aList)

    g.trace(self,mode.name,mode)
    self.d[mode.name] = mode

</t>
<t tx="ekr.20120208064440.10179">def endMode(self):

    k = self ; c = k.c

    w = g.app.gui.get_focus(c)
    if w:
        c.frame.log.deleteTab('Mode') # Changes focus to the body pane

    k.endCommand(k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    k.showStateAndMode() # Restores focus.

    if w:
        c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20120208064440.10180">def enterMode (self):

    g.trace('(ModeInfo)')

    c,k = self.c,self.k
    c.inCommand = False
        # Allow inner commands in the mode.
    event=None ###
    k.generalModeHandler(event,modeName=self.name)
</t>
<t tx="ekr.20120208064440.10190"></t>
<t tx="ekr.20120208064440.10193">def __init__ (self,c,name,aList):

    g.trace(name,aList)

    self.c = c
    self.d = {} # The bindings in effect for this mode.
        # Keys are names of (valid) command names, values are ShortcutInfo objects.
    self.entryCommands = []
        # A list of ShortcutInfo objects.
    self.k = c.k
    self.name = self.computeModeName(name)
    self.prompt = self.computeModePrompt(self.name)

    self.init(name,aList)
</t>
<t tx="ekr.20120208064440.10195">def createModeCommand (self):

    g.trace(self)

    c,k = self.c,self.k
    key = 'enter-' + self.name.replace(' ','-')

    def enterModeCallback (event=None,self=self):
        self.enterMode()

    c.commandsDict[key] = f = enterModeCallback
    k.inverseCommandsDict [f.__name__] = key

    g.trace('(ModeInfo)',f.__name__,key,
        'len(c.commandsDict.keys())',len(list(c.commandsDict.keys())))
</t>
<t tx="ekr.20120208064440.10199">def generalModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting

    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
</t>
<t tx="ekr.20120208064440.10201">def NEWgeneralModeHandler (self,event,
    commandName=None,func=None,modeName=None,nextMode=None,prompt=None):

    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    trace = (False or g.trace_modes) and not g.unitTesting
    if trace: g.trace(modeName,'state',state)

    if state == 0:
        k.inputModeName = modeName
        k.modePrompt = prompt or modeName
        k.modeWidget = event and event.widget
        k.setState(modeName,1,handler=k.generalModeHandler)
        self.initMode(event,modeName)
        # Careful: k.initMode can execute commands that will destroy a commander.
        if g.app.quitting or not c.exists: return
        if not k.silentMode:
            if c.config.getBool('showHelpWhenEnteringModes'):
                k.modeHelp(event)
            else:
                c.frame.log.hideTab('Mode')
    elif not func:
        g.trace('No func: improper key binding')
    else:
        if commandName == 'mode-help':
            func(event)
        else:
            self.endMode()
            if trace or c.config.getBool('trace_doCommand'): g.trace(func.__name__)
            # New in 4.4.1 b1: pass an event describing the original widget.
            if event:
                event.w = event.widget = k.modeWidget
            else:
                event = g.app.gui.create_key_event(c,None,None,k.modeWidget)
            if trace: g.trace(modeName,'state',state,commandName,'nextMode',nextMode)
            func(event)
            if g.app.quitting or not c.exists:
                pass
            elif nextMode in (None,'none'):
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                silent = k.silentMode
                k.setState(modeName,1,handler=k.generalModeHandler)
                self.reinitMode(modeName) # Re-enter this mode.
                k.silentMode = silent
            else:
                k.silentMode = False # All silent modes must do --&gt; set-silent-mode.
                self.initMode(event,nextMode) # Enter another mode.
                # Careful: k.initMode can execute commands that will destroy a commander.
                # if g.app.quitting or not c.exists: return
</t>
<t tx="ekr.20120217070122.10479">def defineSettingsIvars(self):

    # Part 1: These were in the ctor.
    c = self.c
    getBool  = c.config.getBool
    getColor = c.config.getColor
    self.enable_autocompleter           = getBool('enable_autocompleter_initially')
    self.enable_calltips                = getBool('enable_calltips_initially')
    self.ignore_caps_lock               = getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = getBool('ignore_unbound_non_ascii_keys')
    self.minibuffer_background_color    = getColor('minibuffer_background_color') or 'lightblue'
    self.minibuffer_foreground_color    = getColor('minibuffer_foreground_color') or 'black'
    self.minibuffer_warning_color       = getColor('minibuffer_warning_color') or 'lightgrey'
    self.minibuffer_error_color         = getColor('minibuffer_error_color') or 'red'
    self.swap_mac_keys                  = getBool('swap_mac_keys')

    self.warn_about_redefined_shortcuts = getBool('warn_about_redefined_shortcuts')
    # Has to be disabled (default) for AltGr support on Windows
    self.enable_alt_ctrl_bindings       = c.config.getBool('enable_alt_ctrl_bindings')

    # Part 2: These were in finishCreate.

    # Set mode colors used by k.setInputState.
    bg = c.config.getColor('body_text_background_color') or 'white'
    fg = c.config.getColor('body_text_foreground_color') or 'black'

    self.command_mode_bg_color    = getColor('command_mode_bg_color') or bg
    self.command_mode_fg_color    = getColor('command_mode_fg_color') or fg
    self.insert_mode_bg_color     = getColor('insert_mode_bg_color') or bg
    self.insert_mode_fg_color     = getColor('insert_mode_fg_color') or fg
    self.overwrite_mode_bg_color  = getColor('overwrite_mode_bg_color') or bg
    self.overwrite_mode_fg_color  = getColor('overwrite_mode_fg_color') or fg
    self.unselected_body_bg_color = getColor('unselected_body_bg_color') or bg
    self.unselected_body_fg_color = getColor('unselected_body_fg_color') or bg

    # g.trace(self.c.shortFileName())
</t>
<t tx="ekr.20120520174745.9867">def printButtons (self,event=None):

    '''Print all @button and @command commands, their bindings and their source.'''

    k = self ; c = k.c
    tabName = '@buttons &amp;&amp; @commands'
    c.frame.log.clearTab(tabName)

    def put(s):
        g.es('',s,tabName=tabName)

    data = []
    for aList in [c.config.getButtons(),c.config.getCommands()]:
        for z in aList:
            p,script = z
            c = p.v.context
            tag = 'M' if c.shortFileName().endswith('myLeoSettings.leo') else 'G'
            data.append((p.h,tag),)

    for aList in [g.app.config.atLocalButtonsList,g.app.config.atLocalCommandsList]:
        for p in aList:
            data.append((p.h,'L'),)

    result = ['%s %s' % (z[1],z[0]) for z in sorted(data)]
    put('\n'.join(result))

    legend = '''\

legend:
G leoSettings.leo
L local .leo File
M myLeoSettings.leo
'''
    legend = g.adjustTripleString(legend,c.tab_width)
    put(''.join(legend))
</t>
<t tx="ekr.20130920121326.11281">@nocolor-node
@

The big pictures of key bindings:
    
1. Code in leoKeys.py and in leoConfig.py converts user key settings to
   various Python **binding dictionaries** defined in leoKeys.py.
   
2. An instance of LeoQtEventFilter should be attached to all visible panes
   in Leo's main window. g.app.gui.setFilter does this.
   
3. LeoQtEventFilter.eventFilter calls k.masterKeyhandler for every
   keystroke. eventFilter passes only just the event argument to
   k.masterKeyHandler. The event arg gives both the widget in which the
   event occurs and the keystroke.
   
4. k.masterKeyHandler and its helpers use the event argument and the
   binding dictionaries to execute the Leo command (if any) associated with
   the incoming keystroke.
   
Important details:

1. g.app.gui.setFilter allows various traces and assertions to be made
   uniformly. The obj argument to setFilter is a QWidget object; the w
   argument to setFilter can be either the same as obj, or a Leo wrapper
   class the supports the HighLevelInterface protocol. **Important**: the
   types of obj and w are not actually all that important, as discussed
   next.
   
2. The logic in k.masterKeyHandler and its helpers is long and involved:

A. k.getPaneBinding associates a command with the incoming keystroke based
   on a) the widget's name and b) whether the widget is a text widget
   (which depends on the type of the widget).
   
   To do this, k.getPaneBinding uses a **binding priority table**. This
   table is defined within k.getPaneBinding itself. The table indicates
   which of several possible bindings should have priority. For instance,
   if the widget is a text widget, a user binding for a 'text' widget takes
   priority over a default key binding. Similarly, if the widget is Leo's
   tree widget, a 'tree' binding has top priority. There are many other
   details encapsulated in the table. The exactly details of the binding
   priority table are open to debate, but in practice the resulting
   bindings are as expeced.
   
B. If k.getPaneBinding finds a command associated with the incoming
   keystroke, k.masterKeyHandler calls k.masterCommand to execute the
   command. k.masterCommand handles many complex. See the source code for
   details.
   
C. If k.getPaneBinding fails to bind the incoming keystroke to a command,
   k.masterKeyHandler calls k.handleUnboundKeys to handle the keystroke.
   Depending on the widget, and settings, and the keystroke,
   k.handleUnboundKeys may do nothing, or it may call k.masterCommand to
   insert a plain key into the widget.
</t>
<t tx="ekr.20130924035029.12741">def initOneAbbrev (self,commandName,key):
    
    '''Enter key as an abbreviation for commandName in c.commandsDict.'''

    c,k = self.c,self
    if c.commandsDict.get(key):
        g.trace('ignoring duplicate abbrev: %s',key)
    else:
        func = c.commandsDict.get(commandName)
        if func:
            # g.trace(key,commandName,func.__name__)
            c.commandsDict [key] = func
            # k.inverseCommandsDict[func.__name__] = key
        else:
            g.warning('bad abbrev:',key,'unknown command name:',commandName)
</t>
<t tx="ekr.20131017100903.16689">def repeatComplexCommandHelper (self,event):

    k = self ; c = k.c
    char = event and event.char or ''
    if char in ('\n','Return') and k.mb_history:
        last = k.mb_history [0]
        k.resetLabel()
        k.clearState() # Bug fix.
        c.commandsDict [last](event)
    else:
        # g.trace('oops')
        return k.keyboardQuit()
</t>
<t tx="ekr.20131109170017.16504">@first # -*- coding: utf-8 -*-

'''Leo's vim emulator.'''

@language python
@tabwidth -4
@pagewidth 70

import leo.core.leoGlobals as g
import string

@others
</t>
<t tx="ekr.20131109170017.16507">def __init__(vc,c):
    '''The ctor for the VimCommands class.'''
    vc.c = c
    vc.k = c.k
    vc.init_constant_ivars()
    vc.init_dot_ivars()
    vc.init_persistent_ivars()
    vc.init_state_ivars()
    vc.create_dispatch_dicts()
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131111061547.16460">def create_normal_dispatch_d(vc):
    '''
    Return the dispatch dict for normal mode.
    Keys are strokes, values are methods.
    '''
    d = {
    # Vim hard-coded control characters...
    # 'Ctrl+r': vc.vim_ctrl_r,
    # Special chars: these are the Leo's official (tk) strokes.
    'asciicircum': vc.vim_caret,# '^'
    'asciitilde': None,         # '~'
    'asterisk': vc.vim_star,    # '*'
    'at': None,                 # '@'
    'bar': None,                # '|'
    'braceleft': None,          # '{'
    'braceright': None,         # '}'
    'bracketleft': None,        # '['
    'bracketright': None,       # ']'
    'colon': vc.vim_colon,      # ':'
    'comma': None,              # ','
    'dollar': vc.vim_dollar,    # '$'
    'greater': None,            # '&gt;'
    'less': None,               # '&lt;'
    'minus': None,              # '-'
    'numbersign': vc.vim_pound, # '#'
    'parenleft': None,          # '('
    'parenright': None,         # ')'
    'percent': None,            # '%'
    'period': vc.vim_dot,       # '.'
    'plus': None,               # '+'
    'question': vc.vim_question,# '?'
    'quotedbl': None,           # '"'
    'quoteleft': None,          # '`'
    'Return':vc.vim_return,     # '\n'
    'semicolon': None,          # ';'
    'slash': vc.vim_slash,      # '/'
    'underscore': None,         # '_'
    # Digits.
    '0': vc.vim_0,
    '1': vc.vim_digits,
    '2': vc.vim_digits,
    '3': vc.vim_digits,
    '4': vc.vim_digits,
    '5': vc.vim_digits,
    '6': vc.vim_digits,
    '7': vc.vim_digits,
    '8': vc.vim_digits,
    '9': vc.vim_digits,
    # Uppercase letters.
    'A': vc.vim_A,
    'B': None,
    'C': None,
    'D': None,
    'E': None,
    'F': vc.vim_F,
    'G': vc.vim_G,
    'H': None,
    'I': None,
    'J': None,
    'K': None,
    'L': None,
    'M': None,
    'N': None,
    'O': vc.vim_O,
    'P': vc.vim_P, # Paste *outline*
    'R': None,
    'S': None,
    'T': vc.vim_T,
    'U': None,
    'V': vc.vim_V,
    'W': None,
    'X': None,
    'Y': vc.vim_Y,
    'Z': None,
    # Lowercase letters...
    'a': vc.vim_a,
    'b': vc.vim_b,
    'c': vc.vim_c,
    'd': vc.vim_d,
    'e': vc.vim_e,
    'f': vc.vim_f,
    'g': vc.vim_g,
    'h': vc.vim_h,
    'i': vc.vim_i,
    'j': vc.vim_j,
    'k': vc.vim_k,
    'l': vc.vim_l,
    'm': vc.vim_m,
    'n': vc.vim_n,
    'o': vc.vim_o,
    'p': vc.vim_p,
    'q': vc.vim_q,
    'r': vc.vim_r,
    's': vc.vim_s,
    't': vc.vim_t,
    'u': vc.vim_u,
    'v': vc.vim_v,
    'w': vc.vim_w,
    'x': vc.vim_x,
    'y': vc.vim_y,
    'z': vc.vim_z,
    }
    return d
</t>
<t tx="ekr.20131111061547.16467"></t>
<t tx="ekr.20131111061547.16468">def vim_h(vc):
    '''Move the cursor left n chars, but not out of the present line.'''
    trace = False and not g.unitTesting
    if vc.is_text_widget(vc.w):
        w = vc.w
        s = w.getAllText()
        i = w.getInsertPoint()
        if i == 0 or (i &gt; 0 and s[i-1] == '\n'):
            if trace: g.trace('at line start')
        else:
            for z in range(vc.n1*vc.n):
                if i &gt; 0 and s[i-1] != '\n':
                    i -= 1
                if i == 0 or (i &gt; 0 and s[i-1] == '\n'):
                    break # Don't go past present line.
            if vc.state == 'visual':
                w.setSelectionRange(vc.vis_mode_i,i,insert=i)
            else:
                w.setInsertPoint(i)
        vc.done()
    elif vc.in_tree(vc.w):
        vc.do('contract-or-go-left')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20131111105746.16544">def vim_dot(vc):
    '''Repeat the last command.'''
    try:
        vc.in_dot = True
        # Copy the list so it can't change in the loop.
        for event in vc.dot_list[:]:
            # g.trace(vc.state,event)
            vc.do_key(event)
    finally:
        vc.in_dot = False
    vc.done()
</t>
<t tx="ekr.20131111171616.16497">def vim_m(vc):
    '''m&lt;a-zA-Z&gt; mark current position with mark.'''
    vc.not_ready()
    ### vc.accept(handler=vc.vim_m2)
    
def vim_m2(vc):
    g.trace(vc.stroke)
    vc.done()
</t>
<t tx="ekr.20131111171616.16498">def vim_d(vc):
    '''
    N dd      delete N lines
    d{motion} delete the text that is moved over with {motion}
    '''
    if vc.is_text_widget(vc.w):
        vc.n = 1
        vc.accept(handler=vc.vim_d2)
    else:
        vc.quit()
    
</t>
<t tx="ekr.20131113045621.16547">class VimCommands:
    '''A class that handles vim simulation in Leo.'''
    # pylint: disable=no-self-argument
    # The first argument is vc.
    @others
</t>
<t tx="ekr.20131117164142.16955">def startIncremental (self,event,commandName,forward,ignoreCase,regexp):

    c,k = self.c,self.k
    # None is a signal to get the option from the find tab.
    self.event = event
    self.isearch_forward = not self.reverse if forward is None else forward
    self.isearch_ignore_case = self.ignore_case if ignoreCase is None else ignoreCase
    self.isearch_regexp = self.pattern_match if regexp is None else regexp
    # Note: the word option can't be used with isearches!
    self.w = w = c.frame.body.bodyCtrl
    self.p1 = c.p.copy()
    self.sel1 = w.getSelectionRange(sort=False)
    i,j = self.sel1
    self.push(c.p,i,j,self.in_headline)
    self.inverseBindingDict = k.computeInverseBindingDict()
    self.iSearchStrokes = self.getStrokes(commandName)
    k.setLabelBlue('Isearch%s%s%s: ' % (
        '' if self.isearch_forward else ' Backward',
        ' Regexp' if self.isearch_regexp else '',
        ' NoCase' if self.isearch_ignore_case else '',
    ))
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20131117164142.17002">def setReplaceString (self,event):
    '''A state handler to get the replacement string.'''
    trace = False and not g.unitTesting
    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    prompt = 'Replace ' + 'Regex' if self.pattern_match else 'String'
    if trace: g.trace(state)
    if state == 0:
        # self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.setReplaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.setReplaceString,completion=False)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=self.changeAllFlag)
</t>
<t tx="ekr.20131117164142.17007">def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w:
        g.trace('no self.w')
        return
    k.setLabelBlue(prefix)
    self.addFindStringToLabel(protect=False)
    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscapeFlag = False # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True)
</t>
<t tx="ekr.20131121084830.16362"># Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140220134748.16614">def vim_a(vc):
    '''Append text after the cursor N times.'''
    if vc.in_tree(vc.w):
        c = vc.c
        c.bodyWantsFocusNow()
        vc.w = w = c.frame.body.bodyCtrl
    else:
        w = vc.w
    if vc.is_text_widget(w):
        vc.do('forward-char')
        vc.begin_insert_mode()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16617">def vim_j(vc):
    '''N j  Down n lines.'''
    if vc.is_text_widget(vc.w):
        for z in range(vc.n1*vc.n):
            if vc.state == 'visual':
                vc.do('next-line-extend-selection')
            else:
                vc.do('next-line')
        vc.done()
    elif vc.in_tree(vc.w):
        vc.do('goto-next-visible')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16618">def vim_b(vc):
    '''N words backward.'''
    if vc.is_text_widget(vc.w):
        for z in range(vc.n1*vc.n):
            if vc.state == 'visual':
                vc.do('back-word-extend-selection')
            else:
                vc.do('back-word')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16619">def vim_c(vc):
    '''
    N   cc        change N lines
    N   c{motion} change the text that is moved over with {motion}
    VIS c         change the highlighted text
    '''
    vc.not_ready()
    ### vc.accept(handler=vc.vim_c2)
    
def vim_c2(vc):
    if vc.is_text_widget(vc.w):
        g.trace(vc.stroke)
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16620">def vim_f(vc):
    '''move past the Nth occurrence of &lt;stroke&gt;.'''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_f2)
    else:
        vc.quit()

def vim_f2(vc):
    '''Handle f &lt;stroke&gt;'''
    trace = bool and not g.unitTesting
    if vc.is_text_widget(vc.w):
        ec = vc.c.editCommands
        w = vc.w
        s = w.getAllText()
        if s:
            i = i1 = w.getInsertPoint()
            match_i,n = None,vc.n1*vc.n
            while i &lt; len(s):
                if s[i] == vc.ch:
                    match_i,n = i,n-1
                    if n == 0: break
                elif s[i] == '\n' and not vc.cross_lines:
                    break
                i += 1
            if match_i is not None:
                for z in range(match_i-i1+1):
                    if vc.state == 'visual':
                        vc.do('forward-char-extend-selection')
                    else:
                        vc.do('forward-char')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16621">def vim_g(vc):
    '''
    N ge backward to the end of the Nth word
    N gg goto line N (default: first line), on the first non-blank character
      gv start highlighting on previous visual area
    '''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_g2)
    else:
        vc.quit()
    
def vim_g2(vc):
    
    if vc.is_text_widget(vc.w):
        event,w = vc.event,vc.w
        extend = vc.state == 'visual'
        s = w.getAllText()
        i = w.getInsertPoint()
        if vc.stroke == 'g':
            # Go to start of buffer.
            on_line = vc.on_same_line(s,0,i)
            if on_line and extend:
                vc.do('back-to-home-extend-selection')
            elif on_line:
                vc.do('back-to-home')
            elif extend:
                vc.do('beginning-of-buffer-extend-selection')
            else:
                vc.do('beginning-of-buffer')
            vc.done()
        elif vc.stroke == 'b':
            # go to beginning of line: like 0.
            if extend:
                vc.do('beginning-of-line-extend-selection')
            else:
                vc.do('beginning-of-line')
            vc.done()
        elif vc.stroke == 'e':
            # got to end of line: like $
            if vc.state == 'visual':
                vc.do('end-of-line-extend-selection')
            else:
                vc.do('end-of-line')
            vc.done()
        elif vc.stroke == 'h':
            # go home: like ^.
            if extend:
                vc.do('back-to-home-extend-selection')
            elif on_line:
                vc.do('back-to-home')
            vc.done()
        else:
            vc.ignore()
            vc.done()
    else:
        vc.quit()

</t>
<t tx="ekr.20140220134748.16622">def vim_p(vc):
    '''Paste after the cursor.'''
    if vc.in_tree(vc.w):
        vc.do('paste-node')
        vc.done()
    elif vc.is_text_widget(vc.w):
        vc.do('paste-text')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16623">def vim_q(vc):
    '''
    q       stop recording
    q&lt;A-Z&gt;  record typed characters, appended to register &lt;a-z&gt;
    q&lt;a-z&gt;  record typed characters into register &lt;a-z&gt;
    '''
    vc.not_ready()
    ### vc.accept(handler=vc.vim_q2)
    
def vim_q2(vc):
    g.trace(vc.stroke)
    letters = string.ascii_letters
    vc.done()


</t>
<t tx="ekr.20140220134748.16624">def vim_r(vc):
    '''Replace next N characters with &lt;char&gt;'''
    vc.not_ready()
    ### vc.accept(handler=vc.vim_r2)
    
def vim_r2(vc):
    g.trace(vc.n,vc.stroke)
    vc.done()
</t>
<t tx="ekr.20140220134748.16625">def vim_n(vc):
    '''Repeat last search N times.'''
    fc = vc.c.findCommands
    fc.setup_command()
    old_node_only = fc.node_only
    fc.node_only = True
    fc.findNext()
    vc.node_only = old_node_only
    vc.done()
</t>
<t tx="ekr.20140220134748.16626">def vim_u(vc):
    '''U undo the last command.'''
    vc.c.undoer.undo()
    vc.quit()
</t>
<t tx="ekr.20140220134748.16627">def vim_v(vc):
    '''Start visual mode.'''
    if vc.n1_seen:
        vc.ignore()
        # vc.beep('%sv not valid' % vc.n1)
        # vc.done()
    elif vc.is_text_widget(vc.w):
        vc.vis_mode_w = w = vc.w
        vc.vis_mode_i = w.getInsertPoint()
        vc.state = 'visual'
        # Save the dot list in case v terminates visual mode.
        vc.old_dot_list = vc.dot_list[:]
        vc.accept(add_to_dot=False,handler=vc.do_visual_mode)
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16629">def vim_x(vc):
    '''Delete N characters under and after the cursor.'''
    w = vc.w
    if vc.is_text_widget(w):
        for z in range(vc.n1*vc.n):
            # It's simplest just to get the text again.
            s = w.getAllText()
            i = w.getInsertPoint()
            if i &gt; 0:
                if vc.cross_lines or s[i-1] != '\n':
                    w.delete(i-1,i)
            else:
                break
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16630">def vim_y(vc):
    '''
    N   yy          yank N lines 
    N   y{motion}   yank the text moved over with {motion} 
    '''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_y2)
    elif vc.in_tree(vc.w):
        # Paste an outline.
        c = vc.c
        g.es('Yank outline: %s' % c.p.h)
        c.copyOutline()
        vc.done()
    else:
        vc.quit()
    
def vim_y2(vc):
    if vc.is_text_widget(vc.w):
        if vc.stroke == 'y':
            # Yank n lines.
            w = vc.w
            i1 = i = w.getInsertPoint()
            s = w.getAllText()
            for z in range(vc.n1*vc.n):
                i,j = g.getLine(s,i) 
                i = j + 1
            w.setSelectionRange(i1,j,insert=j)
            vc.c.frame.copyText(event=vc.event)
            w.setInsertPoint(i1)
            vc.done()
        else:
            vc.y_stroke = vc.stroke # A scratch var.
            vc.begin_motion(vc.vim_y3)
    else:
        vc.quit()
            
def vim_y3(vc):
    '''Complete the y command after the cursor has moved.'''
    # The motion is responsible for all repeat counts.
     # y2w doesn't extend to line.  y2j does.
    trace = False and not g.unitTesting
    if vc.is_text_widget(vc.w):
        extend_to_line = vc.y_stroke in ('jk')
        n = vc.n1*vc.n
        w = vc.w
        s = w.getAllText()
        i1,i2 = vc.motion_i,w.getInsertPoint()
        if i1 == i2:
            if trace: g.trace('no change')
        elif i1 &lt; i2:
            if extend_to_line:
                i2 = vc.to_eol(s,i2)
                if i2 &lt; len(s) and s[i2] == '\n':
                    i2 += 1
                if trace: g.trace('extend i2 to eol',i1,i2)
        else: # i1 &gt; i2
            i1,i2 = i2,i1
            if extend_to_line:
                i1 = vc.to_bol(s,i1)
                if trace: g.trace('extend i1 to bol',i1,i2)
        if i1 != i2:
            # g.trace(repr(s[i1:i2]))
            w.setSelectionRange(i1,i2,insert=i2)
            vc.c.frame.copyText(event=vc.event)
            w.setInsertPoint(vc.motion_i)
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140220134748.16631">def vim_z(vc):
    '''
    zb redraw current line at bottom of window
    zz redraw current line at center of window
    zt redraw current line at top of window
    '''
    vc.not_ready()
    ### vc.accept(handler=vc.vim_z2)

def vim_z2(vc):
    g.trace(vc.stroke)
    vc.done()
</t>
<t tx="ekr.20140221085636.16685">def do_key(vc,event):
    '''
    Handle the next key in vim mode:
    - Set vc.event, vc.w, vc.stroke and vc.ch for *all* handlers.
    - Call vc.handler.
    Return True if k.masterKeyHandler should handle this key.
    '''
    trace = False and not g.unitTesting
    vc.init_scanner_vars(event)
    if trace: g.trace('stroke: %s' % vc.stroke)
    vc.return_value = None
    if not vc.handle_specials():
        vc.handler()
    if vc.return_value not in (True,False):
        # It looks like no acceptance method has been called.
        vc.oops('bad return_value: %s %s %s' % (
            repr(vc.return_value),vc.state,vc.next_func))
        vc.done() # Sets vc.return_value to True.
    return vc.return_value
</t>
<t tx="ekr.20140221085636.16691">def vim_0(vc):
    '''Handle zero, either the '0' command or part of a repeat count.'''
    if vc.is_text_widget(vc.w):
        if vc.repeat_list:
            vc.vim_digits()
        else:
            if vc.state == 'visual':
                vc.do('beginning-of-line-extend-selection')
            else:
                vc.do('beginning-of-line')
            vc.done()
    elif vc.in_tree(vc.w):
        vc.do('goto-first-visible-node')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16615">def show_status(vc):
    '''Show vc.state and vc.command_list'''
    trace = False and not g.unitTesting
    k = vc.k
    vc.set_border()
    if k.state.kind:
        if trace: g.trace('*** in k.state ***',k.state.kind)
    elif False: ### vc.state == 'visual':
        s = '%8s:' % vc.state.capitalize()
        if trace: g.trace('(vimCommands)',s,g.callers())
        k.setLabelBlue(s) ### label=s,protect=True)
    else:
        state_s = vc.state.capitalize()
        command_s = vc.show_command()
        dot_s = vc.show_dot()
        # if vc.in_motion: state_s = state_s + '(in_motion)'
        if 1: # Don't show the dot:
            s = '%8s: %s' % (state_s,command_s)
        else:
            s = '%8s: %-5s dot: %s' % (state_s,command_s,dot_s)
        if trace: g.trace('(vimCommands)',s,g.callers(2))
        k.setLabelBlue(s) ### label=s,protect=True)
</t>
<t tx="ekr.20140222064735.16618">def vim_i(vc):
    '''Insert text before the cursor N times.'''
    if vc.in_tree(vc.w):
        c = vc.c
        c.bodyWantsFocusNow()
        vc.w = w = c.frame.body.bodyCtrl
    else:
        w = vc.w
    if vc.is_text_widget(w):
        vc.begin_insert_mode()
    else:
        vc.done()

</t>
<t tx="ekr.20140222064735.16619">def vim_o(vc):
    '''Open a new line below the current line N times.'''
    if vc.in_tree(vc.w):
        c = vc.c
        c.bodyWantsFocusNow()
        vc.w = w = c.frame.body.bodyCtrl
    else:
        w = vc.w
    if vc.is_text_widget(w):
        vc.do(['end-of-line','insert-newline'])
        vc.begin_insert_mode()
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16620">def vim_t(vc):
    '''Move before the Nth occurrence of &lt;char&gt; to the right.'''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_t2)
    else:
        vc.quit()
    
def vim_t2(vc):
    '''Handle t &lt;stroke&gt;'''
    if vc.is_text_widget(vc.w):
        ec = vc.c.editCommands
        w = vc.w
        s = w.getAllText()
        if s:
            i = i1 = w.getInsertPoint()
            match_i,n = None,vc.n1*vc.n
            while i &lt; len(s):
                if s[i] == vc.ch:
                    match_i,n = i,n-1
                    if n == 0: break
                elif s[i] == '\n' and not vc.cross_lines:
                    break
                i += 1
            if match_i is not None:
                for z in range(match_i-i1):
                    if vc.state == 'visual':
                        vc.do('forward-char-extend-selection')
                    else:
                        vc.do('forward-char')
        vc.done()
    else:
        vc.quit()

</t>
<t tx="ekr.20140222064735.16622">def vim_slash(vc):
    '''Begin a search.'''
    if vc.is_text_widget(vc.w):
        fc = vc.c.findCommands
        vc.search_stroke = vc.stroke # A scratch ivar for vc.update_dot_before_search.
        fc.reverse = False
        fc.openFindTab(vc.event)
        fc.ftm.clear_focus()
        old_node_only = fc.node_only
        fc.searchWithPresentOptions(vc.event)
            # This returns immediately, before the actual search.
            # leoFind.showSuccess calls vc.update_selection_after_search.
        fc.node_only = old_node_only
        fc.reverse = False
        vc.done(add_to_dot=False,set_dot=False)
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16623">def vim_e(vc):
    '''Forward to the end of the Nth word.'''
    if vc.is_text_widget(vc.w):
        for z in range(vc.n1*vc.n):
            if vc.state == 'visual':
                vc.do('forward-word-extend-selection')
            else:
                vc.do('forward-word')
        vc.done()
    elif vc.in_tree(vc.w):
        vc.do('goto-last-visible-node')
        vc.done()
    else:
        vc.quit()

</t>
<t tx="ekr.20140222064735.16624">def vim_w(vc):
    '''N words forward.'''
    if vc.is_text_widget(vc.w):
        for z in range(vc.n1*vc.n):
            if vc.state == 'visual':
                vc.do('forward-word-extend-selection')
            else:
                vc.do('forward-word')
        vc.done()
    else:
        vc.quit()
    
</t>
<t tx="ekr.20140222064735.16625">def vim_redo(vc):
    '''N Ctrl-R redo last N changes'''
    vc.not_ready()
</t>
<t tx="ekr.20140222064735.16626">def vim_s(vc):
    '''Change N characters'''
    vc.not_ready()
    ### vc.accept(handler=vc.vim_s2)
    
def vim_s2(vc):
    g.trace(vc.n,vc.stroke)
    vc.done()
</t>
<t tx="ekr.20140222064735.16627">def vim_l(vc):
    '''Move the cursor right vc.n chars, but not out of the present line.'''
    trace = False and not g.unitTesting
    if vc.is_text_widget(vc.w):
        w = vc.w
        s = w.getAllText()
        i = w.getInsertPoint()
        if i &gt;= len(s) or s[i] == '\n':
            if trace: g.trace('at line end')
        else:
            for z in range(vc.n1*vc.n):
                if i &lt; len(s) and s[i] != '\n':
                    i += 1
                if i &gt;= len(s) or s[i] == '\n':
                    break # Don't go past present line.
            if vc.state == 'visual':
                w.setSelectionRange(vc.vis_mode_i,i,insert=i)
            else:
                w.setInsertPoint(i)
        vc.done()
    elif vc.in_tree(vc.w):
        vc.do('expand-and-go-right')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16628">def vim_k(vc):
    '''Cursor up N lines.'''
    if vc.is_text_widget(vc.w):
        for z in range(vc.n1 * vc.n):
            if vc.state == 'visual':
                vc.do('previous-line-extend-selection')
            else:
                vc.do('previous-line')
        vc.done()
    elif vc.in_tree(vc.w):
        vc.do('goto-prev-visible')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16629">def vim_digits(vc):
    '''Handle a digit that starts an outer repeat count.'''
    vc.repeat_list = []
    vc.repeat_list.append(vc.stroke)
    vc.accept(handler=vc.vim_digits_2)
        
def vim_digits_2(vc):
    if vc.stroke in '0123456789':
        vc.repeat_list.append(vc.stroke)
        # g.trace('added',vc.stroke,vc.repeat_list)
        vc.accept(handler=vc.vim_digits_2)
    else:
        # Set vc.n1 before vc.n, so that inner motions won't repeat
        # until the end of vim mode.
        try:
            n = int(''.join(vc.repeat_list))
        except Exception:
            n = 1
        if vc.n1_seen:
            vc.n = n
        else:
            vc.n1_seen = True
            vc.n1 = n
        # Don't clear the repeat_list here.
        # The ending character may not be valid,
        if vc.in_motion:
            # Handle the stroke that ended the repeat count.
            vc.do_inner_motion(restart=True)
        else:
            # Restart the command.
            vc.do_normal_mode()
</t>
<t tx="ekr.20140222064735.16630">def create_vis_dispatch_d (vc):
    '''
    Create a dispatch dict for visual mode.
    Keys are strokes, values are methods.
    '''
    d = {
    'Return':vc.vim_return,
    'space': vc.vim_l,
    # Terminating commands...
    'Escape': vc.vis_escape,
    'J': vc.vis_J,
    'c': vc.vis_c,
    'd': vc.vis_d,
    'u': vc.vis_u,
    'v': vc.vis_v,
    'y': vc.vis_y,
    # Motions...
    '0': vc.vim_0,
    '1': vc.vim_digits,
    '2': vc.vim_digits,
    '3': vc.vim_digits,
    '4': vc.vim_digits,
    '5': vc.vim_digits,
    '6': vc.vim_digits,
    '7': vc.vim_digits,
    '8': vc.vim_digits,
    '9': vc.vim_digits,
    'F': vc.vim_F,
    'G': vc.vim_G,
    'T': vc.vim_T,
    'Y': vc.vim_Y,
    'asciicircum': vc.vim_caret,
    'b': vc.vim_b,
    'dollar': vc.vim_dollar,
    'e': vc.vim_e,
    'f': vc.vim_f,
    'g': vc.vim_g,
    'h': vc.vim_h,
    'j': vc.vim_j,
    'k': vc.vim_k,
    'l': vc.vim_l,
    'n': vc.vim_n,
    'question': vc.vim_question,
    'slash': vc.vim_slash,
    't': vc.vim_t,
    'V': vc.vim_V,
    'w': vc.vim_w,
    }
    return d
</t>
<t tx="ekr.20140222064735.16631">def done(vc,add_to_dot=True,return_value=True,set_dot=True,stroke=None):
    '''Complete a command, preserving text and optionally updating the dot.'''
    if vc.state == 'visual':
        vc.handler = vc.do_visual_mode
            # A major bug fix.
        if set_dot:
            stroke2 = stroke or vc.stroke if add_to_dot else None
            vc.compute_dot(stroke2)
        vc.command_list = []
        vc.show_status()
        vc.return_value = True
    else:
        if set_dot:
            stroke2 = stroke or vc.stroke if add_to_dot else None
            vc.compute_dot(stroke2)
        # Undoably preserve any changes to the body.
        vc.save_body()
        # Clear all state, enter normal mode &amp; show the status.
        if vc.in_motion:
            vc.next_func = None
            # Do *not* change vc.in_motion!
        else:
            vc.init_state_ivars()
        vc.show_status()
        vc.return_value = return_value
</t>
<t tx="ekr.20140222064735.16632">def vim_esc(vc):
    '''
    Handle Esc while accumulating a normal mode command.

    Esc terminates the a,A,i,o and O commands normally.
    Call vc.end_insert command to support repeat counts
    such as 5a&lt;lots of typing&gt;&lt;esc&gt;
    '''
    if vc.state == 'insert':
        vc.end_insert_mode()
    elif vc.state == 'visual':
        # Clear the selection and reset dot.
        vc.vis_v()
    else:
        # vc.done()
        vc.quit() # It's helpful to clear everything.
</t>
<t tx="ekr.20140222064735.16634"></t>
<t tx="ekr.20140222064735.16635">@nocolor-node
@

First:

    0               (motion) to first character in the line (also: &lt;Home&gt; key)
N   $               (motion) go to the last character in the line (N-1 lines lower) (also: &lt;End&gt; key)
    ^               (motion) go to first non-blank character in the line
N   ,               (motion) repeat the last "f", "F", "t", or "T" N times in opposite direction
N   ;               (motion) repeat the last "f", "F", "t", or "T" N times
N   /&lt;CR&gt;                       (motion) repeat last search, in the forward direction
N   /{pattern}[/[offset]]&lt;CR&gt;   (motion) search forward for the Nth occurrence of {pattern}
N   ?&lt;CR&gt;                       (motion) repeat last search, in the backward direction
N   ?{pattern}[?[offset]]&lt;CR&gt;   (motion) search backward for the Nth occurrence of {pattern}

Later or never:
    
N   CTRL-I          (motion) go to Nth newer position in jump list
N   CTRL-O          (motion) go to Nth older position in jump list
N   CTRL-T          (motion) Jump back from Nth older tag in tag list
    
N   +               (motion) down N lines, on the first non-blank character (also: CTRL-M and &lt;CR&gt;)
N   _               (motion) down N-1 lines, on the first non-blank character
N   -               (motion) up N lines, on the first non-blank character

N   (               (motion) N sentences backward
N   )               (motion) N sentences forward
N   {               (motion) N paragraphs backward
N   }               (motion) N paragraphs forward
N   |               (motion) to column N (default: 1)
    `"              (motion) go to the position when last editing this file
    '&lt;a-zA-Z0-9[]'"&lt;&gt;&gt;  (motion) same as `, but on the first non-blank in the line
    `&lt;              (motion) go to the start of the (previous) Visual area
    `&lt;0-9&gt;          (motion) go to the position where Vim was last exited
    `&lt;A-Z&gt;          (motion) go to mark &lt;A-Z&gt; in any file
    `&lt;a-z&gt;          (motion) go to mark &lt;a-z&gt; within current file
    `&gt;              (motion) go to the end of the (previous) Visual area
    `[              (motion) go to the start of the previously operated or put text
    `]              (motion) go to the end of the previously operated or put text
    ``              (motion) go to the position before the last jump

N   %       (motion) goto line N percentage down in the file.  N must be given, otherwise it is the % command.
    %       (motion) find the next brace, bracket, comment, or "#if"/ "#else"/"#endif" in this line and go to its match

N   #       (motion) search backward for the identifier under the cursor
N   *       (motion) search forward for the identifier under the cursor

N   [#      (motion) N times back to unclosed "#if" or "#else"
N   [(      (motion) N times back to unclosed '('
N   [*      (motion) N times back to start of comment "/*"
N   [[      (motion) N sections backward, at start of section
N   []      (motion) N sections backward, at end of section
N   [p      (motion?) like P, but adjust indent to current line
N   [{      (motion) N times back to unclosed '{'
N   ]#      (motion) N times forward to unclosed "#else" or "#endif"
N   ])      (motion) N times forward to unclosed ')'
N   ]*      (motion) N times forward to end of comment "*/"
N   ][      (motion) N sections forward, at end of section
N   ]]      (motion) N sections forward, at start of section
N   ]p      (motion?) like p, but adjust indent to current line
N   ]}      (motion) N times forward to unclosed '}'
</t>
<t tx="ekr.20140222064735.16647"># Terminating commands call vc.done().
</t>
<t tx="ekr.20140222064735.16654"></t>
<t tx="ekr.20140222064735.16655"></t>
<t tx="ekr.20140222064735.16656">def vis_c(vc):
    '''Change the highlighted text.'''
    vc.state = 'normal'
    vc.not_ready()
    ### vc.done(set_dot=True)
</t>
<t tx="ekr.20140222064735.16657">def vis_d(vc):
    '''Delete the highlighted text and terminate visual mode.'''
    w  = vc.vis_mode_w
    if vc.is_text_widget(w):
        i1 = vc.vis_mode_i
        i2 = w.getInsertPoint()
        w.delete(i1,i2)
        vc.state = 'normal'
        vc.done(set_dot=True)
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16658"></t>
<t tx="ekr.20140222064735.16659">def vis_u(vc):
    '''Make highlighted text lowercase.'''
    vc.state = 'normal'
    vc.not_ready()
    ### vc.done(set_dot=True)
</t>
<t tx="ekr.20140222064735.16660">def vis_y(vc):
    '''Yank the highlighted text.'''
    if vc.is_text_widget(vc.w):
        vc.c.frame.copyText(event=vc.event)
        vc.state = 'normal'
        vc.done(set_dot=True)
    else:
        vc.quit()

</t>
<t tx="ekr.20140222064735.16661">def vis_J(vc):
    '''Join the highlighted lines.'''
    vc.state = 'normal'
    vc.not_ready()
    ### vc.done(set_dot=True)
</t>
<t tx="ekr.20140222064735.16681">def vis_v(vc):
    '''End visual mode.'''
    if 1:
        # End visual node, retain the selection, and set the dot.
        # This makes much more sense in Leo.
        vc.state = 'normal'
        vc.done()
    else:
        # The real vim clears the selection.
        w = vc.w
        if vc.is_text_widget(w):
            i = w.getInsertPoint()
            w.setSelectionRange(i,i)
            # Visual mode affects the dot only if there is a terminating command.
            vc.dot_list = vc.old_dot_list
            vc.state = 'normal'
            vc.done(set_dot=False)
</t>
<t tx="ekr.20140222064735.16682"></t>
<t tx="ekr.20140222064735.16684">def vis_escape(vc):
    '''Handle Escape in visual mode.'''
    vc.state = 'normal'
    vc.done()
</t>
<t tx="ekr.20140222064735.16686">def vim_T(vc):
    '''Back before the Nth occurrence of &lt;char&gt;.'''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_T2)
    else:
        vc.quit()

def vim_T2(vc):
    '''Handle T &lt;stroke&gt;'''
    if vc.is_text_widget(vc.w):
        ec = vc.c.editCommands
        w = vc.w
        s = w.getAllText()
        if s:
            i = i1 = w.getInsertPoint()
            if i &gt; 0 and s[i-1] == vc.ch:
                i -= 1 # ensure progess.
            match_i,n = None,vc.n1*vc.n
            i -= 1
            while i &gt;= 0:
                if s[i] == vc.ch:
                    match_i,n = i,n-1
                    if n == 0: break
                elif s[i] == '\n' and not vc.cross_lines:
                    break
                i -= 1
            if match_i is not None:
                # g.trace(i1-match_i,vc.ch)
                for z in range(i1-match_i):
                    if vc.state == 'visual':
                        vc.do('back-char-extend-selection')
                    else:
                        vc.do('back-char')
        vc.done()
    else:
        vc.quit()

</t>
<t tx="ekr.20140222064735.16687">def vim_F(vc):
    '''Back to the Nth occurrence of &lt;char&gt;.'''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_F2)
    else:
        vc.quit()

def vim_F2(vc):
    '''Handle F &lt;stroke&gt;'''
    if vc.is_text_widget(vc.w):
        w = vc.w
        s = w.getAllText()
        if s:
            i = i1 = w.getInsertPoint()
            match_i,n = None,vc.n1*vc.n
            i -= 1 # ensure progess.
            while i &gt;= 0:
                if s[i] == vc.ch:
                    match_i,n = i,n-1
                    if n == 0: break
                elif s[i] == '\n' and not vc.cross_lines:
                    break
                i -= 1
            if match_i is not None:
                for z in range(i1-match_i-1):
                    if vc.state == 'visual':
                        vc.do('back-char-extend-selection')
                    else:
                        vc.do('back-char')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16692">def vim_O(vc):
    '''Open a new line above the current line N times.'''
    if vc.in_tree(vc.w):
        c = vc.c
        c.bodyWantsFocusNow()
        vc.w = c.frame.body.bodyCtrl
    if vc.is_text_widget(vc.w):
        vc.do(['beginning-of-line','insert-newline','back-char'])
        vc.begin_insert_mode()
    else:
        vc.quit()
</t>
<t tx="ekr.20140222064735.16702">def create_motion_dispatch_d(vc):
    '''
    Return the dispatch dict for motions.
    Keys are strokes, values are methods.
    '''
    d = {
    'asciicircum': vc.vim_caret,# '^'
    'asciitilde': None,         # '~'
    'asterisk': None,           # '*'
    'at': None,                 # '@'
    'bar': None,                # '|'
    'braceleft': None,          # '{'
    'braceright': None,         # '}'
    'bracketleft': None,        # '['
    'bracketright': None,       # ']'
    'colon': None,              # ':' Not a motion.
    'comma': None,              # ','
    'dollar': vc.vim_dollar,    # '$'
    'greater': None,            # '&gt;'
    'less': None,               # '&lt;'
    'minus': None,              # '-'
    'numbersign': None,         # '#'
    'parenleft': None,          # '('
    'parenright': None,         # ')'
    'percent': None,            # '%'
    'period': None,             # '.' Not a motion.
    'plus': None,               # '+'
    'question': vc.vim_question,# '?'
    'quotedbl': None,           # '"'
    'quoteleft': None,          # '`'
    'Return':vc.vim_return,     # '\n'
    'semicolon': None,          # ';'
    'slash': vc.vim_slash,      # '/'
    'underscore': None,         # '_'
    # Digits.
    '0': vc.vim_0, # Only 0 starts a motion.
    # Uppercase letters.
    'A': None,  # vim doesn't enter insert mode.
    'B': None,
    'C': None,
    'D': None,
    'E': None,
    'F': vc.vim_F,
    'G': vc.vim_G,
    'H': None,
    'I': None,
    'J': None,
    'K': None,
    'L': None,
    'M': None,
    'N': None,
    'O': None,  # vim doesn't enter insert mode.
    'P': None,
    'R': None,
    'S': None,
    'T': vc.vim_T,
    'U': None,
    'V': None,
    'W': None,
    'X': None,
    'Y': vc.vim_Y, # Yank Leo outline.
    'Z': None,
    # Lowercase letters...
    'a': None,      # vim doesn't enter insert mode.
    'b': vc.vim_b,
    # 'c': vc.vim_c,
    'd': None,      # Not valid.
    'e': vc.vim_e,
    'f': vc.vim_f,
    'g': vc.vim_g,
    'h': vc.vim_h,
    'i': None,      # vim doesn't enter insert mode.
    'j': vc.vim_j,
    'k': vc.vim_k,
    'l': vc.vim_l,
    # 'm': vc.vim_m,
    # 'n': vc.vim_n,
    'o': None,      # vim doesn't enter insert mode.
    # 'p': vc.vim_p,
    # 'q': vc.vim_q,
    # 'r': vc.vim_r,
    # 's': vc.vim_s,
    't': vc.vim_t,
    # 'u': vc.vim_u,
    # 'v': vc.vim_v,
    'w': vc.vim_w,
    # 'x': vc.vim_x,
    # 'y': vc.vim_y,
    # 'z': vc.vim_z,
    }
    return d
</t>
<t tx="ekr.20140222064735.16706">def begin_motion(vc,motion_func):
    '''Start an inner motion.'''
    # g.trace(motion_func.__name__,g.callers(2))
    w = vc.w
    vc.command_w = w
    vc.in_motion = True
    vc.motion_func = motion_func
    vc.motion_i = w.getInsertPoint()
    vc.n = 1
    if vc.stroke in '123456789':
        vc.vim_digits()
    else:
        vc.do_inner_motion()
</t>
<t tx="ekr.20140222064735.16709">def begin_insert_mode(vc,i=None,w=None):
    '''Common code for beginning insert mode.'''
    trace = False and not g.unitTesting
    c = vc.c
    if not w: w = vc.w
    vc.state = 'insert'
    vc.command_i = w.getInsertPoint() if i is None else i
    vc.command_w = w
    vc.accept(handler=vc.do_insert_mode,add_to_dot=False)
</t>
<t tx="ekr.20140730175636.17981">def vim_A(vc):
    '''Append text at the end the line N times.'''
    if vc.in_tree(vc.w):
        c = vc.c
        c.bodyWantsFocusNow()
        vc.w = w = c.frame.body.bodyCtrl
    else:
        w = vc.w
    if vc.is_text_widget(w):
        vc.do('end-of-line')
        vc.begin_insert_mode()
    else:
        vc.quit()
</t>
<t tx="ekr.20140730175636.17982">@language rest
    
:% s/find/change/g

Fix dot problems:
- vc.update_dot_before_search must call add_to_dot().
    save &amp; restore vc.command_list?
- :print-dot must handle VimEvents, not chars.
- Fix the dot for f,F,t,T commands (add_to_dot is called correctly.)
- Fix the dot for insert commands.

</t>
<t tx="ekr.20140730175636.17983">def vim_colon(vc):
    '''Enter the minibuffer.'''
    k = vc.k
    vc.colon_w = vc.w # A scratch ivar, for :gt &amp; gT commands.
    vc.quit()
    event = VimEvent(stroke='colon',w=vc.w)
    k.fullCommand(event=event)
    k.extendLabel(':')
</t>
<t tx="ekr.20140730175636.17991">def vim_dollar(vc):
    '''Move the cursor to the end of the line.'''
    if vc.is_text_widget(vc.w):
        if vc.state == 'visual':
            vc.do('end-of-line-extend-selection')
        else:
            vc.do('end-of-line')
        vc.done()
    else:
        vc.quit()

</t>
<t tx="ekr.20140730175636.17992">def vim_ctrl_r(vc):
    '''Redo the last command.'''
    vc.c.undoer.redo()
    vc.done()
</t>
<t tx="ekr.20140801121720.18071">@nocolor-node
@
Not yet:
    
N   B               (motion) N blank-separated WORDS backward
N   E               (motion) forward to the end of the Nth blank-separated WORD
N   G               (motion) goto line N (default: last line), on the first non-blank character
N   N               (motion) repeat last search, in opposite direction
N   W               (motion) N blank-separated WORDS forward
N   g#              (motion) like "#", but also find partial matches
N   g$              (motion) to last character in screen line (differs from "$" when lines wrap)
N   g*              (motion) like "*", but also find partial matches
N   g0              (motion) to first character in screen line (differs from "0" when lines wrap)
    gD              (motion) goto global declaration of identifier under the cursor
N   gE              (motion) backward to the end of the Nth blank-separated WORD
    gd              (motion) goto local declaration of identifier under the cursor
N   ge              (motion) backward to the end of the Nth word
N   gg              (motion) goto line N (default: first line), on the first non-blank character
N   gj              (motion) down N screen lines (differs from "j" when line wraps)
N   gk              (motion) up N screen lines (differs from "k" when line wraps)
</t>
<t tx="ekr.20140801121720.18076">def end_insert_mode(vc):
    '''End an insert mode started with the a,A,i,o and O commands.'''
    # Called from vim_esc.
    w = vc.w
    s = w.getAllText()
    i1 = vc.command_i
    i2 = w.getInsertPoint()
    if i1 &gt; i2: i1,i2 = i2,i1
    s2 = s[i1:i2]
    if vc.n1 &gt; 1:
        s3 = s2 * (vc.n1-1)
        g.trace(vc.in_dot,vc.n1,vc.n,s3)
        w.insert(i2,s3)
    for stroke in s2:
        vc.add_to_dot(stroke)
    vc.done()
</t>
<t tx="ekr.20140801121720.18079">def on_same_line(vc,s,i1,i2):
    '''Return True if i1 and i2 are on the same line.'''
    # Ensure that i1 &lt;= i2 and that i1 and i2 are in range.
    if i1 &gt; i2: i1,i2 = i2,i1
    if i1 &lt; 0: i1 = 0
    if i1 &gt;= len(s): i1 = len(s)-1
    if i2 &lt; 0: i2 = 0
    if i2 &gt;= len(s): i2 = len(s)-1
    if s[i2] == '\n': i2 = max(0,i2-1)
    return s[i1:i2].count('\n') == 0
</t>
<t tx="ekr.20140801121720.18080">def to_bol(vc,s,i):
    '''Return the index of the first character on the line containing s[i]'''
    if i &gt;= len(s): i = len(s)
    while i &gt; 0 and s[i-1] != '\n':
        i -= 1
    return i
    
def to_eol(vc,s,i):
    '''Return the index of the last character on the line containing s[i]'''
    while i &lt; len(s) and s[i] != '\n':
        i += 1
    return i
</t>
<t tx="ekr.20140801121720.18083">def is_plain_key(vc,stroke):
    '''Return True if stroke is a plain key.'''
    return vc.k.isPlainKey(stroke)
    
def is_text_widget(vc,w=None):
    '''Return True if w is a text widget.'''
    return vc.is_body(w) or vc.is_head(w) or g.app.gui.isTextWidget(w)
</t>
<t tx="ekr.20140802120757.17999">def quit(vc):
    '''
    Abort any present command.
    Don't set the dot and enter normal mode.
    '''
    vc.state = 'normal'
    vc.done(return_value=True,set_dot=False,stroke=None)
</t>
<t tx="ekr.20140802120757.18001">def save_body(vc):
    '''Undoably preserve any changes to body text.'''
    trace = False and not g.unitTesting
    c = vc.c
    w = vc.command_w or vc.w
    name = c.widget_name(w)
    if trace: g.trace(name,g.callers())
    if w and name.startswith('body'):
        # Similar to selfInsertCommand.
        oldSel = vc.old_sel or w.getSelectionRange()
        oldText = c.p.b
        newText = w.getAllText()
        # To do: set undoType to the command spelling?
        if newText != oldText:
            if trace: g.trace('** changed **')
            # undoType = ''.join(vc.command_list) or 'Typing'
            c.frame.body.onBodyChanged(undoType='Typing',
                oldSel=oldSel,oldText=oldText,oldYview=None)
</t>
<t tx="ekr.20140802120757.18002">def compute_dot(vc,stroke):
    '''Compute the dot and set vc.dot.'''
    if stroke:
        vc.add_to_dot(stroke)
    if vc.command_list:
        vc.dot_list = vc.command_list[:]
</t>
<t tx="ekr.20140802120757.18003">def init_scanner_vars(vc,event):
    '''Init all ivars used by the scanner.'''
    assert event
    vc.event = event
    stroke = event.stroke
    vc.ch = event.char # Required for f,F,t,T.
    vc.stroke = stroke.s if g.isStroke(stroke) else stroke
    vc.w = event and event.w
    if not vc.in_command:
        vc.in_command = True # May be cleared later.
        if vc.is_text_widget(vc.w):
            vc.old_sel = vc.w.getSelectionRange()
</t>
<t tx="ekr.20140802142132.17981">def show_command(vc):
    '''Show the accumulating command.'''
    return ''.join([repr(z) for z in vc.command_list])

def show_dot(vc):
    '''Show the dot.'''
    s = ''.join([repr(z) for z in vc.dot_list[:10]])
    if len(vc.dot_list) &gt; 10:
        s = s + '...'
    return s
</t>
<t tx="ekr.20140802183521.17996">class VimEvent:
    '''A class to contain the components of the dot.'''
    def __init__(self,stroke,w):
        '''ctor for the VimEvent class.'''
        self.char = '' # For Leo's core.
        self.stroke = stroke
        self.w = w
        self.widget = w # For Leo's core.
    def __repr__(self):
        '''Return the representation of the stroke.'''
        return show_stroke(self.stroke)
    __str__ = __repr__
</t>
<t tx="ekr.20140802183521.17997">def show_stroke(stroke):
    '''Return the best human-readable form of stroke.'''
    s = stroke.s if g.isStroke(stroke) else stroke
    d = {
        '\n':           r'\n',
        'Ctrl+Left':    'Ctrl+Left',
        'Ctrl+Right':   'Ctrl+Right',
        'Ctrl+r':       'Ctrl+r',
        'Down':         '&lt;Dn&gt;',
        'Escape':       '&lt;Esc&gt;',
        'Left':         '&lt;Lt&gt;',
        'Right':        '&lt;Rt&gt;',
        'Up':           '&lt;Up&gt;',
        'colon':        ':',
        'dollar':       '$',
        'period':       '.',
        'space':        ' ',
    }
    # g.trace(stroke,d.get(s,s))
    return d.get(s,s)
</t>
<t tx="ekr.20140802183521.17998">def add_to_dot(vc,stroke=None):
    '''
    Add a new VimEvent to vc.command_list.
    Never change vc.command_list if vc.in_dot is True
    Never add . to vc.command_list
    '''
    if not vc.in_dot:
        s = stroke or vc.stroke
        # Never add '.' to the dot list.
        if s and s != 'period':
            # g.trace(s)
            event = VimEvent(s,vc.w)
            vc.command_list.append(event)
</t>
<t tx="ekr.20140802183521.17999">def in_headline(vc,w):
    '''Return True if we are in a headline edit widget.'''
    return vc.widget_name(w).startswith('head')

def in_tree(vc,w):
    '''Return True if we are in the outline pane, but not in a headline.'''
    return vc.widget_name(w).startswith('canvas')
</t>
<t tx="ekr.20140802225657.18021">def handle_specials(vc):
    '''Return True vc.stroke is an Escape or a Return in the outline pane.'''
    if vc.stroke == 'Escape':
        # k.masterKeyHandler handles Ctrl-G.
        # Escape will end insert mode.
        vc.vim_esc()
        return True
    elif vc.stroke == 'Return' and vc.in_headline(vc.w):
        # End headline editing and enter normal mode.
        vc.c.endEditing()
        vc.done()
        return True
    else:
        return False
</t>
<t tx="ekr.20140802225657.18022">def oops(vc,message):
    '''Report an internal error'''
    g.warning('Internal vim-mode error: %s' % message)
    
</t>
<t tx="ekr.20140802225657.18023"># All acceptance methods must set vc.return_value.
# All key handlers must end with a call to an acceptance method.
</t>
<t tx="ekr.20140802225657.18024">def delegate(vc):
    '''Delegate the present key to k.masterKeyHandler.'''
    vc.show_status()
    vc.return_value = False
</t>
<t tx="ekr.20140802225657.18025">def ignore(vc):
    '''Ignore the present key without passing it to k.masterKeyHandler.'''
    g.es('ignoring',vc.stroke,'in',vc.state,'mode',color='blue')
    g.trace(g.callers())
    vc.show_status()
    vc.return_value = True
</t>
<t tx="ekr.20140802225657.18026"># Neither state handler nor key handlers ever return non-None.
</t>
<t tx="ekr.20140802225657.18029">def do_state(vc,d,mode_name):
    '''General dispatcher code. d is a dispatch dict.'''
    trace = False and not g.unitTesting
    func = d.get(vc.stroke)
    if func:
        if trace: g.trace(mode_name,vc.stroke,func.__name__)
        func()
    elif vc.is_plain_key(vc.stroke):
        if trace: g.trace('ignore',vc.stroke)
        vc.ignore()
    else:
        # Pass non-plain keys to k.masterKeyHandler
        if trace: g.trace('delegate',vc.stroke)
        vc.delegate()
</t>
<t tx="ekr.20140802225657.18031">def accept(vc,add_to_dot=True,handler=None):
    '''
    Accept the present stroke.
    Optionally, this can set the dot or change vc.handler.
    This can be a no-op, but even then it is recommended.
    '''
    if handler:
        if vc.in_motion:
            # Tricky: queue up vc.do_inner_motion to continue the motion.
            vc.handler = vc.do_inner_motion
            vc.next_func = handler
        else:
            # Queue the outer handler as usual.
            vc.handler = handler
    if add_to_dot:
        vc.add_to_dot()
    vc.show_status()
    vc.return_value = True
</t>
<t tx="ekr.20140802225657.18034"></t>
<t tx="ekr.20140803220119.18089">def do_inner_motion(vc,restart=False):
    '''Handle strokes in motions.'''
    trace = False and not g.unitTesting
    if trace: g.trace(vc.command_list)
    assert vc.in_motion
    if restart:
        vc.next_func = None
    func = vc.next_func or vc.motion_dispatch_d.get(vc.stroke)
    if func:
        func()
        if vc.motion_func:
            vc.motion_func()
            vc.in_motion = False # Required.
            vc.done()
    elif vc.is_plain_key(vc.stroke):
        vc.ignore()
    else:
        # Pass non-plain keys to k.masterKeyHandler
        vc.delegate()

</t>
<t tx="ekr.20140803220119.18090">def do_insert_mode(vc):
    '''Handle insert mode: delegate all strokes to k.masterKeyHandler.'''
    # Support the jj abbreviation when there is no selection.
    vc.state = 'insert'
    w = vc.w
    if vc.is_text_widget(w) and vc.test_for_insert_escape(w):
        return
    # Special case for arrow keys.
    if vc.stroke in vc.arrow_d:
        vc.vim_arrow()
    else:
        vc.delegate()

</t>
<t tx="ekr.20140803220119.18091">def do_normal_mode(vc):
    '''Handle strokes in normal mode.'''
    # Unlike visual mode, there is no need to init anything,
    # because all normal mode commands call vc.done.
    vc.do_state(vc.normal_mode_dispatch_d,'normal')
    
</t>
<t tx="ekr.20140803220119.18092">def do_visual_mode(vc):
    '''Handle strokes in visual mode.'''
    vc.n1 = vc.n = 1
    vc.do_state(vc.vis_dispatch_d,'visual')
</t>
<t tx="ekr.20140803220119.18097"></t>
<t tx="ekr.20140803220119.18102"># Called from command handlers or the ctor.
</t>
<t tx="ekr.20140803220119.18103"># Every ivar of this class must be initied in exactly one init helper.
</t>
<t tx="ekr.20140803220119.18104">def init_dot_ivars(vc):
    '''Init all dot-related ivars.'''
    vc.in_dot = False
        # True if we are executing the dot command.
    vc.dot_list = []
        # This list is preserved across commands.
    vc.old_dot_list = []
        # The dot_list saved at the start of visual mode.
</t>
<t tx="ekr.20140803220119.18106">def init_state_ivars(vc):
    '''Init all ivars related to command state.'''
    vc.ch = None
        # The incoming character.
    vc.command_i = None
        # The offset into the text at the start of a command.
    vc.command_list = []
        # The list of all characters seen in this command.
    vc.command_n = None
        # The repeat count in effect at the start of a command.
    vc.command_w = None
        # The widget in effect at the start of a command.
    vc.event = None
        # The event for the current key.
    vc.extend = False
        # True: extending selection.
    vc.handler = vc.do_normal_mode
        # Use the handler for normal mode.
    vc.in_command = False
        # True: we have seen some command characters.
    vc.in_motion = False
        # True if parsing an *inner* motion, the 2j in d2j.
    vc.motion_func = None
        # The callback handler to execute after executing an inner motion.
    vc.motion_i = None
        # The offset into the text at the start of a motion.
    vc.n1 = 1
        # The first repeat count.
    vc.n = 1
        # The second repeat count.
    vc.n1_seen = False
        # True if vc.n1 has been set.
    vc.next_func = None
        # The continuation of a multi-character command.
    vc.old_sel = None
        # The selection range at the start of a command.
    vc.repeat_list = []
        # The characters of the current repeat count.
    vc.return_value = True
        # The value returned by vc.do_key.
        # Handlers set this to False to tell k.masterKeyHandler to handle the key.
    vc.state = 'normal'
        # in ('normal','insert','visual',)
    vc.stroke = None
        # The incoming stroke.
    vc.vis_mode_i = None
        # The insertion point at the start of visual mode.
    vc.vis_mode_w = None
        # The widget in effect at the start of visual mode.
</t>
<t tx="ekr.20140803220119.18107">def init_persistent_ivars(vc):
    '''Init ivars that are never re-inited.'''
    c = vc.c
    vc.colon_w = None
        # The widget that has focus when a ':' command begins.  May be None.
    vc.cross_lines = c.config.getBool('vim-crosses-lines',default=True)
        # True: allow f,F,h,l,t,T,x to cross line boundaries.
    vc.register_d = {}
        # Keys are letters; values are strings.
    vc.search_stroke = None
        # The stroke ('/' or '?') that starts a vim search command.
    vc.trainer = False
        # True: in vim-training mode:
        # Mouse clicks and arrows are disable.
    vc.w = None
        # The present widget.
        # c.frame.body.bodyCtrl is a QTextBrowser.
    vc.j_changed = True
        # False if the .leo file's change indicator should be
        # cleared after doing the j,j abbreviation.
</t>
<t tx="ekr.20140803220119.18109">def init_constant_ivars(vc):
    '''Init ivars whose values never change.'''
    vc.chars = [ch for ch in string.printable if 32 &lt;= ord(ch) &lt; 128]
        # List of printable characters
    vc.register_names = string.ascii_letters
        # List of register names.
</t>
<t tx="ekr.20140803220119.18112">def vim_G(vc):
    '''Put the cursor on the last character of the file.'''
    if vc.is_text_widget(vc.w):
        if vc.state == 'visual':
            vc.do('end-of-buffer-extend-selection')
        else:
            vc.do('end-of-buffer')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140804123147.18929">def set_border(vc,kind=None,w=None,activeFlag=None):
    '''
    Set the border color of vc.w, depending on state.
    Called from qtBody.onFocusColorHelper and vc.show_status.
    '''
    if not w: w = g.app.gui.get_focus()
    if not w: return
    w_name = vc.widget_name(w)
    if w_name == 'richTextEdit':
        vc.set_property(w,focus_flag=activeFlag in (None,True))
    elif w_name.startswith('head'):
        vc.set_property(w,True)
    elif w_name != 'richTextEdit':
        # Clear the border in the body pane.
        try:
            w = vc.c.frame.body.bodyCtrl.widget
            vc.set_property(w,False)
        except Exception:
            pass
</t>
<t tx="ekr.20140804222959.18930">def finishCreate(vc):
    '''Complete the initialization for the VimCommands class.'''
    # Set the widget for vc.set_border.
    c = vc.c
    if c.vim_mode:
        # g.registerHandler('idle',vc.on_idle)
        try:
            # Be careful: c.frame or c.frame.body may not exist in some gui's.
            vc.w = vc.c.frame.body.bodyCtrl
        except Exception:
            vc.w = None
        if c.config.getBool('vim-trainer-mode',default=False):
            vc.toggle_vim_trainer_mode()
</t>
<t tx="ekr.20140805064952.18152">def widget_name(vc,w):
    return vc.c.widget_name(w)
</t>
<t tx="ekr.20140805064952.18153">def on_idle(vc,tag,keys):
    '''The idle-time handler for the VimCommands class.'''
    c = keys.get('c')
    if c and vc == c.vimCommands:
        # Call set_border only for the presently selected tab.
        try:
            # Careful: we may not have tabs.
            w = g.app.gui.frameFactory.masterFrame
        except AttributeError:
            w = None
        if w:
            i = w.indexOf(c.frame.top)
            if i == w.currentIndex():
                vc.set_border()
        else:
            vc.set_border()
</t>
<t tx="ekr.20140805130800.18157"></t>
<t tx="ekr.20140805130800.18158">def vim_arrow(vc):
    '''
    Handle all non-Alt arrows in any mode.
    This method attempts to leave focus unchanged.
    '''
    # pylint: disable=maybe-no-member
    s = vc.stroke.s if g.isStroke(vc.stroke) else vc.stroke
    if s.find('Alt+') &gt; -1:
        # Any Alt key changes c.p.
        vc.quit()
        vc.delegate()
    elif vc.trainer:
        # Ignore all non-Alt arrow keys in text widgets.
        if vc.is_text_widget(vc.w):
            vc.ignore()
        else:
            # Allow plain-arrow keys work in the outline pane.
            vc.delegate()
    else:
        # Delegate all arrow keys.
        vc.delegate()
</t>
<t tx="ekr.20140805130800.18161">def create_arrow_d(vc):
    '''Return a dict binding *all* arrows to vc.arrow.'''
    d = {}
    for arrow in ('Left','Right','Up','Down'):
        for mod in ('',
            'Alt+','Alt+Ctrl','Alt+Ctrl+Shift',
            'Ctrl+','Shift+','Ctrl+Shift+'
        ):
            d[mod+arrow] = vc.vim_arrow
    return d
</t>
<t tx="ekr.20140805130800.18162">def create_dispatch_dicts(vc):
    '''Create all dispatch dicts.'''
    vc.normal_mode_dispatch_d = d1 = vc.create_normal_dispatch_d()
        # Dispatch table for normal mode.
    vc.motion_dispatch_d = d2 = vc.create_motion_dispatch_d()
        # Dispatch table for motions.
    vc.vis_dispatch_d = d3 = vc.create_vis_dispatch_d()
        # Dispatch table for visual mode.
    # Add all entries in arrow dict to the other dicts.
    vc.arrow_d = arrow_d = vc.create_arrow_d()
    for d,tag in ((d1,'normal'),(d2,'motion'),(d3,'visual')):
        for key in arrow_d.keys():
            if key in d:
                g.trace('duplicate arrow key in %s dict: %s' % (tag,key))
            else:
                d[key] = arrow_d.get(key)
    if 1:
        # Check for conflicts between motion dict (d2) and the normal and visual dicts.
        # These are not necessarily errors, but are useful for debugging.
        for d,tag in ((d1,'normal'),(d3,'visual')):
            for key in d2.keys():
                f,f2 = d.get(key),d2.get(key)
                if f2 and f and f != f2:
                    g.trace('conflicting motion key in %s dict: %s %s %s' % (
                            tag,key,f2.__name__,f.__name__))
                elif f2 and not f:
                    g.trace('missing motion key in %s dict: %s %s' % (
                        tag,key,f2.__name__))
                    # d[key] = f2
</t>
<t tx="ekr.20140806075456.18152">def vim_return(vc):
    '''
    Handle a return key, regardless of mode.
    In the body pane only, it has special meaning.
    '''
    if vc.w:
        if vc.is_body(vc.w):
            if vc.state == 'normal':
                vc.begin_insert_mode()
            elif vc.state == 'visual':
                # same as v
                vc.stroke = 'v'
                vc.vis_v()
            else:
                vc.done()
        else:
            vc.delegate()
    else:
        vc.delegate()
</t>
<t tx="ekr.20140806081828.18157">def is_body(vc,w):
    '''Return True if w is the QTextBrowser of the body pane.'''
    w2 = vc.c.frame.body.bodyCtrl
    return w == w2

def is_head(vc,w):
    '''Return True if w is an headline edit widget.'''
    return vc.widget_name(w).startswith('head')
</t>
<t tx="ekr.20140806123540.18159"># This was an attempt to be clever: two commas would switch to insert mode.
def vim_comma(vc):
    '''Handle a comma in normal mode.'''
    if vc.is_text_widget(vc.w):
        vc.accept(handler=vc.vim_comma2)
    else:
        vc.quit()
    
def vim_comma2(vc):
    if vc.is_text_widget(vc.w):
        if vc.stroke == 'comma':
            vc.begin_insert_mode()
        else:
            vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140806204042.18115">def not_ready(vc):
    '''Print a not ready message and quit.'''
    g.es('not ready',g.callers(1))
    vc.ignore()
        # More forgiving than quit. 
</t>
<t tx="ekr.20140807070500.18161">def set_property(vc,w,focus_flag):
    '''Set the property of w, depending on focus and state.'''
    trace = False and not g.unitTesting
    selector = 'vim_%s' % (vc.state) if focus_flag else 'vim_unfocused'
    if trace: g.trace(vc.widget_name(w),selector)
    w.setProperty('vim_state',selector)
    w.style().unpolish(w)
    w.style().polish(w)
</t>
<t tx="ekr.20140807070500.18163">def reset(vc,setFocus):
    '''
    Called from k.keyboardQuit when the user types Ctrl-G (setFocus = True).
    Also called when the user clicks the mouse (setFocus = False).
    '''
    if setFocus:
        # A hard reset.
        vc.quit()
    else:
        # Do *not* change vc.state!
        pass
</t>
<t tx="ekr.20140807112800.18122">def test_for_insert_escape(vc,w):
    '''Return True if the j,j escape sequence has ended insert mode.'''
    c = vc.c
    s = w.getAllText()
    i = w.getInsertPoint()
    i2,j = w.getSelectionRange()
    if i2 == j and vc.stroke == 'j':
        if i &gt; 0 and s[i-1] == 'j':
            # g.trace(i,i2,j,s[i-1:i+1])
            w.delete(i-1,i)
            w.setInsertPoint(i-1)
            # A benign hack: simulate an Escape for the dot.
            vc.stroke = 'Escape'
            vc.end_insert_mode()
            if not vc.j_changed:
                c.setChanged(False)
            return True
        else:
            # Remember the changed state when we saw the first 'j'.
            vc.j_changed = c.isChanged()
    return False
</t>
<t tx="ekr.20140807152406.18125">def vim_P(vc):
    '''Paste text at the cursor or paste a node before the present node.'''
    if vc.in_tree(vc.w):
        vc.do(['goto-prev-visible','paste-node'])
        vc.done()
    elif vc.is_text_widget(vc.w):
        vc.do(['back-char','paste-text'])
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140807152406.18126">def vim_Y(vc):
    '''Yank a Leo outline.'''
    vc.not_ready()
</t>
<t tx="ekr.20140807152406.18127">def vim_question(vc):
    '''Begin a search.'''
    if vc.is_text_widget(vc.w):
        fc = vc.c.findCommands
        ftm = fc.ftm
        vc.search_stroke = vc.stroke # A scratch ivar for vc.update_dot_before_search.
        fc.reverse = True
        fc.openFindTab(vc.event)
        fc.ftm.clear_focus()
        old_node_only = fc.node_only
        fc.searchWithPresentOptions(vc.event)
            # This returns immediately, before the actual search.
            # leoFind.showSuccess calls vc.update_selection_after_search.
        fc.node_only = old_node_only
        vc.done(add_to_dot=False,set_dot=False)
    else:
        vc.quit()
</t>
<t tx="ekr.20140807152406.18128">def vim_caret(vc):
    '''Move to start of line.'''
    if vc.is_text_widget(vc.w):
        if vc.state == 'visual':
            vc.do('back-to-home-extend-selection')
        else:
            vc.do('back-to-home')
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18036">gnx: ekr.20110605121601.18696
</t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140808173212.18070">def vim_pound(vc):
    '''Find previous occurance of word under the cursor.'''
    ec = vc.c.editCommands
    w = vc.w
    if vc.is_text_widget(w):
        i1 = w.getInsertPoint()
        if not w.hasSelection():
            vc.do('extend-to-word')
        if w.hasSelection():
            fc = vc.c.findCommands
            s = w.getSelectedText()
            w.setSelectionRange(i1,i1)
            if not vc.in_dot:
                vc.dot_list.append(vc.stroke)
            old_node_only = fc.node_only
            fc.reverse = True
            fc.find_text = s
            fc.findNext()
            fc.reverse = False
            fc.node_only = old_node_only
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140808182202.18183">- Write extend_vim_mode plugin

- Extend Leo's undo to show the vim characters for the commands.

- tab &amp; shift-tab in normal mode might indent text.
  They do nothing in the real vim.  Sheesh.

- Ctrl-C works like escape (Conflicts with copy-text)

:1,$ s/^/  /g

    From line 1 to EOF ($), replace the beginning of the line (^) with two
    spaces ( ), globally (keep applying as many times as possible)
    
    A quick vim-like way to do indents on a range of characters. I also use
    this one frequently...

EKR: Can't Leo's find command do this?
</t>
<t tx="ekr.20140808182202.18184"></t>
<t tx="ekr.20140810181832.18220">def update_dot_before_search(vc,find_pattern,change_pattern):
    '''A callback that updates the dot just before searching.'''
    # g.trace(vc.search_stroke,find_pattern,change_pattern)
    # Don't use vc.add_to_dot: it updates vc.command_list.
    def add(stroke):
        vc.dot_list.append(stroke)
    if vc.in_dot:
        # Don't set the dot again.
        return
    if vc.search_stroke is None:
        # We didn't start the search with / or ?
        return
    if 1:
        # This is all we can do until there is a substitution command.
        vc.change_pattern = change_pattern
            # Not used at present.
        add(vc.search_stroke)
        for ch in find_pattern:
            add(ch)
        vc.search_stroke = None
    else:
        # We could do this is we had a substitution command.
        if change_pattern is None:
            # A search pattern.
            add(vc.search_stroke)
            for ch in find_pattern:
                add(ch)
        else:
            # A substitution:  :%s/find_pattern/change_pattern/g
            for s in (":%s/",find_pattern,"/",change_pattern,"/g"):
                for ch in s:
                    add(ch)
        vc.search_stroke = None
</t>
<t tx="ekr.20140810210411.18239">def vim_star(vc):
    '''Find previous occurance of word under the cursor.'''
    ec = vc.c.editCommands
    w = vc.w
    if vc.is_text_widget(w):
        i1 = w.getInsertPoint()
        if not w.hasSelection():
            vc.do('extend-to-word')
        if w.hasSelection():
            fc = vc.c.findCommands
            s = w.getSelectedText()
            w.setSelectionRange(i1,i1)
            if not vc.in_dot:
                vc.dot_list.append(vc.stroke)
            old_node_only = fc.node_only
            fc.reverse = False
            fc.find_text = s
            fc.findNext()
            fc.node_only = old_node_only
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140810214537.18241">def do(vc,o,event=None):
    '''Do one or more Leo commands by name.'''
    if not event:
        event = vc.event
    if isinstance(o,(tuple,list)):
        for z in o:
            vc.c.k.simulateCommand(z,event=event)
    else:
        vc.c.k.simulateCommand(o,event=event)
</t>
<t tx="ekr.20140811044942.18243">def update_selection_after_search(vc):
    '''Extend visual mode's selection after a search.'''
    if vc.state == 'visual':
        w = vc.w
        if w == g.app.gui.get_focus():
            i = w.getInsertPoint()
            w.setSelectionRange(vc.vis_mode_i,i,insert=i)
        else:
            g.trace('Search has changed nodes.')
</t>
<t tx="ekr.20140811110221.18250">def vim_V(vc):
    '''Visually select line.'''
    if vc.is_text_widget(vc.w):
        if vc.state == 'visual':
            bx = 'beginning-of-line-extend-selection'
            ex = 'end-of-line-extend-selection'
            s = vc.w.getAllText()
            i = vc.w.getInsertPoint()
            if vc.on_same_line(s,i,vc.vis_mode_i):
                vc.do([bx,ex])
            else:
                vc.do(ex if vc.vis_mode_i &lt; i else bx)
        else:
            vc.do([bx,ex])
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140811175537.18145">def vim_di(vc):
    '''Handle delete inner commands.'''
    if vc.is_text_widget(vc.w):
        if vc.stroke == 'w':
            # diw
            vc.do(['extend-to-word','backward-delete-char'])
            vc.done()
        else:
            vc.ignore()
            vc.quit()
    else:
        vc.quit()
</t>
<t tx="ekr.20140811175537.18146">def vim_d2(vc):
    '''Handle the second stroke of the d command.'''
    if vc.is_text_widget(vc.w):
        if vc.stroke == 'd':
            w = vc.w
            i = w.getInsertPoint()
            for z in range(vc.n1*vc.n):
                # It's simplest just to get the text again.
                s = w.getAllText()
                i,j = g.getLine(s,i)
                # Special case for end of buffer only for n == 1.
                # This is exactly how vim works.
                if vc.n1*vc.n == 1 and i == j == len(s):
                    i = max(0,i-1)
                w.delete(i,j)
            vc.done()
        elif vc.stroke == 'i':
            vc.accept(handler=vc.vim_di)
        else:
            vc.d_stroke = vc.stroke # A scratch var.
            vc.begin_motion(vc.vim_d3)
    else:
        vc.quit()
</t>
<t tx="ekr.20140811175537.18147">def vim_d3(vc):
    '''Complete the d command after the cursor has moved.'''
    # d2w doesn't extend to line.  d2j does.
    trace = False and not g.unitTesting
    if vc.is_text_widget(vc.w):
        extend_to_line = vc.d_stroke in ('jk')
        w = vc.w
        s = w.getAllText()
        i1,i2 = vc.motion_i,w.getInsertPoint()
        if i1 == i2:
            if trace: g.trace('no change')
        elif i1 &lt; i2:
            for z in range(vc.n1*vc.n):
                if extend_to_line:
                    i2 = vc.to_eol(s,i2)
                    if i2 &lt; len(s) and s[i2] == '\n':
                        i2 += 1
                    if trace: g.trace('extend i2 to eol',i1,i2)
            w.delete(i1,i2)
        else: # i1 &gt; i2
            i1,i2 = i2,i1
            for z in range(vc.n1*vc.n):
                if extend_to_line:
                    i1 = vc.to_bol(s,i1)
                    if trace: g.trace('extend i1 to bol',i1,i2)
            w.delete(i1,i2)
        vc.done()
    else:
        vc.quit()
</t>
<t tx="ekr.20140813052702.18194">class FileNameChooser:
    '''A class encapsulation file selection &amp; completion logic.'''
    # pylint: disable=no-self-argument
    # The first argument is fnc.
    @others
</t>
<t tx="ekr.20140813052702.18195">def __init__(fnc,c):
    '''Ctor for FileNameChooser class.'''
    # g.trace('(FileNameChooser)',c.shortFileName(),g.callers())
    fnc.c = c
    fnc.k = c.k
    assert c and c.k
    fnc.log = c.frame.log or g.NullObject()
    fnc.callback = None
    fnc.filterExt = None
    fnc.log = None # inited later.
    fnc.prompt = None
    fnc.tabName = None
</t>
<t tx="ekr.20140813052702.18196">def compute_tab_list (fnc):
    '''Compute the list of completions.'''
    trace = False and not g.unitTesting
    path = fnc.get_label()
    sep = os.path.sep
    if g.os_path_exists(path):
        if trace: g.trace('existing directory',path)
        if g.os_path_isdir(path):
            aList = glob.glob(path+'*')
            tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
        else:
            # An existing file.
            tabList = [path]
    else:
        if trace: g.trace('does not exist',path)
        if path and path.endswith(sep):
            path = path[:-1]
        aList = glob.glob(path+'*')
        tabList = [z + sep if g.os_path_isdir(z) else z for z in aList]
    if fnc.filterExt:
        for ext in fnc.filterExt:
            tabList = [z for z in tabList if not z.endswith(ext)]
    junk,common_prefix = g.itemsMatchingPrefixInList(path,tabList)
    if trace: g.trace('common_prefix',common_prefix)
    return common_prefix,tabList
</t>
<t tx="ekr.20140813052702.18197">def do_back_space (fnc):
    '''Handle a back space.'''
    trace = True and not g.unitTesting
    s = fnc.get_label()
    if s:
        s = s[:-1]
    fnc.set_label(s)
    if s:
        common_prefix,tabList = fnc.compute_tab_list()
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    fnc.show_tab_list(tabList)
</t>
<t tx="ekr.20140813052702.18198">def do_char (fnc,char):
    '''Handle a non-special character.'''
    fnc.extend_label(char)
    common_prefix,tabList = fnc.compute_tab_list()
    fnc.show_tab_list(tabList)
    if common_prefix:
        fnc.set_label(common_prefix)
        # Recompute the tab list.
        junk_common_prefix,tabList = fnc.compute_tab_list()
        fnc.show_tab_list(tabList)
    else:
        # Restore everything.
        fnc.set_label(fnc.get_label()[:-1])
        fnc.extend_label(char)
</t>
<t tx="ekr.20140813052702.18199">def do_tab (fnc):
    '''Handle tab completion.'''
    old = fnc.get_label()
    common_prefix,tabList = fnc.compute_tab_list()
    fnc.show_tab_list(tabList)
    if len(common_prefix) &gt; len(old):
        fnc.set_label(common_prefix)
</t>
<t tx="ekr.20140813052702.18200">def get_file_name(fnc,event,callback,filterExt,prompt,tabName):
    '''Get a file name, supporting file completion.'''
    trace = False and not g.unitTesting
    c,k = fnc.c,fnc.c.k
    tag = 'get-file-name'
    state = k.getState(tag)
    char = event and event.char or ''
    if trace:
        g.trace('state',state,'char',char or '&lt;**no char**&gt;')
    if state == 0:
        # Re-init all ivars.
        fnc.log = c.frame.log or g.NullObject()
        fnc.callback = callback
        fnc.filterExt = filterExt or ['.pyc','.bin',]
        fnc.prompt = prompt
        fnc.tabName = tabName
        # Init the label and state.
        if k.functionTail:
            path = k.functionTail.strip()
            fnc.set_label(g.os_path_finalize_join(os.curdir,path))
        else:
            fnc.set_label(g.os_path_finalize(os.curdir) + os.sep)
        k.setState(tag,1,fnc.get_file_name)
        fnc.log.selectTab(fnc.tabName)
        junk,tabList = fnc.compute_tab_list()
        fnc.show_tab_list(tabList)
        c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif char in ('\n','Return'):
        fnc.log.deleteTab(fnc.tabName)
        path = fnc.get_label()
        k.keyboardQuit()
        if fnc.callback:
            # pylint: disable=not-callable
            fnc.callback(path)
        else:
            g.trace('no callback')
    elif char in ('\t','Tab'):
        fnc.do_tab()
        c.minibufferWantsFocus()
    elif char in ('\b','BackSpace'):
        fnc.do_back_space() 
        c.minibufferWantsFocus()
    else:
        fnc.do_char(char)
</t>
<t tx="ekr.20140813052702.18201">def extend_label(fnc,s):
    '''Extend the label by s.'''
    fnc.c.k.extendLabel(s,select=False,protect=False)

def get_label(fnc):
    '''Return the label, not including the prompt.'''
    return fnc.c.k.getLabel(ignorePrompt=True)

def set_label(fnc,s):
    '''Set the label after the prompt to s. The prompt never changes.'''
    fnc.c.k.setLabel(fnc.prompt,protect=True)
    fnc.c.k.extendLabel(s or '',select=False,protect=False)
</t>
<t tx="ekr.20140813052702.18202">def show_tab_list (fnc,tabList):
    '''Show the tab list in the log tab.'''
    fnc.log.clearTab(fnc.tabName)
    s = g.os_path_finalize(os.curdir) + os.sep
    # g.es('',s,tabName=fnc.tabName)
    for path in tabList:
        theDir,fileName = g.os_path_split(path)
        s = theDir if path.endswith(os.sep) else fileName
        s = fileName or g.os_path_basename(theDir) + os.sep
        g.es('',s,tabName=fnc.tabName)
</t>
<t tx="ekr.20140813052702.18203">def getFileName(self,event,callback=None,
    filterExt=None,prompt='Enter File Name: ',tabName='Dired'
):
    '''Get a file name from the minibuffer.'''
    k = self
    k.fnc.get_file_name(event,callback,filterExt,prompt,tabName)
</t>
<t tx="ekr.20140814105040.18408">- 'V' should provide line mode visual, it inserts a 'V' at cursor
- 'v' starts visual character mode, 'y' should end visual mode and yank, 'y'
     is ignored until another 'v'
- aliasing &lt;return&gt; to 'i' is confusing, in vim it advances cursor to next line
- 'x' is backspace in Leo, delete in vim
</t>
<t tx="ekr.20140815160132.18821"></t>
<t tx="ekr.20140815160132.18822">def cycle_focus(vc,event=None):
    '''Cycle focus'''
    event = VimEvent(stroke='',w=vc.colon_w)
    vc.do('cycle-focus',event=event)
    
def cycle_all_focus(vc,event=None):
    '''Cycle all focus'''
    event = VimEvent(stroke='',w=vc.colon_w)
    vc.do('cycle-all-focus',event=event)
</t>
<t tx="ekr.20140815160132.18823">class LoadFileAtCursor:
    '''
    A class to handle Vim's :r command.
    This class supports the do_tab callback.
    '''
    def __init__(self,vc):
        '''Ctor for VimCommands.LoadFileAtCursor class.'''
        self.vc = vc
    __name__ = ':r'
        # Required.
    @others
</t>
<t tx="ekr.20140815160132.18824">def print_dot(vc,event=None):
    '''Print the dot.'''
    try:
        i = 0
        aList = [vc.c.k.stroke2char(s) for s in vc.dot_list]
        while i &lt; len(aList):
            g.es(','.join(aList[i:i+10]))
            i += 10
    except Exception:
        for z in vc.dot_list:
            g.es(repr(z))
</t>
<t tx="ekr.20140815160132.18825">def q_command(vc,event=None):
    '''Quit, prompting for saves.'''
    g.app.onQuit(event)
    
def qa_command(vc,event=None):
    '''Quit only if there are no unsaved changes.'''
    for c in g.app.commanders():
        if c.isChanged():
            return
    g.app.onQuit(event)
</t>
<t tx="ekr.20140815160132.18826">def revert(vc,event=None):
    '''Revert all changes to a .leo file, prompting if there have been changes.'''
    vc.c.revert()
</t>
<t tx="ekr.20140815160132.18827">def shell_command(vc,event=None):
    '''Execute a shell command.'''
    c,k = vc.c,vc.c.k
    if k.functionTail:
        command = k.functionTail
        c.controlCommands.executeSubprocess(event,command)
    else:
        event = VimEvent(stroke='',w=vc.colon_w)
        vc.do('shell-command',event=event)
</t>
<t tx="ekr.20140815160132.18828">class Substitution:
    '''A class to handle Vim's :% command.'''
    def __init__(self,vc):
        '''Ctor for VimCommands.tabnew class.'''
        self.vc = vc
    __name__ = ':%'
        # Required.
    @others
</t>
<t tx="ekr.20140815160132.18829">class Tabnew:
    '''
    A class to handle Vim's :tabnew command.
    This class supports the do_tab callback.
    '''
    def __init__(self,vc):
        '''Ctor for VimCommands.tabnew class.'''
        self.vc = vc
    __name__ = ':tabnew'
        # Required.
    @others

</t>
<t tx="ekr.20140815160132.18830">def toggle_vim_mode(vc,event=None):
    '''toggle vim-mode.'''
    c = vc.c
    c.vim_mode = not c.vim_mode
    g.es('vim-mode: %s' % (
        'on' if c.vim_mode else 'off'),
        color = 'red')
    if c.vim_mode:
        vc.quit()
    else:
        try:
            vc.state = 'insert'
            c.bodyWantsFocusNow()
            w = c.frame.body.bodyCtrl.widget
            vc.set_border(kind=None,w=w,activeFlag=True)
        except Exception:
            # g.es_exception()
            pass
</t>
<t tx="ekr.20140815160132.18831">def toggle_vim_trainer_mode(vc,event=None):
    '''toggle vim-trainer mode.'''
    vc.trainer = not vc.trainer
    g.es('vim-trainer-mode: %s' % (
        'on' if vc.trainer else 'off'),
        color = 'red')
</t>
<t tx="ekr.20140815160132.18832">def w_command(vc,event= None):
    '''Save the .leo file.'''
    vc.c.save()
        
def xa_command(vc,event=None): # same as :xa
    '''Save all open files and keep working.'''
    for c in g.app.commanders():
        if c.isChanged():
            c.save()

def wq_command(vc,event=None):
    '''Save all open files and exit.'''
    for c in g.app.commanders():
        c.save()
    g.app.onQuit(event)
</t>
<t tx="ekr.20140815160132.18834">def getPublicCommands(vc):
    '''Add the names of commands defined in this file to c.commandsDict'''
    vc.c.commandsDict.update({
        ':!':   vc.shell_command,
        ':%':   vc.Substitution(vc),
        ':e!':  vc.revert,
        ':gT':  vc.cycle_all_focus,
        ':gt':  vc.cycle_focus,
        ':q':   vc.q_command,
        ':qa':  vc.qa_command,
        ':r':   vc.LoadFileAtCursor(vc),
        ':print-dot':               vc.print_dot,
        ':tabnew':                  vc.Tabnew(vc),
        ':toggle-vim-mode':         vc.toggle_vim_mode,
        ':toggle-vim-trainer-mode': vc.toggle_vim_trainer_mode,
    })
</t>
<t tx="ekr.20140816165728.18937">:e directory name
    Shows list of files in the directory:
    selecting and &lt;enter&gt; opens a file

- Kent: v, V, ctrl-v : visual select character, line, column

http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/
</t>
<t tx="ekr.20140816165728.18939">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):
    '''
    Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''
    # pylint: disable=unpacking-non-sequence
    trace = False and not g.app.unitTesting
    k = self ; c = k.c
    state = k.getState('getArg')
    c.check_event(event)
    # Remember these events also.
    if c.macroCommands.recordingMacro and state &gt; 0:
        c.macroCommands.startRecordingMacro(event)
    char = event and event.char or ''
    if state &gt; 0:
        k.setLossage(char,stroke)
    if trace: g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        'isPlain',k.isPlainKey(stroke),
        'escapes',k.getArgEscapes,
        'completion',state==0 and completion or state!=0 and k.arg_completion,
        'handler',handler and handler.__name__ or 'None')
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocus()
    elif char == 'Escape':
        k.keyboardQuit()
    elif (
        char in ('\n','Return',) or
        k.oneCharacterArg or 
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes # The Find Easter Egg.
    ):
        if trace:
            g.trace('***escape***','char',repr(char),
                stroke,k.getArgEscapes,k.afterGetArgState)
            # g.trace(g.callers())
        if char == '\t' and char in k.getArgEscapes:
            k.getArgEscapeFlag = True
        if stroke and stroke in k.getArgEscapes:
            k.getArgEscapeFlag = True
        if k.oneCharacterArg:
            k.arg = char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif char in('\t','Tab'):
        if trace: g.trace('***tab***')
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif char in ('\b','BackSpace'):
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    elif k.isFKey(stroke):
        pass
        # 2011/03/01: ignore F-keys. Ignoring all except plain keys would kill unicode searches.
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
</t>
<t tx="ekr.20140816165728.18940">class GetArg:
    '''A class encapsulating all k.getArg logic.'''
    # pylint: disable=no-self-argument
    # The first argument is ga.
    @others
</t>
<t tx="ekr.20140816165728.18941">def get_arg (ga,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None,useMinibuffer=True
):
    '''
    Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''
    # pylint: disable=unpacking-non-sequence
    trace = False and not g.app.unitTesting
    c,k = ga.c,ga.k
    state = k.getState('getArg')
    c.check_event(event)
    # Remember these events also.
    if c.macroCommands.recordingMacro and state &gt; 0:
        c.macroCommands.startRecordingMacro(event)
    char = event and event.char or ''
    if state &gt; 0:
        k.setLossage(char,stroke)
    if state == 0:
        ga.do_state_zero(completion,event,handler,oneCharacter,prefix,
            returnKind,returnState,tabList,useMinibuffer)
        if trace: ga.trace_state(char,completion,handler,prefix,state,stroke)
    else:
        if trace: ga.trace_state(char,completion,handler,prefix,state,stroke)
        if char == 'Escape':
            k.keyboardQuit()
        elif ga.should_end(char,stroke):
            ga.do_end(event,char,stroke)
        elif char in('\t','Tab'):
            if trace: g.trace('***tab***')
            ga.do_tab(ga.tabList,ga.arg_completion)
        elif char in ('\b','BackSpace'):
            ga.do_back_space(ga.tabList,ga.arg_completion)
            c.minibufferWantsFocus()
        elif k.isFKey(stroke):
            # Ignore only F-keys. Ignoring all except plain keys would kill unicode searches.
            pass
        else:
            ga.do_char(event,char)
</t>
<t tx="ekr.20140816165728.18952">def __init__(ga,c,prompt='full-command: ',tabName='Completion'):
    '''Ctor for GetArg class.'''
    # Common ivars.
    ga.c = c
    ga.k = c.k
    assert c
    assert c.k
    ga.log = c.frame.log or g.NullObject()
    ga.tabName = tabName
    # State vars.
    ga.after_get_arg_state = None,None,None
    ga.arg_completion = True
    ga.handler = None
    ga.tabList = []
    # Tab cycling ivars...
    ga.cycling_prefix = None
    ga.cycling_index = -1
    ga.cycling_tabList = []
    # The following are k globals.
        # k.arg.
        # k.argSelectedText
        # k.oneCharacterArg
</t>
<t tx="ekr.20140816165728.18955">def do_char (ga,event,char):
    '''Handle a non-special character.'''
    k = ga.k
    k.updateLabel(event)
</t>
<t tx="ekr.20140816165728.18958"># Not useful because k.entendLabel doesn't handle selected text.
if 0:
    def extend_label(ga,s):
        '''Extend the label by s.'''
        ga.c.k.extendLabel(s,select=False,protect=False)

def get_label(ga):
    '''Return the label, not including the prompt.'''
    return ga.c.k.getLabel(ignorePrompt=True)

def set_label(ga,s):
    '''Set the label after the prompt to s. The prompt never changes.'''
    k = ga.c.k
    # Using k.mb_prefix is simplest.  No ga.ivars need be inited.
    k.setLabel(k.mb_prefix,protect=True)
    k.extendLabel(s or '',select=False,protect=False)
</t>
<t tx="ekr.20140816165728.18959">def show_tab_list (ga,tabList):
    '''Show the tab list in the log tab.'''
    k = ga.k
    ga.log.clearTab(ga.tabName)
    d = k.computeInverseBindingDict()
    data,n = [],0
    for commandName in tabList:
        dataList = d.get(commandName,[('',''),])
        for z in dataList:
            pane,key = z
            s1a = '%s ' % (pane) if pane != 'all:' else ''
            s1b = k.prettyPrintKey(key)
            s1 = s1a + s1b
            s2 = commandName
            data.append((s1,s2),)
            n = max(n,len(s1))
    aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
    g.es('','\n'.join(aList),tabName=ga.tabName)
</t>
<t tx="ekr.20140816165728.18965"># Called from k.fullCommand: with defaultTabList = list(c.commandsDict.keys())

def do_back_space(ga,tabList,completion=True):
    '''Handle a backspace and update the completion list.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    ga.tabList = tabList[:] if tabList else []
    # Update the label.
    w = k.w
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if ins &gt; len(k.mb_prefix):
        # Step 1: actually delete the character.
        i,j = w.getSelectionRange()
        if i == j:
            ins -= 1
            w.delete(ins)
            w.setSelectionRange(ins,ins,insert=ins)
        else:
            ins = i
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=ins)
    if w.getAllText().strip():
        junk,tabList = ga.compute_tab_list(ga.tabList)
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    ga.reset_tab_cycling()
    ga.show_tab_list(tabList)
</t>
<t tx="ekr.20140816165728.18968">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None,useMinibuffer=True
):
    '''Create the singleton GetArg instance and use it to get an argument.'''
    self.getArgInstance.get_arg(event,returnKind,returnState,handler,
        prefix,tabList,completion,oneCharacter,stroke,useMinibuffer)

def doBackSpace (self,tabList,completion=True):
    self.getArgInstance.do_back_space(tabList,completion)

def doTabCompletion (self,tabList,redraw=True,allow_empty_completion=False):
    self.getArgInstance.do_tab(tabList)
        ### ,redraw,allow_empty_completion)
        
def getMinibufferCommandName(self):
    return self.getArgInstance.get_minibuffer_command_name()
</t>
<t tx="ekr.20140817075533.18314">gnx: ekr.20140225224703.8169
unl: qtui_generate declarations
</t>
<t tx="ekr.20140817075533.18315">gnx: ekr.20140225224703.8170
unl: qt_main declarations
gnx: ekr.20140225224703.8171
unl: class Ui_MainWindow
gnx: ekr.20140225224703.8172
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20140225224703.8173
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20140817075533.18316"></t>
<t tx="ekr.20140817075533.18317">gnx: ekr.20140225224703.8174
unl: qt_quicksearch declarations
gnx: ekr.20140225224703.8175
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20140225224703.8176
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20140225224703.8177
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20140817075533.18318"></t>
<t tx="ekr.20140817110228.18316">def do_end(ga,event,char,stroke):
    '''A return or escape has been seen.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    if trace:
        g.trace('char',repr(char),stroke,k.getArgEscapes)
        if ga.after_get_arg_state:
            kind,n,handler = ga.after_get_arg_state
            g.trace('after state',kind,n,handler and handler.__name__ or 'None')
    if char == '\t' and char in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if stroke and stroke in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if k.oneCharacterArg:
        ga.arg = char
    else:
        k.arg = ga.get_label()
        if trace: g.trace('k.mb_prefix',k.mb_prefix,'k.arg',k.arg)
    kind,n,handler = ga.after_get_arg_state
    if kind: k.setState(kind,n,handler)
    ga.log.deleteTab('Completion')
    if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
    # pylint: disable=not-callable
    ga.reset_tab_cycling()
    if handler: handler(event)
</t>
<t tx="ekr.20140817110228.18317">def do_state_zero(ga,completion,event,handler,oneCharacter,prefix,
    returnKind,returnState,tabList,useMinibuffer
):
    '''Do state 0 processing.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    # We expect a non-empty prefix to match k.mb_prefix.
    # If so we can deprecate/eliminate the unused prefix arg.
    if trace and prefix and prefix != k.mb_prefix:
        g.trace('prefix',prefix,'k.mb_prefix',k.mb_prefix)
    # Set the ga globals...
    ga.after_get_arg_state=returnKind,returnState,handler
    ga.arg_completion = completion
    ga.cycling_prefix = None
    ga.handler = handler
    ga.tabList = tabList[:] if tabList else []
    # Set the k globals...
    k.argSelectedText = c.frame.body.bodyCtrl.getSelectedText()
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.bodyCtrl)
    k.setState('getArg',1,k.getArg)
    k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
    if useMinibuffer: c.minibufferWantsFocus()
</t>
<t tx="ekr.20140817110228.18321"># Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())

def compute_tab_list(ga,tabList,backspace=False,allow_empty_completion=False):
    '''Compute and show the available completions.'''
    # Support vim-mode commands.
    command = ga.get_label()
    if ga.is_command(command):
        tabList,common_prefix = g.itemsMatchingPrefixInList(command,tabList)
        return common_prefix,tabList
            # note order.
    else:
        # For now, disallow further completions if something follows the command.
        command = ga.get_command(command)
        return command,[command]
</t>
<t tx="ekr.20140817110228.18323"># Used by ga.get_arg and k.fullCommand.

def do_tab(ga,tabList,completion=True):
    '''Handle tab completion when the user hits a tab.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    if completion:
        tabList = ga.tabList = tabList[:] if tabList else []
        command = ga.get_label()
        common_prefix,tabList = ga.compute_tab_list(tabList)
        # No tab cycling for completed commands having
        # a 'tab_callback' attribute.
        if len(tabList) == 1:
            if ga.do_tab_callback():
                return
            elif ga.cycling_prefix:
                ga.do_tab_cycling(common_prefix,tabList)
            else:
                ga.show_tab_list(tabList)
                if len(common_prefix) &gt; len(command):
                    ga.set_label(common_prefix)
        else:
            ga.do_tab_cycling(common_prefix,tabList)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20140818052417.18241"></t>
<t tx="ekr.20140818074502.18221">def is_command(ga,s):
    '''Return False if something, even a blank, follows a command.'''
    if s.startswith(':'):
        if len(s) == 1:
            return True
        elif s[1].isalpha():
            for ch in s[1:]:
                if not ch.isalnum() and ch != '-':
                    return False
            return True
        else:
            # assert not s[1].isalpha()
            # Special case for :! and :% etc.
            return len(s) == 2
    else:
        for ch in s:
            if not ch.isalnum() and ch not in '_-':
                return False
        return True
</t>
<t tx="ekr.20140818074502.18222">def get_command(ga,s):
    '''Return the command part of a minibuffer contents s.'''
    if s.startswith(':'):
        # A vim-like command.
        if len(s) == 1:
            return s
        elif s[1].isalpha():
            command = [':']
            for ch in s[1:]:
                if ch.isalnum() or ch != '-':
                    command.append(ch)
                else: break
            return ''.join(command)
        else:
            # Special case for :! and :% etc.
            return s[:2]
    else:
        command = []
        for ch in s:
            if ch.isalnum() or ch in '_-':
                command.append(ch)
            else: break
        return ''.join(command)
</t>
<t tx="ekr.20140818085719.18227">def get_minibuffer_command_name(ga):
    '''Return the command name in the minibuffer.'''
    s = ga.get_label()
    command = ga.get_command(s)
    tail = s[len(command):]
    # g.trace('command:',command,'tail:',tail)
    return command,tail
</t>
<t tx="ekr.20140818103808.18234">def should_end(ga,char,stroke):
    '''Return True if ga.get_arg should return.'''
    k = ga.k
    return (
        char in ('\n','Return',) or
        k.oneCharacterArg or 
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes
            # The Find Easter Egg.
    )
</t>
<t tx="ekr.20140818103808.18235">def trace_state(ga,char,completion,handler,prefix,state,stroke):
    '''Trace the vars and ivars.'''
    k = ga.c.k
    g.trace(
        'prefix',prefix,'k.mb_prefix',k.mb_prefix,
        'state',state,'char',repr(char),'stroke',repr(stroke),
        # 'isPlain',k.isPlainKey(stroke),
        '\n',
        'escapes',k.getArgEscapes,
        'completion',ga.arg_completion,
        'handler',ga.handler and ga.handler.__name__ or 'None',
    )
</t>
<t tx="ekr.20140818145250.18235">def do_tab_callback(ga):
    '''
    If the command-name handler has a tab_callback,
    call handler.tab_callback() and return True.
    '''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    commandName,tail = k.getMinibufferCommandName()
    handler = c.commandsDict.get(commandName)
    if trace: g.trace(commandName,handler and handler.__name__ or 'None')
    if hasattr(handler,'tab_callback'):
        ga.reset_tab_cycling()
        k.functionTail = tail
            # For k.getFileName.
        handler.tab_callback()
        return True
    else:
        return False
</t>
<t tx="ekr.20140818145250.18237"></t>
<t tx="ekr.20140818145250.18238"></t>
<t tx="ekr.20140818201021.18301"></t>
<t tx="ekr.20140819042405.18307"></t>
<t tx="ekr.20140819050118.18317">def do_tab_cycling(ga,common_prefix,tabList):
    '''Put the next (or first) completion in the minibuffer.'''
    trace = False and not g.unitTesting
    s = ga.get_label()
    if ga.cycling_prefix:
        if s.startswith(ga.cycling_prefix):
            n = ga.cycling_index
            ga.cycling_index = n + 1 if n + 1 &lt; len(ga.cycling_tabList) else 0
            if trace: g.trace('cycle',ga.cycling_index)
            ga.set_label(ga.cycling_tabList[ga.cycling_index])
            ga.show_tab_list(ga.cycling_tabList)
        else:
            if trace: g.trace('prefix mismatch')
            ga.cycling_prefix = None
            ga.cycling_index = -1
            ga.show_tab_list(tabList)
                # Abort: show everything.
    else:
        if trace: g.trace('no ga.cycling_prefix')
        ga.cycling_prefix = s
        ga.cycling_index = -1
        ga.cycling_tabList = tabList[:]
        ga.set_label(common_prefix)
            # Don't extend the label yet!
        ga.show_tab_list(ga.cycling_tabList)
</t>
<t tx="ekr.20140819050118.18318">def reset_tab_cycling(ga):
    '''Reset all tab cycling ivars.'''
    ga.cycling_prefix = None
    ga.cycling_index = -1
    ga.cycling_tabList = []
</t>
<t tx="ekr.20140820034724.18313">def __call__(self,event=None):
    '''Prompt for a file name, the open a new Leo tab.'''
    self.vc.c.k.getFileName(event,callback=self.open_file_by_name)
</t>
<t tx="ekr.20140820034724.18314">def tab_callback(self):
    '''Called when the user types :tabnew&lt;tab&gt;'''
    self.vc.c.k.getFileName(event=None,callback=self.open_file_by_name)
</t>
<t tx="ekr.20140820034724.18315">def open_file_by_name(self,fn):
    c = self.vc.c
    if fn and not g.os_path_isdir(fn):
        c2 = g.openWithFileName(fn,old_c=c)
        try:
            g.app.gui.runAtIdle(c2.treeWantsFocusNow)
        except Exception:
            pass
    else:
        c.new()
</t>
<t tx="ekr.20140820034724.18316">def __call__ (self,event=None):
    '''Prompt for a file name, then load it at the cursor.'''
    self.vc.c.k.getFileName(event,callback=self.load_file_at_cursor)
</t>
<t tx="ekr.20140820034724.18317">def load_file_at_cursor(self,fn):
    vc = self.vc
    c,w = vc.c,vc.colon_w
    if not w:
        w = vc.w = c.frame.body.bodyCtrl
    if g.os_path_exists(fn):
        f = open(fn)
        s = f.read()
        f.close()
        i = w.getInsertPoint()
        w.insert(i,s)
        vc.save_body()
    else:
        g.es('does not exist:' % fn)
</t>
<t tx="ekr.20140820034724.18318">def tab_callback(self):
    '''Called when the user types :r&lt;tab&gt;'''
    self.vc.c.k.getFileName(event=None,callback=self.load_file_at_cursor)
</t>
<t tx="ekr.20140820063930.18321">def __call__(self,event=None):
    '''Handle substitution.'''
    k = self.vc.k
    g.trace('(Substitution)','k.arg',k.arg,'k.functionTail',k.functionTail)
</t>
<t tx="ekr.20140820063930.18323">def tab_callback(self):
    '''
    Called when the user types :%&lt;tab&gt; or :%/x&lt;tab&gt;.
    This never ends the command: only return does that.
    '''
    k = self.vc.k
    # g.trace('(Substitution)','k.arg',k.arg,'k.functionTail',k.functionTail)
    tail = k.functionTail
    tail = tail[1:] if tail.startswith(' ') else tail
    if not tail.startswith('/'):
        tail = '/'+tail
    k.setLabel(k.mb_prefix)
    k.extendLabel(':%'+tail+'/')
</t>
<t tx="ekr.20140820162445.18326"></t>
<t tx="ekr.20140821050318.18324">@nocolor-node

- Removed new_arg switch.</t>
</tnodes>
</leo_file>
