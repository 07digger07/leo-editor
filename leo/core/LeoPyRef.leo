<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20090620052003.8505"><vh>@button add-test @key=alt-9</vh></v>
<v t="ekr.20100210214809.5767"><vh>@button compare old/new</vh></v>
<v t="ekr.20090514093345.6054"><vh>Disabled buttons</vh>
<v t="ekr.20100205152016.14055"><vh>@@button find-node-by-gnx</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20100205162207.5844"><vh>@@button print gnx</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
</v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20100223133351.5996"><vh>@@button clean all blank lines</vh></v>
<v t="ekr.20100223133351.5999"><vh>@@button find long line</vh></v>
<v t="ekr.20100225053729.5761"><vh>@@button strip diff</vh></v>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
<v t="ekr.20100407063358.5748"><vh>inspect modules</vh></v>
<v t="ekr.20100515063611.5801"><vh>max N</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20090105132011.6"><vh>Regex notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
</v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="ekr.20100209091422.5978"><vh>Tests</vh>
<v t="ekr.20100208095423.5940"><vh>@@test leoCache</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20100223123910.5836"><vh>First</vh>
<v t="ekr.20100204052559.5791"><vh>Make TOC sidebar collapsible</vh></v>
<v t="ekr.20100707124440.5870"><vh>Fix at-root unit tests</vh></v>
<v t="ekr.20100521090440.5888"><vh>Fix tangle/untangle problems</vh>
<v t="ekr.20100521130114.5903"><vh>Allow @root only in headlines</vh></v>
<v t="ekr.20100507084415.5757"><vh>Fix @root-code/doc bug</vh>
<v t="ekr.20031218072017.1380"><vh>g.Directive utils...</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20071109165315"><vh>g.stripPathCruft</vh></v>
<v t="ekr.20090214075058.8"><vh>g.findAtTabWidthDirectives (must be fast)</vh></v>
<v t="ekr.20090214075058.6"><vh>g.findLanguageDirectives (must be fast)</vh></v>
<v t="ekr.20031218072017.1385"><vh>g.findReference</vh></v>
<v t="ekr.20090214075058.9"><vh>g.get_directives_dict (must be fast)</vh>
<v t="ekr.20090214075058.10"><vh>compute_directives_re</vh></v>
</v>
<v t="ekr.20080827175609.1"><vh>g.get_directives_dict_list (must be fast)</vh></v>
<v t="ekr.20031218072017.1386"><vh>g.getOutputNewline</vh></v>
<v t="ekr.20080827175609.52"><vh>g.scanAtCommentAndLanguageDirectives</vh></v>
<v t="ekr.20080827175609.32"><vh>g.scanAtEncodingDirectives</vh></v>
<v t="ekr.20080827175609.53"><vh>g.scanAtHeaderDirectives</vh></v>
<v t="ekr.20080827175609.33"><vh>g.scanAtLineendingDirectives</vh></v>
<v t="ekr.20080827175609.34"><vh>g.scanAtPagewidthDirectives</vh></v>
<v t="ekr.20100507084415.5760"><vh>g.scanAtRootDirectives</vh></v>
<v t="ekr.20031218072017.3154"><vh>g.scanAtRootOptions</vh>
<v t="ekr.20031218072017.3155"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="ekr.20080827175609.37"><vh>g.scanAtTabwidthDirectives &amp; scanAllTabWidthDirectives</vh></v>
<v t="ekr.20080831084419.4"><vh>g.scanAtWrapDirectives &amp; scanAllAtWrapDirectives</vh></v>
<v t="ekr.20080901195858.4"><vh>g.scanDirectives  (for compatibility only)</vh></v>
<v t="ekr.20040715155607"><vh>g.scanForAtIgnore</vh></v>
<v t="ekr.20040712084911.1"><vh>g.scanForAtLanguage</vh></v>
<v t="ekr.20041123094807"><vh>g.scanForAtSettings</vh></v>
<v t="ekr.20031218072017.1382"><vh>g.set_delims_from_language</vh></v>
<v t="ekr.20031218072017.1383"><vh>g.set_delims_from_string</vh></v>
<v t="ekr.20031218072017.1384"><vh>g.set_language</vh></v>
<v t="ekr.20081001062423.9"><vh>g.setDefaultDirectory &amp; helpers</vh>
<v t="ekr.20081001062423.10"><vh>g.getAbsPathFromNode</vh></v>
<v t="ekr.20081001062423.11"><vh>g.getPathFromDirectives</vh></v>
<v t="ekr.20081001062423.12"><vh>g.findDefaultDirectory (major change)</vh></v>
</v>
</v>
<v t="ekr.20100507084415.5758"><vh>Report</vh></v>
<v t="ekr.20080923124254.16"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20080923124254.17"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3475"><vh>tanglePass1</vh></v>
<v t="ekr.20031218072017.3594"><vh>setRootFromHeadline</vh></v>
<v t="ekr.20031218072017.1259"><vh>setRootFromText</vh></v>
<v t="ekr.20031218072017.3154"></v>
<v t="ekr.20031218072017.3599"><vh>token_type</vh>
<v t="ekr.20031218072017.3600"><vh>&lt;&lt; set token_type in noweb mode &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3602"><vh>&lt;&lt; set kind for directive &gt;&gt;</vh></v>
</v>
<v t="sps.20100618004337.20865"><vh>tanglePass1</vh></v>
</v>
<v t="ekr.20100521090440.5889"><vh>Fix untangle problem with @unit</vh></v>
</v>
<v t="ekr.20100521090440.5885"><vh>Fix mac unicode crasher</vh>
<v t="ekr.20100521090440.5886"><vh>Report</vh></v>
<v t="ekr.20061031131434.105"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20061031131434.106"><vh>&lt;&lt; define specialKeysyms &gt;&gt;</vh></v>
<v t="ekr.20061031131434.107"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20061031131434.109"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20061031131434.110"><vh>k.handleDefaultChar</vh></v>
</v>
</v>
<v t="ekr.20100421104119.5753"><vh>Fix @shadow IndexError crash</vh></v>
<v t="ekr.20100421101608.5824"><vh>Fix rst unicode bug</vh>
<v t="ekr.20090502071837.64"><vh>writeSpecialTree</vh></v>
<v t="ekr.20090502071837.94"><vh>write (leoRst)</vh></v>
</v>
<v t="ekr.20100521130114.5904"><vh>Plugins documentation thread</vh></v>
<v t="ekr.20100522090453.5912"><vh>Fix bugs with @verbatim, @raw and @end_raw</vh></v>
<v t="ekr.20100220190251.5616"><vh>Fix rst bug?</vh>
<v t="ekr.20100220190251.5617"><vh>report</vh></v>
<v t="ekr.20090502071837.72"><vh>handleCodeMode &amp; helper</vh>
<v t="ekr.20090502071837.73"><vh>formatCodeModeLine</vh></v>
<v t="ekr.20090502071837.74"><vh>rstripList</vh></v>
<v t="ekr.20090502071837.75"><vh>finishCodePart</vh></v>
</v>
<v t="ekr.20100220204150.5627"><vh>@@rst hello.html</vh>
<v t="ekr.20100220204150.5628"><vh>Greet the world</vh></v>
</v>
</v>
<v t="ekr.20100221142603.5620"><vh>Fix bug 524890: Incomplete derived file</vh>
<v t="ekr.20100221142603.5625"><vh>@@shadow clone-bug-test.py@</vh>
<v t="ekr.20100221142603.5626"><vh>&lt;&lt; a &gt;&gt;</vh>
<v t="ekr.20100221142603.5629"><vh>clone</vh></v>
</v>
<v t="ekr.20100221142603.5628"><vh>&lt;&lt; b &gt;&gt;</vh>
<v t="ekr.20100221142603.5629"></v>
</v>
</v>
</v>
<v t="ekr.20100223133351.5998"><vh>show-invisibles doesn't work for blank lines</vh></v>
<v t="ekr.20081208102356.1"><vh>Threading colorizer doesn't handle multiple body editors</vh></v>
<v t="ekr.20100131161507.6303"><vh>Unit tests that all commands have docstrings</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@thin leoVersion.py</vh></v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20100120092047.6087"><vh>@thin ../external/ipy_leo.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@thin ../external/lproto.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@thin runLeo.py </vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@thin leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@thin leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@thin leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31342e3071017d71025808000000616e6e6f7461746571037d710473732e"
expanded="EKR.20040612114220,ekr.20041219095213,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20061031131434"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@thin leoRst.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@thin leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@thin ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@thin leoBridgeTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@thin leoDynamicTest.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040504150046.4">def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; import leo.core.leoGlobals as g
    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', '', '')

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    ('', '&lt;!--', '--&gt;')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return '','',''
</t>
<t tx="EKR.20040519090151.2"></t>
<t tx="ekr.20031218072017.1259">@ This code skips the file name used in @root directives.

File names may be enclosed in &lt; and &gt; characters, or in double quotes.
If a file name is not enclosed be these delimiters it continues until
the next newline.
@c
def setRootFromText(self,s,report_errors=True):

    # g.trace(s)
    self.root_name = None
    i,self.start_mode = g.scanAtRootOptions(s,0)
    i = g.skip_ws(s,i)

    if i &gt;= len(s): return i
    # Allow &lt;&gt; or "" as delimiters, or a bare file name.
    if s[i] == '"':
        i += 1 ; delim = '"'
    elif s[i] == '&lt;':
        i += 1 ; delim = '&gt;'
    else: delim = '\n'

    root1 = i # The name does not include the delimiter.
    while i &lt; len(s) and s[i] != delim and not g.is_nl(s,i):
        i += 1
    root2 = i

    if delim != '\n' and not g.match(s,i,delim):
        if report_errors:
            g.scanError("bad filename in @root " + s[:i])
    else:
        self.root_name = s[root1:root2].strip()
    return i
</t>
<t tx="ekr.20031218072017.1380"># New in Leo 4.6:
# g.findAtTabWidthDirectives, g.findLanguageDirectives and
# g.get_directives_dict use re module for faster searching.
</t>
<t tx="ekr.20031218072017.1382"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    trace = False and not g.unitTesting

    val = g.app.language_delims_dict.get(language)
    # if language.startswith('huh'): g.pdb()

    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if trace: g.trace(repr(language),
            repr(delim1),repr(delim2),repr(delim3),g.callers(5))
        if delim2 and not delim3:
            return '',delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return '','','' # Indicate that no change should be made
</t>
<t tx="ekr.20031218072017.1383">def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = ['','','']
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i] or ''
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = ''

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in range(0,3):
        if delims[i]:
            delims[i] = delims[i].replace("__",'\n').replace('_',' ')

    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20031218072017.1384">def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    # assert(g.match_word(s,i,tag))
    if g.match_word(s,i,tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring:",g.get_line(s,i))

    return None, None, None, None,
</t>
<t tx="ekr.20031218072017.1385"># Called from the syntax coloring method that colorizes section references.

def findReference(c,name,root):

    '''Find the section definition for name.

    If a search of the descendants fails,
    and an ancestor is an @root node,
    search all the descendants of the @root node.
    '''

    for p in root.subtree():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # New in Leo 4.7: expand the search for @root trees.
    for p in root.self_and_parents():
        d = g.get_directives_dict(p)
        if 'root' in d:
            for p2 in p.subtree():
                if p2.matchHeadline(name) and not p2.isAtIgnoreNode():
                    return p2

    # g.trace("not found:",name,root)
    return c.nullPosition()
</t>
<t tx="ekr.20031218072017.1386">def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    # g.trace(c,name,c.config.output_newline,'returns',repr(s))

    if g.isPython3:
        s = str(s)
    return s
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 70

@ 
This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a position.
s:  a string.
t:  a tnode or a text widget.
u:  an undoer.
w:  a gui widget.
v:  a vnode
z:  a local temp.

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.bodyCtrl   The body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.tree            The tree pane.
</t>
<t tx="ekr.20031218072017.2604">

</t>
<t tx="ekr.20031218072017.3154">def scanAtRootOptions (s,i,err_flag=False):

    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s,i,"@root"):
        i += len("@root")
        i = g.skip_ws(s,i)

    mode = None 
    while g.match(s,i,'-'):
        &lt;&lt; scan another @root option &gt;&gt;

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")

    # g.trace(mode,g.callers(3))

    return i,mode
</t>
<t tx="ekr.20031218072017.3155">i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','\n','-'):
    i += 1

if err &gt; -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s,i)
    g.es("unknown option:",z_opt,"in",z_line)
</t>
<t tx="ekr.20031218072017.3475"></t>
<t tx="ekr.20031218072017.3594">def setRootFromHeadline (self,p):

    s = p.h

    if s[0:5] == "@root":
        i,self.start_mode = g.scanAtRootOptions(s,0)
        i = g.skip_ws(s,i)

        if i &lt; len(s): # Non-empty file name.
            # self.root_name must be set later by token_type().
            self.root = s[i:]
            # implement headline @root (but create unit tests first):
            # arguments: name, is_code, is_doc
            # st_enter_root_name(self.root, False, False)
</t>
<t tx="ekr.20031218072017.3599">def token_type(self,s,i,report_errors=True):

    """This method returns a code indicating the apparent kind of token at the position i.

    The caller must determine whether section definiton tokens are valid.

    returns (kind, end) and sets global root_name using setRootFromText().
    end is only valid for kind in (section_ref, section_def, at_root)."""

    kind = plain_line ; end = -1
    &lt;&lt; set token_type in noweb mode &gt;&gt;
    if kind == at_other :
        &lt;&lt; set kind for directive &gt;&gt;
    # g.trace(kind,g.get_line(s,i))
    return kind, end
</t>
<t tx="ekr.20031218072017.3600">if g.match(s,i,"&lt;&lt;"):
    i, kind, end = self.skip_section_name(s,i)
    if kind == bad_section_name:
        kind = plain_line # not an error.
    elif kind == at_root:
        assert(self.head_root == None)
        if self.head_root:
            self.setRootFromText(self.head_root,report_errors)
        else:
            kind = bad_section_name # The warning has been given.
elif g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
    # 10/30/02: Only @doc starts a noweb doc part in raw cweb mode.
    kind = g.choose(self.raw_cweb_flag,plain_line,at_doc)
elif g.match(s,i,"@@"): kind = at_at
elif i &lt; len(s) and s[i] == '@': kind = at_other
else: kind = plain_line
</t>
<t tx="ekr.20031218072017.3602"># This code will return at_other for any directive other than those listed.

if g.match_word(s,i,"@c"):
    # 10/30/02: Only @code starts a code section in raw cweb mode.
    kind = g.choose(self.raw_cweb_flag,plain_line,at_code)
else:
    for name, theType in [
        ("@chapter", at_chapter),
        ("@code", at_code),
        ("@doc", at_doc),
        ("@root", at_root),
        ("@section", at_section) ]:
        if g.match_word(s,i,name):
            kind = theType ; break

if self.raw_cweb_flag and kind == at_other:
    # 10/30/02: Everything else is plain text in raw cweb mode.
    kind = plain_line

if kind == at_root:
    end = self.setRootFromText(s[i:],report_errors)
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20040712084911.1">def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents():
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language,delim1,delim2,delim3 = g.set_language(z,0)
                return language

    return c.target_language
</t>
<t tx="ekr.20040715155607">def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents():
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True

    return False
</t>
<t tx="ekr.20041123094807">def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents():
        h = p.h
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060217111834"></t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.

       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others
</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()

    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")
</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.p

    # "Title" is the headline of the current node
    self.title.configure(text=cp.h)

    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)

    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().h
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)

    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)
</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20061031131434.105">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c ; gui = g.app.gui
    trace = (False or k.traceMasterCommand) and not g.unitTesting
    verbose = False
    traceGC = False
    if traceGC: g.printNewObjects('masterCom 1')

    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = gui.eventKeysym(event)
    ch = gui.eventChar(event)
    w = gui.eventWidget(event)
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    &lt;&lt; define specialKeysyms &gt;&gt;
    special = keysym in specialKeysyms
    interesting = func is not None
    inserted = not special

    if trace: #  and interesting:
        g.trace(
            'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;

    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        c.macroCommands.startKbdMacro(event)
        return 'break'

    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        except StopIteration:
            pass
        return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if commandName == 'propagate-key-event':
            # Do *nothing* with the event.
            return k.propagateKeyEvent(event)
        elif commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            if trace: g.trace('calling specialCallback for',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            if trace: g.trace('calling command directly',commandName)
            # if commandName != 'repeat-complex-command': # 2010/01/11
                # k.mb_history.insert(0,commandName)
            # if commandName == 'select-all': g.pdb()
            c.doCommand(func,commandName,event=event)
        if c.exists:
            k.endCommand(event,commandName)
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 2')
        return 'break'
    elif k.inState():
        return 'break' #Ignore unbound keys in a state.
    else:
        if traceGC: g.printNewObjects('masterCom 3')
        val = k.handleDefaultChar(event,stroke)
        if c.exists:
            c.frame.updateStatusLine()
        if traceGC: g.printNewObjects('masterCom 4')
        return val
</t>
<t tx="ekr.20061031131434.106">specialKeysyms = (
    'Alt_L','Alt_R',
    'Meta_L','Meta_R', # Meta support.
    'Caps_Lock','Control_L','Control_R',
    'Num_Lock',
    'Shift_L','Shift_R',
)
</t>
<t tx="ekr.20061031131434.107">if stroke or len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()

    # This looks like a memory leak, but isn't.
    keyHandlerClass.lossage.insert(0,(ch,stroke),)
</t>
<t tx="ekr.20061031131434.109">def callKeystrokeFunction (self,event):

    '''Handle a quick keystroke function.
    Return the function or None.'''

    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)

    return func
</t>
<t tx="ekr.20061031131434.110">def handleDefaultChar(self,event,stroke):
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)
    trace = False and not g.unitTesting

    if trace: g.trace('widget_name',name,'stroke',stroke)

    if (stroke and
        not stroke.startswith('Alt+Ctrl') and
        not self.enable_alt_ctrl_bindings and
        (stroke.find('Ctrl') &gt; -1 or stroke.find('Alt') &gt; -1)
    ):
        if trace: g.trace('*** ignoring unbound ctrl/alt key:',stroke)
        return 'break'

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else: # Ignore the key
            if trace: g.trace('ignoring',stroke)
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    elif name.startswith('canvas'):
        if not stroke: # Not exactly right, but it seems to be good enough.
            c.onCanvasKey(event) # New in Leo 4.4.2
        return 'break'
    elif name.startswith('log'):
        if g.app.gui.guiName() == 'tkinter':
            return None
        else:
            i = w.logCtrl.getInsertPoint()
            if not stroke:
                stroke = event.stroke # 2010/05/04.
            if stroke.lower() == 'return': stroke = '\n'
            elif stroke.lower() == 'tab': stroke = '\t'
            elif stroke.lower() == 'backspace': stroke = '\b'
            elif stroke.lower() == 'period': stroke = '.'
            w.logCtrl.insert(i,stroke)

            return None
    else:
        # Let the widget handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(stroke))
        return None
</t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.b
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20071109165315">def stripPathCruft (path):

    '''Strip cruft from a path name.'''

    if not path:
        return path # Retain empty paths for warnings.

    if len(path) &gt; 2 and (
        (path[0]=='&lt;' and path[-1] == '&gt;') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
</t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.b,ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'"))
        for z in sorted(self.decls)]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.b, p.h
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080827175609.1">def get_directives_dict_list(p1):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to
    the start of each directive"""

    trace = False and not g.unitTesting

    if trace: time1 = g.getTime()

    result = []

    if p1:
        p1 = p1.copy()
        for p in p1.self_and_parents():
            if p.hasParent(): root = None
            else:             root = [p.copy()]
            result.append(g.get_directives_dict(p,root=root))

        if trace:
            n = len(p1.h) + len(p1.b)
            g.trace('%4d %s' % (n,g.timeSince(time1)))

    return result
</t>
<t tx="ekr.20080827175609.32">def scanAtEncodingDirectives(aList):

    '''Scan aList for @encoding directives.'''

    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            # g.trace(encoding)
            return encoding
        elif encoding and not g.app.unitTesting:
            g.es("invalid @encoding:",encoding,color="red")

    return None
</t>
<t tx="ekr.20080827175609.33">def scanAtLineendingDirectives(aList):

    '''Scan aList for @lineending directives.'''

    for d in aList:

        e = d.get('lineending')
        if e in ("cr","crlf","lf","nl","platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.es("invalid @lineending directive:",e,color="red")

    return None
</t>
<t tx="ekr.20080827175609.34">def scanAtPagewidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @pagewidth directives.'''

    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s,0)
            if val != None and val &gt; 0:
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @pagewidth",s,color="red")

    return None
</t>
<t tx="ekr.20080827175609.37">def scanAtTabwidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @tabwidth directives.'''

    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk,val = g.skip_long(s,0)
            if val not in (None,0):
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @tabwidth",s,color="red")
    return None

def scanAllAtTabWidthDirectives(c,p):

    '''Scan p and all ancestors looking for @tabwidth directives.'''

    if c and p:
        aList = g.get_directives_dict_list(p)
        val = g.scanAtTabwidthDirectives(aList)
        ret = g.choose(val is None,c.tab_width,val)
    else:
        ret = None
    # g.trace(ret,p and p.h,ret)
    return ret
</t>
<t tx="ekr.20080827175609.52">def scanAtCommentAndAtLanguageDirectives(aList):

    '''Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.'''

    lang = None

    for d in aList:

        comment = d.get('comment')
        language = d.get('language')

        # Important: assume @comment follows @language.
        if language:
            # if g.unitTesting: g.trace('language',language)
            lang,delim1,delim2,delim3 = g.set_language(language,0)

        if comment:
            # if g.unitTesting: g.trace('comment',comment)
            delim1,delim2,delim3 = g.set_delims_from_string(comment)

        if comment or language:
            delims = delim1,delim2,delim3
            return {'language':lang,'comment':comment,'delims':delims}

    return None
</t>
<t tx="ekr.20080827175609.53">def scanAtHeaderDirectives(aList):

    '''scan aList for @header and @noheader directives.'''

    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.es_print("conflicting @header and @noheader directives",color='red')
</t>
<t tx="ekr.20080831084419.4">def scanAtWrapDirectives(aList,issue_error_flag=False):

    '''Scan aList for @wrap and @nowrap directives.'''

    for d in aList:
        if d.get('wrap') is not None:
            return True
        elif d.get('nowrap') is not None:
            return False

    return None

def scanAllAtWrapDirectives(c,p):

    '''Scan p and all ancestors looking for @wrap/@nowrap directives.'''

    if c and p:
        default = c and c.config.getBool("body_pane_wraps")
        aList = g.get_directives_dict_list(p)

        val = g.scanAtWrapDirectives(aList)
        ret = g.choose(val is None,default,val)
    else:
        ret = None
    # g.trace(ret,p.h)
    return ret
</t>
<t tx="ekr.20080901195858.4">def scanDirectives(c,p=None):

    return c.scanAllDirectives(p)
</t>
<t tx="ekr.20080923124254.16">def scanAllDirectives(self,p):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    self.init_directive_ivars()
    if p:
        s = p.b
        &lt;&lt; Collect @first attributes &gt;&gt;

    table = (
        ('encoding',    self.encoding,  g.scanAtEncodingDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives), 
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    lang_dict = {'language':None,'delims':None}
    self.parent_language_comment_settings(p,lang_dict)

    # Post process.
    lineending      = d.get('lineending')
    if lineending:
        self.output_newline = lineending
    self.encoding             = d.get('encoding')
    self.language             = lang_dict.get('language')
    self.init_delims          = lang_dict.get('delims')
    self.page_width           = d.get('pagewidth')
    self.tangle_directory     = d.get('path')
    self.tab_width            = d.get('tabwidth')

    # Handle the print-mode directives.
    self.print_mode = None
    for d in aList:
        for key in ('verbose','terse','quiet','silent'):
            if d.get(key) is not None:
                self.print_mode = key ; break
        if self.print_mode: break
    if not self.print_mode: self.print_mode = 'verbose'

    # g.trace(self.tangle_directory)

    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.tangle_directory,
        "tabwidth"  : self.tab_width,
    }
</t>
<t tx="ekr.20080923124254.17">@
Stephen P. Schaefer 9/13/2002: Add support for @first. Unlike other
root attributes, does *NOT* inherit from parent nodes.
@c

tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
</t>
<t tx="ekr.20081001062423.10"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

def getAbsPathFromNode(c,p,name=''): # Name is for unit testing.

    default_dir = ''
    if p:
        name = p.anyAtFileNodeName()

    if name:
        theDir = g.os_path_dirname(name)
        if theDir and g.os_path_isabs(theDir):
            if g.os_path_exists(theDir):
                default_dir = theDir
            else:
                default_dir = g.makeAllNonExistentDirectories(theDir,c=c)

    return default_dir
</t>
<t tx="ekr.20081001062423.11">def getPathFromDirectives(c,p):

    '''Scan for @path directives.'''

    trace = False and not g.unitTesting
    default_dir = '' ; error = ''
    if not p: return default_dir,error
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    if path:
        base = g.getBaseDirectory(c) # returns "" on error.
        path = c.os_path_finalize_join(base,path)
        if g.os_path_exists(path):
            default_dir = path
        else:
            default_dir = g.makeAllNonExistentDirectories(path,c=c)
            if not default_dir:
                error = "invalid @path: %s" % path

    return default_dir,error
</t>
<t tx="ekr.20081001062423.12"># This code is executed if no valid absolute path was specified in
# the @file node or in an @path directive.

def findDefaultDirectory(c):

    '''Attempt to find a suitable default directory.'''

    default_dir = ''

    # Check that c.openDirectory and c.frame.openDirectory are in synch.
    if c.openDirectory != c.frame.openDirectory:
        g.trace('***can not happen: c.openDirectory != c.frame.openDirectory')
        g.trace('c.openDirectory',c.openDirectory)
        g.trace('c.frame.openDirectory',c.frame.openDirectory)

    if not g.os_path_isabs(c.openDirectory):
        g.trace('*** can not happen: relative c.openDirectory',c.openDirectory)

    for theDir in (c.openDirectory,g.getBaseDirectory(c)):
        if theDir and g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
            if g.os_path_exists(theDir):
                default_dir = theDir
            else:
                default_dir = g.makeAllNonExistentDirectories(theDir,c=c)
            if default_dir: break

    return default_dir
</t>
<t tx="ekr.20081001062423.9"># This is a refactoring, used by leoImport.scanDefaultDirectory and
# atFile.scanDefaultDirectory

def setDefaultDirectory(c,p,importing=False):

    ''' Compute a default directory by scanning @path directives.
    Return (default_dir,error_message).'''

    if not p: return '',''
    default_dir,error = g.getAbsPathFromNode(c,p),''

    if not default_dir:
        default_dir,error = g.getPathFromDirectives(c,p)

    if c and c.frame and not default_dir and not error:
        default_dir = g.findDefaultDirectory(c)

    if not default_dir and not importing and not error:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    return default_dir, error
</t>
<t tx="ekr.20081208102356.1">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/5be7a099b299327e

&gt; Tk only colorizes one body editor, and if you delete that editor it
&gt; colorizes no editor.

Thanks for this report.  This is a problem, never noticed until now,
with the threading colorizer.  A workaround is to disable the
threading colorizer plugin. 
</t>
<t tx="ekr.20090105132011.6">@nocolor-node

# *** match pat2 if not preceded by pat1::

(?&lt;!pat1)pat2

.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:

copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x

[]
    Used to indicate a set of characters. Characters can be listed individually,
    or a range of characters can be indicated by giving two characters and
    separating them by a '-'. Special characters are not active inside sets.

    [akm$] will match any of the characters 'a', 'k', 'm', or '$';
    [a-z] will match any lowercase letter.
    [a-zA-Z0-9] matches any letter or digit.

    Character classes such as \w or \S (defined below) are also
    acceptable inside a range, although the characters they match depends on
    whether LOCALE or UNICODE mode is in force. If you want to include a ']' or
    a '-' inside a set, precede it with a backslash, or place it as the first
    character. The pattern []] will match ']', for example.

    You can match the characters not within a range by complementing the set.
    This is indicated by including a '^' as the first character of the set; '^'
    elsewhere will simply match the '^' character. For example, [^5] will match
    any character except '5', and [^^] will match any character except '^'.

(?=...)
    Matches if ... matches next, but doesnt consume any of the string.
    This is called a lookahead assertion.
    For example, Isaac (?=Asimov) will match 'Isaac ' only if it's followed by 'Asimov'.

(?!...)
    Matches if ... doesn't match next.
    This is a negative lookahead assertion.
    For example, Isaac (?!Asimov) will match 'Isaac ' only if it is not followed by 'Asimov'.

(?&lt;=...)
    Matches if the current position in the string is preceded by a match for ...
    that ends at the current position. This is called a positive lookbehind assertion.
    The contained pattern must only match strings of some fixed length,
    meaning that abc or a|b are allowed, but a* and a{3,4} are not.
    
(?&lt;!...) Matches if the current position in the string is not preceded by a
    match for .... This is called a negative lookbehind assertion. Similar to
    positive lookbehind assertions, the contained pattern must only match
    strings of some fixed length. Patterns which start with negative lookbehind
    assertions may match at the beginning of the string being searched.</t>
<t tx="ekr.20090214075058.10">def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    if 0: # 2010/02/01
        # The code never this, and this regex is broken
        # because it can confuse g.get_directives_dict.
        # @others can have leading whitespace.
        aList.append(r'^\s@others\s')

    return '|'.join(aList)
</t>
<t tx="ekr.20090214075058.6">g_language_pat = re.compile(r'(^@language)',re.MULTILINE)

def findLanguageDirectives(c,p):

    '''Return the language in effect at position p.'''

    trace = False and not g.unitTesting

    if c is None:
        return # c may be None for testing. 
    if c.target_language:
        language = c.target_language.lower()
    else:
        language = 'python'
    found = False
    # 2009/10/02: no need for copy arg to iter.
    for p in p.self_and_parents():
        if found: break
        for s in p.h,p.b:
            if found: break
            anIter = g_language_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = i + len(word)
                k = g.skip_line(s,j)
                language = s[j:k].strip()
                found = True

    if trace: g.trace(language)
    return language
</t>
<t tx="ekr.20090214075058.8">g_tabwidth_pat = re.compile(r'(^@tabwidth)',re.MULTILINE)

def findTabWidthDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None:
        return # c may be None for testing.

    w = None
    # 2009/10/02: no need for copy arg to iter
    for p in p.self_and_parents():
        if w: break
        for s in p.h,p.b:
            if w: break
            anIter = g_tabwidth_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = g.skip_ws(s,i + len(word))
                junk,w = g.skip_long(s,j)
                if w == 0: w = None
    return w
</t>
<t tx="ekr.20090214075058.9"># The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('&lt;'+'&lt;'+'*'+'&gt;'+'&gt;'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing the stripped remainder of the line
    following the first occurrence of each recognized directive"""

    trace = False and not g.unitTesting
    verbose = False
    if trace: g.trace('*'*20,p.h)

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('head',p.h),('body',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if j &lt; len(s) and s[j] not in (' ','\t','\n'):
                    # g.es_print('invalid character after directive',s[max(0,i-1):k-1],color='red')
                    # if trace:g.trace(word,repr(val),s[i:i+20])
                    pass # Not a valid directive: just ignore it.
                else:
                    directive_word = word.strip()
                    if directive_word in ('root-doc', 'root-code'):
                        d['root'] = val # in addition to optioned version
                    d[directive_word] = val
                    if trace: g.trace(word.strip(),kind,repr(val))
                    # A special case for @path in the body text of @&lt;file&gt; nodes.
                    # Don't give an actual warning: just set some flags.
                    if kind == 'body' and word.strip() == 'path' and p.isAnyAtFileNode():
                        g.app.atPathInBodyWarning = p.h
                        d['@path_in_body'] = p.h
                        if trace: g.trace('@path in body',p.h)

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= may only occur in a topmost node (i.e., without a parent)' % (
                    g.angleBrackets('*')))
            break

    if trace and verbose: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
</t>
<t tx="ekr.20090502071837.64">def writeSpecialTree (self,p,toString,justOneFile):

    c = self.c
    isHtml = self.ext in ('.html','.htm')
    if isHtml and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            g.es('SilverCity not present so no syntax highlighting')

    self.initWrite(p)
        # was encoding=g.choose(isHtml,'utf-8','iso-8859-1'))
    self.outputFile = StringIO()
    self.writeTree(p)
    self.source = self.outputFile.getvalue()
    self.outputFile = None

    if not toString:
        # Compute this here for use by intermediate file.
        self.outputFileName = self.computeOutputFileName(self.outputFileName)

        # Create the directory if it doesn't exist.
        theDir, junk = g.os_path_split(self.outputFileName)
        theDir = c.os_path_finalize(theDir)
        if not g.os_path_exists(theDir):
            ok = g.makeAllNonExistentDirectories(theDir,c=c,force=False)
            if not ok:
                g.es_print('did not create:',theDir,color='red')
                return False

        if self.getOption('write_intermediate_file'):
            ext = self.getOption('write_intermediate_extension')
            name = self.outputFileName.rsplit('.',1)[0] + ext 
            if g.isPython3: # 2010/04/21
                f = open(name,'w',encoding=self.encoding)
            else:
                f = open(name,'w')
            f.write(self.source)
            f.close()
            self.report(name)

    try:
        output = self.writeToDocutils(self.source)
        ok = output is not None
    except Exception:
        g.pr('Exception in docutils')
        g.es_exception()
        ok = False

    if ok:
        if isHtml:
            import re
            idxTitle = output.find('&lt;title&gt;&lt;/title&gt;')
            if idxTitle &gt; -1:
                m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', output)
                if not m:
                    m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', output)
                if m:
                    output = output.replace(
                        '&lt;title&gt;&lt;/title&gt;',
                        '&lt;title&gt;%s&lt;/title&gt;' % m.group(1)
                    )


        if toString:
            self.stringOutput = output
        else:
            # Write the file to the directory containing the .leo file.
            f = open(self.outputFileName,'w')
            f.write(output)
            f.close()
            self.http_endTree(self.outputFileName, p, justOneFile=justOneFile)

    return ok
</t>
<t tx="ekr.20090502071837.72">def handleCodeMode (self,lines):

    '''Handle the preprocessed body text in code mode as follows:

    - Blank lines are copied after being cleaned.
    - @ @rst-markup lines get copied as is.
    - Everything else gets put into a code-block directive.'''

    result = [] ; n = 0 ; code = []
    while n &lt; len(lines):
        s = lines [n] ; n += 1
        if (
            self.isSpecialDocPart(s,'@rst-markup') or (
                self.getOption('show_doc_parts_as_paragraphs') and
                self.isSpecialDocPart(s,None)
            )
        ):
            if code:
                self.finishCodePart(result,code)
                code = []
            result.append('')
            n, lines2 = self.getDocPart(lines,n)
            # A fix, perhaps dubious, to a bug discussed at
            # http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac
            # lines2 = [z.lstrip() for z in lines2]
            # g.trace('lines2',lines2)
            result.extend(lines2)
        elif not s.strip() and not code:
            pass # Ignore blank lines before the first code block.
        elif not code: # Start the code block.
            result.append('')
            result.append(self.code_block_string)
            code.append(s)
        else: # Continue the code block.
            code.append(s)

    if code:
        self.finishCodePart(result,code)
        code = []

    # Munge the result so as to keep docutils happy.
    # Don't use self.rstripList: it's not the same.
    # g.trace(result)
    result2 = []
    for z in result:
        if z == '': result2.append('\n\n')
        elif not z.rstrip(): pass
        elif z.endswith('\n\n'): result2.append(z) # Leave alone.
        else: result2.append('%s\n' % z.rstrip())

    return result2
</t>
<t tx="ekr.20090502071837.73">def formatCodeModeLine (self,s,n,numberOption):

    if not s.strip(): s = ''

    if numberOption:
        return '\t%d: %s' % (n,s)
    else:
        return '\t%s' % s
</t>
<t tx="ekr.20090502071837.74">def rstripList (self,theList):

    '''Removed trailing blank lines from theList.'''

    s = '\n'.join(theList).rstrip()
    return s.split('\n')
</t>
<t tx="ekr.20090502071837.75">def finishCodePart (self,result,code):

    numberOption = self.getOption('number_code_lines')
    code = self.rstripList(code)
    i = 0
    for line in code:
        i += 1
        result.append(self.formatCodeModeLine(line,i,numberOption))
</t>
<t tx="ekr.20090502071837.94">def write (self,s,theFile=None):

    if theFile is None:
        theFile = self.outputFile

    if g.isPython3:
        if g.is_binary_file(theFile):
            s = self.encode(s)
    else:
        s = self.encode(s)

    theFile.write(s)
</t>
<t tx="ekr.20090514093345.6054"></t>
<t tx="ekr.20090620052003.8505">u = c.undoer
w = c.frame.body.bodyCtrl
p2 = p.insertAsNthChild(0)
c.setHeadString(p2,'@test xxx')
s = '''\
if g.unitTesting:

    c,p = g.getTestVars()

    '''
c.setBodyString(p2,s)
c.selectPosition(p2)
c.redraw()
w.setInsertPoint(len(s))
c.bodyWantsFocus()
c.outerUpdate()
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20100131161507.6303"># Just make the test.  It doesn't have to pass.
</t>
<t tx="ekr.20100204052559.5791">@nocolor-node
@wrap

http://groups.google.com/group/leo-editor/browse_thread/thread/abe236a45b0511c7

http://www.google.com/url?sa=t&amp;source=web&amp;ct=res&amp;cd=4&amp;ved=0CBYQFjAD&amp;url=http%3A%2F%2Fbugs.python.org%2Fissue3143&amp;ei=bW5oS-eQIJDalAfqlYyGCA&amp;usg=AFQjCNGyhpE3wZ2jvfwA0dwjCfoAxleDRQ&amp;sig2=2CRD7hNMmx1NzFHMyOq_cQ

includes code for the CSS stylesheet (sidebar.js) to do make the sidebar collapsable.

EKR:

1. Place sidebar.js in leo\doc\html\_build\html\_static

2. Add the following line in the &lt;head&gt; section of all .html files in leo\doc\html\_build\html:

    &lt;script type="text/javascript" src="sidebar.js"&gt;&lt;/script&gt;

Now the sidebar is collapsable. Mousing over the divider shows a &lt;&lt; icon. When
the sidebar is collapsed, mousing over the left edge shows a &gt;&gt; button.

The question is, how to do this automatically?
</t>
<t tx="ekr.20100205152016.14055">gnx = 'ekr.20100205162207.5844'
for v in c.all_nodes():
    if v.gnx == gnx:
        print(v.h)</t>
<t tx="ekr.20100205162207.5844">print(p.v.gnx)

# ekr.20100205162207.5844
</t>
<t tx="ekr.20100208095423.5940">import leo.core.leoCache as leoCache

cacher = leoCache.cacher(c)

if 0:
    import os
    os.system('cls')

assert cacher.test()</t>
<t tx="ekr.20100209091422.5978"># These are intended to be temporary tests,
# to be copied eventually to unitTest.leo</t>
<t tx="ekr.20100210214809.5767">old,new = None,None
for child in p.children():
    if child.h.startswith('old'):
        old = child.copy()
    if child.h.startswith('new'):
        new = child.copy()
if old and new:
    print(old.b == new.b)
    if old.b != new.b:
        print('*' * 20)
        print(len(old.b),len(new.b))
        old_lines = g.splitLines(old.b)
        new_lines = g.splitLines(new.b)
        for i in range(max(len(old_lines),len(new_lines))):
            if (i &lt; len(old_lines) and i &lt; len(new_lines) and
                old_lines[i] == new_lines[i]
            ):
                pass
            else:
                if i &lt; len(old_lines):
                    print('old %2d %s' % (i,repr(old_lines[i])))
                if i &lt; len(new_lines):
                    print('new %2d %s' % (i,repr(new_lines[i])))</t>
<t tx="ekr.20100220190251.5616"></t>
<t tx="ekr.20100220190251.5617">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/c212814815c92aac

The indentation of the second @doc causes the doc part to look like
a continuation of the code:: directive.

It's not clear whether this bug is worth fixing, and it's not clear whether
there would be side effects of any potential fix.

The simplest fix appears to be in handleCodeMode.
</t>
<t tx="ekr.20100220204150.5627">@ @rst-options
verbose=True
code_mode=True
show_doc_parts_as_paragraphs=True
number_code_lines=True
write_intermediate_file=True
@c

</t>
<t tx="ekr.20100220204150.5628">@
Greet the world, politely
@c

g.es ("Hello, world")

@
    Was that polite enough?
    Indentation.
@c
</t>
<t tx="ekr.20100221142603.5620">@nocolor-node

This is the @others bug

1. Create the following tree

Instead of the expected test1.c file of:

Content (clone)
Content (clone)

I got just:

Content (clone)
</t>
<t tx="ekr.20100221142603.5625"># This buglet has been around for a long long time.
# It's not clear what Leo can do to fix it.
# In the meantime, don't put clones under two different
# @others directives :-)

&lt;&lt; A &gt;&gt;
&lt;&lt; B &gt;&gt;
@others
# end
</t>
<t tx="ekr.20100221142603.5626"># Node a
@others
</t>
<t tx="ekr.20100221142603.5628"># Node b
@others
</t>
<t tx="ekr.20100221142603.5629"># Content (clone)
</t>
<t tx="ekr.20100223123910.5836"></t>
<t tx="ekr.20100223133351.5996"># for v in c.all_unique_nodes():
n = 0
g.es('cleaning',c.p.h)
for p in c.p.self_and_subtree():
    print(p.h)
    lines = []
    for s in g.splitLines(p.b):
        if s.strip():
            lines.append(s)
        else:
            # Ensures a trailing newline.
            lines.append('\n')
    s2 = ''.join(lines)
    if s2 != p.b:
        p.b = s2
        p.v.setDirty()
        n += 1

c.redraw()
g.es('cleaned %s nodes' % n)
</t>
<t tx="ekr.20100223133351.5998"></t>
<t tx="ekr.20100223133351.5999"># This works, but splitting long lines by hand
# is the very essence of stupidity.

# Don't use this script!
# Use a *reliable* pep8 tool instead.

g.es('finding long lines in',p.h)
found = False
while p and not found:
    for line in g.splitLines(p.b):
        if len(line) &gt; 80:
            found = True
            g.es('long line in',p.h)
            c.selectPosition(p)
            break
    else:
        p.moveToThreadNext()
g.es('done')</t>
<t tx="ekr.20100225053729.5761"># Strips comments and context lines from a diff
# so real changes can be seen more easily.

result = []
for s in g.splitLines(p.b):
    if s.startswith('===') or s.startswith('+') or s.startswith('-'):
        i = s.find('#')
        if i &gt; -1:
            result.append(s[:i] + '\n')
        else:
            result.append(s)

p.b = ''.join(result)

</t>
<t tx="ekr.20100407063358.5748">import inspect

fn = g.os_path_finalize_join(g.app.loadDir,'leoNodes.py')

m = __import__ ('leoNodes')
# print(m)

classes = inspect.getmembers(m,inspect.isclass)
# print(classes)
print('='*20)
for z in classes:
    name,value = z
    print(name)
    members = inspect.getmembers(value)
    print('members of',name)
    for name2,value2 in members:
        if False: # not name2.startswith('__'):
            print('  ',name2)
        if name2 == '__init__':
            print('__init__',value2)
            if inspect.isfunction(value2):
                init_members = inspect.getmembers(value2)
                print('init members')
                for name3,value3 in init_members:
                    if not name3.startswith('__'):
                        print('    ',name3)</t>
<t tx="ekr.20100421101608.5824"></t>
<t tx="ekr.20100421104119.5753"></t>
<t tx="ekr.20100507084415.5757"></t>
<t tx="ekr.20100507084415.5758">@nocolor-node

Whereas the @root directive in a body works (for some value of works; I'm still
clarifying for myself - it doesn't work the way Leo of October 2002 did),
@root-doc and @root-code always elicit a message:

----- The outline contains no roots
looking for a parent to tangle...
tangle complete
 CancelOk
</t>
<t tx="ekr.20100507084415.5760">def scanAtRootDirectives(aList):

    '''Scan aList for @root directives.'''

    for d in aList:
        s = d.get('root')
        if s is not None:
            i, mode = g.scanAtRootOptions(s,0)
            g.trace(mode)
            return mode

    return None
</t>
<t tx="ekr.20100515063611.5801">n = 0

for p in c.all_positions():
    n = max(n,p.level())

g.es('n',n)

last = 0
delta = 0
d = {}

for p in c.all_positions():
    n = p.level()
    if n &lt; last:
        delta = max(delta,last-n)
        d [last-n] = d.get(last-n,0) + 1
    last = n

g.es('delta',delta)
g.es('d',d)
</t>
<t tx="ekr.20100521090440.5885"></t>
<t tx="ekr.20100521090440.5886">@nocolor-node

I put the following in qtGui.py after

# Last minute-munges to keysym.

    if sys.platform.startswith('darwin'):
        darwinmap = {
            'Alt-Key-5': '[',
            'Alt-Key-6': ']',
            'Alt-Key-7': '|',
            'Alt-slash': '\\',
            'Alt-Key-8': '{',
            'Alt-Key-9': '}',
            'Alt-e': '€',
            'Alt-l': '@',
        }
        if tkKey in darwinmap:
            tkKey = stroke = darwinmap[tkKey]

It works quite reasonabe. Sometimes (not really well reproducable)
following message appears:

/Users/tst/Leo-4.7-final/leo/core/leoKeys.py:3363: UnicodeWarning:
Unicode equal comparison failed to convert both arguments to Unicode -
interpreting them as being unequal
  if k.abortAllModesKey and stroke == k.abortAllModesKey:
/Users/scalet/Leo-4.7-final/leo/core/leoKeys.py:2521: UnicodeWarning:
Unicode equal comparison failed to convert both arguments to Unicode -
interpreting them as being unequal
  if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-
g'

nonetheless the special characters were inserted as expected.

I think all this is quite a hack, but ... thanks for the hack, most
important for me it's working for now. 
</t>
<t tx="ekr.20100521090440.5888"></t>
<t tx="ekr.20100521090440.5889">@nocolor-node

Thanks for quick answer! But I have still some questions.


2010/3/11 Edward K. Ream &lt;edreamleo@gmail.com&gt;

    [...]Something like this:

    @unit
       @root x.h
           &lt;&lt; functions defined in x.c &gt;&gt;

       @root x.c
            &lt;&lt; functions defined in x.c &gt;&gt; +=
                void f1(void);

            void f1 (void) { &lt;&lt; the actual code }


There are no delimiters (section definitions) between the lines above?


    So after tangling x.h will contain:
       void f1(void);
       void f2(void);


Tangling seems to be ok. But there are Big problems with untangling.
Without @unit only the first @root is untangled.
But now, with @unit, I got an error:
'''

untangling...

----- The outline contains no roots

untangle complete

'''


I hope it's only a bug, not the feature :)
</t>
<t tx="ekr.20100521130114.5903">@nocolor-node

I just finished reviewing Chapter 5, and some of its text, if not
downright wrong, is at best confusing, because it was written assuming
use of @root, and then perhaps modified to be less wrong - sometimes.
Before I launch on a significant rewrite, I'd like to know the plans
and timeframe for the revision to @root behavior.

Is it a matter only of @root becoming valid only in headers and not in
the body?  E.g., are there any changes to body section definitions,
e.g.,

+ headline
@c
commentary
@
&lt;&lt;section extension&gt;&gt;=
   more lines
   added to section extension

?  I.e., what's the full spec for the new behavior?

What's more likely to happen first:

(a) I rewrite the chapter to assume @file behavior (approx. two
weeks).
(b) Edward renews interest in changing @root (? days) and fixes it (2
days?)
(c) I get a spec for the new behavior of @root (? days) and attempt to
implement it myself (20 days?) then rewrite chapter 5 (one week; less
to change because I can leave in @root).

Reasons you'll have to wait longer for me than you might otherwise
expect: 1. Edward is more familiar with the code. 2 I've got
concurrent projects. 3. My strongest languages are perl, /bin/sh, C
and only then {python,ruby,lisp,objective-C,C++,erlang,...} 4.
Edward's probably smarter than I am ;-)

</t>
<t tx="ekr.20100521130114.5904">@nocolor-node

We want better docs, automatically, and a way to update @enabled-plugins.

http://groups.google.com/group/leo-editor/browse_thread/thread/b409aac6ca8cd33b
</t>
<t tx="ekr.20100522090453.5912">@nocolor-node

&gt; In the @file family of derived files (@thin, @nosent, etc.)  (i.e.,
&gt; not @root), you can prevent any interpretation of the immediately
&gt; following line with the "@verbatim" directive

This is not true, although it might appear to be true.

There is an @verbatim *sentinel*, but no @verbatim *directive*.

For example, I have just verified that the following does not work:

@verbatim
&lt;&lt; undefined ref &gt;&gt;

@raw and @end_raw do work as described.

There appear to be several bugs in this area:

1. Leo probably should warn that @verbatim does not exist as a
directive, although technically Leo is supposed to write anything that
looks like a sentinel but isn't "verbatim".

2. Leo does appear to read @raw and @end_raw properly in @thin files,
but Leo improperly issues the (red) log message,
converting @file format in @thin test_verbatim_sentinel.py
</t>
<t tx="ekr.20100707124440.5870"></t>
<t tx="sps.20100618004337.20865"># Traverses the tree whose root is given, handling each headline and associated body text.

def tanglePass1(self,p_in,delims):

    """The main routine of tangle pass 1"""

    p = self.p = p_in.copy() # self.p used by update_def in untangle
#    g.trace(p)
    self.setRootFromHeadline(p)
    theDict = g.get_directives_dict(p,[self.head_root])
    if ('ignore' in theDict):
        return
    self.scanAllDirectives(p) # calls init_directive_ivars.
    # Scan the headline and body text.
    # @language and @comment are not recognized in headlines
    self.skip_headline(p)
    delims = self.skip_body(p, delims)
    if self.errors + g.app.scanErrors &gt;= max_errors:
        self.warning("----- Halting Tangle: too many errors")
    elif p.hasChildren():
        p.moveToFirstChild()
        self.tanglePass1(p,delims)
        while p.hasNext() and (self.errors + g.app.scanErrors &lt; max_errors):
            p.moveToNext()
            self.tanglePass1(p,delims)
</t>
</tnodes>
</leo_file>
