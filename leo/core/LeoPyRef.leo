<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="33" left="274" height="930" width="999"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240" str_leo_pos="2,0,4,2,0"><vh>Startup</vh>
<v t="ekr.20080312060129.5"><vh>Buttons</vh>
<v t="ekr.20070628175250"><vh>@@button Add if g.unitTesting @key=f6</vh></v>
<v t="ekr.20071004062031"><vh>@@button print -----</vh></v>
<v t="ekr.20071001054335"><vh>@@button split-defs</vh></v>
<v t="ekr.20080121091513"><vh>@@button parse2tree</vh></v>
<v t="ekr.20080220082617"><vh>@@button print g.es stats</vh>
<v t="ekr.20080220082617.1"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20080220082617.2"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20080220082617.3"><vh> ctor</vh></v>
<v t="ekr.20080220082617.4"><vh>error &amp; trace</vh></v>
<v t="ekr.20080220082617.5"><vh>main</vh></v>
<v t="ekr.20080221101728"><vh>munging...</vh>
<v t="ekr.20080221071308"><vh>mungeString</vh></v>
<v t="ekr.20080220093930"><vh>mungeHeadline</vh></v>
<v t="ekr.20080221073909"><vh>mungeStatements</vh></v>
<v t="ekr.20080221101728.1"><vh>stringize</vh></v>
</v>
<v t="ekr.20080220082617.6"><vh>scan &amp; helpers</vh>
<v t="ekr.20080220182141"><vh>scanIdChain</vh></v>
<v t="ekr.20080220082617.9"><vh>scanNode</vh>
<v t="ekr.20080221071734"><vh>&lt;&lt; insert statements highlighting the @thin node &gt;&gt;</vh></v>
<v t="ekr.20080221071734.1"><vh>&lt;&lt; Insert a comment containing the headline &gt;&gt;</vh></v>
</v>
<v t="ekr.20080220082617.8"><vh>scanParens</vh></v>
<v t="ekr.20080220183819"><vh>scanStringArg</vh></v>
</v>
<v t="ekr.20080220082617.10"><vh>setDecl</vh></v>
<v t="ekr.20080221110301"><vh>setToBeTranslated</vh></v>
</v>
<v t="ekr.20060910141935"><vh>ZODB plugin buttons</vh>
<v t="ekr.20060910141935.1"><vh>@@button zodb-read</vh></v>
<v t="ekr.20060910141935.2"><vh>@@button zodb-write</vh></v>
</v>
</v>
<v t="ekr.20080312060129.6"><vh>Commands</vh>
<v t="ekr.20060531093331"><vh>@@command clones-tab</vh>
<v t="ekr.20060531093331.1"><vh>class cloneNavigator</vh>
<v t="ekr.20060531093331.2"><vh>init</vh></v>
<v t="ekr.20060531093331.3"><vh>getAllClones</vh></v>
<v t="ekr.20060531093331.4"><vh>displayClones</vh>
<v t="ekr.20060531093331.5"><vh>&lt;&lt;Fill listbox with clone parent headlines&gt;&gt;</vh></v>
<v t="ekr.20060531093331.6"><vh>&lt;&lt;Goto selected position when listbox selection changes&gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20071024180738"><vh>@@command ext-unit-test @key=Alt+6</vh></v>
<v t="ekr.20071024171346"><vh>@@command unit-test @key=Alt+4</vh></v>
</v>
<v t="ekr.20070605104410"><vh>@chapters</vh></v>
<v t="ekr.20080121092503"><vh>Scripts</vh>
<v t="ekr.20080121090750"><vh>create-at-auto-nodes</vh></v>
</v>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20080412053100.4"><vh>@bool fixedWindow = False</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20060217111834"><vh>@url http://docs.python.org/lib/re-syntax.html</vh></v>
<v t="ekr.20060908104329"><vh>@url file:c:/prog/tigris-cvs/leo/doc/leoDocs.leo#Users Guide</vh></v>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3" a="E"><vh>Projects</vh>
<v t="EKR.20040429143933" a="E" annotate="7d71002855046e6f6465710155007102550262677103680255087072696f72697479710455043939393971055502666771066802550870726f677265737371076802550961726368657479706571086802752e"
marks="ekr.20060417194232.2,ekr.20041121130043,ekr.20041119204700,ekr.20070925144337.2,ekr.20040803072955.127,ekr.20040803072955.91,ekr.20031218072017.2834,ekr.20080708094444.67,ekr.20080708094444.63,ekr.20080708094444.65,"
expanded="ekr.20080710082231.16,ekr.20080713091247.3,ekr.20080708094444.81,ekr.20080708094444.60,ekr.20080708094444.38,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20080603052650.466,ekr.20031218072017.2834,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601"
marks="ekr.20041107093834,"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20040629121554.1" a="M"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@thin leoBridge.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@thin leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.1,ekr.20031218072017.2834,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"
marks="ekr.20041121130043,ekr.20041119204700,ekr.20070925144337.2,"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20060417194232.2,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@thin leoPymacs.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="285808000000616e6e6f7461746571007d71017471022e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@thin runLeo.py </vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3655"
marks="ekr.20040803072955.91,"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"
marks="ekr.20040803072955.127,"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20080112145409"><vh>Gui gtk classes</vh>
<v t="ekr.20080112145409.1"><vh>@thin leoGtkDialog.py</vh></v>
<v t="ekr.20080112173119"><vh>@thin leoGtkFind.py</vh></v>
<v t="ekr.20080112145409.53"><vh>@thin leoGtkFrame.py</vh></v>
<v t="ekr.20080112145409.435"><vh>@thin leoGtkGui.py</vh></v>
<v t="ekr.20080112171650"><vh>@thin leoGtkKeys.py</vh></v>
<v t="ekr.20080112171213"><vh>@thin leoGtkMenu.py</vh></v>
<v t="ekr.20080112170946"><vh>@thin leoGtkTree.py</vh></v>
</v>
</v>
<v t="ekr.20080708094444.81"><vh>(add support for shadow files)</vh>
<v t="ekr.20080708094444.53"><vh>Module level</vh>
<v t="ekr.20080708094444.54"><vh>init</vh></v>
<v t="ekr.20080708094444.55"><vh>putInHooks</vh></v>
<v t="ekr.20080708094444.56"><vh>OLDapplyConfiguration</vh></v>
<v t="ekr.20080708094444.57"><vh>check_for_shadow_file (Not used)</vh></v>
<v t="ekr.20080708094444.58"><vh>getVerbosity</vh></v>
<v t="ekr.20080708094444.59"><vh>marker_from_extension</vh></v>
</v>
<v t="ekr.20080708094444.60" a="E"><vh>Leo overwrites</vh>
<v t="ekr.20080708094444.87"><vh>Read/write</vh>
<v t="ekr.20080708094444.61"><vh>openForRead</vh></v>
<v t="ekr.20080708094444.62"><vh>openForWrite</vh></v>
<v t="ekr.20080708094444.67" a="M"><vh>atFile.replaceTargetFileIfDifferent</vh></v>
<v t="ekr.20080708094444.68"><vh>massageComment</vh></v>
</v>
<v t="ekr.20080708094444.88"><vh>goto-line-number changes</vh>
<v t="ekr.20080708094444.63" a="M"><vh>gotoLineNumberOpen</vh></v>
<v t="ekr.20080708094444.64"><vh>gotoLineNumber</vh>
<v t="ekr.20080708094444.65" a="M"><vh>applyLineNumberMappingIfAny</vh></v>
</v>
</v>
<v t="ekr.20080708094444.79"><vh> x.ctor</vh></v>
<v t="ekr.20041005105605.19"><vh>openFileForReading (atFile)</vh></v>
<v t="ekr.20041005105605.21"><vh>read (atFile)</vh>
<v t="ekr.20041005105605.22"><vh>&lt;&lt; set fileName &gt;&gt;</vh></v>
<v t="ekr.20071105164407"><vh>&lt;&lt; advise user to delete all unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20041005105605.25"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.26"><vh>readAll (atFile)</vh></v>
<v t="ekr.20080711093251.7"><vh>readOneAtShadowNode (atFile) &amp; helper</vh>
<v t="ekr.20080712080505.1"><vh>importAtShadowNode</vh></v>
</v>
<v t="ekr.20041005105605.27"><vh>readOpenFile</vh>
<v t="ekr.20041005105605.28"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20080711063656.1"><vh>x.File utils</vh>
<v t="ekr.20080711063656.7"><vh>x.baseDirName</vh></v>
<v t="ekr.20080711063656.4"><vh>x.dirName and pathName</vh></v>
<v t="ekr.20080712080505.3"><vh>x.isSignificantPublicFile</vh></v>
<v t="ekr.20080710082231.19"><vh>x.makeShadowDirectory</vh></v>
<v t="ekr.20080711063656.2"><vh>x.rename</vh></v>
<v t="ekr.20080713091247.1"><vh>x.replaceFileWithString</vh></v>
<v t="ekr.20080711063656.6"><vh>x.shadowDirName and shadowPathName</vh></v>
<v t="ekr.20080711063656.3"><vh>x.unlink</vh></v>
</v>
<v t="ekr.20080712080505.3"><vh>x.isSignificantPublicFile</vh></v>
<v t="ekr.20080710082231.19"><vh>x.makeShadowDirectory</vh></v>
<v t="ekr.20080708094444.36"><vh>x.propagate_changes</vh></v>
<v t="bwmulder.20041231170726"><vh>x.updatePublicAndPrivateFiles</vh>
<v t="ekr.20080708094444.27"><vh>x.copy_file_removing_sentinels</vh></v>
</v>
</v>
<v t="ekr.20080710082231.4"><vh>@@button shadow</vh></v>
</v>
<v t="ekr.20080708094444.1" a="E"
expanded="ekr.20080708094444.80,ekr.20080708094444.38,"><vh>@thin leoShadow.py</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="bwmulder.20041231170726">def updatePublicAndPrivateFiles (self,fn,shadow_fn):

    '''handle crucial @shadow read logic.

    This will be called only if the public and private files both exist.'''

    x = self ; trace = False

    if trace and not g.app.unitTesting:
        g.trace('significant',x.isSignificantPublicFile(fn),fn)

    if x.isSignificantPublicFile(fn):
        # Update the private shadow file from the public file.
        written = x.propagate_changes(fn,shadow_fn)
        if written: x.message("updated private %s from public %s" % (shadow_fn, fn))
    else:
        # Create the private file from the private shadow file.
        x.copy_file_removing_sentinels(shadow_fn,fn)
        x.message("created public %s from private %s " % (fn, shadow_fn))
</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

__pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        print '\npychecker.checker running...\n'
    except Exception:
        print '\nCan not import pychecker\n'
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.5 b1, build %s, June 28, 2008" % c.getBuildNumber()
</t>
<t tx="ekr.20041005105605.19">def openFileForReading(self,fn,fromString=False,atShadow=False):

    at = self ; trace = True and not g.app.unitTesting ; verbose = False

    if fromString:
        if atShadow:
            return at.error('can not call read(atShadow=True,fromString=aString)')
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))

        if atShadow:
            x = at.c.shadowController
            # readOneAtShadowNode should already have checked these.
            shadow_fn       = x.shadowPathName(fn)
            shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
            # x.updatePublicAndPrivate will create the public file from the private file
            # if the public file exists. This *is* reasonable: there is nothing to import!
            # if not g.os_path_exists(fn):
                # g.trace('oops public',fn,g.callers())
                # return at.error('can not happen: public file does not exist: %s' % (fn))
            if not shadow_exists:
                g.trace('oops private',shadow_fn,g.callers())
                return at.error('can not happen: private file does not exist: %s' % (shadow_fn))
            # This method is the gateway to the essence of the shadow algorithm.
            x.updatePublicAndPrivateFiles(fn,shadow_fn)
            fn = shadow_fn

        try:
            # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
            if trace and verbose and atShadow: g.trace('opening %s file: %s' % (
                g.choose(atShadow,'private','public'),fn))
            at.inputFile = open(fn,'rb')
            at.warnOnReadOnlyFile(fn)
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None

    return at.inputFile # for unit tests.
</t>
<t tx="ekr.20041005105605.21">def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    &lt;&lt; set fileName &gt;&gt;
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString,atShadow=atShadow)
    if not at.inputFile: return False
    if not g.unitTesting:
        g.es("reading:",root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        &lt;&lt; advise user to delete all unvisited nodes &gt;&gt;
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    &lt;&lt; delete all tempBodyStrings &gt;&gt;
    return at.errors == 0
</t>
<t tx="ekr.20041005105605.22">if fromString:
    fileName = "&lt;string-file&gt;"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
</t>
<t tx="ekr.20041005105605.25">for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
</t>
<t tx="ekr.20041005105605.26">def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if not p.headString().startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
</t>
<t tx="ekr.20041005105605.27">def readOpenFile(self,root,theFile,fileName):

    '''Read an open derived file.

    Leo 4.5 and later can only read 4.x derived files.'''

    at = self

    firstLines,read_new,junk = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        # lastLines = at.scanText3(theFile,root,[],at.endLeo)
        lastLines = []
        g.es('can not read 3.x derived file',fileName,color='red')
        g.es('you may upgrade these file using Leo 4.0 through 4.4.x')
        g.trace('root',root and root.headString(),fileName)

    if root:
        root.v.t.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;
</t>
<t tx="ekr.20041005105605.28">try:
    body = root.v.t.tempBodyString
except Exception:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060217111834">@nocolor

.  any char
^  start line
$  end of line
\w alphanum: [a-zA-Z0-9_]
\W non-alphanum
\s whitespace
\S non-whitespace

These can be done with regexps:
    
copy-to-end-of-each-line:   (.)$        --&gt;  \1x
copy-to-start-of-each-line: ^([ \t]+)   --&gt;  \1x
remove-leading-ws:  ^[ \t]+             --&gt;  empty
remove-trailing-ws: [ \t]+$             --&gt;  empty
paste-at-column:    ^(.{4})             --&gt;  \1x
paste-after-lws:    ^([ \t]+)           --&gt;  \1x

(?=...)
    Matches if ... matches next, but doesnt consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match 'Isaac ' only if it's followed by 'Asimov'.

(?!...)
    Matches if ... doesn't match next. This is a negative lookahead assertion. For example, Isaac (?!Asimov) will match 'Isaac ' only if it is not followed by 'Asimov'.

(?&lt;=...)
    Matches if the current position in the string is preceded by a match for ... that ends at the current position. This is called a positive lookbehind assertion. The contained pattern must only match strings of some fixed length, meaning that abc or a|b are allowed, but a* and a{3,4} are not</t>
<t tx="ekr.20060531093331">@
Ever have a clone that is difficult to understand outside the context of its
original parent? Here's some code to help. It displays the headline of the
current node plus the headlines of all the parents of all the clones of the
current node. Selecting a displayed parent headline moves the current node to
the corresponding clone in the outline.

The idea is to be able to quickly see the context of all the clones of the
current node and to be able to easily navigate from one clone instance to the
next.
@c

@others
c.cn = cloneNavigator(c)
c.cn.displayClones(c)
</t>
<t tx="ekr.20060531093331.1">class cloneNavigator:
    '''
       Displays the headline of the current node plus the headlines of
       all the parents of all the clones of the current node.  Selecting
       a displayed parent headline moves the current node to the
       corresponding clone in the outline.
       
       The idea is to be able to quickly see the context of all the clones
       of the current node and to be able to easily navigate from one clone
       instance to the next.
    '''
    @others</t>
<t tx="ekr.20060531093331.2">def __init__ (self,c):
    self.c = c
    import Tkinter as Tk
    if 0:
        f = Tk.Toplevel()
    else:
        log = c.frame.log
        log.selectTab('Clones')
        f = log.tabFrame
        for w in f.winfo_children():
            w.destroy()
    
    # Create and pack empty label and listbox
    self.title = Tk.Label(f)
    self.title.pack(anchor="nw")
    self.lb = Tk.Listbox(f)
    self.lb.pack(expand=1,fill="both")</t>
<t tx="ekr.20060531093331.3">def getAllClones(self,p):
    c = self.c
    def clonesOf(p,p1=p):
        return p.v.t == p1.v.t
    return filter(clonesOf, c.allNodes_iter(copy=True))</t>
<t tx="ekr.20060531093331.4">def displayClones(self,c):
    '''Displays the parent headline for all the clones of the current position'''
    cp = c.currentPosition()
    
    # "Title" is the headline of the current node
    self.title.configure(text=cp.headString())
    
    # Initialize listbox and clone list
    clones = self.getAllClones(cp)
    self.lb.delete(0,self.lb.size()-1)
    
    &lt;&lt;Fill listbox with clone parent headlines&gt;&gt;    
    &lt;&lt;Goto selected position when listbox selection changes&gt;&gt;
</t>
<t tx="ekr.20060531093331.5"># Add the headlines of all the clone parents to the listbox
for p in clones:
    if p.parent():
        text = p.parent().headString()
    else:
        text = "&lt;root&gt;"
    self.lb.insert(self.lb.size(),text)
    
    # Initial listbox selection corresponds to current position
    if p.v == cp.v:
        self.lb.selection_set(self.lb.size()-1)</t>
<t tx="ekr.20060531093331.6"># Callback for when a listbox entry is selected            
def gotoSelectedPosition(event,lb=self.lb,c=c,positions=clones):
    idx = int(lb.curselection()[0])
    p = positions[idx]
    c.frame.tree.expandAllAncestors(p)
    c.selectPosition(p)
    return
self.lb.bind(g.angleBrackets("ListboxSelect"), gotoSelectedPosition)</t>
<t tx="ekr.20060908104329"></t>
<t tx="ekr.20060910141935"></t>
<t tx="ekr.20060910141935.1"># c.k.simulateCommand('read-zodb-file')

path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.readFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20060910141935.2"># c.k.simulateCommand('write-zodb-file')

path = c.fileName()
# path = r'c:\prog\tigris-cvs\leo\test\test2.leo'

if g.os_path_exists(path):
    c.zodbCommands.writeFile()
else:
    g.es_print('not found: %s' % path)</t>
<t tx="ekr.20070605104410"></t>
<t tx="ekr.20070628175250">@color

u = c.undoer
b = u.beforeChangeNodeContents(p)
s = p.bodyString()

result = [' '*4 + line for line in g.splitLines(s)]
result.insert(0,'if g.unitTesting:\n')
s = ''.join(result)
c.setBodyString(p,s)

u.afterChangeNodeContents(p,'add-if-g-unitTesting',b)
</t>
<t tx="ekr.20071001054335"># script to split node containing multiple def's into child nodes

def createChild (parent,body,line):
    p = parent.insertAsLastChild()
    h = line [3:].strip()
    i = h.find('(')
    if i &gt; -1:
        func = h [: i].strip()
    h2 = g.choose(func,func,h)
    p.setHeadString(h2)
    p.setTnodeText(''.join(body))

s = p.bodyString()
if s.strip():
    b = c.undoer.beforeChangeTree(p)
    c.beginUpdate()
    try:
        lines = g.splitLines(s) ; body = [] ; changed = False ; lastDefLine = ''
        for line in lines:
            if g.match_word(line,0,'def'):
                if body and lastDefLine:
                    createChild(p,body,lastDefLine)
                    body = [] ; changed = True
                lastDefLine = line
            body.append(line)
        if body and lastDefLine:
            createChild(p,body,lastDefLine)
            changed = True
        if changed:
            c.setChanged(True) ; c.setBodyString(p,'')
    finally:
        c.undoer.afterChangeTree(p,'split-defs',b)
        c.endUpdate()</t>
<t tx="ekr.20071004062031">print '-'*60
</t>
<t tx="ekr.20071024171346"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.doTests(c,all=False)
c.selectPosition(p,updateBeadList=False)</t>
<t tx="ekr.20071024180738"># You can run unit tests by selecting an outline containing unit tests.

import leoTest

leoTest.runTestsExternally(c,all=False)

</t>
<t tx="ekr.20071105164407">resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.headString(),color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

</t>
<t tx="ekr.20080112145409"></t>
<t tx="ekr.20080121090750"># A script to create @auto nodes from all .py files in a directory.

import glob,os

reallyCreate = True

baseDir = r'c:\Python25\Lib\site-packages\pubsub'
baseDir = r'C:\Program Files\Komodo Edit 4.3\lib\mozilla\python\komodo\codeintel2'
dirs = ('',) #'Extensions','UserConfig',)
print '-----'

c.beginUpdate()
try:
    for theDir in dirs:
        pattern = g.os_path_join(baseDir,theDir,'*.py')
        files = glob.glob(pattern)
        print pattern
        # print g.listToString(files)
        for name in files:
            h = '@auto %s' % (name[len(baseDir) + 1:].strip())
            print 'creating',h
            if reallyCreate:
                child = p.insertAsLastChild()
                child.initHeadString(h)
finally:
    c.endUpdate()
</t>
<t tx="ekr.20080121091513">c.importCommands.createOutline(
    fileName=None,
    parent=p,
    atAuto=True,
    s=p.bodyString(),ext='.py')


</t>
<t tx="ekr.20080121092503"></t>
<t tx="ekr.20080220082617">@first # -*- coding: utf-8 -*-

# To do: put list of to-be-translated strings in a doc part.

&lt;&lt; docstring &gt;&gt;
&lt;&lt; version history &gt;&gt;

class controllerClass:
    @others

x = controllerClass(c,p)
x.main()
</t>
<t tx="ekr.20080220082617.1">'''Here is a cute Leo script. It discovers all g.es statements and the unbound
variables in those statements in a single pass over the selected outline. It
then puts the decls followed by the statements in the body text of the @scan_g.es_results node.

Thus, after this script, you can **execute** the body text of the @scan_g.es_results node.
In particular, assuming that g.translateString converts all translated text to upper case,
it is easy to tell which strings have been translated.
'''</t>
<t tx="ekr.20080220082617.2">@nocolor
@

2008/2/19 EKR: Initial 2-pass version.
2008/2/20 EKR:
- Convert to single-pass using decls and statements arrays.
- Add 'tabName' to list of keyword arguments.
- Fixed various bugs.
2008/2/20 EKR 2:
- Generate g.es statements to inicate beginnings of files.
  This allows us to execute all generated statements at once.
- Convert between '.' and '__' as needed to avoid using real ivars.
2008/2/21 EKR:
- Added mungeString.
- Rewrote mungeStatements, scanParens and scanIdChain.
These changes now properly handle all arguments.
2008/2/21 EKR 2:
- Added stringize and related logic.
- Added setToBeTranslated to put list of to-be-translated strings into leading docstring.</t>
<t tx="ekr.20080220082617.3">def __init__ (self,c,p):

    self.c = c
    self.p = p

    self.decls = {}
    self.keywordArgs = ('color','commas','newline','spaces','tabName',)
    self.nodeName = '@scan_g.es_results'
    self.statements = []
    self.printStatements = ('g.es','g.es_print',)
    self.suppressTranslation = False # True: keyword arg to g.es seen.
    self.toBeTranslated = []
    self.traceFlag = False

    self.root = g.findNodeAnywhere(c,self.nodeName)
</t>
<t tx="ekr.20080220082617.4">def error (self,s):

    self.statements.append('***error: %s' % s)

def trace(self,s):

    if self.traceFlag:
        self.statements.append(s)
</t>
<t tx="ekr.20080220082617.5">def main (self):

    '''The main line.'''

    c = self.c
    self.scan()
    self.mungeStatements()
    keys = self.decls.keys()
    keys.sort()
    # This is such a great hack :-)
    decls = ["%s = '%s'" % (self.mungeString(z),self.stringize(z,delim="'")) for z in keys]

    # Put to-be-translated.
    results = ['@ To be translated...',]
    self.toBeTranslated.sort()
    results.extend(self.toBeTranslated)
    results.extend(['@c',])
    # Put decls.
    results.extend(['# Decls...',])
    results.extend(["color='red'","newline=True","tabName='Log'"])
    results.extend(decls)
    # Put statements
    results.extend(["g.app.translateToUpperCase=True",])
    results.extend(self.statements)
    results.extend(["g.app.translateToUpperCase=False",])

    results = '\n'.join(results)

    # Put the results in the root node, or print them.
    if self.root:
        c.setBodyString(self.root,results)
        c.beginUpdate()
        try:
            c.selectPosition(self.root)
        finally:
            c.endUpdate()
    else:
        print 'node not found',self.rootName
        print results

    g.es('done')
</t>
<t tx="ekr.20080220082617.6">def scan(self):


    for p in self.p.self_and_subtree_iter():

        self.scanNode(p)</t>
<t tx="ekr.20080220082617.8">def scanParens(self,s,i,outer):

    '''Scan a parenthesized list of args.'''

    assert g.match(s,i,'(')
    j = g.skip_matching_python_parens(s,i)
    if j == -1:
        self.error('**incomplete paren at: %s' % s[i:])
        return i+1 # Just skip the paren

    assert g.match(s,j,')')
    n = 1
    while i &lt; j:
        progress = i ; ch = s[i]

        if ch in ("'",'"',):
            i = self.scanStringArg(s,i,n,outer)
            n += 1

        elif g.is_c_id(ch):
            i = self.scanIdChain(s,i,outer)
            n += 1

        i = max(i,progress+1)

    return j + 1 # return the character after the paren.
</t>
<t tx="ekr.20080220082617.9">def scanNode(self,p):

    tags = ('g.es','g.es_print',)
    s,h = p.bodyString(), p.headString()
    print_h = True

    if h.startswith('@thin'):
        &lt;&lt; insert statements highlighting the @thin node &gt;&gt;

    i = 0
    while i &lt; len(s):
        progress = i
        for tag in tags:
            if g.match_word(s,i,tag):
                start = i ; i += len(tag)
                self.suppressTranslation = False
                i = g.skip_ws(s,i)
                if g.match(s,i,'('):
                    &lt;&lt; Insert a comment containing the headline &gt;&gt;
                    i = self.scanParens(s,i,outer=True)
                    statement = s[start:i]
                    if statement.find('*arg') == -1 and statement.find('**key') == -1:
                        self.statements.append(statement)
                break
        i = max(i,progress+1)
</t>
<t tx="ekr.20080220082617.10">def setDecl (self,s):

    s = s.strip()

    if s in ('c','g','p','len','str','repr','and','or','not','is',):
        return # Don't need a binding for these.

    if s in ('color','newline','tabName',):
        return # Special binding will be used for these.

    if s.isdigit():
        return # Don't bind integers.

    self.decls[s] = True
</t>
<t tx="ekr.20080220093930">def mungeHeadline (self,s):

    s = s.strip()
    s = s.replace('&lt;&lt;','&lt; &lt;')
    s = s.replace('&gt;&gt;','&gt; &gt;')
    return s
</t>
<t tx="ekr.20080220182141">def scanIdChain (self,s,i,outer):

    assert g.is_c_id(s[i])
    start = i 

    while i &lt; len(s):
        progress = i
        # Skip a.b.c...
        if not g.is_c_id(s[i]): break
        i = g.skip_id(s,i,chars='.')
        i = g.skip_ws(s,i)
        word = s[start:i].strip()
        if outer and g.match(s,i,'=') and word in (self.keywordArgs):
            # g.trace('***','=',word)
            self.suppressTranslation = True
        # Only a paren is valid now.
        if not g.match(s,i,'('): break
        # We shall munge the entire paren expression.
        i = g.skip_matching_python_parens(s,i)
        if g.match(s,i,')'): i += 1
        # Only a dot is valid now.
        if not g.match(s,i,'.'): break
        i += 1
        assert i &gt; progress

    self.setDecl(s[start:i])
    return i
</t>
<t tx="ekr.20080220183819">def scanStringArg(self,s,i,n,outer):

    '''Skip a string, and possible %'''

    j = g.skip_python_string(s,i)
    if j &lt;= i: return i

    # g.trace(n,s[i:j])

    if outer:
        self.setToBeTranslated(s[i:j],n)

    i = g.skip_ws(s,j)
    if not g.match(s,i,'%'):
        return i

    # Handle what follows the '%'
    i = g.skip_ws(s,i+1)

    if g.match(s,i,'('):
        i = self.scanParens(s,i,outer=False)
    elif i &lt; len(s) and g.is_c_id(s[i]):
        i = self.scanIdChain(s,i,outer)

    return i
</t>
<t tx="ekr.20080221071308">def mungeString (self,s):

    '''Convert string s so that it is a valid Python name.'''

    s = s.strip()
    # s = s.replace('@','_AT_')
    # s = s.replace('&lt;','_LT_')
    # s = s.replace('&gt;','_GT_')
    s = s.replace(',','_COMMA_')
    s = s.replace('.','_DOT_')
    s = s.replace('()','_PARENS_')
    s = s.replace('(','_LP_')
    s = s.replace(')','_RP_')
    s = s.replace('"','_DQ_')
    s = s.replace("'",'_SQ_')
    s = ''.join([g.choose(z == '_' or z.isalnum(),z,'_') for z in s])
    return s
</t>
<t tx="ekr.20080221071734">self.statements.append('# ---- %s' % (h))
self.statements.append("g.es_print('','%s %s',color='red')" % ('-'*20,h))</t>
<t tx="ekr.20080221071734.1">if print_h:
    print_h = False
    if not h.startswith('@thin'):
        self.statements.append('# -- node %s' % (self.mungeHeadline(h)))</t>
<t tx="ekr.20080221073909">def mungeStatements (self):

    '''Convert a references to an known id chain by the corresponding decl.'''

    keys = self.decls.keys()
    for tag in self.printStatements:
        if tag in keys: keys.remove(tag)

    results = []
    for s in self.statements:
        i = 0 ; inner_result = []
        while i &lt; len(s):
            progress = i
            for key in keys:
                if g.match_word(s,i,key):
                    inner_result.append(self.mungeString(key))
                    i += len(key)
                    break
            else:
                inner_result.append(s[i])
            i = max(i,progress+1)
        new_statement = ''.join(inner_result)
        if new_statement != s:
            # Add the original lines as comments.
            for z in g.splitLines(s):
                results.append ('# %s' % (z.rstrip()))
        results.append(new_statement) # Add the munged line.

    self.statements = results

</t>
<t tx="ekr.20080221101728"></t>
<t tx="ekr.20080221101728.1">def stringize (self,s,delim):

    s = s.strip()
    s = s.replace(delim,'\\%s' % (delim))
    return s
</t>
<t tx="ekr.20080221110301">def setToBeTranslated (self,s,n):


    s = s.strip()

    if s.startswith('"') or s.startswith("'"):
        s = s[1:]
    if s.endswith('"') or s.endswith("'"):
        s = s[:-1]

    s = s.strip()

    # Suppress translation when a keyword is seen, regardless of position.
    if s in self.keywordArgs:
        self.suppressTranslation = True

    if self.suppressTranslation:
        # g.trace('not added',s)
        return

    if (n % 2) == 1 and s not in self.toBeTranslated:
        self.toBeTranslated.append(s)
</t>
<t tx="ekr.20080312060129.5"></t>
<t tx="ekr.20080312060129.6"></t>
<t tx="ekr.20080412053100.4"></t>
<t tx="ekr.20080412053100.5"></t>
<t tx="ekr.20080708094444.27">def copy_file_removing_sentinels (self,source_fn,target_fn):

    '''Copies sourcefilename to targetfilename, removing sentinel lines.'''

    x = self ; marker = x.marker_from_extension(source_fn)

    old_lines = file(source_fn).readlines()
    new_lines, junk = x.separate_sentinels(old_lines,marker)

    copy = not os.path.exists(target_fn) or old_lines != new_lines
    if copy:
        s = ''.join(new_lines)
        x.replaceFileWithString(target_fn,s)
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):

    '''Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)'''

    x = self

    old_public_lines  = file(old_public_file).readlines()
    old_private_lines = file(old_private_file).readlines()
    marker = x.marker_from_extension(old_public_file)

    new_private_lines = x.propagate_changed_lines(
        old_public_lines,
        old_private_lines,
        marker)

    fn = old_private_file
    copy = not os.path.exists(fn) or new_private_lines != old_private_lines

    if copy:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(fn,s)

    return copy
</t>
<t tx="ekr.20080708094444.53"></t>
<t tx="ekr.20080708094444.54"></t>
<t tx="ekr.20080708094444.55">def putInHooks ():
    """Modify methods in Leo's core to support this plugin."""

    # Need to modify Leo's Kernel first
    # Overwrite existing Leo methods.
    g.funcToMethod(replaceTargetFileIfDifferent,leoAtFile.atFile)
    g.funcToMethod(massageComment,leoImport.leoImportCommands)

    # Add new methods used by this plugin to various classes.
    g.funcToMethod(openForRead,leoAtFile.atFile)
    g.funcToMethod(openForWrite,leoAtFile.atFile)
    g.funcToMethod(gotoLineNumberOpen,leoCommands.Commands)
    g.funcToMethod(applyLineNumberMappingIfAny, leoCommands.Commands)
</t>
<t tx="ekr.20080708094444.56">def applyConfiguration (config=None):

    """Called when the user presses the "Apply" button on the Properties form.

    Not sure yet if we need configuration options for this plugin."""

    if config is None:
        fileName = os.path.join(g.app.loadDir,"..","plugins","mod_shadow.ini")
        if os.path.exists(fileName):
            config = ConfigParser.ConfigParser()
            config.read(fileName)
    if config:
        mod_shadow_core.active = config.getboolean("Main","Active")
        mod_shadow_core.testing = config.getboolean("Main", "testing")
        mod_shadow_core.verbosity = config.getint("Main", "verbosity")
        mod_shadow_core.prefix = config.get("Main", "prefix")
        mod_shadow_core.print_copy_operations = config.get("Main", "print_copy_operations")
        mod_shadow_core.shadow_subdir = config.get("Main", "shadow_subdir")</t>
<t tx="ekr.20080708094444.57">def check_for_shadow_file (self,filename):
    """
    Check if there is a shadow file for filename.
    Return:
        - the name of the shadow file,
        - an indicator if the file denoted by 'filename' is
        of zero length.
    """
    dir, simplename = os.path.split(filename)
    rootname, ext = os.path.splitext(simplename)
    if ext=='.tmp':
        shadow_filename = os.path.join(dir, mod_shadow_core.shadow_subdir, mod_shadow_core.prefix + rootname)
        if os.path.exists(shadow_filename):
            resultname = os.path.join(dir, mod_shadow_core.shadow_subdir, mod_shadow_core.prefix + simplename)
            return resultname, False 
        else:
            return '', False 
    else:
        shadow_filename = os.path.join(dir,mod_shadow_core.shadow_subdir,mod_shadow_core.prefix + simplename)
        if os.path.exists(shadow_filename):
            return shadow_filename, os.path.getsize(filename)&lt;= 2
        else:
            return '', False </t>
<t tx="ekr.20080708094444.58">def getVerbosity (c):

    verbosity = c.config.getInt('shadow_verbose')
    if verbosity is None: verbosity = 1
    return verbosity</t>
<t tx="ekr.20080708094444.59">def marker_from_extension(filename):
    return g.comment_delims_from_extension(filename)[0] + "@"</t>
<t tx="ekr.20080708094444.60"></t>
<t tx="ekr.20080708094444.61"></t>
<t tx="ekr.20080708094444.62"></t>
<t tx="ekr.20080708094444.63">def gotoLineNumberOpen (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -&gt; real file number.
    """
    try:
        c = self ; x = c.shadowController
        theDir, simplename = os.path.split(filename)
        shadow_filename = os.path.join(theDir,x.shadow_subdir,x.shadow_prefix + simplename)
        if os.path.exists(shadow_filename):
            lines = file(shadow_filename).readlines()
            c.line_mapping = x.push_filter_mapping(
                lines, x.marker_from_extension(shadow_filename))
        else:
            c.line_mapping = []
            lines = file(filename).readlines()
        return lines 
    except:
        # Make sure failures to open a file generate clear messages.
        g.es_exception()
        raise</t>
<t tx="ekr.20080708094444.64"></t>
<t tx="ekr.20080708094444.65">def applyLineNumberMappingIfAny(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) &gt; n:
        return x.line_mapping[n]
    else:
        return n

    # if hasattr(self,'line_mapping') and self.line_mapping:
        # return self.line_mapping[n]
    # else:
        # return n</t>
<t tx="ekr.20080708094444.67"># We must patch in two places:
# -When the temporary file is written(openWriteFile)
# -When Leo renames the file(replaceTargetFileIfDifferent).

def replaceTargetFileIfDifferent (self,root):

    # Check if we are dealing with a shadow file
    try:
        c = self.c ; x = c.shadowController
        targetFileName = self.targetFileName 
        outputFileName = self.outputFileName
        if self.writing_to_shadow_directory:
            self.targetFileName = self.shadow_filename 
            self.outputFileName = self.shadow_filename+'.tmp'

        if original_replaceTargetFileIfDifferent(self,root):
            if self.writing_to_shadow_directory:
                x.message("Updating file from shadow folder: %s" % x.shadow_subdir)
                x.copy_file_removing_sentinels(self.shadow_filename,targetFileName)
    finally:
        # if self.writing_to_shadow_directory:
            # assert self.targetFileName == self.shadow_filename 
            # assert self.outputFileName == self.shadow_filename+'.tmp'
        # else:
            # assert self.targetFileName == targetFileName
            # assert self.outputFileName == outputFileName
        self.targetFileName = targetFileName
        self.outputFileName = outputFileName
</t>
<t tx="ekr.20080708094444.68"></t>
<t tx="ekr.20080708094444.79">def __init__ (self,c,trace=False,trace_writers=False):

    self.c = c

    # self.print_copy_operations = False   # (not used) Tsrue: tell when files are copied.
    # self.do_backups = False              # (Not used) True: always make backups of each file.

    # Configuration...
    self.shadow_subdir = c.config.getString('shadow_subdir') or 'LeoFolder'
    self.shadow_prefix = c.config.getString('shadow_prefix') or ''

    # Debugging...
    self.trace = trace
    self.trace_writers = trace_writers  # True: enable traces in all sourcewriters.

    # Error handling...
    self.errors = 0
    self.last_error  = '' # The last error message, regardless of whether it was actually shown.

    # Support for goto-line-number.
    self.line_mapping = []

</t>
<t tx="ekr.20080708094444.81"></t>
<t tx="ekr.20080708094444.87"></t>
<t tx="ekr.20080708094444.88"></t>
<t tx="ekr.20080710082231.4">"""
Look for @thin files in the current subtree.
Convert those thin files into a file with a shadow file,
if this shadow file does not exist already.

FIXME: the line end convention is currently changed:
      unix lineendings are converted to DOS lineendings,
      if files are converted on Windows.
      Not sure if that is a probem or not.
"""

x = c.shadowController

for p in p.self_and_subtree_iter():
    h = p.headString() ; tag = '@shadow'
    if h.startswith(tag):
        filename = h[len(tag):].strip()
        x.makeShadowFile(filename)
</t>
<t tx="ekr.20080710082231.19">def makeShadowDirectory (self,fn):

    '''Make a shadow directory for the **public** fn.'''

    x = self ; path = x.shadowDirName(fn)

    if not g.os_path_exists(path):

        try:
            # g.trace('making',path)
            os.mkdir(path)
        except Exception:
            x.error('unexpected exception creating %s' % path)
            g.es_exception()
            return False

    return g.os_path_exists(path) and g.os_path_isdir(path)
</t>
<t tx="ekr.20080711063656.1"></t>
<t tx="ekr.20080711063656.2">def rename (self,src,dst,mode=None,silent=False):

    x = self ; c = x.c

    ok = g.utils_rename (c,src,dst,mode=mode,verbose=not silent)
    if not ok:
        x.error('can not rename %s to %s' % (src,dst),silent=silent)

    return ok
</t>
<t tx="ekr.20080711063656.3">def unlink (self, filename,silent=False):

    '''Unlink filename from the file system.
    Give an error on failure.'''

    x = self

    ok = g.utils_remove(filename, verbose=not silent)
    if not ok:
        x.error('can not delete %s' % (filename),silent=silent)

    return ok
</t>
<t tx="ekr.20080711063656.4">def dirName (self,filename):

    '''Return the directory for filename.'''

    x = self

    return g.os_path_dirname(x.pathName(filename))

def pathName (self,filename):

    '''Return the full path name of filename.'''

    x = self ; theDir = x.baseDirName()

    return theDir and g.os_path_abspath(g.os_path_join(theDir,filename))</t>
<t tx="ekr.20080711063656.6">def shadowDirName (self,filename):

    '''Return the directory for the shadow file corresponding to filename.'''

    x = self

    return g.os_path_dirname(x.shadowPathName(filename))

def shadowPathName (self,filename):

    '''Return the full path name of filename, resolved using c.fileName()'''

    x = self ; baseDir = x.baseDirName()
    fileDir = g.os_path_dirname(filename)
    # g.trace(baseDir)
    # g.trace(x.shadow_subdir)
    # g.trace(fileDir)

    return baseDir and g.os_path_abspath(g.os_path_normpath(g.os_path_join(
            baseDir,
            fileDir, # Bug fix: honor any directories specified in filename.
            x.shadow_subdir,
            x.shadow_prefix + g.shortFileName(filename))))</t>
<t tx="ekr.20080711063656.7">def baseDirName (self):

    x = self ; filename = x.c.fileName()

    if filename:
        return g.os_path_dirname(g.os_path_abspath(filename))
    else:
        self.error('Can not compute shadow path: .leo file has not been saved')
        return None</t>
<t tx="ekr.20080711093251.7">def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = g.os_path_abspath(g.os_path_normpath(g.os_path_join(at.default_directory,fn)))
    shadow_fn       = x.shadowPathName(fn)
    shadow_exists   = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # significant     = x.isSignificantPublicFile(fn)

    if shadow_exists:
        # x.updatePublicAndPrivateFiles creates the public file if it does not exist.
        at.read(p,atShadow=True) # Calls x.updatePublicAndPrivateFiles
    else:
        if not g.unitTesting: g.es("reading:",p.headString())
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # x.makeShadowFile(fn,p)
            at.writeOneAtShadowNode(p,toString=False,force=True)
</t>
<t tx="ekr.20080712080505.1">def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
</t>
<t tx="ekr.20080712080505.3">def isSignificantPublicFile (self,fn):

    '''This tells the atFile.read logic whether to import a public file or use an existing public file.'''

    return g.os_path_exists(fn) and g.os_path_isfile(fn) and g.os_path_getsize(fn) &gt; 10
</t>
<t tx="ekr.20080713091247.1">def replaceFileWithString (self,fn,s):

    '''Replace the file with s if s is different from theFile's contents.

    Return True if theFile was changed.
    '''

    x = self ; testing = g.app.unitTesting

    exists = g.os_path_exists(fn)

    if exists: # Read the file.  Return if it is the same.
        try:
            f = file(fn,'rb')
            s2 = f.read()
            f.close()
        except IOError:
            x.error('unexpected exception creating %s' % fn)
            g.es_exception()
            return False
        if s == s2:
            if not testing: g.es('unchanged:',fn)
            return False

    # Replace the file.
    try:
        f = file(fn,'wb')
        f.write(s)
        f.close()
        if not testing:
            if exists:  g.es('wrote:    ',fn)
            else:       g.es('created:  ',fn)
        return True
    except IOError:
        x.error('unexpected exception writing file: %s' % (fn))
        g.es_exception()
        return False
</t>
</tnodes>
</leo_file>
