<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20150531102337.1"><vh>@bool tidy-keep-blank-lines = False</vh></v>
<v t="ekr.20150617060607.1"><vh>@bool tidy_autobeautify = False</vh></v>
<v t="ekr.20150425145248.1"><vh>@data history-list</vh></v>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20160122104332.1"><vh>Buttons</vh>
<v t="ekr.20180324065741.1"><vh>@@button copy-to-next</vh></v>
<v t="ekr.20150507170849.1"><vh>@@button create decorators</vh>
<v t="ekr.20150508063538.1"><vh>create_d</vh></v>
<v t="ekr.20150508071622.1"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150508063412.1"><vh>create_decorators</vh></v>
<v t="ekr.20150508074623.1"><vh>create_fixups</vh></v>
<v t="ekr.20150508063926.1"><vh>find_class</vh></v>
<v t="ekr.20150507174711.1"><vh>find_next_clone</vh></v>
<v t="ekr.20150507175246.1"><vh>munge_lines</vh></v>
<v t="ekr.20150508062944.1"><vh>run</vh></v>
</v>
<v t="ekr.20150509183433.1"><vh>@@button make-decorators2</vh>
<v t="ekr.20150509183433.2"><vh>create_d</vh></v>
<v t="ekr.20150509183433.3"><vh>create_decorator (@button)</vh></v>
<v t="ekr.20150509183433.4"><vh>create_decorators V2</vh></v>
<v t="ekr.20150509183832.1"><vh>define_s</vh></v>
<v t="ekr.20150509183433.8"><vh>munge_lines</vh></v>
<v t="ekr.20150509183433.9"><vh>run V2</vh></v>
</v>
<v t="ekr.20150703061709.1"><vh>@@button run-pylint</vh></v>
<v t="ekr.20180824065751.1"><vh>@@button show-gnx</vh></v>
<v t="ekr.20131121084830.16362"><vh>@@button toggle-debug</vh></v>
<v t="ekr.20150502050609.1"><vh>@button backup</vh></v>
<v t="ekr.20170811173924.1"><vh>@button backup-repo</vh></v>
<v t="ekr.20150413091056.1"><vh>@button check-clones</vh></v>
</v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20160425070345.1"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20160425070345.2"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20160420054135.4"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20160420054135.5"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20150604130353.1"><vh>@data:@auto test/unit_tests.py</vh>
<v t="ekr.20150604130353.2"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20170427114412.1"><vh>scripts</vh>
<v t="ekr.20170427112302.1"><vh>check leoPy.leo</vh></v>
<v t="ekr.20170428084123.1"><vh>Recursive import script</vh>
<v t="ekr.20170428084123.2"><vh>&lt;&lt; old dir_ settings &gt;&gt;</vh></v>
</v>
<v t="ekr.20180816105258.1"><vh>script: diff-branches</vh></v>
<v t="ekr.20181102040815.1"><vh>script: warn about long lines</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20190122185223.1"><vh>regex: find all kwargs</vh></v>
<v t="ekr.20170302123956.1"><vh>@file ../doc/leoAttic.txt</vh></v>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20190116145049.1"><vh>To do</vh>
<v t="ekr.20190116145036.1"><vh>To do: No milestone</vh>
<v t="ekr.20181027151243.1"><vh>#1006: Allow @button and @command only from trusted directories</vh>
<v t="ekr.20181027133311.1"><vh>g.issueSecurityWarning</vh></v>
<v t="ekr.20140114145953.16691"><vh>c.config.isLocalSetting</vh></v>
<v t="ekr.20150514043850.8"><vh>abbrev.init_settings (called from reload_settings)</vh></v>
</v>
<v t="ekr.20180604114211.408"><vh>#388: wikiview.py plugin problem</vh></v>
<v t="ekr.20180604114156.2"><vh>#433: Complete the tables.py plugin</vh>
<v t="ekr.20180604114156.3"><vh>Error running the demo on Windows 10</vh></v>
</v>
<v t="ekr.20180604114211.561"><vh>#678: Graphics version of outline pane</vh></v>
<v t="ekr.20180619063409.1"><vh>#929: Improve FreeMind importer</vh>
<v t="ekr.20160503145550.1"><vh>class FreeMindImporter</vh>
<v t="ekr.20170222084048.1"><vh>freemind.add_children</vh></v>
<v t="ekr.20160503125844.1"><vh>freemind.create_outline</vh></v>
<v t="ekr.20160503191518.4"><vh>freemind.import_file</vh></v>
<v t="ekr.20160503145113.1"><vh>freemind.import_files</vh></v>
<v t="ekr.20160504043823.1"><vh>freemind.prompt_for_files</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>About widgets and wrappers</vh></v>
<v t="ekr.20140831085423.18630"><vh>Terminology</vh></v>
<v t="ekr.20140831085423.18631"><vh>Official ivars</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20150323150718.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20161026193447.1"><vh>@file leoBackground.py</vh></v>
<v t="ekr.20150521115018.1"><vh>@file leoBeautify.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20150605175037.1"><vh>@file leoCheck.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810" descendentVnodeUnknownAttributes="7d7100580c000000302e312e31312e322e352e3771017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323031382d30382d313871077573732e"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20180212072657.2"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20130302121602.10208"><vh>@file leoDebugger.py</vh></v>
<v t="ekr.20160306114544.1"><vh>@file leoExternalFiles.py</vh></v>
<v t="ekr.20181202062518.1"><vh>@file leoFastRedraw.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31382e3171017d71025808000000616e6e6f7461746571037d710473732e"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20150514154159.1"><vh>@file leoHistory.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20150419124739.1"><vh>@file leoPrinting.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285805000000302e332e3071017d71022858090000007374725f6374696d657103580c000000313331393439313330362e30710458090000007374725f6d74696d657105580d000000313331393439323330312e3532710658090000007374725f6174696d657107580d000000313331393534393339302e38397108755805000000302e332e3171097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313331393436373033382e3235710e58090000007374725f6174696d65710f580c000000313332303432323637302e397110755805000000302e332e3271117d71122858090000007374725f6374696d657113580c000000313331393436303438332e30711458090000007374725f6d74696d657115580d000000313331393436373035302e3438711658090000007374725f6174696d657117580d000000313331393436373035302e34387118755805000000302e332e3371197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313332303432323639302e3534711e58090000007374725f6174696d65711f580d000000313332303433343235372e33367120755805000000302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755805000000302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20180121041003.1"><vh>@file leoTips.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20150514035207.1"><vh>Command classes</vh>
<v t="ekr.20150514035236.1"><vh>@file ../commands/abbrevCommands.py</vh></v>
<v t="ekr.20150514035943.1"><vh>@file ../commands/baseCommands.py</vh></v>
<v t="ekr.20150514035559.1"><vh>@file ../commands/bufferCommands.py</vh></v>
<v t="ekr.20161021090740.1"><vh>@file ../commands/checkerCommands.py</vh></v>
<v t="ekr.20171123135539.1"><vh>@file ../commands/commanderEditCommands.py</vh></v>
<v t="ekr.20171123095353.1"><vh>@file ../commands/commanderFileCommands.py</vh></v>
<v t="ekr.20171124072110.1"><vh>@file ../commands/commanderFindCommands.py</vh></v>
<v t="ekr.20171124073126.1"><vh>@file ../commands/commanderHelpCommands.py</vh></v>
<v t="ekr.20171124080430.1"><vh>@file ../commands/commanderOutlineCommands.py</vh></v>
<v t="ekr.20150514040100.1"><vh>@file ../commands/controlCommands.py</vh></v>
<v t="ekr.20160316095222.1"><vh>@file ../commands/convertCommands.py</vh></v>
<v t="ekr.20150514040118.1"><vh>@file ../commands/debugCommands.py</vh></v>
<v t="ekr.20150514035813.1"><vh>@file ../commands/editCommands.py</vh></v>
<v t="ekr.20150514041209.1"><vh>@file ../commands/editFileCommands.py</vh></v>
<v t="ekr.20150624112334.1"><vh>@file ../commands/gotoCommands.py</vh></v>
<v t="ekr.20150514040138.1"><vh>@file ../commands/helpCommands.py</vh></v>
<v t="ekr.20150514040140.1"><vh>@file ../commands/keyCommands.py</vh></v>
<v t="ekr.20150514040142.1"><vh>@file ../commands/killBufferCommands.py</vh></v>
<v t="ekr.20150514040146.1"><vh>@file ../commands/rectangleCommands.py</vh></v>
<v t="ekr.20150514040239.1"><vh>@file ../commands/spellCommands.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20171031111403.1"><vh>Leo Edit Pane</vh>
<v t="tbrown.20171029210211.1"><vh>@file ../plugins/editpane/clicky_splitter.py</vh></v>
<v t="tbrown.20171028115144.6"><vh>@file ../plugins/editpane/editpane.py</vh></v>
<v t="tbrown.20171028115144.5"><vh>@file ../plugins/editpane/leotextedit.py</vh></v>
<v t="tbrown.20171028115144.4"><vh>@file ../plugins/editpane/markdownview.py</vh></v>
<v t="tbrown.20171028115144.3"><vh>@file ../plugins/editpane/pandownview.py</vh></v>
<v t="tbrown.20171028115144.2"><vh>@file ../plugins/editpane/plaintextedit.py</vh></v>
<v t="tbrown.20171028115144.1"><vh>@file ../plugins/editpane/plaintextview.py</vh></v>
<v t="tbrown.20171028115143.3"><vh>@file ../plugins/editpane/vanillascintilla.py</vh></v>
<v t="tbrown.20171028115143.2"><vh>@file ../plugins/editpane/webengineview.py</vh></v>
<v t="tbrown.20171028115143.1"><vh>@file ../plugins/editpane/webkitview.py</vh></v>
<v t="tbrown.20171028115144.8"><vh>@file ../plugins/editpane/__init__.py</vh></v>
<v t="tbrown.20171028115541.1"><vh>@file signal_manager.py</vh></v>
</v>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20161223152017.1"><vh>@edit ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20161223152353.1"><vh>@edit ../plugins/qt_quicksearch_sub.py</vh></v>
</v>
<v t="ekr.20180225010644.1"><vh>Other files</vh>
<v t="ekr.20180225010707.1"><vh>In leo-editor directory</vh>
<v t="maphew.20180224170853.1"><vh>@file ../../setup.py</vh></v>
<v t="ekr.20150304125314.4"><vh>@clean ../../leo_to_html.xsl</vh>
<v t="ekr.20150304130753.5"><vh>&lt;&lt;style&gt;&gt;</vh></v>
<v t="ekr.20150304130753.6"><vh>&lt;&lt;scripts&gt;&gt;</vh></v>
</v>
<v t="ekr.20181009072707.1"><vh>@clean ../../run_travis_unit_tests.py</vh>
<v t="ekr.20181009084156.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20181009084245.1"><vh>&lt;&lt; compute path &gt;&gt;</vh></v>
<v t="ekr.20181009084323.1"><vh>&lt;&lt; run tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20160124165611.1"><vh>@file ../../launchLeo-unified.spec</vh></v>
<v t="ekr.20181014073705.1"><vh>@file ../../run_pytest_tests.py</vh></v>
<v t="ekr.20150304130753.4"><vh>leo-viewer/leo_to_html.xsl</vh></v>
</v>
<v t="ekr.20180225010913.1"><vh>In leo/core</vh>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py</vh></v>
</v>
<v t="ekr.20180225010743.1"><vh>In leo/external</vh>
<v t="ekr.20160123142722.1"><vh>@clean ../external/make_stub_files.cfg</vh></v>
<v t="ekr.20180708145905.1"><vh>@clean ../external/py2cs_theory.md</vh>
<v t="ekr.20180708152000.1"><vh>The problem</vh></v>
<v t="ekr.20180708152018.1"><vh>Design</vh></v>
<v t="ekr.20180708145905.6"><vh>Using TokenSync class</vh></v>
<v t="ekr.20180708145905.7"><vh>Summary</vh></v>
</v>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ekr.20170429161422.1"><vh>@file ../external/log_broadcast.py</vh></v>
<v t="ekr.20170429153135.1"><vh>@file ../external/log_listener.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20160317054700.1"><vh>@file ../external/make_stub_files.py</vh></v>
<v t="ekr.20160316091132.1"><vh>@file ../external/py2cs.py</vh></v>
<v t="ekr.20170428085201.1"><vh>npyscreen</vh>
<v t="ekr.20170428084207.3"><vh>@file ../external/npyscreen/apNPSApplication.py</vh></v>
<v t="ekr.20170428084207.11"><vh>@file ../external/npyscreen/apNPSApplicationAdvanced.py</vh></v>
<v t="ekr.20170428084207.15"><vh>@file ../external/npyscreen/apNPSApplicationEvents.py</vh></v>
<v t="ekr.20170428084207.29"><vh>@file ../external/npyscreen/apNPSApplicationManaged.py</vh></v>
<v t="ekr.20170428084207.50"><vh>@file ../external/npyscreen/apOptions.py</vh></v>
<v t="ekr.20170428084207.111"><vh>@file ../external/npyscreen/eveventhandler.py</vh></v>
<v t="ekr.20170428084207.121"><vh>@file ../external/npyscreen/fmActionForm.py</vh></v>
<v t="ekr.20170428084207.131"><vh>@file ../external/npyscreen/fmActionFormV2.py</vh></v>
<v t="ekr.20170428084207.153"><vh>@file ../external/npyscreen/fmFileSelector.py</vh></v>
<v t="ekr.20170428084207.174"><vh>@file ../external/npyscreen/fmForm.py</vh></v>
<v t="ekr.20170428084207.223"><vh>@file ../external/npyscreen/fmFormMultiPage.py</vh></v>
<v t="ekr.20170428084207.248"><vh>@file ../external/npyscreen/fmFormMutt.py</vh></v>
<v t="ekr.20170428084207.258"><vh>@file ../external/npyscreen/fmFormMuttActive.py</vh></v>
<v t="ekr.20170428084207.285"><vh>@file ../external/npyscreen/fmFormWithMenus.py</vh></v>
<v t="ekr.20170428084207.303"><vh>@file ../external/npyscreen/fmPopup.py</vh></v>
<v t="ekr.20170428084207.311"><vh>@file ../external/npyscreen/fm_form_edit_loop.py</vh></v>
<v t="ekr.20170428084207.322"><vh>@file ../external/npyscreen/globals.py</vh></v>
<v t="ekr.20170428084207.324"><vh>@file ../external/npyscreen/muMenu.py</vh></v>
<v t="ekr.20170428084207.332"><vh>@file ../external/npyscreen/muNewMenu.py</vh></v>
<v t="ekr.20170428084207.351"><vh>@file ../external/npyscreen/npysGlobalOptions.py</vh></v>
<v t="ekr.20170428084207.353"><vh>@file ../external/npyscreen/npysNPSFilteredData.py</vh></v>
<v t="ekr.20170428084207.364"><vh>@file ../external/npyscreen/npyspmfuncs.py</vh></v>
<v t="ekr.20170428084207.370"><vh>@file ../external/npyscreen/npyssafewrapper.py</vh></v>
<v t="ekr.20170428084207.377"><vh>@file ../external/npyscreen/npysThemeManagers.py</vh></v>
<v t="ekr.20170428084207.390"><vh>@file ../external/npyscreen/npysThemes.py</vh></v>
<v t="ekr.20170428084207.399"><vh>@file ../external/npyscreen/npysTree.py</vh></v>
<v t="ekr.20170428084207.422"><vh>@file ../external/npyscreen/proto_fm_screen_area.py</vh></v>
<v t="ekr.20170428084207.434"><vh>@file ../external/npyscreen/stdfmemail.py</vh></v>
<v t="ekr.20170428084207.464"><vh>@file ../external/npyscreen/utilNotify.py</vh></v>
<v t="ekr.20170428084207.477"><vh>@file ../external/npyscreen/util_viewhelp.py</vh></v>
<v t="ekr.20170428084207.480"><vh>@file ../external/npyscreen/wgannotatetextbox.py</vh></v>
<v t="ekr.20170428084207.494"><vh>@file ../external/npyscreen/wgautocomplete.py</vh></v>
<v t="ekr.20170428084207.503"><vh>@file ../external/npyscreen/wgboxwidget.py</vh></v>
<v t="ekr.20170428084207.524"><vh>@file ../external/npyscreen/wgbutton.py</vh></v>
<v t="ekr.20170428084207.536"><vh>@file ../external/npyscreen/wgcheckbox.py</vh></v>
<v t="ekr.20170428084207.561"><vh>@file ../external/npyscreen/wgcombobox.py</vh></v>
<v t="ekr.20170428084207.575"><vh>@file ../external/npyscreen/wgdatecombo.py</vh></v>
<v t="ekr.20170428084207.586"><vh>@file ../external/npyscreen/wgeditmultiline.py</vh></v>
<v t="ekr.20170428084207.611"><vh>@file ../external/npyscreen/wgfilenamecombo.py</vh></v>
<v t="ekr.20170428084207.618"><vh>@file ../external/npyscreen/wgFormControlCheckbox.py</vh></v>
<v t="ekr.20170428084208.1"><vh>@file ../external/npyscreen/wggrid.py</vh></v>
<v t="ekr.20170428084208.36"><vh>@file ../external/npyscreen/wggridcoltitles.py</vh></v>
<v t="ekr.20170428084208.43"><vh>@file ../external/npyscreen/wgmonthbox.py</vh></v>
<v t="ekr.20170428084208.68"><vh>@file ../external/npyscreen/wgmultiline.py</vh></v>
<v t="ekr.20170428084208.157"><vh>@file ../external/npyscreen/wgmultilineeditable.py</vh></v>
<v t="ekr.20170428084208.173"><vh>@file ../external/npyscreen/wgmultilinetree.py</vh></v>
<v t="ekr.20170428084208.213"><vh>@file ../external/npyscreen/wgmultilinetreeselectable.py</vh></v>
<v t="ekr.20170428084208.225"><vh>@file ../external/npyscreen/wgmultiselect.py</vh></v>
<v t="ekr.20170428084208.245"><vh>@file ../external/npyscreen/wgmultiselecttree.py</vh></v>
<v t="ekr.20170428084208.253"><vh>@file ../external/npyscreen/wgNMenuDisplay.py</vh></v>
<v t="ekr.20170428084208.285"><vh>@file ../external/npyscreen/wgpassword.py</vh></v>
<v t="ekr.20170428084208.290"><vh>@file ../external/npyscreen/wgselectone.py</vh></v>
<v t="ekr.20170428084208.297"><vh>@file ../external/npyscreen/wgslider.py</vh></v>
<v t="ekr.20170428084208.318"><vh>@file ../external/npyscreen/wgtextbox.py</vh></v>
<v t="ekr.20170428084208.354"><vh>@file ../external/npyscreen/wgtextboxunicode.py</vh></v>
<v t="ekr.20170428084208.359"><vh>@file ../external/npyscreen/wgtextbox_controlchrs.py</vh></v>
<v t="ekr.20170428084208.366"><vh>@file ../external/npyscreen/wgtexttokens.py</vh></v>
<v t="ekr.20170428084208.381"><vh>@file ../external/npyscreen/wgtitlefield.py</vh></v>
<v t="ekr.20170428084208.398"><vh>@file ../external/npyscreen/wgwidget.py</vh></v>
<v t="ekr.20170428084208.436"><vh>@file ../external/npyscreen/wgwidget_proto.py</vh></v>
<v t="ekr.20170428084208.443"><vh>@@file ../external/npyscreen/__init__.py</vh>
<v t="ekr.20170428084208.444"><vh>Declarations</vh></v>
</v>
</v>
</v>
<v t="ekr.20180225010850.1"><vh>In leo/modes</vh>
<v t="ekr.20150326145530.1"><vh>@clean ../modes/forth.py</vh>
<v t="ekr.20150326145530.2"><vh>&lt;&lt; define mode rules &gt;&gt;</vh></v>
<v t="ekr.20150326145530.3"><vh>&lt;&lt; define mode data &gt;&gt;</vh></v>
<v t="ekr.20150326145530.4"><vh>&lt;&lt; define extendForth class &gt;&gt;</vh>
<v t="ekr.20150326145530.5"><vh>ctor</vh></v>
<v t="ekr.20150326145530.6"><vh>init &amp; helper</vh>
<v t="ekr.20150326145530.7"><vh>splitList</vh></v>
</v>
<v t="ekr.20150326145530.8"><vh>createBracketRules &amp; helper</vh></v>
<v t="ekr.20150326145530.9"><vh>createDefiningWordRules &amp; helper</vh></v>
<v t="ekr.20150326145530.10"><vh>createKeywords</vh></v>
<v t="ekr.20150326145530.11"><vh>createStringRule</vh></v>
<v t="ekr.20150326145530.12"><vh>extendRulesDict</vh></v>
</v>
</v>
</v>
<v t="ekr.20181013081645.1"><vh>In leo/core/test</vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20160517182239.1"><vh>@file ../../flake8-leo.py</vh></v>
<v t="ekr.20160518000549.1"><vh>@file ../../pyflakes-leo.py</vh></v>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20170805060844.1"><vh>@file ../test/leo-bridge-test.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2794"></v>
<v t="ekr.20180606035619.1"><vh>Recent files</vh>
<v t="ekr.20120419093256.10048"></v>
<v t="ekr.20140907123524.18774"></v>
<v t="ekr.20140907085654.18699"></v>
<v t="ekr.20140907131341.18707"></v>
<v t="ekr.20150323150718.1"></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005806000000302e31382e3171017d71025808000000616e6e6f7461746571037d710473732e"></v>
<v t="ekr.20140810053602.18074"></v>
<v t="ekr.20080708094444.1"></v>
</v>
<v t="ekr.20180604114211.1"><vh>Recent code</vh>
<v t="ekr.20190119062719.1"><vh>Done &amp; documented</vh>
<v t="ekr.20190121135044.1"><vh>#0926: Organize @outline-data tree-abbreviations</vh>
<v t="ekr.20170227062001.1"><vh>abbrev.init_tree_abbrev_helper</vh></v>
</v>
<v t="ekr.20190118130950.1"><vh>#0981 &amp; #0977: File syncing</vh></v>
<v t="ekr.20190119085129.1"><vh>#1047: Tree Window Resizes on Paste Node</vh></v>
<v t="ekr.20190122113449.1"><vh>#1065: refresh-from-disk</vh>
<v t="ekr.20160514120655.1"><vh>class AtFile</vh>
<v t="ekr.20131224053735.16380"><vh>&lt;&lt; define class constants &gt;&gt;</vh></v>
<v t="ekr.20041005105605.7"><vh>at.Birth &amp; init</vh>
<v t="ekr.20041005105605.8"><vh>at.ctor &amp; helpers</vh>
<v t="ekr.20171113152939.1"><vh>at.reloadSettings</vh></v>
</v>
<v t="ekr.20150509194251.1"><vh>at.cmd (decorator)</vh></v>
<v t="ekr.20041005105605.10"><vh>at.initCommonIvars</vh></v>
<v t="ekr.20041005105605.13"><vh>at.initReadIvars</vh></v>
<v t="ekr.20041005105605.15"><vh>at.initWriteIvars</vh></v>
</v>
<v t="ekr.20041005105605.17"><vh>at.Reading</vh>
<v t="ekr.20041005105605.18"><vh>at.Reading (top level)</vh>
<v t="ekr.20070919133659"><vh>at.checkDerivedFile</vh></v>
<v t="ekr.20041005105605.19"><vh>at.openFileForReading &amp; helper</vh>
<v t="ekr.20150204165040.4"><vh>at.openAtShadowFileForReading</vh></v>
</v>
<v t="ekr.20041005105605.21"><vh>at.read &amp; helpers</vh>
<v t="ekr.20100122130101.6174"><vh>at.deleteTnodeList</vh></v>
<v t="ekr.20071105164407"><vh>at.deleteUnvisitedNodes &amp; helpers</vh>
<v t="ekr.20100803073751.5817"><vh>createResurrectedNodesNode</vh></v>
<v t="ekr.20100803073751.5818"><vh>defineResurrectedNodeCallback</vh></v>
</v>
<v t="ekr.20041005105605.22"><vh>at.initFileName</vh></v>
<v t="ekr.20100224050618.11547"><vh>at.isFileLike</vh></v>
</v>
<v t="ekr.20041005105605.26"><vh>at.readAll &amp; helpers</vh>
<v t="ekr.20190108054317.1"><vh>at.findFilesToRead</vh></v>
<v t="ekr.20190108054803.1"><vh>at.readFileAtPosition</vh></v>
</v>
<v t="ekr.20080801071227.7"><vh>at.readAtShadowNodes</vh></v>
<v t="ekr.20070909100252"><vh>at.readOneAtAutoNode</vh></v>
<v t="ekr.20090225080846.3"><vh>at.readOneAtEditNode</vh></v>
<v t="ekr.20190201104956.1"><vh>at.readOneAtAsisNode</vh></v>
<v t="ekr.20150204165040.5"><vh>at.readOneAtCleanNode &amp; helpers</vh>
<v t="ekr.20150204165040.7"><vh>at.dump_lines</vh></v>
<v t="ekr.20150204165040.8"><vh>at.read_at_clean_lines</vh></v>
<v t="ekr.20150204165040.9"><vh>at.write_at_clean_sentinels</vh></v>
</v>
<v t="ekr.20080711093251.7"><vh>at.readOneAtShadowNode &amp; helper</vh>
<v t="ekr.20080712080505.1"><vh>at.importAtShadowNode</vh></v>
</v>
</v>
<v t="ekr.20180622110112.1"><vh>at.fast_read_into_root</vh></v>
<v t="ekr.20041005105605.116"><vh>at.Reading utils...</vh>
<v t="ekr.20041005105605.119"><vh>at.createImportedNode</vh></v>
<v t="ekr.20130911110233.11286"><vh>at.initReadLine</vh></v>
<v t="ekr.20041005105605.120"><vh>at.parseLeoSentinel</vh></v>
<v t="ekr.20130911110233.11284"><vh>at.readFileToUnicode &amp; helpers</vh>
<v t="ekr.20130911110233.11285"><vh>at.openFileHelper</vh></v>
<v t="ekr.20130911110233.11287"><vh>at.getEncodingFromHeader</vh></v>
</v>
<v t="ekr.20041005105605.128"><vh>at.readLine</vh></v>
<v t="ekr.20041005105605.129"><vh>at.scanHeader</vh>
<v t="ekr.20041005105605.130"><vh>at.scanFirstLines</vh></v>
</v>
<v t="ekr.20050103163224"><vh>at.scanHeaderForThin (import code)</vh></v>
</v>
</v>
<v t="ekr.20041005105605.132"><vh>at.Writing</vh>
<v t="ekr.20041005105605.133"><vh>Writing (top level)</vh>
<v t="ekr.20190111153551.1"><vh>at.commands</vh>
<v t="ekr.20070806105859"><vh>at.writeAtAutoNodes &amp; writeDirtyAtAutoNodes &amp; helpers</vh></v>
<v t="ekr.20080711093251.3"><vh>at.writeAtShadowNodes &amp; writeDirtyAtShadowNodes &amp; helpers</vh>
<v t="ekr.20190109153627.13"><vh>at.writeAtShadowNodesHelper</vh></v>
</v>
</v>
<v t="ekr.20041005105605.157"><vh>at.putFile</vh></v>
<v t="ekr.20041005105605.147"><vh>at.writeAll &amp; helpers</vh>
<v t="ekr.20190108052043.1"><vh>at.findFilesToWrite</vh></v>
<v t="ekr.20190108053115.1"><vh>at.internalWriteError</vh></v>
<v t="ekr.20190108112519.1"><vh>at.reportEndOfWrite</vh></v>
<v t="ekr.20140727075002.18108"><vh>at.saveOutlineIfPossible</vh></v>
<v t="ekr.20041005105605.149"><vh>at.writeAllHelper &amp; helper</vh>
<v t="ekr.20150602204757.1"><vh>at.autoBeautify</vh></v>
<v t="ekr.20190108105509.1"><vh>at.writePathChanged</vh></v>
</v>
</v>
<v t="ekr.20190109172025.1"><vh>at.writeAtAutoContents</vh></v>
<v t="ekr.20190111153522.1"><vh>at.writeX...</vh>
<v t="ekr.20041005105605.154"><vh>at.asisWrite &amp; helper</vh>
<v t="ekr.20170331141933.1"><vh>at.writeAsisNode</vh></v>
</v>
<v t="ekr.20041005105605.144"><vh>at.write &amp; helper</vh></v>
<v t="ekr.20041005105605.151"><vh>at.writeMissing &amp; helper</vh>
<v t="ekr.20041005105605.152"><vh>at.writeMissingNode</vh></v>
</v>
<v t="ekr.20070806141607"><vh>at.writeOneAtAutoNode &amp; helpers</vh>
<v t="ekr.20190109163934.24"><vh>at.writeAtAutoNodesHelper</vh></v>
<v t="ekr.20140728040812.17993"><vh>at.dispatch &amp; helpers</vh>
<v t="ekr.20140728040812.17995"><vh>at.writer_for_at_auto</vh></v>
<v t="ekr.20140728040812.17997"><vh>at.writer_for_ext</vh></v>
</v>
</v>
<v t="ekr.20090225080846.5"><vh>at.writeOneAtEditNode</vh></v>
<v t="ekr.20080711093251.5"><vh>at.writeOneAtShadowNode &amp; helpers</vh>
<v t="ekr.20080819075811.13"><vh>at.adjustTargetLanguage</vh></v>
</v>
</v>
<v t="ekr.20190111153506.1"><vh>at.XToString</vh>
<v t="ekr.20190109160056.1"><vh>at.atAsisToString</vh></v>
<v t="ekr.20190109160056.2"><vh>at.atAutoToString</vh></v>
<v t="ekr.20190109160056.3"><vh>at.atEditToString</vh></v>
<v t="ekr.20190109142026.1"><vh>at.atFileToString</vh></v>
<v t="ekr.20050506084734"><vh>at.stringToString</vh></v>
</v>
</v>
<v t="ekr.20041005105605.160"><vh>Writing 4.x</vh>
<v t="ekr.20041005105605.161"><vh>at.putBody &amp; helpers</vh>
<v t="ekr.20041005105605.163"><vh>at.putLine</vh></v>
</v>
<v t="ekr.20041005105605.164"><vh>writing code lines...</vh>
<v t="ekr.20041005105605.165"><vh>at.@all</vh>
<v t="ekr.20041005105605.166"><vh>at.putAtAllLine</vh></v>
<v t="ekr.20041005105605.167"><vh>at.putAtAllBody</vh></v>
<v t="ekr.20041005105605.169"><vh>at.putAtAllChild</vh></v>
</v>
<v t="ekr.20041005105605.170"><vh>at.@others (write)</vh>
<v t="ekr.20041005105605.173"><vh>at.putAtOthersLine &amp; helpers</vh>
<v t="ekr.20041005105605.172"><vh>at.putAtOthersChild</vh></v>
<v t="ekr.20041005105605.171"><vh>at.validInAtOthers (write)</vh></v>
</v>
</v>
<v t="ekr.20041005105605.174"><vh>at.putCodeLine</vh></v>
<v t="ekr.20041005105605.176"><vh>at.putRefLine &amp; helpers</vh>
<v t="ekr.20131224085853.16443"><vh>at.findReference</vh></v>
<v t="ekr.20041005105605.199"><vh>at.findSectionName</vh></v>
<v t="ekr.20041005105605.178"><vh>at.putAfterLastRef</vh></v>
<v t="ekr.20041005105605.179"><vh>at.putAfterMiddleRef</vh></v>
<v t="ekr.20041005105605.177"><vh>at.putRefAt</vh></v>
</v>
</v>
<v t="ekr.20041005105605.180"><vh>writing doc lines...</vh>
<v t="ekr.20041005105605.181"><vh>at.putBlankDocLine</vh></v>
<v t="ekr.20041005105605.183"><vh>at.putDocLine</vh></v>
<v t="ekr.20041005105605.185"><vh>at.putEndDocLine</vh></v>
<v t="ekr.20041005105605.182"><vh>at.putStartDocLine</vh></v>
</v>
</v>
<v t="ekr.20041005105605.187"><vh>Writing 4,x sentinels...</vh>
<v t="ekr.20041005105605.188"><vh>at.nodeSentinelText &amp; helper</vh>
<v t="ekr.20041005105605.189"><vh>at.removeCommentDelims</vh></v>
</v>
<v t="ekr.20041005105605.190"><vh>at.putLeadInSentinel</vh></v>
<v t="ekr.20041005105605.191"><vh>at.putCloseNodeSentinel</vh></v>
<v t="ekr.20041005105605.192"><vh>at.putOpenLeoSentinel 4.x</vh></v>
<v t="ekr.20041005105605.193"><vh>at.putOpenNodeSentinel</vh></v>
<v t="ekr.20041005105605.194"><vh>at.putSentinel (applies cweb hack) 4.x</vh></v>
</v>
<v t="ekr.20041005105605.196"><vh>Writing 4.x utils...</vh>
<v t="ekr.20181024134823.1"><vh>at.addToOrphanList</vh></v>
<v t="ekr.20190111111608.1"><vh>at.checkPath &amp; helpers</vh>
<v t="ekr.20190111112432.1"><vh>at.checkDir</vh></v>
<v t="ekr.20190111112442.1"><vh>at.isWritable</vh></v>
</v>
<v t="ekr.20090514111518.5661"><vh>at.checkPythonCode &amp; helpers</vh>
<v t="ekr.20090514111518.5663"><vh>at.checkPythonSyntax</vh>
<v t="ekr.20090514111518.5666"><vh>at.syntaxError (leoAtFile)</vh></v>
</v>
<v t="ekr.20161021084954.1"><vh>at.runPyflakes</vh></v>
<v t="ekr.20090514111518.5665"><vh>at.tabNannyNode</vh></v>
</v>
<v t="ekr.20041005105605.198"><vh>at.directiveKind4 (write logic)</vh></v>
<v t="ekr.20041005105605.200"><vh>at.isSectionName</vh></v>
<v t="ekr.20190113043601.1"><vh>at.open/closeOutputFile</vh></v>
<v t="ekr.20190109145850.1"><vh>at.open/closeOutputStream</vh></v>
<v t="ekr.20041005105605.201"><vh>at.os and allies</vh>
<v t="ekr.20041005105605.202"><vh>at.oblank, oblanks &amp; otabs</vh></v>
<v t="ekr.20041005105605.203"><vh>at.onl &amp; onl_sent</vh></v>
<v t="ekr.20041005105605.204"><vh>at.os</vh></v>
</v>
<v t="ekr.20041005105605.205"><vh>at.outputStringWithLineEndings</vh></v>
<v t="ekr.20190111045822.1"><vh>at.precheck</vh></v>
<v t="ekr.20050506090446.1"><vh>at.putAtFirstLines</vh></v>
<v t="ekr.20050506090955"><vh>at.putAtLastLines</vh></v>
<v t="ekr.20041005105605.206"><vh>at.putDirective 4.x &amp; helper</vh>
<v t="ekr.20041005105605.207"><vh>at.putDelims</vh></v>
</v>
<v t="ekr.20041005105605.210"><vh>at.putIndent</vh></v>
<v t="ekr.20041005105605.211"><vh>at.putInitialComment</vh></v>
<v t="ekr.20190111172114.1"><vh>at.replaceFile &amp; helpers</vh>
<v t="ekr.20190114061452.27"><vh>at.compareIgnoringBlankLines</vh></v>
<v t="ekr.20190114061452.28"><vh>at.compareIgnoringLineEndings</vh></v>
</v>
<v t="ekr.20041005105605.216"><vh>at.warnAboutOrpanAndIgnoredNodes</vh></v>
<v t="ekr.20041005105605.217"><vh>at.writeError</vh></v>
<v t="ekr.20041005105605.218"><vh>at.writeException</vh></v>
</v>
</v>
<v t="ekr.20041005105605.219"><vh>at.Utilites</vh>
<v t="ekr.20041005105605.220"><vh>at.error &amp; printError</vh></v>
<v t="ekr.20041005105605.221"><vh>at.exception</vh></v>
<v t="ekr.20050104131929"><vh>at.file operations...</vh>
<v t="ekr.20050104131820"><vh>at.chmod</vh></v>
<v t="ekr.20050104132018"><vh>at.remove</vh></v>
<v t="ekr.20050104132026"><vh>at.stat</vh></v>
</v>
<v t="ekr.20090530055015.6023"><vh>at.get/setPathUa</vh></v>
<v t="ekr.20081216090156.4"><vh>at.parseUnderindentTag</vh></v>
<v t="ekr.20090712050729.6017"><vh>at.promptForDangerousWrite</vh></v>
<v t="ekr.20120112084820.10001"><vh>at.rememberReadPath</vh></v>
<v t="ekr.20080923070954.4"><vh>at.scanAllDirectives</vh>
<v t="ekr.20080923070954.14"><vh>&lt;&lt; Set ivars &gt;&gt; (at.scanAllDirectives)</vh></v>
<v t="ekr.20080923070954.13"><vh>&lt;&lt; Set comment strings from delims &gt;&gt; (at.scanAllDirectives)</vh></v>
</v>
<v t="ekr.20120110174009.9965"><vh>at.shouldPromptForDangerousWrite</vh></v>
<v t="ekr.20041005105605.20"><vh>at.warnOnReadOnlyFile</vh></v>
</v>
</v>
<v t="ekr.20180602102448.1"><vh>class FastAtRead</vh>
<v t="ekr.20180602103135.3"><vh>fast_at.get_patterns</vh></v>
<v t="ekr.20180603060721.1"><vh>fast_at.post_pass</vh></v>
<v t="ekr.20180602103135.2"><vh>fast_at.scan_header</vh></v>
<v t="ekr.20180602103135.8"><vh>fast_at.scan_lines</vh>
<v t="ekr.20180602103135.9"><vh>&lt;&lt; init scan_lines &gt;&gt;</vh></v>
<v t="ekr.20180613061743.1"><vh>&lt;&lt; define dump_v &gt;&gt;</vh></v>
<v t="ekr.20180602103135.10"><vh>&lt;&lt; 1. common code for all lines &gt;&gt;</vh></v>
<v t="ekr.20180602103135.12"><vh>&lt;&lt; 2. short-circuit later tests &gt;&gt;</vh></v>
<v t="ekr.20180602103135.14"><vh>&lt;&lt; 3. handle @others &gt;&gt;</vh></v>
<v t="ekr.20180602103135.18"><vh>&lt;&lt; 4. handle section refs &gt;&gt;</vh></v>
<v t="ekr.20180602103135.19"><vh>&lt;&lt; handle node_start &gt;&gt;</vh></v>
<v t="ekr.20180602103135.16"><vh>&lt;&lt; handle end of @doc &amp; @code parts &gt;&gt;</vh></v>
<v t="ekr.20180602103135.13"><vh>&lt;&lt; handle @all &gt;&gt;</vh></v>
<v t="ekr.20180603063102.1"><vh>&lt;&lt; handle afterref &gt;&gt;</vh></v>
<v t="ekr.20180606053919.1"><vh>&lt;&lt; handle @first and @last &gt;&gt;</vh></v>
<v t="ekr.20180621050901.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
<v t="ekr.20180608104836.1"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="ekr.20180606080200.1"><vh>&lt;&lt; handle @raw &gt;&gt;</vh></v>
<v t="ekr.20180602103135.20"><vh>&lt;&lt; handle @-leo &gt;&gt;</vh></v>
<v t="ekr.20180603135602.1"><vh>&lt;&lt; Last 1. handle remaining @@ lines &gt;&gt;</vh></v>
<v t="ekr.20180606054325.1"><vh>&lt;&lt; Last 2. handle remaining @doc lines &gt;&gt;</vh></v>
<v t="ekr.20180602103135.17"><vh>&lt;&lt; Last 3. handle remaining @ lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20180603170614.1"><vh>fast_at.read_into_root</vh></v>
</v>
<v t="ekr.20140717074441.17772"><vh>c_file.refreshFromDisk</vh></v>
<v t="ekr.20041005105605.21"></v>
<v t="ekr.20180603170614.1"></v>
<v t="ekr.20180603060721.1"></v>
<v t="ekr.20180602103135.9"></v>
<v t="ekr.20180602103135.19"></v>
<v t="ekr.20180602103135.8"></v>
</v>
</v>
<v t="ekr.20190306083111.1"><vh>To be documented</vh>
<v t="ekr.20190218071717.1"><vh>#1085: Py3 branch</vh>
<v t="ekr.20190218122943.1"><vh>Deleted</vh>
<v t="ekr.20190218235026.1"><vh>g.ue</vh></v>
<v t="ekr.20170108034643.1"><vh>g.ustr (pyzo)</vh></v>
<v t="ekr.20031218072017.1150"><vh>&lt;&lt; open filename to f, or return &gt;&gt; (weave)</vh></v>
<v t="ekr.20110605121601.18526"><vh>qt_gui.toUnicode</vh></v>
<v t="ekr.20081119083601.1"><vh>UnitTestGui.toUnicode</vh></v>
</v>
<v t="ekr.20190219000246.1"><vh>Done</vh>
<v t="ekr.20190218131849.1"><vh>Removed isPython3</vh>
<v t="ekr.20190218073025.1"><vh> Commands...</vh>
<v t="ekr.20040723094220.5"><vh>c.checkPythonNode</vh></v>
<v t="ekr.20171123135625.5"><vh>c.executeScriptHelper</vh></v>
<v t="ville.20090311200059.1"><vh>c.find_b</vh></v>
<v t="ekr.20070115135502"><vh>c.writeScriptFile</vh></v>
<v t="ekr.20070915142635"><vh>c_file.writeFileFromNode</vh></v>
<v t="ekr.20170806094317.19"><vh>efc.dumpCompareNodes</vh></v>
<v t="ekr.20170806094318.15"><vh>efc.saveFile</vh></v>
<v t="ekr.20160517133049.4"><vh>flake8.get_flake8_config</vh></v>
<v t="ekr.20100813041139.5912"><vh>rst.createIntermediateFile</vh></v>
<v t="ekr.20090502071837.94"><vh>rst.write</vh></v>
<v t="ekr.20100813041139.5919"><vh>rst.write_files &amp; helpers</vh>
<v t="ekr.20100813041139.5913"><vh>rst.addTitleToHtml</vh></v>
<v t="ekr.20100813041139.5914"><vh>rst.createDirectoryForFile</vh></v>
<v t="ekr.20100813041139.5912"></v>
<v t="ekr.20090502071837.65"><vh>rst.writeToDocutils (sets argv) &amp; helper</vh>
<v t="ekr.20090502071837.66"><vh>rst.handleMissingStyleSheetArgs</vh></v>
</v>
</v>
</v>
<v t="ekr.20190218072811.1"><vh> Gui...</vh>
<v t="ekr.20110605121601.18384"><vh>LeoQTreeWidget.setText</vh></v>
<v t="tbrown.20171028115438.26"><vh>load_modules</vh></v>
<v t="ekr.20110605121601.18113"><vh>qsciw.setAllText</vh></v>
<v t="tbrown.20150807090639.1"><vh>qtree.declutter_node &amp; helpers</vh>
<v t="ekr.20171122064635.1"><vh>qtree.declutter_replace</vh></v>
<v t="ekr.20171122055719.1"><vh>qtree.declutter_style</vh></v>
</v>
</v>
<v t="ekr.20190218071807.1"><vh> Imports...</vh>
<v t="ekr.20120219194520.10463"><vh>&lt;&lt; imports &gt;&gt; (leoApp)</vh></v>
<v t="ekr.20100208223942.10436"><vh>&lt;&lt; imports &gt;&gt; (leoCache)</vh></v>
<v t="ekr.20050405141130"><vh>&lt;&lt; imports &gt;&gt; (leoFileCommands)</vh></v>
<v t="ekr.20050208101229"><vh>&lt;&lt; imports &gt;&gt; (leoGlobals)</vh></v>
<v t="ekr.20091224155043.6539"><vh>&lt;&lt; imports &gt;&gt; (leoImport)</vh></v>
<v t="ekr.20100908120927.5971"><vh>&lt;&lt; imports &gt;&gt; (leoRst)</vh></v>
<v t="ekr.20181006100604.1"><vh>&lt;&lt; leoDebugger.py imports &gt;&gt;</vh></v>
<v t="tbrown.20171028115438.1"><vh>&lt;&lt;editpane.py imports&gt;&gt;</vh></v>
</v>
<v t="ekr.20190218073115.1"><vh> IO...</vh>
<v t="ekr.20180602062323.7"><vh>fast.readWithElementTree &amp; helpers</vh>
<v t="ekr.20180624125321.1"><vh>fast.handleBits</vh></v>
<v t="ekr.20180606041211.1"><vh>fast.resolveUa &amp; helper</vh>
<v t="ekr.20180606044154.1"><vh>fast.bytesToUnicode</vh></v>
</v>
<v t="ekr.20180605062300.1"><vh>fast.scanGlobals &amp; helper</vh>
<v t="ekr.20180708060437.1"><vh>fast.getGlobalData</vh></v>
</v>
<v t="ekr.20180602062323.8"><vh>fast.scanTnodes</vh></v>
<v t="ekr.20180602062323.9"><vh>fast.scanVnodes &amp; helper</vh>
<v t="ekr.20180605102822.1"><vh>&lt;&lt; define v_element_visitor &gt;&gt;</vh>
<v t="ekr.20180605075042.1"><vh>&lt;&lt; Make a new vnode, linked to the parent &gt;&gt;</vh></v>
<v t="ekr.20180605075113.1"><vh>&lt;&lt; handle all other v attributes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.1470"><vh>fc.put &amp; helpers</vh>
<v t="ekr.20141020112451.18329"><vh>put_dquote</vh></v>
<v t="ekr.20141020112451.18330"><vh>put_dquoted_bool</vh></v>
<v t="ekr.20141020112451.18331"><vh>put_flag</vh></v>
<v t="ekr.20141020112451.18332"><vh>put_in_dquotes</vh></v>
<v t="ekr.20141020112451.18333"><vh>put_nl</vh></v>
<v t="ekr.20141020112451.18334"><vh>put_tab</vh></v>
<v t="ekr.20141020112451.18335"><vh>put_tabs</vh></v>
</v>
<v t="ekr.20100119145629.6111"><vh>fc.writeToFileHelper &amp; helpers</vh>
<v t="ekr.20100119145629.6106"><vh>fc.createActualFile</vh></v>
<v t="ekr.20031218072017.3047"><vh>fc.createBackupFile</vh></v>
<v t="ekr.20100119145629.6108"><vh>fc.handleWriteLeoFileException</vh></v>
</v>
<v t="ekr.20031218072017.1462"><vh>ic.exportHeadlines</vh></v>
<v t="ekr.20031218072017.1148"><vh>ic.outlineToWeb</vh></v>
<v t="ekr.20080822065427.4"><vh>show_error_lines</vh></v>
</v>
<v t="ekr.20190218072351.1"><vh> leoApp.py...</vh>
<v t="ekr.20090717112235.6007"><vh>app.computeSignon &amp; printSignon</vh></v>
<v t="ekr.20031218072017.1982"><vh>app.setIDFile</vh></v>
<v t="ekr.20031218072017.1981"><vh>app.setIdFromDialog</vh></v>
<v t="ekr.20031218072017.2619"><vh>app.writeWaitingLog</vh></v>
<v t="ekr.20120222103014.10312"><vh>LM.openSettingsFile</vh></v>
<v t="ekr.20120223062418.10410"><vh>LM.openZipFile</vh></v>
<v t="vitalije.20170703115609.1"><vh>rf.editRecentFiles</vh></v>
</v>
<v t="ekr.20190218072404.1"><vh> leoAtFile.py...</vh>
<v t="ekr.20090514111518.5663"></v>
<v t="ekr.20041005105605.205"></v>
</v>
<v t="ekr.20190218073446.1"><vh> leoConfig.py...</vh>
<v t="ekr.20041121143823"><vh>gcm.getValFromDict</vh></v>
<v t="ekr.20120215072959.12520"><vh>getValFromDict</vh></v>
<v t="ekr.20041119204714"><vh>visitNode (SettingsTreeParser)</vh></v>
</v>
<v t="ekr.20190218071916.1"><vh> leoGlobals.py...</vh>
<v t="ekr.20031219074948.1"><vh>class g.NullObject (Python Cookbook)</vh></v>
<v t="ekr.20120320053907.9776"><vh>g.computeFileUrl</vh></v>
<v t="ekr.20060127162818"><vh>g.enable_gc_debug</vh></v>
<v t="ekr.20161223090721.1"><vh>g.exec_file</vh></v>
<v t="ekr.20031218072017.1386"><vh>g.getOutputNewline</vh></v>
<v t="ekr.20031218072017.2278"><vh>g.importFromPath</vh></v>
<v t="ekr.20100329071036.5744"><vh>g.is_binary_file/external_file/string</vh></v>
<v t="ekr.20160229070349.2"><vh>g.isBytes (inlined)</vh></v>
<v t="ekr.20160229070349.3"><vh>g.isCallable</vh></v>
<v t="ekr.20160229070429.1"><vh>g.isInt</vh></v>
<v t="ekr.20161223082445.1"><vh>g.isList</vh></v>
<v t="ekr.20160229070349.5"><vh>g.isString (inlined)</vh></v>
<v t="ekr.20160229070349.6"><vh>g.isUnicode (Inlined)</vh></v>
<v t="ekr.20031218072017.3128"><vh>g.pause</vh></v>
<v t="ekr.20080710101653.1"><vh>g.pr</vh></v>
<v t="ekr.20060221083356"><vh>g.prettyPrintType</vh></v>
<v t="ekr.20031218072017.3135"><vh>g.printStats</vh></v>
<v t="ekr.20050208093800.1"><vh>g.toUnicode (Inlined)</vh></v>
<v t="ekr.20080919065433.1"><vh>g.toUnicodeWithErrorCode (for unit testing)</vh></v>
<v t="ekr.20060810095921"><vh>g.translateString &amp; tr</vh></v>
<v t="ekr.20091206161352.6232"><vh>g.u &amp; g.ue</vh></v>
<v t="ekr.20170226093349.1"><vh>g.unquoteUrl</vh></v>
</v>
<v t="ekr.20190218073221.1"><vh> leoNodes.py...</vh>
<v t="ville.20090311195550.1"><vh>filter_b</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__ &amp; __bool__</vh></v>
<v t="ekr.20031218072017.1581"><vh>v.headString &amp; v.cleanHeadString</vh></v>
</v>
<v t="ekr.20190218072450.1"><vh> leoTest.py</vh>
<v t="ekr.20051104075904.22"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
<v t="ekr.20051104075904.18"><vh>enableGc</vh></v>
<v t="ekr.20051104075904.97"><vh>leoTest.py: factorial (a test of doctests)</vh></v>
<v t="ekr.20051104075904.10"><vh>runTest (generalTestCase)</vh></v>
<v t="ekr.20051104075904.93"><vh>TM.checkFileSyntax</vh></v>
<v t="ekr.20120912094259.10546"><vh>tm.makeTestClass</vh></v>
<v t="ekr.20051104075904.12"><vh>tm.makeTestSuite</vh></v>
</v>
<v t="ekr.20190218071950.1"><vh> Tangle/Untangle...</vh>
<v t="ekr.20031218072017.1149"><vh>&lt;&lt; Write s into newFileName &gt;&gt; (remove-sentinels)</vh></v>
<v t="ekr.20031218072017.1464"><vh>ic.weave</vh>
<v t="ekr.20031218072017.1150"></v>
<v t="ekr.20031218072017.1465"><vh>&lt;&lt; write the context of p to f &gt;&gt; (weave)</vh></v>
</v>
</v>
<v t="ekr.20190218073511.1"><vh>Misc...</vh>
<v t="ekr.20110605121601.18577"><vh>jedit.addLeoRules</vh></v>
<v t="ekr.20120206134955.10150"><vh>td._checkKey/ValType</vh></v>
<v t="ekr.20141210051628.28"><vh>zic.parseZimIndex</vh></v>
<v t="vitalije.20170716201700.3"><vh> __init__ (SqlitePickleShare)</vh></v>
<v t="ekr.20181006160108.1"><vh>xdb.__init__</vh></v>
</v>
</v>
<v t="ekr.20190218153315.1"><vh>Removed 61:g.u</vh>
<v t="ekr.20180602103135.9"></v>
<v t="ekr.20141031053508.15"><vh>add_rclick_menu (QtIconBarClass)</vh></v>
<v t="ekr.20190109160056.1"></v>
<v t="ekr.20190109160056.2"></v>
<v t="ekr.20190109160056.3"></v>
<v t="ekr.20190109142026.1"></v>
<v t="ekr.20190109145850.1"></v>
<v t="ekr.20090225080846.3"></v>
<v t="ekr.20050506084734"></v>
<v t="ekr.20120217070122.10473"><vh>c.initCommandIvars</vh></v>
<v t="ekr.20120217070122.10470"><vh>c.initObjects</vh></v>
<v t="ekr.20110605121601.18148"><vh>dw.createMiniBuffer</vh></v>
<v t="ekr.20180602062323.9"></v>
<v t="vitalije.20170705075107.1"><vh>fc.decodePosition</vh></v>
<v t="vitalije.20170705075117.1"><vh>fc.encodePosition</vh></v>
<v t="ekr.20110605121601.18544"><vh>filter.qtKey</vh></v>
<v t="ekr.20131119185305.16478"><vh>ftm.clear_focus &amp; init_focus &amp; set_entry_focus</vh></v>
<v t="ekr.20131117120458.16789"><vh>ftm.init_widgets (creates callbacks)</vh></v>
<v t="ekr.20131117164142.16853"><vh>ftm.text getters/setters</vh></v>
<v t="ekr.20100125073206.8710"><vh>g.readFileIntoString</vh></v>
<v t="ekr.20031218072017.3120"><vh>g.readlineForceUnixNewline</vh></v>
<v t="ekr.20050208093800.1"></v>
<v t="ekr.20031218072017.2160"><vh>g.toUnicodeFileEncoding</vh></v>
<v t="ekr.20091206161352.6232"></v>
<v t="ekr.20031218072017.3306"><vh>ic.createHeadline</vh></v>
<v t="ekr.20031218072017.1462"></v>
<v t="ekr.20031218072017.1147"><vh>ic.flattenOutline</vh></v>
<v t="ekr.20160504144353.1"><vh>json.create_nodes (generalize)</vh></v>
<v t="vitalije.20170708161511.1"><vh>k.handleInputShortcut</vh>
<v t="vitalije.20170709151653.1"><vh>k.isInShortcutBodyLine</vh></v>
<v t="vitalije.20170709151658.1"><vh>k.isEditShortcutSensible</vh></v>
<v t="vitalije.20170709202924.1"><vh>k.editShortcut_do_bind_helper</vh></v>
</v>
<v t="vitalije.20170709151653.1"></v>
<v t="ekr.20131118172620.16894"><vh>keyPress (EventWrapper)</vh></v>
<v t="ekr.20110605121601.18360"><vh>LeoQtMenu.setMenuLabel</vh></v>
<v t="ekr.20110605121601.18383"><vh>LeoQTreeWidget.parseText</vh></v>
<v t="ekr.20141024170936.7"><vh>lqlw.get_selection</vh></v>
<v t="tbrown.20111011094944.27031"><vh>lqlw.tab_callback</vh></v>
<v t="ekr.20110605121601.18120"><vh>qlew.getAllText</vh></v>
<v t="ekr.20110605121601.18122"><vh>qlew.getSelectionRange</vh></v>
<v t="ekr.20110605121601.18129"><vh>qlew.setInsertPoint</vh></v>
<v t="ekr.20110605121601.18130"><vh>qlew.setSelectionRange</vh></v>
<v t="ekr.20110605121601.18108"><vh>qsciw.getAllText</vh></v>
<v t="ekr.20190118082646.1"><vh>qstatus.compute_columns</vh></v>
<v t="ekr.20170324142416.1"><vh>qt: show-color-wheel</vh></v>
<v t="ekr.20170324143944.3"><vh>qt: show-fonts</vh></v>
<v t="ekr.20160917125948.1"><vh>qt_gui.getTextFromClipboard</vh></v>
<v t="ekr.20110605121601.18494"><vh>qt_gui.runAskLeoIDDialog</vh></v>
<v t="ekr.20110605121601.18499"><vh>qt_gui.runOpenDirectoryDialog</vh></v>
<v t="ekr.20110605121601.18500"><vh>qt_gui.runOpenFileDialog</vh></v>
<v t="ekr.20110605121601.18502"><vh>qt_gui.runSaveFileDialog</vh></v>
<v t="ekr.20110605121601.18081"><vh>qtew.getAllText</vh></v>
<v t="ekr.20110605121601.18311"><vh>qtFrame.Qt bindings...</vh></v>
<v t="ekr.20110605121601.18424"><vh>qtree.getItemText</vh></v>
<v t="ekr.20110605121601.17912"><vh>qtree.onHeadChanged</vh>
<v t="ekr.20120409185504.10028"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="vitalije.20170703115609.1"></v>
<v t="ekr.20131115120119.17395"><vh>setChanged (LeoTabbedTopLevel)</vh></v>
<v t="ekr.20180316093159.1"><vh>ssm.do_pass</vh></v>
<v t="ekr.20110605121601.18441"><vh>tt.createControl (defines class LeoQComboBox)</vh></v>
<v t="ekr.20110605121601.18445"><vh>tt.selectTab</vh></v>
<v t="ekr.20031218072017.3344"><vh>v.__init</vh></v>
</v>
<v t="ekr.20190218154718.1"><vh>Removed 5:g.ue</vh>
<v t="ekr.20041005105605.205"></v>
<v t="ekr.20080805085257.2"><vh>fc.pickle</vh></v>
<v t="ekr.20091206161352.6232"></v>
<v t="ekr.20120223062418.10410"></v>
<v t="ekr.20140713062552.17737"><vh>pd.pickle</vh></v>
</v>
</v>
<v t="ekr.20190218145819.1"><vh>Still uses isPython3</vh>
<v t="ekr.20190218071840.1"><vh> leoAst.py...</vh>
<v t="ekr.20141012064706.18416"><vh>f.arguments</vh></v>
<v t="ekr.20141012064706.18419"><vh>f.Bytes</vh></v>
<v t="ekr.20170721073056.1"><vh>f.Constant (Python 3.6+)</vh></v>
<v t="ekr.20170721075130.1"><vh>f.FormattedValue (Python 3.6+)</vh></v>
<v t="ekr.20141012064706.18459"><vh>f.Raise</vh></v>
<v t="ekr.20141012064706.18531"><vh>Constants &amp; Name</vh></v>
<v t="ekr.20141012064706.18482"><vh>ft.arguments &amp; arg</vh></v>
<v t="ekr.20170721073315.1"><vh>ft.Constant (Python 3.6+)</vh></v>
<v t="ekr.20170721075714.1"><vh>ft.FormattedValue (Python 3.6+)</vh></v>
<v t="ekr.20170721080935.1"><vh>ft.JoinedStr (Python 3.6+)</vh></v>
<v t="ekr.20141012064706.18520"><vh>ft.Raise</vh></v>
<v t="ekr.20170721073431.1"><vh>rt.Constant (Python 3.6+)</vh></v>
<v t="ekr.20150722204300.85"><vh>rt.Raise</vh></v>
<v t="ekr.20170721075845.1"><vh>rf.FormattedValue (Python 3.6+: unfinished)</vh></v>
<v t="ekr.20170721080959.1"><vh>rf.JoinedStr (Python 3.6+: unfinished)</vh></v>
</v>
</v>
<v t="ekr.20190218174250.1"><vh>Possible replacements</vh>
<v t="ekr.20190218154841.1"><vh>Minor</vh>
<v t="ekr.20190218154507.1"><vh>Found 7:isBytes</vh>
<v t="ekr.20180606041211.1"></v>
<v t="ekr.20050418161620.2"><vh>fc.putUaHelper</vh></v>
<v t="ekr.20160229070349.2"></v>
<v t="ekr.20080816125725.2"><vh>g.isBytes/Callable/Int/String/Unicode</vh>
<v t="ekr.20160229070349.2"></v>
<v t="ekr.20160229070349.3"></v>
<v t="ekr.20160229070429.1"></v>
<v t="ekr.20161223082445.1"></v>
<v t="ekr.20160229070349.5"></v>
<v t="ekr.20160229070349.6"></v>
</v>
<v t="ekr.20031218072017.2317"><vh>g.trace</vh></v>
<v t="ekr.20090502071837.65"></v>
<v t="ekr.20050404151753.6"><vh>write (g.FileLikeObject)</vh></v>
</v>
<v t="ekr.20190218154520.1"><vh>Found 2:isCallable</vh>
<v t="ekr.20031218072017.2829"><vh>efc.open_file_in_external_editor</vh></v>
<v t="ekr.20160229070349.3"></v>
</v>
<v t="ekr.20190218154532.1"><vh>Found 7:isInt</vh>
<v t="ekr.20091211111443.6266"><vh>c.checkBatchOperationsList</vh></v>
<v t="ekr.20070317130250"><vh>cc.selectChapterByName &amp; helper</vh>
<v t="ekr.20090306060344.2"><vh>cc.selectChapterByNameHelper</vh></v>
</v>
<v t="ekr.20160229070429.1"></v>
<v t="ekr.20111114151846.9847"><vh>g.toPythonIndex</vh></v>
<v t="ekr.20110605121601.18100"><vh>qtew.toPythonIndex</vh></v>
<v t="ekr.20110605121601.18441"></v>
</v>
<v t="ekr.20190218154614.1"><vh>Found 7:isList</vh>
<v t="ekr.20120129181245.10220"><vh>class g.TypedDict/OfLists &amp; isTypedDict/OfLists</vh>
<v t="ekr.20120205022040.17769"><vh>td.ctor</vh></v>
<v t="ekr.20120205022040.17770"><vh>td.__repr__ &amp; __str__</vh></v>
<v t="ekr.20120206134955.10150"></v>
<v t="ekr.20120205022040.17774"><vh>td.add &amp; td.replace</vh></v>
<v t="ekr.20120223062418.10422"><vh>td.copy</vh></v>
<v t="ekr.20120206134955.10151"><vh>td.dump</vh></v>
<v t="ekr.20120205022040.17771"><vh>td getters</vh></v>
<v t="ekr.20120214165710.10728"><vh>td.setName</vh></v>
<v t="ekr.20120205022040.17807"><vh>td.update</vh></v>
</v>
<v t="ekr.20161223082445.1"></v>
<v t="ekr.20120205022040.17771"></v>
<v t="ekr.20120205022040.17774"></v>
<v t="ekr.20120205022040.17769"></v>
<v t="ekr.20120206134955.10151"></v>
</v>
</v>
<v t="ekr.20190218154421.1"><vh>Found 50:isString</vh>
<v t="ekr.20150514043850.9"><vh>abbrev.init_tree_abbrev</vh>
<v t="ekr.20170227062001.1"></v>
</v>
<v t="ekr.20120215072959.12527"><vh>c.config.getData</vh></v>
<v t="ekr.20131114051702.16542"><vh>c.config.getOutlineData</vh></v>
<v t="ekr.20140717074441.17770"><vh>c.recreateGnxDict</vh></v>
<v t="ekr.20171215074959.2"><vh>checker.Assign &amp; helpers</vh>
<v t="ekr.20171215074959.4"><vh>checker.do_assn_to_self</vh></v>
<v t="ekr.20171215074959.3"><vh>checker.do_assn_to_special</vh></v>
</v>
<v t="ekr.20171216063026.1"><vh>checker.error, fail, note &amp; log_line</vh></v>
<v t="ekr.20171216110107.1"><vh>checker.get_chain</vh></v>
<v t="ekr.20171208142646.1"><vh>checker.resolve &amp; helpers</vh>
<v t="ekr.20171208134737.1"><vh>checker.resolve_call</vh></v>
<v t="ekr.20171209034244.1"><vh>checker.resolve_chain</vh></v>
<v t="ekr.20171208173323.1"><vh>checker.resolve_ivar &amp; helpers</vh>
<v t="ekr.20171217102701.1"><vh>checker.remember_unknown_ivar</vh></v>
<v t="ekr.20171217102055.1"><vh>checker.report_unbounded_recursion</vh></v>
</v>
<v t="ekr.20171209065852.1"><vh>checker_check_signature &amp; helpers</vh>
<v t="ekr.20171212034531.1"><vh>checker.check_arg (Finish)</vh></v>
<v t="ekr.20171212035137.1"><vh>checker.check_arg_helper</vh></v>
<v t="ekr.20171212044621.1"><vh>checker.compare_classes</vh></v>
</v>
</v>
<v t="ekr.20171208134737.1"></v>
<v t="ekr.20171209034244.1"></v>
<v t="ekr.20150523132558.1"><vh>class OutputToken</vh></v>
<v t="ekr.20161028090624.1"><vh>class ProcessData</vh></v>
<v t="ekr.20141012064706.18403"><vh>f.visit</vh></v>
<v t="ekr.20180606041211.1"></v>
<v t="ekr.20050418161620.2"></v>
<v t="ekr.20170222084048.1"></v>
<v t="ekr.20141012064706.18474"><vh>ft.FunctionDef</vh></v>
<v t="ekr.20180627050237.1"><vh>function: dump_cache</vh></v>
<v t="ekr.20131016032805.16721"><vh>g.execute_shell_commands</vh></v>
<v t="ekr.20150722051946.2"><vh>g.flatten_list</vh></v>
<v t="ekr.20160229070349.5"></v>
<v t="ekr.20150722051946.3"><vh>g.join_list</vh></v>
<v t="ekr.20050819064157"><vh>g.objToSTring &amp; g.toString</vh></v>
<v t="ekr.20170216091704.1"><vh>g.openUrlHelper</vh></v>
<v t="ekr.20160417174224.1"><vh>g.plural</vh></v>
<v t="ekr.20031218072017.3135"></v>
<v t="ekr.20031218072017.3136"><vh>g.stat</vh></v>
<v t="ekr.20031218072017.2160"></v>
<v t="ekr.20031218072017.2317"></v>
<v t="ekr.20080220111323"><vh>g.translateArgs</vh></v>
<v t="ekr.20120222103014.10314"><vh>gcm.config_iter</vh></v>
<v t="bob.20071231111744.2"><vh>get / getColor</vh></v>
<v t="ekr.20160518074545.9"><vh>get_files_for_scope</vh></v>
<v t="ekr.20100216141722.5626"><vh>goto.find_gnx</vh></v>
<v t="ekr.20140825102404.18525"><vh>IdleTime.__repr__</vh></v>
<v t="ekr.20090518072506.8494"><vh>k.isFKey</vh></v>
<v t="ekr.20061031131434.126"><vh>k.manufactureKeyPressForCommandName</vh></v>
<v t="ekr.20111028060955.16568"><vh>LeoMenu.getMenuEntryBindings</vh></v>
<v t="ekr.20111028060955.16565"><vh>LeoMenu.getMenuEntryInfo</vh></v>
<v t="ekr.20031218072017.1997"><vh>ni.scanGnx</vh></v>
<v t="ekr.20150526201701.12"><vh>ptb.op*</vh></v>
<v t="ekr.20150527213419.1"><vh>ptb.possible_unary_op &amp; unary_op</vh></v>
<v t="ekr.20150526201701.13"><vh>ptb.word &amp; word_op</vh></v>
<v t="ekr.20110605121601.18510"><vh>qt_gui.getFontFromParams</vh></v>
<v t="ekr.20150722204300.88"><vh>rt.Str</vh></v>
<v t="ekr.20120205022040.17771"></v>
<v t="ekr.20160225102931.9"><vh>ts.dump_token</vh></v>
<v t="ekr.20031218072017.3614"><vh>u.setRedoType</vh></v>
<v t="ekr.20091221145433.6381"><vh>u.setUndoType</vh></v>
</v>
</v>
</v>
<v t="ekr.20190306072725.1"><vh>re: Allow "remote" git-diff</vh>
<v t="ekr.20170616102324.1"><vh>g.execGitCommand</vh></v>
<v t="ekr.20170806094320.13"><vh>class GitDiffController</vh>
<v t="ekr.20170806094320.4"><vh>gdc.__init__ &amp; helper</vh></v>
<v t="ekr.20180510095544.1"><vh>gdc.Entries...</vh>
<v t="ekr.20180506064102.10"><vh>gdc.diff_two_branches</vh></v>
<v t="ekr.20180507212821.1"><vh>gdc.diff_two_revs</vh></v>
<v t="ekr.20170806094320.12"><vh>gdc.git_diff &amp; helper</vh>
<v t="ekr.20170820082125.1"><vh>gdc.diff_revs</vh></v>
</v>
<v t="ekr.20170806094320.6"><vh>gdc.diff_file &amp; helpers</vh>
<v t="ekr.20170806191942.2"><vh>gdc.create_compare_node</vh></v>
<v t="ekr.20170806094321.1"><vh>gdc.create_file_node</vh></v>
<v t="ekr.20170806094320.7"><vh>gdc.find_file</vh></v>
<v t="ekr.20170806094321.7"><vh>gdc.make_at_file_outline</vh></v>
<v t="ekr.20170806125535.1"><vh>gdc.make_diff_outlines &amp; helper</vh>
<v t="ekr.20170806191707.1"><vh>gdc.compute_dicts</vh></v>
</v>
<v t="ekr.20170821052348.1"><vh>gdc.get_revno</vh></v>
<v t="ekr.20170820084258.1"><vh>gdc.make_at_clean_outline</vh></v>
</v>
</v>
<v t="ekr.20180510095801.1"><vh>gdc.Utils</vh>
<v t="ekr.20170806094320.18"><vh>gdc.create_root</vh></v>
<v t="ekr.20170819132219.1"><vh>gdc.find_gnx</vh></v>
<v t="ekr.20170806094321.5"><vh>gdc.finish</vh></v>
<v t="ekr.20180506064102.11"><vh>gdc.get_file_from_branch</vh></v>
<v t="ekr.20170806094320.15"><vh>gdc.get_file_from_rev</vh></v>
<v t="ekr.20170806094320.9"><vh>gdc.get_files</vh></v>
<v t="ekr.20180510095807.1"><vh>gdc.set_directory &amp; helper</vh>
<v t="ekr.20170806094321.3"><vh>gdc.find_git_working_directory</vh></v>
</v>
</v>
</v>
<v t="ekr.20170819035801.90"><vh>efc.gitDiff (git-diff)</vh></v>
<v t="ekr.20190306082736.1"><vh>git diff HEAD </vh>
<v t="ekr.20190306082736.2"><vh>leo/commands/editFileCommands.py</vh>
<v t="ekr.20190306082736.9"><vh>Changed</vh>
<v t="ekr.20190306082736.10"><vh>gdc.__init__ &amp; helper</vh>
<v t="ekr.20190306082736.11"><vh>Old:gdc.__init__ &amp; helper</vh></v>
<v t="ekr.20170806094320.4"></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20190218044303.1"><vh>===== #1081 @asis</vh>
<v t="ekr.20190218061842.1"><vh>ref</vh>
<v t="ekr.20190108054317.1"></v>
<v t="ekr.20190108054317.1"></v>
<v t="ekr.20150405200212.1"><vh>efc.ask</vh></v>
<v t="ekr.20150403045207.1"><vh>efc.has_changed</vh></v>
<v t="ekr.20150330033306.1"><vh>efc.on_idle &amp; helpers</vh>
<v t="ekr.20150404045115.1"><vh>efc.idle_check_commander</vh></v>
<v t="ekr.20150403044823.1"><vh>efc.idle_check_at_file_node</vh></v>
<v t="ekr.20150407124259.1"><vh>efc.idle_check_open_with_file &amp; helper</vh>
<v t="ekr.20150407205631.1"><vh>efc.update_open_with_node</vh></v>
</v>
</v>
</v>
<v t="ekr.20190218061833.1"><vh>changed</vh>
<v t="ekr.20150403044823.1"></v>
<v t="ekr.20190218055230.1"><vh>efc.warn</vh></v>
</v>
</v>
<v t="ekr.20190306083224.1"><vh>re: Added guards to context menu</vh>
<v t="ekr.20110605121601.18437"><vh>qtree.onContextMenu</vh></v>
</v>
<v t="ekr.20190306142950.1"><vh>g.get_files_in_directory</vh></v>
</v>
<v t="ekr.20180824062242.1"><vh>#958: freeze in vim mode</vh>
<v t="ekr.20110605121601.18005"><vh>class LeoQTextBrowser (QtWidgets.QTextBrowser)</vh>
<v t="ekr.20110605121601.18006"><vh> lqtb.ctor (** no longer instantiates leo_h)</vh></v>
<v t="ekr.20110605121601.18007"><vh>lqtb. __repr__ &amp; __str__</vh></v>
<v t="ekr.20110605121601.18008"><vh>lqtb.Auto completion</vh>
<v t="ekr.20110605121601.18009"><vh>class LeoQListWidget(QListWidget)</vh>
<v t="ekr.20110605121601.18010"><vh>lqlw.ctor</vh></v>
<v t="ekr.20110605121601.18011"><vh>lqlw.closeEvent</vh></v>
<v t="ekr.20110605121601.18012"><vh>lqlw.end_completer</vh></v>
<v t="ekr.20141024170936.7"></v>
<v t="ekr.20110605121601.18013"><vh>lqlw.keyPressEvent</vh></v>
<v t="ekr.20110605121601.18014"><vh>lqlw.select_callback</vh></v>
<v t="tbrown.20111011094944.27031"></v>
<v t="ekr.20110605121601.18015"><vh>lqlw.set_position</vh></v>
<v t="ekr.20110605121601.18016"><vh>lqlw.show_completions</vh></v>
</v>
<v t="ekr.20110605121601.18017"><vh>lqtb.lqtb.init_completer</vh></v>
<v t="ekr.20110605121601.18018"><vh>lqtb.redirections to LeoQListWidget</vh></v>
</v>
<v t="ekr.20110605121601.18019"><vh>lqtb.leo_dumpButton</vh></v>
<v t="ekr.20141103061944.31"><vh>lqtb.get/setXScrollPosition</vh></v>
<v t="ekr.20111002125540.7021"><vh>lqtb.get/setYScrollPosition</vh></v>
<v t="ekr.20120925061642.13506"><vh>lqtb.onSliderChanged</vh></v>
<v t="tbrown.20130411145310.18855"><vh>lqtb.wheelEvent</vh></v>
</v>
<v t="ekr.20180824062905.1"><vh>lqtb.onFocusIn</vh></v>
</v>
<v t="ekr.20181008045948.1"><vh>re: Add toggle-gutter command</vh>
<v t="ekr.20110605121601.18163"><vh>dw.createText</vh></v>
<v t="ekr.20110605121601.18143"><vh>dw.createBodyPane</vh></v>
<v t="ekr.20150403094619.1"><vh>class LeoLineTextWidget(QFrame)</vh>
<v t="ekr.20150403094706.9"><vh>__init__(LeoLineTextWidget)</vh></v>
<v t="ekr.20150403094706.10"><vh>eventFilter</vh></v>
</v>
<v t="ekr.20150403094706.2"><vh>class NumberBar(QFrame)</vh>
<v t="ekr.20150403094706.3"><vh>NumberBar.__init__</vh></v>
<v t="ekr.20181005093003.1"><vh>NumberBar.reloadSettings</vh></v>
<v t="ekr.20181005085507.1"><vh>NumberBar.mousePressEvent</vh></v>
<v t="ekr.20150403094706.5"><vh>NumberBar.update</vh></v>
<v t="ekr.20150403094706.6"><vh>NumberBar.paintEvent</vh></v>
<v t="ekr.20150403094706.7"><vh>NumberBar.paintBlock</vh></v>
<v t="ekr.20150403094706.8"><vh>NumberBar.setBold</vh></v>
</v>
<v t="ekr.20181009123539.1"><vh>qt: toggle-gutter</vh></v>
</v>
<v t="ekr.20181004060958.1"><vh>re: can not happen in jedi completer</vh>
<v t="ekr.20180519111302.1"><vh>ac.get_jedi_completions &amp; helper</vh>
<v t="ekr.20180526211127.1"><vh>ac.add_prefix</vh></v>
</v>
</v>
<v t="ekr.20190216104815.1"><vh>===== #525: nested #clean</vh>
<v t="ekr.20190217060648.1"><vh>ref</vh>
<v t="ekr.20190108054317.1"></v>
<v t="ekr.20190108052043.1"></v>
<v t="ekr.20041005105605.174"></v>
<v t="ekr.20041005105605.216"></v>
<v t="ekr.20041005105605.144"></v>
<v t="ekr.20041005105605.147"></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree</vh></v>
</v>
<v t="ekr.20041005105605.157"></v>
<v t="ekr.20041005105605.161"></v>
<v t="ekr.20041005105605.164"></v>
<v t="ekr.20041005105605.173"></v>
<v t="ekr.20041005105605.163"></v>
<v t="ekr.20041005105605.174"></v>
</v>
<v t="ekr.20190306105229.1"><vh>===== #1032: @clean cleans blank lines</vh>
<v t="ekr.20080708094444.36"><vh>x.propagate_changes</vh></v>
<v t="ekr.20080708094444.38"><vh>x.propagate_changed_lines (main algorithm) &amp; helpers</vh>
<v t="ekr.20150207044400.9"><vh> &lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20150207111757.180"><vh>x.dump_args</vh></v>
<v t="ekr.20150207111757.178"><vh>x.dump_lines</vh></v>
<v t="ekr.20150209044257.6"><vh>x.init_data</vh></v>
<v t="ekr.20080708094444.40"><vh>x.init_ivars</vh></v>
<v t="ekr.20150207044400.16"><vh>x.op_bad</vh></v>
<v t="ekr.20150207044400.12"><vh>x.op_delete</vh></v>
<v t="ekr.20150207044400.13"><vh>x.op_equal</vh></v>
<v t="ekr.20150207044400.14"><vh>x.op_insert</vh></v>
<v t="ekr.20150207044400.15"><vh>x.op_replace</vh></v>
<v t="ekr.20150208060128.7"><vh>x.preprocess</vh></v>
<v t="ekr.20150208223018.4"><vh>x.put_plain_line</vh></v>
<v t="ekr.20150209044257.8"><vh>x.put_sentinels</vh></v>
</v>
<v t="ekr.20190109142026.1"></v>
<v t="ekr.20041005105605.157"></v>
<v t="ekr.20041005105605.161"></v>
<v t="ekr.20041005105605.174"></v>
<v t="ekr.20041005105605.204"></v>
</v>
<v t="ekr.20190316153545.1"><vh>===== #1096 pyzo</vh>
<v t="ekr.20190319024244.1"><vh>checkin: DynamicWindow is just an object</vh></v>
<v t="ekr.20190317083529.1"><vh>Changed &amp; new</vh>
<v t="ekr.20090717112235.6007"></v>
<v t="ekr.20120215072959.12539"><vh>c.config.getShortcut</vh></v>
<v t="ekr.20031219074948.1"></v>
<v t="ekr.20131118172620.16858"><vh>dw.finishCreateLogPane</vh></v>
<v t="tbrown.20110621120042.22914"><vh>flc.get_top_splitter</vh></v>
<v t="ekr.20070626132332"><vh>g.es</vh></v>
<v t="ekr.20061119120006"><vh>LeoFrame.Icon area convenience methods</vh></v>
<v t="ekr.20130921043420.21175"><vh>qt_gui.setFilter</vh></v>
<v t="ekr.20110605121601.18421"><vh>qtree.createTreeItem</vh></v>
</v>
<v t="ekr.20190317082603.1"><vh>COPY pyzo_test.py</vh>
<v t="ekr.20190317082603.2"><vh>&lt;&lt; easy imports &gt;&gt;</vh></v>
<v t="ekr.20190317082603.3"><vh>&lt;&lt; class LeoEmptySplashWidget &gt;&gt;</vh></v>
<v t="ekr.20190317082603.4"><vh>&lt;&lt; class LeoPyzoConfig &gt;&gt;</vh>
<v t="ekr.20190317082603.5"><vh>Dict.__repr__</vh></v>
<v t="ekr.20190317082603.6"><vh>Dict.__getattribute__</vh></v>
<v t="ekr.20190317082603.7"><vh>Dict.__setattr__</vh></v>
<v t="ekr.20190317082603.8"><vh>Dict.__dir__</vh></v>
</v>
<v t="ekr.20190317082603.9"><vh>&lt;&lt; pyzo imports &gt;&gt;</vh></v>
<v t="ekr.20190317082603.10"><vh>class LeoMainWindow (MainWindow)</vh>
<v t="ekr.20190317082603.11"><vh>LeoMainWindow.__init__ (override: don't hold splash)</vh></v>
<v t="ekr.20190317082603.12"><vh>LeoMainWindow._populate (unchanged)</vh></v>
<v t="ekr.20190317082603.13"><vh>LeoMainWindow.setStyleSheet (override)</vh></v>
<v t="ekr.20190317082603.14"><vh>LeoMainWindow.closeEvent (traces)</vh></v>
</v>
</v>
<v t="ekr.20120212060348.10374"><vh> &lt;&lt; global switches &gt;&gt; (leoGlobals.py)</vh></v>
<v t="ekr.20190317082435.1"><vh>&lt;&lt; pyzo imports &gt;&gt; (qt_frame.py)</vh></v>
<v t="ekr.20190317084039.1"><vh>----- new main window</vh>
<v t="ekr.20110605121601.18141"><vh>dw.createMainWindow &amp; helpers</vh>
<v t="ekr.20110605121601.18142"><vh>dw.top-level</vh>
<v t="ekr.20110605121601.18143"></v>
<v t="ekr.20110605121601.18144"><vh>dw.createCentralWidget</vh></v>
<v t="ekr.20110605121601.18145"><vh>dw.createLogPane &amp; helpers</vh>
<v t="ekr.20131118172620.16858"></v>
</v>
<v t="ekr.20110605121601.18146"><vh>dw.createMainLayout</vh></v>
<v t="ekr.20110605121601.18147"><vh>dw.createMenuBar</vh></v>
<v t="ekr.20110605121601.18148"></v>
<v t="ekr.20110605121601.18149"><vh>dw.createOutlinePane</vh></v>
<v t="ekr.20110605121601.18150"><vh>dw.createStatusBar</vh></v>
<v t="ekr.20110605121601.18151"><vh>dw.setMainWindowOptions</vh></v>
</v>
<v t="ekr.20110605121601.18152"><vh>dw.widgets</vh>
<v t="ekr.20110605121601.18153"><vh>dw.createButton</vh></v>
<v t="ekr.20110605121601.18154"><vh>dw.createCheckBox</vh></v>
<v t="ekr.20110605121601.18155"><vh>dw.createFrame</vh></v>
<v t="ekr.20110605121601.18156"><vh>dw.createGrid</vh></v>
<v t="ekr.20110605121601.18157"><vh>dw.createHLayout &amp; createVLayout</vh></v>
<v t="ekr.20110605121601.18158"><vh>dw.createLabel</vh></v>
<v t="ekr.20110605121601.18159"><vh>dw.createLineEdit</vh></v>
<v t="ekr.20110605121601.18160"><vh>dw.createRadioButton</vh></v>
<v t="ekr.20110605121601.18161"><vh>dw.createStackedWidget</vh></v>
<v t="ekr.20110605121601.18162"><vh>dw.createTabWidget</vh></v>
<v t="ekr.20110605121601.18163"></v>
<v t="ekr.20110605121601.18164"><vh>dw.createTreeWidget</vh></v>
</v>
<v t="ekr.20110605121601.18165"><vh>dw.log tabs</vh>
<v t="ekr.20110605121601.18167"><vh>dw.createSpellTab</vh></v>
<v t="ekr.20110605121601.18166"><vh>dw.createFindTab &amp; helpers</vh>
<v t="ekr.20131118152731.16847"><vh>dw.create_find_grid</vh></v>
<v t="ekr.20131118152731.16849"><vh>dw.create_find_header</vh></v>
<v t="ekr.20131118152731.16848"><vh>dw.create_find_findbox</vh></v>
<v t="ekr.20131118152731.16850"><vh>dw.create_find_replacebox</vh></v>
<v t="ekr.20131118152731.16851"><vh>dw.create_find_checkboxes</vh></v>
<v t="ekr.20131118152731.16852"><vh>dw.create_find_buttons</vh></v>
<v t="ekr.20131118152731.16853"><vh>dw.create_help_row</vh></v>
<v t="ekr.20150618072619.1"><vh>dw.create_find_status</vh></v>
<v t="ekr.20131118172620.16891"><vh>dw.override_events</vh>
<v t="ekr.20131118172620.16892"><vh>class EventWrapper</vh>
<v t="ekr.20131120054058.16281"><vh>create_d</vh></v>
<v t="ekr.20131118172620.16893"><vh>wrapper</vh></v>
<v t="ekr.20131118172620.16894"></v>
<v t="ekr.20131118172620.16895"><vh>keyRelease</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20110605121601.18168"><vh>dw.utils</vh>
<v t="ekr.20110605121601.18169"><vh>dw.setName</vh></v>
<v t="ekr.20110605121601.18170"><vh>dw.setSizePolicy</vh></v>
<v t="ekr.20110605121601.18171"><vh>dw.tr</vh></v>
</v>
</v>
<v t="ekr.20110605121601.18139"><vh>dw.construct &amp; helpers</vh>
<v t="ekr.20140915062551.19519"><vh>dw.set_icon_bar_orientation</vh></v>
</v>
<v t="ekr.20190317084000.1"><vh>dw.createPyzoMainWindow (*** new)</vh></v>
</v>
<v t="ekr.20110605121601.18464"><vh>class TabbedFrameFactory</vh>
<v t="ekr.20110605121601.18465"><vh> ctor (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18466"><vh>createFrame (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18468"><vh>createMaster (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18472"><vh>createTabCommands (TabbedFrameFactory)</vh>
<v t="ekr.20110605121601.18473"><vh>&lt;&lt; Commands for tabs &gt;&gt;</vh></v>
</v>
<v t="ekr.20110605121601.18467"><vh>deleteFrame (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18471"><vh>focusCurrentBody (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18469"><vh>setTabForCommander (TabbedFrameFactory)</vh></v>
<v t="ekr.20110605121601.18470"><vh>signal handlers (TabbedFrameFactory)</vh></v>
</v>
<v t="ekr.20110605121601.18137"><vh>class  DynamicWindow (QtWidgets.QMainWindow)</vh>
<v t="ekr.20110605121601.18138"><vh> ctor &amp; reloadSettings (DynamicWindow)</vh></v>
<v t="ekr.20110605121601.18172"><vh>do_leo_spell_btn_*</vh></v>
<v t="ekr.20110605121601.18139"></v>
<v t="ekr.20110605121601.18141"></v>
<v t="ekr.20110605121601.18179"><vh>dw.Event handlers</vh>
<v t="ekr.20110605121601.18140"><vh>dw.closeEvent</vh></v>
</v>
<v t="ekr.20110605121601.18173"><vh>dw.select</vh></v>
<v t="ekr.20110605121601.18178"><vh>dw.setGeometry</vh></v>
<v t="ekr.20110605121601.18177"><vh>dw.setLeoWindowIcon</vh></v>
<v t="ekr.20110605121601.18174"><vh>dw.setSplitDirection</vh></v>
<v t="ekr.20130804061744.12425"><vh>dw.setWindowTitle</vh></v>
</v>
<v t="ekr.20190317084647.1"><vh>class LeoPyzoMainWindow (MainWindow) (new)</vh>
<v t="ekr.20190317084647.2"><vh>LeoPyzoMainWindow.__init__ (override: don't hold splash)</vh></v>
<v t="ekr.20190317084647.3"><vh>LeoPyzoMainWindow._populate (unchanged)</vh></v>
<v t="ekr.20190317084647.4"><vh>LeoPyzoMainWindow.setStyleSheet (override)</vh></v>
<v t="ekr.20190317084647.5"><vh>LeoPyzoMainWindow.closeEvent (traces)</vh></v>
</v>
<v t="ekr.20190319022339.1"><vh>----- call order</vh></v>
<v t="ekr.20110605121601.18250"><vh>qtFrame.finishCreate &amp; helpers</vh>
<v t="ekr.20110605121601.18251"><vh>qtFrame.createSplitterComponents</vh></v>
</v>
<v t="ekr.20110605121601.18466"></v>
<v t="ekr.20110605121601.18139"></v>
<v t="ekr.20190317084000.1"></v>
<v t="ekr.20190317084647.2"></v>
</v>
</v>
<v t="ekr.20140827092102.18574"></v>
<v t="ekr.20190319150024.1"><vh>===== pygments</vh>
<v t="ekr.20190319151056.1"><vh> Not used</vh>
<v t="ekr.20190321002423.1"><vh>COPY: old pyg_c.mainLoop</vh></v>
<v t="ekr.20170428054142.1"><vh>leo_h.force_rehighlight</vh></v>
<v t="ekr.20110605121601.18568"><vh>leo_h.rehighlight (disabled)</vh></v>
<v t="ekr.20190319151826.23"><vh> pygments.Pattern matchers</vh>
<v t="ekr.20190319151826.24"><vh> About the pattern matchers</vh></v>
<v t="ekr.20190319151826.25"><vh>pygments.dump</vh></v>
<v t="ekr.20190319151826.26"><vh>pygments.Leo rule functions</vh>
<v t="ekr.20190319151826.27"><vh>pygments.match_at_color</vh>
<v t="ekr.20190319151826.28"><vh>restartColor</vh></v>
</v>
<v t="ekr.20190319151826.29"><vh>pygments.match_at_killcolor &amp; restarter</vh>
<v t="ekr.20190319151826.30"><vh>pygments.restartKillColor</vh></v>
</v>
<v t="ekr.20190319151826.31"><vh>pygments.match_at_language</vh></v>
<v t="ekr.20190319151826.32"><vh>pygments.match_at_nocolor &amp; restarter</vh>
<v t="ekr.20190319151826.33"><vh>pygments.restartNoColor</vh></v>
</v>
<v t="ekr.20190319151826.34"><vh>pygments.match_at_nocolor_node &amp; restarter</vh>
<v t="ekr.20190319151826.35"><vh>pygments.restartNoColorNode</vh></v>
</v>
<v t="ekr.20190319151826.36"><vh>pygments.match_at_wrap</vh></v>
<v t="ekr.20190319151826.37"><vh>pygments.match_blanks</vh></v>
<v t="ekr.20190319151826.38"><vh>pygments.match_doc_part &amp; restarter</vh>
<v t="ekr.20190319151826.39"><vh>pygments.restartDocPart</vh></v>
</v>
<v t="ekr.20190319151826.40"><vh>pygments.match_image</vh></v>
<v t="ekr.20190319151826.41"><vh>pygments.match_leo_keywords</vh></v>
<v t="ekr.20190319151826.42"><vh>pygments.match_section_ref</vh>
<v t="ekr.20190319151826.43"><vh>&lt;&lt; set the hyperlink &gt;&gt; (jedit)</vh></v>
</v>
<v t="ekr.20190319151826.44"><vh>pygments.match_tabs</vh></v>
<v t="ekr.20190319151826.45"><vh>pygments.match_tabs</vh></v>
<v t="ekr.20190319151826.46"><vh>pygments.match_unl</vh></v>
<v t="ekr.20190319151826.47"><vh>pygments.match_url_any/f/h</vh></v>
</v>
<v t="ekr.20190319151826.48"><vh>pygments.match_compiled_regexp</vh>
<v t="ekr.20190319151826.49"><vh>pygments.match_compiled_regexp_helper</vh></v>
</v>
<v t="ekr.20190319151826.50"><vh>pygments.match_eol_span</vh></v>
<v t="ekr.20190319151826.51"><vh>pygments.match_eol_span_regexp</vh></v>
<v t="ekr.20190319151826.52"><vh>pygments.match_everything</vh></v>
<v t="ekr.20190319151826.53"><vh>pygments.match_keywords</vh></v>
<v t="ekr.20190319151826.54"><vh>pygments.match_line</vh></v>
<v t="ekr.20190319151826.55"><vh>pygments.match_mark_following &amp; getNextToken</vh>
<v t="ekr.20190319151826.56"><vh>pygments.getNextToken</vh></v>
</v>
<v t="ekr.20190319151826.57"><vh>pygments.match_mark_previous</vh></v>
<v t="ekr.20190319151826.58"><vh>pygments.match_regexp_helper</vh></v>
<v t="ekr.20190319151826.59"><vh>pygments.match_seq</vh></v>
<v t="ekr.20190319151826.60"><vh>pygments.match_seq_regexp</vh></v>
<v t="ekr.20190319151826.61"><vh>pygments.match_span &amp; helper &amp; restarter</vh>
<v t="ekr.20190319151826.62"><vh>pygments.match_span_helper</vh></v>
<v t="ekr.20190319151826.63"><vh>pygments.restart_match_span</vh></v>
</v>
<v t="ekr.20190319151826.64"><vh>pygments.match_span_regexp</vh></v>
<v t="ekr.20190319151826.65"><vh>pygments.match_wiki_pattern</vh></v>
<v t="ekr.20190319151826.66"><vh>pygments.match_word_and_regexp</vh></v>
<v t="ekr.20190319151826.67"><vh>pygments.skip_line</vh></v>
<v t="ekr.20190319151826.68"><vh>pygments.trace_match</vh></v>
</v>
<v t="ekr.20190319151826.8"><vh>pygments.addImportedRules</vh></v>
<v t="ekr.20190320062624.6"><vh>class PygmentsHighlighter(QSyntaxHighlighter) (NOT YET)</vh>
<v t="ekr.20190320062624.7"><vh>pyg_h.__init__</vh></v>
<v t="ekr.20190320062624.8"><vh>pyg_h.highlightBlock</vh></v>
<v t="ekr.20190320062624.9"><vh>pyg_h.set_style</vh></v>
<v t="ekr.20190320062624.10"><vh>pyg_h.set_style_sheet (not used)</vh></v>
<v t="ekr.20190320063234.1"><vh>Protected interface</vh>
<v t="ekr.20190320062624.11"><vh>pyg_h._clear_caches</vh></v>
<v t="ekr.20190320062624.12"><vh>pyg_h._get_format &amp; helpers</vh>
<v t="ekr.20190320062624.13"><vh>pyg_h._get_format_from_document</vh></v>
<v t="ekr.20190320062624.14"><vh>pyg_h._get_format_from_style</vh></v>
<v t="ekr.20190320062624.15"><vh>pyg_h._get_brush</vh></v>
<v t="ekr.20190320062624.16"><vh>pyg_h._get_color</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20190319192254.1"><vh> Changed</vh>
<v t="ekr.20190319151826.16"><vh>pyg_c.init_mode_from_module (changed)</vh></v>
<v t="ekr.20190319151826.78"><vh>pyg_c.mainLoop (new) (to do: Leonine features)</vh></v>
</v>
<v t="ekr.20190319150835.1"><vh>print pygments tokens</vh></v>
</v>
<v t="ekr.20190321124036.1"><vh>----- style prototypes</vh>
<v t="ekr.20190319185726.1"><vh>python wrapper.configDict</vh></v>
<v t="ekr.20190321104651.1"><vh>color settings</vh></v>
<v t="ekr.20190321104134.1"><vh>style</vh></v>
<v t="ekr.20190321112916.1"><vh>dynamic style</vh>
<v t="ekr.20190321120119.1"><vh>is_valid_color</vh></v>
</v>
<v t="ekr.20190321130021.1"><vh>&lt;&lt; define class LeonineStyle &gt;&gt; (not used)</vh>
<v t="ekr.20190321130235.2"><vh>StyleMeta.__new__ (disabled)</vh></v>
<v t="ekr.20190321130235.3"><vh>StyleMeta.style_for_token (hacked)</vh></v>
<v t="ekr.20190321130235.4"><vh>StyleMeta.list_styles</vh></v>
<v t="ekr.20190321130235.5"><vh>StyleMeta.styles_token</vh></v>
<v t="ekr.20190321130235.6"><vh>StyleMeta.__iter__</vh></v>
<v t="ekr.20190321130235.7"><vh>StyleMeta.__len__</vh></v>
</v>
<v t="ekr.20190321170917.1"><vh>leo_h.patch_leo_styles</vh></v>
<v t="ekr.20190321104651.1"></v>
<v t="ekr.20190321182604.1"><vh>EKRDark.leo Colors...</vh>
<v t="ekr.20190321182604.2"><vh>Base colors: not all are solarized colors</vh>
<v t="ekr.20190321182604.3"><vh>@color dark-base0 = #fdffdd</vh></v>
<v t="ekr.20190321182604.4"><vh>@color dark-base00 = #657b83</vh></v>
<v t="ekr.20190321182604.5"><vh>@color dark-base01 = #586e75</vh></v>
<v t="ekr.20190321182604.6"><vh>@color dark-base02 = #073642</vh></v>
<v t="ekr.20190321182604.7"><vh>@color dark-base03 = #000005</vh></v>
<v t="ekr.20190321182604.8"><vh>@color dark-base04 = #000059</vh></v>
<v t="ekr.20190321182604.9"><vh>@color dark-base05 = #003b00</vh></v>
<v t="ekr.20190321182604.10"><vh>@color dark-base06 = #3b0000</vh></v>
<v t="ekr.20190321182604.11"><vh>@color dark-base1 = #93a1a1</vh></v>
<v t="ekr.20190321182604.12"><vh>@color dark-base2 = #eee8d5</vh></v>
<v t="ekr.20190321182604.13"><vh>@color dark-base3 = #fdf6e3</vh></v>
<v t="ekr.20190321182604.14"><vh>@color solarized-black = #000005</vh></v>
<v t="ekr.20190321182604.15"><vh>@color solarized-blue = #268bd2</vh></v>
<v t="ekr.20190321182604.16"><vh>@color solarized-cyan = #2aa198</vh></v>
<v t="ekr.20190321182604.17"><vh>@color solarized-green = #859900</vh></v>
<v t="ekr.20190321182604.18"><vh>@color solarized-magenta = #d33682</vh></v>
<v t="ekr.20190321182604.19"><vh>@color solarized-red = #dc322f</vh></v>
<v t="ekr.20190321182604.20"><vh>@color solarized-orange = #cb4b16</vh></v>
<v t="ekr.20190321182604.21"><vh>@color solarized-violet = #6c71c4</vh></v>
<v t="ekr.20190321182604.22"><vh>@color solarized-white = #fdf6e3 </vh></v>
<v t="ekr.20190321182604.23"><vh>@color solarized-yellow = #b58900</vh></v>
</v>
<v t="ekr.20190321182604.24"><vh>Colors: Logical colors</vh>
<v t="ekr.20190321182604.25"><vh>@color LeoBlue = @LightSteelBlue1</vh></v>
<v t="ekr.20190321182604.26"><vh>@color LeoGreen = #00AA00</vh></v>
<v t="ekr.20190321182604.27"><vh>@color LeoYellow = @LightYellow</vh></v>
<v t="ekr.20190321182604.28"><vh>@color log_black_color = @text-foreground</vh></v>
<v t="ekr.20190321182604.29"><vh>@color log_blue_color = @solarized-blue</vh></v>
<v t="ekr.20190321182604.30"><vh>@color log_cyan_color = @solarized-cyan</vh></v>
<v t="ekr.20190321182604.31"><vh>@color log_error_color =@solarized-red</vh></v>
<v t="ekr.20190321182604.32"><vh>@color log_green_color = @solarized-green</vh></v>
<v t="ekr.20190321182604.33"><vh>@color log_info_color = @solarized-blue</vh></v>
<v t="ekr.20190321182604.34"><vh>@color log_magenta_color = @solarized-magenta</vh></v>
<v t="ekr.20190321182604.35"><vh>@color log_note_color = @solarized-blue</vh></v>
<v t="ekr.20190321182604.36"><vh>@color log_orange_color = @solarized-orange</vh></v>
<v t="ekr.20190321182604.37"><vh>@color log_red_color = @solarized-red</vh></v>
<v t="ekr.20190321182604.38"><vh>@color log_violet_color = @solarized-violet</vh></v>
<v t="ekr.20190321182604.39"><vh>@color log_warning_color = @solarized-red</vh></v>
<v t="ekr.20190321182604.40"><vh>@color log_white_color = @solarized-white</vh></v>
<v t="ekr.20190321182604.41"><vh>@color log_yellow_color = @solarized-yellow</vh></v>
</v>
<v t="ekr.20190321182604.42"><vh>Colors: Syntax coloring</vh>
<v t="ekr.20190321182604.43"><vh>Colors: defaults</vh>
<v t="ekr.20190321182604.44"><vh>@color alt_solarized_green = #84c805</vh></v>
<v t="ekr.20190321182604.45"><vh>@color blank_color = grey</vh></v>
<v t="ekr.20190321182604.46"><vh>@color tab_color = red</vh></v>
<v t="ekr.20190321182604.47"><vh>@color label_color = red</vh></v>
<v t="ekr.20190321182604.48"><vh>@color keyword1_color = #268bd2</vh></v>
<v t="ekr.20190321182604.49"><vh>@color keyword2_color = #268bd2</vh></v>
<v t="ekr.20190321182604.50"><vh>@color keyword3_color = #268bd2</vh></v>
<v t="ekr.20190321182604.51"><vh>@color keyword4_color = #268bd2</vh></v>
<v t="ekr.20190321182604.52"><vh>@color literal1_color = @alt-solarized-green</vh></v>
<v t="ekr.20190321182604.53"><vh>@color literal2_color = @alt-solarized-green</vh></v>
<v t="ekr.20190321182604.54"><vh>@color literal3_color = @alt-solarized-green</vh></v>
<v t="ekr.20190321182604.55"><vh>@color literal4_color = @alt-solarized-green</vh></v>
<v t="ekr.20190321182604.56"><vh>@color markup_color = #268bd2</vh></v>
<v t="ekr.20190321182604.57"><vh>@color comment1_color = #d33682</vh></v>
<v t="ekr.20190321182604.58"><vh>@color comment2_color = #d33682</vh></v>
<v t="ekr.20190321182604.59"><vh>@color comment3_color = #d33682</vh></v>
<v t="ekr.20190321182604.60"><vh>@color comment4_color = #d33682</vh></v>
</v>
<v t="ekr.20190321182604.61"><vh>Colors: Leo constructs</vh>
<v t="ekr.20190321182604.62"><vh>@color section_name_brackets_color = @solarized-blue</vh></v>
<v t="ekr.20190321182604.63"><vh>@color null_color = #6c71c4</vh></v>
<v t="ekr.20190321182604.64"><vh>@color operator_color = #6c71c4</vh></v>
<v t="ekr.20190321182604.65"><vh>@color doc_part_color = @solarized-red</vh></v>
<v t="ekr.20190321182604.66"><vh>@color leo_keyword_color = @literal1_color</vh></v>
<v t="ekr.20190321182604.67"><vh>@color section_name_color = @solarized-red</vh></v>
<v t="ekr.20190321182604.68"><vh>@color show_invisibles_space_color = #E5E5E5</vh></v>
<v t="ekr.20190321182604.69"><vh>@color show_invisibles_tab_color = #CCCCCC</vh></v>
<v t="ekr.20190321182604.70"><vh>@color undefined_section_name_color = red</vh></v>
<v t="ekr.20190321182604.71"><vh>@color url_color = @solarized-purple</vh></v>
</v>
<v t="ekr.20190321182604.72"><vh>Colors: patch (diff)</vh>
<v t="ekr.20190321182604.73"><vh>@color patch_keyword1_color = @solarized-green</vh></v>
<v t="ekr.20190321182604.74"><vh>@color patch_keyword2_color = @solarized-red</vh></v>
<v t="ekr.20190321182604.75"><vh>@color patch_keyword3_color = @solarized-blue</vh></v>
<v t="ekr.20190321182604.76"><vh>@color patch_literal1_color = @solarized-blue</vh></v>
<v t="ekr.20190321182604.77"><vh>@color patch_literal2_color = @solarized-blue</vh></v>
</v>
</v>
<v t="ekr.20190321182604.78"><vh>Colors: Text</vh>
<v t="ekr.20190321182604.79"><vh>@color log_text_background_color = #000005</vh></v>
<v t="ekr.20190321182604.80"><vh>@color log_text_foreground_color = #ffffff</vh></v>
<v t="ekr.20190321182604.81"><vh>@color text-background =@dark-base03</vh></v>
<v t="ekr.20190321182604.82"><vh>@color text-background-bright =@dark-base02</vh></v>
<v t="ekr.20190321182604.83"><vh>@color text-foreground =@dark-base0</vh></v>
<v t="ekr.20190321182604.84"><vh>@color text-foreground-bright =@dark-base2</vh></v>
</v>
<v t="ekr.20190321182604.85"><vh>Colors: Widgets</vh>
<v t="ekr.20190321182604.86"><vh>@color button-hover-fg =@dark-base03</vh></v>
</v>
</v>
</v>
<v t="ekr.20120212060348.10374"></v>
<v t="ekr.20140827092102.18575"><vh>&lt;&lt; imports &gt;&gt; (leoColorizer.py)</vh></v>
<v t="ekr.20190320161623.1"><vh>----- classes</vh>
<v t="ekr.20110605121601.18569"><vh>class JEditColorizer(BaseColorizer)</vh>
<v t="ekr.20110605121601.18571"><vh> jedit.Birth &amp; init</vh>
<v t="ekr.20110605121601.18572"><vh>jedit.__init &amp; helpers</vh>
<v t="ekr.20110605121601.18573"><vh>jedit.defineLeoKeywordsDict</vh></v>
<v t="ekr.20110605121601.18574"><vh>jedit.defineDefaultColorsDict</vh></v>
<v t="ekr.20110605121601.18575"><vh>jedit.defineDefaultFontDict</vh></v>
<v t="ekr.20171114041307.1"><vh>jedit.reloadSettings</vh></v>
</v>
<v t="ekr.20110605121601.18576"><vh>jedit.addImportedRules</vh></v>
<v t="ekr.20110605121601.18577"></v>
<v t="ekr.20111024091133.16702"><vh>jedit.configure_hard_tab_width</vh></v>
<v t="ekr.20110605121601.18578"><vh>jedit.configure_tags</vh></v>
<v t="ekr.20110605121601.18579"><vh>jedit.configure_variable_tags</vh></v>
<v t="ekr.20110605121601.18580"><vh>jedit.init</vh></v>
<v t="ekr.20170201082248.1"><vh>jedit.init_all_state</vh></v>
<v t="ekr.20110605121601.18581"><vh>jedit.init_mode &amp; helpers</vh>
<v t="btheado.20131124162237.16303"><vh>jedit.init_mode_from_module</vh></v>
<v t="ekr.20110605121601.18582"><vh>jedit.nameToRulesetName</vh></v>
<v t="ekr.20110605121601.18583"><vh>jedit.setKeywords</vh></v>
<v t="ekr.20110605121601.18584"><vh>jedit.setModeAttributes</vh></v>
<v t="ekr.20110605121601.18585"><vh>jedit.initModeFromBunch</vh></v>
<v t="ekr.20110605121601.18586"><vh>jedit.updateDelimsTables</vh></v>
</v>
<v t="ekr.20110605121601.18587"><vh>jedit.munge</vh></v>
</v>
<v t="ekr.20110605121601.18589"><vh> jedit.Pattern matchers</vh>
<v t="ekr.20110605121601.18590"><vh> About the pattern matchers</vh></v>
<v t="ekr.20110605121601.18591"><vh>jedit.dump</vh></v>
<v t="ekr.20110605121601.18592"><vh>jedit.Leo rule functions</vh>
<v t="ekr.20110605121601.18593"><vh>jedit.match_at_color</vh>
<v t="ekr.20170125140113.1"><vh>restartColor</vh></v>
</v>
<v t="ekr.20110605121601.18597"><vh>jedit.match_at_killcolor &amp; restarter</vh>
<v t="ekr.20110605121601.18598"><vh>jedit.restartKillColor</vh></v>
</v>
<v t="ekr.20110605121601.18594"><vh>jedit.match_at_language</vh></v>
<v t="ekr.20110605121601.18595"><vh>jedit.match_at_nocolor &amp; restarter</vh>
<v t="ekr.20110605121601.18596"><vh>jedit.restartNoColor</vh></v>
</v>
<v t="ekr.20110605121601.18599"><vh>jedit.match_at_nocolor_node &amp; restarter</vh>
<v t="ekr.20110605121601.18600"><vh>jedit.restartNoColorNode</vh></v>
</v>
<v t="ekr.20150622072456.1"><vh>jedit.match_at_wrap</vh></v>
<v t="ekr.20110605121601.18601"><vh>jedit.match_blanks</vh></v>
<v t="ekr.20110605121601.18602"><vh>jedit.match_doc_part &amp; restarter</vh>
<v t="ekr.20110605121601.18603"><vh>jedit.restartDocPart</vh></v>
</v>
<v t="ekr.20170204072452.1"><vh>jedit.match_image</vh></v>
<v t="ekr.20110605121601.18604"><vh>jedit.match_leo_keywords</vh></v>
<v t="ekr.20110605121601.18605"><vh>jedit.match_section_ref</vh>
<v t="ekr.20110605121601.18606"><vh>&lt;&lt; set the hyperlink &gt;&gt; (jedit)</vh></v>
</v>
<v t="ekr.20110605121601.18607"><vh>jedit.match_tabs</vh></v>
<v t="tbrown.20170707150713.1"><vh>jedit.match_tabs</vh></v>
<v t="ekr.20170225103140.1"><vh>jedit.match_unl</vh></v>
<v t="ekr.20110605121601.18608"><vh>jedit.match_url_any/f/h</vh></v>
</v>
<v t="ekr.20110605121601.18609"><vh>jedit.match_compiled_regexp</vh>
<v t="ekr.20110605121601.18610"><vh>jedit.match_compiled_regexp_helper</vh></v>
</v>
<v t="ekr.20110605121601.18611"><vh>jedit.match_eol_span</vh></v>
<v t="ekr.20110605121601.18612"><vh>jedit.match_eol_span_regexp</vh></v>
<v t="ekr.20110605121601.18613"><vh>jedit.match_everything</vh></v>
<v t="ekr.20110605121601.18614"><vh>jedit.match_keywords</vh></v>
<v t="ekr.20110605121601.18615"><vh>jedit.match_line</vh></v>
<v t="ekr.20110605121601.18616"><vh>jedit.match_mark_following &amp; getNextToken</vh>
<v t="ekr.20110605121601.18617"><vh>jedit.getNextToken</vh></v>
</v>
<v t="ekr.20110605121601.18618"><vh>jedit.match_mark_previous</vh></v>
<v t="ekr.20110605121601.18619"><vh>jedit.match_regexp_helper</vh></v>
<v t="ekr.20110605121601.18620"><vh>jedit.match_seq</vh></v>
<v t="ekr.20110605121601.18621"><vh>jedit.match_seq_regexp</vh></v>
<v t="ekr.20110605121601.18622"><vh>jedit.match_span &amp; helper &amp; restarter</vh>
<v t="ekr.20110605121601.18623"><vh>jedit.match_span_helper</vh></v>
<v t="ekr.20110605121601.18624"><vh>jedit.restart_match_span</vh></v>
</v>
<v t="ekr.20110605121601.18625"><vh>jedit.match_span_regexp</vh></v>
<v t="ekr.20170205074106.1"><vh>jedit.match_wiki_pattern</vh></v>
<v t="ekr.20110605121601.18626"><vh>jedit.match_word_and_regexp</vh></v>
<v t="ekr.20110605121601.18627"><vh>jedit.skip_line</vh></v>
<v t="ekr.20110605121601.18628"><vh>jedit.trace_match</vh></v>
</v>
<v t="ekr.20110605121601.18629"><vh> jedit.State methods</vh>
<v t="ekr.20110605121601.18630"><vh>jedit.clearState</vh></v>
<v t="ekr.20110605121601.18631"><vh>jedit.computeState</vh></v>
<v t="ekr.20110605121601.18632"><vh>jedit.getters &amp; setters</vh></v>
<v t="ekr.20170125141148.1"><vh>jedit.inColorState</vh></v>
<v t="ekr.20110605121601.18633"><vh>jedit.setRestart</vh></v>
<v t="ekr.20110605121601.18635"><vh>jedit.show...</vh></v>
<v t="ekr.20110605121601.18636"><vh>jedit.stateNameToStateNumber</vh></v>
</v>
<v t="ekr.20110605121601.18637"><vh>jedit.colorRangeWithTag</vh></v>
<v t="ekr.20110605121601.18638"><vh>jedit.mainLoop</vh></v>
<v t="ekr.20110605121601.18640"><vh>jedit.recolor (color one line)</vh>
<v t="ekr.20170126100139.1"><vh>jedit.initBlock0</vh></v>
<v t="ekr.20170126101049.1"><vh>jedit.setInitialStateNumber</vh></v>
<v t="ekr.20170126103925.1"><vh>jedit.languageTag</vh></v>
</v>
<v t="ekr.20170205055743.1"><vh>jedit.set_wikiview_patterns</vh></v>
<v t="ekr.20110605121601.18641"><vh>jedit.setTag</vh></v>
</v>
<v t="ekr.20170127141855.1"><vh>class BaseColorizer (object)</vh>
<v t="ekr.20170127142001.1"><vh>bc.updateSyntaxColorer &amp; helpers</vh>
<v t="ekr.20170127142001.2"><vh>bc.scanLanguageDirectives &amp; helpers</vh>
<v t="ekr.20170201150505.1"><vh>bc.findAllValidLanguageDirectives</vh></v>
<v t="ekr.20170127142001.5"><vh>bc.findFirstAtLanguageDirective</vh></v>
<v t="ekr.20170127142001.6"><vh>bc.isValidLanguage</vh></v>
</v>
<v t="ekr.20170127142001.7"><vh>bc.useSyntaxColoring &amp; helper</vh>
<v t="ekr.20170127142001.8"><vh>bc.findColorDirectives</vh></v>
</v>
</v>
<v t="ekr.20170514054524.1"><vh>bc.fonts</vh></v>
</v>
<v t="ekr.20110605121601.18565"><vh>class LeoHighlighter (QSyntaxHighlighter)</vh>
<v t="ekr.20110605121601.18566"><vh>leo_h.ctor</vh></v>
<v t="ekr.20110605121601.18567"><vh>leo_h.highlightBlock</vh></v>
<v t="ekr.20190320154014.1"><vh>leo_h: From PygmentsHighlighter</vh>
<v t="ekr.20190320153605.1"><vh>leo_h._get_format &amp; helpers</vh>
<v t="ekr.20190320162831.1"><vh>pyg_h._get_format_from_document</vh></v>
<v t="ekr.20190320153716.1"><vh>leo_h._get_format_from_style</vh></v>
</v>
<v t="ekr.20190320153958.1"><vh>leo_h.setStyle</vh></v>
<v t="ekr.20190320154604.1"><vh>leo_h.clear_caches</vh></v>
<v t="ekr.20190320154752.1"><vh>leo_h._get_brush/color</vh></v>
</v>
</v>
<v t="ekr.20190321004028.1"><vh>-----</vh></v>
<v t="ekr.20190319151826.1"><vh>class PygmentsColorizer(BaseColorizer)</vh>
<v t="ekr.20190319151826.2"><vh> pyg_c.Birth &amp; init</vh>
<v t="ekr.20190319151826.3"><vh>pyg_c.__init &amp; helpers</vh>
<v t="ekr.20190319151826.4"><vh>pyg_c.defineLeoKeywordsDict</vh></v>
<v t="ekr.20190319151826.5"><vh>pyg_c.defineDefaultColorsDict</vh></v>
<v t="ekr.20190319151826.6"><vh>pyg_c.defineDefaultFontDict</vh></v>
<v t="ekr.20190319151826.7"><vh>pyg_c.reloadSettings</vh></v>
</v>
<v t="ekr.20190319151826.9"><vh>pyg_c.addLeoRules (to do)</vh></v>
<v t="ekr.20190319151826.10"><vh>pyg_c.configure_hard_tab_width</vh></v>
<v t="ekr.20190319151826.11"><vh>pyg_c.configure_tags</vh></v>
<v t="ekr.20190319151826.12"><vh>pyg_c.configure_variable_tags</vh></v>
<v t="ekr.20190319151826.13"><vh>pyg_c.init</vh></v>
<v t="ekr.20190319151826.14"><vh>pyg_c.init_all_state</vh></v>
<v t="ekr.20190319151826.15"><vh>pyg_c.init_mode &amp; helpers</vh>
<v t="ekr.20190319151826.16"></v>
<v t="ekr.20190319151826.17"><vh>pyg_c.nameToRulesetName</vh></v>
<v t="ekr.20190319151826.18"><vh>pyg_c.setKeywords</vh></v>
<v t="ekr.20190319151826.19"><vh>pyg_c.setModeAttributes</vh></v>
<v t="ekr.20190319151826.20"><vh>pyg_c.initModeFromBunch</vh></v>
<v t="ekr.20190319151826.21"><vh>pyg_c.updateDelimsTables</vh></v>
</v>
<v t="ekr.20190319151826.22"><vh>pyg_c.munge</vh></v>
</v>
<v t="ekr.20190319151826.69"><vh> pyg_c.State methods</vh>
<v t="ekr.20190319151826.70"><vh>pyg_c.clearState</vh></v>
<v t="ekr.20190319151826.71"><vh>pyg_c.computeState</vh></v>
<v t="ekr.20190319151826.72"><vh>pyg_c.getters &amp; setters</vh></v>
<v t="ekr.20190319151826.73"><vh>pyg_c.inColorState</vh></v>
<v t="ekr.20190319151826.74"><vh>pyg_c.setRestart</vh></v>
<v t="ekr.20190319151826.75"><vh>pyg_c.show...</vh></v>
<v t="ekr.20190319151826.76"><vh>pyg_c.stateNameToStateNumber</vh></v>
</v>
<v t="ekr.20190319151826.77"><vh>pyg_c.colorRangeWithTag</vh></v>
<v t="ekr.20190319151826.78"></v>
<v t="ekr.20190319151826.79"><vh>pyg_c.recolor</vh>
<v t="ekr.20190319151826.80"><vh>pyg_c.initBlock0</vh></v>
<v t="ekr.20190320084740.1"><vh>pyg_c.restartNoColor</vh></v>
<v t="ekr.20190319151826.81"><vh>pyg_c.setInitialStateNumber</vh></v>
<v t="ekr.20190319151826.82"><vh>pyg_c.languageTag</vh></v>
</v>
<v t="ekr.20190319151826.83"><vh>pyg_c.set_wikiview_patterns</vh></v>
<v t="ekr.20190319151826.84"><vh>pyg_c.setTag</vh></v>
</v>
<v t="ekr.20190320062624.3"><vh>class PygmentsBlockUserData(QTextBlockUserData)</vh></v>
</v>
<v t="ekr.20190319151826.78"></v>
<v t="ekr.20190321205442.1"><vh>subclassing lexer</vh>
<v t="ekr.20190321205811.1"><vh>&lt;&lt; section reference &gt;&gt;</vh></v>
</v>
<v t="ekr.20190322040433.1"><vh>git diff HEAD </vh>
<v t="ekr.20190322040433.2"><vh>leo/core/leoColorizer.py</vh>
<v t="ekr.20190322040433.9"><vh>Changed</vh>
<v t="ekr.20190322040433.10"><vh>pyg_c.mainLoop (new) (to do: Leonine features)</vh>
<v t="ekr.20190322040433.11"><vh>Old:pyg_c.mainLoop (new) (to do: Leonine features)</vh></v>
<v t="ekr.20190319151826.78"></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943">@nosearch
</t>
<t tx="bob.20071231111744.2">def getColor(name, default=None):
    """ Translate a named color into #rrggbb' format.

    if 'name' is not a string it is returned unchanged.

    If 'name' is already in '#rrggbb' format then it is returned unchanged.

    If 'name' is not in global_color_database then getColor(default, None)
    is called and that result returned.
    """
    if not g.isString(name):
        return name
    if name[0] == '#':
        return name
    name = name.replace(' ', '').lower().strip()
    if name in leo_color_database:
        name2 = leo_color_database[name]
        return name2
    if default:
        return getColor(default, default=None)
    return None

get = getColor
</t>
<t tx="btheado.20131124162237.16303">def init_mode_from_module(self, name, mode):
    '''Name may be a language name or a delegate name.
       Mode is a python module or class containing all
       coloring rule attributes for the mode.
    '''
    language, rulesetName = self.nameToRulesetName(name)
    if mode:
        # A hack to give modes/forth.py access to c.
        if hasattr(mode, 'pre_init_mode'):
            mode.pre_init_mode(self.c)
    else:
        # Create a dummy bunch to limit recursion.
        self.modes[rulesetName] = self.modeBunch = g.Bunch(
            attributesDict={},
            defaultColor=None,
            keywordsDict={},
            language='unknown-language',
            mode=mode,
            properties={},
            rulesDict={},
            rulesetName=rulesetName,
            word_chars=self.word_chars, # 2011/05/21
        )
        self.rulesetName = rulesetName
        self.language = 'unknown-language'
        return False
    self.language = language
    self.rulesetName = rulesetName
    self.properties = getattr(mode, 'properties', None) or {}
    self.keywordsDict = mode.keywordsDictDict.get(rulesetName, {}) if hasattr(mode, 'keywordsDictDict') else {}
    self.setKeywords()
    self.attributesDict = mode.attributesDictDict.get(rulesetName) if hasattr(mode, 'attributesDictDict') else {}
    self.setModeAttributes()
    self.rulesDict = mode.rulesDictDict.get(rulesetName) if hasattr(mode, 'rulesDictDict') else {}
    self.addLeoRules(self.rulesDict)
    self.defaultColor = 'null'
    self.mode = mode
    self.modes[rulesetName] = self.modeBunch = g.Bunch(
        attributesDict=self.attributesDict,
        defaultColor=self.defaultColor,
        keywordsDict=self.keywordsDict,
        language = self.language,
        mode=self.mode,
        properties=self.properties,
        rulesDict=self.rulesDict,
        rulesetName=self.rulesetName,
        word_chars=self.word_chars, # 2011/05/21
    )
    # Do this after 'officially' initing the mode, to limit recursion.
    self.addImportedRules(mode, self.rulesDict, rulesetName)
    self.updateDelimsTables()
    initialDelegate = self.properties.get('initialModeDelegate')
    if initialDelegate:
        # Replace the original mode by the delegate mode.
        self.init_mode(initialDelegate)
        language2, rulesetName2 = self.nameToRulesetName(initialDelegate)
        self.modes[rulesetName] = self.modes.get(rulesetName2)
        self.language = language2 # 2017/01/31
    else:
        self.language = language # 2017/01/31
    return True
</t>
<t tx="ekr.20031218072017.1147">def flattenOutline(self, fileName):
    '''
    A helper for the flatten-outline command.

    Export the selected outline to an external file.
    The outline is represented in MORE format.
    '''
    c = self.c
    nl = g.u(self.output_newline)
    p = c.p
    if not p:
        return
    self.setEncoding()
    firstLevel = p.level()
    try:
        theFile = open(fileName, 'wb')
            # Fix crasher: open in 'wb' mode.
    except IOError:
        g.warning("can not open", fileName)
        c.testManager.fail()
        return
    for p in p.self_and_subtree(copy=False):
        s = p.moreHead(firstLevel) + nl
        s = g.toEncodedString(s, encoding=self.encoding, reportErrors=True)
        theFile.write(s)
        s = p.moreBody() + nl # Inserts escapes.
        if s.strip():
            s = g.toEncodedString(s, self.encoding, reportErrors=True)
            theFile.write(s)
    theFile.close()
</t>
<t tx="ekr.20031218072017.1148">def outlineToWeb(self, fileName, webType):
    c = self.c; nl = self.output_newline
    current = c.p
    if not current: return
    self.setEncoding()
    self.webType = webType
    try:
        theFile = open(fileName, 'w')
    except IOError:
        g.warning("can not open", fileName)
        c.testManager.fail()
        return
    self.treeType = "@file"
    # Set self.treeType to @root if p or an ancestor is an @root node.
    for p in current.parents():
        flag, junk = g.is_special(p.b, "@root")
        if flag:
            self.treeType = "@root"
            break
    for p in current.self_and_subtree(copy=False):
        s = self.convertVnodeToWeb(p)
        if s:
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s, self.encoding, reportErrors=True)
            theFile.write(s)
            if s[-1] != '\n': theFile.write(nl)
    theFile.close()
</t>
<t tx="ekr.20031218072017.1149"># Remove sentinels command.
try:
    theFile = open(newFileName, 'w')
    if not g.isPython3: # 2010/08/27
        s = g.toEncodedString(s, self.encoding, reportErrors=True)
    theFile.write(s)
    theFile.close()
    if not g.unitTesting:
        g.es("created:", newFileName)
except Exception:
    g.es("exception creating:", newFileName)
    g.es_print_exception()
</t>
<t tx="ekr.20031218072017.1150">try:
    if g.isPython3:
        f = open(filename, 'w', encoding=self.encoding)
    else:
        f = open(filename, 'w')
except Exception:
    g.es("exception opening:", filename)
    g.es_print_exception()
    return
</t>
<t tx="ekr.20031218072017.1386">def getOutputNewline(c=None, name=None):
    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    if name: s = name
    elif c: s = c.config.output_newline
    else: s = app.config.output_newline
    if not s: s = ''
    s = s.lower()
    # pylint: disable=undefined-loop-variable
    # looks like a pylint bug
    if s in ("nl", "lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    if g.isPython3:
        s = str(s)
    return s
</t>
<t tx="ekr.20031218072017.1462">def exportHeadlines(self, fileName):
    c = self.c; p = c.p
    nl = g.u(self.output_newline)
    if not p: return
    self.setEncoding()
    firstLevel = p.level()
    try:
        theFile = open(fileName, 'w')
    except IOError:
        g.warning("can not open", fileName)
        c.testManager.fail()
        return
    for p in p.self_and_subtree(copy=False):
        head = p.moreHead(firstLevel, useVerticalBar=True)
        s = head + nl
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s, encoding=self.encoding, reportErrors=True)
        theFile.write(s)
    theFile.close()
</t>
<t tx="ekr.20031218072017.1464">def weave(self, filename):
    c = self.c; nl = self.output_newline
    p = c.p
    if not p: return
    self.setEncoding()
    &lt;&lt; open filename to f, or return &gt;&gt;
    for p in p.self_and_subtree():
        s = p.b
        s2 = s.strip()
        if s2:
            f.write("-" * 60); f.write(nl)
            &lt;&lt; write the context of p to f &gt;&gt;
            f.write("-" * 60); f.write(nl)
            if not g.isPython3:
                s = g.toEncodedString(s, self.encoding, reportErrors=True)
            f.write(s.rstrip() + nl)
    f.flush()
    f.close()
</t>
<t tx="ekr.20031218072017.1465"># write the headlines of p, p's parent and p's grandparent.
context = []; p2 = p.copy(); i = 0
while i &lt; 3:
    i += 1
    if not p2: break
    context.append(p2.h)
    p2.moveToParent()
context.reverse()
indent = ""
for line in context:
    f.write(indent)
    indent += '\t'
    if not g.isPython3: # 2010/08/27.
        line = g.toEncodedString(line, self.encoding, reportErrors=True)
    f.write(line)
    f.write(nl)
</t>
<t tx="ekr.20031218072017.1470">def put(self, s):
    '''Put string s to self.outputFile. All output eventually comes here.'''
    # Improved code: self.outputFile (a cStringIO object) always exists.
    if s:
        self.putCount += 1
        if not g.isPython3:
            s = g.toEncodedString(s, self.leo_file_encoding, reportErrors=True)
        self.outputFile.write(s)
</t>
<t tx="ekr.20031218072017.1581">head_unicode_warning = False

def headString(self):
    """Return the headline string."""
    # This message should never be printed and we want to avoid crashing here!
    if not g.isString(self._headString):
        if not self.head_unicode_warning:
            self.head_unicode_warning = True
            g.internalError('not a string', repr(self._headString))
    # Make _sure_ we return a unicode string.
    return g.toUnicode(self._headString)

def cleanHeadString(self):
    s = self._headString
    if g.isPython3:
        return s
    else:
        return g.toEncodedString(s, "ascii") # Replaces non-ascii characters by '?'
</t>
<t tx="ekr.20031218072017.1981">def setIdFromDialog(self):
    '''Get leoID from a dialog.'''
    # Don't put up a splash screen.
    # It would obscure the coming dialog.
    self.use_splash_screen = False
    # New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.
    if self.gui is None:
        # Create the Qt gui if it exists.
        self.createDefaultGui(fileName='g.app.setLeoId', verbose=False)
    if self.gui is None: # Neither gui could be created: this should never happen.
        g.es_debug("Please enter LeoID (e.g. your username, 'johndoe'...)")
        # pylint: disable=no-member
        f = builtins.input if g.isPython3 else builtins.raw_input
            # Suppress pyflakes complaint.
        leoid = f('LeoID: ')
    else:
        leoid = self.gui.runAskLeoIDDialog()
    # Bug fix: 2/6/05: put result in g.app.leoID.
    # Careful: periods in the id field of a gnx will corrupt the .leo file!
    self.leoID = leoid.replace('.', '-')
    g.blue('leoID=', repr(self.leoID), spaces=False)
</t>
<t tx="ekr.20031218072017.1982">def setIDFile(self):
    '''Create leoID.txt.'''
    tag = ".leoID.txt"
    for theDir in (self.homeLeoDir, self.globalConfigDir, self.loadDir):
        if theDir:
            try:
                fn = g.os_path_join(theDir, tag)
                f = open(fn, 'w')
                s = self.leoID
                if not g.isPython3:
                    s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
                f.write(s)
                f.close()
                if g.os_path_exists(fn):
                    g.error('', tag, 'created in', theDir)
                    return
            except IOError:
                pass
            g.error('can not create', tag, 'in', theDir)
</t>
<t tx="ekr.20031218072017.1997">def scanGnx(self, s, i=0):
    """Create a gnx from its string representation."""
    if not g.isString(s):
        g.error("scanGnx: unexpected index type:", type(s), '', s)
        return None, None, None
    s = s.strip()
    theId, t, n = None, None, None
    i, theId = g.skip_to_char(s, i, '.')
    if g.match(s, i, '.'):
        i, t = g.skip_to_char(s, i + 1, '.')
        if g.match(s, i, '.'):
            i, n = g.skip_to_char(s, i + 1, '.')
    # Use self.defaultId for missing id entries.
    if not theId:
        theId = self.defaultId
    return theId, t, n
</t>
<t tx="ekr.20031218072017.2160">def toUnicodeFileEncoding(path):
    # Fix bug 735938: file association crash
    if path and g.isString(path):
        path = path.replace('\\', os.sep)
        # Yes, this is correct.  All os_path_x functions return Unicode strings.
        return g.toUnicode(path)
    else:
        return g.u('')
</t>
<t tx="ekr.20031218072017.2278">def importFromPath(moduleName, path, verbose=False):
    '''
    Import a module whose name is given from the directory given by path.

    **Warning**: This is a thin wrapper for imp.load_module, which is
    equivalent to reload! Reloading Leo files while running will crash Leo.
    '''
    trace = 'plugins' in g.app.debug
    path = g.os_path_normpath(path)
    if g.isPython3:
        assert g.isString(path)
    else:
        path = g.toEncodedString(path)
    # Bug fix 2011/10/28: Always import the path from the specified path!
    try:
        module, theFile = None, None
        try:
            data = imp.find_module(moduleName, [path]) # This can open the file.
            theFile, pathname, description = data
            module = imp.load_module(moduleName, theFile, pathname, description)
            if trace: g.trace('loaded', moduleName, 'from', path)
        except ImportError:
            if trace or verbose:
                g.error('no module %s in path %s' % (moduleName, path))
        except UiTypeException:
            if not g.unitTesting and not g.app.batchMode:
                g.es_print('Plugin %s does not support %s gui' % (
                    moduleName, g.app.gui.guiName()))
        except Exception:
            g.error("unexpected exception in g.importFromPath(%s)" %
                (moduleName))
            g.es_exception()
    # Put no return statements before here!
    finally:
        if theFile: theFile.close()
    return module
</t>
<t tx="ekr.20031218072017.2317">def trace(*args, **keys):
    '''Print a tracing message.'''
    # Don't use g here: in standalone mode g is a NullObject!
    # Compute the effective args.
    d = {'align': 0, 'before': '', 'newline': True, 'caller_level': 1, 'noname': False}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    align = d.get('align', 0)
    caller_level = d.get('caller_level', 1)
    noname = d.get('noname')
    # Compute the caller name.
    if noname:
        name = ''
    else:
        try: # get the function name from the call stack.
            f1 = sys._getframe(caller_level) # The stack frame, one level up.
            code1 = f1.f_code # The code object
            name = code1.co_name # The code name
        except Exception:
            name = g.shortFileName(__file__)
        if name == '&lt;module&gt;':
            name = g.shortFileName(__file__)
        if name.endswith('.pyc'):
            name = name[: -1]
    # Pad the caller name.
    if align != 0 and len(name) &lt; abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align &gt; 0: name = name + pad
        else: name = pad + name
    # Munge *args into s.
    result = [name] if name else []
    for arg in args:
        if isString(arg):
            pass
        elif isBytes(arg):
            arg = toUnicode(arg)
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = d.get('before') + ''.join(result)
    pr(s, newline=newline)
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e"># This file contains almost all of Leo's sources.
# See the "About this file" node for important notes.
@language python
</t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2619">def writeWaitingLog(self, c):
    '''Write all waiting lines to the log.'''
    #
    # Do not call g.es, g.es_print, g.pr or g.trace here!
    app = self
    if not c or not c.exists:
        return
    if g.unitTesting:
        app.logWaiting = []
        g.app.setLog(None) # Prepare to requeue for other commanders.
        return
    # Write the signon to the log: similar to self.computeSignon().
    p3 = 'isPython3: %s' % g.isPython3
    table = [
        ('Leo Log Window', 'red'),
        (app.signon, None),
        (app.signon1, None),
        (app.signon2, None),
        (p3, None),
    ]
    table.reverse()
    c.setLog()
    app.logInited = True # Prevent recursive call.
    if not app.silentMode:
        # Write the signon.
        for s, color in table:
            if s:
                app.logWaiting.insert(0, (s, color, True),)
        # Write all the queued log entries.
        for msg in app.logWaiting:
            s, color, newline = msg[:3]
            kwargs = {} if len(msg) &lt; 4 else msg[3]
            kwargs = {k:v for k,v in kwargs.items() if k not in ('color', 'newline')}
            g.es('', s, color=color, newline=newline, **kwargs)
        if hasattr(c.frame.log, 'scrollToEnd'):
            g.app.gui.runAtIdle(c.frame.log.scrollToEnd)
    app.logWaiting = []
    # Essential when opening multiple files...
    g.app.setLog(None)
</t>
<t tx="ekr.20031218072017.2829">def open_file_in_external_editor(self, c, d, fn, testing=False):
    '''
    Open a file fn in an external editor.

    This will be an entire external file, or a temp file for a single node.

    d is a dictionary created from an @openwith settings node.

        'args':     the command-line arguments to be used to open the file.
        'ext':      the file extension.
        'kind':     the method used to open the file, such as subprocess.Popen.
        'name':     menu label (used only by the menu code).
        'p':        the nearest @&lt;file&gt; node, or None.
        'shortcut': menu shortcut (used only by the menu code).
    '''
    testing = testing or g.unitTesting
    arg_tuple = d.get('args', [])
    arg = ' '.join(arg_tuple)
    kind = d.get('kind')
    try:
        # All of these must be supported because they
        # could exist in @open-with nodes.
        command = '&lt;no command&gt;'
        if kind in ('os.system', 'os.startfile'):
            # New in Leo 5.7: 
            # Use subProcess.Popen(..., shell=True)
            c_arg = self.join(arg, fn)
            if not testing:
                try:
                    subprocess.Popen(c_arg, shell=True)
                except OSError:
                    g.es_print('c_arg', repr(c_arg))
                    g.es_exception()
        elif kind == 'exec':
            g.es_print('open-with exec no longer valid.')
        elif kind == 'os.spawnl':
            filename = g.os_path_basename(arg)
            command = 'os.spawnl(%s,%s,%s)' % (arg, filename, fn)
            if not testing: os.spawnl(os.P_NOWAIT, arg, filename, fn)
        elif kind == 'os.spawnv':
            filename = os.path.basename(arg_tuple[0])
            vtuple = arg_tuple[1:]
            vtuple.insert(0, filename)
                # add the name of the program as the first argument.
                # Change suggested by Jim Sizelove.
            vtuple.append(fn)
            command = 'os.spawnv(%s)' % (vtuple)
            if not testing:
                os.spawnv(os.P_NOWAIT, arg[0], vtuple) #???
        elif kind == 'subprocess.Popen':
            c_arg = self.join(arg, fn)
            command = 'subprocess.Popen(%s)' % c_arg
            if not testing:
                try:
                    subprocess.Popen(c_arg, shell=True)
                except OSError:
                    g.es_print('c_arg', repr(c_arg))
                    g.es_exception()
        elif g.isCallable(kind):
            # Invoke openWith like this:
            # c.openWith(data=[func,None,None])
            # func will be called with one arg, the filename
            command = '%s(%s)' % (kind, fn)
            if not testing: kind(fn)
        else:
            command = 'bad command:' + str(kind)
            if not testing: g.trace(command)
        return command # for unit testing.
    except Exception:
        g.es('exception executing open-with command:', command)
        g.es_exception()
        return 'oops: %s' % command
</t>
<t tx="ekr.20031218072017.3047">def createBackupFile(self, fileName):
    '''
        Create a closed backup file and copy the file to it,
        but only if the original file exists.
    '''
    if g.os_path_exists(fileName):
        fd, backupName = tempfile.mkstemp(text=False)
        f = open(fileName, 'rb') # rb is essential.
        s = f.read()
        f.close()
        try:
            try:
                os.write(fd, s)
            finally:
                os.close(fd)
            ok = True
        except Exception:
            g.error('exception creating backup file')
            g.es_exception()
            ok, backupName = False, None
        if not ok and self.read_only:
            g.error("read only")
    else:
        ok, backupName = True, None
    return ok, backupName
</t>
<t tx="ekr.20031218072017.3120">@ Stephen P. Schaefer 9/7/2002

The Unix readline() routine delivers "\r\n" line end strings verbatim,
while the windows versions force the string to use the Unix convention
of using only "\n". This routine causes the Unix readline to do the
same.
@c

def readlineForceUnixNewline(f, fileName=None):
    try:
        s = f.readline()
    except UnicodeDecodeError:
        g.trace('UnicodeDecodeError: %s' % (fileName), f, g.callers())
        s = g.u('')
    if len(s) &gt;= 2 and s[-2] == "\r" and s[-1] == "\n":
        s = s[0: -2] + "\n"
    return s
</t>
<t tx="ekr.20031218072017.3128">def pause(s):
    g.pr(s)
    i = 0
    # Use builtins to suppress pyflakes complaint.
    # pylint: disable=no-member, undefined-variable
    n = 1000 * 1000 if g.isPython3 else builtins.long(1000) * builtins.long(1000)
    while i &lt; n:
        i += 1
</t>
<t tx="ekr.20031218072017.3135">@command('show-stats')
def printStats(event=None, name=None):
    '''
    Print all gathered statistics.
    
    Here is the recommended code to gather stats for one method/function:
        
        if not g.app.statsLockout:
            g.app.statsLockout = True
            try:
                d = g.app.statsDict
                key = 'g.isUnicode:' + g.callers()
                d [key] = d.get(key, 0) + 1
            finally:
                g.app.statsLockout = False
    '''
    if name:
        if not isString(name):
            name = repr(name)
    else:
        name = g._callerName(n=2) # Get caller name 2 levels back.
    #
    # Print the stats, organized by number of calls.
    d = g.app.statsDict
    if g.isPython3:
        d2 = {val: key for key, val in d.items()}
    else:
        d2 = {val: key for key, val in d.iteritems()}
    for key in reversed(sorted(d2.keys())):
        print('%7s %s' % (key, d2.get(key)))
</t>
<t tx="ekr.20031218072017.3136">def stat(name=None):
    """Increments the statistic for name in g.app.statsDict
    The caller's name is used by default.
    """
    d = g.app.statsDict
    if name:
        if not isString(name):
            name = repr(name)
    else:
        name = g._callerName(n=2) # Get caller name 2 levels back.
    d[name] = 1 + d.get(name, 0)
</t>
<t tx="ekr.20031218072017.3306">def createHeadline(self, parent, body, headline):
    '''Create a new VNode as the last child of parent position.'''
    p = parent.insertAsLastChild()
    body = g.u(body)
    headline = g.u(headline)
    p.initHeadString(headline)
    if body:
        self.setBodyString(p, body)
    return p
</t>
<t tx="ekr.20031218072017.3344">def __init__(self, context, gnx=None):
    '''
    Ctor for the VNode class.
    To support ZODB, the code must set v._p_changed = 1 whenever
    v.unknownAttributes or any mutable VNode object changes.
    '''
    # The primary data: headline and body text.
    self._headString = g.u('newHeadline')
    self._bodyString = g.u('')
    # Structure data...
    self.children = []
        # Ordered list of all children of this node.
    self.parents = []
        # Unordered list of all parents of this node.
    # Other essential data...
    self.fileIndex = None
        # The immutable fileIndex (gnx) for this node. Set below.
    self.iconVal = 0
        # The present value of the node's icon.
    self.statusBits = 0
        # status bits
    # Information that is never written to any file...
    self.context = context # The context containing context.hiddenRootNode.
        # Required so we can compute top-level siblings.
        # It is named .context rather than .c to emphasize its limited usage.
    self.expandedPositions = []
        # Positions that should be expanded.
    self.insertSpot = None
        # Location of previous insert point.
    self.scrollBarSpot = None
        # Previous value of scrollbar position.
    self.selectionLength = 0
        # The length of the selected body text.
    self.selectionStart = 0
        # The start of the selected body text.
    # To make VNode's independent of Leo's core,
    # wrap all calls to the VNode ctor::
    #
    #   def allocate_vnode(c,gnx):
    #       v = VNode(c)
    #       g.app.nodeIndices.new_vnode_helper(c,gnx,v)
    g.app.nodeIndices.new_vnode_helper(context, gnx, self)
    assert self.fileIndex, g.callers()
</t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree(self):
    for p in self.self_and_subtree(copy=False):
        p.v.clearVisited()
        p.v.clearWriteBit()
</t>
<t tx="ekr.20031218072017.3614"># These routines update both the ivar and the menu label.

def setRedoType(self, theType):

    u = self; frame = u.c.frame
    if not g.isString(theType):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.redoMenuName(theType)
    if name != u.redoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline = -1 if g.match(name, 0, "Can't") else 0
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;", "")
        frame.menu.setMenuLabel(menu, u.realRedoMenuLabel, realLabel, underline=underline)
        u.redoMenuLabel = name
        u.realRedoMenuLabel = realLabel
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20031219074948.1">@nobeautify

class NullObject(object):
    """
    An object that does nothing, and does it very well.
    From the Python cookbook, recipe 5.23
    """
    def __init__(self, *args, **keys): pass
    def __call__(self, *args, **keys): return self
    # def __len__    (self): return 0 # Debatable.
    def __repr__(self): return "NullObject"
    def __str__(self): return "NullObject"
    if isPython3:
        def __bool__(self): return False
    else:
        def __nonzero__(self): return 0
    def __delattr__(self, attr): return self
    def __getattr__(self, attr): return self
    def __setattr__(self, attr, val): return self

nullObject = NullObject
    # For compatibility
</t>
<t tx="ekr.20040117173448">@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test
whether a position p is valid. In particular, tests like 'if p is
None' or 'if p is not None' will not work properly.
@c
if g.isPython3:

    def __bool__(self):
        """Return True if a position is valid."""
        # Tracing this appears to cause unbounded prints.
        # print("__bool__",self.v and self.v.cleanHeadString())
        return self.v is not None

else:

    def __nonzero__(self):
        """Return True if a position is valid."""
        return self.v is not None
</t>
<t tx="ekr.20040723094220.5">def checkPythonNode(self, p, unittest=False, suppressErrors=False):
    c = self; h = p.h
    # Call getScript to ignore directives and section references.
    body = g.getScript(c, p.copy())
    if not body: return
    try:
        fn = '&lt;node: %s&gt;' % p.h
        if not g.isPython3:
            body = g.toEncodedString(body)
        compile(body + '\n', fn, 'exec')
        c.tabNannyNode(p, h, body, unittest, suppressErrors)
    except SyntaxError:
        if not suppressErrors:
            g.warning("Syntax error in: %s" % h)
            g.es_exception(full=False, color="black")
        if unittest: raise
    except Exception:
        g.es_print('unexpected exception')
        g.es_exception()
        if unittest: raise
</t>
<t tx="ekr.20041005105605.10">def initCommonIvars(self):
    """
    Init ivars common to both reading and writing.

    The defaults set here may be changed later.
    """
    at = self
    c = at.c
    at.at_auto_encoding = c.config.default_at_auto_file_encoding
    at.default_directory = None
    at.encoding = c.config.default_derived_file_encoding
    at.endSentinelComment = ""
    at.errors = 0
    at.inCode = True
    at.indent = 0 # The unit of indentation is spaces, not tabs.
    at.language = None
    at.output_newline = g.getOutputNewline(c=c)
    at.page_width = None
    at.raw = False # True: in @raw mode
    at.root = None # The root (a position) of tree being read or written.
    at.startSentinelComment = ""
    at.startSentinelComment = ""
    at.tab_width = c.tab_width or -4
    at.writing_to_shadow_directory = False
</t>
<t tx="ekr.20041005105605.116"></t>
<t tx="ekr.20041005105605.119">def createImportedNode(self, root, headline):
    at = self
    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True
    p.v.setVisited() # Suppress warning about unvisited node.
    return p
</t>
<t tx="ekr.20041005105605.120">def parseLeoSentinel(self, s):
    '''
    Parse the sentinel line s.
    If the sentinel is valid, set at.encoding, at.readVersion, at.readVersion5.
    '''
    at, c = self, self.c
    # Set defaults.
    encoding = c.config.default_derived_file_encoding
    readVersion, readVersion5 = None, None
    new_df, start, end, isThin = False, '', '', False
    # Example: \*@+leo-ver=5-thin-encoding=utf-8,.*/
    pattern = re.compile(r'(.+)@\+leo(-ver=([0123456789]+))?(-thin)?(-encoding=(.*)(\.))?(.*)')
        # The old code weirdly allowed '.' in version numbers.
        # group 1: opening delim
        # group 2: -ver=
        # group 3: version number
        # group(4): -thin
        # group(5): -encoding=utf-8,.
        # group(6): utf-8,
        # group(7): .
        # group(8): closing delim.
    m = pattern.match(s)
    valid = bool(m)
    if valid:
        start = m.group(1) # start delim
        valid = bool(start)
    if valid:
        new_df = bool(m.group(2)) # -ver=
        if new_df:
            # Set the version number.
            if m.group(3):
                readVersion = m.group(3)
                readVersion5 = readVersion &gt;= '5'
            else:
                valid = False
    if valid:
        # set isThin
        isThin = bool(m.group(4))
    if valid and m.group(5):
        # set encoding.
        encoding = m.group(6)
        if encoding and encoding.endswith(','):
            # Leo 4.2 or after.
            encoding = encoding[:-1]
        if not g.isValidEncoding(encoding):
            g.es_print("bad encoding in derived file:", encoding)
            valid = False
    if valid:
        end = m.group(8) # closing delim
    if valid:
        at.encoding = encoding
        at.readVersion = readVersion
        at.readVersion5 = readVersion5
    return valid, new_df, start, end, isThin
</t>
<t tx="ekr.20041005105605.128">def readLine(self):
    """
    Read one line from file using the present encoding.
    Returns at.read_lines[at.read_i++]
    """
    # This is an old interface, now used only by at.scanHeader.
    # For now, it's not worth replacing.
    at = self
    if at.read_i &lt; len(at.read_lines):
        s = at.read_lines[at.read_i]
        at.read_i += 1
        return s
    else:
        return '' # Not an error.
</t>
<t tx="ekr.20041005105605.129">def scanHeader(self, fileName, giveErrors=True):
    """
    Scan the @+leo sentinel, using the old readLine interface.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df,isThinDerivedFile) where:
    firstLines        contains all @first lines,
    new_df            is True if we are reading a new-format derived file.
    isThinDerivedFile is True if the file is an @thin file.
    """
    at = self
    new_df, isThinDerivedFile = False, False
    firstLines = [] # The lines before @+leo.
    s = self.scanFirstLines(firstLines)
    valid = len(s) &gt; 0
    if valid:
        valid, new_df, start, end, isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    elif giveErrors:
        at.error("No @+leo sentinel in: %s" % fileName)
        g.trace(g.callers())
    return firstLines, new_df, isThinDerivedFile
</t>
<t tx="ekr.20041005105605.13">def initReadIvars(self, root, fileName,
    importFileName=None,
    perfectImportRoot=None,
    atShadow=False,
):
    at = self
    at.initCommonIvars()
    at.bom_encoding = None
        # The encoding implied by any BOM (set by g.stripBOM)
    at.cloneSibCount = 0
        # n &gt; 1: Make sure n cloned sibs exists at next @+node sentinel
    at.correctedLines = 0
        # For perfect import.
    at.docOut = [] # The doc part being accumulated.
    at.done = False # True when @-leo seen.
    at.endSentinelIndentStack = []
        # Restored indentation for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelStack = []
        # Contains entries for +node sentinels only when not readVersion5
    at.endSentinelLevelStack = []
        # The saved level, len(at.thinNodeStack), for @-others and @-&lt;&lt; sentinels.
        # Used only when readVersion5.
    at.endSentinelNodeStack = []
        # Used only when readVersion5.
    at.fromString = False
    at.importing = bool(importFileName)
    at.importRootSeen = False
    at.indentStack = []
    at.inputFile = None
    at.lastLines = [] # The lines after @-leo
    at.lastRefNode = None
        # The previous reference node, for at.readAfterRef.
        # No stack is needed because -&lt;&lt; sentinels restore at.v
        # to the node needed by at.readAfterRef.
    at.lastThinNode = None
        # The last thin node at this level.
        # Used by createThinChild4.
    at.leadingWs = ""
    at.lineNumber = 0 # New in Leo 4.4.8.
    at.out = None
    at.outStack = []
    at.perfectImportRoot = perfectImportRoot
    at.read_i = 0
    at.read_lines = []
    at.readVersion = ''
        # New in Leo 4.8: "4" or "5" for new-style thin files.
    at.readVersion5 = False
        # synonym for at.readVersion &gt;= '5' and not atShadow.
    at.root = root
    at.rootSeen = False
    at.atShadow = atShadow
    at.targetFileName = fileName
        # For at.writeError only.
    at.tnodeList = []
        # Needed until old-style @file nodes are no longer supported.
    at.tnodeListIndex = 0
    at.v = None
    at.vStack = [] # Stack of at.v values.
    at.thinChildIndexStack = [] # number of siblings at this level.
    at.thinNodeStack = [] # Entries are vnodes.
    at.updateWarningGiven = False
</t>
<t tx="ekr.20041005105605.130">def scanFirstLines(self, firstLines):
    '''
    Append all lines before the @+leo line to firstLines.

    Empty lines are ignored because empty @first directives are
    ignored.

    We can not call sentinelKind here because that depends on the comment
    delimiters we set here.
    '''
    at = self
    s = at.readLine()
    while s and s.find("@+leo") == -1:
        firstLines.append(s)
        s = at.readLine()
    return s
</t>
<t tx="ekr.20041005105605.132"></t>
<t tx="ekr.20041005105605.133"></t>
<t tx="ekr.20041005105605.144">def write(self, root, sentinels=True):
    """Write a 4.x derived file.
    root is the position of an @&lt;file&gt; node.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.anyAtFileNodeName(), sentinels=sentinels)
        if not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        at.warnAboutOrphandAndIgnoredNodes()
        contents = at.closeOutputStream()
        if at.errors:
            g.es("not written:", g.shortFileName(fileName))
            at.addToOrphanList(root)
        else:
            at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.writeException(fileName, root)
</t>
<t tx="ekr.20041005105605.147">def writeAll(self, all=False, dirty=False):
    """Write @file nodes in all or part of the outline"""
    at, c = self, self.c
    at.sameFiles = 0
    # This is the *only* place where these are set.
    # promptForDangerousWrite sets cancelFlag only if canCancelFlag is True.
    at.canCancelFlag = True
    at.cancelFlag = False
    at.yesToAll = False
    files, root = at.findFilesToWrite(all)
    for p in files:
        try:
            at.writeAllHelper(p, root)
        except Exception:
            at.internalWriteError(p)
    # Make *sure* these flags are cleared for other commands.
    at.canCancelFlag = False
    at.cancelFlag = False
    at.yesToAll = False
    # Say the command is finished.
    at.reportEndOfWrite(files, all, dirty)
    if c.isChanged():
        # Save the outline if only persistence data nodes are dirty.
        at.saveOutlineIfPossible()
</t>
<t tx="ekr.20041005105605.149">def writeAllHelper(self, p, root):
    '''
    Write one file for the at.writeAll.
    Do *not* write @auto files unless p == root.
    This prevents the write-all command from needlessly updating
    the @persistence data, thereby annoyingly changing the .leo file.
    '''
    at = self
    at.root = root
    try:
        at.writePathChanged(p)
    except IOError:
        return
    if p.isDirty():
        at.autoBeautify(p)
    # Tricky: @ignore not recognised in @asis nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtIgnoreNode():
        return # Handled in caller.
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p)
        # Do *not* clear the dirty bits the entries in @persistence tree here!
    elif p.isAtCleanNode() or p.isAtNoSentFileNode():
        at.write(p, sentinels=False)
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p)
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p)
    elif p.isAtThinFileNode() or p.isAtFileNode():
        at.write(p)
    #
    # Clear the dirty bits in all descendant nodes.
    # The persistence data may still have to be written.
    for p2 in p.self_and_subtree(copy=False):
        p2.v.clearDirty()
</t>
<t tx="ekr.20041005105605.15">def initWriteIvars(self, root, targetFileName,
    atEdit=False,
    atShadow=False,
    defaultDirectory = None,
    forcePythonSentinels=False,
    sentinels=True,
):
    '''
    Compute default values of all write-related ivars.
    Return the finalized name of the output file.
    '''
    at, c = self, self.c
    assert root
    self.initCommonIvars()
    assert at.checkPythonCodeOnWrite is not None
    assert at.underindentEscapeString is not None
    #
    # Copy args
    at.atEdit = atEdit
        # Used only by putBody.
    at.atShadow = atShadow
    at.root = root
    at.sentinels = sentinels
    #
    # Override initCommonIvars.
    if forcePythonSentinels:
        at.endSentinelComment = None
        at.startSentinelComment = "#"
    if g.app.unitTesting:
        at.output_newline = '\n'
    #
    # Set other ivars.
    at.force_newlines_in_at_nosent_bodies = \
        c.config.getBool('force-newlines-in-at-nosent-bodies')
        # For at.putBody only.
    at.sameFiles = 0
        # For communication between replaceFile and reportEndOfWrite.
    at.outputList = []
        # For stream output.
    at.targetFileName = targetFileName
        # For at.writeError only.
    at.scanAllDirectives(root, forcePythonSentinels=forcePythonSentinels)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    #
    # Overrides of at.scanAllDirectives...
    if defaultDirectory:
        at.default_directory = defaultDirectory
    if at.language == 'python':
        # Encoding directive overrides everything else.
        encoding = g.getPythonEncodingFromString(root.b)
        if encoding:
            at.encoding = encoding
    #
    # Clean root.v.
    if not at.errors and at.root:
        if hasattr(at.root.v, 'tnodeList'):
            delattr(at.root.v, 'tnodeList')
        at.root.v._p_changed = True
    #
    # Return the finalized file name.
    return g.os_path_realpath(
        c.os_path_finalize_join(at.default_directory, targetFileName))
</t>
<t tx="ekr.20041005105605.151">def writeMissing(self, p):
    at, c = self, self.c
    writtenFiles = False
    c.init_error_dialogs()
    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            fileName = p.anyAtFileNodeName()
            if fileName:
                fileName = c.os_path_finalize_join(at.default_directory, fileName)
                if at.precheck(fileName, p):
                    at.writeMissingNode(p)
                    writtenFiles = True
                else:
                    at.addToOrphanList(p)
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if writtenFiles &gt; 0:
            g.es("finished")
        else:
            g.es("no @file node in the selected tree")
    c.raise_error_dialogs(kind='write')
</t>
<t tx="ekr.20041005105605.152">def writeMissingNode(self, p):

    at = self
    if p.isAtAsisFileNode():
        at.asisWrite(p)
    elif p.isAtNoSentFileNode():
        at.write(p, sentinels=False)
    elif p.isAtFileNode():
        at.write(p)
    elif p.isAtAutoNode() or p.isAtAutoRstNode():
        g.es('Can not write missing @auto node', p.h, color='red')
    else:
        g.trace('can not happen: unknown @file node')
</t>
<t tx="ekr.20041005105605.154">def asisWrite(self, root):
    at, c = self, self.c
    try:
        c.endEditing()
        c.init_error_dialogs()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        if not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return
        at.openOutputStream()
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        contents = at.closeOutputStream()
        at.replaceFile(contents, at.encoding, fileName, root)
    except Exception:
        at.writeException(fileName, root)

silentWrite = asisWrite # Compatibility with old scripts.
</t>
<t tx="ekr.20041005105605.157">def putFile(self, root, fromString='', sentinels=True):
    '''Write the contents of the file to the output stream.'''
    at = self
    s = fromString if fromString else root.v.b
    root.clearAllVisitedInTree()
    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=5")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root, fromString=fromString)
    at.putCloseNodeSentinel(root)
    # The -leo sentinel is required to handle @last.
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)
</t>
<t tx="ekr.20041005105605.160"></t>
<t tx="ekr.20041005105605.161">def putBody(self, p, fromString=''):
    '''
    Generate the body enclosed in sentinel lines.
    Return True if the body contains an @others line.
    '''
    at = self
    #
    # New in 4.3 b2: get s from fromString if possible.
    s = fromString if fromString else p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    #
    # Fix #1048 &amp; #1037: regularize most trailing whitespace.
    if s and (at.sentinels or at.force_newlines_in_at_nosent_bodies):
        if not s.endswith('\n'):
            s = s + '\n'
    at.raw = False # Bug fix.
    i = 0
    status = g.Bunch(
        at_comment_seen = False,
        at_delims_seen = False,
        at_warning_given = False,
        has_at_others = False,
        in_code = True,
    )
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert next_i &gt; i, 'putBody'
        kind = at.directiveKind4(s, i)
        at.putLine(i, kind, p, s, status)
        i = next_i
    # pylint: disable=no-member
        # g.bunch *does* have .in_code and has_at_others members.
    if not status.in_code:
        at.putEndDocLine()
    return status.has_at_others
</t>
<t tx="ekr.20041005105605.163">def putLine(self, i, kind, p, s, status):
    '''Put the line at s[i:] of the given kind, updating the status.'''
    at = self
    if kind == at.noDirective:
        if status.in_code:
            if at.raw:
                at.putCodeLine(s, i)
            else:
                name, n1, n2 = at.findSectionName(s, i)
                if name:
                    at.putRefLine(s, i, n1, n2, name, p)
                else:
                    at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
    elif at.raw:
        if kind == at.endRawDirective:
            at.raw = False
            at.putSentinel("@@end_raw")
        else:
            # Fix bug 784920: @raw mode does not ignore directives
            at.putCodeLine(s, i)
    elif kind in (at.docDirective, at.atDirective):
        if not status.in_code:
            # Bug fix 12/31/04: handle adjacent doc parts.
            at.putEndDocLine()
        at.putStartDocLine(s, i, kind)
        status.in_code = False
    elif kind in (at.cDirective, at.codeDirective):
        # Only @c and @code end a doc part.
        if not status.in_code:
            at.putEndDocLine()
        at.putDirective(s, i)
        status.in_code = True
    elif kind == at.allDirective:
        if status.in_code:
            if p == self.root:
                at.putAtAllLine(s, i, p)
            else:
                at.error('@all not valid in: %s' % (p.h))
        else: at.putDocLine(s, i)
    elif kind == at.othersDirective:
        if status.in_code:
            if status.has_at_others:
                at.error('multiple @others in: %s' % (p.h))
            else:
                at.putAtOthersLine(s, i, p)
                status.has_at_others = True
        else:
            at.putDocLine(s, i)
    elif kind == at.rawDirective:
        at.raw = True
        at.putSentinel("@@raw")
    elif kind == at.endRawDirective:
        # Fix bug 784920: @raw mode does not ignore directives
        at.error('unmatched @end_raw directive: %s' % p.h)
    elif kind == at.startVerbatim:
        # Fix bug 778204: @verbatim not a valid Leo directive.
        if g.unitTesting:
            # A hack: unit tests for @shadow use @verbatim as a kind of directive.
            pass
        else:
            at.error('@verbatim is not a Leo directive: %s' % p.h)
    elif kind == at.miscDirective:
        # Fix bug 583878: Leo should warn about @comment/@delims clashes.
        if g.match_word(s, i, '@comment'):
            status.at_comment_seen = True
        elif g.match_word(s, i, '@delims'):
            status.at_delims_seen = True
        if (
            status.at_comment_seen and
            status.at_delims_seen and not
            status.at_warning_given
        ):
            status.at_warning_given = True
            at.error('@comment and @delims in node %s' % p.h)
        at.putDirective(s, i)
    else:
        at.error('putBody: can not happen: unknown directive kind: %s' % kind)
</t>
<t tx="ekr.20041005105605.164"></t>
<t tx="ekr.20041005105605.165"></t>
<t tx="ekr.20041005105605.166">def putAtAllLine(self, s, i, p):
    """Put the expansion of @all."""
    at = self
    j, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    k = g.skip_to_end_of_line(s,i)
    at.putLeadInSentinel(s, i, j, delta)
    at.indent += delta
    at.putSentinel("@+" + s[j+1:k].strip())
        # s[j:k] starts with '@all'
    for child in p.children():
        at.putAtAllChild(child)
    at.putSentinel("@-all")
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.167">def putAtAllBody(self, p):
    """ Generate the body enclosed in sentinel lines."""
    at = self
    s = p.b
    p.v.setVisited()
        # Make sure v is never expanded again.
        # Suppress orphans check.
    if at.sentinels and s and s[-1] != '\n':
        s = s + '\n'
    i, inCode = 0, True
    while i &lt; len(s):
        next_i = g.skip_line(s, i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s, i)
        else:
            at.putDocLine(s, i)
        i = next_i
    if not inCode:
        at.putEndDocLine()
</t>
<t tx="ekr.20041005105605.169">def putAtAllChild(self, p):
    '''
    This code puts only the first of two or more cloned siblings, preceding
    the clone with an @clone n sentinel.
    
    This is a debatable choice: the cloned tree appears only once in the
    external file. This should be benign; the text created by @all is
    likely to be used only for recreating the outline in Leo. The
    representation in the derived file doesn't matter much.
    '''
    at = self
    at.putOpenNodeSentinel(p, inAtAll=True)
        # Suppress warnings about @file nodes.
    at.putAtAllBody(p)
    for child in p.children():
        at.putAtAllChild(child)
    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20041005105605.17"></t>
<t tx="ekr.20041005105605.170"></t>
<t tx="ekr.20041005105605.171">def validInAtOthers(self, p):
    """
    Return True if p should be included in the expansion of the @others
    directive in the body text of p's parent.
    """
    at = self
    i = g.skip_ws(p.h, 0)
    isSection, junk = at.isSectionName(p.h, i)
    if isSection:
        return False # A section definition node.
    elif at.sentinels:
        # @ignore must not stop expansion here!
        return True
    elif p.isAtIgnoreNode():
        g.error('did not write @ignore node', p.v.h)
        return False
    elif p.isAtCleanNode():
        p.v.setVisited()
            # # 525: Nested @clean.
            # Suppress a future error. Requires other changes.
        return False
    else:
        return True
</t>
<t tx="ekr.20041005105605.172">def putAtOthersChild(self, p):
    at = self
    at.putOpenNodeSentinel(p)
    at.putBody(p)
    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20041005105605.173">def putAtOthersLine(self, s, i, p):
    """Put the expansion of @others."""
    at = self
    j, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    k = g.skip_to_end_of_line(s,i)
    at.putLeadInSentinel(s, i, j, delta)
    at.indent += delta
    at.putSentinel("@+" + s[j+1:k].strip())
        # s[j:k] starts with '@others'
        # Never write lws in new sentinels.
    for child in p.children():
        p = child.copy()
        after = p.nodeAfterTree()
        while p and p != after:
            if at.validInAtOthers(p):
                at.putOpenNodeSentinel(p)
                at_others_flag = at.putBody(p)
                at.putCloseNodeSentinel(p)
                if at_others_flag:
                    p.moveToNodeAfterTree()
                else:
                    p.moveToThreadNext()
            else:
                p.moveToNodeAfterTree()
    # This is the same in both old and new sentinels.
    at.putSentinel("@-others")
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.174">def putCodeLine(self, s, i):
    '''Put a normal code line.'''
    at = self
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s, i)
    if g.match(s, k, self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')
    j = g.skip_line(s, i)
    line = s[i: j]
    # Don't put any whitespace in otherwise blank lines.
    if len(line) &gt; 1: # Preserve *anything* the user puts on the line!!!
        if not at.raw:
            at.putIndent(at.indent, line)
        if line[-1:] == '\n':
            at.os(line[: -1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    elif line:
        at.os(line) # Bug fix: 2013/09/16
    else:
        g.trace('Can not happen: completely empty line')
</t>
<t tx="ekr.20041005105605.176">def putRefLine(self, s, i, n1, n2, name, p):
    """Put a line containing one or more references."""
    at = self
    ref = at.findReference(name, p)
    if not ref:
        if hasattr(at, 'allow_undefined_refs'):
            # Allow apparent section reference: just write the line.
            at.putCodeLine(s, i)
        return
    # Compute delta only once.
    junk, delta = g.skip_leading_ws_with_indent(s, i, at.tab_width)
    # Write the lead-in sentinel only once.
    at.putLeadInSentinel(s, i, n1, delta)
    self.putRefAt(name, ref, delta)
    while 1:
        progress = i
        i = n2
        name, n1, n2 = at.findSectionName(s, i)
        if name:
            ref = at.findReference(name, p)
                # Issues error if not found.
            if ref:
                middle_s = s[i:n1]
                self.putAfterMiddleRef(middle_s, delta)
                self.putRefAt(name, ref, delta)
        else: break
        assert progress &lt; i
    self.putAfterLastRef(s, i, delta)
</t>
<t tx="ekr.20041005105605.177">def putRefAt(self, name, ref, delta):
    at = self
    # Fix #132: Section Reference causes clone...
    # https://github.com/leo-editor/leo-editor/issues/132
    # Never put any @+middle or @-middle sentinels.
    at.indent += delta
    at.putSentinel("@+" + name)
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    at.putSentinel("@-" + name)
    at.indent -= delta
</t>
<t tx="ekr.20041005105605.178">def putAfterLastRef(self, s, start, delta):
    """Handle whatever follows the last ref of a line."""
    at = self
    j = g.skip_ws(s, start)
    if j &lt; len(s) and s[j] != '\n':
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        end = g.skip_line(s, start)
        after = s[start: end]
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.179">def putAfterMiddleRef(self, s, delta):
    """Handle whatever follows a ref that is not the last ref of a line."""
    at = self
    if s:
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(s)
        at.onl_sent() # Not a real newline.
        at.indent -= delta
</t>
<t tx="ekr.20041005105605.18"></t>
<t tx="ekr.20041005105605.180"></t>
<t tx="ekr.20041005105605.181">def putBlankDocLine(self):
    at = self
    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment); at.oblank()
    at.onl()
</t>
<t tx="ekr.20041005105605.182">def putStartDocLine(self, s, i, kind):
    """Write the start of a doc part."""
    at = self
    sentinel = "@+doc" if kind == at.docDirective else "@+at"
    directive = "@doc" if kind == at.docDirective else "@"
    # Put whatever follows the directive in the sentinel.
    # Skip past the directive.
    i += len(directive)
    j = g.skip_to_end_of_line(s, i)
    follow = s[i: j]
    # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
    at.putSentinel(sentinel + follow)
    # Put the opening comment if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment); at.onl()
</t>
<t tx="ekr.20041005105605.183">def putDocLine(self, s, i):
    """
    Handle one line of a doc part.

    Output complete lines and split long lines.
    Precede Inserted newlines by whitespace.
    """
    at = self
    j = g.skip_line(s, i)
    s = s[i: j]
    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        # Write the line as it is.
        at.putIndent(at.indent)
        if not at.endSentinelComment:
            at.os(at.startSentinelComment)
            at.oblank()
        at.os(s)
        if not s.endswith('\n'):
            at.onl()
</t>
<t tx="ekr.20041005105605.185">def putEndDocLine(self):
    """Write the conclusion of a doc part."""
    at = self
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.
</t>
<t tx="ekr.20041005105605.187"></t>
<t tx="ekr.20041005105605.188">def nodeSentinelText(self, p):
    """Return the text of a @+node or @-node sentinel for p."""
    at = self
    h = at.removeCommentDelims(p)
    if getattr(at, 'at_shadow_test_hack', False):
        # A hack for @shadow unit testing.
        # see AtShadowTestCase.makePrivateLines.
        return h
    gnx = p.v.fileIndex
    level = 1 + p.level() - self.root.level()
    if level &gt; 2:
        return "%s: *%s* %s" % (gnx, level, h)
    else:
        return "%s: %s %s" % (gnx, '*' * level, h)
</t>
<t tx="ekr.20041005105605.189">def removeCommentDelims(self, p):
    '''
    If the present @language/@comment settings do not specify a single-line comment
    we remove all block comment delims from h. This prevents headline text from
    interfering with the parsing of node sentinels.
    '''
    at = self
    start = at.startSentinelComment
    end = at.endSentinelComment
    h = p.h
    if end:
        h = h.replace(start, "")
        h = h.replace(end, "")
    return h
</t>
<t tx="ekr.20041005105605.19">def openFileForReading(self, fromString=False):
    '''
    Open the file given by at.root.
    This will be the private file for @shadow nodes.
    '''
    at, c = self, self.c
    if fromString:
        if at.atShadow:
            return at.error(
                'can not call at.read from string for @shadow files')
        at.inputFile = g.FileLikeObject(fromString=fromString)
        at.initReadLine(fromString)
        return None, None
    #
    # Not from a string. Carefully read the file.
    fn = g.fullPath(c, at.root)
        # Returns full path, including file name.
    at.setPathUa(at.root, fn)
        # Remember the full path to this node.
    if at.atShadow:
        fn = at.openAtShadowFileForReading(fn)
        if not fn:
            return None, None
    assert fn
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        at.inputFile = open(fn, 'rb')
        s = at.readFileToUnicode(fn)
            # Sets at.encoding, regularizes whitespace and calls at.initReadLines.
        at.warnOnReadOnlyFile(fn)
    except IOError:
        at.error("can not open: '@file %s'" % (fn))
        at.inputFile = None
        at._file_bytes = g.toEncodedString('')
        fn, s = None, None
    return fn, s
</t>
<t tx="ekr.20041005105605.190">def putLeadInSentinel(self, s, i, j, delta):
    """
    Set at.leadingWs as needed for @+others and @+&lt;&lt; sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet.
    """
    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.
    k = g.skip_ws(s, i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i: j] # Remember the leading whitespace, including its spelling.
    else:
        self.putIndent(at.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i: j])
        at.onl_sent()
</t>
<t tx="ekr.20041005105605.191">def putCloseNodeSentinel(self, p):
    '''End a node.'''
    at = self
    at.raw = False # Bug fix: 2010/07/04
</t>
<t tx="ekr.20041005105605.192">def putOpenLeoSentinel(self, s):
    """Write @+leo sentinel."""
    at = self
    if at.sentinels or hasattr(at, 'force_sentinels'):
        s = s + "-thin"
        encoding = at.encoding.lower()
        if encoding != "utf-8":
            # New in 4.2: encoding fields end in ",."
            s = s + "-encoding=%s,." % (encoding)
        at.putSentinel(s)
</t>
<t tx="ekr.20041005105605.193">def putOpenNodeSentinel(self, p, inAtAll=False):
    """Write @+node sentinel for p."""
    at = self
    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.h)
        return
    s = at.nodeSentinelText(p)
    at.putSentinel("@+node:" + s)
    # Leo 4.7 b2: we never write tnodeLists.
</t>
<t tx="ekr.20041005105605.194">def putSentinel(self, s):
    '''
    Write a sentinel whose text is s, applying the CWEB hack if needed.
    
    This method outputs all sentinels.
    '''
    at = self
    if at.sentinels or hasattr(at, 'force_sentinels'):
        at.putIndent(at.indent)
        at.os(at.startSentinelComment)
        # Apply the cweb hack to s:
        #   If the opening comment delim ends in '@',
        #   double all '@' signs except the first.
        start = at.startSentinelComment
        if start and start[-1] == '@':
            s = s.replace('@', '@@')[1:]
        at.os(s)
        if at.endSentinelComment:
            at.os(at.endSentinelComment)
        at.onl()
</t>
<t tx="ekr.20041005105605.196"></t>
<t tx="ekr.20041005105605.198"># These patterns exclude constructs such as @encoding.setter or @encoding(whatever)
# However, they must allow @language python, @nocolor-node, etc.
at_directive_kind_pattern = re.compile(r'\s*@([\w-]+)\s*')

def directiveKind4(self, s, i):
    """
    Return the kind of at-directive or noDirective.
    
    Potential simplifications:
    - Using strings instead of constants.
    - Using additional regex's to recognize directives.
    """
    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s, i)
        if g.match_word(s, j, "@others"):
            return at.othersDirective
        elif g.match_word(s, j, "@all"):
            return at.allDirective
        else:
            return at.noDirective
    table = (
        ("@all", at.allDirective),
        ("@c", at.cDirective),
        ("@code", at.codeDirective),
        ("@doc", at.docDirective),
        ("@end_raw", at.endRawDirective),
        ("@others", at.othersDirective),
        ("@raw", at.rawDirective),
        ("@verbatim", at.startVerbatim))
    # Rewritten 6/8/2005.
    if i + 1 &gt;= n or s[i + 1] in (' ', '\t', '\n'):
        # Bare '@' not recognized in cweb mode.
        return at.noDirective if at.language == "cweb" else at.atDirective
    if not s[i + 1].isalpha():
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language == "cweb" and g.match_word(s, i, '@c'):
        return at.noDirective
    for name, directive in table:
        if g.match_word(s, i, name):
            return directive
    # Support for add_directives plugin.
    # Use regex to properly distinguish between Leo directives
    # and python decorators.
    s2 = s[i:]
    m = self.at_directive_kind_pattern.match(s2)
    if m:
        word = m.group(1)
        if word not in g.globalDirectiveList:
            return at.noDirective
        s3 = s2[m.end(1):]
        if s3 and s3[0] in ".(":
            return at.noDirective
        else:
            return at.miscDirective
    return at.noDirective
</t>
<t tx="ekr.20041005105605.199">def findSectionName(self, s, i):
    '''
    Return n1, n2 representing a section name.
    The section name, *including* brackes is s[n1:n2]
    '''
    end = s.find('\n', i)
    if end == -1:
        n1 = s.find("&lt;&lt;", i)
        n2 = s.find("&gt;&gt;", i)
    else:
        n1 = s.find("&lt;&lt;", i, end)
        n2 = s.find("&gt;&gt;", i, end)
    ok = -1 &lt; n1 &lt; n2
    if ok:
        # Warn on extra brackets.
        for ch, j in (('&lt;', n1 + 2), ('&gt;', n2 + 2)):
            if g.match(s, j, ch):
                line = g.get_line(s, i)
                g.es('dubious brackets in', line)
                break
        name = s[n1:n2+2]
        return name, n1, n2+2
    else:
        return None, n1, len(s)
</t>
<t tx="ekr.20041005105605.20">def warnOnReadOnlyFile(self, fn):
    # os.access() may not exist on all platforms.
    try:
        read_only = not os.access(fn, os.W_OK)
    except AttributeError:
        read_only = False
    if read_only:
        g.error("read only:", fn)
</t>
<t tx="ekr.20041005105605.200"># returns (flag, end). end is the index of the character after the section name.

def isSectionName(self, s, i):
    # 2013/08/01: bug fix: allow leading periods.
    while i &lt; len(s) and s[i] == '.':
        i += 1
    if not g.match(s, i, "&lt;&lt;"):
        return False, -1
    i = g.find_on_line(s, i, "&gt;&gt;")
    if i &gt; -1:
        return True, i + 2
    else:
        return False, -1
</t>
<t tx="ekr.20041005105605.201"># Note:  self.outputFile may be either a FileLikeObject or a real file.
</t>
<t tx="ekr.20041005105605.202">def oblank(self):
    self.os(' ')

def oblanks(self, n):
    self.os(' ' * abs(n))

def otabs(self, n):
    self.os('\t' * abs(n))
</t>
<t tx="ekr.20041005105605.203">def onl(self):
    """Write a newline to the output stream."""
    self.os('\n') # **not** self.output_newline

def onl_sent(self):
    """Write a newline to the output stream, provided we are outputting sentinels."""
    if self.sentinels:
        self.onl()
</t>
<t tx="ekr.20041005105605.204">def os(self, s):
    """
    Write a string to the output file or stream.

    All output produced by leoAtFile module goes here.
    """
    at = self
    if s.startswith(self.underindentEscapeString):
        try:
            junk, s = at.parseUnderindentTag(s)
        except Exception:
            at.exception("exception writing:" + s)
            return
    if not g.isUnicode(s):
        s = g.toUnicode(s, at.encoding)
    at.outputList.append(s)
</t>
<t tx="ekr.20041005105605.205"># Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings(self, s):
    at = self
    # Calling self.onl() runs afoul of queued newlines.
    if g.isPython3:
        s = g.ue(s, at.encoding)
    s = s.replace('\n', at.output_newline)
    self.os(s)
</t>
<t tx="ekr.20041005105605.206">def putDirective(self, s, i):
    r'''
    Output a sentinel a directive or reference s.

    It is important for PHP and other situations that \@first and \@last
    directives get translated to verbatim lines that do *not* include what
    follows the @first &amp; @last directives.
    '''
    at = self
    k = i
    j = g.skip_to_end_of_line(s, i)
    directive = s[i: j]
    if g.match_word(s, k, "@delims"):
        at.putDelims(directive, s, k)
    elif g.match_word(s, k, "@language"):
        self.putSentinel("@" + directive)
    elif g.match_word(s, k, "@comment"):
        self.putSentinel("@" + directive)
    elif g.match_word(s, k, "@last"):
        self.putSentinel("@@last")
            # Convert to an verbatim line _without_ anything else.
    elif g.match_word(s, k, "@first"):
        self.putSentinel("@@first")
            # Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)
    i = g.skip_line(s, k)
    return i
</t>
<t tx="ekr.20041005105605.207">def putDelims(self, directive, s, k):
    '''Put an @delims directive.'''
    at = self
    # Put a space to protect the last delim.
    at.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims
    # Skip the keyword and whitespace.
    j = i = g.skip_ws(s, k + len("@delims"))
    # Get the first delim.
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
        i += 1
    if j &lt; i:
        at.startSentinelComment = s[j: i]
        # Get the optional second delim.
        j = i = g.skip_ws(s, i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s, i):
            i += 1
        at.endSentinelComment = s[j: i] if j &lt; i else ""
    else:
        at.writeError("Bad @delims directive")
</t>
<t tx="ekr.20041005105605.21">def read(self, root, importFileName=None,
    fromString=None, atShadow=False, force=False
):
    """Read an @thin or @file tree."""
    at, c = self, self.c
    fileName = at.initFileName(fromString, importFileName, root)
    if not fileName:
        at.error("Missing file name.  Restoring @file tree from .leo file.")
        return False
    at.rememberReadPath(g.fullPath(c, root), root)
        # Fix bug 760531: always mark the root as read, even if there was an error.
        # Fix bug 889175: Remember the full fileName.
    at.initReadIvars(root, fileName,
        importFileName=importFileName, atShadow=atShadow)
    at.fromString = fromString
    if at.errors:
        return False
    fileName, file_s = at.openFileForReading(fromString=fromString)
        # For @shadow files, calls x.updatePublicAndPrivateFiles.
        # Calls at.initReadLine(s), where s is the file contents.
        # This will be used only if not cached.
    #
    # Set the time stamp.
    if fileName and at.inputFile:
        c.setFileTimeStamp(fileName)
    elif not fileName and not fromString and not file_s:
        return False
    root.clearVisitedInTree()
    at.scanAllDirectives(root, importing=at.importing, reading=True)
        # Sets the following ivars:
            # at.default_directory
            # at.encoding: **changed later** by readOpenFile/at.scanHeader.
            # at.explicitLineEnding
            # at.language
            # at.output_newline
            # at.page_width
            # at.tab_width
    gnx2vnode = c.fileCommands.gnxDict
    contents = fromString or file_s
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    root.clearDirty()
    return True
</t>
<t tx="ekr.20041005105605.210">def putIndent(self, n, s=''):
    """Put tabs and spaces corresponding to n spaces,
    assuming that we are at the start of a line.

    Remove extra blanks if the line starts with the underindentEscapeString"""
    tag = self.underindentEscapeString
    if s.startswith(tag):
        n2, s2 = self.parseUnderindentTag(s)
        if n2 &gt;= n: return
        elif n &gt; 0: n -= n2
        else: n += n2
    if n &gt; 0:
        w = self.tab_width
        if w &gt; 1:
            q, r = divmod(n, w)
            self.otabs(q)
            self.oblanks(r)
        else:
            self.oblanks(n)
</t>
<t tx="ekr.20041005105605.211">def putInitialComment(self):
    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = s2.split("\\n")
        for line in lines:
            line = line.replace("@date", time.asctime())
            if line:
                self.putSentinel("@comment " + line)
</t>
<t tx="ekr.20041005105605.216"># Called from putFile.

def warnAboutOrphandAndIgnoredNodes(self):
    # Always warn, even when language=="cweb"
    at, root = self, self.root
    if at.errors:
        return # No need to repeat this.
    for p in root.self_and_subtree(copy=False):
        if not p.v.isVisited():
            at.writeError("Orphan node:  " + p.h)
            if p.hasParent():
                g.blue("parent node:", p.parent().h)
    p = root.copy()
    after = p.nodeAfterTree()
    while p and p != after:
        if p.isAtAllNode():
            p.moveToNodeAfterTree()
        else:
            # #1050: test orphan bit.
            if p.isOrphan():
                at.writeError("Orphan node: " + p.h)
                if p.hasParent():
                    g.blue("parent node:", p.parent().h)
            p.moveToThreadNext()
</t>
<t tx="ekr.20041005105605.217">def writeError(self, message):
    '''Issue an error while writing an @&lt;file&gt; node.'''
    at = self
    if at.errors == 0:
        g.es_error("errors writing: " + at.targetFileName)
    at.error(message)
    at.addToOrphanList(at.root)
</t>
<t tx="ekr.20041005105605.218">def writeException(self, fileName, root):
    at = self
    g.error("exception writing:", fileName)
    g.es_exception()
    if getattr(at, 'outputFile', None):
        at.outputFile.flush()
        at.outputFile.close()
        at.outputFile = None
    at.remove(fileName)
    at.addToOrphanList(root)
</t>
<t tx="ekr.20041005105605.219"></t>
<t tx="ekr.20041005105605.22">def initFileName(self, fromString, importFileName, root):
    '''Return the fileName to be used in messages.'''
    at = self
    if fromString:
        fileName = "&lt;string-file&gt;"
    elif importFileName:
        fileName = importFileName
    elif root.isAnyAtFileNode():
        fileName = root.anyAtFileNodeName()
    else:
        fileName = None
    if fileName:
        # Fix bug 102: call the commander method, not the global funtion.
        fileName = at.c.os_path_finalize(fileName)
    return fileName
</t>
<t tx="ekr.20041005105605.220">def error(self, *args):
    at = self
    if True: # args:
        at.printError(*args)
    at.errors += 1

def printError(self, *args):
    '''Print an error message that may contain non-ascii characters.'''
    at = self
    if at.errors:
        g.error(*args)
    else:
        g.warning(*args)
</t>
<t tx="ekr.20041005105605.221">def exception(self, message):
    self.error(message)
    g.es_exception()
</t>
<t tx="ekr.20041005105605.26">def readAll(self, root, force=False):
    """Scan positions, looking for @&lt;file&gt; nodes to read."""
    at, c = self, self.c
    old_changed = c.changed
    if force:
        # Capture the current headline only if
        # we aren't doing the initial read.
        c.endEditing()
    t1 = time.time()
    c.init_error_dialogs()
    files = at.findFilesToRead(force, root)
    for p in files:
        at.readFileAtPosition(force, p)
    for p in files:
        p.v.clearDirty()
    if not g.unitTesting:
        if files:
            t2 = time.time()
            g.es('read %s files in %2.2f seconds' % (len(files), t2 - t1))
        elif force:
            g.es("no @&lt;file&gt; nodes in the selected tree")
    c.changed = old_changed
    c.raise_error_dialogs()
</t>
<t tx="ekr.20041005105605.7"></t>
<t tx="ekr.20041005105605.8"># Note: g.getScript also call the at.__init__ and at.finishCreate().

def __init__(self, c):
    '''ctor for atFile class.'''
    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.encoding = 'utf-8' # 2014/08/13
    self.fileCommands = c.fileCommands
    self.errors = 0 # Make sure at.error() works even when not inited.
    # **Only** at.writeAll manages these flags.
    # promptForDangerousWrite sets cancelFlag and yesToAll only if canCancelFlag is True.
    self.canCancelFlag = False
    self.cancelFlag = False
    self.yesToAll = False
    # User options: set in reloadSettings.
    self.checkPythonCodeOnWrite = False
    self.runPyFlakesOnWrite = False
    self.underindentEscapeString = '\\-'
    self.reloadSettings()
</t>
<t tx="ekr.20041119204714">def visitNode(self, p):
    """Init any settings found in node p."""
    p = p.copy()
        # Bug fix 2011/11/24
        # Ensure inner traversals don't change callers's p.
    munge = g.app.config.munge
    kind, name, val = self.parseHeadline(p.h)
    kind = munge(kind)
    if g.isPython3:
        isNone = val in ('None', 'none', '', None)
    else:
        isNone = val in (
            g.u('None'), g.u('none'), g.u(''),
            'None', 'none', '', None)
    if kind is None: # Not an @x node. (New in Leo 4.4.4)
        pass
    elif kind == "settings":
        pass
    # elif kind in self.basic_types and val in (u'None',u'none','None','none','',None):
    elif kind in self.basic_types and isNone:
        # None is valid for all basic types.
        self.set(p, kind, name, None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        if f:
            try:
                return f(p, kind, name, val)
            except Exception:
                g.es_exception()
        else:
            g.pr("*** no handler", kind)
    return None
</t>
<t tx="ekr.20041121143823">def getValFromDict(self, d, setting, requestedType, warn=True):
    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''
    gs = d.get(self.munge(setting))
    if not gs: return None, False
    assert isinstance(gs, g.GeneralSetting)
    val = gs.val
    # 2011/10/24: test for an explicit None.
    if g.isPython3:
        isNone = val in ('None', 'none', '') # ,None)
    else:
        isNone = val in (
            g.u('None'), g.u('none'), g.u(''),
            'None', 'none', '')
    if not self.typesMatch(gs.kind, requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.error('warning: ignoring', gs.kind, '', setting, 'is not', requestedType)
            g.error('there may be conflicting settings!')
        return None, False
    # elif val in (u'None',u'none','None','none','',None):
    elif isNone:
        return '', True
            # 2011/10/24: Exists, a *user-defined* empty value.
    else:
        return val, True
</t>
<t tx="ekr.20050103163224">def scanHeaderForThin(self, fileName):
    '''
    Return true if the derived file is a thin file.

    This is a kludgy method used only by the import code.'''
    at = self
    at.readFileToUnicode(fileName)
        # Sets at.encoding, regularizes whitespace and calls at.initReadLines.
    junk, junk, isThin = at.scanHeader(None)
        # scanHeader uses at.readline instead of its args.
        # scanHeader also sets at.encoding.
    return isThin
</t>
<t tx="ekr.20050104131820">def chmod(self, fileName, mode):
    # Do _not_ call self.error here.
    return g.utils_chmod(fileName, mode)
</t>
<t tx="ekr.20050104131929">@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
</t>
<t tx="ekr.20050104132018">def remove(self, fileName, verbose=True):
    if not fileName:
        g.trace('No file name', g.callers())
        return False
    try:
        os.remove(fileName)
        return True
    except Exception:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
            g.trace(g.callers(5))
        return False
</t>
<t tx="ekr.20050104132026">def stat(self, fileName):
    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''
    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
</t>
<t tx="ekr.20050208093800.1"># This inlining makes a huge difference.
# It saves most calls to _toUnicode and g.isUnicode!

if isPython3:
    def toUnicode(s, encoding='utf-8', reportErrors=False):
        '''Convert a non-unicode string with the given encoding to unicode.'''
        # pylint: disable=no-member
        return s if isinstance(s, str) else _toUnicode(s, encoding, reportErrors)
else:
    def toUnicode(s, encoding='utf-8', reportErrors=False):
        '''Convert a non-unicode string with the given encoding to unicode.'''
        # pylint: disable=no-member
        return s if isinstance(s, types.UnicodeType) else _toUnicode(s, encoding, reportErrors)
            
def _toUnicode(s, encoding, reportErrors):
    '''Helper for g.toUnicode.'''
    if not encoding:
        encoding = 'utf-8'
    #
    # These are the only significant calls to s.decode in Leo.
    try:
        s = s.decode(encoding, 'strict')
    except (UnicodeDecodeError, UnicodeError):
        # https://wiki.python.org/moin/UnicodeDecodeError
        s = s.decode(encoding, 'replace')
        if reportErrors:
            g.trace(g.callers())
            g.error("toUnicode: Error converting %s...from %s encoding to unicode" % (
                s[: 200], encoding))
    except AttributeError:
        # May be a QString.
        s = g.u(s)
    return s
</t>
<t tx="ekr.20050208101229">if 0:
    # This is now done in run.
    import leo.core.leoGlobals as g # So code can use g below.
# Don't import this here: it messes up Leo's startup code.
# import leo.core.leoTest as leoTest
try:
    import builtins # Python 3
except ImportError:
    import __builtin__ as builtins # Python 2.
import codecs
try:
    import filecmp
except ImportError: # does not exist in jython.
    filecmp = None
if isPython3:
    from functools import reduce
try:
    import gc
except ImportError:
    gc = None
try:
    import gettext
except ImportError: # does not exist in jython.
    gettext = None
import glob
if isPython3:
    import io
    StringIO = io.StringIO
else:
    import cStringIO
    StringIO = cStringIO.StringIO
# import functools
import imp
import inspect
# import locale
import operator
import os
# Module 'urllib' has no 'parse' member.
import urllib # py-lint: disable=E0611
# Do NOT import pdb here!  We shall define pdb as a _function_ below.
# import pdb
import re
import shlex
import shutil
import string
import subprocess
# import sys
import tempfile
import time
import traceback
import types
if isPython3:
    # pylint: disable=no-name-in-module
    import urllib.parse as urlparse
else:
    import urlparse
import binascii
# import zipfile
# These do not exist in IronPython.
# However, it *is* valid for IronPython to use the Python 2.4 libs!
    # import os
    # import string
    # import tempfile
    # import traceback
    # import types
</t>
<t tx="ekr.20050404151753.6">def write(self, s):
    if s:
        if g.isBytes(s):
            s = g.toUnicode(s, self.encoding)
        self.list.append(s)
</t>
<t tx="ekr.20050405141130">import xml.etree.ElementTree as ElementTree
try:
    # IronPython has problems with this.
    import xml.sax
    import xml.sax.saxutils
except Exception:
    pass
import leo.core.leoGlobals as g
import leo.core.leoNodes as leoNodes
import binascii
from collections import defaultdict
import difflib
import time
if g.isPython3:
    import io # Python 3.x
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    import cStringIO # Python 2.x
    StringIO = cStringIO.StringIO
import os
import pickle
# import string
# import sys
import tempfile
import zipfile
import sqlite3
import hashlib
from contextlib import contextmanager
</t>
<t tx="ekr.20050418161620.2">def putUaHelper(self, torv, key, val):
    '''Put attribute whose name is key and value is val to the output stream.'''
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if g.isString(val) or g.isBytes(val):
            val = g.toUnicode(val)
            attr = ' %s="%s"' % (key, xml.sax.saxutils.escape(val))
            return attr
        else:
            g.trace(type(val), repr(val))
            g.warning("ignoring non-string attribute", key, "in", torv)
            return ''
    else:
        return self.pickle(torv=torv, val=val, tag=key)
</t>
<t tx="ekr.20050506084734">def stringToString(self, root, s, forcePythonSentinels=True, sentinels=True):
    """
    Write a 4.x derived file from a string.

    This is at.write specialized for scripting.
    """
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;",
            forcePythonSentinels=forcePythonSentinels, sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, fromString=s, sentinels=sentinels)
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if root:
            if hasattr(self.root.v, 'tnodeList'):
                delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        at.exception("exception preprocessing script")
        return g.u('')
</t>
<t tx="ekr.20050506090446.1">def putAtFirstLines(self, s):
    '''Write any @firstlines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines preceding the @+leo sentinel.'''
    at = self; tag = "@first"
    i = 0
    while g.match(s, i, tag):
        i += len(tag)
        i = g.skip_ws(s, i)
        j = i
        i = g.skip_to_end_of_line(s, i)
        # Write @first line, whether empty or not
        line = s[j: i]
        at.os(line); at.onl()
        i = g.skip_nl(s, i)
</t>
<t tx="ekr.20050506090955">def putAtLastLines(self, s):
    '''Write any @last lines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines following the @-leo sentinel.'''
    at = self; tag = "@last"
    # Use g.splitLines to preserve trailing newlines.
    lines = g.splitLines(s)
    n = len(lines); j = k = n - 1
    # Scan backwards for @last directives.
    while j &gt;= 0:
        line = lines[j]
        if g.match(line, 0, tag): j -= 1
        elif not line.strip():
            j -= 1
        else: break
    # Write the @last lines.
    for line in lines[j + 1: k + 1]:
        if g.match(line, 0, tag):
            i = len(tag); i = g.skip_ws(line, i)
            at.os(line[i:])
</t>
<t tx="ekr.20050721093241">@nobeautify
@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1.

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.

- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction.
</t>
<t tx="ekr.20050819064157">def objToString(obj, indent='', printCaller=False, tag=None):
    '''Pretty print any Python object to a string.'''
    # pylint: disable=undefined-loop-variable
        # Looks like a a pylint bug.
    #
    # Compute s.
    if isinstance(obj, dict):
        s = dictToString(obj, indent=indent)
    elif isinstance(obj, list):
        s = listToString(obj, indent=indent)
    elif isinstance(obj, tuple):
        s = tupleToString(obj, indent=indent)
    elif g.isString(obj):
        # Print multi-line strings as lists.
        s = obj
        lines = g.splitLines(s)
        if len(lines) &gt; 1:
            s = listToString(lines, indent=indent)
        else:
            s = repr(s)
    else:
        s = repr(obj)
    #
    # Compute the return value.
    if printCaller and tag:
        prefix = '%s: %s' % (g.caller(), tag)
    elif printCaller or tag:
        prefix = g.caller() if printCaller else tag
    else:
        prefix = None
    if prefix:
        sep = '\n' if '\n' in s else ' '
        return '%s:%s%s' % (prefix, sep, s)
    return s
toString = objToString
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051104075904.10">def runTest(self, define_g=True):
    '''Run a Leo GeneralTestCase test.'''
    trace_time = False
    tm = self
    c = tm.c
    p = tm.p.copy()
    if trace_time:
        t1 = time.clock()
    script = g.getScript(c, p).strip()
    if self.setup_script:
        script = self.setup_script + '\n' + script
    tm.assertTrue(script)
    if c.shortFileName() == 'dynamicUnitTest.leo':
        c.write_script_file = True
    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c': c, 'g': g, 'p': p and p.copy()}
    if define_g:
        d = {'c': c, 'g': g, 'p': p and p.copy(), 'self': tm,}
    else:
        d = {'self': tm,}
    script = script + '\n'
    # Execute the script. Let the unit test handle any errors!
    # 2011/11/02: pass the script sources to exec or execfile.
    if c.write_script_file:
        scriptFile = c.writeScriptFile(script)
        # pylint: disable=no-member
        if g.isPython3:
            exec(compile(script, scriptFile, 'exec'), d)
        else:
            builtins.execfile(scriptFile, d)
    else:
        exec(script, d)
    if trace_time:
        t2 = time.clock()
        if t2 - t1 &gt; 3.0:
            print('')
            g.trace('EXCESSIVE TIME: %5.2f sec. in %s' % (t2-t1, self.p.h))
</t>
<t tx="ekr.20051104075904.12"># This code executes the script in an @suite node.
# This code assumes that the script sets the 'suite' var to the test suite.

def makeTestSuite(self, p, setup_script):
    """Create a suite of test cases by executing the script in an @suite node."""
    c, tm = self.c, self
    fname = 'makeTestSuite'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("no script in %s" % p.h)
        return None
    if setup_script:
        script = setup_script + script
    try:
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print("\n%s: %s script did not set suite var" % (fname, p.h))
        return suite
    except Exception:
        print('\n%s: exception creating test cases for %s' % (fname, p.h))
        g.es_print_exception()
        return None
</t>
<t tx="ekr.20051104075904.18">def set_debugGc():
    # pylint: disable=no-member
    if g.isPython3:
        gc.set_debug(
            gc.DEBUG_STATS # prints statistics.
            # gc.DEBUG_LEAK | # Same as all below.
            # gc.DEBUG_COLLECTABLE
            # gc.DEBUG_UNCOLLECTABLE
            # gc.DEBUG_SAVEALL
        )
    else:
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            # gc.DEBUG_LEAK | # Same as all below.
            # gc.DEBUG_COLLECTABLE
            # gc.DEBUG_UNCOLLECTABLE
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS
            # gc.DEBUG_SAVEALL
        )
</t>
<t tx="ekr.20051104075904.22">import types
import inspect
global lastFunctionsDict
funcDict = {}
for obj in gc.get_objects():
    if isinstance(obj, types.FunctionType):
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key] = None
        if key not in lastFunctionsDict:
            g.pr('\n', obj)
            if g.isPython3:
                # pylint: disable=no-member
                # signature exists in Python 3.x.
                args, varargs, varkw, defaults = inspect.signature(obj)
                g.pr("args", args)
                if varargs: g.pr("varargs", varargs)
                if varkw: g.pr("varkw", varkw)
                if defaults:
                    g.pr("defaults...")
                    for s in defaults: g.pr(s)
lastFunctionsDict = funcDict
funcDict = {}
</t>
<t tx="ekr.20051104075904.93">def checkFileSyntax(self, fileName, s, reraise=True, suppress=False):
    '''Called by a unit test to check the syntax of a file.'''
    try:
        if not g.isPython3:
            s = g.toEncodedString(s)
        s = s.replace('\r', '')
        compile(s + '\n', fileName, 'exec')
        return True
    except SyntaxError:
        if not suppress:
            g.warning("syntax error in:", fileName)
            g.es_print_exception(full=True, color="black")
        if reraise: raise
        return False
    except Exception:
        if not suppress:
            g.warning("unexpected error in:", fileName)
            # g.es_print_exception(full=False,color="black")
        if reraise: raise
        return False
</t>
<t tx="ekr.20051104075904.97"># Some of these will fail now for Python 2.x.

def factorial(n):
    """Return the factorial of n, an exact integer &gt;= 0.

    If the result is small enough to fit in an int, return an int.
    Else return a long.

    &gt;&gt;&gt; [factorial(n) for n in range(6)]
    [1, 1, 2, 6, 24, 120]
    &gt;&gt;&gt; factorial(30)
    265252859812191058636308480000000
    &gt;&gt;&gt; factorial(-1)
    Traceback (most recent call last):
        ...
    ValueError: n must be &gt;= 0

    Factorials of floats are OK, but the float must be an exact integer:
    &gt;&gt;&gt; factorial(30.1)
    Traceback (most recent call last):
        ...
    ValueError: n must be exact integer
    &gt;&gt;&gt; factorial(30.0)
    265252859812191058636308480000000

    It must also not be ridiculously large:
    &gt;&gt;&gt; factorial(1e100)
    Traceback (most recent call last):
        ...
    OverflowError: n too large
    """
    import math
    if not n &gt;= 0:
        raise ValueError("n must be &gt;= 0")
    if math.floor(n) != n:
        raise ValueError("n must be exact integer")
    if n + 1 == n: # catch a value like 1e300
        raise OverflowError("n too large")
    result = 1
    factor = 2
    while factor &lt;= n:
        try:
            result *= factor
        except OverflowError:
            # pylint: disable=no-member
            f = builtins.int if g.isPython3 else builtins.long
            result *= f(factor)
        factor += 1
    return result
</t>
<t tx="ekr.20060127162818">def enable_gc_debug(event=None):
    # pylint: disable=no-member
    if not gc:
        g.error('can not import gc module')
        return
    if g.isPython3:
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            gc.DEBUG_LEAK | # Same as all below.
            gc.DEBUG_COLLECTABLE |
            gc.DEBUG_UNCOLLECTABLE |
            # gc.DEBUG_INSTANCES |
            # gc.DEBUG_OBJECTS |
            gc.DEBUG_SAVEALL)
    else:
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            gc.DEBUG_LEAK | # Same as all below.
            gc.DEBUG_COLLECTABLE |
            gc.DEBUG_UNCOLLECTABLE |
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS |
            gc.DEBUG_SAVEALL)
</t>
<t tx="ekr.20060221083356">def prettyPrintType(obj):
    # pylint: disable=no-member
    # These do not exist in Python 3.
    if g.isString(obj):
        return 'string'
    # Compute method types.
    method_types = [types.MethodType, types.BuiltinMethodType]
    if g.isPython3:
        method_types.append(types.UnboundMethodType)
    t = type(obj)
    if t in (types.BuiltinFunctionType, types.FunctionType):
        return 'function'
    elif t == types.ModuleType: # NOQA
        return 'module'
    elif t == types.InstanceType: # NOQA
        return 'object'
    elif t in method_types:
        return 'method'
    else:
        # Fall back to a hack.
        t = str(type(obj))
        if t.startswith("&lt;type '"): t = t[7:]
        if t.endswith("'&gt;"): t = t[: -2]
        return t
</t>
<t tx="ekr.20060810095921">def translateString(s):
    '''Return the translated text of s.'''
    # pylint: disable=undefined-loop-variable
    # looks like a pylint bug
    upper = app and getattr(app, 'translateToUpperCase', None)
    if isPython3:
        if not isString(s):
            s = str(s, 'utf-8')
        if upper:
            s = s.upper()
        else:
            s = gettext.gettext(s)
        return s
    else:
        if upper:
            return s.upper()
        else:
            return gettext.gettext(s)

tr = translateString
</t>
<t tx="ekr.20061031131434.126">def manufactureKeyPressForCommandName(self, w, commandName):
    '''
    Implement a command by passing a keypress to the gui.
    
    **Only unit tests use this method.**
    '''
    c, k = self.c, self
    stroke = k.getStrokeForCommandName(commandName)
    assert g.isStroke(stroke), stroke.__class__.__name__
    shortcut = stroke.s
    assert g.isString(shortcut)
    if shortcut and w:
        g.app.gui.set_focus(c, w)
        g.app.gui.event_generate(c, None, shortcut, w)
    else:
        message = 'no shortcut for %s' % (commandName)
        if g.app.unitTesting:
            raise AttributeError(message)
        else:
            g.error(message)
</t>
<t tx="ekr.20061119120006">def addIconButton(self, *args, **keys):
    if self.iconBar: return self.iconBar.add(*args, **keys)
    else: return None

def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

def addIconWidget(self, w):
    if self.iconBar: return self.iconBar.addWidget(w)

def clearIconBar(self):
    if self.iconBar: self.iconBar.clear()

def createIconBar(self):
    c = self.c
    if not self.iconBar:
        self.iconBar = self.iconBarClass(c, self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c, self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c, self.outerFrame)
    return self.iconBar.getNewFrame()

def hideIconBar(self):
    if self.iconBar: self.iconBar.hide()

def showIconBar(self):
    if self.iconBar: self.iconBar.show()
</t>
<t tx="ekr.20070115135502">def writeScriptFile(self, script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script-file-path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        # xxx bad idea, loadDir is often read only!
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.homeLeoDir, 'scriptFile.py')
    # Write the file.
    try:
        if g.isPython3:
            # Use the default encoding.
            f = open(path, encoding='utf-8', mode='w')
        else:
            f = open(path, 'w')
        s = script
        if not g.isPython3: # 2010/08/27
            s = g.toEncodedString(s, reportErrors=True)
        f.write(s)
        f.close()
    except Exception:
        g.es_exception()
        g.es("Failed to write script to %s" % path)
        # g.es("Check your configuration of script_file_path, currently %s" %
            # c.config.getString('script-file-path'))
        path = None
    return path
</t>
<t tx="ekr.20070317130250">def selectChapterByName(self, name, collapse=True):
    '''Select a chapter.  Return True if a redraw is needed.'''
    cc = self
    if self.selectChapterLockout:
        return
    if g.isInt(name):
        return cc.note('PyQt5 chapters not supported')
    chapter = cc.getChapter(name)
    if not chapter:
        g.es_print('no such @chapter node: %s' % name)
        return
    try:
        cc.selectChapterLockout = True
        cc.selectChapterByNameHelper(chapter, collapse=collapse)
    finally:
        cc.selectChapterLockout = False
</t>
<t tx="ekr.20070626132332">def es(*args, **keys):
    '''Put all non-keyword args to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    if not app or app.killed:
        return
    if app.gui and app.gui.consoleOnly:
        return
    log = app.log
    # Compute the effective args.
    d = {
        'color': None,
        'commas': False,
        'newline': True,
        'spaces': True,
        'tabName': 'Log',
        'nodeLink': None,
    }
    d = g.doKeywordArgs(keys, d)
    color = d.get('color')
    if color == 'suppress':
        return # New in 4.3.
    color = g.actualColor(color)
    tabName = d.get('tabName') or 'Log'
    newline = d.get('newline')
    s = g.translateArgs(args, d)
    if app.batchMode:
        if app.log:
            app.log.put(s)
    elif g.unitTesting:
        if log and not log.isNull:
            # This makes the output of unit tests match the output of scripts.
            g.pr(s, newline=newline)
    elif log and app.logInited:
        if newline:
            s += '\n'
        log.put(s, color=color, tabName=tabName, nodeLink=d['nodeLink'])
        # Count the number of *trailing* newlines.
        for ch in s:
            if ch == '\n': log.newlines += 1
            else: log.newlines = 0
    else:
        app.logWaiting.append((s, color, newline, d),)
        
log = es

</t>
<t tx="ekr.20070806105859">@cmd('write-at-auto-nodes')
def writeAtAutoNodes(self, event=None):
    '''Write all @auto nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    at.writeAtAutoNodesHelper(writeDirtyOnly=False)
    c.raise_error_dialogs(kind='write')

@cmd('write-dirty-at-auto-nodes')
def writeDirtyAtAutoNodes(self, event=None):
    '''Write all dirty @auto nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    at.writeAtAutoNodesHelper(writeDirtyOnly=True)
    c.raise_error_dialogs(kind='write')
</t>
<t tx="ekr.20070806141607">def writeOneAtAutoNode(self, p):
    '''
    Write p, an @auto node.
    File indices *must* have already been assigned.
    Return True if the node was written successfully.
    '''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        if not p.atAutoNodeName():
            return False
        fileName = at.initWriteIvars(root, p.atAutoNodeName(),
            defaultDirectory = g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        if not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        if c.persistenceController:
            c.persistenceController.update_before_write_foreign_file(root)
        contents = at.writeAtAutoContents(fileName, root)
        if contents is None:
            g.es("not written:", fileName)
            at.addToOrphanList(root)
            return False
        at.replaceFile(contents, at.encoding, fileName, root,
            ignoreBlankLines=root.isAtAutoRstNode())
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20070909100252">def readOneAtAutoNode(self, fileName, p):
    '''Read an @auto file into p. Return the *new* position.'''
    at, c, ic = self, self.c, self.c.importCommands
    oldChanged = c.isChanged()
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    fileName = c.os_path_finalize_join(at.default_directory, fileName)
    if not g.os_path_exists(fileName):
        g.error('not found: %r' % (p.h), nodeLink=p.get_UNL(with_proto=True))
        return p
    # Remember that we have seen the @auto node.
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fileName, p)
    ### if not g.unitTesting: g.es("reading:", p.h)
    try:
        # For #451: return p.
        old_p = p.copy()
        at.scanAllDirectives(
            p,
            forcePythonSentinels=False,
            importing=True,
            reading=True,
        )
        p.v.b = '' # Required for @auto API checks.
        p.v._deleteAllChildren()
        p = ic.createOutline(fileName, parent=p.copy())
        # Do *not* select a postion here.
        # That would improperly expand nodes.
            # c.selectPosition(p)
    except Exception:
        p = old_p
        ic.errors += 1
        g.es_print('Unexpected exception importing', fileName)
        g.es_exception()
    if ic.errors:
        g.error('errors inhibited read @auto %s' % (fileName))
    elif c.persistenceController:
        c.persistenceController.update_after_read_foreign_file(p)
    # Finish.
    if ic.errors or not g.os_path_exists(fileName):
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        g.doHook('after-auto', c=c, p=p)
    return p
</t>
<t tx="ekr.20070915142635">@g.commander_command('write-file-from-node')
def writeFileFromNode(self, event=None):
    '''If node starts with @read-file-into-node, use the full path name in the headline.
    Otherwise, prompt for a file name.
    '''
    c = self; p = c.p
    c.endEditing()
    h = p.h.rstrip()
    s = p.b
    tag = '@read-file-into-node'
    if h.startswith(tag):
        fileName = h[len(tag):].strip()
    else:
        fileName = None
    if not fileName:
        filetypes = [("All files", "*"), ("Python files", "*.py"), ("Leo files", "*.leo"),]
        fileName = g.app.gui.runSaveFileDialog(c,
            initialfile=None,
            title='Write File From Node',
            filetypes=filetypes,
            defaultextension=None)
    if fileName:
        try:
            with open(fileName, 'w') as f:
                g.chdir(fileName)
                if s.startswith('@nocolor\n'):
                    s = s[len('@nocolor\n'):]
                if not g.isPython3: # 2010/08/27
                    s = g.toEncodedString(s, reportErrors=True)
                f.write(s)
                f.flush()
                g.blue('wrote:', fileName)
        except IOError:
            g.error('can not write %s', fileName)
        
</t>
<t tx="ekr.20070919133659">@cmd('check-derived-file')
def checkDerivedFile(self, event=None):
    '''Make sure an external file written by Leo may be read properly.'''
    g.trace('=====')
    at = self; c = at.c; p = c.p
    if not p.isAtFileNode() and not p.isAtThinFileNode():
        return g.red('Please select an @thin or @file node')
    fn = p.anyAtFileNodeName()
    path = g.os_path_dirname(c.mFileName)
    fn = g.os_path_finalize_join(g.app.loadDir, path, fn)
    if not g.os_path_exists(fn):
        return g.error('file not found: %s' % (fn))
    s, e = g.readFileIntoString(fn)
    if s is None: return
    #
    # Create a dummy, unconnected, VNode as the root.
    root_v = leoNodes.VNode(context=c)
    root = leoNodes.Position(root_v)
    FastAtRead(c, gnx2vnode={}).read_into_root(s, fn, root)
    return c
</t>
<t tx="ekr.20071105164407">def deleteUnvisitedNodes(self, root, redraw=True):
    '''
    Delete unvisited nodes in root's subtree, not including root.

    Before Leo 5.6: Move unvisited node to be children of the 'Resurrected
    Nodes'.
    '''
    at = self
    # Find the unvisited nodes.
    aList = [z for z in root.subtree() if not z.isVisited()]
    if aList:
        # new-read: Never create resurrected nodes.
            # r = at.createResurrectedNodesNode()
            # callback = at.defineResurrectedNodeCallback(r, root)
            # # Move the nodes using the callback.
            # at.c.deletePositionsInList(aList, callback)
        at.c.deletePositionsInList(aList, redraw=redraw)
</t>
<t tx="ekr.20080220111323">console_encoding = None

def translateArgs(args, d):
    '''Return the concatenation of s and all args,

    with odd args translated.'''
    global console_encoding
    if not console_encoding:
        e = sys.getdefaultencoding()
        console_encoding = e if isValidEncoding(e) else 'utf-8'
        # print 'translateArgs',console_encoding
    result = []; n = 0; spaces = d.get('spaces')
    for arg in args:
        n += 1
        # print('g.translateArgs: arg',arg,type(arg),g.isString(arg),'will trans',(n%2)==1)
        # First, convert to unicode.
        if g.isString(arg):
            arg = toUnicode(arg, console_encoding)
        # Now translate.
        if not isString(arg):
            arg = repr(arg)
        elif(n % 2) == 1:
            arg = translateString(arg)
        else:
            pass # The arg is an untranslated string.
        if arg:
            if result and spaces: result.append(' ')
            result.append(arg)
    return ''.join(result)
</t>
<t tx="ekr.20080412053100.5">@language rest
</t>
<t tx="ekr.20080708094444.36">def propagate_changes(self, old_public_file, old_private_file):
    '''
    Propagate the changes from the public file (without_sentinels)
    to the private file (with_sentinels)
    '''
    x, at = self, self.c.atFileCommands
    at.errors = 0
    self.encoding = at.encoding
    s = at.readFileToUnicode(old_private_file)
        # Sets at.encoding and inits at.readLines.
    old_private_lines = g.splitLines(s)
    s = at.readFileToUnicode(old_public_file)
    if at.encoding != self.encoding:
        g.trace('can not happen: encoding mismatch: %s %s' % (
            at.encoding, self.encoding))
        at.encoding = self.encoding
    old_public_lines = g.splitLines(s)
    if 0:
        g.trace('\nprivate lines...%s' % old_private_file)
        for s in old_private_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
        g.trace('\npublic lines...%s' % old_public_file)
        for s in old_public_lines:
            g.trace(type(s), g.isUnicode(s), repr(s))
    marker = x.markerFromFileLines(old_private_lines, old_private_file)
    new_private_lines = x.propagate_changed_lines(
        old_public_lines, old_private_lines, marker)
    # Important bug fix: Never create the private file here!
    fn = old_private_file
    exists = g.os_path_exists(fn)
    different = new_private_lines != old_private_lines
    copy = exists and different
    # 2010/01/07: check at.errors also.
    if copy and x.errors == 0 and at.errors == 0:
        s = ''.join(new_private_lines)
        x.replaceFileWithString(at.encoding, fn, s)
    return copy
</t>
<t tx="ekr.20080708094444.38">def propagate_changed_lines(self, new_public_lines, old_private_lines, marker, p=None):
    &lt;&lt; docstring &gt;&gt;
    x = self
    x.init_ivars(new_public_lines, old_private_lines, marker)
    sm = difflib.SequenceMatcher(None, x.a, x.b)
    # Ensure leading sentinels are put first.
    x.put_sentinels(0)
    x.sentinels[0] = []
    for tag, ai, aj, bi, bj in sm.get_opcodes():
        f = x.dispatch_dict.get(tag, x.op_bad)
        f(tag, ai, aj, bi, bj)
    # Put the trailing sentinels &amp; check the result.
    x.results.extend(x.trailing_sentinels)
    # check_output is likely to be more buggy than the code under test.
    # x.check_output()
    return x.results
</t>
<t tx="ekr.20080708094444.40">def init_ivars(self, new_public_lines, old_private_lines, marker):
    '''Init all ivars used by propagate_changed_lines &amp; its helpers.'''
    x = self
    x.delim1, x.delim2 = marker.getDelims()
    x.marker = marker
    x.old_sent_lines = old_private_lines
    x.results = []
    x.verbatim_line = '%s@verbatim%s\n' % (x.delim1, x.delim2)
    old_public_lines = x.init_data()
    x.b = x.preprocess(new_public_lines)
    x.a = x.preprocess(old_public_lines)
</t>
<t tx="ekr.20080710101653.1"># see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args, **keys):
    '''
    Print all non-keyword args. This is a wrapper for the print statement.

    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''
    # Compute the effective args.
    d = {'commas': False, 'newline': True, 'spaces': True}
    d = doKeywordArgs(keys, d)
    newline = d.get('newline')
    stdout = sys.stdout if sys.stdout and g.unitTesting else sys.__stdout__
        # Unit tests require sys.stdout.
    if not stdout:
        # Fix #541.
        return
    if sys.platform.lower().startswith('win'):
        encoding = 'ascii' # 2011/11/9.
    elif getattr(stdout, 'encoding', None):
        # sys.stdout is a TextIOWrapper with a particular encoding.
        encoding = stdout.encoding
    else:
        encoding = 'utf-8'
    s = translateArgs(args, d)
        # Translates everything to unicode.
    func = g.toUnicode if g.isPython3 else g.toEncodedString
    s = func(s, encoding=encoding, reportErrors=False)
    if newline:
        s += g.u('\n') if g.isPython3 else '\n'
    # Python's print statement *can* handle unicode, but
    # sitecustomize.py must have sys.setdefaultencoding('utf-8')
    try:
        # 783: print-* commands fail under pythonw.
        # https://github.com/leo-editor/leo-editor/issues/783.
        stdout.write(s)
    except Exception:
        pass
</t>
<t tx="ekr.20080711093251.3">@cmd('write-at-shadow-nodes')
def writeAtShadowNodes(self, event=None):
    '''Write all @shadow nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    val = at.writeAtShadowNodesHelper(writeDirtyOnly=False)
    c.raise_error_dialogs(kind='write')
    return val

@cmd('write-dirty-at-shadow-nodes')
def writeDirtyAtShadowNodes(self, event=None):
    '''Write all dirty @shadow nodes in the selected outline.'''
    at = self; c = at.c
    c.init_error_dialogs()
    val = at.writeAtShadowNodesHelper(writeDirtyOnly=True)
    c.raise_error_dialogs(kind='write')
    return val
</t>
<t tx="ekr.20080711093251.5">def writeOneAtShadowNode(self, p, testing=False):
    '''
    Write p, an @shadow node.
    File indices *must* have already been assigned.
    
    testing: set by unit tests to suppress the call to at.precheck.
    '''
    at, c = self, self.c
    root = p.copy()
    x = c.shadowController
    try:
        c.endEditing() # Capture the current headline.
        fn = p.atShadowFileNodeName()
        assert fn, p.h
        self.adjustTargetLanguage(fn) 
            # A hack to support unknown extensions. May set c.target_language.
        full_path = g.fullPath(c, p)
        at.initWriteIvars(root, None,
            atShadow = True,
            defaultDirectory = g.os_path_dirname(full_path),
            forcePythonSentinels = True)
                # Force python sentinels to suppress an error message.
                # The actual sentinels will be set below.
        at.default_directory = g.os_path_dirname(full_path)
            # Override.
        # Make sure we can compute the shadow directory.
        private_fn = x.shadowPathName(full_path)
        if not private_fn:
            return False
        if not testing and not at.precheck(full_path, root):
            return False
        #
        # Bug fix: Leo 4.5.1:
        # use x.markerFromFileName to force the delim to match
        # what is used in x.propegate changes.
        marker = x.markerFromFileName(full_path)
        at.startSentinelComment, at.endSentinelComment = marker.getDelims()
        if g.app.unitTesting:
            ivars_dict = g.getIvarsDict(at)
        #
        # Write the public and private files to strings.
        def put(sentinels):
            at.openOutputStream()
            at.sentinels = sentinels
            at.putFile(root, sentinels=sentinels)
            return at.closeOutputStream()
            
        at.public_s = put(False)
        at.private_s = put(True)
        at.warnAboutOrphandAndIgnoredNodes()
        if g.app.unitTesting:
            exceptions = ('public_s', 'private_s', 'sentinels', 'outputList')
            assert g.checkUnchangedIvars(at, ivars_dict, exceptions), 'writeOneAtShadowNode'
        if not at.errors:
            # Write the public and private files.
            x.makeShadowDirectory(full_path)
                # makeShadowDirectory takes a *public* file name.
            x.replaceFileWithString(at.encoding, private_fn, at.private_s)
            x.replaceFileWithString(at.encoding, full_path, at.public_s)
        at.checkPythonCode(
            contents = at.private_s,
            fileName = full_path,
            root = root,
        )
        if at.errors:
            g.error("not written:", full_path)
            at.addToOrphanList(root)
        else:
            root.clearDirty()
        return not at.errors
    except Exception:
        at.writeException(full_path, root)
        return False
</t>
<t tx="ekr.20080711093251.7">def readOneAtShadowNode(self, fn, p, force=False):

    at = self; c = at.c; x = c.shadowController
    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    fn = c.os_path_finalize_join(at.default_directory, fn)
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    if shadow_exists:
        at.read(p, atShadow=True, force=force)
    else:
        ### if not g.unitTesting: g.es("reading:", p.h)
        ok = at.importAtShadowNode(fn, p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p)
</t>
<t tx="ekr.20080712080505.1">def importAtShadowNode(self, fn, p):
    at = self; c = at.c; ic = c.importCommands
    oldChanged = c.isChanged()
    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()
    # Import the outline, exactly as @auto does.
    ic.createOutline(fn, parent=p.copy(), atShadow=True)
    if ic.errors:
        g.error('errors inhibited read @shadow', fn)
    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)
    # else: g.doHook('after-shadow', p = p)
    return ic.errors == 0
</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20080801071227.7">def readAtShadowNodes(self, p):
    '''Read all @shadow nodes in the p's tree.'''
    at = self
    after = p.nodeAfterTree()
    p = p.copy() # Don't change p in the caller.
    while p and p != after: # Don't use iterator.
        if p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode(fileName, p)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20080805085257.2">def pickle(self, torv, val, tag):
    '''Pickle val and return the hexlified result.'''
    try:
        s = pickle.dumps(val, protocol=1)
        s2 = binascii.hexlify(s)
        s3 = g.ue(s2, 'utf-8')
        field = ' %s="%s"' % (tag, s3)
        return field
    except pickle.PicklingError:
        if tag: # The caller will print the error if tag is None.
            g.warning("ignoring non-pickleable value", val, "in", torv)
        return ''
    except Exception:
        g.error("fc.pickle: unexpected exception in", torv)
        g.es_exception()
        return ''
</t>
<t tx="ekr.20080816125725.2"># The syntax of these functions must be valid on Python2K and Python3K.
</t>
<t tx="ekr.20080819075811.13">def adjustTargetLanguage(self, fn):
    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""
    at = self
    c = at.c
    junk, ext = g.os_path_splitext(fn)
    if ext:
        if ext.startswith('.'): ext = ext[1:]
        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            # Use the default language, **not** 'unknown_language'
            pass
</t>
<t tx="ekr.20080822065427.4">def show_error_lines(self, lines, fileName):
    for i, line in enumerate(lines):
        g.es_print('%3s %s' % (i, repr(line)))
    if False: # Only for major debugging.
        try:
            f1 = open(fileName, "w")
            for s in lines:
                if not g.isPython3: # 2010/08/27
                    s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
                f1.write(repr(s))
            f1.close()
        except IOError:
            g.es_exception()
            g.es_print('can not open', fileName)
</t>
<t tx="ekr.20080919065433.1">def toUnicodeWithErrorCode(s, encoding, reportErrors=False):
    '''For unit testing: convert s to unicode and return (s,ok).'''
    ok = True
    # pylint: disable=undefined-variable, no-member
    # unicode does not exist in Python 3.
    # f = str if g.isPython3 else unicode
    f = builtins.str if g.isPython3 else builtins.unicode
        # Suppress pyflakes complaint.
    if s is None:
        s = g.u('')
    if not g.isUnicode(s):
        try:
            s = f(s, encoding, 'strict')
        except UnicodeError:
            s = f(s, encoding, 'replace')
            if reportErrors:
                g.error("Error converting %s from %s encoding to unicode" % (s, encoding))
            ok = False
    return s, ok
</t>
<t tx="ekr.20080923070954.13">if forcePythonSentinels:
    # Force Python language.
    delim1, delim2, delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1, delim2, delim3 = delims
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    #
    # Issue an error only if at.language has been set.
    # This suppresses a message from the markdown importer.
    if not g.app.unitTesting and at.language:
        g.trace(repr(at.language), g.callers())
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:", c.target_language)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""
</t>
<t tx="ekr.20080923070954.14">at.page_width = c.page_width
at.tab_width = c.tab_width
at.default_directory = None # 8/2: will be set later.
if c.target_language:
    c.target_language = c.target_language.lower()
delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language
at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=c) # Init from config settings.
</t>
<t tx="ekr.20080923070954.4">def scanAllDirectives(self,
    p,
    forcePythonSentinels=False,
    importing=False,
    issuePathWarning=False,
    reading=False,
):
    '''
    Scan p and p's ancestors looking for directives,
    setting corresponding AtFile ivars.
    '''
    at, c = self, self.c
    g.app.atPathInBodyWarning = None
    &lt;&lt; set ivars &gt;&gt;
    lang_dict = {'language': at.language, 'delims': delims,}
    table = (
        ('encoding', at.encoding, g.scanAtEncodingDirectives),
        # ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lang-dict', None, g.scanAtCommentAndAtLanguageDirectives),
        ('lineending', None, g.scanAtLineendingDirectives),
        ('pagewidth', c.page_width, g.scanAtPagewidthDirectives),
        ('path', None, c.scanAtPathDirectives),
        ('tabwidth', c.tab_width, g.scanAtTabwidthDirectives),
    )
    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key, default, func in table:
        val = func(aList)
        d[key] = default if val is None else val
    # Post process.
    lineending = d.get('lineending')
    lang_dict = d.get('lang-dict')
    if lang_dict:
        delims = lang_dict.get('delims')
        at.language = lang_dict.get('language')
    else:
        # No language directive.  Look for @&lt;file&gt; nodes.
        language = g.getLanguageFromAncestorAtFileNode(p) or 'python'
        delims = g.set_delims_from_language(language)
    at.encoding = d.get('encoding')
    at.explicitLineEnding = bool(lineending)
    at.output_newline = lineending or g.getOutputNewline(c=c)
    at.page_width = d.get('pagewidth')
    at.default_directory = d.get('path')
    at.tab_width = d.get('tabwidth')
    if not importing and not reading:
        # Don't override comment delims when reading!
        &lt;&lt; set comment strings from delims &gt;&gt;
    # For unit testing.
    d = {
        "all": all,
        "encoding": at.encoding,
        "language": at.language,
        "lineending": at.output_newline,
        "pagewidth": at.page_width,
        "path": at.default_directory,
        "tabwidth": at.tab_width,
    }
    return d
</t>
<t tx="ekr.20081119083601.1">if g.isPython3:

    def toUnicode(self, s):
        # pylint: disable=no-member
        return str(s)
            
else:
    
    def toUnicode(self, s):
        # pylint: disable=no-member
        return builtins.unicode(s)
</t>
<t tx="ekr.20081216090156.4"># Important: this is part of the *write* logic.
# It is called from at.os and at.putIndent.

def parseUnderindentTag(self, s):
    tag = self.underindentEscapeString
    s2 = s[len(tag):]
    # To be valid, the escape must be followed by at least one digit.
    i = 0
    while i &lt; len(s2) and s2[i].isdigit():
        i += 1
    if i &gt; 0:
        n = int(s2[: i])
        # Bug fix: 2012/06/05: remove any period following the count.
        # This is a new convention.
        if i &lt; len(s2) and s2[i] == '.':
            i += 1
        return n, s2[i:]
    else:
        return 0, s
</t>
<t tx="ekr.20090225080846.3">def readOneAtEditNode(self, fn, p):
    at = self
    c = at.c
    ic = c.importCommands
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    fn = c.os_path_finalize_join(at.default_directory, fn)
    junk, ext = g.os_path_splitext(fn)
    # Fix bug 889175: Remember the full fileName.
    at.rememberReadPath(fn, p)
    ### if not g.unitTesting: g.es("reading: @edit %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    changed = c.isChanged()
    head = ''
    ext = ext.lower()
    if ext in ('.html', '.htm'): head = '@language html\n'
    elif ext in ('.txt', '.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = '@language %s\n' % language
        else:
            head = '@nocolor\n'
    p.b = g.u(head) + g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not changed: c.setChanged(False)
    g.doHook('after-edit', p=p)
</t>
<t tx="ekr.20090225080846.5">def writeOneAtEditNode(self, p): 
    '''Write one @edit node.'''
    at, c = self, self.c
    root = p.copy()
    try:
        c.endEditing()
        c.init_error_dialogs()
        if not p.atEditNodeName():
            return False
        if p.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(root, p.atEditNodeName(),
            atEdit=True,
            defaultDirectory = g.setDefaultDirectory(c, p, importing=True),
            sentinels=False,
        )
        if not at.precheck(fileName, root):
            at.addToOrphanList(root)
            return False
        contents = ''.join([s for s in g.splitLines(p.b)
            if at.directiveKind4(s, 0) == at.noDirective])
        at.replaceFile(contents, at.encoding, fileName, root)
        c.raise_error_dialogs(kind='write')
        return True
    except Exception:
        at.writeException(fileName, root)
        return False
</t>
<t tx="ekr.20090306060344.2">def selectChapterByNameHelper(self, chapter, collapse=True):
    '''Select the chapter, and redraw if necessary.'''
    cc, c = self, self.c
    if not cc.selectedChapter and chapter.name == 'main':
        chapter.p = c.p
        return
    if chapter == cc.selectedChapter:
        chapter.p = c.p
        return
    if cc.selectedChapter:
        cc.selectedChapter.unselect()
    else:
        main_chapter = cc.getChapter('main')
        if main_chapter:
            main_chapter.unselect()
    if chapter.p and c.positionExists(chapter.p):
        p = chapter.p
    elif chapter.name == 'main':
        p = chapter.p # Do *not* use c.p here!
    else:
        p = chapter.p = chapter.findRootNode()
        if not p:
            return
    chapter.select()
    c.setCurrentPosition(chapter.p)
    # Clean up, but not initially.
    if collapse and chapter.name == 'main':
        for p in c.all_positions():
            # Compare vnodes, not positions.
            if p.v != c.p.v:
                p.contract()
    c.redraw(chapter.p)
        # Fix part of #265.
        # Redraw only here, when we are sure it is needed.
</t>
<t tx="ekr.20090502071837.65">def writeToDocutils(self, p, s, ext):
    '''Send s to docutils using the writer implied by ext and return the result.'''
    if not docutils:
        g.error('writeToDocutils: docutils not present')
        return None
    openDirectory = self.c.frame.openDirectory
    overrides = {'output_encoding': self.encoding}
    # Compute the args list if the stylesheet path does not exist.
    styleSheetArgsDict = self.handleMissingStyleSheetArgs(p)
    if ext == '.pdf':
        module = g.importFromPath(
            moduleName='leo_pdf',
            path=g.os_path_finalize_join(g.app.loadDir, '..', 'plugins'),
            verbose=False)
        if not module:
            return None
        writer = module.Writer() # Get an instance.
        writer_name = None
    else:
        writer = None
        for ext2, writer_name in (
            ('.html', 'html'),
            ('.htm', 'html'),
            ('.tex', 'latex'),
            ('.pdf', 'leo.plugins.leo_pdf'), # 2011/11/03
            ('.s5', 's5'), # 2011/03/27
            ('.odt', 'odt'), # 2011/03/27
        ):
            if ext2 == ext: break
        else:
            g.error('unknown docutils extension: %s' % (ext))
            return None
    # SilverCity seems not to be supported, so this warning is strange.
    if False and ext in ('.html', '.htm') and not SilverCity:
        if not self.silverCityWarningGiven:
            self.silverCityWarningGiven = True
            if not g.unitTesting:
                g.es('SilverCity not present so no syntax highlighting')
    # Make the stylesheet path relative to the directory containing the output file.
    rel_stylesheet_path = self.getOption(p, 'stylesheet_path') or ''
    # New in Leo 4.5: The rel_stylesheet_path is relative to the open directory.
    stylesheet_path = g.os_path_finalize_join(
        openDirectory, rel_stylesheet_path)
    stylesheet_name = self.getOption(p, 'stylesheet_name')
    assert stylesheet_name
    path = g.os_path_finalize_join(stylesheet_path, stylesheet_name)
    if self.getOption(p, 'stylesheet_embed') is False:
        rel_path = g.os_path_join(
            rel_stylesheet_path, self.getOption(p, 'stylesheet_name'))
        rel_path = rel_path.replace('\\', '/') # 2010/01/28
        overrides['stylesheet'] = rel_path
        overrides['stylesheet_path'] = None
        overrides['embed_stylesheet'] = None
    elif g.os_path_exists(path):
        if ext != '.pdf':
            overrides['stylesheet'] = path
            overrides['stylesheet_path'] = None
    elif styleSheetArgsDict:
        g.es_print('using publish_argv_for_missing_stylesheets',
            styleSheetArgsDict)
        overrides.update(styleSheetArgsDict)
            # MWC add args to settings
    elif rel_stylesheet_path == stylesheet_path:
        g.error('stylesheet not found: %s' % (path))
    else:
        g.error('stylesheet not found\n', path)
        if self.path: g.es_print('@path:', self.path)
        g.es_print('open path:', openDirectory)
        if rel_stylesheet_path:
            g.es_print('relative path:', rel_stylesheet_path)
    try:
        # All paths now come through here.
        result = None # Ensure that result is defined.
        result = docutils.core.publish_string(source=s,
                reader_name='standalone',
                parser_name='restructuredtext',
                writer=writer,
                writer_name=writer_name,
                settings_overrides=overrides)
        if g.isBytes(result):
            result = g.toUnicode(result)
    except docutils.ApplicationError as error:
        # g.error('Docutils error (%s):' % (error.__class__.__name__))
        g.error('Docutils error:')
        g.blue(error)
    except Exception:
        g.es_print('Unexpected docutils exception')
        g.es_exception()
    return result
</t>
<t tx="ekr.20090502071837.66">def handleMissingStyleSheetArgs(self, p, s=None):
    '''
    Parse the publish_argv_for_missing_stylesheets option,
    returning a dict containing the parsed args.
    '''
    force = False
    if force:
        # See http://docutils.sourceforge.net/docs/user/config.html#documentclass
        return {'documentclass': 'report', 'documentoptions': 'english,12pt,lettersize'}
    if not s:
        s = self.getOption(p, 'publish_argv_for_missing_stylesheets')
    if not s:
        return {}
    # Handle argument lists such as this:
    # --language=en,--documentclass=report,--documentoptions=[english,12pt,lettersize]
    d = {}
    while s:
        s = s.strip()
        if not s.startswith('--'): break
        s = s[2:].strip()
        eq = s.find('=')
        cm = s.find(',')
        if eq == -1 or (-1 &lt; cm &lt; eq): # key[nl] or key,
            val = ''
            cm = s.find(',')
            if cm == -1:
                key = s.strip()
                s = ''
            else:
                key = s[: cm].strip()
                s = s[cm + 1:].strip()
        else: # key = val
            key = s[: eq].strip()
            s = s[eq + 1:].strip()
            if s.startswith('['): # [...]
                rb = s.find(']')
                if rb == -1: break # Bad argument.
                val = s[: rb + 1]
                s = s[rb + 1:].strip()
                if s.startswith(','):
                    s = s[1:].strip()
            else: # val[nl] or val,
                cm = s.find(',')
                if cm == -1:
                    val = s
                    s = ''
                else:
                    val = s[: cm].strip()
                    s = s[cm + 1:].strip()
        if not key:
            break
        if not val.strip(): val = '1'
        d[str(key)] = str(val)
    return d
</t>
<t tx="ekr.20090502071837.94">def write(self, s, theFile=None):
    '''Write s to the given file, or self.outputFile.'''
    if theFile is None:
        theFile = self.outputFile
    if g.isPython3:
        if g.is_binary_file(theFile):
            s = self.encode(s)
    else:
        s = self.encode(s)
    theFile.write(s)
</t>
<t tx="ekr.20090514111518.5661">def checkPythonCode(self, contents, fileName, root, pyflakes_errors_only=False): 
    '''Perform python-related checks on root.'''
    at = self
    if contents and fileName and fileName.endswith('.py') and at.checkPythonCodeOnWrite:
        # It's too slow to check each node separately.
        if pyflakes_errors_only:
            ok = True
        else:
            ok = at.checkPythonSyntax(root, contents)
        # Syntax checking catches most indentation problems.
            # if ok: at.tabNannyNode(root,s)
        if ok and at.runPyFlakesOnWrite and not g.unitTesting:
            ok2 = self.runPyflakes(root, pyflakes_errors_only=pyflakes_errors_only)
        else:
            ok2 = True
        if not ok or not ok2:
            g.app.syntax_error_files.append(g.shortFileName(fileName))
</t>
<t tx="ekr.20090514111518.5663">def checkPythonSyntax(self, p, body, supress=False):
    at = self
    try:
        ok = True
        if not g.isPython3:
            body = g.toEncodedString(body)
        body = body.replace('\r', '')
        fn = '&lt;node: %s&gt;' % p.h
        compile(body + '\n', fn, 'exec')
    except SyntaxError:
        if not supress:
            at.syntaxError(p, body)
        ok = False
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        ok = False
    return ok
</t>
<t tx="ekr.20090514111518.5665">def tabNannyNode(self, p, body, suppress=False):
    import parser
    import tabnanny
    import tokenize
    try:
        readline = g.ReadLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
    except parser.ParserError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        else:
            g.error("ParserError in", p.h)
            g.es('', str(msg))
    except IndentationError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        else:
            g.error("IndentationError in", p.h)
            g.es('', str(msg))
    except tokenize.TokenError:
        junk, msg, junk = sys.exc_info()
        if suppress:
            raise
        else:
            g.error("TokenError in", p.h)
            g.es('', str(msg))
    except tabnanny.NannyNag:
        junk, nag, junk = sys.exc_info()
        if suppress:
            raise
        else:
            badline = nag.get_lineno()
            line = nag.get_line()
            message = nag.get_msg()
            g.error("indentation error in", p.h, "line", badline)
            g.es(message)
            line2 = repr(str(line))[1: -1]
            g.es("offending line:\n", line2)
    except Exception:
        g.trace("unexpected exception")
        g.es_exception()
        if suppress: raise
</t>
<t tx="ekr.20090514111518.5666">def syntaxError(self, p, body):
    '''Report a syntax error.'''
    g.error("Syntax error in: %s" % (p.h))
    typ, val, tb = sys.exc_info()
    message = hasattr(val, 'message') and val.message
    if message: g.es_print(message)
    if val is None: return
    lines = g.splitLines(body)
    n = val.lineno
    offset = val.offset or 0
    if n is None: return
    i = val.lineno - 1
    for j in range(max(0, i - 2), min(i + 2, len(lines) - 1)):
        if j == i:
            mark = '*'
            node_link = "%s,-%d" % (
                p.get_UNL(with_proto=True, with_count=True), j+1)
        else:
            mark = ' '
            node_link = None
        text = '%5s:%s %s' % (j+1, mark, lines[j].rstrip())
        g.es_print(text, nodeLink=node_link)
        if j == i:
            g.es_print(' ' * (7 + offset) + '^')
</t>
<t tx="ekr.20090518072506.8494">def isFKey(self, stroke):
    # k = self
    if not stroke: return False
    assert g.isString(stroke) or g.isStroke(stroke)
    s = stroke.s if g.isStroke(stroke) else stroke
    s = s.lower()
    return s.startswith('f') and len(s) &lt;= 3 and s[1:].isdigit()
</t>
<t tx="ekr.20090530055015.6023">def getPathUa(self, p):
    if hasattr(p.v, 'tempAttributes'):
        d = p.v.tempAttributes.get('read-path', {})
        return d.get('path')
    else:
        return ''

def setPathUa(self, p, path):
    if not hasattr(p.v, 'tempAttributes'):
        p.v.tempAttributes = {}
    d = p.v.tempAttributes.get('read-path', {})
    d['path'] = path
    p.v.tempAttributes['read-path'] = d
</t>
<t tx="ekr.20090712050729.6017">def promptForDangerousWrite(self, fileName, kind, message=None):
    '''Raise a dialog asking the user whether to overwrite an existing file.'''
    at, c, root = self, self.c, self.root
    if g.app.unitTesting:
        val = g.app.unitTestDict.get('promptForDangerousWrite')
        return val in (None, True)
    if at.cancelFlag:
        assert at.canCancelFlag
        return False
    if at.yesToAll:
        assert at.canCancelFlag
        return True
    if root and root.h.startswith('@auto-rst'):
        # Fix bug 50: body text lost switching @file to @auto-rst
        # Refuse to convert any @&lt;file&gt; node to @auto-rst.
        d = root.v.at_read if hasattr(root.v, 'at_read') else {}
        aList = sorted(d.get(fileName, []))
        for h in aList:
            if not h.startswith('@auto-rst'):
                g.es('can not convert @file to @auto-rst!', color='red')
                g.es('reverting to:', h)
                root.h = h
                c.redraw()
                return False
    if message is None:
        message = '%s %s\n%s\n%s' % (
            kind, g.splitLongFileName(fileName),
            g.tr('already exists.'),
            g.tr('Overwrite this file?'))
    result = g.app.gui.runAskYesNoCancelDialog(c,
        title='Overwrite existing file?',
        yesToAllMessage="Yes To &amp;All",
        message=message,
        cancelMessage="&amp;Cancel (No To All)",
    )
    if at.canCancelFlag:
        # We are in the writeAll logic so these flags can be set.
        if result == 'cancel':
            at.cancelFlag = True
        elif result == 'yes-to-all':
            at.yesToAll = True
    return result in ('yes', 'yes-to-all')
</t>
<t tx="ekr.20090717112235.6007">def computeSignon(self):
    import leo.core.leoVersion as leoVersion
    app = self
    build, date = leoVersion.build, leoVersion.date
    guiVersion = ', ' + app.gui.getFullVersion() if app.gui else ''
    leoVer = leoVersion.version
    n1, n2, n3, junk, junk = sys.version_info
    if sys.platform.startswith('win'):
        sysVersion = 'Windows '
        try:
            # peckj 20140416: determine true OS architecture
            # the following code should return the proper architecture
            # regardless of whether or not the python architecture matches
            # the OS architecture (i.e. python 32-bit on windows 64-bit will return 64-bit)
            v = platform.win32_ver()
            release, winbuild, sp, ptype = v
            true_platform = os.environ['PROCESSOR_ARCHITECTURE']
            try:
                true_platform = os.environ['PROCESSOR_ARCHITEw6432']
            except KeyError:
                pass
            sysVersion = 'Windows %s %s (build %s) %s' % (
                release, true_platform, winbuild, sp)
        except Exception:
            pass
    else: sysVersion = sys.platform
    branch, commit = g.gitInfo()
    if not commit:
        app.signon1 = 'Not running from a git repo'
    else:
        app.signon1 = 'Git repo info: branch = %s, commit = %s' % (
            branch or '(none)', commit)
    app.signon = 'Leo %s' % leoVer
    if build:
        app.signon += ', build '+build
    if date:
        app.signon += ', '+date
    app.signon2 = 'Python %s.%s.%s%s\n%s' % (
        n1, n2, n3, guiVersion, sysVersion)
        
def printSignon(self, verbose=False):
    '''Print a minimal sigon to the log.'''
    app = self
    if app.silentMode:
        return
    if sys.stdout.encoding and sys.stdout.encoding.lower() != 'utf-8':
        print('Note: sys.stdout.encoding is not UTF-8')
        print('Encoding is: %r' % sys.stdout.encoding)
        print('See: https://stackoverflow.com/questions/14109024')
        print('')
    print(app.signon)
    if verbose:
        print(app.signon1)
        print(app.signon2)
        print('** isPython3: %s' % g.isPython3)
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20091206161352.6232">if isPython3: # g.not defined yet.

    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        return s

    def ue(s, encoding):
        return s if g.isUnicode(s) else str(s, encoding)

else:

    def u(s):
        '''Return s, converted to unicode from Qt widgets.'''
        # Use builtins to suppress pyflakes complaint.
        # pylint: disable=no-member, undefined-variable
        return builtins.unicode(s) # Suppress pyflakes complaint.

    def ue(s, encoding):
        # Use builtins to suppress pyflakes complaint.
        # pylint: disable=no-member, undefined-variable
        return builtins.unicode(s, encoding)
</t>
<t tx="ekr.20091211111443.6266">def checkBatchOperationsList(self, aList):
    ok = True; d = {}
    for z in aList:
        try:
            op, p, n = z
            ok = (op in ('insert', 'delete') and
                isinstance(p, leoNodes.position) and g.isInt(n))
            if ok:
                aList2 = d.get(p.v, [])
                data = n, op
                aList2.append(data)
                d[p.v] = aList2
        except ValueError:
            ok = False
        if not ok: break
    return ok, d
</t>
<t tx="ekr.20091221145433.6381">def setUndoType(self, theType):

    u = self; frame = u.c.frame
    if not g.isString(theType):
        g.trace('oops: expected string for command, got %s' % repr(theType))
        g.trace(g.callers())
        theType = '&lt;unknown&gt;'
    menu = frame.menu.getMenu("Edit")
    name = u.undoMenuName(theType)
    if name != u.undoMenuLabel:
        # Update menu using old name.
        realLabel = frame.menu.getRealMenuName(name)
        if realLabel == name:
            underline = -1 if g.match(name, 0, "Can't") else 0
        else:
            underline = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;", "")
        frame.menu.setMenuLabel(menu, u.realUndoMenuLabel, realLabel, underline=underline)
        u.undoType = theType
        u.undoMenuLabel = name
        u.realUndoMenuLabel = realLabel
</t>
<t tx="ekr.20091224155043.6539"># Required so the unit test that simulates an @auto leoImport.py will work!
import leo.core.leoGlobals as g
import leo.core.leoNodes as leoNodes
import csv
try:
    import docutils
    import docutils.core
    # print('leoImport.py:',docutils)
except ImportError:
    docutils = None
    # print('leoImport.py: can not import docutils')
# import glob
# import importlib
import json
try:
    import lxml.html
except ImportError:
    lxml = None
import os
import re
if g.isPython3:
    import io
    StringIO = io.StringIO
else:
    import StringIO
    StringIO = StringIO.StringIO
import time
import urllib
</t>
<t tx="ekr.20100119145629.6106">def createActualFile(self, fileName, toOPML, toZip):
    if toZip:
        self.toString = True
        theActualFile = None
    else:
        try:
            # 2010/01/21: always write in binary mode.
            theActualFile = open(fileName, 'wb')
        except IOError:
            g.es('can not open %s' % fileName)
            g.es_exception()
            theActualFile = None
    return fileName, theActualFile
</t>
<t tx="ekr.20100119145629.6108">def handleWriteLeoFileException(self, fileName, backupName, theActualFile):
    c = self.c
    g.es("exception writing:", fileName)
    g.es_exception(full=True)
    if theActualFile:
        theActualFile.close()
    # Delete fileName.
    if fileName and g.os_path_exists(fileName):
        self.deleteFileWithMessage(fileName, '')
    # Rename backupName to fileName.
    if backupName and g.os_path_exists(backupName):
        g.es("restoring", fileName, "from", backupName)
        # No need to create directories when restoring.
        g.utils_rename(c, backupName, fileName)
    else:
        g.error('backup file does not exist!', repr(backupName))
</t>
<t tx="ekr.20100119145629.6111">def writeToFileHelper(self, fileName, toOPML):
    c = self.c; toZip = c.isZipped
    ok, backupName = self.createBackupFile(fileName)
    if not ok: return False
    fileName, theActualFile = self.createActualFile(fileName, toOPML, toZip)
    if not theActualFile: return False
    self.mFileName = fileName
    self.outputFile = StringIO() # Always write to a string.
    try:
        if toOPML:
            if hasattr(c, 'opmlController'):
                c.opmlController.putToOPML(owner=self)
            else:
                # This is not likely ever to be called.
                g.trace('leoOPML plugin not active.')
        else:
            self.putLeoFile()
        s = self.outputFile.getvalue()
        g.app.write_Leo_file_string = s # 2010/01/19: always set this.
        if toZip:
            self.writeZipFile(s)
        else:
            if g.isPython3:
                s = bytes(s, self.leo_file_encoding, 'replace')
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            # raise AttributeError # To test handleWriteLeoFileException.
            # Delete backup file.
            if backupName and g.os_path_exists(backupName):
                self.deleteFileWithMessage(backupName, 'backup')
        return True
    except Exception:
        self.handleWriteLeoFileException(
            fileName, backupName, theActualFile)
        return False
</t>
<t tx="ekr.20100122130101.6174">def deleteTnodeList(self, p): # AtFile method.
    '''Remove p's tnodeList.'''
    v = p.v
    if hasattr(v, "tnodeList"):
        if False: # Not an error, but a useful trace.
            g.blue("deleting tnodeList for " + repr(v))
        delattr(v, "tnodeList")
        v._p_changed = True
</t>
<t tx="ekr.20100125073206.8710">def readFileIntoString(fileName,
    encoding='utf-8', # BOM may override this.
    kind=None, # @file, @edit, ...
    verbose=True,
):
    '''Return the contents of the file whose full path is fileName.

    Return (s,e)
    s is the string, converted to unicode, or None if there was an error.
    e is the encoding of s, computed in the following order:
    - The BOM encoding if the file starts with a BOM mark.
    - The encoding given in the # -*- coding: utf-8 -*- line for python files.
    - The encoding given by the 'encoding' keyword arg.
    - None, which typically means 'utf-8'.
    '''
    if not fileName:
        if verbose: g.trace('no fileName arg given')
        return None, None
    if g.os_path_isdir(fileName):
        if verbose: g.trace('not a file:', fileName)
        return None, None
    if not g.os_path_exists(fileName):
        if verbose: g.error('file not found:', fileName)
        return None, None
    try:
        e = None
        with open(fileName, 'rb') as f:
            s = f.read()
        # Fix #391.
        if not s:
            return g.u(''), None
        # New in Leo 4.11: check for unicode BOM first.
        e, s = g.stripBOM(s)
        if not e:
            # Python's encoding comments override everything else.
            junk, ext = g.os_path_splitext(fileName)
            if ext == '.py':
                e = g.getPythonEncodingFromString(s)
        s = g.toUnicode(s, encoding=e or encoding)
        return s, e
    except IOError:
        # Translate 'can not open' and kind, but not fileName.
        if verbose:
           g.error('can not open', '', (kind or ''), fileName)
    except Exception:
        g.error('readFileIntoString: unexpected exception reading %s' % (fileName))
        g.es_exception()
    return None, None
</t>
<t tx="ekr.20100208223942.10436">import sys
isPython3 = sys.version_info &gt;= (3, 0, 0)
import leo.core.leoGlobals as g
if isPython3:
    import pickle
else:
    import cPickle as pickle
# import glob
import fnmatch
# import hashlib
import os
import stat
# import time
import zlib
import sqlite3
# try:
    # import marshal
# except ImportError:
    # marshal = None
</t>
<t tx="ekr.20100216141722.5626">def find_gnx(self, root, gnx, vnodeName):
    '''
    Scan root's tree for a node with the given gnx and vnodeName.
    return (p,found)
    '''
    if gnx:
        assert g.isString(gnx)
        gnx = g.toUnicode(gnx)
        for p in root.self_and_subtree(copy=False):
            if p.matchHeadline(vnodeName):
                if p.v.fileIndex == gnx:
                    return p.copy(), True
        return None, False
    else:
        return root, False
</t>
<t tx="ekr.20100224050618.11547">def isFileLike(self, s):
    '''Return True if s has file-like sentinels.'''
    at = self; tag = "@+leo"
    s = g.toUnicode(s)
    i = s.find(tag)
    if i == -1:
        return True # Don't use the cache.
    else:
        j, k = g.getLine(s, i)
        line = s[j: k]
        valid, new_df, start, end, isThin = at.parseLeoSentinel(line)
        return not isThin
</t>
<t tx="ekr.20100329071036.5744">def is_binary_file(f):
    if g.isPython3:
        return f and isinstance(f, io.BufferedIOBase)
    else:
        g.internalError('g.is_binary_file called from Python 2.x code')

def is_binary_external_file(fileName):
    try:
        with open(fileName, 'rb') as f:
            s = f.read(1024) # bytes, in Python 3.
        return g.is_binary_string(s)
    except IOError:
        return False
    except Exception:
        g.es_exception()
        return False

def is_binary_string(s):
    # http://stackoverflow.com/questions/898669
    # aList is a list of all non-binary characters.
    aList = [7, 8, 9, 10, 12, 13, 27] + list(range(0x20, 0x100))
    if g.isPython3:
        aList = bytes(aList)
    else:
        aList = ''.join([chr(z) for z in aList])
    return bool(s.translate(None, aList))
</t>
<t tx="ekr.20100803073751.5817">def createResurrectedNodesNode(self):
    '''Create a 'Resurrected Nodes' node as the last top-level node.'''
    at = self; c = at.c; tag = 'Resurrected Nodes'
    # Find the last top-level node.
    last = c.rootPosition()
    while last.hasNext():
        last.moveToNext()
    # Create the node after last if it doesn't exist.
    if last.h == tag:
        p = last
    else:
        p = last.insertAfter()
        p.setHeadString(tag)
    p.expand()
    return p
</t>
<t tx="ekr.20100803073751.5818">def defineResurrectedNodeCallback(self, r, root):
    '''Define a callback that moves node p as r's last child.'''

    def callback(p, r=r.copy(), root=root):
        '''The resurrected nodes callback.'''
        child = r.insertAsLastChild()
        child.h = 'From %s' % root.h
        v = p.v
        if 1: # new code: based on vnodes.
            import leo.core.leoNodes as leoNodes
            for parent_v in v.parents:
                assert isinstance(parent_v, leoNodes.VNode), parent_v
                if v in parent_v.children:
                    childIndex = parent_v.children.index(v)
                    v._cutLink(childIndex, parent_v)
                    v._addLink(len(child.v.children), child.v)
                else:
                    # This would be surprising.
                    g.trace('**already deleted**', parent_v, v)
        else: # old code, based on positions.
            p.moveToLastChildOf(child)
        if not g.unitTesting:
            g.error('resurrected node:', v.h)
            g.blue('in file:', root.h)

    return callback
</t>
<t tx="ekr.20100813041139.5912">def createIntermediateFile(self, fn, p, s):
    '''Write s to to the file whose name is fn.'''
    ext = self.getOption(p, 'write_intermediate_extension')
    ext = ext or '.txt' # .txt by default.
    if not ext.startswith('.'): ext = '.' + ext
    fn = fn + ext
    if g.isPython3:
        f = open(fn, 'w', encoding=self.encoding)
    else:
        f = open(fn, 'w')
        # Huh?  Shouldn't this always be done???
        s = g.toEncodedString(s, encoding=self.encoding, reportErrors=True)
    f.write(s)
    f.close()
    self.report(fn, p)
</t>
<t tx="ekr.20100813041139.5913">def addTitleToHtml(self, s):
    '''Replace an empty &lt;title&gt; element by the contents of
    the first &lt;h1&gt; element.'''
    i = s.find('&lt;title&gt;&lt;/title&gt;')
    if i == -1: return s
    m = re.search('&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;', s)
    if not m:
        m = re.search('&lt;h1&gt;&lt;[^&gt;]+&gt;([^&lt;]*)&lt;/a&gt;&lt;/h1&gt;', s)
    if m:
        s = s.replace('&lt;title&gt;&lt;/title&gt;',
            '&lt;title&gt;%s&lt;/title&gt;' % m.group(1))
    return s
</t>
<t tx="ekr.20100813041139.5914">def createDirectoryForFile(self, fn):
    '''Create the directory for fn if
    a) it doesn't exist and
    b) the user options allow it.

    Return True if the directory existed or was made.'''
    c = self.c
    # Create the directory if it doesn't exist.
    theDir, junk = g.os_path_split(fn)
    theDir = c.os_path_finalize(theDir)
    if g.os_path_exists(theDir):
        return True
    else:
        ok = g.makeAllNonExistentDirectories(theDir, c=c, force=False)
        if not ok:
            g.error('did not create:', theDir)
        return ok
</t>
<t tx="ekr.20100813041139.5919">def write_files(self, ext, fn, p, callDocutils, toString, writeIntermediateFile):
    '''Write a file to the indicated locations.'''
    isHtml = ext in ('.html', '.htm')
    fn = self.computeOutputFileName(fn)
    if not toString:
        if not self.createDirectoryForFile(fn):
            return
    if writeIntermediateFile:
        if not toString:
            self.createIntermediateFile(fn, p, self.source)
    if callDocutils and ext in ('.htm', '.html', '.tex', '.pdf', '.s5', '.odt'):
        self.stringOutput = s = self.writeToDocutils(p, self.source, ext)
        if s and isHtml:
            self.stringOutput = s = self.addTitleToHtml(s)
        if not s:
            return
        if toString:
            if not g.isUnicode(s):
                s = g.toUnicode(s, 'utf-8')
        else:
            # Fixes bug 923301: Unicode error when executing 'rst3' command
            if g.isPython3:
                s = g.toEncodedString(s, 'utf-8')
            f = open(fn, 'wb') # Bug fix: use 'wb'
            f.write(s)
            f.close()
            self.report(fn, p)
            # self.http_endTree(fn,p,justOneFile=justOneFile)
</t>
<t tx="ekr.20100908120927.5971">import leo.core.leoGlobals as g
verbose = 'plugins' in g.app.debug
try:
    import docutils
    import docutils.core
except ImportError:
    docutils = None
if verbose:
    print('leoRst3.py: docutils: %s' % docutils)
if docutils:
    try:
        from docutils import parsers
        if verbose or not parsers: print('leoRst.py', parsers)
        from docutils.parsers import rst
        if verbose or not rst: print('leoRst.py', rst)
        if not parsers or not rst:
            docutils = None
    except ImportError:
        docutils = None
    except Exception:
        g.es_exception()
        docutils = None
if g.isPython3:
    # pylint: disable=no-name-in-module
    import html.parser as HTMLParser
else:
    import HTMLParser
try:
    import leo.plugins.mod_http as mod_http
except ImportError:
    mod_http = None
except Exception:
    # Don't let a problem with a plugin crash Leo's core!
    # g.es_print('leoRst: can not import leo.plugins.mod_http')
    # g.es_exception()
    mod_http = None
# import os
import pprint
import re
try:
    import SilverCity
except ImportError:
    SilverCity = None
if g.isPython3:
    import io
    StringIO = io.StringIO
else:
    import StringIO
    StringIO = StringIO.StringIO
# import sys
# import tempfile
import time
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.
</t>
<t tx="ekr.20110605121601.17912"># Tricky code: do not change without careful thought and testing.

def onHeadChanged(self, p, undoType='Typing', s=None, e=None):
    '''Officially change a headline.'''
    c = self.c; u = c.undoer
    if not p:
        return
    item = self.getCurrentItem()
    if not item:
        return
    if not e:
        e = self.getTreeEditorForItem(item)
    if not e:
        return
    s = g.u(e.text())
    self.closeEditorHelper(e, item)
    oldHead = p.h
    changed = s != oldHead
    if g.doHook("headkey1", c=c, p=c.p, v=c.p, s=s, changed=changed):
        return
    if changed:
        # New in Leo 4.10.1.
        &lt;&lt; truncate s if it has multiple lines &gt;&gt;
        p.initHeadString(s)
        item.setText(0, s) # Required to avoid full redraw.
        undoData = u.beforeChangeNodeContents(p, oldHead=oldHead)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.body.recolor(p)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p, undoType, undoData,
            dirtyVnodeList=dirtyVnodeList, inHead=True) # 2013/08/26.
    g.doHook("headkey2", c=c, p=c.p, v=c.p, s=s, changed=changed)
    # This is a crucial shortcut.
    if g.unitTesting: return
    if changed:
        self.redraw_after_head_changed()
    if 0: # Don't do this: it interferes with clicks, and is not needed.
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    p.v.contentModified()
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.18005">if QtWidgets:

    class LeoQTextBrowser(QtWidgets.QTextBrowser):
        '''A subclass of QTextBrowser that overrides the mouse event handlers.'''
        @others
</t>
<t tx="ekr.20110605121601.18006">def __init__(self, parent, c, wrapper):
    '''ctor for LeoQTextBrowser class.'''
    for attr in ('leo_c', 'leo_wrapper',):
        assert not hasattr(QtWidgets.QTextBrowser, attr), attr
    self.leo_c = c
    self.leo_s = '' # The cached text.
    self.leo_wrapper = wrapper
    self.htmlFlag = True
    QtWidgets.QTextBrowser.__init__(self, parent)
    self.setCursorWidth(c.config.getInt('qt-cursor-width') or 1)
    # Connect event handlers...
    if 0: # Not a good idea: it will complicate delayed loading of body text.
        self.textChanged.connect(self.onTextChanged)
    # This event handler is the easy way to keep track of the vertical scroll position.
    self.leo_vsb = vsb = self.verticalScrollBar()
    vsb.valueChanged.connect(self.onSliderChanged)
    # For QCompleter
    self.leo_q_completer = None
    self.leo_options = None
    self.leo_model = None
</t>
<t tx="ekr.20110605121601.18007">def __repr__(self):
    return '(LeoQTextBrowser) %s' % id(self)

__str__ = __repr__
</t>
<t tx="ekr.20110605121601.18008"></t>
<t tx="ekr.20110605121601.18009">class LeoQListWidget(QtWidgets.QListWidget):
    @others
</t>
<t tx="ekr.20110605121601.18010">def __init__(self, c):
    '''ctor for LeoQListWidget class'''
    QtWidgets.QListWidget.__init__(self)
    self.setWindowFlags(QtCore.Qt.Popup | self.windowFlags())
    # Make this window a modal window.
    # Calling this does not fix the Ubuntu-specific modal behavior.
    # self.setWindowModality(QtCore.Qt.NonModal) # WindowModal)
    # Inject the ivars
    self.leo_w = c.frame.body.wrapper.widget
        # A LeoQTextBrowser, a subclass of QtWidgets.QTextBrowser.
    self.leo_c = c
    # A weird hack.
    self.leo_geom_set = False # When true, self.geom returns global coords!
    self.itemClicked.connect(self.select_callback)
</t>
<t tx="ekr.20110605121601.18011">def closeEvent(self, event):
    '''Kill completion and close the window.'''
    self.leo_c.k.autoCompleter.abort()
</t>
<t tx="ekr.20110605121601.18012">def end_completer(self):
    '''End completion.'''
    c = self.leo_c
    c.in_qt_dialog = False
    # This is important: it clears the autocompletion state.
    c.k.keyboardQuit()
    c.bodyWantsFocusNow()
    try:
        self.deleteLater()
    except RuntimeError:
        # Avoid bug 1338773: Autocompleter error
        pass
</t>
<t tx="ekr.20110605121601.18013">def keyPressEvent(self, event):
    '''Handle a key event from QListWidget.'''
    c = self.leo_c
    w = c.frame.body.wrapper
    qt = QtCore.Qt
    key = event.key()
    if event.modifiers() != qt.NoModifier and not event.text():
        # A modifier key on it's own.
        pass
    elif key in (qt.Key_Up, qt.Key_Down):
        QtWidgets.QListWidget.keyPressEvent(self, event)
    elif key == qt.Key_Tab:
        self.tab_callback()
    elif key in (qt.Key_Enter, qt.Key_Return):
        self.select_callback()
    else:
        # Pass all other keys to the autocompleter via the event filter.
        w.ev_filter.eventFilter(obj=self, event=event)
</t>
<t tx="ekr.20110605121601.18014">def select_callback(self):
    '''Called when user selects an item in the QListWidget.'''
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper # 2014/09/19
    # Replace the tail of the prefix with the completion.
    completion = self.currentItem().text()
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &gt; 1:
        tail = parts[-1]
    else:
        tail = prefix
    if tail != completion:
        j = w.getInsertPoint()
        i = j - len(tail)
        w.delete(i, j)
        w.insert(i, completion)
        j = i + len(completion)
        c.setChanged(True)
        w.setInsertPoint(j)
        c.frame.body.onBodyChanged('Typing')
    self.end_completer()
</t>
<t tx="ekr.20110605121601.18015">def set_position(self, c):
    '''Set the position of the QListWidget.'''

    def glob(obj, pt):
        '''Convert pt from obj's local coordinates to global coordinates.'''
        return obj.mapToGlobal(pt)

    w = self.leo_w
    vp = self.viewport()
    r = w.cursorRect()
    geom = self.geometry() # In viewport coordinates.
    gr_topLeft = glob(w, r.topLeft())
    # As a workaround to the Qt setGeometry bug,
    # The window is destroyed instead of being hidden.
    if self.leo_geom_set:
        g.trace('Error: leo_geom_set')
        return
    # This code illustrates the Qt bug...
        # if self.leo_geom_set:
            # # Unbelievable: geom is now in *global* coords.
            # gg_topLeft = geom.topLeft()
        # else:
            # # Per documentation, geom in local (viewport) coords.
            # gg_topLeft = glob(vp,geom.topLeft())
    gg_topLeft = glob(vp, geom.topLeft())
    delta_x = gr_topLeft.x() - gg_topLeft.x()
    delta_y = gr_topLeft.y() - gg_topLeft.y()
    # These offset are reasonable. Perhaps they should depend on font size.
    x_offset, y_offset = 10, 60
    # Compute the new geometry, setting the size by hand.
    geom2_topLeft = QtCore.QPoint(
        geom.x() + delta_x + x_offset,
        geom.y() + delta_y + y_offset)
    geom2_size = QtCore.QSize(400, 100)
    geom2 = QtCore.QRect(geom2_topLeft, geom2_size)
    # These tests fail once offsets are added.
    if x_offset == 0 and y_offset == 0:
        if self.leo_geom_set:
            if geom2.topLeft() != glob(w, r.topLeft()):
                g.trace('Error: geom.topLeft: %s, geom2.topLeft: %s' % (
                    geom2.topLeft(), glob(w, r.topLeft())))
        else:
            if glob(vp, geom2.topLeft()) != glob(w, r.topLeft()):
                g.trace('Error 2: geom.topLeft: %s, geom2.topLeft: %s' % (
                    glob(vp, geom2.topLeft()), glob(w, r.topLeft())))
    self.setGeometry(geom2)
    self.leo_geom_set = True
</t>
<t tx="ekr.20110605121601.18016">def show_completions(self, aList):
    '''Set the QListView contents to aList.'''
    self.clear()
    self.addItems(aList)
    self.setCurrentRow(0)
    self.activateWindow()
    self.setFocus()
</t>
<t tx="ekr.20110605121601.18017">def init_completer(self, options):
    '''Connect a QCompleter.'''
    c = self.leo_c
    self.leo_qc = qc = self.LeoQListWidget(c)
    # Move the window near the body pane's cursor.
    qc.set_position(c)
    # Show the initial completions.
    c.in_qt_dialog = True
    qc.show()
    qc.activateWindow()
    c.widgetWantsFocusNow(qc)
    qc.show_completions(options)
    return qc
</t>
<t tx="ekr.20110605121601.18018">def end_completer(self):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.end_completer()
        delattr(self, 'leo_qc')

def show_completions(self, aList):
    if hasattr(self, 'leo_qc'):
        self.leo_qc.show_completions(aList)
</t>
<t tx="ekr.20110605121601.18019">def leo_dumpButton(self, event, tag):

    button = event.button()
    table = (
        (QtCore.Qt.NoButton, 'no button'),
        (QtCore.Qt.LeftButton, 'left-button'),
        (QtCore.Qt.RightButton, 'right-button'),
        (QtCore.Qt.MidButton, 'middle-button'),
    )
    for val, s in table:
        if button == val:
            kind = s; break
    else:
        kind = 'unknown: %s' % repr(button)
    return kind
</t>
<t tx="ekr.20110605121601.18081">def getAllText(self):
    '''QTextEditWrapper.'''
    w = self.widget
    s = g.u(w.toPlainText())
    return s
</t>
<t tx="ekr.20110605121601.18100">def toPythonIndex(self, index, s=None):
    '''This is much faster than versions using g.toPythonIndex.'''
    w = self
    te = self.widget
    if index is None:
        return 0
    elif g.isInt(index):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w.getLastPosition()
    else:
        doc = te.document()
        data = index.split('.')
        if len(data) == 2:
            row, col = data
            row, col = int(row), int(col)
            bl = doc.findBlockByNumber(row - 1)
            return bl.position() + col
        else:
            g.trace('bad string index: %s' % index)
            return 0
</t>
<t tx="ekr.20110605121601.18108">def getAllText(self):
    '''Get all text from a QsciScintilla widget.'''
    w = self.widget
    s = w.text()
    s = g.u(s)
    return s
</t>
<t tx="ekr.20110605121601.18113">def setAllText(self, s):
    '''Set the text of a QScintilla widget.'''
    w = self.widget
    assert isinstance(w, Qsci.QsciScintilla), w
    if g.isPython3:
        w.setText(s)
    else:
        w.setText(g.toEncodedString(s))
    # w.update()
</t>
<t tx="ekr.20110605121601.18120">def getAllText(self):
    '''QHeadlineWrapper.'''
    if self.check():
        w = self.widget
        s = w.text()
        return g.u(s)
    else:
        return ''
</t>
<t tx="ekr.20110605121601.18122">def getSelectionRange(self, sort=True):
    '''QHeadlineWrapper.'''
    w = self.widget
    if self.check():
        if w.hasSelectedText():
            i = w.selectionStart()
            s = w.selectedText()
            s = g.u(s)
            j = i + len(s)
        else:
            i = j = w.cursorPosition()
        return i, j
    else:
        return 0, 0
</t>
<t tx="ekr.20110605121601.18129">def setInsertPoint(self, i, s=None):
    '''QHeadlineWrapper.'''
    if not self.check(): return
    w = self.widget
    if s is None:
        s = w.text()
        s = g.u(s)
    i = self.toPythonIndex(i)
    i = max(0, min(i, len(s)))
    w.setCursorPosition(i)
</t>
<t tx="ekr.20110605121601.18130">def setSelectionRange(self, i, j, insert=None, s=None):
    '''QHeadlineWrapper.'''
    if not self.check(): return
    w = self.widget
    if i &gt; j: i, j = j, i
    if s is None:
        s = w.text()
        s = g.u(s)
    n = len(s)
    i = self.toPythonIndex(i)
    j = self.toPythonIndex(j)
    i = max(0, min(i, n))
    j = max(0, min(j, n))
    if insert is None:
        insert = j
    else:
        insert = self.toPythonIndex(insert)
        insert = max(0, min(insert, n))
    if i == j:
        w.setCursorPosition(i)
    else:
        length = j - i
        # Set selection is a QLineEditMethod
        if insert &lt; j:
            w.setSelection(j, -length)
        else:
            w.setSelection(i, length)
# setSelectionRangeHelper = setSelectionRange
</t>
<t tx="ekr.20110605121601.18137">class DynamicWindow(QtWidgets.QMainWindow):
    '''
    A class representing all parts of the main Qt window.

    **Important**: when using tabs, the LeoTabbedTopLevel widget
    is the top-level window, **not** this QMainWindow!

    c.frame.top is a DynamicWindow object.

    For --gui==qttabs:
        c.frame.top.parent is a TabbedFrameFactory
        c.frame.top.leo_master is a LeoTabbedTopLevel

    All leoQtX classes use the ivars of this Window class to
    support operations requested by Leo's core.
    '''
    @others
</t>
<t tx="ekr.20110605121601.18138">def __init__(self, c, parent=None):
    '''Ctor for the DynamicWindow class.  The main window is c.frame.top'''
        # Called from LeoQtFrame.finishCreate.
        # For qttabs gui, parent is a LeoTabbedTopLevel.
    QtWidgets.QMainWindow.__init__(self, parent)
    self.leo_c = c
    self.leo_master = None # Set in construct.
    self.leo_menubar = None # Set in createMenuBar.
    self.leo_ui = None # Set in construct.
    c._style_deltas = defaultdict(lambda: 0) # for adjusting styles dynamically
    self.reloadSettings()

def reloadSettings(self):
    c = self.leo_c
    c.registerReloadSettings(self)
    self.bigTree = c.config.getBool('big-outline-pane')
    self.show_iconbar = c.config.getBool('show-iconbar', default=True)
    self.toolbar_orientation = c.config.getString('qt-toolbar-location') or ''
    self.use_gutter = c.config.getBool('use-gutter', default=False)
    if getattr(self, 'iconBar', None):
        if self.show_iconbar:
            self.iconBar.show()
        else:
            self.iconBar.hide()
</t>
<t tx="ekr.20110605121601.18139">def construct(self, master=None):
    """ Factor 'heavy duty' code out from the DynamicWindow ctor """
    c = self.leo_c
    self.leo_master = master
        # A LeoTabbedTopLevel for tabbed windows.
        # None for non-tabbed windows.
    # Init the base class.
    self.useScintilla = c.config.getBool('qt-use-scintilla')
    self.reloadSettings()
    main_splitter, secondary_splitter = self.createMainWindow()
    self.iconBar = self.addToolBar("IconBar")
    self.set_icon_bar_orientation(c)
    # #266 A setting to hide the icon bar.
    # Calling reloadSettings again would also work.
    if not self.show_iconbar:
        self.iconBar.hide()
    self.leo_menubar = self.menuBar()
    self.statusBar = QtWidgets.QStatusBar()
    self.setStatusBar(self.statusBar)
    orientation = c.config.getString('initial-split-orientation')
    self.setSplitDirection(main_splitter, secondary_splitter, orientation)
    if hasattr(c, 'styleSheetManager'):
        c.styleSheetManager.set_style_sheets(top=self, all=True)
</t>
<t tx="ekr.20110605121601.18140">def closeEvent(self, event):
    '''Handle a close event in the Leo window.'''
    c = self.leo_c
    if not c.exists:
        # Fixes double-prompt bug on Linux.
        event.accept()
    elif c.inCommand:
        c.requestCloseWindow = True
    else:
        ok = g.app.closeLeoWindow(c.frame)
        if ok:
            event.accept()
        else:
            event.ignore()
</t>
<t tx="ekr.20110605121601.18141">def createMainWindow(self):
    '''
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    '''
    dw = self
    self.leo_ui = self
    self.setMainWindowOptions()
    self.createCentralWidget()
    main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
        # Creates .verticalLayout
    if self.bigTree:
        self.createBodyPane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        treeFrame = self.createOutlinePane(main_splitter)
        main_splitter.addWidget(treeFrame)
        main_splitter.addWidget(secondary_splitter)
    else:
        self.createOutlinePane(secondary_splitter)
        self.createLogPane(secondary_splitter)
        self.createBodyPane(main_splitter)
    self.createMiniBuffer(self.centralwidget)
    self.createMenuBar()
    self.createStatusBar(dw)
    # Signals
    QtCore.QMetaObject.connectSlotsByName(dw)
    return main_splitter, secondary_splitter
</t>
<t tx="ekr.20110605121601.18142"></t>
<t tx="ekr.20110605121601.18143">def createBodyPane(self, parent):
    '''Create the body pane.'''
    # Create widgets.
    c = self.leo_c
    bodyFrame = self.createFrame(parent, 'bodyFrame')
    innerFrame = self.createFrame(bodyFrame, 'innerBodyFrame',
        hPolicy=QtWidgets.QSizePolicy.Expanding)
    sw = self.createStackedWidget(innerFrame, 'bodyStackedWidget')
    page2 = QtWidgets.QWidget()
    self.setName(page2, 'bodyPage2')
    body = self.createText(page2, 'richTextEdit') # A LeoQTextBrowser
    # Pack.
    vLayout = self.createVLayout(page2, 'bodyVLayout', spacing=6)
    grid = self.createGrid(bodyFrame, 'bodyGrid')
    innerGrid = self.createGrid(innerFrame, 'bodyInnerGrid')
    if self.use_gutter:
        lineWidget = qt_text.LeoLineTextWidget(c, body)
        vLayout.addWidget(lineWidget)
    else:
        vLayout.addWidget(body)
    sw.addWidget(page2)
    innerGrid.addWidget(sw, 0, 0, 1, 1)
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    self.verticalLayout.addWidget(parent)
    # Official ivars
    self.text_page = page2
    self.stackedWidget = sw # used by LeoQtBody
    self.richTextEdit = body
    self.leo_body_frame = bodyFrame
    self.leo_body_inner_frame = innerFrame
</t>
<t tx="ekr.20110605121601.18144">def createCentralWidget(self):
    '''Create the central widget.'''
    dw = self
    w = QtWidgets.QWidget(dw)
    w.setObjectName("centralwidget")
    dw.setCentralWidget(w)
    # Official ivars.
    self.centralwidget = w
</t>
<t tx="ekr.20110605121601.18145">def createLogPane(self, parent):
    '''Create all parts of Leo's log pane.'''
    # Create widgets.
    c = self.leo_c
    logFrame = self.createFrame(parent, 'logFrame',
        vPolicy=QtWidgets.QSizePolicy.Minimum)
    innerFrame = self.createFrame(logFrame, 'logInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred,
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    tabWidget = self.createTabWidget(innerFrame, 'logTabWidget')
    # Pack.
    innerGrid = self.createGrid(innerFrame, 'logInnerGrid')
    innerGrid.addWidget(tabWidget, 0, 0, 1, 1)
    outerGrid = self.createGrid(logFrame, 'logGrid')
    outerGrid.addWidget(innerFrame, 0, 0, 1, 1)
    # Embed the Find tab in a QScrollArea.
    findScrollArea = QtWidgets.QScrollArea()
    findScrollArea.setObjectName('findScrollArea')
    # Find tab.
    findTab = QtWidgets.QWidget()
    findTab.setObjectName('findTab')
    # Fix #516:
    use_minibuffer = c.config.getBool('minibuffer-find-mode', default=False)
    use_dialog = c.config.getBool('use-find-dialog', default=False)
    if not use_minibuffer and not use_dialog:
        tabWidget.addTab(findScrollArea, 'Find')
    # Do this later, in LeoFind.finishCreate
    self.findScrollArea = findScrollArea
    self.findTab = findTab
    # Spell tab.
    spellTab = QtWidgets.QWidget()
    spellTab.setObjectName('spellTab')
    tabWidget.addTab(spellTab, 'Spell')
    self.createSpellTab(spellTab)
    tabWidget.setCurrentIndex(1)
    # Official ivars
    self.tabWidget = tabWidget # Used by LeoQtLog.
</t>
<t tx="ekr.20110605121601.18146">def createMainLayout(self, parent):
    '''Create the layout for Leo's main window.'''
    # c = self.leo_c
    vLayout = self.createVLayout(parent, 'mainVLayout', margin=3)
    main_splitter = splitter_class(parent)
    main_splitter.setOrientation(QtCore.Qt.Vertical)
    secondary_splitter = splitter_class(main_splitter)
    secondary_splitter.setOrientation(QtCore.Qt.Horizontal)
    # Official ivar:
    self.verticalLayout = vLayout
    self.setSizePolicy(secondary_splitter)
    self.verticalLayout.addWidget(main_splitter)
    return main_splitter, secondary_splitter
</t>
<t tx="ekr.20110605121601.18147">def createMenuBar(self):
    '''Create Leo's menu bar.'''
    dw = self
    w = QtWidgets.QMenuBar(dw)
    w.setNativeMenuBar(platform.system() == 'Darwin')
    w.setGeometry(QtCore.QRect(0, 0, 957, 22))
    w.setObjectName("menubar")
    dw.setMenuBar(w)
    # Official ivars.
    self.leo_menubar = w
</t>
<t tx="ekr.20110605121601.18148">def createMiniBuffer(self, parent):
    '''Create the widgets for Leo's minibuffer area.'''
    # Create widgets.
    frame = self.createFrame(self.centralwidget, 'minibufferFrame',
        hPolicy=QtWidgets.QSizePolicy.MinimumExpanding,
        vPolicy=QtWidgets.QSizePolicy.Fixed)
    frame.setMinimumSize(QtCore.QSize(100, 0))
    label = self.createLabel(frame, 'minibufferLabel', 'Minibuffer:')

    class VisLineEdit(QtWidgets.QLineEdit):
        """In case user has hidden minibuffer with gui-minibuffer-hide"""

        def focusInEvent(self, event):
            self.parent().show()
            QtWidgets.QLineEdit.focusInEvent(self, event)
                # EKR: 2014/06/28: Call the base class method.
        def restore_selection(self):
            w = self
            i, j, ins = self._sel_and_insert
            if i == j:
                w.setCursorPosition(i)
            else:
                length = j - i
                # Set selection is a QLineEditMethod
                if ins &lt; j:
                    w.setSelection(j, -length)
                else:
                    w.setSelection(i, length)

        def focusOutEvent(self, event):
            self.store_selection()
            QtWidgets.QLineEdit.focusOutEvent(self, event)
        def store_selection(self):
            w = self
            ins = w.cursorPosition()
            if w.hasSelectedText():
                i = w.selectionStart()
                s = w.selectedText()
                s = g.u(s)
                j = i + len(s)
            else:
                i = j = ins
            w._sel_and_insert = (i, j, ins)

    lineEdit = VisLineEdit(frame)
    lineEdit._sel_and_insert = (0, 0, 0)
    lineEdit.setObjectName('lineEdit') # name important.
    # Pack.
    hLayout = self.createHLayout(frame, 'minibufferHLayout', spacing=4)
    hLayout.setContentsMargins(3, 2, 2, 0)
    hLayout.addWidget(label)
    hLayout.addWidget(lineEdit)
    self.verticalLayout.addWidget(frame)
    label.setBuddy(lineEdit)
    # Official ivars.
    self.lineEdit = lineEdit
    # self.leo_minibuffer_frame = frame
    # self.leo_minibuffer_layout = layout
</t>
<t tx="ekr.20110605121601.18149">def createOutlinePane(self, parent):
    '''Create the widgets and ivars for Leo's outline.'''
    # Create widgets.
    treeFrame = self.createFrame(parent, 'outlineFrame',
        vPolicy=QtWidgets.QSizePolicy.Expanding)
    innerFrame = self.createFrame(treeFrame, 'outlineInnerFrame',
        hPolicy=QtWidgets.QSizePolicy.Preferred)
    treeWidget = self.createTreeWidget(innerFrame, 'treeWidget')
    grid = self.createGrid(treeFrame, 'outlineGrid')
    grid.addWidget(innerFrame, 0, 0, 1, 1)
    innerGrid = self.createGrid(innerFrame, 'outlineInnerGrid')
    innerGrid.addWidget(treeWidget, 0, 0, 1, 1)
    # Official ivars...
    self.treeWidget = treeWidget
    return treeFrame
</t>
<t tx="ekr.20110605121601.18150">def createStatusBar(self, parent):
    '''Create the widgets and ivars for Leo's status area.'''
    w = QtWidgets.QStatusBar(parent)
    w.setObjectName("statusbar")
    parent.setStatusBar(w)
    # Official ivars.
    self.statusBar = w
</t>
<t tx="ekr.20110605121601.18151">def setMainWindowOptions(self):
    '''Set default options for Leo's main window.'''
    dw = self
    dw.setObjectName("MainWindow")
    dw.resize(691, 635)
    dw.setDockNestingEnabled(False)
    dw.setDockOptions(
        QtWidgets.QMainWindow.AllowTabbedDocks |
        QtWidgets.QMainWindow.AnimatedDocks)
</t>
<t tx="ekr.20110605121601.18152"></t>
<t tx="ekr.20110605121601.18153">def createButton(self, parent, name, label):
    w = QtWidgets.QPushButton(parent)
    w.setObjectName(name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18154">def createCheckBox(self, parent, name, label):
    w = QtWidgets.QCheckBox(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18155">def createFrame(self, parent, name,
    hPolicy=None, vPolicy=None,
    lineWidth=1,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    '''Create a Qt Frame.'''
    w = QtWidgets.QFrame(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setFrameShape(shape)
    w.setFrameShadow(shadow)
    w.setLineWidth(lineWidth)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18156">def createGrid(self, parent, name, margin=0, spacing=0):
    w = QtWidgets.QGridLayout(parent)
    w.setContentsMargins(QtCore.QMargins(margin, margin, margin, margin))
        # 2014/08/24: honor margin argument.
    w.setSpacing(spacing)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18157">def createHLayout(self, parent, name, margin=0, spacing=0):
    hLayout = QtWidgets.QHBoxLayout(parent)
    hLayout.setSpacing(spacing)
    hLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(hLayout, name)
    return hLayout

def createVLayout(self, parent, name, margin=0, spacing=0):
    vLayout = QtWidgets.QVBoxLayout(parent)
    vLayout.setSpacing(spacing)
    vLayout.setContentsMargins(QtCore.QMargins(0, 0, 0, 0))
    self.setName(vLayout, name)
    return vLayout
</t>
<t tx="ekr.20110605121601.18158">def createLabel(self, parent, name, label):
    w = QtWidgets.QLabel(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18159">def createLineEdit(self, parent, name, disabled=True):

    w = QtWidgets.QLineEdit(parent)
    w.setObjectName(name)
    w.leo_disabled = disabled # Inject the ivar.
    return w
</t>
<t tx="ekr.20110605121601.18160">def createRadioButton(self, parent, name, label):
    w = QtWidgets.QRadioButton(parent)
    self.setName(w, name)
    w.setText(self.tr(label))
    return w
</t>
<t tx="ekr.20110605121601.18161">def createStackedWidget(self, parent, name,
    lineWidth=1,
    hPolicy=None, vPolicy=None,
):
    w = QtWidgets.QStackedWidget(parent)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    w.setAcceptDrops(True)
    w.setLineWidth(1)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18162">def createTabWidget(self, parent, name, hPolicy=None, vPolicy=None):
    w = QtWidgets.QTabWidget(parent)
    # tb = w.tabBar()
    # tb.setTabsClosable(True)
    self.setSizePolicy(w, kind1=hPolicy, kind2=vPolicy)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18163">def createText(self, parent, name,
    # hPolicy=None,vPolicy=None,
    lineWidth=0,
    shadow=QtWidgets.QFrame.Plain,
    shape=QtWidgets.QFrame.NoFrame,
):
    # Create a text widget.
    c = self.leo_c
    if name == 'richTextEdit' and self.useScintilla and Qsci:
        # Do this in finishCreate, when c.frame.body exists.
        w = Qsci.QsciScintilla(parent)
        self.scintilla_widget = w
    else:
        w = qt_text.LeoQTextBrowser(parent, c, None)
        # self.setSizePolicy(w,kind1=hPolicy,kind2=vPolicy)
        w.setFrameShape(shape)
        w.setFrameShadow(shadow)
        w.setLineWidth(lineWidth)
        self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18164">def createTreeWidget(self, parent, name):
    c = self.leo_c
    w = LeoQTreeWidget(c, parent)
    self.setSizePolicy(w)
    # 12/01/07: add new config setting.
    multiple_selection = c.config.getBool('qt-tree-multiple-selection', default=True)
    if multiple_selection:
        w.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
    else:
        w.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        w.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectItems)
    w.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    w.setHeaderHidden(False)
    self.setName(w, name)
    return w
</t>
<t tx="ekr.20110605121601.18165"></t>
<t tx="ekr.20110605121601.18166">def createFindTab(self, parent, tab_widget):
    '''Create a Find Tab in the given parent.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    assert not fc.ftm
    fc.ftm = ftm = FindTabManager(c)
    grid = self.create_find_grid(parent)
    row = 0 # The index for the present row.
    row = dw.create_find_header(grid, parent, row)
    row = dw.create_find_findbox(grid, parent, row)
    row = dw.create_find_replacebox(grid, parent, row)
    max_row2 = 1
    max_row2 = dw.create_find_checkboxes(grid, parent, max_row2, row)
    row = dw.create_find_buttons(grid, parent, max_row2, row)
    row = dw.create_help_row(grid, parent, row)
    # Status row
    dw.create_find_status(grid, parent, row)
    row += 1
    dw.override_events()
    # Last row: Widgets that take all additional vertical space.
    w = QtWidgets.QWidget()
    grid.addWidget(w, row, 0)
    grid.addWidget(w, row, 1)
    grid.addWidget(w, row, 2)
    grid.setRowStretch(row, 100)
    # Official ivars (in addition to checkbox ivars).
    self.leo_find_widget = tab_widget # A scrollArea.
    ftm.init_widgets()
</t>
<t tx="ekr.20110605121601.18167">def createSpellTab(self, parent):
    # dw = self
    vLayout = self.createVLayout(parent, 'spellVLayout', margin=2)
    spellFrame = self.createFrame(parent, 'spellFrame')
    vLayout2 = self.createVLayout(spellFrame, 'spellVLayout')
    grid = self.createGrid(None, 'spellGrid', spacing=2)
    table = (
        ('Add', 'Add', 2, 1),
        ('Find', 'Find', 2, 0),
        ('Change', 'Change', 3, 0),
        ('FindChange', 'Change,Find', 3, 1),
        ('Ignore', 'Ignore', 4, 0),
        ('Hide', 'Hide', 4, 1),
    )
    for(ivar, label, row, col) in table:
        name = 'spell_%s_button' % label
        button = self.createButton(spellFrame, name, label)
        grid.addWidget(button, row, col)
        func = getattr(self, 'do_leo_spell_btn_%s' % ivar)
        button.clicked.connect(func)
        # This name is significant.
        setattr(self, 'leo_spell_btn_%s' % (ivar), button)
    self.leo_spell_btn_Hide.setCheckable(False)
    spacerItem = QtWidgets.QSpacerItem(20, 40,
        QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
    grid.addItem(spacerItem, 5, 0, 1, 1)
    listBox = QtWidgets.QListWidget(spellFrame)
    self.setSizePolicy(listBox,
        kind1=QtWidgets.QSizePolicy.MinimumExpanding,
        kind2=QtWidgets.QSizePolicy.Expanding)
    listBox.setMinimumSize(QtCore.QSize(0, 0))
    listBox.setMaximumSize(QtCore.QSize(150, 150))
    listBox.setObjectName("leo_spell_listBox")
    grid.addWidget(listBox, 1, 0, 1, 2)
    spacerItem1 = QtWidgets.QSpacerItem(40, 20,
        QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
    grid.addItem(spacerItem1, 2, 2, 1, 1)
    lab = self.createLabel(spellFrame, 'spellLabel', 'spellLabel')
    grid.addWidget(lab, 0, 0, 1, 2)
    vLayout2.addLayout(grid)
    vLayout.addWidget(spellFrame)
    listBox.itemDoubleClicked.connect(self.do_leo_spell_btn_FindChange)
    # Official ivars.
    self.spellFrame = spellFrame
    self.spellGrid = grid
    self.leo_spell_widget = parent # 2013/09/20: To allow bindings to be set.
    self.leo_spell_listBox = listBox # Must exist
    self.leo_spell_label = lab # Must exist (!!)
</t>
<t tx="ekr.20110605121601.18168"></t>
<t tx="ekr.20110605121601.18169">def setName(self, widget, name):
    if name:
        # if not name.startswith('leo_'):
            # name = 'leo_' + name
        widget.setObjectName(name)
</t>
<t tx="ekr.20110605121601.18170">def setSizePolicy(self, widget, kind1=None, kind2=None):
    if kind1 is None: kind1 = QtWidgets.QSizePolicy.Ignored
    if kind2 is None: kind2 = QtWidgets.QSizePolicy.Ignored
    sizePolicy = QtWidgets.QSizePolicy(kind1, kind2)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(
        widget.sizePolicy().hasHeightForWidth())
    widget.setSizePolicy(sizePolicy)
</t>
<t tx="ekr.20110605121601.18171">def tr(self, s):
    # pylint: disable=no-member
    if isQt5:
        # QApplication.UnicodeUTF8 no longer exists.
        return QtWidgets.QApplication.translate('MainWindow', s, None)
    else:
        return QtWidgets.QApplication.translate(
            'MainWindow',
            s,
            None,
            QtWidgets.QApplication.UnicodeUTF8)
</t>
<t tx="ekr.20110605121601.18172">def doSpellBtn(self, btn):
    getattr(self.leo_c.spellCommands.handler.tab, btn)()

def do_leo_spell_btn_Add(self):
    self.doSpellBtn('onAddButton')

def do_leo_spell_btn_Change(self):
    self.doSpellBtn('onChangeButton')

def do_leo_spell_btn_Find(self):
    self.doSpellBtn('onFindButton')

def do_leo_spell_btn_FindChange(self):
    self.doSpellBtn('onChangeThenFindButton')

def do_leo_spell_btn_Hide(self):
    self.doSpellBtn('onHideButton')

def do_leo_spell_btn_Ignore(self):
    self.doSpellBtn('onIgnoreButton')
</t>
<t tx="ekr.20110605121601.18173">def select(self, c):
    '''Select the window or tab for c. self is c.frame.top.'''
    if self.leo_master:
        # A LeoTabbedTopLevel.
        self.leo_master.select(c)
    else:
        w = c.frame.body.wrapper
        g.app.gui.set_focus(c, w)
</t>
<t tx="ekr.20110605121601.18174">def setSplitDirection(self, main_splitter, secondary_splitter, orientation):
    '''Set the orientations of the splitters in the Leo main window.'''
    # c = self.leo_c
    vert = orientation and orientation.lower().startswith('v')
    h, v = QtCore.Qt.Horizontal, QtCore.Qt.Vertical
    orientation1 = v if vert else h
    orientation2 = h if vert else v
    main_splitter.setOrientation(orientation1)
    secondary_splitter.setOrientation(orientation2)
</t>
<t tx="ekr.20110605121601.18177">def setLeoWindowIcon(self):
    """ Set icon visible in title bar and task bar """
    # self.setWindowIcon(QtGui.QIcon(g.app.leoDir + "/Icons/leoapp32.png"))
    g.app.gui.attachLeoIcon(self)
</t>
<t tx="ekr.20110605121601.18178">def setGeometry(self, rect):
    '''Set the window geometry, but only once when using the qttabs gui.'''
    if g.app.qt_use_tabs:
        m = self.leo_master
        assert self.leo_master
        # Only set the geometry once, even for new files.
        if not hasattr(m, 'leo_geom_inited'):
            m.leo_geom_inited = True
            self.leo_master.setGeometry(rect)
            QtWidgets.QMainWindow.setGeometry(self, rect)
    else:
        QtWidgets.QMainWindow.setGeometry(self, rect)
</t>
<t tx="ekr.20110605121601.18179"></t>
<t tx="ekr.20110605121601.18250">def finishCreate(self):

    f = self
    c = self.c
    assert c
    # returns DynamicWindow
    f.top = g.app.gui.frameFactory.createFrame(f)
    f.createIconBar() # A base class method.
    f.createSplitterComponents()
    f.createStatusLine() # A base class method.
    f.createFirstTreeNode() # Call the base-class method.
    f.menu = LeoQtMenu(c, f, label='top-level-menu')
    g.app.windowList.append(f)
    f.miniBufferWidget = qt_text.QMinibufferWrapper(c)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20110605121601.18251">def createSplitterComponents(self):
    c, f = self.c, self
    f.tree = qt_tree.LeoQtTree(c, f)
    f.log = LeoQtLog(f, None)
    f.body = LeoQtBody(f, None)
    f.splitVerticalFlag, ratio, secondary_ratio = f.initialRatios()
    f.resizePanesToRatio(ratio, secondary_ratio)

</t>
<t tx="ekr.20110605121601.18311">def bringToFront(self):
    self.lift()

def deiconify(self):
    if self.top and self.top.isMinimized(): # Bug fix: 400739.
        self.lift()

def getFocus(self):
    return g.app.gui.get_focus(self.c) # Bug fix: 2009/6/30.

def get_window_info(self):
    if hasattr(self.top, 'leo_master') and self.top.leo_master:
        f = self.top.leo_master
    else:
        f = self.top
    rect = f.geometry()
    topLeft = rect.topLeft()
    x, y = topLeft.x(), topLeft.y()
    w, h = rect.width(), rect.height()
    return w, h, x, y

def iconify(self):
    if self.top: self.top.showMinimized()

def lift(self):
    if not self.top: return
    if self.top.isMinimized(): # Bug 379141
        self.top.showNormal()
    self.top.activateWindow()
    self.top.raise_()

def getTitle(self):
    # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
    # When using tabs, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
    w = self.top.leo_master if g.app.qt_use_tabs else self.top
    s = g.u(w.windowTitle())
    return s

def setTitle(self, s):
    # pylint: disable=arguments-differ
    if self.top:
        # Fix https://bugs.launchpad.net/leo-editor/+bug/1194209
        # When using tabs, leo_master (a LeoTabbedTopLevel) contains the QMainWindow.
        w = self.top.leo_master if g.app.qt_use_tabs else self.top
        w.setWindowTitle(s)

def setTopGeometry(self, w, h, x, y, adjustSize=True):
    # self.top is a DynamicWindow.
    if self.top:
        self.top.setGeometry(QtCore.QRect(x, y, w, h))

def update(self, *args, **keys):
    self.top.update()
</t>
<t tx="ekr.20110605121601.18360">def setMenuLabel(self, menu, name, label, underline=-1):

    def munge(s):
        return g.u(s or '').replace('&amp;', '')

    # menu is a QtMenuWrapper.
    if not menu: return
    realName = munge(self.getRealMenuName(name))
    realLabel = self.getRealMenuName(label)
    for action in menu.actions():
        s = munge(action.text())
        s = s.split('\t')[0]
        if s == realName:
            action.setText(realLabel)
            break
</t>
<t tx="ekr.20110605121601.18383">def parseText(self, md):
    '''Parse md.text() into (fn,s)'''
    fn = ''
    # Fix bug 1046195: character encoding changes when dragging outline between leo files
    # Python3: md.text() is a (unicode) str.  Python2: md.text is a QString.
    s = g.u(md.text())
    # s = g.toUnicode(s,'utf-8')
    if s:
        i = s.find(',')
        if i == -1:
            pass
        else:
            fn = s[: i]
            s = s[i + 1:]
    return fn, s
</t>
<t tx="ekr.20110605121601.18384">def setText(self, md):
    c = self.c
    fn = self.fileName()
    s = c.fileCommands.putLeoOutline()
    if not g.isPython3:
        s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
        fn = g.toEncodedString(fn, encoding='utf-8', reportErrors=True)
    md.setText('%s,%s' % (fn, s))
</t>
<t tx="ekr.20110605121601.18421">def createTreeItem(self, p, parent_item):

    w = self.treeWidget
    itemOrTree = parent_item or w
    item = QtWidgets.QTreeWidgetItem(itemOrTree)
    item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
    try:
        g.visit_tree_item(self.c, p, item)
    except leoPlugins.TryNext:
        pass
    #print "item",item
    return item
</t>
<t tx="ekr.20110605121601.18424">def getItemText(self, item):
    '''Return the text of the item.'''
    if item:
        return g.u(item.text(0))
    else:
        return '&lt;no item&gt;'
</t>
<t tx="ekr.20110605121601.18437">def onContextMenu(self, point):
    c = self.c
    w = self.treeWidget
    handlers = g.tree_popup_handlers
    menu = QtWidgets.QMenu()
    menuPos = w.mapToGlobal(point)
    if not handlers:
        menu.addAction("No popup handlers")
    p = c.p.copy()
    done = set()
    for handler in handlers:
        # every handler has to add it's QActions by itself
        if handler in done:
            # do not run the same handler twice
            continue
        try:
            handler(c, p, menu)
        except Exception:
            g.es_print('Exception executing right-click handler')
            g.es_exception()
    menu.popup(menuPos)
    self._contextmenu = menu
</t>
<t tx="ekr.20110605121601.18441">def createControl(self):

    class LeoQComboBox(QtWidgets.QComboBox):
        '''Create a subclass in order to handle focusInEvents.'''

        def __init__(self, tt):
            self.leo_tt = tt
            QtWidgets.QComboBox.__init__(self) # Init the base class.
            # Fix #458: Chapters drop-down list is not automatically resized.
            self.setSizeAdjustPolicy(self.AdjustToContents)

        def focusInEvent(self, event):
            self.leo_tt.setNames()
            QtWidgets.QComboBox.focusInEvent(self, event) # Call the base class

    tt = self
    frame = QtWidgets.QLabel('Chapters: ')
    tt.iconBar.addWidget(frame)
    tt.w = w = LeoQComboBox(tt)
    tt.setNames()
    tt.iconBar.addWidget(w)

    def onIndexChanged(s, tt=tt):
        if g.isInt(s):
            s = '' if s == -1 else tt.w.currentText()
        else: # s is the tab name.
            s = g.u(s)
        if s and not tt.cc.selectChapterLockout:
            tt.selectTab(s)
    # A change: the argument could now be an int instead of a string.

    w.currentIndexChanged.connect(onIndexChanged)
</t>
<t tx="ekr.20110605121601.18445">def selectTab(self, tabName):
    '''LeoQtTreeTab.'''
    tt, c, cc = self, self.c, self.cc
    tabName = g.u(tabName)
    exists = tabName in self.tabNames
    c.treeWantsFocusNow()
        # Fix #969. Somehow this is important.
    if not exists:
        tt.createTab(tabName) # Calls tt.setNames()
    if tt.lockout:
        return
    cc.selectChapterByName(tabName)
    c.redraw()
    c.outerUpdate()
</t>
<t tx="ekr.20110605121601.18464">class TabbedFrameFactory(object):
    """ 'Toplevel' frame builder for tabbed toplevel interface

    This causes Leo to maintain only one toplevel window,
    with multiple tabs for documents
    """
    @others
</t>
<t tx="ekr.20110605121601.18465">def __init__(self):
    # will be created when first frame appears
    # DynamicWindow =&gt; Leo frame map
    self.alwaysShowTabs = True
        # Set to true to workaround a problem
        # setting the window title when tabs are shown.
    self.leoFrames = {}
        # Keys are DynamicWindows, values are frames.
    self.masterFrame = None
    self.createTabCommands()

</t>
<t tx="ekr.20110605121601.18466">def createFrame(self, leoFrame):

    c = leoFrame.c
    if self.masterFrame is None:
        self.createMaster()
    tabw = self.masterFrame
    dw = DynamicWindow(c, tabw)
    self.leoFrames[dw] = leoFrame
    # Shorten the title.
    title = os.path.basename(c.mFileName) if c.mFileName else leoFrame.title
    tip = leoFrame.title
    dw.setWindowTitle(tip) # 2010/1/1
    idx = tabw.addTab(dw, title)
    if tip: tabw.setTabToolTip(idx, tip)
    dw.construct(master=tabw)
    tabw.setCurrentIndex(idx)
    g.app.gui.setFilter(c, dw, dw, tag='tabbed-frame')
    # Work around the problem with missing dirty indicator
    # by always showing the tab.
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() &gt; 1)
    tabw.setTabsClosable(c.config.getBool('outline-tabs-show-close', True))
    dw.show()
    tabw.show()
    return dw
</t>
<t tx="ekr.20110605121601.18467">def deleteFrame(self, wdg):

    if not wdg:
        return
    if wdg not in self.leoFrames:
        # probably detached tab
        self.masterFrame.delete(wdg)
        return
    tabw = self.masterFrame
    idx = tabw.indexOf(wdg)
    tabw.removeTab(idx)
    del self.leoFrames[wdg]
    wdg2 = tabw.currentWidget()
    if wdg2:
        g.app.selectLeoWindow(wdg2.leo_c)
    tabw.tabBar().setVisible(self.alwaysShowTabs or tabw.count() &gt; 1)
</t>
<t tx="ekr.20110605121601.18468">def createMaster(self):
    mf = self.masterFrame = LeoTabbedTopLevel(factory=self)
    g.app.gui.attachLeoIcon(mf)
    tabbar = mf.tabBar()
    try:
        tabbar.setTabsClosable(True)
        tabbar.tabCloseRequested.connect(self.slotCloseRequest)
    except AttributeError:
        pass # Qt 4.4 does not support setTabsClosable
    mf.currentChanged.connect(self.slotCurrentChanged)
    if g.app.start_minimized:
        mf.showMinimized()
    elif g.app.start_maximized:
        mf.showMaximized()
    elif g.app.start_fullscreen:
        mf.showFullScreen()
    else:
        mf.show()
</t>
<t tx="ekr.20110605121601.18469">def setTabForCommander(self, c):
    tabw = self.masterFrame # a QTabWidget
    for dw in self.leoFrames: # A dict whose keys are DynamicWindows.
        if dw.leo_c == c:
            for i in range(tabw.count()):
                if tabw.widget(i) == dw:
                    tabw.setCurrentIndex(i)
                    break
            break
</t>
<t tx="ekr.20110605121601.18470">def slotCloseRequest(self, idx):

    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames[w]
    c = f.c
    c.close(new_c=None)
        # 2012/03/04: Don't set the frame here.
        # Wait until the next slotCurrentChanged event.
        # This keeps the log and the QTabbedWidget in sync.

def slotCurrentChanged(self, idx):
    # Two events are generated, one for the tab losing focus,
    # and another event for the tab gaining focus.
    tabw = self.masterFrame
    w = tabw.widget(idx)
    f = self.leoFrames.get(w)
    if not f:
        return
    tabw.setWindowTitle(f.title)
    if hasattr(g.app.gui, 'findDialogSelectCommander'):
        g.app.gui.findDialogSelectCommander(f.c)
    # g.app.selectLeoWindow(f.c)
        # would break --minimize
    # Fix bug 690260: correct the log.
    g.app.log = f.log
    # Redraw the tab.
    c = f.c
    if c:
        c.redraw()
</t>
<t tx="ekr.20110605121601.18471">def focusCurrentBody(self):
    """ Focus body control of current tab """
    tabw = self.masterFrame
    w = tabw.currentWidget()
    w.setFocus()
    f = self.leoFrames[w]
    c = f.c
    c.bodyWantsFocusNow()
    # Fix bug 690260: correct the log.
    g.app.log = f.log
</t>
<t tx="ekr.20110605121601.18472">def detachTab(self, wdg):
    """ Detach specified tab as individual toplevel window """
    del self.leoFrames[wdg]
    wdg.setParent(None)
    wdg.show()

def createTabCommands(self):
    &lt;&lt; Commands for tabs &gt;&gt;
</t>
<t tx="ekr.20110605121601.18473">@g.command('tab-detach')
def tab_detach(event):
    """ Detach current tab from tab bar """
    if len(self.leoFrames) &lt; 2:
        g.es_print_error("Can't detach last tab")
        return
    c = event['c']
    f = c.frame
    tabwidget = g.app.gui.frameFactory.masterFrame
    tabwidget.detach(tabwidget.indexOf(f.top))
    f.top.setWindowTitle(f.title + ' [D]')
# this is actually not tab-specific, move elsewhere?

@g.command('close-others')
def close_others(event):
    '''Close all windows except the present window.'''
    myc = event['c']
    for c in g.app.commanders():
        if c is not myc:
            c.close()

def tab_cycle(offset):

    tabw = self.masterFrame
    cur = tabw.currentIndex()
    count = tabw.count()
    # g.es("cur: %s, count: %s, offset: %s" % (cur,count,offset))
    cur += offset
    if cur &lt; 0:
        cur = count - 1
    elif cur &gt;= count:
        cur = 0
    tabw.setCurrentIndex(cur)
    self.focusCurrentBody()

@g.command('tab-cycle-next')
def tab_cycle_next(event):
    """ Cycle to next tab """
    tab_cycle(1)

@g.command('tab-cycle-previous')
def tab_cycle_previous(event):
    """ Cycle to next tab """
    tab_cycle(-1)
</t>
<t tx="ekr.20110605121601.18494">def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    if g.unitTesting: return None
    message = (
        "leoID.txt not found\n\n" +
        "Please enter an id that identifies you uniquely.\n" +
        "Your cvs/bzr login name is a good choice.\n\n" +
        "Leo uses this id to uniquely identify nodes.\n\n" +
        "Your id must contain only letters and numbers\n" +
        "and must be at least 3 characters in length.")
    parent = None
    title = 'Enter Leo id'
    s, ok = QtWidgets.QInputDialog.getText(parent, title, message)
    return g.u(s)
</t>
<t tx="ekr.20110605121601.18499">def runOpenDirectoryDialog(self, title, startdir):
    """Create and run an Qt open directory dialog ."""
    parent = None
    d = QtWidgets.QFileDialog()
    self.attachLeoIcon(d)
    s = d.getExistingDirectory(parent, title, startdir)
    return g.u(s)
</t>
<t tx="ekr.20110605121601.18500">def runOpenFileDialog(self, c, title, filetypes,
    defaultextension='',
    multiple=False,
    startpath=None,
):
    """Create and run an Qt open file dialog ."""
    if g.unitTesting:
        return ''
    parent = None
    filter_ = self.makeFilter(filetypes)
    dialog = QtWidgets.QFileDialog()
    dialog.setStyleSheet(c.active_stylesheet)
    self.attachLeoIcon(dialog)
    # 2018/03/14: Bug fixes:
    # - Use init_dialog_folder only if a path is not given
    # - *Never* Use os.curdir by default!
    if not startpath:
        startpath = g.init_dialog_folder(c, c.p, use_at_path=True)
            # Returns c.last_dir or os.curdir
    func = dialog.getOpenFileNames if multiple else dialog.getOpenFileName
    c.in_qt_dialog = True
    try:
        val = func(
            parent=parent,
            caption=title,
            directory=startpath,
            filter=filter_,
        )
    finally:
        c.in_qt_dialog = False
    if isQt5: # this is a *Py*Qt change rather than a Qt change
        val, junk_selected_filter = val
    if multiple:
        files = [g.os_path_normslashes(g.u(s)) for s in val]
        if files:
            c.last_dir = g.os_path_dirname(files[-1])
        return files
    else:
        s = g.os_path_normslashes(g.u(val))
        if s:
            c.last_dir = g.os_path_dirname(s)
        return s
</t>
<t tx="ekr.20110605121601.18502">def runSaveFileDialog(self, c, initialfile='', title='Save', filetypes=None, defaultextension=''):
    """Create and run an Qt save file dialog ."""
    if filetypes is None:
        filetypes = []
    if g.unitTesting:
        return ''
    else:
        parent = None
        filter_ = self.makeFilter(filetypes)
        d = QtWidgets.QFileDialog()
        d.setStyleSheet(c.active_stylesheet)
        self.attachLeoIcon(d)
        c.in_qt_dialog = True
        obj = d.getSaveFileName(
            parent,
            title,
            # os.curdir,
            g.init_dialog_folder(c, c.p, use_at_path=True),
            filter_)
        c.in_qt_dialog = False
        # Very bizarre: PyQt5 version can return a tuple!
        s = obj[0] if isinstance(obj, (list, tuple)) else obj
        s = g.u(s or '')
        if s:
            c.last_dir = g.os_path_dirname(s)
        return s
</t>
<t tx="ekr.20110605121601.18510">size_warnings = []

def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    '''Required to handle syntax coloring.'''
    if g.isString(size):
        if size.endswith('pt'):
            size = size[: -2].strip()
        elif size.endswith('px'):
            if size not in self.size_warnings:
                self.size_warnings.append(size)
                g.es('px ignored in font setting: %s' % size)
            size = size[: -2].strip()
    try:
        size = int(size)
    except Exception:
        size = 0
    if size &lt; 1: size = defaultSize
    d = {
        'black': QtGui.QFont.Black,
        'bold': QtGui.QFont.Bold,
        'demibold': QtGui.QFont.DemiBold,
        'light': QtGui.QFont.Light,
        'normal': QtGui.QFont.Normal,
    }
    weight_val = d.get(weight.lower(), QtGui.QFont.Normal)
    italic = slant == 'italic'
    if not family:
        family = g.app.config.defaultFontFamily
    if not family:
        family = 'DejaVu Sans Mono'
    try:
        font = QtGui.QFont(family, size, weight_val, italic)
        if sys.platform.startswith('linux'):
            font.setHintingPreference(font.PreferFullHinting)
        # g.es(font,font.hintingPreference())
        return font
    except Exception:
        g.es("exception setting font", g.callers(4))
        g.es("", "family,size,slant,weight:", "", family, "", size, "", slant, "", weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
</t>
<t tx="ekr.20110605121601.18526">def toUnicode(self, s):
    try:
        s = g.u(s)
        return s
    except Exception:
        g.trace('*** Unicode Error: bugs possible')
        # The mass update omitted the encoding param.
        return g.toUnicode(s, reportErrors='replace')
</t>
<t tx="ekr.20110605121601.18544">def qtKey(self, event):
    '''
    Return the components of a Qt key event.

    Modifiers are handled separately.

    Return (keynum, text, toString, ch).

    keynum: event.key()
    ch:     g.u(chr(keynum)) or '' if there is an exception.
    toString:
        For special keys: made-up spelling that become part of the setting.
        For all others:   QtGui.QKeySequence(keynum).toString()
    text:   event.text()
    '''
    keynum = event.key()
    text = event.text() # This is the unicode character!
    qt = QtCore.Qt
    d = {
        qt.Key_Alt: 'Key_Alt',
        qt.Key_AltGr: 'Key_AltGr',
            # On Windows, when the KeyDown event for this key is sent,
            # the Ctrl+Alt modifiers are also set.
        qt.Key_Control: 'Key_Control', # MacOS: Command key
        qt.Key_Meta: 'Key_Meta',
            # MacOS: Control key, Alt-Key on Microsoft keyboard on MacOs.
        qt.Key_Shift: 'Key_Shift',
        qt.Key_NumLock: 'Num_Lock',
            # 868.
    }
    if d.get(keynum):
        if 0: # Allow bare modifier key.
            toString = d.get(keynum)
        else:
            toString = ''
    else:
        toString = QtGui.QKeySequence(keynum).toString()
    # Fix bug 1244461: Numpad 'Enter' key does not work in minibuffer
    if toString == 'Enter':
        toString = 'Return'
    if toString == 'Esc':
        toString = 'Escape'
    try:
        ch1 = chr(keynum)
    except ValueError:
        ch1 = ''
    try:
        ch = g.u(ch1)
    except UnicodeError:
        ch = ch1
    text = g.u(text)
    toString = g.u(toString)
    return keynum, text, toString, ch
</t>
<t tx="ekr.20110605121601.18565"># Careful: we may be running from the bridge.
if QtGui:
    

    class LeoHighlighter(QtGui.QSyntaxHighlighter):
        '''
        A subclass of QSyntaxHighlighter that overrides
        the highlightBlock and rehighlight methods.

        All actual syntax coloring is done in the highlighter class.
        '''
        # This is c.frame.body.colorizer.highlighter
        
        @others
</t>
<t tx="ekr.20110605121601.18566">def __init__(self, c, colorizer, document):
    '''ctor for LeoHighlighter class.'''
    self.c = c
    self.colorizer = colorizer
    self.n_calls = 0
    assert isinstance(document, QtGui.QTextDocument), document
        # Alas, a QsciDocument is not a QTextDocument.
    QtGui.QSyntaxHighlighter.__init__(self, document)
        # Init the base class.
    if g.pygments:
        self._brushes = {}
        self._document = document
        self._formats = {}
        self._formatter = HtmlFormatter(nowrap=True)
        
        self._style = None
        # Style gallery: https://help.farbox.com/pygments.html
        # Dark styles: fruity, monokai, native, vim
        try:
            self.setStyle('solarized') # or 'leonine'
            # https://github.com/gthank/solarized-dark-pygments
        except Exception:
            self.setStyle('default') # 'solarized' or 'leonine'
</t>
<t tx="ekr.20110605121601.18567">def highlightBlock(self, s):
    """ Called by QSyntaxHighlighter """
    self.n_calls += 1
    s = g.toUnicode(s)
    self.colorizer.recolor(s)
        # Highlight just one line.
</t>
<t tx="ekr.20110605121601.18568">if 0:
    no_method_message = True # True: give message once.

    def rehighlight(self, p):
        '''
        Override base rehighlight method.
        Does nothing unless QSyntaxHighlighter.currentBlock exists.

        It appears that this method is seldom (never?) called!
        '''
        # pylint: disable=arguments-differ
        if not hasattr(self, 'currentBlock'):
            if self.no_method_message:
                self.no_method_message = False
                g.trace('===== QSyntaxHighlighter has no currentBlock method')
            return
        c = self.c
        if not p.b.strip():
            return
        self.n_calls = 0
        tree = c.frame.tree
        self.widget = c.frame.body.widget
        # n = self.colorer.recolorCount
        if self.colorizer.enabled:
            # Lock out onTextChanged.
            old_selecting = tree.selecting
            try:
                tree.selecting = True
                self.colorer.init(p, p.b)
                QtGui.QSyntaxHighlighter.rehighlight(self)
                    # Execute the base class method.
            finally:
                tree.selecting = old_selecting
</t>
<t tx="ekr.20110605121601.18569"># This is c.frame.body.colorizer
class JEditColorizer(BaseColorizer):
    '''
    The JEditColorizer class adapts jEdit pattern matchers for QSyntaxHighlighter.
    For full documentation, see:
    https://github.com/leo-editor/leo-editor/blob/master/leo/doc/colorizer.md
    '''
    @others
</t>
<t tx="ekr.20110605121601.18571"></t>
<t tx="ekr.20110605121601.18572">def __init__(self, c, widget, wrapper):
    '''Ctor for JEditColorizer class.'''
    BaseColorizer.__init__(self,c)
    assert self.c, g.callers()
    self.widget = widget
    self.wrapper = wrapper
    # This assert is not true when using multiple body editors
        # assert(wrapper == self.c.frame.body.wrapper)
    self.enabled = True
        # Per-node enable/disable flag.
        # Set by updateSyntaxColorer, used by jEdit colorizer.
    self.full_recolor_count = 0 # For unit testing.
    self.language = 'python' # set by scanLanguageDirectives.
    self.showInvisibles = False
    # Step 2: create the highlighter.
    if isinstance(widget, QtWidgets.QTextEdit):
        self.highlighter = LeoHighlighter(c,
            colorizer = self,
            document = widget.document(),
        )
    else:
        self.highlighter = None
    if widget:
        # #503: widget may be None during unit tests.
        widget.leo_colorizer = self
    # State data used by recolor and helpers...
    # init() properly sets these for each language.
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    # State dicts, etc.
    self.after_doc_language = None
    self.initialStateNumber = -1
    self.old_v = None
    self.nextState = 1 # Dont use 0.
    self.n2languageDict = {-1: c.target_language}
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.
    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Debugging...
    self.allow_mark_prev = True
    self.n_setTag = 0
    self.tagCount = 0
    self.trace_leo_matches = False
    self.trace_match_flag = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.initLanguage = None
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
        # Keys are state ints, values are language names.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.tags = [
        # 8 Leo-specific tags.
        "blank", # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        # jEdit tags.
        'comment1', 'comment2', 'comment3', 'comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1', 'keyword2', 'keyword3', 'keyword4',
        'label', 'literal1', 'literal2', 'literal3', 'literal4',
        'markup', 'operator',
        'trailing_whitespace',
    ]
    self.reloadSettings()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
</t>
<t tx="ekr.20110605121601.18573">def defineLeoKeywordsDict(self):
    self.leoKeywordsDict = {}
    for key in g.globalDirectiveList:
        self.leoKeywordsDict[key] = 'leokeyword'
</t>
<t tx="ekr.20110605121601.18574">@nobeautify

def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {

        # Used in Leo rules...

        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),

        # Used by the old colorizer: to be removed.

        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', 'black'), # 2014/09/17
        'trailing_whitespace': ('trailing_whitespace_color', '#808080'),
    }
</t>
<t tx="ekr.20110605121601.18575">@nobeautify

def defineDefaultFontDict (self):

    self.default_font_dict = {

        # Used in Leo rules...

            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',

        # Used by old colorizer.

            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',

         # jEdit tags.

             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
            'trailing_whitespace' :'trailing_whitespace_font',
    }
</t>
<t tx="ekr.20110605121601.18576">def addImportedRules(self, mode, rulesDict, rulesetName):
    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''
    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets[rulesetName] = True
    names = mode.importDict.get(rulesetName, []) if hasattr(mode, 'importDict') else []
    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key, [])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        aList.extend(rules)
                        self.rulesDict[key] = aList
        self.initModeFromBunch(savedBunch)
</t>
<t tx="ekr.20110605121601.18577">def addLeoRules(self, theDict):
    '''Put Leo-specific rules to theList.'''
    # pylint: disable=no-member
    # Python 2 uses rule.im_func. Python 3 uses rule.__func__.
    table = [
        # Rules added at front are added in **reverse** order.
        ('@', self.match_leo_keywords, True), # Called after all other Leo matchers.
            # Debatable: Leo keywords override langauge keywords.
        ('@', self.match_at_color, True),
        ('@', self.match_at_killcolor, True),
        ('@', self.match_at_language, True), # 2011/01/17
        ('@', self.match_at_nocolor, True),
        ('@', self.match_at_nocolor_node, True),
        ('@', self.match_at_wrap, True), # 2015/06/22
        ('@', self.match_doc_part, True),
        ('f', self.match_url_f, True),
        ('g', self.match_url_g, True),
        ('h', self.match_url_h, True),
        ('m', self.match_url_m, True),
        ('n', self.match_url_n, True),
        ('p', self.match_url_p, True),
        ('t', self.match_url_t, True),
        ('u', self.match_unl, True),
        ('w', self.match_url_w, True),
        # ('&lt;', self.match_image, True),
        ('&lt;', self.match_section_ref, True), # Called **first**.
        # Rules added at back are added in normal order.
        (' ', self.match_blanks, False),
        ('\t', self.match_tabs, False),
    ]
    if self.c.config.getBool("color-trailing-whitespace"):
        table += [
            (' ', self.match_trailing_ws, True),
            ('\t', self.match_trailing_ws, True),
        ]
    for ch, rule, atFront, in table:
        # Replace the bound method by an unbound method.
        if g.isPython3:
            rule = rule.__func__
        else:
            rule = rule.im_func
        theList = theDict.get(ch, [])
        if rule not in theList:
            if atFront:
                theList.insert(0, rule)
            else:
                theList.append(rule)
            theDict[ch] = theList
</t>
<t tx="ekr.20110605121601.18578">def configure_tags(self):
    '''Configure all tags.'''
    c = self.c
    wrapper = self.wrapper
    isQt = g.app.gui.guiName().startswith('qt')
    if wrapper and hasattr(wrapper, 'start_tag_configure'):
        wrapper.start_tag_configure()
    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant", "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont
    # Configure fonts.
    keys = list(self.default_font_dict.keys()); keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.language, option_name), (option_name)):
            font = self.fonts.get(name)
            if font:
                wrapper.tag_configure(key, font=font)
                break
            else:
                family = c.config.get(name + '_family', 'family')
                size = c.config.get(name + '_size', 'size')
                slant = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight', 'weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size = size or c.config.defaultBodyFontSize
                    slant = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family, size, slant, weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    wrapper.tag_configure(key, font=font)
                    break
        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                self.fonts[key] = font # Essential
                wrapper.tag_configure(key, font=defaultBodyfont)
        if isQt and key == 'url' and font:
            font.setUnderline(True)
    keys = sorted(self.default_colors_dict.keys())
    for name in keys:
        option_name, default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.language, option_name)) or
            c.config.getColor(option_name) or
            default_color)
        # Must use foreground, not fg.
        try:
            wrapper.tag_configure(name, foreground=color)
        except Exception: # Recover after a user error.
            g.es_exception()
            wrapper.tag_configure(name, foreground=default_color)
    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        wrapper.tag_configure("link", underline=1) # defined
        wrapper.tag_configure("name", underline=0) # undefined
    else:
        wrapper.tag_configure("link", underline=0)
        if self.underline_undefined:
            wrapper.tag_configure("name", underline=1)
        else:
            wrapper.tag_configure("name", underline=0)
    self.configure_variable_tags()
    try:
        wrapper.end_tag_configure()
    except AttributeError:
        pass
</t>
<t tx="ekr.20110605121601.18579">def configure_variable_tags(self):
    c = self.c
    wrapper = self.wrapper
    for name, option_name, default_color in (
        # ("blank", "show_invisibles_space_background_color", "Gray90"),
        # ("tab", "show_invisibles_tab_background_color", "Gray80"),
        ("elide", None, "yellow"),
    ):
        if self.showInvisibles:
            color = c.config.getColor(option_name) if option_name else default_color
        else:
            option_name, default_color = self.default_colors_dict.get(name, (None, None),)
            color = c.config.getColor(option_name) if option_name else ''
        try:
            wrapper.tag_configure(name, background=color)
        except Exception: # A user error.
            wrapper.tag_configure(name, background=default_color)
    # Special case:
    if not self.showInvisibles:
        wrapper.tag_configure("elide", elide="1")
</t>
<t tx="ekr.20110605121601.18580">def init(self, p):
    '''Init the colorizer, but *not* state. p is for tracing only.'''
    #
    # These *must* be recomputed.
    self.initialStateNumber = self.setInitialStateNumber()
    #
    # Fix #389. Do *not* change these.
        # self.nextState = 1 # Dont use 0.
        # self.stateDict = {}
        # self.stateNameDict = {}
        # self.restartDict = {}
    self.init_mode(self.language)
    self.clearState()
    # Used by matchers.
    self.prev = None
    # Must be done to support per-language @font/@color settings.
    self.configure_tags()
    self.configure_hard_tab_width() # 2011/10/04
</t>
<t tx="ekr.20110605121601.18581">def init_mode(self, name):
    '''Name may be a language name or a delegate name.'''
    if not name:
        return False
    language, rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            return False
        else:
            self.initModeFromBunch(bunch)
            self.language = language # 2011/05/30
            return True
    else:
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        path = g.os_path_join(g.app.loadDir, '..', 'modes')
        fn = g.os_path_join(path, '%s.py' % (language))
        if g.os_path_exists(fn):
            mode = g.importFromPath(moduleName=language, path=path)
        else:
            mode = None
        return self.init_mode_from_module(name, mode)
</t>
<t tx="ekr.20110605121601.18582">def nameToRulesetName(self, name):
    '''
    Compute language and rulesetName from name, which is either a language
    name or a delegate name.
    '''
    if not name:
        return ''
    i = name.find('::')
    if i == -1:
        language = name
        # New in Leo 5.0: allow delegated language names.
        language = g.app.delegate_language_dict.get(language, language)
        rulesetName = '%s_main' % (language)
    else:
        language = name[: i]
        delegate = name[i + 2:]
        rulesetName = self.munge('%s_%s' % (language, delegate))
    return language, rulesetName
</t>
<t tx="ekr.20110605121601.18583">def setKeywords(self):
    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.
     '''
    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d[key] = 'leokeyword'
    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]
    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))
    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)
    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
</t>
<t tx="ekr.20110605121601.18584">def setModeAttributes(self):
    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''
    d = self.attributesDict
    aList = (
        ('default', 'null'),
        ('digit_re', ''),
        ('escape', ''), # New in Leo 4.4.2.
        ('highlight_digits', True),
        ('ignore_case', True),
        ('no_word_sep', ''),
    )
    for key, default in aList:
        val = d.get(key, default)
        if val in ('true', 'True'): val = True
        if val in ('false', 'False'): val = False
        setattr(self, key, val)
</t>
<t tx="ekr.20110605121601.18585">def initModeFromBunch(self, bunch):
    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor = bunch.defaultColor
    self.keywordsDict = bunch.keywordsDict
    self.language = bunch.language
    self.mode = bunch.mode
    self.properties = bunch.properties
    self.rulesDict = bunch.rulesDict
    self.rulesetName = bunch.rulesetName
    self.word_chars = bunch.word_chars # 2011/05/21
</t>
<t tx="ekr.20110605121601.18586">def updateDelimsTables(self):
    '''Update g.app.language_delims_dict if no entry for the language exists.'''
    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')
    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment, startComment, endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment, endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None
    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.language):
            d[self.language] = delims
</t>
<t tx="ekr.20110605121601.18587">def munge(self, s):
    '''Munge a mode name so that it is a valid python id.'''
    valid = string.ascii_letters + string.digits + '_'
    return ''.join([ch.lower() if ch in valid else '_' for ch in s])
</t>
<t tx="ekr.20110605121601.18589"></t>
<t tx="ekr.20110605121601.18590">@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
</t>
<t tx="ekr.20110605121601.18591">def dump(self, s):
    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
</t>
<t tx="ekr.20110605121601.18592"></t>
<t tx="ekr.20110605121601.18593">def match_at_color(self, s, i):
    if self.trace_leo_matches:
        g.trace()
    # Only matches at start of line.
    if i == 0 and g.match_word(s, 0, '@color'):
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enable coloring of *this* line.
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
            # Now required. Sets state.
        return len('@color')
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18594">def match_at_language(self, s, i):
    '''Match Leo's @language directive.'''
    # Only matches at start of line.
    if i != 0: return 0
    if g.match_word(s, i, '@language'):
        old_name = self.language
        j = g.skip_ws(s, i + len('@language'))
        k = g.skip_c_id(s, j)
        name = s[j: k]
        ok = self.init_mode(name)
        if ok:
            self.colorRangeWithTag(s, i, k, 'leokeyword')
            if name != old_name:
                # Solves the recoloring problem!
                n = self.setInitialStateNumber()
                self.setState(n)
        return k - i
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18595">def match_at_nocolor(self, s, i):

    if self.trace_leo_matches:
        g.trace(i, repr(s))
    # Only matches at start of line.
    if i == 0 and not g.match(s, i, '@nocolor-') and g.match_word(s, i, '@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18596">def restartNoColor(self, s):
    if self.trace_leo_matches:
        g.trace(repr(s))
    if g.match_word(s, 0, '@color'):
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enables coloring of *this* line.
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
        return len('@color')
    else:
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
</t>
<t tx="ekr.20110605121601.18597">def match_at_killcolor(self, s, i):

    # Only matches at start of line.
    if i == 0 and g.match_word(s, i, '@killcolor'):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18598">def restartKillColor(self, s):
    self.setRestart(self.restartKillColor)
    return len(s) + 1
</t>
<t tx="ekr.20110605121601.18599">def match_at_nocolor_node(self, s, i):

    # Only matches at start of line.
    if i == 0 and g.match_word(s, i, '@nocolor-node'):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18600">def restartNoColorNode(self, s):
    self.setRestart(self.restartNoColorNode)
    return len(s) + 1
</t>
<t tx="ekr.20110605121601.18601">def match_blanks(self, s, i):
    if 1: # Use Qt code to show invisibles.
        return 0
    else: # Old code...
        if not self.showInvisibles:
            return 0
        j = i; n = len(s)
        while j &lt; n and s[j] == ' ':
            j += 1
        if j &gt; i:
            self.colorRangeWithTag(s, i, j, 'blank')
            return j - i
        else:
            return 0
</t>
<t tx="ekr.20110605121601.18602">def match_doc_part(self, s, i):
    '''
    Colorize Leo's @ and @ doc constructs.
    Matches only at the start of the line.
    '''
    if i != 0:
        return 0
    elif g.match_word(s, i, '@doc'):
        j = i + 4
    elif g.match(s, i, '@') and (i + 1 &gt;= len(s) or s[i + 1] in (' ', '\t', '\n')):
        j = i + 1
    else:
        return 0
    c = self.c
    self.colorRangeWithTag(s, 0, j, 'leokeyword')
    # New in Leo 5.5: optionally colorize doc parts using reStructuredText
    if c.config.getBool('color-doc-parts-as-rest'):
        # Switch langauges.
        self.after_doc_language = self.language
        self.language = 'rest'
        self.clearState()
        self.init(c.p)
        # Restart.
        self.setRestart(self.restartDocPart)
        # Do *not* color the text here!
        return j
    else:
        self.clearState()
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s, j, len(s), 'docpart')
        return len(s)
</t>
<t tx="ekr.20110605121601.18603">def restartDocPart(self, s):
    '''
    Restarter for @ and @ contructs.
    Continue until an @c, @code or @language at the start of the line.
    '''
    for tag in ('@c', '@code', '@language'):
        if g.match_word(s, 0, tag):
            if tag == '@language':
                return self.match_at_language(s, 0)
            else:
                j = len(tag)
                self.colorRangeWithTag(s, 0, j, 'leokeyword') # 'docpart')
                # Switch languages.
                self.language = self.after_doc_language
                self.clearState()
                self.init(self.c.p)
                self.after_doc_language = None
                return j
    # Color the next line.
    self.setRestart(self.restartDocPart)
    if self.c.config.getBool('color-doc-parts-as-rest'):
        # Do *not* colorize the text here.
        return 0
    else:
        self.colorRangeWithTag(s, 0, len(s), 'docpart')
        return len(s)
</t>
<t tx="ekr.20110605121601.18604">def match_leo_keywords(self, s, i):
    '''Succeed if s[i:] is a Leo keyword.'''
    self.totalLeoKeywordsCalls += 1
    if s[i] != '@':
        return 0
    # fail if something besides whitespace precedes the word on the line.
    i2 = i - 1
    while i2 &gt;= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ', '\t'):
            i2 -= 1
        else:
            return 0
    # Get the word as quickly as possible.
    j = i + 1
    while j &lt; len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i + 1: j] # entries in leoKeywordsDict do not start with '@'.
    if j &lt; len(s) and s[j] not in (' ', '\t', '\n'):
        return 0 # Fail, but allow a rescan, as in objective_c.
    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i + 1 # Bug fix: skip the last character.
        self.trace_match(kind, s, i, j)
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s, i, j, kind)
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            return j - i
        else:
            # Bug fix: allow rescan.  Affects @language patch.
            return 0
            # Wrong: return -(j - i + 1)
</t>
<t tx="ekr.20110605121601.18605">def match_section_ref(self, s, i):
    if self.trace_leo_matches:
        g.trace()
    p = self.c.p
    if not g.match(s, i, '&lt;&lt;'):
        return 0
    k = g.find_on_line(s, i + 2, '&gt;&gt;')
    if k == -1:
        return 0
    else:
        j = k + 2
        self.colorRangeWithTag(s, i, i + 2, 'namebrackets')
        ref = g.findReference(s[i: j], p)
        if ref:
            if self.use_hyperlinks:
                &lt;&lt; set the hyperlink &gt;&gt;
            else:
                self.colorRangeWithTag(s, i + 2, k, 'link')
        else:
            self.colorRangeWithTag(s, i + 2, k, 'name')
        self.colorRangeWithTag(s, k, j, 'namebrackets')
        return j - i
</t>
<t tx="ekr.20110605121601.18606"># Set the bindings to VNode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
</t>
<t tx="ekr.20110605121601.18607">def match_tabs(self, s, i):
    if 1: # Use Qt code to show invisibles.
        return 0
    else: # Old code...
        if not self.showInvisibles:
            return 0
        if self.trace_leo_matches: g.trace()
        j = i; n = len(s)
        while j &lt; n and s[j] == '\t':
            j += 1
        if j &gt; i:
            self.colorRangeWithTag(s, i, j, 'tab')
            return j - i
        else:
            return 0
</t>
<t tx="ekr.20110605121601.18608"># Fix bug 893230: URL coloring does not work for many Internet protocols.
# Added support for: gopher, mailto, news, nntp, prospero, telnet, wais
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_g = re.compile(r"""gopher://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex_m = re.compile(r"""mailto://[^\s'"]+[\w=/]""")
url_regex_n = re.compile(r"""(news|nntp)://[^\s'"]+[\w=/]""")
url_regex_p = re.compile(r"""prospero://[^\s'"]+[\w=/]""")
url_regex_t = re.compile(r"""telnet://[^\s'"]+[\w=/]""")
url_regex_w = re.compile(r"""wais://[^\s'"]+[\w=/]""")
kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
url_regex = re.compile(r"""%s://[^\s'"]+[\w=/]""" % (kinds))

def match_any_url(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex)

def match_url_f(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_f)

def match_url_g(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_g)

def match_url_h(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_h)

def match_url_m(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_m)

def match_url_n(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_n)

def match_url_p(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_p)

def match_url_t(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_t)

def match_url_w(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_w)
</t>
<t tx="ekr.20110605121601.18609">def match_compiled_regexp(self, s, i, kind, regexp, delegate=''):
    '''Succeed if the compiled regular expression regexp matches at s[i:].'''
    n = self.match_compiled_regexp_helper(s, i, regexp)
    if n &gt; 0:
        j = i + n
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return n
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18610">def match_compiled_regexp_helper(self, s, i, regex):
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s, i) # re_obj.search(s,i)
    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    return end - start
</t>
<t tx="ekr.20110605121601.18611">def match_eol_span(self, s, i,
    kind=None, seq='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False
):
    '''Succeed if seq matches s[i:]'''
    if at_line_start and i != 0 and s[i - 1] != '\n':
        return 0
    if at_whitespace_end and i != g.skip_ws(s, 0):
        return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars:
        return 0
    if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i + len(seq)] in self.word_chars:
        return 0
    if g.match(s, i, seq):
        j = len(s)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18612">def match_eol_span_regexp(self, s, i,
    kind='', regexp='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False
):
    '''Succeed if the regular expression regex matches s[i:].'''
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    n = self.match_regexp_helper(s, i, regexp)
    if n &gt; 0:
        j = len(s)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return j - i
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18613"># def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):
    # '''Match the entire rest of the string.'''
    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    # return j
</t>
<t tx="ekr.20110605121601.18614"># This is a time-critical method.

def match_keywords(self, s, i):
    '''
    Succeed if s[i:] is a keyword.
    Returning -len(word) for failure greatly reduces the number of times this
    method is called.
    '''
    self.totalKeywordsCalls += 1
    # We must be at the start of a word.
    if i &gt; 0 and s[i - 1] in self.word_chars:
        return 0
    # Get the word as quickly as possible.
    j = i; n = len(s)
    chars = self.word_chars
    # A kludge just for Haskell:
    if self.language in ('haskell','clojure'):
        chars["'"] = "'"
    while j &lt; n and s[j] in chars:
        j += 1
    word = s[i: j]
    # Fix part of #585: A kludge for css.
    if self.language == 'css' and word.endswith(':'):
        j -= 1
        word = word[:-1]
    if not word:
        g.trace('can not happen', repr(s[i: max(j, i + 1)]), repr(s[i: i + 10]), g.callers())
        return 0
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i
        self.trace_match(kind, s, i, j)
        return result
    else:
        return -len(word) # An important new optimization.
</t>
<t tx="ekr.20110605121601.18615">def match_line(self, s, i, kind=None, delegate='', exclude_match=False):
    '''Match the rest of the line.'''
    j = g.skip_to_end_of_line(s, i)
    self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
    return j - i
</t>
<t tx="ekr.20110605121601.18616">def match_mark_following(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Succeed if s[i:] matches pattern.'''
    if not self.allow_mark_prev: return 0
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 &lt; len(s) and s[i + len(pattern)] in self.word_chars:
        return 0 # 7/5/2008
    if g.match(s, i, pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s, j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k &gt; j:
            self.colorRangeWithTag(s, i, j, kind, exclude_match=exclude_match)
            self.colorRangeWithTag(s, j, k, kind, exclude_match=False)
            j = k
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            return j - i
        else:
            return 0
    else:
        return 0
</t>
<t tx="ekr.20110605121601.18617">def getNextToken(self, s, i):
    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?
    i0 = i
    while i &lt; len(s) and s[i].isspace():
        i += 1
    i1 = i
    while i &lt; len(s) and s[i] in self.word_chars:
        i += 1
    if i == i1:
        return i0
    else:
        # 2011/05/31: was i+1
        return min(len(s), i)
</t>
<t tx="ekr.20110605121601.18618">def match_mark_previous(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''
    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
</t>
<t tx="ekr.20110605121601.18619">def match_regexp_helper(self, s, i, pattern):
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
    try:
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        re_obj = re.compile(pattern, flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0
    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s, i) # re_obj.search(s,i)
    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        return end - start
</t>
<t tx="ekr.20110605121601.18620">def match_seq(self, s, i,
    kind='', seq='',
    at_line_start=False,
    at_whitespace_end=False,
    at_word_start=False,
    delegate=''
):
    '''Succeed if s[:] mathces seq.'''
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i + len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s, i, seq):
        j = i + len(seq)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
    else:
        j = i
    return j - i
</t>
<t tx="ekr.20110605121601.18621">def match_seq_regexp(self, s, i,
    kind='', regexp='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate=''
):
    '''Succeed if the regular expression regexp matches at s[i:].'''
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0
    n = self.match_regexp_helper(s, i, regexp)
    j = i + n
    assert(j - i == n)
    self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
    self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    return j - i
</t>
<t tx="ekr.20110605121601.18622">def match_span(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False
):
    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''
    dots = False # A flag that we are using dots as a continuation.
    if i &gt;= len(s):
        return 0
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i &gt; 0 and s[i - 1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 &lt; len(s) and s[i + len(begin)] in self.word_chars:
        j = i
    elif not g.match(s, i, begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s, i + len(begin), end,
            no_escape, no_line_break, no_word_break=no_word_break)
        if j == -1:
            j = i # A real failure.
        else:
            # A hack to handle continued strings. Should work for most languages.
            # Prepend "dots" to the kind, as a flag to setTag.
            dots = j &gt; len(s) and begin in "'\"" and end in "'\"" and kind.startswith('literal')
            dots = dots and self.language not in ('lisp', 'elisp')
            if dots:
                kind = 'dots'+kind
            # A match
            i2 = i + len(begin); j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s, i, i2, kind, delegate=None, exclude_match=exclude_match)
                self.colorRangeWithTag(s, i2, j, kind, delegate=delegate, exclude_match=exclude_match)
                self.colorRangeWithTag(s, j, j2, kind, delegate=None, exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
            j = j2
            self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    # New in Leo 5.5: don't recolor everything after continued strings.
    if j &gt; len(s) and not dots:
        j = len(s) + 1

        def span(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keyword args.
            delegate=delegate, end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    return j - i # Correct, whatever j is.
</t>
<t tx="ekr.20110605121601.18623">def match_span_helper(self, s, i, pattern, no_escape, no_line_break, no_word_break):
    '''
    Return n &gt;= 0 if s[i] ends with a non-escaped 'end' string.
    '''
    esc = self.escape
    while 1:
        j = s.find(pattern, i)
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s) + 1
        elif no_word_break and j &gt; 0 and s[j - 1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i: j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k &gt;= 0 and s[j - k] == esc:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                assert s[j - 1] == esc
                i += 1 # 2013/08/26: just advance past the *one* escaped character.
            else:
                return j
        else:
            return j
</t>
<t tx="ekr.20110605121601.18624">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    '''Remain in this state until 'end' is seen.'''
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20110605121601.18625">def match_span_regexp(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False,
):
    '''Succeed if s[i:] starts with 'begin' (a regular expression) and
    contains a following 'end'.
    '''
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 &lt; len(s) and s[i + len(begin)] in self.word_chars:
        return 0 # 7/5/2008
    n = self.match_regexp_helper(s, i, begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n &gt; 0:
        j = i + n
        j2 = s.find(end, j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k &gt;= 0 and s[j - k] == self.escape:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s, i, j, kind, delegate=None, exclude_match=exclude_match)
            self.colorRangeWithTag(s, j, i2, kind, delegate=delegate, exclude_match=False)
            self.colorRangeWithTag(s, i2, j2, kind, delegate=None, exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j2)
        return j2 - i
    else: return 0
</t>
<t tx="ekr.20110605121601.18626">def match_word_and_regexp(self, s, i,
    kind1='', word='',
    kind2='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Succeed if s[i:] matches pattern.'''
    if not self.allow_mark_prev: return 0
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 &lt; len(s) and s[i + len(word)] in self.word_chars:
        j = i
    if not g.match(s, i, word):
        return 0
    j = i + len(word)
    n = self.match_regexp_helper(s, j, pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s, i, j, kind1, exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s, j, k, kind2, exclude_match=False)
    self.prev = (j, k, kind2)
    self.trace_match(kind1, s, i, j)
    self.trace_match(kind2, s, j, k)
    return k - i
</t>
<t tx="ekr.20110605121601.18627">def skip_line(self, s, i):
    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i &lt; len(s):
            j = g.skip_line(s, i)
            if not g.match(s, j - n, escape):
                return j
            i = j
        return i
    else:
        return g.skip_line(s, i)
            # Include the newline so we don't get a flash at the end of the line.
</t>
<t tx="ekr.20110605121601.18628">def trace_match(self, kind, s, i, j):

    if j != i and self.trace_match_flag:
        g.trace(kind, i, j, g.callers(2), self.dump(s[i: j]))
</t>
<t tx="ekr.20110605121601.18629"></t>
<t tx="ekr.20110605121601.18630">def clearState(self):
    '''
    Create a *language-specific* default state.
    This properly forces a full recoloring when @language changes.
    '''
    n = self.initialStateNumber
    self.setState(n)
    return n
</t>
<t tx="ekr.20110605121601.18631">def computeState(self, f, keys):
    '''
    Compute the state name associated with f and all the keys.
    Return a unique int n representing that state.
    '''
    # Abbreviate arg names.
    d = {
        'delegate': '=&gt;',
        'end': 'end',
        'at_line_start': 'start',
        'at_whitespace_end': 'ws-end',
        'exclude_match': '!match',
        'no_escape': '!esc',
        'no_line_break': '!lbrk',
        'no_word_break': '!wbrk',
    }
    result = [self.languageTag(self.language)]
    if not self.rulesetName.endswith('_main'):
        result.append(self.rulesetName)
    if f:
        result.append(f.__name__)
    for key in sorted(keys):
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key, val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None, ''):
            result.append('%s=%s' % (key, keyVal))
    state = ';'.join(result).lower()
    table = (
        ('kind=', ''),
        ('literal', 'lit'),
        ('restart', '@'),
    )
    for pattern, s in table:
        state = state.replace(pattern, s)
    n = self.stateNameToStateNumber(f, state)
    return n
</t>
<t tx="ekr.20110605121601.18632">def currentBlockNumber(self):
    block = self.highlighter.currentBlock()
    return block.blockNumber() if block and block.isValid() else -1

def currentState(self):
    return self.highlighter.currentBlockState()

def prevState(self):
    return self.highlighter.previousBlockState()

def setState(self, n):
    self.highlighter.setCurrentBlockState(n)
    return n
</t>
<t tx="ekr.20110605121601.18633">def setRestart(self, f, **keys):
    n = self.computeState(f, keys)
    self.setState(n)
    return n

</t>
<t tx="ekr.20110605121601.18635">def showState(self, n):
    state = self.stateDict.get(n, 'no-state')
    return '%2s:%s' % (n, state)

def showCurrentState(self):
    n = self.currentState()
    return self.showState(n)

def showPrevState(self):
    n = self.prevState()
    return self.showState(n)
</t>
<t tx="ekr.20110605121601.18636">def stateNameToStateNumber(self, f, stateName):
    '''
    stateDict:     Keys are state numbers, values state names.
    stateNameDict: Keys are state names, values are state numbers.
    restartDict:   Keys are state numbers, values are restart functions
    '''
    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        self.n2languageDict [n] = self.language
    return n
</t>
<t tx="ekr.20110605121601.18637">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''
    trace = 'coloring' in g.app.debug
        # A superb trace: enable this first to see what gets colored.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    if delegate:
        if trace:
            if len(repr(s[i: j])) &lt;= 20:
                s2 = repr(s[i: j])
            else:
                s2 = repr(s[i: i + 17 - 2] + '...')
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate, tag)), i, j, s2, g.callers(2)))
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    i += n; break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = repr(s[i: j]) if len(repr(s[i: j])) &lt;= 20 else repr(s[i: i + 17 - 2] + '...')
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language, tag)), i, j, s2, g.callers(2)))
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh': # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20110605121601.18638">def mainLoop(self, n, s):
    '''Colorize a *single* line s, starting in state n.'''
    f = self.restartDict.get(n)
    i = f(s) if f else 0
    while i &lt; len(s):
        progress = i
        functions = self.rulesDict.get(s[i], [])
        # g.printList(functions)
        for f in functions:
            n = f(self, s, i)
            if n is None:
                g.trace('Can not happen: n is None', repr(f))
                break
            elif n &gt; 0: # Success. The match has already been colored.
                i += n
                break
            elif n &lt; 0: # Total failure.
                i += -n
                break
            else: # Partial failure: Do not break or change i!
                pass
        else:
            i += 1
        assert i &gt; progress
    # Don't even *think* about changing state here.
</t>
<t tx="ekr.20110605121601.18640">def recolor(self, s):
    '''
    jEdit.recolor: Recolor a *single* line, s.
    QSyntaxHighligher calls this method repeatedly and automatically.
    '''
    p = self.c.p
    self.recolorCount += 1
    block_n = self.currentBlockNumber()
    n = self.prevState()
    if p.v != self.old_v:
        self.updateSyntaxColorer(p) # Force a full recolor
        assert self.language
        self.init_all_state(p.v)
        self.init(p)
    else:
        new_language = self.n2languageDict.get(n)
        if new_language != self.language:
            self.language = new_language
            self.init(p)
    if block_n == 0:
        n = self.initBlock0()
    n = self.setState(n) # Required.
    # Always color the line, even if colorizing is disabled.
    if s:
        self.mainLoop(n, s)
</t>
<t tx="ekr.20110605121601.18641">def setTag(self, tag, s, i, j):
    '''Set the tag in the highlighter.'''
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper # A QTextEditWrapper
    tag = tag.lower() # 2011/10/28
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots'):]
    colorName = wrapper.configDict.get(tag)
    # Munge the color name.
    if not colorName:
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[: -1]
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name', colorName, g.callers())
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20111002125540.7021">def getYScrollPosition(self):
    '''Get the vertical scrollbar position.'''
    w = self
    sb = w.verticalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setYScrollPosition(self, pos):
    '''Set the position of the vertical scrollbar.'''
    w = self
    if pos is None: pos = 0
    sb = w.verticalScrollBar()
    sb.setSliderPosition(pos)
</t>
<t tx="ekr.20111024091133.16702">def configure_hard_tab_width(self):
    '''Set the width of a hard tab.
    The stated default is 40, but apparently it must be set explicitly.
    '''
    c, widget, wrapper = self.c, self.widget, self.wrapper
    # For some reason, the size is not accurate.
    if isinstance(widget, QtWidgets.QTextEdit):
        font = wrapper.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point * size * c.tab_width))
        wrapper.widget.setTabStopWidth(hard_tab_width)
    else:
        # To do: configure the QScintilla widget.
        pass
</t>
<t tx="ekr.20111028060955.16565">def getMenuEntryInfo(self, data, menu):
    done = False
    if g.isString(data):
        # A single string is both the label and the command.
        s = data
        removeHyphens = s and s[0] == '*'
        if removeHyphens: s = s[1:]
        label = self.capitalizeMinibufferMenuName(s, removeHyphens)
        command = s.replace('&amp;', '').lower()
        if label == '-':
            self.add_separator(menu)
            done = True # That's all.
    else:
        ok = isinstance(data, (list, tuple)) and len(data) in (2, 3)
        if ok:
            if len(data) == 2:
                # Command can be a minibuffer-command name.
                label, command = data
            else:
                # Ignore shortcuts bound in menu tables.
                label, junk, command = data
            if label in (None, '-'):
                self.add_separator(menu)
                done = True # That's all.
        else:
            g.trace('bad data in menu table: %s' % repr(data))
            done = True # Ignore bad data
    return label, command, done
</t>
<t tx="ekr.20111028060955.16568">def getMenuEntryBindings(self, command, dynamicMenu, label):
    '''Compute commandName from command.'''
    c = self.c
    if g.isString(command):
        # Command is really a command name.
        commandName = command
    else:
        # First, get the old-style name.
        commandName = self.computeOldStyleShortcutKey(label)
    command = c.commandsDict.get(commandName)
    return commandName
</t>
<t tx="ekr.20111114151846.9847">def toPythonIndex(s, index):
    '''Convert index to a Python int.

    index may be a Tk index (x.y) or 'end'.
    '''
    if index is None:
        return 0
    elif g.isInt(index):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return len(s)
    else:
        data = index.split('.')
        if len(data) == 2:
            row, col = data
            row, col = int(row), int(col)
            i = g.convertRowColToPythonIndex(s, row - 1, col)
            return i
        else:
            g.trace('bad string index: %s' % index)
            return 0
</t>
<t tx="ekr.20120110174009.9965">def shouldPromptForDangerousWrite(self, fn, p):
    '''
    Return True if a prompt should be issued
    when writing p (an @&lt;file&gt; node) to fn.
    '''
    if not g.os_path_exists(fn):
        # No danger of overwriting fn.
        return False
    elif hasattr(p.v, 'at_read'):
        # Fix bug #50: body text lost switching @file to @auto-rst
        d = p.v.at_read
        aSet = d.get(fn, set())
        return p.h not in aSet
    else:
        return True
            # The file was never read.
</t>
<t tx="ekr.20120112084820.10001">def rememberReadPath(self, fn, p):
    '''
    Remember the files that have been read *and*
    the full headline (@&lt;file&gt; type) that caused the read.
    '''
    v = p.v
    # Fix bug #50: body text lost switching @file to @auto-rst
    if not hasattr(v, 'at_read'):
        v.at_read = {}
    d = v.at_read
    aSet = d.get(fn, set())
    aSet.add(p.h)
    d[fn] = aSet
</t>
<t tx="ekr.20120129181245.10220">class TypedDict(object):
    '''A class containing a name and enforcing type checking.'''
    @others

def isTypedDict(obj):
    return isinstance(obj, TypedDict)

class TypedDictOfLists(TypedDict):
    '''A class whose values are lists of typed values.'''

    def __init__(self, name, keyType, valType):
        TypedDict.__init__(self, name, keyType, valType) # Init the base class
        self.isList = True

    def __repr__(self):
        return '&lt;TypedDictOfLists name:%s keys:%s values:%s len(keys): %s' % (
            self._name, self.keyType.__name__, self.valType.__name__, len(list(self.keys())))

    __str__ = __repr__

    def copy(self, name=None):
        d = TypedDictOfLists(name or self._name, self.keyType, self.valType)
        d.d = dict(self.d)
        return d

def isTypedDictOfLists(obj):
    return isinstance(obj, TypedDictOfLists)
</t>
<t tx="ekr.20120205022040.17769">def __init__(self, name, keyType, valType):

    self.d = {}
    self.isList = False
    self._name = name # name is a method.
    self.keyType = keyType
    self.valType = valType
</t>
<t tx="ekr.20120205022040.17770">def __repr__(self):
    return '&lt;TypedDict name:%s keys:%s values:%s len(keys): %s' % (
        self._name, self.keyType.__name__, self.valType.__name__, len(list(self.keys())))

__str__ = __repr__
</t>
<t tx="ekr.20120205022040.17771">def get(self, key, default=None):
    self._checkKeyType(key)
    if default is None and self.isList:
        default = []
    return self.d.get(key, default)
    
# New in Leo 5.7.1
def get_setting(self, key):
    key = key.replace('-','').replace('_','')
    gs = self.get(key)
    val = gs and gs.val
    return val
    
# New in Leo 5.7.1
def get_string_setting(self, key):
    val = self.get_setting(key)
    return g.toUnicode(val) if val and g.isString(val) else None

def keys(self):
    return self.d.keys()

def name(self):
    return self._name
</t>
<t tx="ekr.20120205022040.17774">def add(self, key, val):
    if key is None:
        g.trace('TypeDict: None is not a valid key', g.callers())
        return
    self._checkKeyType(key)
    self._checkValType(val)
    if self.isList:
        aList = self.d.get(key, [])
        if val not in aList:
            aList.append(val)
            self.d[key] = aList
    else:
        self.d[key] = val

def replace(self, key, val):
    if key is None:
        g.trace('TypeDict: None is not a valid key', g.callers())
        return
    self._checkKeyType(key)
    if self.isList:
        try:
            for z in val:
                self._checkValType(z)
        except TypeError:
            self._checkValType(val) # val is not iterable.
        self.d[key] = val
    else:
        self._checkValType(val)
        self.d[key] = val

__setitem__ = replace # allow d[key] = val.
</t>
<t tx="ekr.20120205022040.17807">def update(self, d):
    if isinstance(d, TypedDict):
        self.d.update(d.d)
    else:
        self.d.update(d)
</t>
<t tx="ekr.20120206134955.10150">def _checkKeyType(self, key):
    # These fail on Python 2.x for strings.
    if g.isPython3:
        if key and key.__class__ != self.keyType:
            self._reportTypeError(key, self.keyType)

def _checkValType(self, val):
    # This doesn't fail, either on Python 2.x or 3.x.
    assert val.__class__ == self.valType, self._reportTypeError(val, self.valType)

def _reportTypeError(self, obj, objType):
    print('obj', obj, 'obj.__class__', obj.__class__, 'objType', objType)
    return 'dict: %s expected %s got %s' % (
        self._name, obj.__class__.__name__, objType.__name__)
</t>
<t tx="ekr.20120206134955.10151">def dump(self):
    result = ['Dump of %s' % (self)]
    for key in sorted(self.d.keys()):
        if self.isList:
            result.append(key)
            aList = self.d.get(key, [])
            for z in aList:
                result.append('  ' + repr(z))
        else:
            result.append(key, self.d.get(key))
    return '\n'.join(result)
</t>
<t tx="ekr.20120212060348.10374">in_bridge = False
    # Set to True in leoBridge.py just before importing leo.core.leoApp.
    # This tells leoApp to load a null Gui.
SQLITE = True
    # True: Enable SQLite DB.
pygments = True
print('\n ===== g.pygments: %s' % pygments)
</t>
<t tx="ekr.20120214165710.10728">def setName(self, name):
    self._name = name
</t>
<t tx="ekr.20120215072959.12520">def getValFromDict(self, d, setting, requestedType, warn=True):
    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''
    gs = d.get(g.app.config.munge(setting))
    if not gs: return None, False
    assert g.isGeneralSetting(gs), gs
    val = gs.val
    # 2011/10/24: test for an explicit None.
    if g.isPython3:
        isNone = val in ('None', 'none', '') # ,None)
    else:
        isNone = val in (
            g.u('None'), g.u('none'), g.u(''),
            'None', 'none', '') #,None)
    if not self.typesMatch(gs.kind, requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.error('warning: ignoring', gs.kind, '', setting, 'is not', requestedType)
            g.error('there may be conflicting settings!')
        return None, False
    elif isNone:
        return '', True
            # 2011/10/24: Exists, a *user-defined* empty value.
    else:
        return val, True
</t>
<t tx="ekr.20120215072959.12527">def getData(self, setting, strip_comments=True, strip_data=True):
    '''Return a list of non-comment strings in the body text of @data setting.'''
    # 904: Add local abbreviations to global settings.
    append = setting == 'global-abbreviations'
    if append:
        data0 = g.app.config.getData(setting,
            strip_comments=strip_comments,
            strip_data=strip_data,
        )
    data = self.get(setting, "data")
    # New in Leo 4.11: parser.doData strips only comments now.
    # New in Leo 4.12: parser.doData strips *nothing*.
    if g.isString(data):
        data = [data]
    if data and strip_comments:
        data = [z for z in data if not z.strip().startswith('#')]
    if data and strip_data:
        data = [z.strip() for z in data if z.strip()]
    if append and data != data0:
        if data:
            data.extend(data0)
        else:
            data = data0
    return data
</t>
<t tx="ekr.20120215072959.12539">def getShortcut(self, commandName):
    '''Return rawKey,accel for shortcutName'''
    c = self.c
    d = self.shortcutsDict
    if not c.frame.menu:
        g.trace('no menu: %s' % (commandName))
        return None, []
    if d:
        assert g.isTypedDictOfLists(d), d
        key = c.frame.menu.canonicalizeMenuName(commandName)
        key = key.replace('&amp;', '') # Allow '&amp;' in names.
        aList = d.get(commandName, [])
        if aList: # A list of g.BindingIndo objects.
            # It's important to filter empty strokes here.
            aList = [z for z in aList
                if z.stroke and z.stroke.lower() != 'none']
        return key, aList
    else:
        # lm.readGlobalSettingsFiles is opening a settings file.
        # lm.readGlobalSettingsFiles has not yet set lm.globalSettingsDict.
        return None, []
</t>
<t tx="ekr.20120217070122.10470">@nobeautify

def initObjects(self, gui):

    c = self
    gnx = 'hidden-root-vnode-gnx'
    assert not hasattr(c, 'fileCommands'), c.fileCommands

    class DummyFileCommands:
        def __init__(self):
            self.gnxDict = {}

    c.fileCommands = DummyFileCommands()
    self.hiddenRootNode = leoNodes.VNode(context=c, gnx=gnx)
    self.hiddenRootNode.h = g.u('&lt;hidden root vnode&gt;')
    c.fileCommands = None
    # Create the gui frame.
    title = c.computeWindowTitle(c.mFileName)
    if not g.app.initing:
        g.doHook("before-create-leo-frame", c=c)
    self.frame = gui.createLeoFrame(c, title)
    assert self.frame
    assert self.frame.c == c
    import leo.core.leoHistory as leoHistory
    self.nodeHistory = leoHistory.NodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.
    # Break circular import dependencies by doing imports here.
    # These imports take almost 3/4 sec in the leoBridge.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoBeautify as leoBeautify # So decorators are executed.
    assert leoBeautify # for pyflakes.
    import leo.core.leoChapters as leoChapters
    # User commands...
    import leo.commands.abbrevCommands as abbrevCommands
    import leo.commands.checkerCommands as checkerCommands
    assert checkerCommands
        # To suppress a pyflakes warning.
        # The import *is* required to define commands.
    import leo.commands.controlCommands as controlCommands
    import leo.commands.convertCommands as convertCommands
    import leo.commands.debugCommands as debugCommands
    import leo.commands.editCommands as editCommands
    import leo.commands.editFileCommands as editFileCommands
    import leo.commands.gotoCommands as gotoCommands
    import leo.commands.helpCommands as helpCommands
    import leo.commands.keyCommands as keyCommands
    import leo.commands.killBufferCommands as killBufferCommands
    import leo.commands.rectangleCommands as rectangleCommands
    import leo.commands.spellCommands as spellCommands
    # Import files to execute @g.commander_command decorators
    import leo.core.leoCompare as leoCompare
    assert leoCompare
    import leo.core.leoDebugger as leoDebugger
    assert leoDebugger
    import leo.commands.commanderEditCommands as commanderEditCommands
    assert commanderEditCommands
    import leo.commands.commanderFileCommands as commanderFileCommands
    assert commanderFileCommands
    import leo.commands.commanderFindCommands as commanderFindCommands
    assert commanderFindCommands
    import leo.commands.commanderHelpCommands as commanderHelpCommands
    assert commanderHelpCommands
    import leo.commands.commanderOutlineCommands as commanderOutlineCommands
    assert commanderOutlineCommands
    # Other subcommanders.
    import leo.core.leoFind as leoFind # Leo 4.11.1
    import leo.core.leoKeys as leoKeys
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoPersistence as leoPersistence
    import leo.core.leoPrinting as leoPrinting
    import leo.core.leoRst as leoRst
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoTest as leoTest
    import leo.core.leoUndo as leoUndo
    import leo.core.leoVim as leoVim
    # Define the subcommanders.
    self.keyHandler = self.k    = leoKeys.KeyHandlerClass(c)
    self.chapterController      = leoChapters.ChapterController(c)
    self.shadowController       = leoShadow.ShadowController(c)
    self.fileCommands           = leoFileCommands.FileCommands(c)
    self.findCommands           = leoFind.LeoFind(c)
    self.atFileCommands         = leoAtFile.AtFile(c)
    self.importCommands         = leoImport.LeoImportCommands(c)
    self.persistenceController  = leoPersistence.PersistenceDataController(c)
    self.printingController     = leoPrinting.PrintingController(c)
    self.rstCommands            = leoRst.RstCommands(c)
    self.tangleCommands         = leoTangle.TangleCommands(c)
    self.testManager            = leoTest.TestManager(c)
    self.vimCommands            = leoVim.VimCommands(c)
    # User commands
    self.abbrevCommands     = abbrevCommands.AbbrevCommandsClass(c)
    self.controlCommands    = controlCommands.ControlCommandsClass(c)
    self.convertCommands    = convertCommands.ConvertCommandsClass(c)
    self.debugCommands      = debugCommands.DebugCommandsClass(c)
    self.editCommands       = editCommands.EditCommandsClass(c)
    self.editFileCommands   = editFileCommands.EditFileCommandsClass(c)
    self.gotoCommands       = gotoCommands.GoToCommands(c)
    self.helpCommands       = helpCommands.HelpCommandsClass(c)
    self.keyHandlerCommands = keyCommands.KeyHandlerCommandsClass(c)
    self.killBufferCommands = killBufferCommands.KillBufferCommandsClass(c)
    self.rectangleCommands  = rectangleCommands.RectangleCommandsClass(c)
    self.spellCommands      = spellCommands.SpellCommandsClass(c)
    self.undoer             = leoUndo.Undoer(c)
    # Create the list of subcommanders.
    self.subCommanders = [
        self.abbrevCommands,
        self.atFileCommands,
        self.chapterController,
        self.controlCommands,
        self.convertCommands,
        self.debugCommands,
        self.editCommands,
        self.editFileCommands,
        self.fileCommands,
        self.findCommands,
        self.gotoCommands,
        self.helpCommands,
        self.importCommands,
        self.keyHandler,
        self.keyHandlerCommands,
        self.killBufferCommands,
        self.persistenceController,
        self.printingController,
        self.rectangleCommands,
        self.rstCommands,
        self.shadowController,
        self.spellCommands,
        self.tangleCommands,
        self.testManager,
        self.vimCommands,
        self.undoer,
    ]
    # Other objects
    c.configurables = c.subCommanders[:]
        # A list of other classes that have a reloadSettings method
    c.db = g.app.commander_cacher.get_wrapper(c)
    import leo.plugins.free_layout as free_layout
    self.free_layout = free_layout.FreeLayoutController(c)
    if hasattr(g.app.gui, 'styleSheetManagerClass'):
        self.styleSheetManager = g.app.gui.styleSheetManagerClass(c)
        self.subCommanders.append(self.styleSheetManager)
    else:
        self.styleSheetManager = None
</t>
<t tx="ekr.20120217070122.10473">def initCommandIvars(self):
    '''Init ivars used while executing a command.'''
    self.commandsDict = {}
        # Keys are command names, values are functions.
    self.disableCommandsMessage = ''
        # The presence of this message disables all commands.
    self.hookFunction = None
        # One of three places that g.doHook looks for hook functions.
    self.ignoreChangedPaths = False
        # True: disable path changed message in at.WriteAllHelper.
    self.inCommand = False
        # Interlocks to prevent premature closing of a window.
    self.isZipped = False
        # Set by g.openWithFileName.
    self.outlineToNowebDefaultFileName = "noweb.nw"
        # For Outline To Noweb dialog.
    # For tangle/untangle
    self.tangle_errors = 0
    # Default Tangle options
    self.use_header_flag = False
    self.output_doc_flag = False
    # For hoist/dehoist commands.
    self.hoistStack = []
        # Stack of nodes to be root of drawn tree.
        # Affects drawing routines and find commands.
    # For outline navigation.
    self.navPrefix = g.u('') # Must always be a string.
    self.navTime = None

    self.sqlite_connection = None
</t>
<t tx="ekr.20120219194520.10463">import leo.core.leoGlobals as g
import leo.core.leoExternalFiles as leoExternalFiles
try:
    import builtins # Python 3
except ImportError:
    import __builtin__ as builtins # Python 2.
# import glob
import importlib
import io
import os
import optparse
import subprocess
import string
import sys
import time
import traceback
import zipfile
import platform
if g.isPython3:
    StringIO = io.StringIO
else:
    import cStringIO
    StringIO = cStringIO.StringIO
import sqlite3
</t>
<t tx="ekr.20120222103014.10312">def openSettingsFile(self, fn):
    '''
    Open a settings file with a null gui.  Return the commander.

    The caller must init the c.config object.
    '''
    lm = self
    if not fn:
        return None
    theFile = lm.openLeoOrZipFile(fn)
    if not theFile:
        return None # Fix #843.
    if not any([g.app.unitTesting, g.app.silentMode, g.app.batchMode]):
        # This occurs early in startup, so use the following.
        s = 'reading settings in %s' % (fn)
        if not g.isPython3:
                s = g.toEncodedString(s, 'ascii')
        if 'startup' in g.app.debug:
            print(s)
        g.es(s, color='blue')
    # Changing g.app.gui here is a major hack.  It is necessary.
    oldGui = g.app.gui
    g.app.gui = g.app.nullGui
    c = g.app.newCommander(fn)
    frame = c.frame
    frame.log.enable(False)
    g.app.lockLog()
    g.app.openingSettingsFile = True
    try:
        ok =  c.fileCommands.openLeoFile(theFile, fn,
                readAtFileNodesFlag=False, silent=True)
                    # closes theFile.
    finally:
        g.app.openingSettingsFile = False
    g.app.unlockLog()
    c.openDirectory = frame.openDirectory = g.os_path_dirname(fn)
    g.app.gui = oldGui
    return c if ok else None
</t>
<t tx="ekr.20120222103014.10314">def config_iter(self, c):
    '''Letters:
      leoSettings.leo
    D default settings
    F loaded .leo File
    M myLeoSettings.leo
    @ @button, @command, @mode.
    '''
    lm = g.app.loadManager
    d = c.config.settingsDict if c else lm.globalSettingsDict
    limit = c.config.getInt('print-settings-at-data-limit')
    if limit is None:
        limit = 20 # A resonable default.
    # pylint: disable=len-as-condition
    for key in sorted(list(d.keys())):
        gs = d.get(key)
        assert g.isGeneralSetting(gs), gs
        if gs and gs.kind:
            letter = lm.computeBindingLetter(gs.path)
            val = gs.val
            if gs.kind == 'data':
                # #748: Remove comments
                aList = [' '*8 + z.rstrip() for z in val
                    if z.strip() and not z.strip().startswith('#')]
                if not aList:
                    val = '[]'
                elif limit == 0 or len(aList) &lt; limit:
                    val = '\n    [\n' + '\n'.join(aList) + '\n    ]'
                    # The following doesn't work well.
                    # val = g.objToString(aList, indent=' '*4)
                else:
                    val = '&lt;%s non-comment lines&gt;' % len(aList)
            elif g.isString(val) and val.startswith('&lt;?xml'):
                val = '&lt;xml&gt;'
            key2 = '@%-6s %s' % (gs.kind, key)
            yield key2, val, c, letter
</t>
<t tx="ekr.20120223062418.10410">def openZipFile(self, fn):
    # lm = self
    try:
        theFile = zipfile.ZipFile(fn, 'r')
        if not theFile: return None
        # Read the file into an StringIO file.
        aList = theFile.namelist()
        name = aList and len(aList) == 1 and aList[0]
        if not name: return None
        s = theFile.read(name)
        if g.isPython3: s = g.ue(s, 'utf-8')
        return StringIO(s)
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.error("can not open:", fn)
        return None
</t>
<t tx="ekr.20120223062418.10422">def copy(self, name=None):
    '''Return a new dict with the same contents.'''
    d = TypedDict(name or self._name, self.keyType, self.valType)
    d.d = dict(self.d)
    return d
</t>
<t tx="ekr.20120320053907.9776">def computeFileUrl(fn, c=None, p=None):
    '''
    Compute finalized url for filename fn.
    This involves adding url escapes and evaluating Leo expressions.
    '''
    if 1:
        # pylint: disable=no-member
        unquote = urllib.parse.unquote if isPython3 else urllib.unquote
    # First, replace special characters (especially %20, by their equivalent).
    url = unquote(fn)
    # Finalize the path *before* parsing the url.
    i = url.find('~')
    if i &gt; -1:
        # Expand '~' and handle Leo expressions.
        path = url[i:]
        path = g.os_path_expanduser(path)
        path = g.os_path_expandExpression(path, c=c)
        path = g.os_path_finalize(path)
        url = url[: i] + path
    else:
        # Handle Leo expressions.
        tag = 'file://'
        tag2 = 'file:///'
        if sys.platform.startswith('win') and url.startswith(tag2):
            path = url[len(tag2):].lstrip()
        elif url.startswith(tag):
            path = url[len(tag):].lstrip()
        else:
            path = url
        path = g.os_path_expandExpression(path, c=c)
        # Handle ancestor @path directives.
        if c and c.openDirectory:
            base = c.getNodePath(p)
            path = g.os_path_finalize_join(c.openDirectory, base, path)
        else:
            path = g.os_path_finalize(path)
        url = '%s%s' % (tag, path)
    return url
</t>
<t tx="ekr.20120409185504.10028"># Remove trailing newlines before warning of truncation.
while s and s[-1] == '\n':
    s = s[: -1]
# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    s = s[: i]
    if s != oldHead:
        g.warning("truncating headline to one line")
limit = 1000
if len(s) &gt; limit:
    s = s[: limit]
    if s != oldHead:
        g.warning("truncating headline to", limit, "characters")
</t>
<t tx="ekr.20120912094259.10546">def makeTestClass(self, p):
    """Create a subclass of unittest.TestCase"""
    c, tm = self.c, self
    fname = 'makeTestClass'
    p = p.copy()
    script = g.getScript(c, p).strip()
    if not script:
        print("nothing in %s" % p.h)
        return None
    try:
        script = script + tm.get_test_class_script()
        script = script + tm.get_suite_script()
        d = {'c': c, 'g': g, 'p': p, 'unittest': unittest}
        if c.write_script_file:
            scriptFile = c.writeScriptFile(script)
            # pylint: disable=no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script + '\n', d)
        testclass = g.app.scriptDict.get('testclass')
        suite = g.app.scriptDict.get('suite')
        if suite and testclass:
            print("\n%s: both 'suite' and 'testclass defined in %s" % (
                fname, p.h))
        elif testclass:
            suite = unittest.TestLoader().loadTestsFromTestCase(testclass)
            return suite
        elif suite:
            return suite
        else:
            print("\n%s: neither 'suite' nor 'testclass' defined in %s" % (
                fname, p.h))
            return None
    except Exception:
        print('\n%s: exception creating test class in %s' % (fname, p.h))
        g.es_print_exception()
        return None
</t>
<t tx="ekr.20120925061642.13506">def onSliderChanged(self, arg):
    '''Handle a Qt onSliderChanged event.'''
    c = self.leo_c
    p = c.p
    # Careful: changing nodes changes the scrollbars.
    if hasattr(c.frame.tree, 'tree_select_lockout'):
        if c.frame.tree.tree_select_lockout:
            return
    # Only scrolling in the body pane should set v.scrollBarSpot.
    if not c.frame.body or self != c.frame.body.wrapper.widget:
        return
    if p:
        p.v.scrollBarSpot = arg
</t>
<t tx="ekr.20130804061744.12425">if 0: # Override for debugging only.

    def setWindowTitle(self, s):
        g.trace('***(DynamicWindow)', s, self.parent())
        # Call the base class method.
        QtWidgets.QMainWindow.setWindowTitle(self, s)
</t>
<t tx="ekr.20130911110233.11284">def readFileToUnicode(self, fileName):
    '''
    Carefully sets at.encoding, then uses at.encoding to convert the file
    to a unicode string.

    Sets at.encoding as follows:
    1. Use the BOM, if present. This unambiguously determines the encoding.
    2. Use the -encoding= field in the @+leo header, if present and valid.
    3. Otherwise, uses existing value of at.encoding, which comes from:
        A. An @encoding directive, found by at.scanAllDirectives.
        B. The value of c.config.default_derived_file_encoding.

    Returns the string, or None on failure.
    '''
    at = self
    s = at.openFileHelper(fileName)
    if s is not None:
        e, s = g.stripBOM(s)
        if e:
            # The BOM determines the encoding unambiguously.
            s = g.toUnicode(s, encoding=e)
        else:
            # Get the encoding from the header, or the default encoding.
            s_temp = g.toUnicode(s, 'ascii', reportErrors=False)
            e = at.getEncodingFromHeader(fileName, s_temp)
            s = g.toUnicode(s, encoding=e)
        s = s.replace('\r\n', '\n')
        at.encoding = e
        at.initReadLine(s)
    return s
</t>
<t tx="ekr.20130911110233.11285">def openFileHelper(self, fileName):
    '''Open a file, reporting all exceptions.'''
    at = self
    s = None
    try:
        with open(fileName, 'rb') as f:
            s = f.read()
    except IOError:
        at.error('can not open %s' % (fileName))
    except Exception:
        at.error('Exception reading %s' % (fileName))
        g.es_exception()
    return s
</t>
<t tx="ekr.20130911110233.11286">def initReadLine(self, s):
    '''Init the ivars so that at.readLine will read all of s.'''
    at = self
    at.read_i = 0
    at.read_lines = g.splitLines(s)
    at._file_bytes = g.toEncodedString(s)
</t>
<t tx="ekr.20130911110233.11287">def getEncodingFromHeader(self, fileName, s):
    '''
    Return the encoding given in the @+leo sentinel, if the sentinel is
    present, or the previous value of at.encoding otherwise.
    '''
    at = self
    if at.errors:
        g.trace('can not happen: at.errors &gt; 0')
        e = at.encoding
        if g.unitTesting: assert False, g.callers()
            # This can happen when the showTree command in a unit test is left on.
            # A @file/@clean node is created which refers to a non-existent file.
            # It's surprisingly difficult to set at.error=0 safely elsewhere.
            # Otoh, I'm not sure why this test here is ever really useful.
    else:
        at.initReadLine(s)
        old_encoding = at.encoding
        assert old_encoding
        at.encoding = None
        # Execute scanHeader merely to set at.encoding.
        at.scanHeader(fileName, giveErrors=False)
        e = at.encoding or old_encoding
    assert e
    return e
</t>
<t tx="ekr.20130921043420.21175"># w's type is in (DynamicWindow,QMinibufferWrapper,LeoQtLog,LeoQtTree,
# QTextEditWrapper,LeoQTextBrowser,LeoQuickSearchWidget,cleoQtUI)

def setFilter(self, c, obj, w, tag):
    '''
    Create an event filter in obj.
    w is a wrapper object, not necessarily a QWidget.
    '''
    # gui = self
    assert isinstance(obj, QtWidgets.QWidget), obj
    theFilter = qt_events.LeoQtEventFilter(c, w=w, tag=tag)
    obj.installEventFilter(theFilter)
    w.ev_filter = theFilter
        # Set the official ivar in w.
</t>
<t tx="ekr.20131016032805.16721" annotate="7d71002e">def execute_shell_commands(commands, trace=False):
    '''
    Execute each shell command in a separate process.
    Wait for each command to complete, except those starting with '&amp;'
    '''
    if g.isString(commands): commands = [commands]
    for command in commands:
        wait = not command.startswith('&amp;')
        if command.startswith('&amp;'): command = command[1:].strip()
        proc = subprocess.Popen(command, shell=True)
        if wait: proc.communicate()
</t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131114051702.16542">def getOutlineData(self, setting):
    '''Return the pastable (xml) text of the entire @outline-data tree.'''
    data = self.get(setting, "outlinedata")
    if setting == 'tree-abbreviations':
        # 904: Append local tree abbreviations to the global abbreviations.
        data0 = g.app.config.getOutlineData(setting)
        if data and data0 and data != data0:
            assert g.isString(data0)
            assert g.isString(data)
            # We can't merge the data here: they are .leo files!
            # abbrev.init_tree_abbrev_helper does the merge.
            data = [data0, data]
    return data
</t>
<t tx="ekr.20131115120119.17395">def setChanged(self, c, changed):
    # Find the tab corresponding to c.
    dw = c.frame.top # A DynamicWindow
    i = self.indexOf(dw)
    if i &lt; 0: return
    s = self.tabText(i)
    s = g.u(s)
    if len(s) &gt; 2:
        if changed:
            if not s.startswith('* '):
                title = "* " + s
                self.setTabText(i, title)
        else:
            if s.startswith('* '):
                title = s[2:]
                self.setTabText(i, title)
</t>
<t tx="ekr.20131117120458.16789">def init_widgets(self):
    '''
    Init widgets and ivars from c.config settings.
    Create callbacks that always keep the LeoFind ivars up to date.
    '''
    c = self.c
    find = c.findCommands
    # Find/change text boxes.
    table = (
        ('find_findbox', 'find_text', '&lt;find pattern here&gt;'),
        ('find_replacebox', 'change_text', ''),
    )
    for ivar, setting_name, default in table:
        s = c.config.getString(setting_name) or default
        s = g.u(s)
        w = getattr(self, ivar)
        w.insert(s)
        if find.minibuffer_mode:
            w.clearFocus()
        else:
            w.setSelection(0, len(s))
    # Check boxes.
    table = (
        ('ignore_case', self.check_box_ignore_case),
        ('mark_changes', self.check_box_mark_changes),
        ('mark_finds', self.check_box_mark_finds),
        ('pattern_match', self.check_box_regexp),
        ('search_body', self.check_box_search_body),
        ('search_headline', self.check_box_search_headline),
        ('whole_word', self.check_box_whole_word),
        ('wrap', self.check_box_wrap_around),
    )
    for setting_name, w in table:
        val = c.config.getBool(setting_name, default=False)
        # The setting name is also the name of the LeoFind ivar.
        assert hasattr(find, setting_name), setting_name
        setattr(find, setting_name, val)
        if val:
            w.toggle()

        def check_box_callback(n, setting_name=setting_name, w=w):
            # The focus has already change when this gets called.
            # focus_w = QtWidgets.QApplication.focusWidget()
            val = w.isChecked()
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            # Too kludgy: we must use an accurate setting.
            # It would be good to have an "about to change" signal.
            # Put focus in minibuffer if minibuffer find is in effect.
            c.bodyWantsFocusNow()

        w.stateChanged.connect(check_box_callback)
    # Radio buttons
    table = (
        ('node_only', 'node_only', self.radio_button_node_only),
        ('entire_outline', None, self.radio_button_entire_outline),
        ('suboutline_only', 'suboutline_only', self.radio_button_suboutline_only),
    )
    for setting_name, ivar, w in table:
        val = c.config.getBool(setting_name, default=False)
        # The setting name is also the name of the LeoFind ivar.
        if ivar is not None:
            assert hasattr(find, setting_name), setting_name
            setattr(find, setting_name, val)
            w.toggle()

        def radio_button_callback(n, ivar=ivar, setting_name=setting_name, w=w):
            val = w.isChecked()
            find.radioButtonsChanged = True
            if ivar:
                assert hasattr(find, ivar), ivar
                setattr(find, ivar, val)

        w.toggled.connect(radio_button_callback)
    # Ensure one radio button is set.
    if not find.node_only and not find.suboutline_only:
        w = self.radio_button_entire_outline
        w.toggle()
</t>
<t tx="ekr.20131117164142.16853">def getFindText(self):
    return g.u(self.find_findbox.text())

def getReplaceText(self):
    return g.u(self.find_replacebox.text())

getChangeText = getReplaceText

def setFindText(self, s):
    w = self.find_findbox
    s = g.toUnicode(s)
    w.clear()
    w.insert(s)

def setReplaceText(self, s):
    w = self.find_replacebox
    s = g.toUnicode(s)
    w.clear()
    w.insert(s)

setChangeText = setReplaceText
</t>
<t tx="ekr.20131118152731.16847">def create_find_grid(self, parent):
    grid = self.createGrid(parent, 'findGrid', margin=10, spacing=10)
    grid.setColumnStretch(0, 100)
    grid.setColumnStretch(1, 100)
    grid.setColumnStretch(2, 10)
    grid.setColumnMinimumWidth(1, 75)
    grid.setColumnMinimumWidth(2, 175)
    return grid
</t>
<t tx="ekr.20131118152731.16848">def create_find_findbox(self, grid, parent, row):
    '''Create the Find: label and text area.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_findbox is None
    ftm.find_findbox = w = dw.createLineEdit(parent, 'findPattern', disabled=fc.expert_mode)
    lab2 = self.createLabel(parent, 'findLabel', 'Find:')
    grid.addWidget(lab2, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
</t>
<t tx="ekr.20131118152731.16849">def create_find_header(self, grid, parent, row):
    if False:
        dw = self
        lab1 = dw.createLabel(parent, 'findHeading', 'Find/Change Settings...')
        grid.addWidget(lab1, row, 0, 1, 2, QtCore.Qt.AlignLeft)
            # AlignHCenter
        row += 1
    return row
</t>
<t tx="ekr.20131118152731.16850">def create_find_replacebox(self, grid, parent, row):
    '''Create the Replace: label and text area.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm
    assert ftm.find_replacebox is None
    ftm.find_replacebox = w = dw.createLineEdit(parent, 'findChange', disabled=fc.expert_mode)
    lab3 = dw.createLabel(parent, 'changeLabel', 'Replace:') # Leo 4.11.1.
    grid.addWidget(lab3, row, 0)
    grid.addWidget(w, row, 1, 1, 2)
    row += 1
    return row
</t>
<t tx="ekr.20131118152731.16851">def create_find_checkboxes(self, grid, parent, max_row2, row):
    '''Create check boxes and radio buttons.'''
    c, dw = self.leo_c, self
    fc = c.findCommands
    ftm = fc.ftm

    def mungeName(kind, label):
        # The returned value is the namve of an ivar.
        kind = 'check_box_' if kind == 'box' else 'radio_button_'
        name = label.replace(' ', '_').replace('&amp;', '').lower()
        return '%s%s' % (kind, name)
    # Rows for check boxes, radio buttons &amp; execution buttons...

    d = {
        'box': dw.createCheckBox,
        'rb': dw.createRadioButton,
    }
    table = (
        # Note: the Ampersands create Alt bindings when the log pane is enable.
        # The QShortcut class is the workaround.
        # First row.
        ('box', 'whole &amp;Word', 0, 0),
        ('rb', '&amp;Entire outline', 0, 1),
        # Second row.
        ('box', '&amp;Ignore case', 1, 0),
        ('rb', '&amp;Suboutline only', 1, 1),
        # Third row.
        ('box', 'wrap &amp;Around', 2, 0),
        ('rb', '&amp;Node only', 2, 1),
        # Fourth row.
        ('box', 'rege&amp;Xp', 3, 0),
        ('box', 'search &amp;Headline', 3, 1),
        # Fifth row.
        ('box', 'mark &amp;Finds', 4, 0),
        ('box', 'search &amp;Body', 4, 1),
        # Sixth row.
        ('box', 'mark &amp;Changes', 5, 0),
        # a,b,c,e,f,h,i,n,rs,w
    )
    for kind, label, row2, col in table:
        max_row2 = max(max_row2, row2)
        name = mungeName(kind, label)
        func = d.get(kind)
        assert func
        # Fix the greedy checkbox bug:
        label = label.replace('&amp;', '')
        w = func(parent, name, label)
        grid.addWidget(w, row + row2, col)
        # The the checkbox ivars in dw and ftm classes.
        assert getattr(ftm, name) is None
        setattr(ftm, name, w)
    return max_row2
</t>
<t tx="ekr.20131118152731.16852">def create_find_buttons(self, grid, parent, max_row2, row):
    c, dw = self.leo_c, self
    k = c.k
    ftm = c.findCommands.ftm

    def mungeName(label):
        kind = 'push-button'
        name = label.replace(' ', '').replace('&amp;', '')
        return '%s%s' % (kind, name)
    # Create Buttons in column 2 (Leo 4.11.1.)

    table = (
        (0, 2, 'findButton', 'Find Next', 'find-next'),
        (1, 2, 'findPreviousButton', 'Find Previous', 'find-prev'),
        (2, 2, 'findAllButton', 'Find All', 'find-all'),
        (3, 2, 'changeButton', 'Replace', 'replace'),
        (4, 2, 'changeThenFindButton', 'Replace Then Find', 'replace-then-find'),
        (5, 2, 'changeAllButton', 'Replace All', 'replace-all'),
        # (6,2,'helpForFindCommands','Help','help-for-find-commands'),
    )
    # findTabHandler does not exist yet.
    for row2, col, func_name, label, cmd_name in table:

        def find_tab_button_callback(event, c=c, func_name=func_name):
            # h will exist when the Find Tab is open.
            fc = c.findCommands
            func = getattr(fc, func_name, None)
            if func: func()
            else:
                g.trace('* does not exist:', func_name)

        name = mungeName(label)
        # Prepend the shortcut if it exists:
        stroke = k.getStrokeForCommandName(cmd_name)
        if stroke:
            label = '%s:  %s' % (label, k.prettyPrintKey(stroke))
        if 1: # Not bad.
            w = dw.createButton(parent, name, label)
            grid.addWidget(w, row + row2, col)
        else:
            # grid.addLayout(layout,row+row2,col)
            # layout = dw.createHLayout(frame,name='button_layout',margin=0,spacing=0)
            # frame.setLayout(layout)
            frame = dw.createFrame(parent, name='button:%s' % label)
            w = dw.createButton(frame, name, label)
            grid.addWidget(frame, row + row2, col)
        # Connect the button with the command.
        w.clicked.connect(find_tab_button_callback)
        # Set the ivar.
        ivar = '%s-%s' % (cmd_name, 'button')
        ivar = ivar.replace('-', '_')
        assert getattr(ftm, ivar) is None
        setattr(ftm, ivar, w)
    row += max_row2
    row += 2
    return row
</t>
<t tx="ekr.20131118152731.16853">def create_help_row(self, grid, parent, row):
    # Help row.
    if False:
        w = self.createLabel(parent,
            'findHelp', 'For help: &lt;alt-x&gt;help-for-find-commands&lt;return&gt;')
        grid.addWidget(w, row, 0, 1, 3)
        row += 1
    return row
</t>
<t tx="ekr.20131118172620.16858">def finishCreateLogPane(self):
    '''It's useful to create this late, because c.config is now valid.'''
    # self.findTab exists even if there is not Find tab in the Log pane.
    assert self.findTab
    self.createFindTab(self.findTab, self.findScrollArea)
    self.findScrollArea.setWidget(self.findTab)
</t>
<t tx="ekr.20131118172620.16891">def override_events(self):
    # dw = self
    c = self.leo_c
    fc = c.findCommands
    ftm = fc.ftm
    # Define class EventWrapper.
    @others
    EventWrapper(c, w=ftm.find_findbox, next_w=ftm.find_replacebox, func=fc.findNextCommand)
    EventWrapper(c, w=ftm.find_replacebox, next_w=ftm.find_next_button, func=fc.findNextCommand)
    table = (
        ('findNextCommand', 'find-next'),
        ('findPrevCommand', 'find-prev'),
        ('findAll', 'find-all'),
        ('changeCommand', 'replace'),
        ('changeThenFind', 'replace-then-find'),
        ('changeAll', 'replace-all'),
    )
    for func_name, cmd_name in table:
        ivar = '%s-%s' % (cmd_name, 'button')
        ivar = ivar.replace('-', '_')
        w = getattr(ftm, ivar, None)
        func = getattr(fc, func_name, None)
        if w and func:
            next_w = ftm.check_box_whole_word if cmd_name == 'replace-all' else None
            EventWrapper(c, w=w, next_w=next_w, func=func)
        else:
            g.trace('**oops**')
    # Finally, checkBoxMarkChanges goes back to ftm.find_findBox.
    EventWrapper(c, w=ftm.check_box_mark_changes, next_w=ftm.find_findbox, func=None)
</t>
<t tx="ekr.20131118172620.16892">class EventWrapper(object):
    
    def __init__(self, c, w, next_w, func):
        self.c = c
        self.d = self.create_d()
            # Keys: stroke.s; values: command-names.
        self.w = w
        self.next_w = next_w
        self.eventFilter = qt_events.LeoQtEventFilter(c, w, 'EventWrapper')
        self.func = func
        self.oldEvent = w.event
        w.event = self.wrapper

    @others
</t>
<t tx="ekr.20131118172620.16893">def wrapper(self, event):

    e = QtCore.QEvent
    type_ = event.type()
    # Must intercept KeyPress for events that generate FocusOut!
    if type_ == e.KeyPress:
        return self.keyPress(event)
    elif type_ == e.KeyRelease:
        return self.keyRelease(event)
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16894">def keyPress(self, event):

    s = g.u(event.text())
    out = s and s in '\t\r\n'
    if out:
        # Move focus to next widget.
        if s == '\t':
            if self.next_w:
                self.next_w.setFocus(QtCore.Qt.TabFocusReason)
            else:
                # Do the normal processing.
                return self.oldEvent(event)
        elif self.func:
            self.func()
        return True
    # Stay in the present widget.
    binding, ch = self.eventFilter.toBinding(event)
    if  binding:
        cmd_name = self.d.get(binding)
        if cmd_name:
            self.c.k.simulateCommand(cmd_name)
            return True
    # Do the normal processing.
    return self.oldEvent(event)
</t>
<t tx="ekr.20131118172620.16895">def keyRelease(self, event):
    return self.oldEvent(event)
</t>
<t tx="ekr.20131119185305.16478">def clear_focus(self):
    self.entry_focus = None
    self.find_findbox.clearFocus()

def init_focus(self):
    self.set_entry_focus()
    w = self.find_findbox
    w.setFocus()
    s = g.u(w.text())
    w.setSelection(0, len(s))

def set_entry_focus(self):
    # Remember the widget that had focus, changing headline widgets
    # to the tree pane widget.  Headline widgets can disappear!
    c = self.c
    w = g.app.gui.get_focus(raw=True)
    if w != c.frame.body.wrapper.widget:
        w = c.frame.tree.treeWidget
    self.entry_focus = w

</t>
<t tx="ekr.20131120054058.16281">def create_d(self):
    '''Create self.d dictionary.'''
    c = self.c
    d = {}
    table = (
        'toggle-find-ignore-case-option',
        'toggle-find-in-body-option',
        'toggle-find-in-headline-option',
        'toggle-find-mark-changes-option',
        'toggle-find-mark-finds-option',
        'toggle-find-regex-option',
        'toggle-find-word-option',
        'toggle-find-wrap-around-option',
        # New in Leo 5.2: Support these in the Find Dialog.
        'find-all',
        'find-next',
        'find-prev',
        'hide-find-tab',
        'replace',
        'replace-all',
        'replace-then-find',
        'set-find-everywhere',
        'set-find-node-only',
        'set-find-suboutline-only',
    )
    for cmd_name in table:
        stroke = c.k.getStrokeForCommandName(cmd_name)
        if stroke:
            d[stroke.s] = cmd_name
    return d
</t>
<t tx="ekr.20131121084830.16362">@language python

# Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131224053735.16380">@nobeautify

# directives...
noDirective     =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective    =  3 # @doc.
atDirective     =  4 # @&lt;space&gt; or @&lt;newline&gt;
codeDirective   =  5 # @code
cDirective      =  6 # @c&lt;space&gt; or @c&lt;newline&gt;
othersDirective =  7 # at-others
miscDirective   =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw
startVerbatim   = 11 # @verbatim
    # Not a real directive. Used to issue warnings.
</t>
<t tx="ekr.20131224085853.16443">def findReference(self, name, p):
    '''Find a reference to name.  Raise an error if not found.'''
    at = self
    ref = g.findReference(name, p)
    if not ref and not hasattr(at, 'allow_undefined_refs'):
        # Do give this error even if unit testing.
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" % (
                g.truncate(name, 60), g.truncate(p.h, 60)))
    return ref
</t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140114145953.16691">def isLocalSetting(self, setting, kind):
    '''Return True if the indicated setting comes from a local .leo file.'''
    if not kind or kind in ('shortcut', 'shortcuts', 'openwithtable'):
        return False
    key = g.app.config.munge(setting)
    if key is None:
        return False
    if not self.settingsDict:
        return False
    gs = self.settingsDict.get(key)
    if not gs:
        return False
    assert g.isGeneralSetting(gs), gs
    path = gs.path.lower()
    for fn in ('myLeoSettings.leo', 'leoSettings.leo'):
        if path.endswith(fn.lower()):
            return False
    return True
</t>
<t tx="ekr.20140713062552.17737">def pickle(self, p):
    '''Pickle val and return the hexlified result.'''
    try:
        ua = p.v.u
        s = pickle.dumps(ua, protocol=1)
        s2 = binascii.hexlify(s)
        s3 = g.ue(s2, 'utf-8')
        return s3
    except pickle.PicklingError:
        g.warning("ignoring non-pickleable value", ua, "in", p.h)
        return ''
    except Exception:
        g.error("pd.pickle: unexpected exception in", p.h)
        g.es_exception()
        return ''
</t>
<t tx="ekr.20140717074441.17770">def recreateGnxDict(self):
    '''Recreate the gnx dict prior to refreshing nodes from disk.'''
    c, d = self, {}
    for v in c.all_unique_nodes():
        gnxString = v.fileIndex
        if g.isString(gnxString):
            d[gnxString] = v
            if 'gnx' in g.app.debug:
                g.trace(c.shortFileName(), gnxString, v)
        else:
            g.internalError('no gnx for vnode: %s' % (v))
    c.fileCommands.gnxDict = d
</t>
<t tx="ekr.20140717074441.17772"># refresh_pattern = re.compile('^(@[\w-]+)')

@g.commander_command('refresh-from-disk')
def refreshFromDisk(self, event=None):
    '''Refresh an @&lt;file&gt; node from disk.'''
    c, p, u = self, self.p, self.undoer
    c.nodeConflictList = []
    fn = p.anyAtFileNodeName()
    shouldDelete = (not g.SQLITE) or (c.sqlite_connection is None)
    if not fn:
        g.warning('not an @&lt;file&gt; node:\n%r' % (p.h))
        return
    b = u.beforeChangeTree(p)
    redraw_flag = True
    at = c.atFileCommands
    c.recreateGnxDict()
        # Fix bug 1090950 refresh from disk: cut node ressurection.
    i = g.skip_id(p.h, 0, chars='@')
    word = p.h[0: i]
    if word == '@auto':
        # This includes @auto-*
        if shouldDelete: p.v._deleteAllChildren()
        # Fix #451: refresh-from-disk selects wrong node.
        p = at.readOneAtAutoNode(fn, p)
    elif word in ('@thin', '@file'):
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True)
    elif word == '@clean':
        # Wishlist 148: use @auto parser if the node is empty.
        if p.b.strip() or p.hasChildren():
            at.readOneAtCleanNode(p)
        else:
            # Fix #451: refresh-from-disk selects wrong node.
            p = at.readOneAtAutoNode(fn, p)
    elif word == '@shadow':
        if shouldDelete: p.v._deleteAllChildren()
        at.read(p, force=True, atShadow=True)
    elif word == '@edit':
        at.readOneAtEditNode(fn, p)
            # Always deletes children.
    elif word == '@asis':
        # Fix #1067.
        at.readOneAtAsisNode(fn, p)
            # Always deletes children.
    else:
        g.es_print('can not refresh from disk\n%r' % p.h)
        redraw_flag = False
    if redraw_flag:
        # Fix #451: refresh-from-disk selects wrong node.
        c.selectPosition(p)
        u.afterChangeTree(p, command='refresh-from-disk', bunch=b)
        # Create the 'Recovered Nodes' tree.
        c.fileCommands.handleNodeConflicts()
        c.redraw()
</t>
<t tx="ekr.20140727075002.18108">def saveOutlineIfPossible(self):
    '''Save the outline if only persistence data nodes are dirty.'''
    c = self.c
    changed_positions = [p for p in c.all_unique_positions() if p.v.isDirty()]
    at_persistence = c.persistenceController and c.persistenceController.has_at_persistence_node()
    if at_persistence:
        changed_positions = [p for p in changed_positions
            if not at_persistence.isAncestorOf(p)]
    if not changed_positions:
        # g.warning('auto-saving @persistence tree.')
        c.setChanged(False)
        c.redraw()
</t>
<t tx="ekr.20140728040812.17993">def dispatch(self, ext, p):
    '''Return the correct writer function for p, an @auto node.'''
    at = self
    # Match @auto type before matching extension.
    return at.writer_for_at_auto(p) or at.writer_for_ext(ext)
</t>
<t tx="ekr.20140728040812.17995">def writer_for_at_auto(self, root):
    '''A factory returning a writer function for the given kind of @auto directive.'''
    at = self
    d = g.app.atAutoWritersDict
    for key in d.keys():
        aClass = d.get(key)
        if aClass and g.match_word(root.h, 0, key):

            def writer_for_at_auto_cb(root):
                # pylint: disable=cell-var-from-loop
                try:
                    writer = aClass(at.c)
                    s = writer.write(root)
                    return s
                except Exception:
                    g.es_exception()
                    return None

            return writer_for_at_auto_cb
    return None
</t>
<t tx="ekr.20140728040812.17997">def writer_for_ext(self, ext):
    '''A factory returning a writer function for the given file extension.'''
    at = self
    d = g.app.writersDispatchDict
    aClass = d.get(ext)
    if aClass:

        def writer_for_ext_cb(root):
            try:
                return aClass(at.c).write(root)
            except Exception:
                g.es_exception()
                return None

        return writer_for_ext_cb
    else:
        return None
</t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140825102404.18525">def __repr__(self):
    '''IdleTime repr.'''
    tag = self.tag
    if tag:
        return '&lt;IdleTime: %s&gt;' % (tag if g.isString(tag) else repr(tag))
    else:
        return '&lt;IdleTime: id: %s&gt;' % id(self)

__str__ = __repr__
</t>
<t tx="ekr.20140827092102.18575">import re
import string
# import time
import leo.core.leoGlobals as g
from leo.core.leoQt import Qsci, QtGui, QtWidgets # isQt5, QtCore
if g.pygments:
    # pylint: disable=no-name-in-module
        ### PythonLexer or PythonLexer3 will be undefined.
    try:
        # Jupyter imports.
        from pygments.formatters.html import HtmlFormatter
        from pygments.lexer import RegexLexer, _TokenType, Text, Error
        ### To be removed.
        if g.isPython3:
            from pygments.lexers import Python3Lexer as Lexer # pylint: disable=no-name-in-module
        else:
            from pygments.lexers import PythonLexer as Lexer # pylint: disable=no-name-in-module
        from pygments.styles import get_style_by_name
    except ImportError:
        g.pygments = None
</t>
<t tx="ekr.20140831085423.18630">This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:

si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">The following 'official' ivars will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following were official ivars that no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.
</t>
<t tx="ekr.20140831085423.18639">Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases. All wrapper classes define an official ``widget`` ivar, so core or plugin code can gain access to the real Qt widget using wrapper.widget. Searching for wrapper.widget will find all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@
@language rest
@wrap

Leo uses a model/view/controller architecture.

- Controller: The Commands class and its helpers in leoCommands.py and leoEditCommands.py.

- Model: The VNode and Position classes in leoNodes.py.

- View: The gui-independent base classes are in the node "Gui Base Classes". The Qt-Specific subclasses are in the node "Qt gui".

**Important**: The general organization of these classes have changed hardly at all in Leo's 20+ year history.  The reason is that what each class does is fairly obvious.  How the gets the job done may have changed drastically, but *that's an internal implementation detail of the class itself*.  This is the crucial design principle that allows Leo's code to remain stable.  *Classes do not know or meddle in the internal details of other classes*.  As a result, nobody, including EKR, needs to remember internal details.
@c
</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140915062551.19519">def set_icon_bar_orientation(self, c):
    '''Set the orientation of the icon bar based on settings.'''
    d = {
        'bottom': QtCore.Qt.BottomToolBarArea,
        'left': QtCore.Qt.LeftToolBarArea,
        'right': QtCore.Qt.RightToolBarArea,
        'top': QtCore.Qt.TopToolBarArea,
    }
    where = self.toolbar_orientation
    if not where:
        where = 'top'
    where = d.get(where.lower())
    if where:
        self.addToolBar(where, self.iconBar)
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20141012064706.18403">def visit(self, node, *args, **keys):
    '''Return the formatted version of an Ast node, or list of Ast nodes.'''
    if isinstance(node, (list, tuple)):
        return ','.join([self.visit(z) for z in node])
    elif node is None:
        return 'None'
    else:
        assert isinstance(node, ast.AST), node.__class__.__name__
        method_name = 'do_' + node.__class__.__name__
        method = getattr(self, method_name)
        s = method(node, *args, **keys)
        assert g.isString(s), type(s)
        return s
</t>
<t tx="ekr.20141012064706.18416"># 2: arguments = (expr* args, identifier? vararg, identifier?
#                arg? kwarg, expr* defaults)
# 3: arguments = (arg*  args, arg? vararg,
#                arg* kwonlyargs, expr* kw_defaults,
#                arg? kwarg, expr* defaults)

def do_arguments(self, node):
    '''Format the arguments node.'''
    kind = self.kind(node)
    assert kind == 'arguments', kind
    args = [self.visit(z) for z in node.args]
    defaults = [self.visit(z) for z in node.defaults]
    args2 = []
    n_plain = len(args) - len(defaults)
    for i in range(len(node.args)):
        if i &lt; n_plain:
            args2.append(args[i])
        else:
            args2.append('%s=%s' % (args[i], defaults[i - n_plain]))
    if g.isPython3:
        # Add the vararg and kwarg expressions.
        vararg = getattr(node, 'vararg', None)
        if vararg: args2.append('*' + self.visit(vararg))
        kwarg = getattr(node, 'kwarg', None)
        if kwarg: args2.append('**' + self.visit(kwarg))
    else:
        # Add the vararg and kwarg names.
        name = getattr(node, 'vararg', None)
        if name: args2.append('*' + name)
        name = getattr(node, 'kwarg', None)
        if name: args2.append('**' + name)
    return ','.join(args2)
</t>
<t tx="ekr.20141012064706.18419">def do_Bytes(self, node): # Python 3.x only.
    assert g.isPython3
    return str(node.s)
</t>
<t tx="ekr.20141012064706.18459"># Raise(expr? type, expr? inst, expr? tback)    Python 2
# Raise(expr? exc, expr? cause)                 Python 3

def do_Raise(self, node):
    args = []
    attrs = ('exc', 'cause') if g.isPython3 else ('type', 'inst', 'tback')
    for attr in attrs:
        if getattr(node, attr, None) is not None:
            args.append(self.visit(getattr(node, attr)))
    if args:
        return self.indent('raise %s\n' % (
            ','.join(args)))
    else:
        return self.indent('raise\n')
</t>
<t tx="ekr.20141012064706.18474"># 2: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list)
# 3: FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list,
#                expr? returns)

def do_FunctionDef(self, node, visit_body=True):

    old_context = self.context
    self.context = node
    self.level += 1
    # Visit the tree in token order.
    for z in node.decorator_list:
        self.visit(z)
    assert g.isString(node.name)
    self.visit(node.args)
    if getattr(node, 'returns', None): # Python 3.
        self.visit(node.returns)
    if visit_body:
        for z in node.body:
            self.visit(z)
    self.level -= 1
    self.context = old_context

do_AsyncFunctionDef = do_FunctionDef
</t>
<t tx="ekr.20141012064706.18482"># 2: arguments = (
# expr* args,
#   identifier? vararg,
#   identifier? kwarg,
#   expr* defaults)
# 3: arguments = (
#   arg*  args,
#   arg? vararg,
#   arg* kwonlyargs,
#   expr* kw_defaults,
#   arg? kwarg,
#   expr* defaults)

def do_arguments(self, node):

    for z in node.args:
        self.visit(z)
    if g.isPython3 and getattr(node, 'vararg', None):
        # An identifier in Python 2.
        self.visit(node.vararg)
    if g.isPython3 and getattr(node, 'kwarg', None):
        # An identifier in Python 2.
        self.visit_list(node.kwarg)
    if getattr(node, 'kwonlyargs', None): # Python 3.
        self.visit_list(node.kwonlyargs)
    if getattr(node, 'kw_defaults', None): # Python 3.
        self.visit_list(node.kw_defaults)
    for z in node.defaults:
        self.visit(z)

# 3: arg = (identifier arg, expr? annotation)

def do_arg(self, node):
    if getattr(node, 'annotation', None):
        self.visit(node.annotation)
</t>
<t tx="ekr.20141012064706.18520"># Raise(expr? type, expr? inst, expr? tback)    Python 2
# Raise(expr? exc, expr? cause)                 Python 3

def do_Raise(self, node):

    attrs = ('exc', 'cause') if g.isPython3 else ('type', 'inst', 'tback')
    for attr in attrs:
        if getattr(node, attr, None):
            self.visit(getattr(node, attr))
</t>
<t tx="ekr.20141012064706.18531"># Return generic markers allow better pattern matches.

def do_BoolOp(self, node): # Python 2.x only.
    return 'Bool'

def do_Bytes(self, node): # Python 3.x only.
    assert g.isPython3
    return 'Bytes' # return str(node.s)
    
def do_Constant(self, node): # Python 3.6+ only.
    assert g.isPython3
    return 'Constant'

def do_Name(self, node):
    return 'Bool' if node.id in ('True', 'False') else node.id

def do_NameConstant(self, node): # Python 3 only.
    s = repr(node.value)
    return 'Bool' if s in ('True', 'False') else s

def do_Num(self, node):
    return 'Num' # return repr(node.n)

def do_Str(self, node):
    '''This represents a string constant.'''
    return 'Str' # return repr(node.s)
</t>
<t tx="ekr.20141020112451.18329">def put_dquote(self):
    self.put('"')
</t>
<t tx="ekr.20141020112451.18330">def put_dquoted_bool(self, b):
    if b: self.put('"1"')
    else: self.put('"0"')
</t>
<t tx="ekr.20141020112451.18331">def put_flag(self, a, b):
    if a:
        self.put(" "); self.put(b); self.put('="1"')
</t>
<t tx="ekr.20141020112451.18332">def put_in_dquotes(self, a):
    self.put('"')
    if a: self.put(a) # will always be True if we use backquotes.
    else: self.put('0')
    self.put('"')
</t>
<t tx="ekr.20141020112451.18333">def put_nl(self):
    self.put("\n")
</t>
<t tx="ekr.20141020112451.18334">def put_tab(self):
    self.put("\t")
</t>
<t tx="ekr.20141020112451.18335">def put_tabs(self, n):
    while n &gt; 0:
        self.put("\t")
        n -= 1
</t>
<t tx="ekr.20141024170936.7">def get_selection(self):
    '''Return the presently selected item's text.'''
    return g.u(self.currentItem().text())
</t>
<t tx="ekr.20141031053508.15">def add_rclick_menu(self, action_container, rclicks, controller,
    top_level=True,
    button=None,
    script=None
):
    c = controller.c
    top_offset = -2 # insert before the remove button and goto script items
    if top_level:
        button = action_container
    for rc in rclicks:
        # pylint: disable=cell-var-from-loop
        headline = rc.position.h[8:].strip()
        act = QtWidgets.QAction(headline, action_container)
        if '---' in headline and headline.strip().strip('-') == '':
            act.setSeparator(True)
        elif rc.position.b.strip():

            def cb(checked, p=rc.position, button=button):
                controller.executeScriptFromButton(
                    b=button,
                    buttonText=p.h[8:].strip(),
                    p=p,
                    script=script,
                )
                if c.exists:
                    c.outerUpdate()

            act.triggered.connect(cb)
        else: # recurse submenu
            sub_menu = QtWidgets.QMenu(action_container)
            act.setMenu(sub_menu)
            self.add_rclick_menu(sub_menu, rc.children, controller,
                top_level=False, button=button)
        if top_level:
            # insert act before Remove Button
            action_container.insertAction(
                action_container.actions()[top_offset], act)
        else:
            action_container.addAction(act)
    if top_level and rclicks:
        act = QtWidgets.QAction('---', action_container)
        act.setSeparator(True)
        action_container.insertAction(
            action_container.actions()[top_offset], act)
        action_container.setText(
            g.u(action_container.text()) +
            (c.config.getString('mod-scripting-subtext') or '')
        )
</t>
<t tx="ekr.20141103061944.31">def getXScrollPosition(self):
    '''Get the horizontal scrollbar position.'''
    w = self
    sb = w.horizontalScrollBar()
    pos = sb.sliderPosition()
    return pos

def setXScrollPosition(self, pos):
    '''Set the position of the horizontal scrollbar.'''
    if pos is not None:
        w = self
        sb = w.horizontalScrollBar()
        sb.setSliderPosition(pos)
</t>
<t tx="ekr.20141210051628.28">def parseZimIndex(self):
    """
    Parse Zim wiki index.rst and return a list of tuples (level, name, path)
    """
    # c = self.c
    pathToZim = g.os_path_abspath(self.pathToZim)
    pathToIndex = g.os_path_join(pathToZim, 'index.rst')
    if not g.os_path_exists(pathToIndex):
        g.es('not found: %s' % (pathToIndex), color='red')
        return None
    index = open(pathToIndex).read()
    # pylint: disable=anomalous-backslash-in-string
    parse = re.findall('(\t*)-\s`(.+)\s&lt;(.+)&gt;`_', index)
    if not parse:
        g.es('invalid index: %s' % (pathToIndex), color='red')
        return None
    results = []
    for result in parse:
        level = len(result[0])
        name = result[1].decode('utf-8')
        # pylint: disable=no-member
        unquote = urllib.parse.unquote if g.isPython3 else urllib.unquote
        path = [g.os_path_abspath(g.os_path_join(
            pathToZim, unquote(result[2]).decode('utf-8')))]
        results.append((level, name, path))
    return results
</t>
<t tx="ekr.20150204165040.4">def openAtShadowFileForReading(self, fn):
    '''Open an @shadow for reading and return shadow_fn.'''
    at = self
    x = at.c.shadowController
    # readOneAtShadowNode should already have checked these.
    shadow_fn = x.shadowPathName(fn)
    shadow_exists = (g.os_path_exists(shadow_fn) and
        g.os_path_isfile(shadow_fn))
    if not shadow_exists:
        g.trace('can not happen: no private file',
            shadow_fn, g.callers())
        at.error('can not happen: private file does not exist: %s' % (
            shadow_fn))
        return None
    # This method is the gateway to the shadow algorithm.
    x.updatePublicAndPrivateFiles(at.root, fn, shadow_fn)
    return shadow_fn
</t>
<t tx="ekr.20150204165040.5">def readOneAtCleanNode(self, root):
    '''Update the @clean/@nosent node at root.'''
    at, c, x = self, self.c, self.c.shadowController
    fileName = g.fullPath(c, root)
    if not g.os_path_exists(fileName):
        g.es_print('not found: %s' % (fileName), color='red',
            nodeLink=root.get_UNL(with_proto=True))
        return
    at.rememberReadPath(fileName, root)
    at.initReadIvars(root, fileName)
        # Must be called before at.scanAllDirectives.
    at.scanAllDirectives(root)
        # Sets at.startSentinelComment/endSentinelComment.
    new_public_lines = at.read_at_clean_lines(fileName)
    old_private_lines = self.write_at_clean_sentinels(root)
    marker = x.markerFromFileLines(old_private_lines, fileName)
    old_public_lines, junk = x.separate_sentinels(old_private_lines, marker)
    if old_public_lines:
        new_private_lines = x.propagate_changed_lines(
            new_public_lines, old_private_lines, marker, p=root)
    else:
        new_private_lines = []
        root.b = ''.join(new_public_lines)
        return True
    if new_private_lines == old_private_lines:
        return True
    if not g.unitTesting:
        g.es("updating:", root.h)
    root.clearVisitedInTree()
    gnx2vnode = at.fileCommands.gnxDict
    contents = ''.join(new_private_lines)
    FastAtRead(c, gnx2vnode).read_into_root(contents, fileName, root)
    return True # Errors not detected.
</t>
<t tx="ekr.20150204165040.7">def dump(self, lines, tag):
    '''Dump all lines.'''
    print('***** %s lines...\n' % tag)
    for s in lines:
        print(s.rstrip())
</t>
<t tx="ekr.20150204165040.8">def read_at_clean_lines(self, fn):
    '''Return all lines of the @clean/@nosent file at fn.'''
    at = self
    s = at.openFileHelper(fn)
        # Use the standard helper. Better error reporting.
        # Important: uses 'rb' to open the file.
    s = g.toUnicode(s, encoding=at.encoding)
    s = s.replace('\r\n', '\n')
        # Suppress meaningless "node changed" messages.
    return g.splitLines(s)
</t>
<t tx="ekr.20150204165040.9">def write_at_clean_sentinels(self, root):
    '''
    Return all lines of the @clean tree as if it were
    written as an @file node.
    '''
    at = self.c.atFileCommands
    result = at.atFileToString(root, sentinels=True)
    s = g.toUnicode(result, encoding=at.encoding)
    return g.splitLines(s)
</t>
<t tx="ekr.20150207044400.12">def op_delete(self, tag, ai, aj, bi, bj):
    '''Handle the 'delete' opcode.'''
    x = self
    for i in range(ai, aj):
        x.put_sentinels(i)
</t>
<t tx="ekr.20150207044400.13">def op_equal(self, tag, ai, aj, bi, bj):
    '''Handle the 'equal' opcode.'''
    x = self
    assert aj - ai == bj - bi and x.a[ai: aj] == x.b[bi: bj]
    for i in range(ai, aj):
        x.put_sentinels(i)
        x.put_plain_line(x.a[i])
            # works because x.lines[ai:aj] == x.lines[bi:bj]
</t>
<t tx="ekr.20150207044400.14">def op_insert(self, tag, ai, aj, bi, bj):
    '''Handle the 'insert' opcode.'''
    x = self
    for i in range(bi, bj):
        x.put_plain_line(x.b[i])
    # Prefer to put sentinels after inserted nodes.
    # Requires a call to x.put_sentinels(0) before the main loop.
</t>
<t tx="ekr.20150207044400.15">def op_replace(self, tag, ai, aj, bi, bj):
    '''Handle the 'replace' opcode.'''
    x = self
    if 1:
        # Intersperse sentinels and lines.
        b_lines = x.b[bi: bj]
        for i in range(ai, aj):
            x.put_sentinels(i)
            if b_lines:
                x.put_plain_line(b_lines.pop(0))
        # Put any trailing lines.
        while b_lines:
            x.put_plain_line(b_lines.pop(0))
    else:
        # Feasible. Causes the present unit tests to fail.
        for i in range(ai, aj):
            x.put_sentinels(i)
        for i in range(bi, bj):
            x.put_plain_line(x.b[i])
</t>
<t tx="ekr.20150207044400.16">def op_bad(self, tag, ai, aj, bi, bj):
    '''Report an unexpected opcode.'''
    x = self
    x.error('unknown SequenceMatcher opcode: %s' % repr(tag))
</t>
<t tx="ekr.20150207044400.9">'''
The Mulder update algorithm, revised by EKR.

Use the diff between the old and new public lines to insperse sentinels
from old_private_lines into the result.

The algorithm never deletes or rearranges sentinels. However, verbatim
sentinels may be inserted or deleted as needed.
'''
</t>
<t tx="ekr.20150207111757.178">def dump_lines(self, lines, title):
    '''Dump the given lines.'''
    print('\n%s...\n' % title)
    for i, line in enumerate(lines):
        g.pr('%4s %s' % (i, repr(line)))
</t>
<t tx="ekr.20150207111757.180">def dump_args(self):
    '''Dump the argument lines.'''
    x = self
    table = (
        (x.old_sent_lines, 'old private lines'),
        (x.a, 'old public lines'),
        (x.b, 'new public lines'),
    )
    for lines, title in table:
        x.dump_lines(lines, title)
    g.pr()
</t>
<t tx="ekr.20150208060128.7">def preprocess(self, lines):
    '''
    Preprocess public lines, adding newlines as needed.
    This happens before the diff.
    '''
    result = []
    for line in lines:
        if not line.endswith('\n'):
            line = line + '\n'
        result.append(line)
    return result
</t>
<t tx="ekr.20150208223018.4">def put_plain_line(self, line):
    '''Put a plain line to x.results, inserting verbatim lines if necessary.'''
    x = self
    if x.marker.isSentinel(line):
        x.results.append(x.verbatim_line)
        if x.trace: print('put %s' % repr(x.verbatim_line))
    x.results.append(line)
    if x.trace: print('put %s' % repr(line))
</t>
<t tx="ekr.20150209044257.6">def init_data(self):
    '''
    Init x.sentinels and x.trailing_sentinels arrays.
    Return the list of non-sentinel lines in x.old_sent_lines.
    '''
    x = self
    lines = x.old_sent_lines
    sentinels = []
        # The sentinels preceding each non-sentinel line,
        # not including @verbatim sentinels.
    new_lines = []
        # A list of all non-sentinel lines found.  Should match x.a.
    x.sentinels = []
        # A list of lists of sentinels preceding each line.
    i = 0
    while i &lt; len(lines):
        line = lines[i]
        i += 1
        if x.marker.isVerbatimSentinel(line):
            # Do *not* include the @verbatim sentinel.
            if i &lt; len(lines):
                line = lines[i]
                i += 1
                x.sentinels.append(sentinels)
                sentinels = []
                new_lines.append(line)
            else:
                x.verbatim_error()
        elif x.marker.isSentinel(line):
            sentinels.append(line)
        else:
            x.sentinels.append(sentinels)
            sentinels = []
            new_lines.append(line)
    x.trailing_sentinels = sentinels
    return new_lines
</t>
<t tx="ekr.20150209044257.8">def put_sentinels(self, i):
    '''Put all the sentinels to the results'''
    x = self
    if 0 &lt;= i &lt; len(x.sentinels):
        sentinels = x.sentinels[i]
        if x.trace: g.trace('%3s %s' % (i, sentinels))
        x.results.extend(sentinels)
</t>
<t tx="ekr.20150304125314.4">@tabwidth -2
@killbeautify
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!--
    &lt;link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css"&gt;
    &lt;script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"&gt;&lt;/script&gt;
    --&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;!-- &lt;h4&gt;Outline Pane&lt;/h4&gt; --&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;!-- &lt;h4&gt;Body Pane&lt;/h4&gt; --&gt;
      &lt;pre class="body-text"&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test ='./v' &gt;
        &lt;xsl:attribute name="has-children"&gt;1&lt;/xsl:attribute&gt;
        &lt;h1&gt;+ &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
        &lt;xsl:apply-templates select = 'v'/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test ='vh' &gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:when&gt;
      &lt;!--
      &lt;xsl:otherwise&gt;
        &lt;h1&gt;- &lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
      &lt;/xsl:otherwise&gt;
      --&gt;
    &lt;/xsl:choose&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.4">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html" version="1.0" encoding="UTF-8" indent="yes"/&gt;

&lt;!-- The default setting. Not needed unless there is a strip-space element. --&gt;
  &lt;!-- &lt;xsl:preserve-space elements='leo_file nodes t'/&gt; --&gt;

&lt;xsl:template match ='leo_file'&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;&lt;style&gt;&gt;
    &lt;&lt;scripts&gt;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;xsl:apply-templates select='tnodes'/&gt;
    &lt;div class="outlinepane"&gt;
      &lt;xsl:apply-templates select='vnodes'/&gt;
    &lt;/div&gt;
    &lt;div class="bodypane"&gt;
      &lt;h1&gt;Body Pane&lt;/h1&gt;
      &lt;pre class="body-text"&gt;body&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'tnodes'&gt;
&lt;div class="tnodes"&gt;
  &lt;xsl:for-each select = 't'&gt;
    &lt;div class="tnode"&gt;
      &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@tx'/&gt;&lt;/xsl:attribute&gt;
      &lt;xsl:value-of select='.'/&gt;
    &lt;/div&gt;
  &lt;/xsl:for-each&gt;
&lt;/div&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match = 'vnodes'&gt;
  &lt;xsl:for-each select = 'v'&gt;
    &lt;xsl:apply-templates select ='.'/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='v'&gt;
  &lt;div class="node"&gt;
    &lt;xsl:attribute name="id"&gt;&lt;xsl:value-of select='@t'/&gt;&lt;/xsl:attribute&gt;
    &lt;h1&gt;&lt;xsl:value-of select='vh'/&gt;&lt;/h1&gt;
    &lt;xsl:if test ='./v' &gt;
      &lt;xsl:apply-templates select = 'v'/&gt;
    &lt;/xsl:if&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</t>
<t tx="ekr.20150304130753.5">&lt;style&gt;
    /* pre { background:#FFE7C6; } */
    /* Must use h1 for nodes: see below. */
    h1 {
      font-size: 12pt;
      font-style: normal;
      font-weight: normal;
    }
    div.outlinepane {
      position: absolute;
      background: #ffffec; /* Leo yellow */
      top: 10px;
      height: 300px;
      width: 700px;
      overflow: scroll;
      line-height: 0.8;

    }
    div.bodypane {
      position: absolute;
      top: 310px;
      height: 300px;
      width: 700px;
      overflow: scroll;
    }
    div.tnode {
        visibility: hidden;
        height: 0;
    }
    div.node {
        position: relative;
        left: 20px;
    }
    div.node[has-children] &gt; h1 {
        &lt;!-- works --&gt;
        &lt;!-- background: red; --&gt;
    }
&lt;/style&gt;
</t>
<t tx="ekr.20150304130753.6">@language javascript

&lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"&gt;&lt;/script&gt;
&lt;script&gt;

  $(document).ready(function(){
    if (true) {
        // Toggle all but top-level nodes.
        // This requires an indication
        $(".node").toggle()
        $(".outlinepane").children(".node").toggle()
    } else {
        // Toggle all second-level nodes.
        // Safer, until we can see which nodes have children.
        $(".outlinepane").children(".node").children(".node").toggle()
    }
    $("h1").click(function(){
      $(this).parent().children("div.node").toggle();
      // The parent div's id is v.x.
      // Find the tnode div whose id is t.x.
      console.clear();
      parent_id=$(this).parent().attr("id");
      if (parent_id) {
        target=$(this).parent().attr("id").substring(2);
          console.log("clicked:"+$(this).text())
          // console.log("parent:"+$(this).parent())
          // console.log("target:"+target)
        $(".tnode").each(function(){
          console.log($(this).attr("id"))
          target2=$(this).attr("id").substring(2);
          if (target === target2) {
            console.log("found:"+target2)
            // $("pre.body-text").text($(this).text());
            $("code").text($(this).text());
          };
        }); // end .each.
      };
    });
  });
@language html
&lt;/script&gt;
</t>
<t tx="ekr.20150326145530.1"># Hand-written Leo colorizer control file for forth mode.
# This file is in the public domain.
@killbeautify
import leo.core.leoGlobals as g
&lt;&lt; define mode rules &gt;&gt;
&lt;&lt; define mode data &gt;&gt;
&lt;&lt; define extendForth class &gt;&gt;
e = extendForth()

def pre_init_mode(c):
    e.c = c
    e.init()
    e.createKeywords()
    e.createBracketRules()
    e.createDefiningWordRules()
</t>
<t tx="ekr.20150326145530.10">def createKeywords(self):
    '''Create the mode keyword table and
    entries in the rulesDict for the forth_keyword_rule'''
    # global forth_main_keywords_dict
    # global forth_keyword_rule
    table = (
        (self.keywords, 'keyword1'),
      # (self.definingwords,    'keyword2'), # Done in createDefiningWordRules.
        (self.boldwords, 'keyword3'),
        (self.bolditalicwords, 'keyword4'),
        (self.italicwords, 'keyword5'),
        (self.stringwords, 'string'),
    )
    d = forth_main_keywords_dict
    for keywordList, kind in table:
        for z in keywordList:
            # Create the entry in the keyword table.
            if kind == 'string':
                func = self.createStringRule(d, z)
            else:
                func = forth_keyword_rule
            # Always make the entry.
            d[z] = kind
            self.extendRulesDict(ch=z[0], func=func)
</t>
<t tx="ekr.20150326145530.11">def createStringRule(self, d, pair):
    '''Create an entry in d for a string keyword.'''
    aList = pair.split(' ')
    if len(aList) != 2:
        g.trace('can not happen: expecting pair of forth strings:', pair)
        return
    begin, end = aList

    def forth_string_word_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin=begin.strip(), end=end.strip(),
            at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False) # Don't require ending word.

    return forth_string_word_rule
</t>
<t tx="ekr.20150326145530.12">def extendRulesDict(self, ch, func):
    global rulesDict
    # Extend the rulesDict entry for the first character of z.
    aList = rulesDict.get(ch, [])
    if func not in aList:
        aList.append(func)
        rulesDict[ch] = aList
</t>
<t tx="ekr.20150326145530.2"># Rules for forth_main ruleset.

def forth_block_comment_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="comment2", begin="(", end=")",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)

def forth_comment_rule(colorer, s, i):
    return colorer.match_eol_span(s, i, kind="comment1", seq="\\",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word
        delegate="", exclude_match=False)

def forth_keyword_rule(colorer, s, i):
    return colorer.match_keywords(s, i)

def forth_string_rule(colorer, s, i):
    return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
        at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word
        delegate="", exclude_match=False,
        no_escape=False, no_line_break=False, no_word_break=False)
# ==========================

if 0:

    def forth_rule0(colorer, s, i):
        return colorer.match_eol_span(s, i, kind="comment1", seq="#",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False)

    def forth_rule1(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="\"\"\"", end="\"\"\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule2(colorer, s, i):
        return colorer.match_span(s, i, kind="literal2", begin="'''", end="'''",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule3(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="\"", end="\"",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule4(colorer, s, i):
        return colorer.match_span(s, i, kind="literal1", begin="'", end="'",
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=False)

    def forth_rule5(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule6(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="!",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule7(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule8(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;=",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule9(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="+",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule10(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="-",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule11(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="/",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule12(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="*",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule13(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&gt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule14(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&lt;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule15(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="%",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule16(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="&amp;",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule17(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="|",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule18(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="^",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule19(colorer, s, i):
        return colorer.match_seq(s, i, kind="operator", seq="~",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, delegate="")

    def forth_rule20(colorer, s, i):
        return colorer.match_mark_previous(s, i, kind="function", pattern="(",
            at_line_start=False, at_whitespace_end=False, at_word_start=False, exclude_match=True)

    def forth_rule21(colorer, s, i):
        return colorer.match_keywords(s, i)
</t>
<t tx="ekr.20150326145530.3"># Properties for forth mode.
properties = {
    # "indentNextLines": "\\s*[^#]{3,}:\\s*(#.*)?",
    "lineComment": "\\",
}
# Attributes dict for forth_main ruleset.
forth_main_attributes_dict = {
    "default": "null",
    "digit_re": "",
    # "escape": "\\",
    "highlight_digits": "false",
    "ignore_case": "false",
    "no_word_sep": "",
}
# Dictionary of attributes dictionaries for forth mode.
attributesDictDict = {
    "forth_main": forth_main_attributes_dict,
}
# Keywords dict for forth_main ruleset.
forth_main_keywords_dict = {} # Created by extendForth class.
# Dictionary of keywords dictionaries for forth mode.
keywordsDictDict = {
    "forth_main": forth_main_keywords_dict,
}
# Rules dict for forth_main ruleset.
# This is extended by extendForth.
rulesDict = {
    '(': [forth_block_comment_rule],
    '\\': [forth_comment_rule],
    '"': [forth_string_rule],
}
# x.rulesDictDict for forth mode.
rulesDictDict = {
    "forth_main": rulesDict,
}
# Import dict for forth mode.
importDict = {}
</t>
<t tx="ekr.20150326145530.4">class extendForth(object):
    '''A helper class to extend the mode tables from @data forth-x settings.'''
    @others
</t>
<t tx="ekr.20150326145530.5">def __init__(self):
    self.c = None # set by pre_init_mode function.
    #
    # Default forth keywords: extended by @data forth-words
    # Forth words to be rendered in boldface: extended by @data forth-bold-words
    self.boldwords = []
    #
    # Forth bold-italics words: extended by @data forth-bold-italic-words
    # Note: on some boxen, bold italics may show in plain bold.
    self.bolditalicwords = []
    #
    # Forth words that define brackets: extended by @data forth-delimiter-pairs
    self.brackets = [] # Helper: a list of tuples.
    self.brackets1 = []
    self.brackets2 = []
    #
    # Words which define other words: extended by forth-defwords
    self.definingwords = []
    #
    # Forth words to be rendered in italics: extended by forth-italic-words
    self.italicwords = []
    #
    # Default keywords: extended by @data forth-keywords
    self.keywords = []
        # "variable", "constant", "code", "end-code",
        # "dup", "2dup", "swap", "2swap", "drop", "2drop",
        # "r&gt;", "&gt;r", "2r&gt;", "2&gt;r",
        # "if", "else", "then",
        # "begin", "again", "until", "while", "repeat",
        # "v-for", "v-next", "exit",
        # "meta", "host", "target", "picasm", "macro",
        # "needs", "include",
        # "'", "[']",
        # # ":", # Now a defining word.
        # ";",
        # "@", "!", ",", "1+", "+", "-",
        # "&lt;", "&lt;=", "=", "&gt;=", "&gt;",
        # "invert", "and", "or",
    #
    # Forth words which start strings: extended by @data forth-string-word-pairs
    self.stringwords = []
    self.stringwords1 = []
    self.stringwords2 = []
    self.verbose = False # True: tell when extending forth words.

</t>
<t tx="ekr.20150326145530.6">def init(self):
    '''Set our ivars from settings.'''
    c = self.c
    assert(c)
    table = (
        (self.definingwords, "forth-defwords"),
        (self.brackets, "forth-delimiter-pairs"),
        (self.keywords, "forth-words"),
        (self.stringwords, "forth-string-word-pairs"),
        (self.boldwords, "forth-bold-words"),
        (self.bolditalicwords, "forth-bold-italic-words"),
        (self.italicwords, "forth-italic-words"),
    )
    # Add entries from @data nodes (if they exist) to the corresponding lists.
    for(ivarList, setting) in table:
        extras = []
        aList = c.config.getData(setting)
        if aList:
            for s in aList:
                s = s.strip()
                if s and s[0] != '\\':
                    extras.append(s)
            if extras:
                if self.verbose:
                    if not g.app.unitTesting and not g.app.batchMode:
                        g.pr("Found extra forth: %s" % " ".join(extras))
                ivarList.extend(extras)
    # Create brackets1/2 and stringwords1/2 lists.
    table2 = (
        ("brackets", "@data forth-delimiter-pairs"),
        ("stringwords", "@data forth-string-word-pairs"),
    )
    for(ivar, setting) in table2:
        self.splitList(ivar, setting)
</t>
<t tx="ekr.20150326145530.7">def splitList(self, ivar, setting):
    '''Process lines containing pairs of entries
    in a list whose *name* is ivar.
    Put the results in ivars whose names are ivar1 and ivar2.'''
    result1 = []; result2 = []
    aList = getattr(self, ivar)
    # Look for pairs.  Comments have already been removed.
    for s in aList:
        pair = s.split(' ')
        if len(pair) == 2 and pair[0].strip() and pair[1].strip():
            result1.append(pair[0].strip())
            result2.append(pair[1].strip())
        else:
            g.es_print('%s: ignoring line: %s' % (setting, s))
    # Set the ivars.
    name1 = '%s1' % ivar
    name2 = '%s2' % ivar
    setattr(self, name1, result1)
    setattr(self, name2, result2)
</t>
<t tx="ekr.20150326145530.8">def createBracketRules(self):
    for z in self.brackets1:
        func = self.createBracketRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createBracketRule(self, begin):
    i = self.brackets1.index(begin)
    end = self.brackets2[i]

    def forth_bracket_rule(colorer, s, i):
        return colorer.match_span(s, i, kind="bracketRange", begin=begin, end=end,
            at_line_start=False, at_whitespace_end=False, at_word_start=True, # Require word.
            delegate="", exclude_match=False,
            no_escape=False, no_line_break=False, no_word_break=True) # Require word.

    return forth_bracket_rule
</t>
<t tx="ekr.20150326145530.9">def createDefiningWordRules(self):
    for z in self.definingwords:
        func = self.createDefiningWordRule(z)
        self.extendRulesDict(ch=z[0], func=func)

def createDefiningWordRule(self, word):

    def forth_defining_word_rule(colorer, s, i):

        return colorer.match_word_and_regexp(s, i,
            kind1="keyword2", # defining word
            word=word,
            kind2="keyword3", # bold
            pattern=r'(\s)*(\S)+',
            at_line_start=False, at_whitespace_end=False, at_word_start=False,
            exclude_match=False)

    return forth_defining_word_rule
</t>
<t tx="ekr.20150330033306.1">on_idle_count = 0

def on_idle(self):
    '''
    Check for changed open-with files and all external files in commanders
    for which @bool check_for_changed_external_file is True.
    '''
    if not g.app or g.app.killed:
        return
    self.on_idle_count += 1
    # New in Leo 5.7: always handle delayed requests.
    if g.app.windowList:
        c = g.app.log and g.app.log.c
        if c:
            c.outerUpdate()
    if 1:
        # Fix #262: Improve performance of check_for_changed_external_files.
        if self.unchecked_files:
            # Check all external files.
            for ef in self.unchecked_files:
                self.idle_check_open_with_file(ef)
            self.unchecked_files = []
        elif self.unchecked_commanders:
            # Check the next commander for which
            # @bool check_for_changed_external_file is True.
            c = self.unchecked_commanders.pop()
            self.idle_check_commander(c)
        else:
            # Add all commanders for which
            # @bool check_for_changed_external_file is True.
            self.unchecked_commanders = [
                z for z in g.app.commanders() if self.is_enabled(z)
            ]
            self.unchecked_files = [z for z in self.files if z.exists()]
    else:
        # First, check all existing open-with files.
        for ef in self.files: # A list of ExternalFile instances.
            if ef.exists():
                self.idle_check_open_with_file(ef)
        # Next, check all commanders for which
        # @bool check_for_changed_external_file is True.
        for c in g.app.commanders():
            if self.is_enabled(c):
                self.idle_check_commander(c)
</t>
<t tx="ekr.20150403044823.1">def idle_check_at_file_node(self, c, p):
    '''Check the @&lt;file&gt; node at p for external changes.'''
    path = g.fullPath(c, p)
    if self.has_changed(c, path):
        if p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Fix #1081: issue a warning.
            self.warn(c, path, p=p)
        elif self.ask(c, path, p=p):
            c.redraw(p=p)
            c.refreshFromDisk(p)
            c.redraw()
        # Always update the path &amp; time to prevent future warnings.
        self.set_time(path)
        self.checksum_d[path] = self.checksum(path)
</t>
<t tx="ekr.20150403045207.1">def has_changed(self, c, path):
    '''Return True if p's external file has changed outside of Leo.'''
    if not g.os_path_exists(path):
        return False
    if g.os_path_isdir(path):
        return False
    #
    # First, check the modification times.
    old_time = self.get_time(path)
    new_time = self.get_mtime(path)
    if not old_time:
        # Initialize.
        self.set_time(path, new_time)
        self.checksum_d[path] = self.checksum(path)
        return False
    if old_time == new_time:
        return False
    #
    # Check the checksums *only* if the mod times don't match.
    old_sum = self.checksum_d.get(path)
    new_sum = self.checksum(path)
    if new_sum == old_sum:
        # The modtime changed, but it's contents didn't.
        # Update the time, so we don't keep checking the checksums.
        # Return False so we don't prompt the user for an update.
        self.set_time(path, new_time)
        return False
    else:
        # The file has really changed.
        assert old_time, path
        if 0: # Fix bug 208: external change overwrite protection only works once
            # https://github.com/leo-editor/leo-editor/issues/208
            # These next two lines mean that if the Leo version
            # is changed (dirtied) again, overwrite will occur without warning.
            self.set_time(path, new_time)
            self.checksum_d[path] = new_sum
        return True
</t>
<t tx="ekr.20150403094619.1">class LeoLineTextWidget(QtWidgets.QFrame):
    '''
    A QFrame supporting gutter line numbers.
    
    This class *has* a QTextEdit.
    '''
    @others
</t>
<t tx="ekr.20150403094706.10">def eventFilter(self, obj, event):
    '''
    Update the line numbers for all events on the text edit and the viewport.
    This is easier than connecting all necessary signals.
    '''
    if obj in (self.edit, self.edit.viewport()):
        self.number_bar.update()
        return False
    else:
        return QtWidgets.QFrame.eventFilter(obj, event)
</t>
<t tx="ekr.20150403094706.2">class NumberBar(QtWidgets.QFrame):
    @others
</t>
<t tx="ekr.20150403094706.3">def __init__(self, c, e, *args):
    '''Ctor for NumberBar class.'''
    QtWidgets.QFrame.__init__(self, *args)
        # Init the base class.
    self.c = c
    self.edit = e
        # A QTextEdit.
    self.d = e.document()
        # A QTextDocument.
    self.fm = self.fontMetrics()
        # A QFontMetrics
    self.image = QtGui.QImage(g.app.gui.getImageImage(
        g.os_path_finalize_join(g.app.loadDir,
            '..', 'Icons', 'Tango','16x16', 'actions', 'stop.png')))
    self.highest_line = 0
        # The highest line that is currently visibile.
    # Set the name to gutter so that the QFrame#gutter style sheet applies.
    self.offsets = []
    self.setObjectName('gutter')
    self.reloadSettings()
</t>
<t tx="ekr.20150403094706.5">def update(self, *args):
    '''
    Updates the number bar to display the current set of numbers.
    Also, adjusts the width of the number bar if necessary.
    '''
    # w_adjust is used to compensate for the current line being bold.
    # Always allocate room for 2 columns
    width = self.fm.width(str(max(1000, self.highest_line))) + self.w_adjust
    if self.width() != width:
        self.setFixedWidth(width)
    QtWidgets.QWidget.update(self, *args)
</t>
<t tx="ekr.20150403094706.6">def paintEvent(self, event):
    '''
    Enhance QFrame.paintEvent.
    Paint all visible text blocks in the editor's document.
    '''
    e = self.edit
    d = self.d
    layout = d.documentLayout()
    # Compute constants.
    current_block = d.findBlock(e.textCursor().position())
    scroll_y = e.verticalScrollBar().value()
    page_bottom = scroll_y + e.viewport().height()
    # Paint each visible block.
    painter = QtGui.QPainter(self)
    block = d.begin()
    n = i = 0
    c = self.c
    translation = c.user_dict.get('line_number_translation', [])
    self.offsets = []
    while block.isValid():
        i = translation[n] if n &lt; len(translation) else n + 1
        n += 1
        top_left = layout.blockBoundingRect(block).topLeft()
        if top_left.y() &gt; page_bottom:
            break # Outside the visible area.
        bold = block == current_block
        self.paintBlock(bold, i, painter, top_left, scroll_y)
        block = block.next()
    self.highest_line = i
    painter.end()
    QtWidgets.QWidget.paintEvent(self, event)
        # Propagate the event.
</t>
<t tx="ekr.20150403094706.7">def paintBlock(self, bold, n, painter, top_left, scroll_y):
    '''Paint n, right justified in the line number field.'''
    c = self.c
    if bold:
        self.setBold(painter, True)
    s = str(n)
    pad = max(4, len(str(self.highest_line))) - len(s)
    s = ' '*pad + s
    # x = self.width() - self.fm.width(s) - self.w_adjust
    x = 0
    y = round(top_left.y()) - scroll_y + self.fm.ascent() + self.y_adjust
    self.offsets.append((n, y),)
    painter.drawText(x, y, s)
    if bold:
        self.setBold(painter, False)
    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    if not xdb.has_breakpoints():
        return
    path = g.fullPath(c, c.p)
    if xdb.has_breakpoint(path, n):
        target_r = QtCore.QRect(
            self.fm.width(s) + 16,
            top_left.y() + self.y_adjust - 2,
            16.0, 16.0)
        if self.image:
            source_r = QtCore.QRect(0.0, 0.0, 16.0, 16.0)
            painter.drawImage(target_r, self.image, source_r)
        else:
            painter.drawEllipse(target_r)
</t>
<t tx="ekr.20150403094706.8">def setBold(self, painter, flag):
    '''Set or clear bold facing in the painter, depending on flag.'''
    font = painter.font()
    font.setBold(flag)
    painter.setFont(font)
</t>
<t tx="ekr.20150403094706.9">def __init__(self, c, e, *args):
    '''Ctor for LineTextWidget.'''
    QtWidgets.QFrame.__init__(self, *args)
        # Init the base class.
    self.c = c
    self.setFrameStyle(self.StyledPanel | self.Sunken)
    self.edit = e # A QTextEdit
    e.setFrameStyle(self.NoFrame)
    # e.setAcceptRichText(False)
    self.number_bar = NumberBar(c, e)
    hbox = QtWidgets.QHBoxLayout(self)
    hbox.setSpacing(0)
    hbox.setContentsMargins(0, 0, 0, 0)
    hbox.addWidget(self.number_bar)
    hbox.addWidget(e)
    e.installEventFilter(self)
    e.viewport().installEventFilter(self)
</t>
<t tx="ekr.20150404045115.1">def idle_check_commander(self, c):
    '''
    Check all external files corresponding to @&lt;file&gt; nodes in c for
    changes.
    '''
    p = c.rootPosition()
    seen = set()
    while p:
        if p.v in seen:
            p.moveToNodeAfterTree()
        elif p.isAtCleanNode():
            # Fix #1074: nested @clean nodes.
            seen.add(p.v)
            self.idle_check_at_file_node(c, p)
            p.moveToThreadNext()
        elif p.isAnyAtFileNode():
            seen.add(p.v)
            self.idle_check_at_file_node(c, p)
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
</t>
<t tx="ekr.20150405200212.1">def ask(self, c, path, p=None):
    '''
    Ask user whether to overwrite an @&lt;file&gt; tree.
    Return True if the user agrees.
    '''
    if g.unitTesting:
        return False
    if c not in g.app.commanders():
        return False
    if self.yesno_all_time + 3 &gt;= time.time() and self.yesno_all_answer:
        self.yesno_all_time = time.time()  # Still reloading?  Extend time.
        return bool('yes' in self.yesno_all_answer.lower())
    if not p:
        for ef in self.files:
            if ef.path == path:
                where = ef.p.h
                break
        else:
            where = 'the outline node'
    else:
        where = p.h
    _is_leo = path.endswith(('.leo', '.db'))
    if _is_leo:
        s = '\n'.join([
            '%s has changed outside Leo.' %(g.splitLongFileName(path)),
            'Overwrite it?'
        ])
    else:
        s = '\n'.join([
            '%s has changed outside Leo.' % (g.splitLongFileName(path)),
            'Reload %s in Leo?' % (where),
        ])
    result = g.app.gui.runAskYesNoDialog(c, 'Overwrite the version in Leo?', s,
        yes_all=not _is_leo, no_all=not _is_leo)
    if result and "-all" in result.lower():
        self.yesno_all_time = time.time()
        self.yesno_all_answer = result.lower()
    return bool(result and 'yes' in result.lower())
        # Careful: may be unit testing.
</t>
<t tx="ekr.20150407124259.1">def idle_check_open_with_file(self, ef):
    '''Update the open-with node given by ef.'''
    assert isinstance(ef, ExternalFile), ef
    if ef.path and os.path.exists(ef.path):
        time = self.get_mtime(ef.path)
        if time and time != ef.time:
            ef.time = time # inhibit endless dialog loop.
            self.update_open_with_node(ef)
</t>
<t tx="ekr.20150407205631.1">def update_open_with_node(self, ef):
    '''Update the body text of ef.p to the contents of ef.path.'''
    assert isinstance(ef, ExternalFile), ef
    c, p = ef.c, ef.p.copy()
    # Ask the user how to resolve the conflict.
    if self.ask(c, ef.path, p=p):
        g.blue('updated %s' % p.h)
        s, e = g.readFileIntoString(ef.path)
        p.b = s
        if c.config.getBool('open-with-goto-node-on-update'):
            c.selectPosition(p)
        if c.config.getBool('open-with-save-on-update'):
            c.save()
        else:
            p.setDirty()
            c.setChanged(True)
</t>
<t tx="ekr.20150413091056.1">'''Warn if leoProjects.txt or leoToDo.txt contain any clones.'''

clones,nodes,seen = 0,0,set()
table = (
  '@file ../doc/leoProjects.txt',
  '@file ../doc/leoToDo.txt',
)

def check_clone(c,p0,root):
    '''Warn if p appears in any @&lt;file&gt; node outside of root's tree.'''
    global nodes,seen
    v = p0.v
    for p in c.all_positions():
        nodes += 1
        if p.v == v:
            # Check *all* ancestors, not just the nearest one.
            for parent in p.self_and_parents():
                nodes += 1
                if parent.isAnyAtFileNode() and parent.v != root.v:
                    if parent.v not in seen:
                        seen.add(parent.v)
                        g.es_print('%s and %s contain clone: %s' % (
                            root.h,parent.h,p0.h))

for h in table:
    root = g.findNodeAnywhere(c,h)
    if root:
        for p in root.self_and_subtree():
            nodes += 1
            if p.isCloned():
                clones += 1
                check_clone(c,p,root)
    else:
        g.es_print('not found',h,color='red')
print('done: %s nodes, %s clones' % (nodes,clones))

@tabwidth -4
@language python
</t>
<t tx="ekr.20150425145248.1">run-pylint
clone-to-at-spot
beautify-tree
cfa-code
sort-lines
# show-data
# test-ptb
check-clones
expand-log-pane
contract-log-pane</t>
<t tx="ekr.20150502050609.1">c.backup_helper(sub_dir='leoPy')
</t>
<t tx="ekr.20150507170849.1">g.cls()

print('===== Start =====')

class CreateDecorators(object):
    '''
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    '''
    def __init__(self,c,make_changes):
        self.c = c
        self.fixups = self.create_fixups()
        self.n = 0
        self.n_fail = 0
        self.make_changes=make_changes
        self.suppress = [
            'c.frame.body and c.frame.body.addEditor',
            'cls','cloneFindParents','cycleTabFocus',
            'k and k.keyboardQuit',
            'menuShortcutPlaceHolder','removeBlankLines',
            'saveBuffersKillLeo',
        ]
    @others

CreateDecorators(c,make_changes=False).run()
</t>
<t tx="ekr.20150507174711.1">def find_next_clone(self,p):
    v = p.v
    p = p.copy()
    p.moveToThreadNext()
    wrapped = False
    while 1:
        # g.trace(p.v,p.h)
        if p and p.v == v:
            break
        elif p:
            p.moveToThreadNext()
        elif wrapped:
            break
        else:
            wrapped = True
            p = c.rootPosition()
    return p
</t>
<t tx="ekr.20150507175246.1">def munge_lines(self,root,publicCommands):
    '''Return munged lines of '''
    # print('')
    # g.trace(root.h)
    s = publicCommands.b
    i,j = s.find('{'),s.find('}')
    s = s[i+1:j]
    # print(s)
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    # print('\n'.join(lines))
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150508062944.1">def run(self):
    '''Top-level code.'''
    self.n = 0
    found = g.findNodeAnywhere(c,'Found: getPublicCommands')
    assert found
    for child in found.children():
        publicCommands = self.find_next_clone(child)
        root = self.find_class(publicCommands)
        if root:
            lines = self.munge_lines(root,publicCommands)
            d = self.create_d(lines,publicCommands)
            self.create_decorators(d,root)
    print('\n%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150508063412.1">def create_decorators(self,d,root):
    '''Create decorators for all items in d in root's tree.'''
    # print('***** %s' % root.h)
    if root.h in self.fixups:
        roots = []
        aList = self.fixups.get(root.h)
        for root2_h in aList:
            root2 = g.findNodeAnywhere(self.c,root2_h)
            if root2:
                # g.trace(root.h,'=====&gt;',root2.h)
                roots.append(root2)
            else:
                g.trace('===== not found',root2_h)
    else:
        roots = [root]
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %30s %s' % (root.h,f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150508063538.1">def create_d(self,lines,publicCommands):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    if trace:
        print('')
        g.trace(publicCommands.h)
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150508063926.1">def find_class(self,p):
    '''Return the position of the class enclosing p.'''
    for p2 in p.parents():
        if p2.h.lower().find('class') &gt; -1 and p2.b.find('class') &gt; -1:
            return p2
    else:
        g.trace('*** no class for p.h')
        return None
</t>
<t tx="ekr.20150508071622.1">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    # g.trace('%45s %s' % (c_name,f_name))
    trace = False
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        # if changed and self.make_changes:
            # new_body = ''.join(result)
            # # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150508074623.1">def create_fixups(self):
    '''
    Return a fixup dict.
    Keys are headlines for classes.
    Values are new headlines of nodes containing the actual class.
    '''
    return {
        'ChapterCommandsClass': ['class ChapterController'],
        'EditCommandsClass': [
            'EditCommandsClass',
            'class Commands',
            'class LeoQtFrame',
            'class LeoBody',
        ],
        'class SearchCommandsClass': ['class LeoFind (LeoFind.py)'],
        'KeyHandlerCommandsClass (add docstrings)': [
            'class KeyHandlerClass',
            'class AutoCompleterClass',
        ]
    }
</t>
<t tx="ekr.20150509183433.1">g.cls()

# Changed files:
# leoApp.py
# leoAtFile.py
# leoCommands.py
# leoFileCommands.py
# leoFrame.py
# leoUndo.py
# qt_frame.py

make_changes = True
    # True, actually make the change

class CreateDecorators(object):
    '''
    A class to create decorators from tables in getPublicCommands.
    
    Note: the node "Found: getPublicCommands" must exist.
    '''
    def __init__(self):
        self.n = 0
        self.n_fail = 0
        self.s = self.define_s()
    @others

CreateDecorators().run()
</t>
<t tx="ekr.20150509183433.2">def create_d(self,lines):
    '''Create a dict. keys are method names; values are command names.'''
    trace = False
    d = {}
    for s in lines:
        aList = s.split()
        if len(aList) &gt; 2:
            aList = [aList[0],' '.join(aList[1:])]
        c_name,f_name = aList[0].strip(),aList[1].strip()
        if ' ' not in f_name:
            f_name = f_name.split('.')[-1]
        # if '(' in f_name:
            # f_name = f_name[:f_name.find('(')]
        if trace: g.trace('%45s %s' % (c_name,f_name))
        d [f_name] = c_name
    return d
</t>
<t tx="ekr.20150509183433.3">def create_decorator(self,c_name,f_name,root):
    '''
    Search root for a definition of f_name.
    If found, insert @cmd(f_name) before the definition.
    '''
    trace = True
    found = False
    decorator = "@cmd('%s')\n" % (c_name)
    for p in root.self_and_subtree(copy=False):
        changed,result = False,[]
        for s in g.splitLines(p.b):
            if g.match_word(s,0,'def ' + f_name):
                if found:
                    if f_name not in self.suppress:
                        g.trace('duplicate def',f_name)
                else:
                    changed,found = True,True
                    result.append(decorator)
                    # print('%s%s' % (decorator,s))
            result.append(s)
        if changed and make_changes:
            new_body = ''.join(result)
            print('%40s %s' % (p.h[:40],decorator.rstrip()))
            # use git as our undo :-)
            # p.b = new_body
    return found
</t>
<t tx="ekr.20150509183433.4">def create_decorators(self,d):
    '''Create decorators for all items in d in root's tree.'''
    table = (
        'class Commands', # c.
        'class LeoQtFrame', # f.
        'class LeoFrame', # f.
        'class LeoApp', # g.app.
        '@file leoAtFile.py', # c.atFileCommands
        '@file leoFileCommands.py', # c.fileCommands
        'class Undoer', # c.undoer
    )
    roots = []
    for h in table:
        root = g.findNodeAnywhere(c,h)
        assert root,h
        roots.append(root)
    for f_name in sorted(d.keys()):
        found = False
        for root in roots:
            c_name = d.get(f_name)
            found = self.create_decorator(c_name,f_name,root)
            if found: break
        if not found and f_name not in self.suppress:
            print('===== not found: %s' % (f_name))
            self.n_fail += 1
</t>
<t tx="ekr.20150509183433.8">def munge_lines(self,s):
    '''Return munged lines of s. '''
    lines = sorted([z.strip() for z in g.splitLines(s) if z.strip()])
    lines = [z for z in lines if not z.startswith('#')]
    lines = [z[:z.find('#')] if z.find('#') &gt; -1 else z for z in lines]
    lines = [z.rstrip().rstrip(',') for z in lines]
    lines = [z[1:] for z in lines]
    lines = [z.replace("':",' ') for z in lines]
    self.n += len(lines)
    return lines
</t>
<t tx="ekr.20150509183433.9">def run(self):
    '''Top-level code.'''
    lines = self.munge_lines(self.s)
    d = self.create_d(lines)
    self.create_decorators(d)
    print('%s commands %s failed' % (self.n,self.n_fail))
</t>
<t tx="ekr.20150509183832.1"># 'check-all-python-code':      c.checkAllPythonCode,
# 'check-python-code':          c.checkPythonCode,
# 'extract-python-method':        c.extractPythonMethod,
# 'extract-section':              c.extractSection,
# 'import-at-file':               c.importAtFile,
# 'import-at-root':               c.importAtRoot,
# 'import-cweb-files':            c.importCWEBFiles,
# 'import-derived-file':          c.importDerivedFile,
# 'import-flattened-outline':     c.importFlattenedOutline,
# 'import-noweb-files':           c.importNowebFiles,
# 'mark-changed-roots':           c.markChangedRoots,
# 'mark-clones':                c.markClones,
# 'open-compare-window':        c.openCompareWindow,
# 'open-online-tutorial':       c.leoTutorial,
# 'reformat-body':              c.reformatBody, # 2013/10/02.
def define_s(self):
    return '''
'abort-edit-headline':          f.abortEditLabelCommand,
'about-leo':                    c.about,
'add-comments':                 c.addComments,     
'beautify':                     c.beautifyPythonCode,
'beautify-all':                 c.beautifyAllPythonCode,
'beautify-c':                   c.beautifyCCode,
'beautify-tree':                c.beautifyPythonTree,
'cascade-windows':              f.cascade,
'check-derived-file':           c.atFileCommands.checkDerivedFile,
'check-leo-file':               c.fileCommands.checkLeoFile,
'check-outline':                c.fullCheckOutline,
'clean-recent-files':           c.cleanRecentFiles,
'clear-recent-files':           c.clearRecentFiles,
'clone-node':                   c.clone,
'clone-node-to-last-node':      c.cloneToLastNode,
'close-window':                 c.close,
'contract-all':                 c.contractAllHeadlines,
'contract-all-other-nodes':     c.contractAllOtherNodes,
'contract-node':                c.contractNode,
'contract-or-go-left':          c.contractNodeOrGoToParent,
'contract-parent':              c.contractParent,
'convert-all-blanks':           c.convertAllBlanks,
'convert-all-tabs':             c.convertAllTabs,
'convert-blanks':               c.convertBlanks,
'convert-tabs':                 c.convertTabs,
'copy-node':                    c.copyOutline,
'copy-text':                    f.copyText,
'cut-node':                     c.cutOutline,
'cut-text':                     f.cutText,
'de-hoist':                     c.dehoist,
'delete-comments':              c.deleteComments,
'delete-node':                  c.deleteOutline,
'demote':                       c.demote,
'dump-outline':                 c.dumpOutline,
'edit-headline':                c.editHeadline,
'end-edit-headline':            f.endEditLabelCommand,
'equal-sized-panes':            f.equalSizedPanes,
'execute-script':               c.executeScript,
'exit-leo':                     g.app.onQuit,
'expand-all':                   c.expandAllHeadlines,
'expand-all-subheads':          c.expandAllSubheads,
'expand-ancestors-only':        c.expandOnlyAncestorsOfNode,
'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
'expand-next-level':            c.expandNextLevel,
'expand-node':                  c.expandNode,
'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
'expand-prev-level':            c.expandPrevLevel,
'expand-to-level-1':            c.expandLevel1,
'expand-to-level-2':            c.expandLevel2,
'expand-to-level-3':            c.expandLevel3,
'expand-to-level-4':            c.expandLevel4,
'expand-to-level-5':            c.expandLevel5,
'expand-to-level-6':            c.expandLevel6,
'expand-to-level-7':            c.expandLevel7,
'expand-to-level-8':            c.expandLevel8,
'expand-to-level-9':            c.expandLevel9,
'export-headlines':             c.exportHeadlines,
'extract':                      c.extract,
'extract-names':                c.extractSectionNames,
'find-next-clone':              c.findNextClone,
'flatten-outline':              c.flattenOutline,
'flatten-outline-to-node':      c.flattenOutlineToNode,
'go-back':                      c.goPrevVisitedNode,
'go-forward':                   c.goNextVisitedNode,
'goto-first-node':              c.goToFirstNode,
'goto-first-sibling':           c.goToFirstSibling,
'goto-first-visible-node':      c.goToFirstVisibleNode,
'goto-last-node':               c.goToLastNode,
'goto-last-sibling':            c.goToLastSibling,
'goto-last-visible-node':       c.goToLastVisibleNode,
'goto-next-changed':            c.goToNextDirtyHeadline,
'goto-next-clone':              c.goToNextClone,
'goto-next-history-node':       c.goToNextHistory,
'goto-next-marked':             c.goToNextMarkedHeadline,
'goto-next-node':               c.selectThreadNext,
'goto-next-sibling':            c.goToNextSibling,
'goto-next-visible':            c.selectVisNext,
'goto-parent':                  c.goToParent,
'goto-prev-history-node':       c.goToPrevHistory,
'goto-prev-node':               c.selectThreadBack,
'goto-prev-sibling':            c.goToPrevSibling,
'goto-prev-visible':            c.selectVisBack,
'hide-invisibles':              c.hideInvisibles,
'hoist':                        c.hoist,
'import-file':                  c.importAnyFile,
'indent-region':                c.indentBody,
'insert-body-time':             c.insertBodyTime,
'insert-child':                 c.insertChild,
'insert-node':                  c.insertHeadline,
'insert-node-before':           c.insertHeadlineBefore,
'mark':                         c.markHeadline,
'mark-changed-items':           c.markChangedHeadlines,
'mark-subheads':                c.markSubheads,
'match-brackets':               c.findMatchingBracket,
'minimize-all':                 f.minimizeAll,
'move-outline-down':            c.moveOutlineDown,
'move-outline-left':            c.moveOutlineLeft,
'move-outline-right':           c.moveOutlineRight,
'move-outline-up':              c.moveOutlineUp,
'new':                          c.new,
'open-cheat-sheet-leo':         c.openCheatSheet,
'open-leoDocs-leo':             c.leoDocumentation,
'open-leoPlugins-leo':          c.openLeoPlugins,
'open-leoSettings-leo':         c.openLeoSettings,
'open-local-settings':          c.selectAtSettingsNode,
'open-myLeoSettings-leo':       c.openMyLeoSettings,
'open-offline-tutorial':        f.leoHelp,
'open-online-home':             c.leoHome,
'open-online-toc':              c.openLeoTOC,
'open-online-tutorials':        c.openLeoTutorials,
'open-online-videos':           c.openLeoVideos,
'open-outline':                 c.open,
'open-python-window':           c.openPythonWindow,
'open-quickstart-leo':          c.leoQuickStart,
'open-scripts-leo':             c.openLeoScripts,
'open-users-guide':             c.openLeoUsersGuide,
'open-with':                    c.openWith,
'outline-to-cweb':              c.outlineToCWEB,
'outline-to-noweb':             c.outlineToNoweb,
'paste-node':                   c.pasteOutline,
'paste-retaining-clones':       c.pasteOutlineRetainingClones,
'paste-text':                   f.pasteText,
'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
'pretty-print-python-code':     c.prettyPrintPythonCode,
'promote':                      c.promote,
'read-at-auto-nodes':           c.readAtAutoNodes,
'read-at-file-nodes':           c.readAtFileNodes,
'read-at-shadow-nodes':         c.readAtShadowNodes,
'read-file-into-node':          c.readFileIntoNode,
'read-outline-only':            c.readOutlineOnly,
'redo':                         c.undoer.redo,
'reformat-paragraph':           c.reformatParagraph,
'refresh-from-disk':            c.refreshFromDisk,
'remove-sentinels':             c.removeSentinels,
'resize-to-screen':             f.resizeToScreen,
'revert':                       c.revert,
'save-all':                     c.saveAll,
'save-file':                    c.save,
'save-file-as':                 c.saveAs,
'save-file-as-unzipped':        c.saveAsUnzipped,
'save-file-as-zipped':          c.saveAsZipped,
'save-file-to':                 c.saveTo,
'set-colors':                   c.colorPanel,
'set-font':                     c.fontPanel,
'settings':                     c.preferences,
'show-invisibles':              c.showInvisibles,
'sort-children':                c.sortChildren,
'sort-recent-files':            c.sortRecentFiles,
'sort-siblings':                c.sortSiblings,
'tangle':                       c.tangle,
'tangle-all':                   c.tangleAll,
'tangle-marked':                c.tangleMarked,
'toggle-active-pane':           f.toggleActivePane,
'toggle-angle-brackets':        c.toggleAngleBrackets,
'toggle-invisibles':            c.toggleShowInvisibles,
'toggle-sparse-move':           c.toggleSparseMove,
'toggle-split-direction':       f.toggleSplitDirection,
'undo':                         c.undoer.undo,
'unformat-paragraph':           c.unformatParagraph,
'unindent-region':              c.dedentBody,
'unmark-all':                   c.unmarkAll,
'untangle':                     c.untangle,
'untangle-all':                 c.untangleAll,
'untangle-marked':              c.untangleMarked,
'weave':                        c.weave,
'write-at-auto-nodes':          c.atFileCommands.writeAtAutoNodes,
'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
'write-at-shadow-nodes':        c.fileCommands.writeAtShadowNodes,
'write-dirty-at-auto-nodes':    c.atFileCommands.writeDirtyAtAutoNodes,
'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
'write-dirty-at-shadow-nodes':  c.fileCommands.writeDirtyAtShadowNodes,
'write-file-from-node':         c.writeFileFromNode,
'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
'write-outline-only':           c.fileCommands.writeOutlineOnly,
'''
</t>
<t tx="ekr.20150509194251.1">def cmd(name):
    '''Command decorator for the AtFileCommands class.'''
    # pylint: disable=no-self-argument
    return g.new_cmd_decorator(name, ['c', 'atFileCommands',])
</t>
<t tx="ekr.20150514035207.1"></t>
<t tx="ekr.20150514043850.8">def init_settings(self):
    '''Called from AbbrevCommands.reload_settings aka reloadSettings.'''
    c = self.c
    c.k.abbrevOn = c.config.getBool('enable-abbreviations', default=False)
    # Init these here for k.masterCommand.
    c.abbrev_place_end = c.config.getString('abbreviations-place-end')
    c.abbrev_place_start = c.config.getString('abbreviations-place-start')
    c.abbrev_subst_end = c.config.getString('abbreviations-subst-end')
    c.abbrev_subst_env = {'c': c, 'g': g, '_values': {},}
        # The environment for all substitutions.
        # May be augmented in init_env.
    c.abbrev_subst_start = c.config.getString('abbreviations-subst-start')
    # Local settings.
    self.enabled = (
        c.config.getBool('scripting-at-script-nodes') or
        c.config.getBool('scripting-abbreviations'))
    self.globalDynamicAbbrevs = c.config.getBool('globalDynamicAbbrevs')
    # @data abbreviations-subst-env must *only* be defined in leoSettings.leo or myLeoSettings.leo!
    if c.config:
        key = 'abbreviations-subst-env'
        if c.config.isLocalSetting(key, 'data'):
            g.issueSecurityWarning('@data %s' % key)
            self.subst_env = ""
        else:
            self.subst_env = c.config.getData(key, strip_data=False)
</t>
<t tx="ekr.20150514043850.9">def init_tree_abbrev(self):
    '''Init tree_abbrevs_d from @data tree-abbreviations nodes.'''
    c = self.c
    #
    # Careful. This happens early in startup.
    root = c.rootPosition()
    if not root:
        return
    if not c.p:
        c.selectPosition(root)
    if not c.p:
        return
    data = c.config.getOutlineData('tree-abbreviations')
    if data is None:
        return
    d = {}
    # #904: data may be a string or a list of two strings.
    aList = [data] if g.isString(data) else data
    for tree_s in aList:
        #
        # Expand the tree so we can traverse it.
        if not c.canPasteOutline(tree_s):
            return
        c.fileCommands.leo_file_encoding = 'utf-8'
        #
        # As part of #427, disable all redraws.
        try:
            old_disable = g.app.disable_redraw
            g.app.disable_redraw = True
            self.init_tree_abbrev_helper(d, tree_s)
        finally:
            g.app.disable_redraw = old_disable
    self.tree_abbrevs_d = d
</t>
<t tx="ekr.20150523132558.1">class OutputToken(object):
    '''A class representing Output Tokens'''

    def __init__(self, kind, value):
        self.kind = kind
        self.value = value

    def __repr__(self):
        if self.kind == 'line-indent':
            assert not self.value.strip(' ')
            return '%15s %s' % (self.kind, len(self.value))
        else:
            return '%15s %r' % (self.kind, self.value)

    __str__ = __repr__

    def to_string(self):
        '''Convert an output token to a string.'''
        return self.value if g.isString(self.value) else ''
</t>
<t tx="ekr.20150526201701.12">def op(self, s):
    '''Add op token to code list.'''
    assert s and g.isString(s), repr(s)
    self.blank()
    self.add_token('op', s)
    self.blank()

def op_blank(self, s):
    '''Remove a preceding blank token, then add op and blank tokens.'''
    assert s and g.isString(s), repr(s)
    self.clean('blank')
    self.add_token('op', s)
    self.blank()

def op_no_blanks(self, s):
    '''Add an operator *not* surrounded by blanks.'''
    self.clean('blank')
    self.add_token('op-no-blanks', s)
</t>
<t tx="ekr.20150526201701.13">def word(self, s):
    '''Add a word request to the code list.'''
    assert s and g.isString(s), repr(s)
    self.blank()
    self.add_token('word', s)
    self.blank()

def word_op(self, s):
    '''Add a word-op request to the code list.'''
    assert s and g.isString(s), repr(s)
    self.blank()
    self.add_token('word-op', s)
    self.blank()
</t>
<t tx="ekr.20150527213419.1">def possible_unary_op(self, s):
    '''Add a unary or binary op to the token list.'''
    self.clean('blank')
    prev = self.code_list[-1]
    if prev.kind in ('lt', 'op', 'op-no-blanks', 'word-op'):
        self.unary_op(s)
    elif prev.kind == 'word' and prev.value in ('elif', 'if', 'return', 'while'):
        self.unary_op(s)
    else:
        self.op(s)

def unary_op(self, s):
    '''Add an operator request to the code list.'''
    assert s and g.isString(s), repr(s)
    self.blank()
    self.add_token('unary-op', s)
</t>
<t tx="ekr.20150531102337.1"></t>
<t tx="ekr.20150602204757.1">def autoBeautify(self, p):
    '''Auto beautify p's tree if allowed by settings and directives.'''
    c = self.c
    try:
        if not p.isDirty():
            return
        if leoBeautify.should_kill_beautify(p):
            return
        if c.config.getBool('tidy-autobeautify'):
            leoBeautify.beautifyPythonTree(event={'c': c, 'p0': p.copy()})
    except Exception:
        g.es('unexpected exception')
        g.es_exception()
</t>
<t tx="ekr.20150604130353.1">gnx: ekr.20150604130223.363
</t>
<t tx="ekr.20150604130353.2"></t>
<t tx="ekr.20150617060607.1"></t>
<t tx="ekr.20150618072619.1">def create_find_status(self, grid, parent, row):
    '''Create the status line.'''
    dw = self
    status_label = dw.createLabel(parent, 'status-label', 'Status')
    status_line = dw.createLineEdit(parent, 'find-status', disabled=True)
    grid.addWidget(status_label, row, 0)
    grid.addWidget(status_line, row, 1, 1, 2)
    # Official ivars.
    dw.find_status_label = status_label
    dw.find_status_edit = status_line
</t>
<t tx="ekr.20150622072456.1">def match_at_wrap(self, s, i):
    '''Match Leo's @wrap directive.'''
    c = self.c
    # Only matches at start of line.
    seq = '@wrap'
    if i == 0 and g.match_word(s, i, seq):
        j = i + len(seq)
        k = g.skip_ws(s, j)
        self.colorRangeWithTag(s, i, k, 'leokeyword')
        c.frame.setWrap(c.p, force=True)
        return k - i
    else:
        return 0
</t>
<t tx="ekr.20150703061709.1">@language python

'''myLeoSettings.py: save the outline and run the pylint command'''

# print('@button run-pylint: %s' % c.shortFileName())
if c.isChanged():
    c.save()
c.k.simulateCommand('pylint')
</t>
<t tx="ekr.20150722051946.2">def flatten_list(obj):
    '''A generator yielding a flattened (concatenated) version of obj.'''
    if isinstance(obj, dict) and obj.get('_join_list'):
        # join_list created obj, and ensured that all args are strings.
        indent = obj.get('indent') or ''
        leading = obj.get('leading') or ''
        sep = obj.get('sep') or ''
        trailing = obj.get('trailing') or ''
        aList = obj.get('aList')
        for i, item in enumerate(aList):
            if leading: yield leading
            for s in flatten_list(item):
                if indent and s.startswith('\n'):
                    yield '\n' + indent + s[1:]
                else:
                    yield s
            if sep and i &lt; len(aList) - 1: yield sep
            if trailing: yield trailing
    elif isinstance(obj, (list, tuple)):
        for obj2 in obj:
            for s in flatten_list(obj2):
                yield s
    elif obj:
        if g.isString(obj):
            yield obj
        else:
            yield repr(obj) # Not likely to be useful.
    else:
        pass # Allow None and empty containers.
</t>
<t tx="ekr.20150722051946.3">def join_list(aList, indent='', leading='', sep='', trailing=''):
    '''
    Create a dict representing the concatenation of the
    strings in aList, formatted per the keyword args.
    See the HTMLReportTraverser class for many examples.
    '''
    if not aList:
        return None
    if 1: # These asserts are reasonable.
        assert g.isString(indent), indent
        assert g.isString(leading), leading
        assert g.isString(sep), sep
        assert g.isString(trailing), trailing
    else: # This generality is not likely to be useful.
        if leading and not g.isString(leading):
            leading = list_to_string(leading)
        if sep and not g.isString(sep):
            sep = list_to_string(sep)
        if trailing and not g.isString(trailing):
            trailing = list_to_string(trailing)
    if indent or leading or sep or trailing:
        return {
            '_join_list': True, # Indicate that join_list created this dict.
            'aList': aList,
            'indent': indent, 'leading': leading, 'sep': sep, 'trailing': trailing,
        }
    else:
        return aList
</t>
<t tx="ekr.20150722204300.85"># Raise(expr? type, expr? inst, expr? tback)    Python 2
# Raise(expr? exc, expr? cause)                 Python 3

def do_Raise(self, node):

    self.div('statement')
    self.keyword("raise")
    attrs = ('exc', 'cause') if g.isPython3 else ('type', 'inst', 'tback')
    for attr in attrs:
        if getattr(node, attr, None) is not None:
            self.visit(getattr(node, attr))
    self.end_div('statement')
</t>
<t tx="ekr.20150722204300.88">def do_Str(self, node):
    '''This represents a string constant.'''

    def clean(s):
        return s.replace(' ','').replace('\n','').replace('"','').replace("'",'')

    assert g.isString(node.s)
    if self.last_doc and clean(self.last_doc) == clean(node.s):
        # Already seen.
        self.last_doc = None
    else:
        self.string(node.s)
</t>
<t tx="ekr.20160122104332.1">@language python
</t>
<t tx="ekr.20160123142722.1"># An example configuration file for make_stub_files.py.
# By default, this is ~/stubs/make_stub_files.cfg.
# Can be changed using the --config=path command-line option.

[Global]

files:

    # Files to be used *only* if no files are given on the command line.
    # glob.glob wildcards are supported.

    # c:/leo.repo/leo-editor/leo/core/leoAst.py
    # c:/leo.repo/leo-editor/leo/core/*.py
    # c:/leo.repo/leo-editor/plugins/*.py

output_directory: ~/stubs

prefix_lines:
    # Lines to be inserted at the start of each stub file.
    from typing import TypeVar, Iterable, Tuple
    T = TypeVar('T', int, float, complex)

[Def Name Patterns]

[General Patterns]
</t>
<t tx="ekr.20160225102931.9">def dump_token(self, token, verbose=False):
    '''Dump the token. It is either a string or a 5-tuple.'''
    if g.isString(token):
        return token
    else:
        t1, t2, t3, t4, t5 = token
        kind = g.toUnicode(token_module.tok_name[t1].lower())
        # raw_val = g.toUnicode(t5)
        val = g.toUnicode(t2)
        if verbose:
            return 'token: %10s %r' % (kind, val)
        else:
            return val
</t>
<t tx="ekr.20160229070349.2">if isPython3:

    def isBytes(s):
        '''Return True if s is Python3k bytes type.'''
        return isinstance(s, bytes)
        
else:

    def isBytes(s):
        '''Return True if s is Python3k bytes type.'''
        return False
</t>
<t tx="ekr.20160229070349.3">def isCallable(obj):
    if g.isPython3:
        return hasattr(obj, '__call__')
    else:
        return callable(obj)
</t>
<t tx="ekr.20160229070349.5">if isPython3:

    def isString(s):
        '''Return True if s is any string, but not bytes.'''
        # pylint: disable=no-member
        return isinstance(s, str)

else:

     def isString(s):
        '''Return True if s is any string, but not bytes.'''
        # pylint: disable=no-member
        return isinstance(s, types.StringTypes)
</t>
<t tx="ekr.20160229070349.6">if isPython3:
    
    def isUnicode(s):
        '''Return True if s is a unicode string.'''
        # pylint: disable=no-member
        return isinstance(s, str)

else:

    def isUnicode(s):
        '''Return True if s is a unicode string.'''
        # pylint: disable=no-member
        return isinstance(s, types.UnicodeType)
</t>
<t tx="ekr.20160229070429.1">def isInt(obj):
    '''Return True if obj is an int or a long.'''
    # 'long' does not exist in Python 3.
    # pylint: disable=no-member
    # pylint: disable=undefined-variable
    if g.isPython3:
        return isinstance(obj, int)
    else:
        return isinstance(obj, (int, builtins.long))
</t>
<t tx="ekr.20160417174224.1">def plural(obj):
    '''Return "s" or "" depending on n.'''
    if isinstance(obj, (list, tuple)) or g.isString(obj):
        n = len(obj)
    else:
        n = obj
    return '' if n == 1 else 's'
</t>
<t tx="ekr.20160420054135.4">gnx: ekr.20160412193816.5
unl: qt_quicksearch declarations
gnx: ekr.20160412193816.6
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20160412193816.7
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20160412193816.8
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20160420054135.5"></t>
<t tx="ekr.20160425070345.1">gnx: ekr.20160412193816.1
unl: qt_main declarations
gnx: ekr.20160412193816.2
unl: class Ui_MainWindow
gnx: ekr.20160412193816.3
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20160412193816.4
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20160425070345.2"></t>
<t tx="ekr.20160503125844.1">def create_outline(self, path):
    '''Create a tree of nodes from a FreeMind file.'''
    c = self.c
    junk, fileName = g.os_path_split(path)
    undoData = c.undoer.beforeInsertNode(c.p)
    try:
        self.import_file(path)
        c.undoer.afterInsertNode(c.p, 'Import', undoData)
    except Exception:
        g.es_print('Exception importing FreeMind file', g.shortFileName(path))
        g.es_exception()
    return c.p
</t>
<t tx="ekr.20160503145113.1">def import_files(self, files):
    '''Import a list of FreeMind (.mmap) files.'''
    c = self.c
    if files:
        self.tab_width = c.getTabWidth(c.p)
        for fileName in files:
            g.setGlobalOpenDir(fileName)
            p = self.create_outline(fileName)
            p.contract()
            p.setDirty()
            c.setChanged(True)
        c.redraw(p)
</t>
<t tx="ekr.20160503145550.1">class FreeMindImporter(object):
    '''Importer class for FreeMind (.mmap) files.'''

    def __init__(self, c):
        '''ctor for FreeMind Importer class.'''
        self.c = c
        self.count = 0
        self.d = {}

    @others
</t>
<t tx="ekr.20160503191518.4">def import_file(self, path):
    '''The main line of the FreeMindImporter class.'''
    c = self.c
    sfn = g.shortFileName(path)
    if g.os_path_exists(path):
        htmltree = lxml.html.parse(path)
        root = htmltree.getroot()
        body = root.findall('body')[0]
        if body is None:
            g.error('no body in: %s' % sfn)
        else:
            root_p = c.lastTopLevel().insertAfter()
            root_p.h = g.shortFileName(path)
            for child in body:
                if child != body:
                    self.add_children(root_p, child)
            c.selectPosition(root_p)
            c.redraw()
    else:
        g.error('file not found: %s' % sfn)
</t>
<t tx="ekr.20160504043823.1">def prompt_for_files(self):
    '''Prompt for a list of FreeMind (.mm.html) files and import them.'''
    c = self.c
    types = [
        ("FreeMind files", "*.mm.html"),
        ("All files", "*"),
    ]
    names = g.app.gui.runOpenFileDialog(c,
        title="Import FreeMind File",
        filetypes=types,
        defaultextension=".html",
        multiple=True)
    c.bringToFront()
    if names:
        g.chdir(names[0])
        self.import_files(names)
</t>
<t tx="ekr.20160504144353.1">def create_nodes(self, parent, parent_d):
    '''Create the tree of nodes rooted in parent.'''
    d = self.gnx_dict
    for child_gnx in parent_d.get('children'):
        d2 = d.get(child_gnx)
        if child_gnx in self.vnodes_dict:
            # It's a clone.
            v = self.vnodes_dict.get(child_gnx)
            n = parent.numberOfChildren()
            child = leoNodes.Position(v)
            child._linkAsNthChild(parent, n)
            # Don't create children again.
        else:
            child = parent.insertAsLastChild()
            child.h = d2.get('h') or '&lt;**no h**&gt;'
            child.b = d2.get('b') or g.u('')
            if d2.get('gnx'):
                child.v.findIndex = gnx = d2.get('gnx')
                self.vnodes_dict[gnx] = child.v
            if d2.get('ua'):
                child.u = d2.get('ua')
            self.create_nodes(child, d2)
</t>
<t tx="ekr.20160514120655.1">class AtFile(object):
    """A class implementing the atFile subcommander."""
    &lt;&lt; define class constants &gt;&gt;
    @others

atFile = AtFile # compatibility
</t>
<t tx="ekr.20160517133049.4">def get_flake8_config(self):
    '''Return the path to the pylint configuration file.'''
    join = g.os_path_finalize_join
    dir_table = (
        g.app.homeDir,
        join(g.app.homeDir, '.leo'),
        join(g.app.loadDir, '..', '..', 'leo', 'test'),
    )
    if g.isPython3:
        base_table = ('flake8', 'flake8.txt')
    else:
        base_table = ('flake8',)
    for base in base_table:
        for path in dir_table:
            fn = g.os_path_abspath(join(path, base))
            if g.os_path_exists(fn):
                return fn
    if not g.unitTesting:
        g.es_print('no flake8 configuration file found in\n%s' % (
            '\n'.join(dir_table)))
    return None
</t>
<t tx="ekr.20160518074545.9">def get_files_for_scope(self, scope, fn):
    '''Return a list of absolute filenames for external linters.'''
    d = {
        'all':      [self.core, self.commands, self.external, self.plugins], #  self.modes
        'commands': [self.commands],
        'core':     [self.core, self.commands, self.external, self.gui_plugins],
        'external': [self.external],
        'file':     [fn],
        'gui':      [self.gui_plugins],
        'modes':    [self.modes],
        'plugins':  [self.plugins],
    }
    functions = d.get(scope)
    paths = []
    if functions:
        for func in functions:
            files = [func] if g.isString(func) else func()
                # Bug fix: 2016/10/15
            for fn in files:
                fn = g.os_path_abspath(fn)
                if g.os_path_exists(fn):
                    if g.os_path_isfile(fn):
                        paths.append(fn)
                else:
                    print('does not exist: %s' % fn)
        paths = sorted(set(paths))
        return paths
    else:
        print('LinterTable.get_table: bad scope', scope)
        return []
</t>
<t tx="ekr.20160917125948.1">def getTextFromClipboard(self):
    '''Get a unicode string from the clipboard.'''
    cb = self.qtApp.clipboard()
    if cb:
        QtWidgets.QApplication.processEvents()
        s = cb.text()
        # Fix bug 147: Python 3 clipboard encoding
        s = g.u(s)
            # Don't call g.toUnicode here!
            # s is a QString, which isn't exactly a unicode string!
        return s
    else:
        g.trace('no clipboard!')
        return ''
</t>
<t tx="ekr.20161021084954.1">def runPyflakes(self, root, pyflakes_errors_only):
    '''Run pyflakes on the selected node.'''
    try:
        import leo.commands.checkerCommands as checkerCommands
        if checkerCommands.pyflakes:
            x = checkerCommands.PyflakesCommand(self.c)
            ok = x.run(p=root,pyflakes_errors_only=pyflakes_errors_only)
            return ok
        else:
            return True # Suppress error if pyflakes can not be imported.
    except Exception:
        g.es_exception()
</t>
<t tx="ekr.20161028090624.1">class ProcessData(object):
    '''A class to hold data about running or queued processes.'''

    def __init__(self, c, kind, fn, link_pattern, link_root, shell):
        '''Ctor for the ProcessData class.'''
        self.c = c
        self.callback = None
        self.fn = fn
        self.kind = kind
        self.link_pattern = None
        self.link_root = link_root
        self.shell = shell
        #
        # Check and compile the link pattern.
        if link_pattern and g.isString(link_pattern):
            try:
                self.link_pattern = re.compile(link_pattern)
            except Exception:
                g.trace('Invalid link pattern: %s' % link_pattern)
                self.link_pattern = None

    def __repr__(self):
        return 'c: %s kind: %s callback: %s fn: %s shell: %s' % (
            self.c.shortFileName(),
            self.kind,
            id(self.callback) if self.callback else None,
            self.fn,
            self.shell,
        )

    __str__ = __repr__
</t>
<t tx="ekr.20161223082445.1">def isList(s):
    '''Return True if s is a list.'''
    # pylint: disable=no-member
    if g.isPython3:
        return isinstance(s, list)
    else:
        return isinstance(s, types.ListTypes)
</t>
<t tx="ekr.20161223090721.1">def exec_file(path, d, script=None):
    '''Simulate python's execfile statement for python 3.'''
    # pylint: disable=no-member
    # execfile does not exist in python 3.
    if g.isPython3:
        if script is None:
            with open(path) as f:
                script = f.read()
        exec(compile(script, path, 'exec'), d)
    else:
        builtins.execfile(path, d)
</t>
<t tx="ekr.20170108034643.1">def ustr(s):
    '''Define the pyzo ustr function.'''
    # pylint: disable=no-member
    return str(s) if isPython3 else g.builtins.unicode(s)
</t>
<t tx="ekr.20170125140113.1">def restartColor(self, s):
    '''Change all lines up to the next color directive.'''
    if g.match_word(s, 0, '@killcolor'):
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
        self.setRestart(self.restartKillColor)
        return -len(s) # Continue to suppress coloring.
    elif g.match_word(s, 0, '@nocolor-node'):
        self.setRestart(self.restartNoColorNode)
        return -len(s) # Continue to suppress coloring.
    elif g.match_word(s, 0, '@nocolor'):
        self.setRestart(self.restartNoColor)
        return -len(s) # Continue to suppress coloring.
    else:
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enables coloring of *this* line.
        return 0 # Allow colorizing!
</t>
<t tx="ekr.20170125141148.1">def inColorState(self):
    '''True if the *current* state is enabled.'''
    n = self.currentState()
    state = self.stateDict.get(n, 'no-state')
    enabled = (
        not state.endswith('@nocolor') and
        not state.endswith('@nocolor-node') and
        not state.endswith('@killcolor'))
    return enabled


</t>
<t tx="ekr.20170126100139.1">def initBlock0 (self):
    '''
    Init *local* ivars when handling block 0.
    This prevents endless recalculation of the proper default state.
    '''
    if self.enabled:
        n = self.setInitialStateNumber()
    else:
        n = self.setRestart(self.restartNoColor)
    return n
</t>
<t tx="ekr.20170126101049.1">def setInitialStateNumber(self):
    '''
    Init the initialStateNumber ivar for clearState()
    This saves a lot of work.

    Called from init() and initBlock0.
    '''
    state = self.languageTag(self.language)
    n = self.stateNameToStateNumber(None, state)
    self.initialStateNumber = n
    self.blankStateNumber = self.stateNameToStateNumber(None,state+';blank')
    return n
</t>
<t tx="ekr.20170126103925.1">def languageTag(self, name):
    '''
    Return the standardized form of the language name.
    Doing this consistently prevents subtle bugs.
    '''
    if name:
        table = (
            ('markdown', 'md'),
            ('python', 'py'),
            ('javascript', 'js'),
        )
        for pattern, s in table:
            name = name.replace(pattern, s)
        return name
    else:
        return 'no-language'
</t>
<t tx="ekr.20170127141855.1">class BaseColorizer(object):
    '''The base class for all Leo colorizers.'''

    def __init__ (self, c):
        '''ctor for BaseColorizer class.'''
        self.c = c
        self.count = 0
        self.enabled = False
        self.full_recolor_count = 0
        self.highlighter = g.NullObject()
            # Overridden in subclasses.
        self.showInvisibles = False

    def init(self, p):
        '''May be over-ridden in subclasses.'''
        pass

    @others
</t>
<t tx="ekr.20170127142001.1">at_language_pattern = re.compile(r'^@language\s+([\w-]+)', re.MULTILINE)

def updateSyntaxColorer(self, p):
    '''
    Scan for color directives in p and its ancestors.
    Return True unless an coloring is unambiguously disabled.
    Called from Leo's node-selection logic and from the colorizer.
    '''
    if p: # This guard is required.
        try:
            self.enabled = self.useSyntaxColoring(p)
            self.language = self.scanLanguageDirectives(p)
        except Exception:
            g.es_print('unexpected exception in updateSyntaxColorer')
            g.es_exception()
</t>
<t tx="ekr.20170127142001.2">def scanLanguageDirectives(self, p, use_default=True):
    '''Return language based on the directives in p's ancestors.'''
    c = self.c
    root = p.copy()
    # Look for the first @language directive only in p itself.
    language = self.findFirstValidAtLanguageDirective(p)
    if language:
        return language
    for p in root.parents():
        languages = self.findAllValidLanguageDirectives(p)
        if len(languages) == 1: # An unambiguous language
            language = languages[0]
            return language
    #  Get the language from the nearest ancestor @&lt;file&gt; node.
    language = g.getLanguageFromAncestorAtFileNode(root)
    if not language and use_default:
        language = c.target_language
    return language

</t>
<t tx="ekr.20170127142001.5">def findFirstValidAtLanguageDirective(self, p):
    '''Return the first *valid* @language directive in p.b.'''
    for m in self.at_language_pattern.finditer(p.b):
        language = m.group(1)
        if self.isValidLanguage(language):
            return language
    return None

</t>
<t tx="ekr.20170127142001.6">def isValidLanguage(self, language):
    '''True if language exists in leo/modes.'''
    fn = g.os_path_join(g.app.loadDir, '..', 'modes', '%s.py' % (language))
    return g.os_path_exists(fn)
</t>
<t tx="ekr.20170127142001.7">def useSyntaxColoring(self, p):
    '''True if p's parents enable coloring in p.'''
    # Special cases for the selected node.
    d = self.findColorDirectives(p)
    if 'killcolor' in d: return False
    if 'nocolor-node' in d: return False
    # Now look at the parents.
    for p in p.parents():
        d = self.findColorDirectives(p)
        # @killcolor anywhere disables coloring.
        if 'killcolor' in d: return False
        # unambiguous @color enables coloring.
        elif 'color' in d and 'nocolor' not in d: return True
        # Unambiguous @nocolor disables coloring.
        elif 'nocolor' in d and 'color' not in d: return False
    return True
</t>
<t tx="ekr.20170127142001.8">color_directives_pat = re.compile(
    # Order is important: put longest matches first.
    r'(^@color|^@killcolor|^@nocolor-node|^@nocolor)'
    , re.MULTILINE)

def findColorDirectives(self, p):
    '''Return a dict with each color directive in p.b, without the leading '@'.'''
    d = {}
    for m in self.color_directives_pat.finditer(p.b):
        word = m.group(0)[1:]
        d[word] = word
    return d
</t>
<t tx="ekr.20170201082248.1">def init_all_state(self, v):
    '''Completely init all state data.'''
    assert self.language, g.callers(8)
    self.old_v = v
    self.n2languageDict = {-1: self.language}
    self.nextState = 1 # Dont use 0.
    self.restartDict = {}
    self.stateDict = {}
    self.stateNameDict = {}
</t>
<t tx="ekr.20170201150505.1">def findAllValidLanguageDirectives(self, p):
    '''Return list of all valid @language directives in p.b'''
    languages = set()
    for m in self.at_language_pattern.finditer(p.b):
        language = m.group(1)
        if self.isValidLanguage(language):
            languages.add(language)
    return list(sorted(languages))
</t>
<t tx="ekr.20170204072452.1">image_url = re.compile(r'^\s*&lt;\s*img\s+.*src=\"(.*)\".*&gt;\s*$')

def match_image(self, s, i):
    '''Matcher for &lt;img...&gt;'''
    m = self.image_url.match(s,i)
    if m:
        self.image_src = src = m.group(1)
        j = len(src)
        doc = self.highlighter.document()
        block_n = self.currentBlockNumber()
        text_block = doc.findBlockByNumber(block_n)
        g.trace('block_n: %2s %s' % (block_n, repr(s)))
        g.trace('block text: %s' % repr(text_block.text()))
            # How to get the cursor of the colorized line.
                # body = self.c.frame.body
                # s = body.wrapper.getAllText()
                # wrapper.delete(0, j)
                # cursor.insertHtml(src)
        return j
    else:
        return 0
</t>
<t tx="ekr.20170205055743.1">def set_wikiview_patterns(self, leadins, patterns):
    '''
    Init the colorizer so it will *skip* all patterns.
    The wikiview plugin calls this method.
    '''
    d = self.rulesDict
    for leadins_list, pattern in zip(leadins, patterns):
        for ch in leadins_list:

            def wiki_rule(self, s, i, pattern=pattern):
                '''Bind pattern and leadin for jedit.match_wiki_pattern.'''
                return self.match_wiki_pattern(s, i, pattern)

            aList = d.get(ch, [])
            if wiki_rule not in aList:
                aList.insert(0, wiki_rule)
                d [ch] = aList
    self.rulesDict = d
</t>
<t tx="ekr.20170205074106.1">def match_wiki_pattern(self, s, i, pattern):
    '''Show or hide a regex pattern managed by the wikiview plugin.'''
    m = pattern.match(s,i)
    if m:
        n = len(m.group(0))
        self.colorRangeWithTag(s, i, i + n, 'url')
        return n
    else:
        return 0
</t>
<t tx="ekr.20170216091704.1">def openUrlHelper(event, url=None):
    '''Open the UNL or URL under the cursor.  Return it for unit testing.'''
    c = getattr(event, 'c', None)
    if not c: return None
    w = getattr(event, 'w', c.frame.body.wrapper)
    if not g.app.gui.isTextWrapper(w):
        g.internalError('must be a text wrapper', w)
        return None
    setattr(event, 'widget', w)
    # Part 1: get the url.
    if url is None:
        s = w.getAllText()
        ins = w.getInsertPoint()
        i, j = w.getSelectionRange()
        if i != j: return None # So find doesn't open the url.
        row, col = g.convertPythonIndexToRowCol(s, ins)
        i, j = g.getLine(s, ins)
        line = s[i: j]
        # Find the url on the line.
        for match in g.url_regex.finditer(line):
            # Don't open if we click after the url.
            if match.start() &lt;= col &lt; match.end():
                url = match.group()
                if g.isValidUrl(url):
                    break
        else:
            # Look for the unl:
            for match in g.unl_regex.finditer(line):
                # Don't open if we click after the unl.
                if match.start() &lt;= col &lt; match.end():
                    unl = match.group()
                    g.handleUnl(unl, c)
                    return
    elif not g.isString(url):
        url = url.toString()
        url = g.toUnicode(url)
            # Fix #571
    if url and g.isValidUrl(url):
        # Part 2: handle the url
        p = c.p
        if not g.doHook("@url1", c=c, p=p, url=url):
            g.handleUrl(url, c=c, p=p)
        g.doHook("@url2", c=c, p=p)
        return url
    else:
        # Part 3: call find-def.
        if not w.hasSelection():
            c.editCommands.extendToWord(event, select=True)
        word = w.getSelectedText().strip()
        if word:
            c.findCommands.findDef(event)
        return None
</t>
<t tx="ekr.20170222084048.1">def add_children(self, parent, element):
    '''
    parent is the parent position, element is the parent element.
    Recursively add all the child elements as descendants of parent_p.
    '''
    p = parent.insertAsLastChild()
    attrib_text = element.attrib.get('text','').strip()
    tag = element.tag if g.isString(element.tag) else ''
    text = element.text or ''
    if not tag: text = text.strip()
    p.h = attrib_text or tag or 'Comment'
    p.b = text if text.strip() else ''
    for child in element:
        self.add_children(p, child)
</t>
<t tx="ekr.20170225103140.1">def match_unl(self, s, i):
    if g.match(s.lower(), i, 'unl://'):
        j = len(s)
        self.colorRangeWithTag(s, i, j, 'url')
        return j
    else:
        return 0
</t>
<t tx="ekr.20170226093349.1">def unquoteUrl(url):
    '''
    Replace special characters (especially %20, by their equivalent).

    This function handles 2/3 issues and suppresses pylint complaints.
    '''
    # pylint: disable=no-member
    unquote = urllib.parse.unquote if isPython3 else urllib.unquote
    return unquote(url)
</t>
<t tx="ekr.20170227062001.1">def init_tree_abbrev_helper(self, d, tree_s):

    c = self.c
    hidden_root = c.fileCommands.getPosFromClipboard(tree_s)
    if not hidden_root:
        return g.trace('no pasted node')
    for p in hidden_root.children():
        for s in g.splitLines(p.b):
            if s.strip() and not s.startswith('#'):
                abbrev_name = s.strip()
                # #926: Allow organizer nodes by searching all descendants.
                for child in p.subtree():
                    if child.h.strip() == abbrev_name:
                        abbrev_s = c.fileCommands.putLeoOutline(child)
                        d[abbrev_name] = abbrev_s
                        break
                else:
                    g.trace('no definition for %s' % abbrev_name)
</t>
<t tx="ekr.20170324142416.1">@g.command('show-color-wheel')
def showColorWheel(self, event=None):
    '''Show a Qt color dialog.'''
    c = self.c; p = c.p
    picker = QtWidgets.QColorDialog()
    in_color_setting = p.h.startswith('@color ')
    try:
        text = QtWidgets.QApplication.clipboard().text()
        if in_color_setting:
            text = p.h.split('=', 1)[1].strip()
        color = QtGui.QColor(text)
        picker.setCurrentColor(color)
    except (ValueError, IndexError) as e:
        g.trace('error caught', e)
    if not picker.exec_():
        g.es("No color selected")
    elif in_color_setting:
        udata = c.undoer.beforeChangeNodeContents(p)
        p.h = '%s = %s'%(p.h.split('=', 1)[0].strip(),
                         g.u(picker.selectedColor().name()))
        c.undoer.afterChangeNodeContents(p, 'change-color', udata)
    else:
        text = picker.selectedColor().name()
        g.es("copied to clipboard:", text)
        QtWidgets.QApplication.clipboard().setText(text)
</t>
<t tx="ekr.20170324143944.3">@g.command('show-fonts')
def showFonts(self, event=None):
    '''Open a tab in the log pane showing a font picker.'''
    c = self.c; p = c.p

    picker = QtWidgets.QFontDialog()
    if p.h.startswith('@font'):
        (name, family, weight, slant, size) = leoConfig.parseFont(p.b)
    else:
        name, family, weight, slant, size = None, None, False, False, 12
    try:
        font = QtGui.QFont()
        if family: font.setFamily(family)
        font.setBold(weight)
        font.setItalic(slant)
        font.setPointSize(size)
        picker.setCurrentFont(font)
    except ValueError:
        pass
    if not picker.exec_():
        g.es("No font selected")
    else:
        font = picker.selectedFont()
        udata = c.undoer.beforeChangeNodeContents(p)
        comments = [x for x in g.splitLines(p.b) if x.strip().startswith('#')]

        defs = [
            '\n' if comments else '',
            '%s_family = %s\n'%(name, font.family()),
            '%s_weight = %s\n'%(name, 'bold' if font.bold() else 'normal'),
            '%s_slant = %s\n'%(name, 'italic' if font.italic() else 'roman'),
            '%s_size = %s\n'%(name, font.pointSizeF())
        ]

        p.b = g.u('').join(comments + defs)
        c.undoer.afterChangeNodeContents(p, 'change-font', udata)
</t>
<t tx="ekr.20170331141933.1">def writeAsisNode(self, p):
    '''Write the p's node to an @asis file.'''
    at = self
    # Write the headline only if it starts with '@@'.
    s = p.h
    if g.match(s, 0, "@@"):
        s = s[2:]
        if s:
            at.outputFile.write(s)
    # Write the body.
    s = p.b
    if s:
        s = g.toEncodedString(s, at.encoding, reportErrors=True)
        at.outputStringWithLineEndings(s)
</t>
<t tx="ekr.20170427112302.1">g.cls()
import glob
files = glob.glob(g.os_path_join(g.app.loadDir, '*.py'))
files = [z for z in files if g.os_path_basename(z).startswith('leo')]
if 0:
    g.printList(files)
found = set()
for p in c.all_unique_positions():
    name = p.isAnyAtFileNode()
    if name and name.startswith('leo'):
        path = g.os_path_join(g.app.loadDir, name)
        found.add(path)
if 0:
    print('found')
    g.printList(list(found))
else:
    missing = set(files) - found
    if missing:
        print('not found...')
        g.printList(list(sorted(missing)))
    else:
        print('done')
        </t>
<t tx="ekr.20170427114412.1"></t>
<t tx="ekr.20170428054142.1">if 0:
    # Part of the failed fix for #466.

    def force_rehighlight(self, p):
        '''Force a complete rehighlighting of p.b.'''
        if hasattr(self, 'currentBlock') and self.colorizer.enabled:
            QtGui.QSyntaxHighlighter.rehighlight(self)
</t>
<t tx="ekr.20170428084123.1">'''Recursively import all python files in a directory and clean the result.'''
if 0:
    &lt;&lt; old dir_ settings &gt;&gt;
g.cls()
dir_ = r'C:\leo.repo\leo-editor\leo\core\editpane'
# dir_ = r'C:\leo.repo\leo-editor\leo\external\npyscreen'
c.recursiveImport(
    dir_ = dir_,
    kind = '@file', # '@clean', #'@nosent','@auto','@file',
    recursive = True,
    safe_at_file = False,
    theTypes = ['.py',],
)
</t>
<t tx="ekr.20170428084123.2">dir_ = r'C:\prog\yoton',
dir_ = r'c:\leo.repo\ace\lib'
# Tests: 2017/04/07
dir_ = r'c:\leo.repo\ace\demo\kitchen-sink\dev_util.js' # pass.
dir_ = r'c:\leo.repo\ace\demo\static-highlighter\server.js' # Perfect import fails.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\asciidoc_highlight_rules.js' # undefined sections.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\abap.js' # pass.
dir_ = r'c:\leo.repo\ace\lib\ace\lib\event.js' # pass.
dir_ = r'c:\leo.repo\ace\lib\ace\lib' # pass.
dir_ = r'c:\leo.repo\ace\demo' # All pass except server.js
dir_ = r'c:\test\js-import-test.js' # pass.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\coffee\coffee.js'
# Perfect import fails. Compressed code. Maybe will never pass.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\behaviour' # All pass
dir_ = r'c:\leo.repo\ace\lib\ace\mode' # One failure.
dir_ = r'c:\leo.repo\ace\lib\ace\mode\xquery\xqlint.js' # perfect import fails.
dir_ = r'c:\prog\brython-home.html'</t>
<t tx="ekr.20170428084208.443">#!/usr/bin/python
# This file generates pyflakes warnings for *all* imported symbols.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20170428084208.444">from .globals                   import DEBUG, DISABLE_RESIZE_SYSTEM

from .wgwidget                  import TEST_SETTINGS, ExhaustedTestInput, add_test_input_from_iterable, add_test_input_ch

from .npyssafewrapper           import wrapper, wrapper_basic

from   .npysThemeManagers       import ThemeManager, disableColor, enableColor
from   . import npysThemes      as     Themes
from   .apNPSApplication        import NPSApp
from   .apNPSApplicationManaged import NPSAppManaged
from   .proto_fm_screen_area    import setTheme
from   .fmForm                  import FormBaseNew, Form, TitleForm, TitleFooterForm, SplitForm, FormExpanded, FormBaseNewExpanded, blank_terminal
from   .fmActionForm            import ActionForm, ActionFormExpanded
from   .fmActionFormV2          import ActionFormV2, ActionFormExpandedV2, ActionFormMinimal
from   .fmFormWithMenus         import FormWithMenus, ActionFormWithMenus, \
                                       FormBaseNewWithMenus, SplitFormWithMenus, \
                                       ActionFormV2WithMenus
from   .fmPopup                 import Popup, MessagePopup, ActionPopup, PopupWide, ActionPopupWide
from   .fmFormMutt              import FormMutt, FormMuttWithMenus
from   .fmFileSelector          import FileSelector, selectFile

from .fmFormMuttActive          import ActionControllerSimple, TextCommandBox, \
                                       FormMuttActive, FormMuttActiveWithMenus
from .fmFormMuttActive          import FormMuttActiveTraditional, FormMuttActiveTraditionalWithMenus


from .fmFormMultiPage           import FormMultiPage, FormMultiPageAction,\
                                       FormMultiPageActionWithMenus, FormMultiPageWithMenus

from .npysNPSFilteredData       import NPSFilteredDataBase, NPSFilteredDataList

from .wgbutton                  import MiniButton
from .wgbutton                  import MiniButtonPress
from .wgbutton                  import MiniButton      as Button
from .wgbutton                  import MiniButtonPress as ButtonPress

from .wgtextbox                 import Textfield, FixedText
from .wgtitlefield              import TitleText, TitleFixedText
from .wgpassword                import PasswordEntry, TitlePassword
from .wgannotatetextbox         import AnnotateTextboxBase
from .wgannotatetextbox         import AnnotateTextboxBaseRight

from .wgslider                  import Slider, TitleSlider
from .wgslider                  import SliderNoLabel, TitleSliderNoLabel
from .wgslider                  import SliderPercent, TitleSliderPercent

from .wgwidget                  import DummyWidget, NotEnoughSpaceForWidget
from . import wgwidget as widget

from .wgmultiline               import MultiLine, Pager, TitleMultiLine, TitlePager, MultiLineAction, BufferPager, TitleBufferPager
from .wgmultiselect             import MultiSelect, TitleMultiSelect, MultiSelectFixed, \
                                       TitleMultiSelectFixed, MultiSelectAction
from .wgeditmultiline           import MultiLineEdit
from .wgcombobox                import ComboBox, TitleCombo
from .wgcheckbox                import Checkbox, RoundCheckBox, CheckBoxMultiline, RoundCheckBoxMultiline, CheckBox, CheckboxBare
from .wgFormControlCheckbox     import FormControlCheckbox
from .wgautocomplete            import TitleFilename, Filename, Autocomplete
from .muMenu                    import Menu
from .wgselectone               import SelectOne, TitleSelectOne
from .wgdatecombo               import DateCombo, TitleDateCombo

from .npysTree import TreeData
from .wgmultilinetree           import MLTree, MLTreeAnnotated, MLTreeAction, MLTreeAnnotatedAction
from .wgmultilinetreeselectable import MLTreeMultiSelect, TreeLineSelectable
from .wgmultilinetreeselectable import MLTreeMultiSelectAnnotated, TreeLineSelectableAnnotated


# The following are maintained for compatibility with old code only. ##########################################

from .compatibility_code.oldtreeclasses import MultiLineTree, SelectOneTree
from .compatibility_code.oldtreeclasses import MultiLineTreeNew, MultiLineTreeNewAction, TreeLine, TreeLineAnnotated # Experimental
from .compatibility_code.oldtreeclasses import MultiLineTreeNewAnnotatedAction, MultiLineTreeNewAnnotated # Experimental
from .compatibility_code.npysNPSTree import NPSTreeData

# End compatibility. ###########################################################################################

from .wgfilenamecombo           import FilenameCombo, TitleFilenameCombo
from .wgboxwidget               import BoxBasic, BoxTitle
from .wgmultiline               import MultiLineActionWithShortcuts
from .wgmultilineeditable       import MultiLineEditable, MultiLineEditableTitle, MultiLineEditableBoxed

from .wgmonthbox                import MonthBox
from .wggrid                    import SimpleGrid
from .wggridcoltitles           import GridColTitles

from .muNewMenu                 import NewMenu, MenuItem
from .wgNMenuDisplay            import MenuDisplay, MenuDisplayScreen

from .npyspmfuncs               import CallSubShell

from .utilNotify                 import notify, notify_confirm, notify_wait, notify_ok_cancel, notify_yes_no

# Base classes for overriding:

# Standard Forms:
from . import stdfmemail

# Experimental Only
from .wgtextboxunicode import TextfieldUnicode
from .wgtexttokens     import TextTokens, TitleTextTokens

# Very experimental. Don't use for anything serious
from .apOptions import SimpleOptionForm
from .apOptions import OptionListDisplay, OptionChanger, OptionList, OptionLimitedChoices, OptionListDisplayLine
from .apOptions import OptionFreeText, OptionSingleChoice, OptionMultiChoice, OptionMultiFreeList, \
                       OptionBoolean, OptionFilename, OptionDate, OptionMultiFreeText


# This really is about as experimental as it gets
from .apNPSApplicationEvents import StandardApp
from .eveventhandler import Event


</t>
<t tx="ekr.20170428085201.1">@nosearch</t>
<t tx="ekr.20170514054524.1">def getFontFromParams(self, family, size, slant, weight, defaultSize=12):
    return None

# def setFontFromConfig(self):
    # pass
</t>
<t tx="ekr.20170616102324.1">def execGitCommand(command, directory=None):
    '''Execute the given git command in the given directory.'''
    git_dir = g.os_path_finalize_join(directory, '.git')
    if not g.os_path_exists(git_dir):
        g.trace('not found:', git_dir)
        return []
    if '\n' in command:
        g.trace('removing newline from', command)
        command = command.replace('\n','')
    if directory:
        os.chdir(directory)
    p = subprocess.Popen(
        shlex.split(command),
        stdout=subprocess.PIPE,
        stderr=None, # Shows error traces.
        shell=False,
    )
    out, err = p.communicate()
    lines = [g.toUnicode(z) for z in g.splitLines(out or [])]
    return lines
</t>
<t tx="ekr.20170721073056.1">def do_Constant(self, node): # Python 3.6+ only.
    assert g.isPython3
    return str(node.s) # A guess.
</t>
<t tx="ekr.20170721073315.1">def do_Constant(self, node): # Python 3.6+ only.
    assert g.isPython3
</t>
<t tx="ekr.20170721073431.1">def do_Constant(self, node): # Python 3.6+ only.
    assert g.isPython3
    return str(node.s) # A guess.
</t>
<t tx="ekr.20170721075130.1"># FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node): # Python 3.6+ only.
    assert g.isPython3
    return '%s%s%s' % (
        self.visit(node.value),
        self.visit(node.conversion) if node.conversion else '',
        self.visit(node.format_spec) if node.format_spec else '')
</t>
<t tx="ekr.20170721075714.1"># FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node): # Python 3.6+ only.
    assert g.isPython3
    self.visit(node.value)
    if node.conversion:
        self.visit(node.conversion)
    if node.format_spec:
        self.visit(node.format_spec)
</t>
<t tx="ekr.20170721075845.1"># FormattedValue(expr value, int? conversion, expr? format_spec)

def do_FormattedValue(self, node): # Python 3.6+ only.
    assert g.isPython3
    self.div('statement')
    self.visit(node.value)
    if node.conversion:
        self.visit(node.conversion)
    if node.format_spec:
        self.visit(node.format_spec)
    self.end_div('statement')
</t>
<t tx="ekr.20170721080935.1"># JoinedStr(expr* values)

def do_JoinedStr(self, node):
    assert g.isPython3
    for value in node.values or []:
        self.visit(value)
</t>
<t tx="ekr.20170721080959.1"># JoinedStr(expr* values)

def do_JoinedStr(self, node):
    assert g.isPython3
    for value in node.values or []:
        self.visit(value)
</t>
<t tx="ekr.20170806094317.19">def dumpCompareNodes(self, fileName1, fileName2, inserted, deleted, changed):
    for d, kind in (
        (inserted, 'inserted (only in %s)' % (fileName1)),
        (deleted, 'deleted  (only in %s)' % (fileName2)),
        (changed, 'changed'),
    ):
        g.pr('\n', kind)
        for key in d:
            p = d.get(key)
            if g.isPython3:
                g.pr('%-32s %s' % (key, p.h))
            else:
                g.pr('%-32s %s' % (key, g.toEncodedString(p.h, 'ascii')))
</t>
<t tx="ekr.20170806094318.15">@cmd('file-save')
def saveFile(self, event):
    '''Prompt for the name of a file and put the body text of the selected node into it..'''
    c = self.c
    w = self.editWidget(event)
    if not w:
        return
    fileName = g.app.gui.runSaveFileDialog(c,
        initialfile=None,
        title='save-file',
        filetypes=[("Text", "*.txt"), ("All files", "*")],
        defaultextension=".txt")
    if fileName:
        try:
            f = open(fileName, 'w')
            s = w.getAllText()
            if not g.isPython3: # 2010/08/27
                s = g.toEncodedString(s, encoding='utf-8', reportErrors=True)
            f.write(s)
            f.close()
        except IOError:
            g.es('can not create', fileName)
</t>
<t tx="ekr.20170806094320.12">def git_diff(self, directory=None, rev1='HEAD', rev2=''):
    '''The main line of the git diff command.'''
    if not self.set_directory(directory):
        return
    #
    # Diff the given revs.
    ok = self.diff_revs(rev1, rev2)
    if ok: return
    #
    # Go back at most 5 revs...
    n1, n2 = 1, 0
    while n1 &lt;= 5:
        ok = self.diff_revs(
            rev1 = 'HEAD@{%s}' % (n1),
            rev2 = 'HEAD@{%s}' % (n2))
        if ok: return
        n1, n2 = n1+1, n2+1
    if not ok:
        g.es_print('no changed readable files from HEAD@{1}..HEAD@(5)')
</t>
<t tx="ekr.20170806094320.13">class GitDiffController:
    '''A class to do git diffs.'''
    @others
</t>
<t tx="ekr.20170806094320.15">def get_file_from_rev(self, rev, fn):
    '''Get the file from the given rev, or the working directory if None.'''
    if rev:
        # Get the file using git.
        command = 'git show %s:%s' % (rev, fn)
        lines = g.execGitCommand(command, self.repo_dir)
        s = ''.join(lines)
    else:
        # Get the file from the working directory.
        path = g.os_path_finalize_join(self.repo_dir, fn)
        if g.os_path_exists(path):
            try:
                with open(path, 'rb') as f: # Was 'r'
                    s = f.read()
            except Exception:
                g.es_print('Can not read', path)
                g.es_exception()
                s = ''
        else:
            g.trace('not found:', path)
            s = ''
    return g.toUnicode(s).replace('\r','')
</t>
<t tx="ekr.20170806094320.18">def create_root(self, rev1, rev2):
    '''Create the top-level organizer node describing the git diff.'''
    c = self.c
    r1, r2 = rev1 or '', rev2 or ''
    p = c.lastTopLevel().insertAfter()
    p.h = 'git diff %s %s' % (r1, r2)
    p.b = '@ignore\n@nosearch\n'
    if r1 and r2:
        p.b += '%s=%s\n%s=%s' % (
            r1, self.get_revno(r1),
            r2, self.get_revno(r2),
        )
    else:
        p.b += '%s=%s' % (r1, self.get_revno(r1))
    return p
</t>
<t tx="ekr.20170806094320.4">def __init__ (self, c, repo_dir=None):
    '''Ctor for the GitDiffController class.'''
    self.c = c
    self.file_node = None
    self.old_dir = g.os_path_abspath('.')
    self.repo_dir = repo_dir
    self.root = None
</t>
<t tx="ekr.20170806094320.6">def diff_file(self, fn, directory=None, rev1='HEAD', rev2=''):
    '''
    Create an outline describing the git diffs for fn.
    '''
    if not self.set_directory(directory):
        return
    c = self.c
    s1 = self.get_file_from_rev(rev1, fn)
    s2 = self.get_file_from_rev(rev2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(
        lines1,
        lines2,
        rev1 or 'uncommitted',
        rev2 or 'uncommitted',
    ))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    if c.looksLikeDerivedFile(fn):
        c1 = self.make_at_file_outline(fn, s1, rev1)
        c2 = self.make_at_file_outline(fn, s2, rev2)
    else:
        root = self.find_file(fn)
        if root:
            c1 = self.make_at_clean_outline(fn, root, s1, rev1)
            c2 = self.make_at_clean_outline(fn, root, s2, rev2)
        else:
            # This warning is silly.
            # g.es_print('No outline for', fn)
            c1 = c2 = None
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn, rev1, rev2)
        self.file_node.b = '%s\n@language %s\n' % (
            self.file_node.b.rstrip(), c2.target_language)
</t>
<t tx="ekr.20170806094320.7">def find_file(self, fn):
    '''Return the @&lt;file&gt; node matching fn.'''
    c = self.c
    fn = g.os_path_basename(fn)
    for p in c.all_unique_positions():
        if p.isAnyAtFileNode():
            fn2 = p.anyAtFileNodeName()
            if fn2.endswith(fn):
                return p
    return None
</t>
<t tx="ekr.20170806094320.9">def get_files(self, rev1, rev2):
    '''Return a list of changed files.'''

    def readable(fn):
        for suffix in ('commit_timestamp.json', '.db', '.leo', '.zip', ):
            if fn.strip().endswith(suffix):
                return False
        return True

    command = 'git diff --name-only %s %s' % (rev1 or '', rev2 or '')
    files = [
        z.strip() for z in g.execGitCommand(command, self.repo_dir)
            if readable(z)
    ]
    return files
</t>
<t tx="ekr.20170806094321.1">def create_file_node(self, diff_list, fn):
    '''Create an organizer node for the file.'''
    p = self.root.insertAsLastChild()
    p.h = fn.strip()
    p.b = ''.join(diff_list)
    return p
</t>
<t tx="ekr.20170806094321.3">def find_git_working_directory(self, directory):
    '''Return the git working directory, starting at directory.'''
    assert directory
    while directory:
        if g.os_path_exists(g.os_path_finalize_join(directory, '.git')):
            return directory
        path2 = g.os_path_finalize_join(directory, '..')
        if path2 == directory:
            break
        directory = path2
    return None
</t>
<t tx="ekr.20170806094321.5">def finish(self):
    '''Finish execution of this command.'''
    c = self.c
    os.chdir(self.old_dir)
    c.contractAllHeadlines(redrawFlag=False)
    self.root.expand()
    c.selectPosition(self.root)
    c.redraw()
    c.treeWantsFocusNow()
</t>
<t tx="ekr.20170806094321.7">def make_at_file_outline(self, fn, s, rev):
    '''Create a hidden temp outline from lines.'''
    # A specialized version of atFileCommands.read.
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    at = hidden_c.atFileCommands
    hidden_c.frame.createFirstTreeNode()
    root = hidden_c.rootPosition()
    root.h = fn + ':' + rev if rev else fn
    at.initReadIvars(root, fn, importFileName=None, atShadow=None)
    if at.errors &gt; 0:
        g.trace('***** errors')
        return None
    at.fast_read_into_root(
        c = hidden_c,
        contents = s,
        gnx2vnode = {},
        path = fn,
        root = root,
    )
    return hidden_c
   
</t>
<t tx="ekr.20170806125535.1">def make_diff_outlines(self, c1, c2, fn, rev1='', rev2=''):
    '''Create an outline-oriented diff from the *hidden* outlines c1 and c2.'''
    added, deleted, changed = self.compute_dicts(c1, c2)
    table = (
        (added, 'Added'),
        (deleted, 'Deleted'),
        (changed, 'Changed'))
    for d, kind in table:
        self.create_compare_node(c1, c2, d, kind, rev1, rev2)
</t>
<t tx="ekr.20170806191707.1">def compute_dicts(self, c1, c2):
    '''Compute inserted, deleted, changed dictionaries.'''
    # Special case the root: only compare the body text.
    root1, root2 = c1.rootPosition().v, c2.rootPosition().v
    root1.h = root2.h
    if 0:
        g.trace('c1...')
        for p in c1.all_positions():
            print('%4s %s' % (len(p.b), p.h))
        g.trace('c2...')
        for p in c2.all_positions():
            print('%4s %s' % (len(p.b), p.h))
    d1 = {v.fileIndex: v for v in c1.all_unique_nodes()} 
    d2 = {v.fileIndex: v for v in c2.all_unique_nodes()}
    added   = {key: d2.get(key) for key in d2 if not d1.get(key)}
    deleted = {key: d1.get(key) for key in d1 if not d2.get(key)}
    # Remove the root from the added and deleted dicts.
    if root2.fileIndex in added:
        del added[root2.fileIndex]
    if root1.fileIndex in deleted:
        del deleted[root1.fileIndex]
    changed = {}
    for key in d1:
        if key in d2:
            v1 = d1.get(key)
            v2 = d2.get(key)
            assert v1 and v2
            assert v1.context != v2.context
            if v1.h != v2.h or v1.b != v2.b:
                changed[key] = (v1, v2)
    return added, deleted, changed
</t>
<t tx="ekr.20170806191942.2">def create_compare_node(self, c1, c2, d, kind, rev1, rev2):
    '''Create nodes describing the changes.'''
    if not d:
        return
    parent = self.file_node.insertAsLastChild()
    parent.setHeadString(kind)
    for key in d:
        if kind.lower() == 'changed':
            v1, v2 = d.get(key)
            # Organizer node: contains diff
            organizer = parent.insertAsLastChild()
            organizer.h = v2.h
            body = list(difflib.unified_diff(
                g.splitLines(v1.b),
                g.splitLines(v2.b),
                rev1 or 'uncommitted',
                rev2 or 'uncommitted',
            ))
            if ''.join(body).strip():
                body.insert(0, '@ignore\n@nosearch\n@language patch\n')
                body.append('@language %s\n' % (c2.target_language))
            else:
                body = ['Only headline has changed']
            organizer.b = ''.join(body)
            # Node 2: Old node
            p2 = organizer.insertAsLastChild()
            p2.h = 'Old:' + v1.h
            p2.b = v1.b
            # Node 3: New node
            assert v1.fileIndex == v2.fileIndex
            p_in_c = self.find_gnx(self.c, v1.fileIndex)
            if p_in_c: # Make a clone, if possible.
                p3 = p_in_c.clone()
                p3.moveToLastChildOf(organizer)
            else:
                p3 = organizer.insertAsLastChild()
                p3.h = 'New:' + v2.h
                p3.b = v2.b
        else:
            v = d.get(key)
            p = parent.insertAsLastChild()
            p.h = v.h
            p.b = v.b
</t>
<t tx="ekr.20170811173924.1">@language python
import os
import subprocess
import sys
import time
win = sys.platform.startswith('win')
old_dir = g.os_path_abspath('.')
if win:
    new_dir = r'C:\leo.repo\leo-editor'
    path = r'C:\Users\edreamleo\Backup'
else:
    new_dir = '/home/edward/leo.repo/leo-editor'
    path = '/home/edward/Backup'
assert g.os_path_exists(new_dir), repr(new_dir)
assert g.os_path_exists(path), repr(path)
stamp = time.strftime("%Y%m%d-%H%M%S")
fn = g.os_path_finalize_join(path, 'leo-bundle-all-%s' % (stamp))
bundle_command = 'git bundle create %s --all' % fn
print(bundle_command)
os.chdir(new_dir)
# os.system(bundle_command)
proc = subprocess.Popen(bundle_command, shell=True)
proc.wait()
os.chdir(old_dir)
print('done! wrote %s' % fn)
</t>
<t tx="ekr.20170819035801.90">@cmd('git-diff')
@cmd('gd')
def gitDiff(self, event):

    GitDiffController(c=self.c).git_diff(rev1='HEAD')
</t>
<t tx="ekr.20170819132219.1">def find_gnx(self, c, gnx):
    '''Return a position in c having the given gnx.'''
    for p in c.all_unique_positions():
        if p.v.fileIndex == gnx:
            return p
    return None
</t>
<t tx="ekr.20170820082125.1">def diff_revs(self, rev1, rev2):
    '''Diff all files given by rev1 and rev2.'''
    files = self.get_files(rev1, rev2)
    if files:
        self.root = self.create_root(rev1, rev2)
        for fn in files:
            self.diff_file(fn=fn, rev1=rev1, rev2=rev2)
        self.finish()
    return bool(files)
    
</t>
<t tx="ekr.20170820084258.1">def make_at_clean_outline(self, fn, root, s, rev):
    '''
    Create a hidden temp outline from lines without sentinels.
    root is the @&lt;file&gt; node for fn.
    s is the contents of the (public) file, without sentinels.
    '''
    # A specialized version of at.readOneAtCleanNode.
    hidden_c = leoCommands.Commands(fn, gui=g.app.nullGui)
    at = hidden_c.atFileCommands
    x = hidden_c.shadowController
    hidden_c.frame.createFirstTreeNode()
    hidden_root = hidden_c.rootPosition()
    # copy root to hidden root, including gnxs.
    root.copyTreeFromSelfTo(hidden_root, copyGnxs=True)
    hidden_root.h = fn + ':' + rev if rev else fn
    # Set at.encoding first.
    at.initReadIvars(hidden_root, fn)
        # Must be called before at.scanAllDirectives.
    at.scanAllDirectives(hidden_root)
        # Sets at.startSentinelComment/endSentinelComment.
    new_public_lines = g.splitLines(s)
    old_private_lines = at.write_at_clean_sentinels(hidden_root)
    marker = x.markerFromFileLines(old_private_lines, fn)
    old_public_lines, junk = x.separate_sentinels(old_private_lines, marker)
    assert old_public_lines
    new_private_lines = x.propagate_changed_lines(
        new_public_lines, old_private_lines, marker, p=hidden_root)
    at.fast_read_into_root(
        c = hidden_c,
        contents = ''.join(new_private_lines),
        gnx2vnode = {},
        path = fn,
        root = hidden_root,
    )
    return hidden_c
</t>
<t tx="ekr.20170821052348.1">def get_revno(self, revspec, abbreviated=True):
    '''Return the abbreviated hash the given revision spec.'''
    if revspec:
        # Return only the abbreviated hash for the revspec.
        command = 'git show --format=%%%s --no-patch %s' % (
            'h' if abbreviated else 'H',
            revspec)
        lines = g.execGitCommand(command, self.repo_dir)
        return ''.join(lines).strip()
    else:
        return 'uncommitted'
</t>
<t tx="ekr.20171031111403.1"></t>
<t tx="ekr.20171113152939.1">def reloadSettings(self):
    '''AtFile.reloadSettings'''
    c = self.c
    self.checkPythonCodeOnWrite = \
        c.config.getBool('check-python-code-on-write', default=True)
    self.runPyFlakesOnWrite = \
        c.config.getBool('run-pyflakes-on-write', default=False)
    self.underindentEscapeString = \
        c.config.getString('underindent-escape-string') or '\\-'
</t>
<t tx="ekr.20171114041307.1">def reloadSettings(self):
    c = self.c
    self.showInvisibles = c.config.getBool("show-invisibles-by-default")
    self.underline_undefined = c.config.getBool("underline-undefined-section-names")
    self.use_hyperlinks = c.config.getBool("use-hyperlinks")
    # There were in setFontFromConfig.
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.color_tags_list = []
</t>
<t tx="ekr.20171122055719.1">def declutter_style(self, arg, c, cmd, item, new_icons):
    '''Handle style options.'''
    arg = c.styleSheetManager.expand_css_constants(arg).split()[0]
    if cmd == 'ICON':
        new_icons.append(arg)
    elif cmd == 'BG':
        item.setBackground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FG':
        item.setForeground(0, QtGui.QBrush(QtGui.QColor(arg)))
    elif cmd == 'FONT':
        item.setFont(0, QtGui.QFont(arg))
    elif cmd == 'ITALIC':
        font = item.font(0)
        font.setItalic(bool(int(arg)))
        item.setFont(0, font)
    elif cmd == 'WEIGHT':
        arg = getattr(QtGui.QFont, arg, 75)
        font = item.font(0)
        font.setWeight(arg)
        item.setFont(0, font)
    elif cmd == 'PX':
        font = item.font(0)
        font.setPixelSize(int(arg))
        item.setFont(0, font)
    elif cmd == 'PT':
        font = item.font(0)
        font.setPointSize(int(arg))
        item.setFont(0, font)
</t>
<t tx="ekr.20171122064635.1">def declutter_replace(self, arg, cmd, item, m, pattern, text):
    '''
    Execute cmd and return True if cmd is any replace command.
    '''
    if cmd == 'REPLACE':
        text = pattern.sub(arg, text)
        item.setText(0, text)
        return True
    elif cmd == 'REPLACE-HEAD':
        s = text[:m.start()]
        item.setText(0, s.rstrip())
        return True
    elif cmd == 'REPLACE-TAIL':
        s = text[m.end():]
        item.setText(0, s.lstrip())
        return True
    elif cmd == 'REPLACE-REST':
        s = text[:m.start] + text[m.end():]
        item.setText(0, s.strip())
        return True
    else:
        return False
    
</t>
<t tx="ekr.20171123135625.5">def executeScriptHelper(self, args, define_g, define_name, namespace, script):
    c = self
    if c.p:
        p = c.p.copy() # *Always* use c.p and pass c.p to script.
        c.setCurrentDirectoryFromContext(p)
    else:
        p = None
    # Do NOT define a subfunction here!
    #
    # On some, python 2.x versions it causes exec to cause a syntax error
    # Workarounds that avoid the syntax error hurt performance.
    # See http://stackoverflow.com/questions/4484872.

        # def g_input_wrapper(message, c=c):
            # return g.input_(message, c=c)

    d = {'c': c, 'g': g, 'input': g.input_, 'p': p} if define_g else {}
    if define_name: d['__name__'] = define_name
    d['script_args'] = args or []
    d['script_gnx'] = g.app.scriptDict.get('script_gnx')
    if namespace: d.update(namespace)
    # A kludge: reset c.inCommand here to handle the case where we *never* return.
    # (This can happen when there are multiple event loops.)
    # This does not prevent zombie windows if the script puts up a dialog...
    try:
        c.inCommand = False
        g.inScript = g.app.inScript = True
            # g.inScript is a synonym for g.app.inScript.
        if c.write_script_file:
            scriptFile = self.writeScriptFile(script)
            # pylint: disable=undefined-variable, no-member
            if g.isPython3:
                exec(compile(script, scriptFile, 'exec'), d)
            else:
                builtins.execfile(scriptFile, d)
        else:
            exec(script, d)
    finally:
        g.inScript = g.app.inScript = False
</t>
<t tx="ekr.20171208134737.1"># Call(expr func, expr* args, keyword* keywords, expr? starargs, expr? kwargs)

def resolve_call(self, node):
    '''Resolve the head of the call's chain to a Type.'''
    assert self.pass_n == 2
    self.stats.resolve_call += 1
    chain = self.get_chain(node.func)
    if chain:
        func = chain.pop()
        if isinstance(func, ast.Name):
            func = func.id
        assert g.isString(func), repr(func)
    if chain:
        assert isinstance(chain[0], ast.Name), repr(chain[0])
        chain[0] = chain[0].id
        # args = ','.join([self.format(z) for z in node.args])
        self.recursion_count = 0
        if self.class_name:
            context = self.Type('instance', self.class_name)
        else:
            context = self.Type('module', self.file_name)
        result = self.resolve_chain(node, chain, context)
    else:
        result = self.Type('unknown', 'empty chain')
    assert isinstance(result, self.Type), repr(result)
    return result
</t>
<t tx="ekr.20171208142646.1">def resolve(self, node, name, context, trace=False):
    '''Resolve name in the given context to a Type.'''
    self.stats.resolve += 1
    assert g.isString(name), (repr(name), g.callers())
    if context:
        if context.kind in ('error', 'unknown'):
            result = context
        elif name == 'self':
            if context.name:
                result = self.Type('instance', context.name)
            else:
                g.trace('===== NO OBJECT NAME')
                result = self.Type('error', 'no object name')
        elif context.kind in ('class', 'instance'):
            result = self.resolve_ivar(node, name, context)
        else:
            result = self.Type('error', 'unknown kind: %s' % context.kind)
    else:
        result = self.Type('error', 'unbound name: %s' % name)
    return result
</t>
<t tx="ekr.20171208173323.1">def resolve_ivar(self, node, ivar, context):
    '''Resolve context.ivar to a Type.'''
    assert self.pass_n == 2, repr(self.pass_n)
    self.stats.resolve_ivar += 1
    class_name = 'Commands' if context.name == 'c' else context.name
    self.recursion_count += 1
    if self.recursion_count &gt; 20:
        self.report_unbounded_recursion(node, class_name, ivar, context)
        return self.Type('error', 'recursion')
    the_class = self.classes.get(class_name)
    if not the_class:
        return self.Type('error', 'no class %s' % ivar)
    ivars = the_class.get('ivars')
    methods = the_class.get('methods')
    if ivar == 'self':
        return self.Type('instance', class_name)
    elif methods.get(ivar):
        return self.Type('func', ivar)
    elif ivars.get(ivar):
        val = ivars.get(ivar)
        if isinstance(val, self.Type):
            return val
        # Check for pre-defined special names.
        for special_name, special_obj in self.special_names_dict.items():
            tail = val[len(special_name):]
            if val == special_name:
                return special_obj
            elif val.startswith(special_name) and tail.startswith('.'):
                # Resovle the rest of the tail in the found context.
                return self.resolve_chain(node, tail[1:], special_obj)
        # Avoid recursion .
        head = val.split('.')
        if ivar in (val, head[0]):
            return self.Type('unknown', ivar)
        for name2 in head:
            old_context = context
            context = self.resolve(node, name2, context)
            if 0: g.trace('recursive %s: %r --&gt; %r' % (name2, old_context, context))
        if 0: g.trace('END RECURSIVE: %r', context)
        return context
    elif ivar in self.special_names_dict:
        val = self.special_names_dict.get(ivar)
        return val
    else:
        # Remember the unknown.
        self.remember_unknown_ivar(ivar)
        return self.Type('error', 'no member %s' % ivar)
</t>
<t tx="ekr.20171209034244.1">def resolve_chain(self, node, chain, context, trace=False):
    '''Resolve the chain to a Type.'''
    self.stats.resolve_chain += 1
    name = '&lt;no name&gt;'
    for obj in chain:
        name = obj.id if isinstance(obj, ast.Name) else obj
        assert g.isString(name), (repr(name), g.callers())
        context = self.resolve(node, name, context, trace=trace)
    assert isinstance(context, self.Type), repr(context)
    return context
</t>
<t tx="ekr.20171209065852.1">def check_signature(self, node, func, args, signature):
    
    self.stats.check_signature += 1
    if signature[0] == 'self':
        signature = signature[1:]
    result = 'ok'
    for i, arg in enumerate(args):
        if i &lt; len(signature):
            result = self.check_arg(node, func, args, arg, signature[i])
            if result is 'fail':
                self.fail(node, '\n%s(%s) incompatible with %s(%s)' % (
                    func, ','.join(args),
                    func, ','.join(signature),
                ))
                break
    if result == 'ok':
        self.stats.sig_ok += 1
    elif result == 'fail':
        self.stats.sig_fail += 1
    else:
        assert result == 'unknown'
        self.stats.sig_unknown += 1
</t>
<t tx="ekr.20171212034531.1">def check_arg(self, node, func, args, call_arg, sig_arg):
    '''
    Check call_arg and sig_arg with arg (a list).
    
    To do: check keyword args.
    '''
    return self.check_arg_helper(node, func, call_arg, sig_arg)

</t>
<t tx="ekr.20171212035137.1">def check_arg_helper(self, node, func, call_arg, sig_arg):

    special_names_dict = self.special_names_dict
    if call_arg == sig_arg or sig_arg in (None, 'None'):
        # Match anything against a default value of None.
        return 'ok'
    # Resolve the call_arg if possible.
    chain = call_arg.split('.')
    if len(chain) &gt; 1:
        head, tail = chain[0], chain[1:]
        if head in special_names_dict:
            context = special_names_dict.get(head)
            context = self.resolve_chain(node, tail, context)
            if context.kind == 'error':
                # Caller will report the error.
                return 'unknown'
            if sig_arg in special_names_dict:
                sig_class = special_names_dict.get(sig_arg)
                return self.compare_classes(
                    node, call_arg, sig_arg, context, sig_class)
    if sig_arg in special_names_dict and call_arg in special_names_dict:
        sig_class = special_names_dict.get(sig_arg)
        call_class = special_names_dict.get(call_arg)
        return self.compare_classes(
            node, call_arg, sig_arg, call_class, sig_class)
    return 'unknown'
</t>
<t tx="ekr.20171212044621.1">def compare_classes(self, node, arg1, arg2, class1, class2):

    if class1 == class2:
        self.stats.sig_infer_ok += 1
        return 'ok'
    else:
        # The caller reports the failure.
        # self.error(node, 'FAIL', arg1, arg2, class1, class2)
        self.stats.sig_infer_fail += 1
        return 'fail'
</t>
<t tx="ekr.20171215074959.2">def before_Assign(self, node):
    
    s = self.format(node)
    if self.test_kind is 'test': print(s)
    if self.pass_n == 1:
        return
    self.stats.assignments += 1
    for target in node.targets:
        chain = self.get_chain(target)
        if len(chain) == 2:
            var1, var2 = chain
            assert isinstance(var1, ast.Name), repr(var1)
            assert g.isString(var2), repr(var2)
            name = var1.id
            if name == 'self':
                self.do_assn_to_self(node, name, var2)
            elif name in self.special_names_dict:
                self.do_assn_to_special(node, name, var2)
</t>
<t tx="ekr.20171215074959.3">def do_assn_to_special(self, node, var1, var2):

    assert self.pass_n == 2
    assert var1 in self.special_names_dict, (repr(var1))
    class_name = self.class_name
    t = self.special_names_dict.get(var1)
    if not t:
        if 0: self.note(node, 'not special', var1, self.format(node).strip())
        return
    # Do not set members within the class itself.
    if t.kind == 'instance' and t.name == class_name:
        if 0: self.note(node, 'SKIP', var1, class_name)
        return
    # Resolve val, if possible.
    context = self.Type(
        'instance' if class_name else 'module',
        class_name or self.file_name,
    )
    self.recursion_count = 0
    value_s = self.format(node.value)
    resolved_type = self.resolve(node, value_s, context, trace=False)
    assert isinstance(resolved_type, self.Type), repr(resolved_type)
    if 0: self.note(node, 'context %s : %s ==&gt; %s' % (context, value_s, resolved_type))
    # Update var1's dict, not class_name's dict.
    d = self.classes.get(t.name)
    ivars = d.get('ivars')
    # tag:setter ivar1.ivar2 = Type
    ivars[var2] = resolved_type
    d['ivars'] = ivars
</t>
<t tx="ekr.20171215074959.4">def do_assn_to_self(self, node, var1, var2):

    assert self.pass_n == 2
    assert var1 == 'self'
    class_name = self.class_name
    if not class_name:
        self.note(node, 'SKIP: no class name', self.format(node))
        return
    if class_name in self.special_class_names:
        # self.note(node, 'SKIP: not special', self.format(node))
        return
    d = self.classes.get(class_name)
    assert d is not None, class_name
    ivars = d.get('ivars')
    ivars[var2] = self.format(node.value)
    d['ivars'] = ivars
</t>
<t tx="ekr.20171216063026.1">def error(self, node, *args, **kwargs):
    
    self.errors += 1
    print('')
    print('Error: %s' % self.log_line(node, *args, **kwargs))
    print('')
    
def fail(self, node, *args, **kwargs):
    self.stats.inference_fails += 1
    print('')
    print('Inference failure: %s' % self.log_line(node, *args, **kwargs))
    print('')
    
def log_line(self, node=None, *args, **kwargs):
    # pylint: disable=keyword-arg-before-vararg
        # putting *args first is invalid in Python 2.x.
    return 'line: %s file: %s: %s' % (
        getattr(node, 'lineno', '??'),
        self.file_name or '&lt;string&gt;',
        ' '.join([z if g.isString(z) else repr(z) for z in args]),
    )
    
def note(self, node, *args, **kwargs):

    print('')
    print('Note: %s' % self.log_line(node, *args, **kwargs))
    print('')
</t>
<t tx="ekr.20171216110107.1">def get_chain(self,node):
    '''Scan node for a chain of names.'''
    chain, node1 = [], node
    while not isinstance(node, ast.Name):
        if isinstance(node, ast.Attribute):
            assert g.isString(node.attr), repr(node.attr)
            chain.append(node.attr)
            node = node.value
        else:
            name = node.__class__.__name__
            if name not in (
                'BoolOp', # c.config.getString('stylesheet') or ''.strip
                'Call', # c1.rootPosition().h = whatever
                'Dict', # {}.whatever.
                'Subscript', # d[x] = whatever
                'Str', # ''.join(), etc
                'Tuple', # (hPos,vPos) = self.getScroll()
            ):
                self.note(node1, '(get_chain) target %s:\n%s' % (
                    name, self.format(node1)))
            return []
    if isinstance(node, ast.Name):
        chain.append(node)
        return list(reversed(chain))
    else:
        return []
</t>
<t tx="ekr.20171217102055.1">def report_unbounded_recursion(self, node, class_name, ivar, context):
    
    the_class = self.classes.get(class_name)
    self.error(node, 'UNBOUNDED RECURSION: %r %r\nCallers: %s' % (
        ivar, context, g.callers()))
    if 0:
        g.trace('CLASS DICT: Commands')
        g.printDict(self.classes.get('Commands'))
    if 0:
        g.trace('CLASS DICT', class_name)
        g.printDict(the_class)
</t>
<t tx="ekr.20171217102701.1">def remember_unknown_ivar(self, ivar):

    d = self.unknowns
    aList = d.get(ivar, [])
    data = (self.line_number, self.file_name)
    aList.append(data)
    # tag:setter (data describing unknown ivar)
    d[ivar] = aList
    # self.error(node, 'No member:', ivar)
    return self.Type('error', 'no member %s' % ivar)
</t>
<t tx="ekr.20180225010644.1"></t>
<t tx="ekr.20180225010707.1"></t>
<t tx="ekr.20180225010743.1">@nosearch</t>
<t tx="ekr.20180225010850.1"></t>
<t tx="ekr.20180225010913.1"></t>
<t tx="ekr.20180316093159.1">def do_pass(self, constants, deltas, settingsDict, sheet, to_do):
    
    to_do.sort(key=len, reverse=True)
    for const in to_do:
        value = None
        if const in constants:
            # This constant is about to be removed.
            value = constants[const]
            if const[1:] not in deltas and not self.css_warning_given:
                self.css_warning_given = True
                g.es_print("'%s' from style-sheet comment definition, " % const)
                g.es_print("please use regular @string / @color type @settings.")
        else:
            key = g.app.config.canonicalizeSettingName(const[1:])
                # lowercase, without '@','-','_', etc.
            value = settingsDict.get(key)
            if value is not None:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                    # value = '%s /* %s */' % (g.u(value.val), key)
                value = g.u(value.val)
            elif key in self.color_db:
                # New in Leo 5.5: Do NOT add comments here.
                # They RUIN style sheets if they appear in a nested comment!
                value = self.color_db.get(key)
                    # value = '%s /* %s */' % (value, key)
        if value:
            # Partial fix for #780.
            try:
                sheet = re.sub(
                    const + "(?![-A-Za-z0-9_])",
                        # don't replace shorter constants occuring in larger
                    value,
                    sheet,
                )
            except Exception:
                g.es_print('Exception handling style sheet')
                g.es_print(sheet)
                g.es_exception()
        else:
            pass
            # tricky, might be an undefined identifier, but it might
            # also be a @foo in a /* comment */, where it's harmless.
            # So rely on whoever calls .setStyleSheet() to do the right thing.
    return sheet
</t>
<t tx="ekr.20180324065741.1">'''Copy the selected text to the next node.'''
w = c.frame.body.wrapper
s = w.getSelectedText()
if s.strip():
    w.deleteTextSelection()
    c.p.b = w.getAllText()
    w.setInsertPoint(0)
    p = c.insertHeadline()
    c.selectPosition(p)
    p.b = s
    c.editHeadline()
else:
    g.es_print('no text selected')
</t>
<t tx="ekr.20180506064102.10">def diff_two_branches(self, branch1, branch2, fn, directory=None):
    '''Create an outline describing the git diffs for fn.'''
    c = self.c
    if not self.set_directory(directory):
        return
    self.root = p = c.lastTopLevel().insertAfter()
    p.h = 'git-diff-branches %s %s' % (branch1, branch2)
    s1 = self.get_file_from_branch(branch1, fn)
    s2 = self.get_file_from_branch(branch2, fn)
    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diff_list = list(difflib.unified_diff(
        lines1,
        lines2,
        branch1 ,
        branch2,
    ))
    diff_list.insert(0, '@ignore\n@nosearch\n@language patch\n')
    self.file_node = self.create_file_node(diff_list, fn)
    if c.looksLikeDerivedFile(fn):
        c1 = self.make_at_file_outline(fn, s1, branch1)
        c2 = self.make_at_file_outline(fn, s2, branch2)
    else:
        root = self.find_file(fn)
        if root:
            c1 = self.make_at_clean_outline(fn, root, s1, branch1)
            c2 = self.make_at_clean_outline(fn, root, s2, branch2)
        else:
            c1 = c2 = None
    if c1 and c2:
        self.make_diff_outlines(c1, c2, fn)
        self.file_node.b = '%s\n@language %s\n' % (
            self.file_node.b.rstrip(), c2.target_language)
    self.finish()
</t>
<t tx="ekr.20180506064102.11">def get_file_from_branch(self, branch, fn):
    '''Get the file from the hed of the given branch.'''
    # Get the file using git.
    command = 'git show %s:%s' % (branch, fn)
    directory = self.repo_dir
    lines = g.execGitCommand(command, directory)
    s = ''.join(lines)
    return g.toUnicode(s).replace('\r','')
</t>
<t tx="ekr.20180507212821.1">def diff_two_revs(self, directory=None, rev1='HEAD', rev2=''):
    '''
    Create an outline describing the git diffs for all files changed
    between rev1 and rev2.
    '''
    c = self.c
    if not self.set_directory(directory):
        return
    # Get list of changed files.
    files = self.get_files(rev1, rev2)
    g.es_print('diffing %s files. This may take awhile' % len(files))
    # Create the root node.
    self.root = c.lastTopLevel().insertAfter()
    self.root.h = 'git diff revs: %s %s' % (rev1, rev2)
    self.root.b = '@ignore\n@nosearch\n'
    # Create diffs of all files.
    for fn in files:
        self.diff_file(fn=fn, rev1=rev1, rev2=rev2)
    self.finish()
</t>
<t tx="ekr.20180510095544.1"></t>
<t tx="ekr.20180510095801.1"></t>
<t tx="ekr.20180510095807.1">def set_directory(self, directory):
    '''
    Handle directory inits.
    Return True if the .git directory has been found.
    '''
    if not directory:
        if self.repo_dir:
            # Use previously-computed result.
            return self.repo_dir
        directory = g.os_path_abspath(os.curdir)
    #
    # Change to the new directory.
    self.repo_dir = self.find_git_working_directory(directory)
    if self.repo_dir:
        os.chdir(directory)
    else:
        g.es_print('no .git directory found in %r' % directory)
    return self.repo_dir
</t>
<t tx="ekr.20180519111302.1">def get_jedi_completions(self, prefix):

    c = self.c
    w = c.frame.body.wrapper
    i = w.getInsertPoint()
    p = c.p
    body_s = p.b
    #
    # Get the entire source for jedi.
    t1 = time.clock()
    goto = gotoCommands.GoToCommands(c)
    root, fileName = goto.find_root(p)
    if root:
        source = goto.get_external_file_with_sentinels(root=root or p)
        n0 = goto.find_node_start(p=p, s=source)
        if n0 is None: n0 = 0
    else:
        source = body_s
        n0 = 0
    t2 = time.clock()
    #
    # Get local line
    lines = g.splitLines(body_s)
    row, column = g.convertPythonIndexToRowCol(body_s, i)
    line = lines[row]
    #
    # Find the global line, and compute offsets.
    source_lines = g.splitLines(source)
    for jedi_line, g_line in enumerate(source_lines[n0:]):
        if line.lstrip() == g_line.lstrip():
            # Adjust the column.
            indent1 = len(line)-len(line.lstrip())
            indent2 = len(g_line)-len(g_line.lstrip())
            if indent2 &gt;= indent1:
                local_column = column # For traces.
                column += abs(indent2-indent1)
                break
    else:
        completions = None
        jedi_line, indent1, indent2 = None, None, None
        g.printObj(source_lines[n0-1:n0+30])
        print('can not happen: not found: %r' % line)
    #
    # Get the jedi completions.
    if jedi_line is not None:
        import jedi
        try:
            script = jedi.Script(
                source=source,
                line=1+n0+jedi_line,
                column=column,
                path = g.shortFileName(fileName),
                # encoding='utf-8',
                # sys_path=None):
            ) 
            completions = script.completions()
            t3 = time.clock()
        except ValueError:
            t3 = time.clock()
            completions = None
            g.printObj(source_lines[n0-1:n0+30])
            print('ERROR', p.h)
    if not completions:
        return []
    # May be used in traces below.
    assert t3 &gt;= t2 &gt;= t1
    assert local_column is not None  
    completions = [z.name for z in completions]
    completions = [self.add_prefix(prefix, z) for z in completions]
    # Retain these for now...
        # g.printObj(completions[:5])
        # head = line[:local_column]
        # ch = line[local_column:local_column+1]
        # g.trace(len(completions), repr(ch), head.strip())
    return completions
</t>
<t tx="ekr.20180526211127.1">def add_prefix(self, prefix, s):
    '''A hack to match the callers expectations.'''
    if prefix.find('.') &gt; -1:
        aList = prefix.split('.')
        prefix = '.'.join(aList[:-1]) + '.'
    return s if s.startswith(prefix) else prefix + s
</t>
<t tx="ekr.20180602062323.7">translate_table = b''.join([g.toEncodedString(chr(z)) for z in range(20) if chr(z) not in '\t\r\n'])
    # See https://en.wikipedia.org/wiki/Valid_characters_in_XML.

def readWithElementTree(self, path, s):
    
    s = s.translate(None, self.translate_table)
        # Fix #1036 and #1046.
    contents = g.toUnicode(s) if g.isPython3 else s
    try:
        xroot = ElementTree.fromstring(contents)
    except Exception as e:
        if path:
            message = 'bad .leo file: %s' % g.shortFileName(path)
        else:
            message = 'The clipboard is not a vaild .leo file'
        print('')
        g.es_print(message, color='red')
        g.es_print(g.toUnicode(e))
        print('')
        # #970: Just report failure here.
        return None
    g_element = xroot.find('globals')
    v_elements = xroot.find('vnodes')
    t_elements = xroot.find('tnodes')
    gnx2body, gnx2ua = self.scanTnodes(t_elements)
    hidden_v = self.scanVnodes(gnx2body, self.gnx2vnode, gnx2ua, v_elements)
    self.handleBits()
    return hidden_v, g_element
</t>
<t tx="ekr.20180602062323.8">def scanTnodes (self, t_elements):

    gnx2body, gnx2ua = {}, defaultdict(dict)
    for e in t_elements:
        # First, find the gnx.
        gnx = e.attrib['tx']
        gnx2body [gnx] = e.text or ''
        # Next, scan for uA's for this gnx.
        for key, val in e.attrib.items():
            if key != 'tx':
                gnx2ua [gnx][key] = self.resolveUa(key, val)
    return gnx2body, gnx2ua
</t>
<t tx="ekr.20180602062323.9">def scanVnodes(self, gnx2body, gnx2vnode, gnx2ua, v_elements):
    
    c, fc = self.c, self.c.fileCommands
    &lt;&lt; define v_element_visitor &gt;&gt;
    #
    # Create the hidden root vnode.
    gnx = 'hidden-root-vnode-gnx'
    hidden_v = leoNodes.VNode(context=c, gnx=gnx)
    hidden_v._headString = g.u('&lt;hidden root vnode&gt;')
    gnx2vnode [gnx] = hidden_v
    #
    # Traverse the tree of v elements.
    v_element_visitor(v_elements, hidden_v)
    return hidden_v
</t>
<t tx="ekr.20180602102448.1">class FastAtRead (object):
    '''
    Read an exteral file, created from an @file tree.
    This is Vitalije's code, edited by EKR.
    '''

    def __init__ (self, c, gnx2vnode, test=False, TestVNode=None): 
        self.c = c
        assert gnx2vnode is not None
        self.gnx2vnode = gnx2vnode
            # The global fc.gnxDict. Keys are gnx's, values are vnodes.
        self.path = None
        self.root = None
        self.VNode = TestVNode if test else leoNodes.VNode
        self.test = test

    @others
</t>
<t tx="ekr.20180602103135.10">if verbatim:
    # We are in raw mode, or other special situation.
    # Previous line was verbatim sentinel. Append this line as it is.
    if afterref:
        afterref = False
        if body: # a List of lines.
            body[-1] = body[-1].rstrip() + line
        else:
            body = [line]
        verbatim = False
    elif in_raw:
        m = end_raw_pat.match(line)
        if m:
            in_raw = False
            verbatim = False
        else:
             body.append(line)
             # Continue verbatim/raw mode.
    else:
        body.append(line)
        verbatim = False
    continue
if line == verbline: # &lt;delim&gt;@verbatim.
    verbatim = True
    continue
#
# Strip the line only once.
strip_line = line.strip()
#
# Undo the cweb hack.
if is_cweb and line.startswith(sentinel):
    line = line[:len(sentinel)] + line[len(sentinel):].replace('@@', '@')
# Adjust indentation.
if indent and line[:indent].isspace() and len(line) &gt; indent:
    line = line[indent:]
</t>
<t tx="ekr.20180602103135.12"># This is valid because all following sections are either:
# 1. guarded by 'if in_doc' or
# 2. guarded by a pattern that matches the start of the sentinel.   
#
if not in_doc and not strip_line.startswith(sentinel):
    # lstrip() is faster than using a regex!
    body.append(line)
    continue
</t>
<t tx="ekr.20180602103135.13">m = all_pat.match(line)
if m:
    # @all tells Leo's *write* code not to check for undefined sections.
    # Here, in the read code, we merely need to add it to the body.
    # Pushing and popping the stack may not be necessary, but it can't hurt.
    if m.group(2) == '+': # opening sentinel
        body.append('%s@all%s\n' % (m.group(1), m.group(3) or ''))
        stack.append((gnx, indent, body))
    else: # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
        gnx2body[gnx] = body
    continue
</t>
<t tx="ekr.20180602103135.14">m = others_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+': # opening sentinel
        body.append('%s@others%s\n' % (m.group(1), m.group(3) or ''))
        stack.append((gnx, indent, body))
        indent += m.end(1) # adjust current identation
    else: # closing sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
</t>
<t tx="ekr.20180602103135.16">if in_doc:
    # When delim_end exists the doc block:
    # - begins with the opening delim, alonw on its own line
    # - ends with the closing delim, alone on its own line.
    # Both of these lines should be skipped
    if line in doc_skip:
        # doc_skip is (delim_start + '\n', delim_end + '\n')
        continue
    #
    # Check for @c or @code.
    m = code_pat.match(line)
    if m:
        in_doc = False 
        body.append('@code\n' if m.group(1) else '@c\n')
        continue
else:
    m = doc_pat.match(line)
    if m:
        # @+at or @+doc?
        doc = '@doc' if m.group(1) == 'doc' else '@'
        doc2 = m.group(2) or '' # Trailing text.
        if doc2:
            body.append('%s%s\n'%(doc, doc2))
        else:
            body.append(doc + '\n')
        # Enter @doc mode.
        in_doc = True
        continue
</t>
<t tx="ekr.20180602103135.17"># Probably can't happen: an apparent sentinel line.
# Such lines should be @@ lines or follow @verbatim.
#
# This assert verifies the short-circuit test.
assert strip_line.startswith(sentinel), (repr(sentinel), repr(line))
#
# This trace is less important, but interesting.
g.trace('UNEXPECTED LINE:', repr(sentinel), repr(line), g.shortFileName(self.path))
body.append(line)
</t>
<t tx="ekr.20180602103135.18">m = ref_pat.match(line)
if m:
    in_doc = False
    if m.group(2) == '+':
        # open sentinel.
        body.append(m.group(1) + g.angleBrackets(m.group(3)) + '\n')
        stack.append((gnx, indent, body))
        indent += m.end(1)
    else:
        # close sentinel.
        # m.group(2) is '-' because the pattern matched.
        gnx, indent, body = stack.pop()
    continue
</t>
<t tx="ekr.20180602103135.19">m = node_start_pat.match(line)
if m:
    in_doc, in_raw = False, False
    gnx, head = m.group(2), m.group(5)
    level = int(m.group(3)) if m.group(3) else 1 + len(m.group(4))
        # m.group(3) is the level number, m.group(4) is the number of stars.
    v = gnx2vnode.get(gnx)
    #
    # Case 1: The root @file node. Don't change the headline.
    if not root_seen:
        # Fix #1064: The node represents the root, regardless of the gnx!
        root_seen = True
        clone_v = None
        gnx2body[gnx] = body = []
        if not v:
            # Fix #1064.
            v = root_v
            # This message is annoying when using git-diff.
                # if gnx != root_gnx:
                    # g.es_print("using gnx from external file: %s" % (v.h), color='blue')
            gnx2vnode [gnx] = v
            v.fileIndex = gnx
        v.children = []
        continue
    #
    # Case 2: We are scanning the descendants of a clone.
    parent_v, clone_v = level_stack[level-2]
    if v and clone_v:
        # The last version of the body and headline wins..
        gnx2body[gnx] = body = []
        v._headString = head
        # Update the level_stack.
        level_stack = level_stack[:level-1]
        level_stack.append((v, clone_v),)
        # Always clear the children!
        v.children=[]
        parent_v.children.append(v)
        continue
    #
    # Case 3: we are not already scanning the descendants of a clone.
    if v:
        # The *start* of a clone tree. Reset the children.
        clone_v = v
        v.children = []
    else:
        # Make a new vnode.
        v = self.VNode(context=context, gnx=gnx)
    #
    # The last version of the body and headline wins.
    gnx2vnode[gnx] = v
    gnx2body[gnx] = body = []
    v._headString = head
    #
    # Update the stack.
    level_stack = level_stack[:level-1]
    level_stack.append((v, clone_v),)
    #
    # Update the links.
    assert v != root_v
    parent_v.children.append(v)
    v.parents.append(parent_v)
    # dump_v()
    continue
</t>
<t tx="ekr.20180602103135.2">header_pattern = re.compile(r'''
    ^(.+)@\+leo
    (-ver=(\d+))?
    (-thin)?
    (-encoding=(.*)(\.))?
    (.*)$''', re.VERBOSE)

def scan_header(self, lines):
    '''
    Scan for the header line, which follows any @first lines.
    Return (delims, first_lines, i+1) or None
    '''
    first_lines = []
    i = 0 # To keep pylint happy.
    for i, line in enumerate(lines):
        m = self.header_pattern.match(line)
        if m:
            delims = m.group(1), m.group(8) or ''
            return delims, first_lines, i+1
        first_lines.append(line)
    return None
</t>
<t tx="ekr.20180602103135.20">if line.startswith(delim_start + '@-leo'):
    i += 1
    break
</t>
<t tx="ekr.20180602103135.3">@nobeautify

def get_patterns(self, delims):
    '''Create regex patterns for the given comment delims.'''
    # This must be a function, because of @comments &amp; @delims.
    delim_start, delim_end = delims
    delims = re.escape(delim_start), re.escape(delim_end or '')
    delim_start, delim_end = delims
    patterns = (
        # The list of patterns, in alphabetical order.
        # These patterns must be mutually exclusive.
        r'^\s*%s@afterref%s$'%delims,               # @afterref
        r'^(\s*)%s@(\+|-)all\b(.*)%s$'%delims,      # @all
        r'^\s*%s@@c(ode)?%s$'%delims,               # @c and @code
        r'^\s*%s@comment(.*)%s'%delims,             # @comment
        r'^\s*%s@delims(.*)%s'%delims,              # @delims
        r'^\s*%s@\+(at|doc)?(\s.*?)?%s\n'%delims,   # @doc or @
        r'^\s*%s@end_raw\s*%s'%delims,              # @end_raw
        r'^\s*%s@@first%s$'%delims,                 # @first
        r'^\s*%s@@last%s$'%delims,                  # @last
        r'^(\s*)%s@\+node:([^:]+): \*(\d+)?(\*?) (.*)%s$'%delims, # @node
        r'^(\s*)%s@(\+|-)others\b(.*)%s$'%delims,   # @others
        r'^\s*%s@raw(.*)%s'%delims,                 # @raw
        r'^(\s*)%s@(\+|-)%s\s*%s$'%(                # section ref
            delim_start, g.angleBrackets('(.*)'), delim_end)
    )
    # Return the compiled patterns, in alphabetical order.
    return (re.compile(pattern) for pattern in patterns)
</t>
<t tx="ekr.20180602103135.8">def scan_lines(self, delims, first_lines, lines, start, test=False):
    '''Scan all lines of the file, creating vnodes.'''
    &lt;&lt; init scan_lines &gt;&gt;
    &lt;&lt; define dump_v &gt;&gt;
    i = 0 # To keep pylint happy.
    for i, line in enumerate(lines[start:]):
        # Order matters.
        &lt;&lt; 1. common code for all lines &gt;&gt;
        &lt;&lt; 2. short-circuit later tests &gt;&gt;
        &lt;&lt; 3. handle @others &gt;&gt; # clears in_doc
        &lt;&lt; 4. handle section refs &gt;&gt; # clears in_doc.
        # Order doesn't matter, but match more common sentinels first.
        &lt;&lt; handle node_start &gt;&gt;
        &lt;&lt; handle end of @doc &amp; @code parts &gt;&gt;
        &lt;&lt; handle @all &gt;&gt;
        &lt;&lt; handle afterref &gt;&gt;
        &lt;&lt; handle @first and @last &gt;&gt;
        &lt;&lt; handle @comment &gt;&gt;
        &lt;&lt; handle @delims &gt;&gt;
        &lt;&lt; handle @raw &gt;&gt;
        &lt;&lt; handle @-leo &gt;&gt;
        # These must be last, in this order.
        &lt;&lt; Last 1. handle remaining @@ lines &gt;&gt;
        &lt;&lt; Last 2. handle remaining @doc lines &gt;&gt;
        &lt;&lt; Last 3. handle remaining @ lines &gt;&gt;
    else:
        # No @-leo sentinel
        return None, []
    # Handle @last lines.
    last_lines = lines[start+i:]
    if last_lines:
        last_lines = ['@last ' + z for z in last_lines]
        gnx2body[root_gnx] = gnx2body[root_gnx] + last_lines
    self.post_pass(gnx2body, gnx2vnode, root_v)
    return root_v, last_lines
</t>
<t tx="ekr.20180602103135.9">#
# Simple vars...
afterref = False
    # A special verbatim line follows @afterref.
clone_v = None
    # The root of the clone tree.
    # When not None, we are scanning a clone and all it's descendants.
delim_start, delim_end = delims
    # The start/end delims.
doc_skip = (delim_start + '\n', delim_end + '\n')
    # To handle doc parts.
first_i = 0
    # Index into first array.
in_doc = False
    # True: in @doc parts.
in_raw = False
    # True: @raw seen.
is_cweb = delim_start == '@q@' and delim_end == '@&gt;'
    # True: cweb hack in effect.
indent = 0 
    # The current indentation.
level_stack = []
    # Entries are (vnode, in_clone_tree)
n_last_lines = 0
    # The number of @@last directives seen.
root_seen = False
    # False: The next +@node sentinel denotes the root, regardless of gnx.
    # Needed to handle #1065 so reads will not create spurious child nodes.
sentinel = delim_start + '@'
    # Faster than a regex!
stack = []
    # Entries are (gnx, indent, body)
    # Updated when at+others, at+&lt;section&gt;, or at+all is seen.
verbline = delim_start + '@verbatim' + delim_end + '\n'
    # The spelling of at-verbatim sentinel
verbatim = False
    # True: the next line must be added without change.
#
# Init the data for the root node.
#

#
# Init the parent vnode for testing.
#
if self.test:
    root_gnx = gnx = g.u('root-gnx')
        # The node that we are reading.
        # start with the gnx for the @file node.
    gnx_head =  g.u('&lt;hidden top vnode&gt;')
        # The headline of the root node.
    context = None
    parent_v = self.VNode(context=context, gnx=gnx)
    parent_v._headString = gnx_head
        # Corresponds to the @files node itself.
else:
    # Production.
    root_gnx = gnx = self.root.gnx
    context = self.c
    parent_v = self.root.v
root_v = parent_v
    # Does not change.
level_stack.append((root_v, False),)
#
# Init the gnx dict last.
#
gnx2vnode = self.gnx2vnode
    # Keys are gnx's, values are vnodes.
gnx2body = {}
    # Keys are gnxs, values are list of body lines.
gnx2vnode[gnx] = parent_v
    # Add gnx to the keys
gnx2body[gnx] = body = first_lines
    # Add gnx to the keys.
    # Body is the list of lines presently being accumulated.
#
# get the patterns.
after_pat, all_pat, code_pat, comment_pat, delims_pat,\
doc_pat, end_raw_pat, first_pat, last_pat, \
node_start_pat, others_pat, raw_pat, ref_pat = self.get_patterns(delims)
</t>
<t tx="ekr.20180603060721.1">def post_pass(self, gnx2body, gnx2vnode, root_v):
    '''Set all body text.'''
    # Set the body text.
    if self.test:
        # Check the keys.
        bkeys = sorted(gnx2body.keys())
        vkeys = sorted(gnx2vnode.keys())
        if bkeys != vkeys:
            g.trace('KEYS MISMATCH')
            g.printObj(bkeys)
            g.printObj(vkeys)
            if self.test:
                sys.exit(1)
        # Set the body text.
        for key in vkeys:
            v = gnx2vnode.get(key)
            body = gnx2body.get(key)
            v._bodyString = ''.join(body)
    else:
        assert root_v.gnx in gnx2vnode, root_v
        assert root_v.gnx in gnx2body, root_v
        # Don't use items(): it doesn't exist in Python 2.
        for key in gnx2body: 
            body = gnx2body.get(key)
            v = gnx2vnode.get(key)
            assert v, (key, v)
            v._bodyString = g.toUnicode(''.join(body))
</t>
<t tx="ekr.20180603063102.1">m = after_pat.match(line)
if m:
    afterref = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
</t>
<t tx="ekr.20180603135602.1"># @first, @last, @delims and @comment generate @@ sentinels,
# So this must follow all of those.
if line.startswith(delim_start + '@@'):
    ii = len(delim_start) + 1 # on second '@'
    jj = line.rfind(delim_end) if delim_end else -1
    body.append(line[ii:jj] + '\n')
    continue
</t>
<t tx="ekr.20180603170614.1">def read_into_root(self, contents, path, root):
    '''
    Parse the file's contents, creating a tree of vnodes
    anchored in root.v.
    '''
    trace = False
    t1 = time.clock()
    self.path = path
    self.root = root
    sfn = g.shortFileName(path)
    contents = contents.replace('\r','')
    lines = g.splitLines(contents)
    data = self.scan_header(lines)
    if not data:
        g.trace('Invalid external file: %s' % sfn)
        return False
    # Clear all children.
    # Previously, this had been done in readOpenFile.
    root.v._deleteAllChildren()
    delims, first_lines, start_i = data
    self.scan_lines(
        delims, first_lines, lines, start_i)
    if trace:
        t2 = time.clock()
        g.trace('%5.3f sec. %s' % ((t2-t1), path))
    return True
</t>
<t tx="ekr.20180604114156.2">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/433

- Report error: see child node.
- Ask: Do I need to accept Terry's work?

Terry's code is in plugins/editpane/editpane.py

@language python
</t>
<t tx="ekr.20180604114156.3">@language rest
@wrap

LEP: __init__ LEP
LEP: Loaded module: plaintextedit
LEP: Loaded module: plaintextview
LEP: Loaded module: __init__
LEP: Loaded module: clicky_splitter
LEP: Loaded module: csvedit
LEP: Loaded module: editpane
LEP: Loaded module: leotextedit
LEP: Loaded module: markdownview
LEP: Module not loaded (unmet dependencies?): pandownview
LEP: Module not loaded (unmet dependencies?): vanillascintilla
LEP: Module not loaded (unmet dependencies?): webengineview
LEP: Loaded module: webkitview
LEP: build layout
LEP: new edit position
LEP: text changed, NOT focused
LEP: new view position
LEP: update edit position
LEP: update editor text
LEP: text changed, NOT focused
LEP: update view position
LEP:
register handlers
LEP: unregister handlers</t>
<t tx="ekr.20180604114211.1">@nosearch
</t>
<t tx="ekr.20180604114211.408">@language rest
@wrap
wikiview.py plugin problem with new colorizing code
https://github.com/leo-editor/leo-editor/issues/388

@language python
</t>
<t tx="ekr.20180604114211.561">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/678

10 years ago:
http://leo.zwiki.org/GraphsInTrees

@language python
</t>
<t tx="ekr.20180605062300.1">def scanGlobals(self, g_element):
    '''Get global data from the cache, with reasonable defaults.'''
    c = self.c
    d = self.getGlobalData()
    windowSize = g.app.loadManager.options.get('windowSize')
    if windowSize is not None:
        h, w = windowSize # checked in LM.scanOption.
    else:
        w, h = d.get('width'), d.get('height')
    x, y = d.get('left'), d.get('top')
    r1, r2 = d.get('r1'), d.get('r2')
    c.frame.setTopGeometry(w, h, x, y, adjustSize=True)
    c.frame.resizePanesToRatio(r1, r2)
    if g.app.start_minimized:
        c.frame.setTopGeometry(w, h, x, y)
    elif not g.app.start_maximized and not g.app.start_fullscreen:
        c.frame.setTopGeometry(w, h, x, y)
        c.frame.deiconify()
</t>
<t tx="ekr.20180605075042.1">v = leoNodes.VNode(context=c, gnx=gnx)
gnx2vnode [gnx] = v
parent_v.children.append(v)
v.parents.append(parent_v)
body = g.toUnicode(gnx2body.get(gnx) or '')
assert g.isUnicode(body), body.__class__.__name__
v._bodyString = body
v._headString = 'PLACE HOLDER'
</t>
<t tx="ekr.20180605075113.1"># Like fc.handleVnodeSaxAttrutes.
#
# The native attributes of &lt;v&gt; elements are a, t, vtag, tnodeList,
# marks, expanded, and descendentTnode/VnodeUnknownAttributes.
d = e.attrib
s = d.get('tnodeList', '')
tnodeList = s and s.split(',')
if tnodeList:
    # This tnodeList will be resolved later.
    v.tempTnodeList = tnodeList
s = d.get('descendentTnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentTnodeUaDictList.append(aDict)
s = d.get('descendentVnodeUnknownAttributes')
if s:
    aDict = fc.getDescendentUnknownAttributes(s, v=v)
    if aDict:
        fc.descendentVnodeUaDictList.append((v, aDict),)
#
# Handle vnode uA's
uaDict = gnx2ua[gnx]
    # gnx2ua is a defaultdict(dict)
    # It might already exists because of tnode uA's.
for key, val in d.items():
    if key not in self.nativeVnodeAttributes:
        uaDict[key] = self.resolveUa(key, val)
if uaDict:
    v.unknownAttributes = uaDict
</t>
<t tx="ekr.20180605102822.1">def v_element_visitor(parent_e, parent_v):
    '''Visit the given element, creating or updating the parent vnode.'''
    for e in parent_e:
        assert e.tag in ('v','vh'), e.tag
        if e.tag == 'vh':
            parent_v._headString = g.toUnicode(e.text or '')
            continue
        gnx = e.attrib['t']
        v = gnx2vnode.get(gnx)
        if v:
            # A clone
            parent_v.children.append(v)
            v.parents.append(parent_v)
            # The body overrides any previous body text.
            body = g.toUnicode(gnx2body.get(gnx) or '')
            assert g.isUnicode(body), body.__class__.__name__
            v._bodyString = body
        else:
            &lt;&lt; Make a new vnode, linked to the parent &gt;&gt;
            &lt;&lt; handle all other v attributes &gt;&gt;
            # Handle all inner elements.
            v_element_visitor(e, v)
</t>
<t tx="ekr.20180606035619.1"></t>
<t tx="ekr.20180606041211.1">def resolveUa(self, attr, val, kind=None): # Kind is for unit testing.
    '''Parse an unknown attribute in a &lt;v&gt; or &lt;t&gt; element.'''
    try:
        val = g.toEncodedString(val)
    except Exception:
        g.es_print('unexpected exception converting hexlified string to string')
        g.es_exception()
        return None
    # Leave string attributes starting with 'str_' alone.
    if attr.startswith('str_'):
        if g.isString(val) or g.isBytes(val):
            return g.toUnicode(val)
    try:
        binString = binascii.unhexlify(val)
            # Throws a TypeError if val is not a hex string.
    except Exception:
        # Python 2.x throws TypeError
        # Python 3.x throws binascii.Error
        # Assume that Leo 4.1 or above wrote the attribute.
        if g.unitTesting:
            assert kind == 'raw', 'unit test failed: kind=' % repr(kind)
        else:
            g.trace('can not unhexlify %s=%s' % (attr, val))
        return val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        return val2
    except Exception:
        try:
            # for python 2.7 and python 3.4
            # pylint: disable=unexpected-keyword-arg
            val2 = pickle.loads(binString, encoding='bytes')
            val2 = self.bytesToUnicode(val2)
            return val2
        except Exception:
            g.trace('can not unpickle %s=%s' % (attr, val))
            return val
</t>
<t tx="ekr.20180606044154.1">def bytesToUnicode(self, ob):
    """
    Recursively convert bytes objects in strings / lists / dicts to str
    objects, thanks to TNT
    http://stackoverflow.com/questions/22840092
    Needed for reading Python 2.7 pickles in Python 3.4.
    """
    # pylint: disable=unidiomatic-typecheck
    # This is simpler than using isinstance.
    t = type(ob)
    if t in (list, tuple):
        l = [str(i, 'utf-8') if type(i) is bytes else i for i in ob]
        l = [self.bytesToUnicode(i) if type(i) in (list, tuple, dict) else i
            for i in l]
        ro = tuple(l) if t is tuple else l
    elif t is dict:
        byte_keys = [i for i in ob if type(i) is bytes]
        for bk in byte_keys:
            v = ob[bk]
            del(ob[bk])
            ob[str(bk, 'utf-8')] = v
        for k in ob:
            if type(ob[k]) is bytes:
                ob[k] = str(ob[k], 'utf-8')
            elif type(ob[k]) in (list, tuple, dict):
                ob[k] = self.bytesToUnicode(ob[k])
        ro = ob
    elif t is bytes: # TNB added this clause
        ro = str(ob, 'utf-8')
    else:
        ro = ob
    return ro
</t>
<t tx="ekr.20180606053919.1">m = first_pat.match(line)
if m:
    if 0 &lt;= first_i &lt; len(first_lines):
        body.append('@first ' + first_lines[first_i])
        first_i += 1
    else:
        g.trace('too many @first lines')
    continue
m = last_pat.match(line)
if m:
    n_last_lines += 1
    continue
</t>
<t tx="ekr.20180606054325.1">if in_doc:
    if delim_end:
        # doc lines are unchanged.
        body.append(line)
    else:
        # Doc lines start with start_delim + one blank.
        body.append(line[len(delim_start)+1:])
    continue
</t>
<t tx="ekr.20180606080200.1"># http://leoeditor.com/directives.html#part-4-dangerous-directives
m = raw_pat.match(line)
if m:
    in_raw = True
    verbatim = True
        # Avoid an extra test in the main loop.
    continue
</t>
<t tx="ekr.20180608104836.1">m = delims_pat.match(line)
if m:
    # Get 1 or 2 comment delims
    # Whatever happens, retain the original @delims line.
    delims = m.group(1).strip()
    body.append('@delims %s\n' % delims)
    #
    # Parse the delims.
    delims_pat = re.compile(r'^([^ ]+)\s*([^ ]+)?')
    m2 = delims_pat.match(delims)
    if not m2:
        g.trace('Ignoring invalid @comment: %r' % line)
        continue
    delim_start = m2.group(1)
    delim_end = m2.group(2) or ''
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__','\n').replace('_',' ')
    delim_end = delim_end.replace('__','\n').replace('_',' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@&gt;'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
</t>
<t tx="ekr.20180613061743.1">def dump_v():
    '''Dump the level stack and v.'''
    print('----- LEVEL', level, v.h)
    print('       PARENT', parent_v.h)
    print('[')
    for i, data in enumerate(level_stack):
        v2, in_tree = data
        print('%2s %5s %s' % (i+1, in_tree, v2.h))
    print(']')
    print('PARENT.CHILDREN...')
    g.printObj([v3.h for v3 in parent_v.children])
    print('PARENTS...')
    g.printObj([v4.h for v4 in v.parents])
</t>
<t tx="ekr.20180619063409.1">@language rest
@wrap

The freemind importer should use ElementTree, not lxml
https://github.com/leo-editor/leo-editor/issues/929
ElementTree is more widely available.

@language python
</t>
<t tx="ekr.20180621050901.1"># http://leoeditor.com/directives.html#part-4-dangerous-directives
m = comment_pat.match(line)
if m:
    # &lt;1, 2 or 3 comment delims&gt;
    delims = m.group(1).strip()
    # Whatever happens, retain the @delims line.
    body.append('@comment %s\n' % delims)
    delim1, delim2, delim3 = g.set_delims_from_string(delims)
        # delim1 is always the single-line delimiter.
    if delim1:
        delim_start, delim_end = delim1, ''
    else:
        delim_start, delim_end = delim2, delim3
    #
    # Within these delimiters:
    # - double underscores represent a newline.
    # - underscores represent a significant space,
    delim_start = delim_start.replace('__','\n').replace('_',' ')
    delim_end = delim_end.replace('__','\n').replace('_',' ')
    # Recalculate all delim-related values
    doc_skip = (delim_start + '\n', delim_end + '\n')
    is_cweb = delim_start == '@q@' and delim_end == '@&gt;'
    sentinel = delim_start + '@'
    #
    # Recalculate the patterns.
    delims = delim_start, delim_end
    (
        after_pat, all_pat, code_pat, comment_pat, delims_pat,
        doc_pat, end_raw_pat, first_pat, last_pat,
        node_start_pat, others_pat, raw_pat, ref_pat
    ) = self.get_patterns(delims)
    continue
</t>
<t tx="ekr.20180622110112.1">def fast_read_into_root(self, c, contents, gnx2vnode, path, root):
    '''A convenience wrapper for FastAtReAD.read_into_root()'''
    return FastAtRead(c, gnx2vnode).read_into_root(contents, path, root)
</t>
<t tx="ekr.20180624125321.1">def handleBits(self):

    c, fc = self.c, self.c.fileCommands
    expanded = c.db.get('expanded')
    marked = c.db.get('marked')
    expanded = expanded.split(',') if expanded else []
    marked = marked.split(',') if marked else []
    fc.descendentExpandedList = expanded
    fc.descendentMarksList = marked
</t>
<t tx="ekr.20180627050237.1">def dump_cache(db, tag):
    '''Dump the given cache.'''
    print('\n===== %s =====\n' % tag)
    # Create a dict, sorted by file prefixes.
    d = {}
    for key in db.keys():
        key = key[0]
        val = db.get(key)
        data = key.split(':::')
        if len(data) == 2:
            fn, key2 = data
        else:
            fn, key2 = 'None', key
        aList = d.get(fn, [])
        aList.append((key2, val),)
        d[fn] = aList
    # Print the dict.
    files = 0
    for key in sorted(d.keys()):
        if key != 'None':
            dump_list('File: ' + key, d.get(key))
            files += 1
    if d.get('None'):
        heading = 'All others' if files else None
        dump_list(heading, d.get('None'))
        
def dump_list(heading, aList):
    if heading:
        print('\n%s...\n' % heading)
    for aTuple in aList:
        key, val = aTuple
        if g.isString(val):
            if key.endswith(('leo_expanded', 'leo_marked')):
                if val:
                    print('%30s:' % key)
                    g.printObj(val.split(','))
                else:
                    print('%30s: []' % key)
            else:
                print('%30s: %s' % (key, val))   
        elif isinstance(val, (int, float)):
            print('%30s: %s' % (key, val))    
        else:
            print('%30s:' % key)
            g.printObj(val)
</t>
<t tx="ekr.20180708060437.1">def getGlobalData(self):
    '''Return a dict containing all global data.'''
    c = self.c
    try:
        window_pos = c.db.get('window_position')
        r1 = float(c.db.get('body_outline_ratio', '0.5'))
        r2 = float(c.db.get('body_secondary_ratio', '0.5'))
        top, left, height, width = window_pos
        return {
            'top': int(top),
            'left': int(left),
            'height': int(height),
            'width': int(width),
            'r1': r1,
            'r2': r2,
        }
    except Exception:
        pass
    # Use reasonable defaults.
    return {
        'top': 50, 'left': 50,
        'height': 500, 'width': 800,
        'r1': 0.5, 'r2': 0.5,
    }
</t>
<t tx="ekr.20180708145905.1">@language rest
@wrap

This is the theory of operation document for py2cs.py. The most interesting aspect of this script is the TokenSync class. This class provides a reliable way of associating tokenizer tokens with ast nodes.

@others
</t>
<t tx="ekr.20180708145905.6">
### Using the TokenSync class

The present code is driven by ast trees, but each visitor of the CoffeeScriptTraverser class takes care to preserve **otherwise-ignored tokens**. These are tokens that would otherwise be ignored: namely blank lines and comments, both entire-line comments and trailing comments.

The visitor for each statement intersperses otherwise ignored tokens using calls to the TokenSync class.  The simplest cases are like this:

    def do_Break(self, node):
        head = self.leading_string(node)
        tail = self.trailing_comment(node)
        return head + self.indent('break') + tail

The leading_string and trailing_comment methods simply redirect to the corresponding methods in the TokenSync class.  Saves a bit of typing. Compound statements are a bit more bother, but not overly so. For example:

    def do_If(self, node):

        result = self.leading_lines(node)
        tail = self.trailing_comment(node)
        s = 'if %s:%s' % (self.visit(node.test), tail)
        result.append(self.indent(s))
        for z in node.body:
            self.level += 1
            result.append(self.visit(z))
            self.level -= 1
        if node.orelse:
            tail = self.tail_after_body(node.body, node.orelse, result)
            result.append(self.indent('else:' + tail))
            for z in node.orelse:
                self.level += 1
                result.append(self.visit(z))
                self.level -= 1
        return ''.join(result)

The line:

        tail = self.tail_after_body(node.body, node.orelse, result)

is a hack needed to compensate for the lack of an actual ast.Else node.
</t>
<t tx="ekr.20180708145905.7">
### Summary

The TokenSync class is, a new, elegant, unexpected and happy development. It is a relatively easy-to-use helper that allows parser-based code to preserve data that is not easily accessible in parse trees.

The TokenSync class avoids [problems with the col_offset field](
http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) in ast nodes. The TokenSync class depends only on the ast.lineno field and the tokenize module. We can expect it to be rock solid.

Edward K. Ream
February 20 to 25, 2016



</t>
<t tx="ekr.20180708152000.1">
### The problem

The initial version of py2cs.py (the script) used only tokens. This solved all token-related problems, but made parsing difficult. Alas, it is [difficult](http://stackoverflow.com/questions/16748029/how-to-get-source-corresponding-to-a-python-ast-node) to associate tokens with ast nodes.

The script needs the following token-related data:

- The **ignored lines** (comment lines and blank lines) that precede any statement.

- The **trailing comment** strings that might follow any line.

- Optionally, the **line breaks** occurring within lines. At present, this script does not preserve such breaks, and it's probably not worth doing. Indeed, automatically breaking long lines seems more useful, especially considering that coffeescript lines may be substantially shorter than the corresponding python lines.

- The **exact spelling** of all strings.

The [ast_utils module](
https://bitbucket.org/plas/thonny/src/3b71fda7ac0b66d5c475f7a668ffbdc7ae48c2b5/thonny/ast_utils.py?at=master) purports to solve this problem with convoluted adjustments to the col_offset field. This approach is subject to subtle Python bugs, and subtle differences between Python 2 and Python 3. There is a better way...
</t>
<t tx="ekr.20180708152018.1">
### Design

The main idea is to use *only* the ast.lineno fields and the tokenizer module to recreate token data. The design assumes only that both the ast.lineno field and Python's tokenizer module are solid. This is a much more reasonable assumption than assuming that the col_offset field always tells the truth. In short, this design *ignores* the ast.col_offset field.

At startup, the TokenSync ctor assigns all the incoming tokens to various lists.  These lists are indexed by lineno:

    ts.line_tokens[i]: all the tokens on line i
    ts.string_tokens[i]: all string tokens on line i
    st.ignored_lines: the blank or comment line on line i

It is very easy to create these lists. The code does not depend on any arcane details.

#### Recovering the exact spelling of stings.

ts.synch_string returns the *next* string on the line. Here it is, stripped of defensive code:

    def sync_string(self, node):
        '''Return the spelling of the string at the given node.'''
        tokens = self.string_tokens[node.lineno-1]
        token = tokens.pop(0)
        self.string_tokens[node.lineno-1] = tokens
        return self.token_val(token)

Stripped of defensive code, the do_Str visitor is just:

    def do_Str(self, node):
        '''A string constant, including docstrings.'''
        return self.sync_string(node)

#### Recovering otherwise ignored nodes

**ts.leading_lines(node)** returns a list of otherwise ignored lines that
precede the node's line that have not already been returned.
**ts.leading_string(node)** is a convenience method that returns ''.join(ts.leading_lines(node)). The visitors of the CoffeeScriptTraverser class show how to use these methods.
</t>
<t tx="ekr.20180816105258.1">import leo.commands.editFileCommands as efc

efc.GitDiffController(c).diff_two_branches(
    branch1='devel',
    branch2='5.8-b1-rel',
    fn='leo/plugins/qt_tree.py',
    directory=None,
)
</t>
<t tx="ekr.20180824062242.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/958

Leo 5.7 freezes with Python2 and PyQt4 in vim-mode.

I can't fix this if I can't duplicate it.

@language python
</t>
<t tx="ekr.20180824062905.1"># Apparently only necessary on some platforms, with some versions of Qt.

leo_changing_focus = False

def onFocusIn(self, event):
    '''Override QTextBrowser.focusInEvent.'''
    if self.leo_changing_focus:
        return
    try:
        if 'events' in g.app.debug:
            g.trace(g.callers())
        self.leo_changing_focus = True
        QtWidgets.QTextBrowser.focusInEvent(self, event)
    finally:
        self.leo_changing_focus = False
</t>
<t tx="ekr.20180824065751.1">print(p.gnx)</t>
<t tx="ekr.20181004060958.1"></t>
<t tx="ekr.20181005085507.1">def mousePressEvent(self, event):
    
    c = self.c

    def find_line(y):
        n, last_y = 0, 0
        for n, y2 in self.offsets:
            if last_y &lt;= y &lt; y2:
                return n
            last_y = y2
        return n if self.offsets else 0
        
    xdb = getattr(g.app, 'xdb', None)
    if not xdb:
        return
    path = xdb.canonic(g.fullPath(c, c.p))
    if not path:
        return
    n = find_line(event.y())
    if not xdb.checkline(path, n):
        g.trace('FAIL checkline', path, n)
        return
    if xdb.has_breakpoint(path, n):
        xdb.qc.put('clear %s:%s' % (path, n))
    else:
        xdb.qc.put('b %s:%s' % (path, n))
</t>
<t tx="ekr.20181005093003.1">def reloadSettings(self):
    c = self.c
    c.registerReloadSettings(self)
    self.w_adjust = c.config.getInt('gutter-w-adjust') or 12
        # Extra width for column.
    self.y_adjust = c.config.getInt('gutter-y-adjust') or 10
        # The y offset of the first line of the gutter.
</t>
<t tx="ekr.20181006100604.1">import leo.core.leoGlobals as g
import bdb
if g.isPython3:
    import queue
else:
    import Queue as queue
import os
import pdb
import re
import sys
import threading
</t>
<t tx="ekr.20181006160108.1">def __init__(self, path=None):
        
    self.qc = queue.Queue() # The command queue.
    self.qr = queue.Queue() # The request queue.
    stdin_q = self.QueueStdin(qc=self.qc)
    stdout_q = self.QueueStdout(qr=self.qr)
    # Start the singleton listener, in the main Leo thread.
    timer = getattr(g.app, 'xdb_timer', None)
    if timer:
        self.timer = timer
    else:
        self.timer = g.IdleTime(listener, delay=0)
        self.timer.start()
    # Init the base classes.
    threading.Thread.__init__(self)
    if g.isPython3:
        pdb.Pdb.__init__(self,
            stdin=stdin_q,
            stdout=stdout_q,
            readrc=False,
                # Don't read a .rc file.
        )
    else:
         pdb.Pdb.__init__(self, stdin=stdin_q, stdout=stdout_q)
    sys.stdout = stdout_q
    self.daemon = True
    self.path = path
    self.prompt = '(xdb) '
    self.saved_frame = None
    self.saved_traceback = None
</t>
<t tx="ekr.20181008045948.1"></t>
<t tx="ekr.20181009072707.1">@first # -*- coding: utf-8 -*-
&lt;&lt; imports &gt;&gt;
&lt;&lt; compute path &gt;&gt;
controller = leoBridge.controller(gui='nullGui',
    loadPlugins=False, readSettings=True,
    silent=False, verbose=False)
g = controller.globals()
c = controller.openLeoFile(path)
try:
    # Run all unit tests locally.
    root = g.findTopLevelNode(c, 'Active Unit Tests', exact=True)
    assert root, 'Not found: Active Unit Tests'
    c.selectPosition(root)
    &lt;&lt; run tests &gt;&gt;
except Exception as e:
    print('Unexpected exception 2', e)
    sys.exit(1)
</t>
<t tx="ekr.20181009084156.1">import leo.core.leoBridge as leoBridge
import os
import sys
# import pdb ; pdb.set_trace()
import unittest

</t>
<t tx="ekr.20181009084245.1">load_dir = os.path.abspath(os.path.dirname(__file__))
test_dir = os.path.join(load_dir, 'leo', 'test')
path = os.path.join(test_dir, 'unitTest.leo')
assert os.path.exists(path), repr(path)
</t>
<t tx="ekr.20181009084323.1">tm = c.testManager
g.unitTesting = g.app.unitTesting = True
suite = unittest.makeSuite(unittest.TestCase)
aList = tm.findAllUnitTestNodes(all=False, marked=False)
setup_script = None
found = False
for p in aList:
    if tm.isTestSetupNode(p):
        setup_script = p.b
        test = None
    elif tm.isTestNode(p):
        test = tm.makeTestCase(p, setup_script)
    elif tm.isSuiteNode(p):
        test = tm.makeTestSuite(p, setup_script)
    elif tm.isTestClassNode(p):
        test = tm.makeTestClass(p)
    else:
        test = None
    if test:
        suite.addTest(test)
        found = True
if not found:
    print('No unit tests')
    sys.exit(1)
runner = unittest.TextTestRunner(
    failfast=True, verbosity=1)
try:
    result = runner.run(suite)
    if result.errors or result.failures:
        print('errors: %s, failures: %s' % (
            len(result.errors), len(result.failures)))
        sys.exit(1)
    else:
        print('Travis unit tests all passed.')
        sys.exit(0)
except Exception:
    print('Unexpected exception')
    g.es_exception()
    sys.exit(1)
</t>
<t tx="ekr.20181009123539.1">@g.command('toggle-gutter')
def add_gutter(event):
    '''Add the gutter area showing line numbers.'''
    c = event.get('c')
    if not c:
        return
    dw = c.frame.top
    gutter = dw.gutter
    glayout = dw.gutter_layout
    if gutter.using_gutter:
        # NumberBar has a reference to gutter.edit.
        # Apparently, this causes problems.
        glayout.removeWidget(gutter.edit)
        glayout.removeWidget(gutter.number_bar)
        # glayout.invalidate()
        # glayout.parent().layout().invalidate()
        glayout.addWidget(dw.gutter.edit)
        gutter.using_gutter = False
    else:
        glayout.removeWidget(gutter.edit)
        glayout.addWidget(gutter.number_bar)
        glayout.addWidget(gutter.edit)
        gutter.using_gutter = True
</t>
<t tx="ekr.20181013081645.1">@path test</t>
<t tx="ekr.20181024134823.1">def addToOrphanList(self, root):
    '''Mark the root as erroneous for c.raise_error_dialogs().'''
    c = self.c
    # Fix #1050:
    root.setOrphan()
    c.orphan_at_file_nodes.append(root.h)
</t>
<t tx="ekr.20181027133311.1">def issueSecurityWarning(setting):
    g.es('Security warning! Ignoring...',color='red')
    g.es(setting, color='red')
    g.es('This setting can be set only in')
    g.es('leoSettings.leo or myLeoSettings.leo')
</t>
<t tx="ekr.20181027151243.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1006

@language python
</t>
<t tx="ekr.20181102040815.1">files = [
    'test/unittest.leo',
]
for fn in files:
    path = g.os_path_finalize_join(g.app.loadDir, '..', fn)
    assert g.os_path_exists(path), repr(path)
    with open(path, 'r') as f:
        s = f.read()
        for line in g.splitLines(s):
            if len(line) &gt; 150:
                print(line)</t>
<t tx="ekr.20190108052043.1">def findFilesToWrite(self, force):
    '''
    Return a list of files to write.
    We must do this in a prepass, so as to avoid errors later.
    '''
    c = self.c
    if force:
        # The Write @&lt;file&gt; Nodes command.
        # Write all nodes in the selected tree.
        root = c.p
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        root = c.rootPosition()
        p = c.rootPosition()
        after = None
    seen = set()
    files = []
    while p and p != after:
        if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            # Note: @ignore not honored in @asis nodes.
            p.moveToNodeAfterTree() # 2011/10/08: Honor @ignore!
        elif p.isAnyAtFileNode():
            data = p.v, g.fullPath(c, p)
            if data not in seen:
                seen.add(data)
                files.append(p.copy())
            p.moveToThreadNext()
                #525: Scan for nested @&lt;file&gt; nodes
        else:
            p.moveToThreadNext()
    if not force:
        files = [z for z in files if z.isDirty()]
    return files, root
</t>
<t tx="ekr.20190108053115.1">def internalWriteError(self, p):
    '''
    Fix bug 1260415: https://bugs.launchpad.net/leo-editor/+bug/1260415
    Give a more urgent, more specific, more helpful message.
    '''
    g.es_exception()
    g.es('Internal error writing: %s' % (p.h), color='red')
    g.es('Please report this error to:', color='blue')
    g.es('https://groups.google.com/forum/#!forum/leo-editor', color='blue')
    g.es('Warning: changes to this file will be lost', color='red')
    g.es('unless you can save the file successfully.', color='red')
</t>
<t tx="ekr.20190108054317.1">def findFilesToRead(self, force, root):

    c = self.c
    p = root.copy()
    scanned_tnodes = set()
    files = []
    after = p.nodeAfterTree() if force else None
    while p and p != after:
        data = (p.gnx, g.fullPath(c, p))
        # skip clones referring to exactly the same paths.
        if data in scanned_tnodes:
            p.moveToNodeAfterTree()
            continue
        scanned_tnodes.add(data)
        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            if p.isAnyAtFileNode():
                c.ignored_at_file_nodes.append(p.h)
            p.moveToNodeAfterTree()
        elif (
            p.isAtThinFileNode() or
            p.isAtAutoNode() or
            p.isAtEditNode() or
            p.isAtShadowFileNode() or
            p.isAtFileNode()
        ):
            files.append(p.copy())
            p.moveToNodeAfterTree()
        elif p.isAtAsisFileNode() or p.isAtNoSentFileNode():
            # Note (see #1081): @asis and @nosent can *not* be updated automatically.
            # Doing so using refresh-from-disk will delete all child nodes.
            p.moveToNodeAfterTree()
        elif p.isAtCleanNode():
            files.append(p.copy())
            p.moveToThreadNext()
                # #525: Nested nodes.
        else:
            p.moveToThreadNext()
    return files
</t>
<t tx="ekr.20190108054803.1">def readFileAtPosition(self, force, p):
    '''Read the @&lt;file&gt; node at p.'''
    at, c, fileName = self, self.c, p.anyAtFileNodeName()
    if p.isAtThinFileNode() or p.isAtFileNode():
        at.read(p, force=force)
    elif p.isAtAutoNode():
        at.readOneAtAutoNode(fileName, p)
    elif p.isAtEditNode():
        at.readOneAtEditNode(fileName, p)
    elif p.isAtShadowFileNode():
        at.readOneAtShadowNode(fileName, p)
    elif p.isAtAsisFileNode() or p.isAtNoSentFileNode():
        at.rememberReadPath(g.fullPath(c, p), p)
    elif p.isAtCleanNode():
        at.readOneAtCleanNode(p)
</t>
<t tx="ekr.20190108105509.1">def writePathChanged(self, p):
    '''
    Return True if the path has changed and the user allows it.
    raise IOError if the user forbids the write.
    Return False if the path has not changed.
    '''
    at, c = self, self.c
    if p.isAtIgnoreNode() and not p.isAtAsisFileNode():
        return False
    oldPath = g.os_path_normcase(at.getPathUa(p))
    newPath = g.os_path_normcase(g.fullPath(c, p))
    pathChanged = oldPath and oldPath != newPath
    # 2010/01/27: suppress this message during save-as and save-to commands.
    if pathChanged and not c.ignoreChangedPaths:
        ok = at.promptForDangerousWrite(
            fileName=None,
            kind=None,
            message='%s\n%s' % (
                g.tr('path changed for %s' % (p.h)),
                g.tr('write this file anyway?')))
        if not ok:
            raise IOError
        at.setPathUa(p, newPath) # Remember that we have changed paths.
    return pathChanged
</t>
<t tx="ekr.20190108112519.1">def reportEndOfWrite(self, files, all, dirty):
    
    at, c = self, self.c
    if g.unitTesting:
        return
    if files:
        report = c.config.getBool('report-unchanged-files', default=True)
        if report:
            g.es("finished")
        elif at.sameFiles:
            g.es('finished. %s unchanged files' % at.sameFiles)
    elif all:
        g.warning("no @&lt;file&gt; nodes in the selected tree")
        # g.es("to write an unchanged @auto node,\nselect it directly.")
    elif dirty:
        g.es("no dirty @&lt;file&gt; nodes in the selected tree")
</t>
<t tx="ekr.20190109142026.1">def atFileToString(self, root, sentinels=True):
    '''Write an external file to a string, and return its contents.'''
    at, c = self, self.c
    try:
        c.endEditing()
        at.initWriteIvars(root, "&lt;string-file&gt;", sentinels=sentinels)
        at.openOutputStream()
        at.putFile(root, sentinels=sentinels)
        assert root == at.root, 'write'
        result = at.closeOutputStream()
        # Major bug: failure to clear this wipes out headlines!
        #            Sometimes this causes slight problems...
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
            root.v._p_changed = True
        return result
    except Exception:
        if hasattr(self.root.v, 'tnodeList'):
            delattr(self.root.v, 'tnodeList')
        at.exception("exception preprocessing script")
        root.v._p_changed = True
        return g.u('')
</t>
<t tx="ekr.20190109145850.1"># open/close methods used by top-level atFile.write logic.

def openOutputStream(self):
    '''Open the output stream, which a list, *not* a file-like object.'''
    at = self
    at.outputList = []
    # Can't be inited in initWriteIvars because not valid in @shadow logic.
    if g.app.unitTesting:
        at.output_newline = '\n'

def closeOutputStream(self):
    '''Close the output stream, returning its contents.'''
    at = self
    contents = g.u('') if at.errors else u''.join(at.outputList)
    at.outputList = []
    return contents
</t>
<t tx="ekr.20190109153627.13">def writeAtShadowNodesHelper(self, writeDirtyOnly=True): 
    """Write @shadow nodes in the selected outline"""
    at = self; c = at.c
    p = c.p; after = p.nodeAfterTree()
    found = False
    while p and p != after:
        if (
            p.atShadowFileNodeName() and not p.isAtIgnoreNode()
            and (p.isDirty() or not writeDirtyOnly)
        ):
            ok = at.writeOneAtShadowNode(p)
            if ok:
                found = True
                g.blue('wrote %s' % p.atShadowFileNodeName())
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @shadow nodes in the selected tree")
        else:
            g.es("no @shadow nodes in the selected tree")
    return found
</t>
<t tx="ekr.20190109160056.1">def atAsisToString(self, root):
    '''Write the @asis node to a string.'''
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAsisFileNodeName())
        at.openOutputStream()
        for p in root.self_and_subtree(copy=False):
            at.writeAsisNode(p)
        return at.closeOutputStream()
    except Exception:
        at.writeException(fileName, root)
        return g.u('')
</t>
<t tx="ekr.20190109160056.2">def atAutoToString(self, root):
    '''Write the root @auto node to a string, and return it.'''
    at, c = self, self.c
    try:
        c.endEditing()
        fileName = at.initWriteIvars(root, root.atAutoNodeName(), sentinels=False)
        return at.writeAtAutoContents(fileName, root) or g.u('')
    except Exception:
        at.writeException(fileName, root)
        return g.u('')
</t>
<t tx="ekr.20190109160056.3">def atEditToString(self, root):
    '''Write one @edit node.'''
    at, c = self, self.c
    try:
        c.endEditing()
        if root.hasChildren():
            g.error('@edit nodes must not have children')
            g.es('To save your work, convert @edit to @auto, @file or @clean')
            return False
        fileName = at.initWriteIvars(root, root.atEditNodeName(), atEdit=True, sentinels=False)
        contents = ''.join([
            s for s in g.splitLines(root.b)
                if at.directiveKind4(s, 0) == at.noDirective])
        return contents
    except Exception:
        at.writeException(fileName, root)
        return g.u('')
</t>
<t tx="ekr.20190109163934.24">def writeAtAutoNodesHelper(self, writeDirtyOnly=True):
    """Write @auto nodes in the selected outline"""
    at = self; c = at.c
    p = c.p; after = p.nodeAfterTree()
    found = False
    while p and p != after:
        if (
            p.isAtAutoNode() and not p.isAtIgnoreNode() and
            (p.isDirty() or not writeDirtyOnly)
        ):
            ok = at.writeOneAtAutoNode(p)
            if ok:
                found = True
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()
    if not g.unitTesting:
        if found:
            g.es("finished")
        elif writeDirtyOnly:
            g.es("no dirty @auto nodes in the selected tree")
        else:
            g.es("no @auto nodes in the selected tree")
</t>
<t tx="ekr.20190109172025.1">def writeAtAutoContents(self, fileName, root):
    '''Common helper for atAutoToString and writeOneAtAutoNode.'''
    at, c = self, self.c
    # Dispatch the proper writer.
    junk, ext = g.os_path_splitext(fileName)
    writer = at.dispatch(ext, root)
    if writer:
        at.openOutputStream()
        writer(root)
        return at.closeOutputStream()
    if root.isAtAutoRstNode():
        # An escape hatch: fall back to the theRst writer
        # if there is no rst writer plugin.
        outputFile = at.openOutputFile()
        ok = c.rstCommands.writeAtAutoFile(root, fileName, outputFile)
        return outputFile.close() if ok else None
    # leo 5.6: allow undefined section references in all @auto files.
    ivar = 'allow_undefined_refs'
    try:
        setattr(at, ivar, True)
        at.openOutputStream()
        at.putFile(root, sentinels=False)
        return at.closeOutputStream()
    except Exception:
        return None
    finally:
        if hasattr(at, ivar):
            delattr(at, ivar)
</t>
<t tx="ekr.20190111045822.1">def precheck(self, fileName, root):
    '''
    Check for dangerous writes.
    Return False if the user declines to do the write.
    '''
    at = self
    if not at.shouldPromptForDangerousWrite(fileName, root):
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    # Prompt if the write would overwrite the existing file.
    ok = self.promptForDangerousWrite(fileName, kind='@asis')
    if ok:
        # Fix bug 889175: Remember the full fileName.
        at.rememberReadPath(fileName, root)
        return True
    # Fix #1031: do not add @ignore here!
    g.es("not written:", fileName)
    return False
</t>
<t tx="ekr.20190111111608.1">def checkPath(self, fileName):
    '''Return True if we can write to the file's directory.'''
    at = self
    assert g.os_path_isabs(fileName), (repr(fileName), g.callers())
    directory = g.os_path_dirname(fileName)
    if not at.checkDirectory(directory):
        return False
    if g.os_path_exists(fileName):
        return at.isWritable(fileName)
    return True
</t>
<t tx="ekr.20190111112432.1">def checkDirectory(self, directory):
    '''Return True if directory exists or could be created.'''
    at, c = self, self.c
    assert directory, g.callers()
    if g.os_path_exists(directory):
        return at.isWritable(directory)
    try:
        g.makeAllNonExistentDirectories(directory, c=c)
        return True
    except Exception:
        g.es("exception creating path: %r" % (directory), color='red')
        g.es_exception()
        return False
</t>
<t tx="ekr.20190111112442.1">def isWritable(self, path):
    '''Return True if the path is writable.'''
    try:
        # os.access() may not exist on all platforms.
        ok = os.access(path, os.W_OK)
    except AttributeError:
        return True
    if not ok:
        g.es('read only:', repr(path), color='red')
    return ok
</t>
<t tx="ekr.20190111153506.1"></t>
<t tx="ekr.20190111153522.1"></t>
<t tx="ekr.20190111153551.1"></t>
<t tx="ekr.20190111172114.1">def replaceFile(self, contents, encoding, fileName, root, ignoreBlankLines=False):
    '''
    Write or create the given file from the contents.
    Return True if the original file was changed.
    '''
    at, c = self, self.c
    if root:
        root.clearDirty()
    #
    # Create the timestamp (only for messages).
    if c.config.getBool('log-show-save-time', default=False):
        format = c.config.getString('log-timestamp-format') or "%H:%M:%S"
        timestamp = time.strftime(format) + ' '
    else:
        timestamp = ''
    #
    # Adjust the contents.
    assert g.isUnicode(contents), g.callers()
    if at.output_newline != '\n':
        contents = contents.replace('\r', '').replace('\n', at.output_newline)
    #
    # If file does not exist, create it from the contents.
    fileName = g.os_path_realpath(fileName)
    sfn = g.shortFileName(fileName)
    if not g.os_path_exists(fileName):
        ok = g.writeFile(contents, encoding, fileName)
        if ok:
            c.setFileTimeStamp(fileName)
            if not g.unitTesting:
                g.es('%screated: %s' % (timestamp, fileName))
            if root:
                # Fix bug 889175: Remember the full fileName.
                at.rememberReadPath(fileName, root)
        else:
            at.addToOrphanList(root)
        # No original file to change. Return value tested by a unit test.
        at.checkPythonCode(contents, fileName, root)
        return False # No change to original file.
    #
    # Compare the old and new contents.
    old_contents = g.readFileIntoUnicodeString(fileName,
        encoding=at.encoding, silent=True)
    unchanged = (
        contents == old_contents or
        (not at.explicitLineEnding and at.compareIgnoringLineEndings(old_contents, contents)) or
        ignoreBlankLines and at.compareIgnoringBlankLines(old_contents, contents))
    if unchanged:
        at.sameFiles += 1
        if not g.unitTesting and c.config.getBool('report-unchanged-files', default=True):
            g.es('%sunchanged: %s' % (timestamp, sfn))
        # Leo 5.6: Check unchanged files.
        at.checkPythonCode(contents, fileName, root, pyflakes_errors_only=True)
        return False # No change to original file.
    #
    # Warn if we are only adjusting the line endings.
    if at.explicitLineEnding:
        ok = (
            at.compareIgnoringLineEndings(old_contents, contents) or
            ignoreBlankLines and at.compareIgnoringLineEndings(old_contents, contents))
        if not ok:
            g.warning("correcting line endings in:", fileName)
    #
    # Write a changed file.
    ok = g.writeFile(contents, encoding, fileName)
    if ok:
        c.setFileTimeStamp(fileName)
        if not g.unitTesting:
            g.es('%swrote: %s' % (timestamp, sfn))
    else:
        g.error('error writing', sfn)
        g.es('not written:', sfn)
        at.addToOrphanList(root)
    at.checkPythonCode(contents, fileName, root)
        # Check *after* writing the file.
    return ok
</t>
<t tx="ekr.20190113043601.1">def openOutputFile(self):
    '''Open the output file, which must be file-like'''
    at = self
    at.outputFile = g.FileLikeObject()
    # Can't be inited in initWriteIvars because not valid in @shadow logic.
    if g.app.unitTesting:
        at.output_newline = '\n'

def closeOutputFile(self):
    '''Close the output file, returning its contents.'''
    at = self
    at.outputFile.flush()
    contents = g.toUnicode('' if at.errors else at.outputFile.get())
    at.outputFile.close()
    at.outputFile = None
    return contents
</t>
<t tx="ekr.20190114061452.27">def compareIgnoringBlankLines(self, s1, s2):
    '''Compare two strings, ignoring blank lines.'''
    assert g.isUnicode(s1), g.callers()
    assert g.isUnicode(s2), g.callers()
    if s1 == s2:
        return True
    s1 = g.removeBlankLines(s1)
    s2 = g.removeBlankLines(s2)
    return s1 == s2
</t>
<t tx="ekr.20190114061452.28">def compareIgnoringLineEndings(self, s1, s2):
    '''Compare two strings, ignoring line endings.'''
    assert g.isUnicode(s1), g.callers()
    assert g.isUnicode(s2), g.callers()
    if s1 == s2:
        return True
    # Wrong: equivalent to ignoreBlankLines!
        # s1 = s1.replace('\n','').replace('\r','')
        # s2 = s2.replace('\n','').replace('\r','')
    s1 = s1.replace('\r', '')
    s2 = s2.replace('\r', '')
    return s1 == s2
</t>
<t tx="ekr.20190116145036.1"></t>
<t tx="ekr.20190116145049.1">@language rest
@wrap

*** Add *real* vim emulation to Leo.
    Use nvim-python: https://github.com/neovim/pynvim
*** Add *real* org mode emulation to Leo

@language python
</t>
<t tx="ekr.20190118082646.1">def compute_columns(self, block, cursor):
    
    c = self.c
    line = g.u(block.text())
    col = cursor.columnNumber()
    offset = c.p.textOffset()
    fcol_offset = 0
    s2 = line[0: col]
    col = g.computeWidth(s2, c.tab_width)
    #
    # Fix bug #195: fcol when using @first directive is inaccurate
    # https://github.com/leo-editor/leo-editor/issues/195
    i = line.find('&lt;&lt;')
    j = line.find('&gt;&gt;')
    if -1 &lt; i &lt; j or g.match_word(line.strip(), 0, '@others'):
        offset = None
    else:
        for tag in ('@first ', '@last '):
            if line.startswith(tag):
                fcol_offset = len(tag)
                break
    #
    # fcol is '' if there is no ancestor @&lt;file&gt; node.
    fcol = None if offset is None else max(0, col + offset - fcol_offset)
    return col, fcol
</t>
<t tx="ekr.20190118130950.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/981
https://github.com/leo-editor/leo-editor/issues/977

The only real change was to efc.open_with. It deletes temp files before reopening them.

@language python
@nosearch
</t>
<t tx="ekr.20190119062719.1"># for reference only.
# This can be deleted at any time.
</t>
<t tx="ekr.20190119085129.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1047

The following call FastRead().readFileFromClipboard:
    
- fc.getLeoOutlineFromClipBoard.
- fc.getLeoOutlineFromClipBoardRetainingClones.
- fc.getPos/VnodeFromClipboard.

@language python
</t>
<t tx="ekr.20190121135044.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/926

The change was to abbrev.init_tree_abbrev_helper.

@language python
</t>
<t tx="ekr.20190122113449.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1065

@language python
</t>
<t tx="ekr.20190122185223.1">@language text

Find all kwargs using regex:

^\s*(def\s+\w+\s*\(.*\=.*\))

found 1154 nodes

^\s*(def\s+\w+\s*\(.*\=.*\=.*\))

found 284 nodes
</t>
<t tx="ekr.20190201104956.1">def readOneAtAsisNode(self, fn, p):
    '''Read one @asis node. Used only by refresh-from-disk'''
    at, c = self, self.c
    at.default_directory = g.setDefaultDirectory(c, p, importing=True)
    fn = c.os_path_finalize_join(at.default_directory, fn)
    junk, ext = g.os_path_splitext(fn)
    # Remember the full fileName.
    at.rememberReadPath(fn, p)
    ### if not g.unitTesting: g.es("reading: @asis %s" % (g.shortFileName(fn)))
    s, e = g.readFileIntoString(fn, kind='@edit')
    if s is None: return
    encoding = 'utf-8' if e is None else e
    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()
    old_body = p.b
    p.b = g.toUnicode(s, encoding=encoding, reportErrors='True')
    if not c.isChanged() and p.b != old_body:
        c.setChanged(True)
</t>
<t tx="ekr.20190216104815.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/525

@language python
</t>
<t tx="ekr.20190217060648.1"></t>
<t tx="ekr.20190218044303.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1081

Added warning when @asis or @nosent files change outside of Leo.

@language python
</t>
<t tx="ekr.20190218055230.1">def warn(self, c, path, p):
    '''
    Warn that an @asis or @nosent node has been changed externally.
    
    There is *no way* to update the tree automatically.
    '''
    if g.unitTesting or c not in g.app.commanders():
        return
    if not p:
        g.trace('NO P')
        return
    g.app.gui.runAskOkDialog(
        c=c,
        message='\n'.join([
            '%s has changed outside Leo.\n' % g.splitLongFileName(path),
            'Leo can not update this file automatically.\n',
            'This file was created from %s.\n' % p.h,
            'Warning: refresh-from-disk will destroy all children.'
        ]),
        title='External file changed',
    )
</t>
<t tx="ekr.20190218061833.1"></t>
<t tx="ekr.20190218061842.1"></t>
<t tx="ekr.20190218071717.1">@language rest
@wrap
@nosearch

https://github.com/leo-editor/leo-editor/issues/1085

@language python
</t>
<t tx="ekr.20190218071807.1"></t>
<t tx="ekr.20190218071840.1"></t>
<t tx="ekr.20190218071916.1"></t>
<t tx="ekr.20190218071950.1"></t>
<t tx="ekr.20190218072351.1"></t>
<t tx="ekr.20190218072404.1"></t>
<t tx="ekr.20190218072450.1"></t>
<t tx="ekr.20190218072811.1"></t>
<t tx="ekr.20190218073025.1"></t>
<t tx="ekr.20190218073115.1"></t>
<t tx="ekr.20190218073221.1"></t>
<t tx="ekr.20190218073446.1"></t>
<t tx="ekr.20190218073511.1"></t>
<t tx="ekr.20190218122943.1"></t>
<t tx="ekr.20190218131849.1"></t>
<t tx="ekr.20190218145819.1"></t>
<t tx="ekr.20190218153315.1">@nosearch

# flattened, word, ignore-case, head, body

# found 61 nodes</t>
<t tx="ekr.20190218154421.1">@nosearch

# flattened, word, ignore-case, head, body

# found 50 nodes</t>
<t tx="ekr.20190218154507.1">@nosearch

# flattened, word, ignore-case, head, body

# found 8 nodes</t>
<t tx="ekr.20190218154520.1">@nosearch

# flattened, word, ignore-case, head, body

# found 3 nodes</t>
<t tx="ekr.20190218154532.1">@nosearch

# flattened, word, ignore-case, head, body

# found 7 nodes</t>
<t tx="ekr.20190218154614.1">@nosearch

# flattened, word, ignore-case, head, body

# found 7 nodes</t>
<t tx="ekr.20190218154718.1">@nosearch

# flattened, word, ignore-case, head, body

# found 5 nodes</t>
<t tx="ekr.20190218154841.1"></t>
<t tx="ekr.20190218174250.1"># These are **NOT** necessary.
# Many have been made in py3replace branch.</t>
<t tx="ekr.20190218235026.1">def ue(s, encoding):
    return s if isinstance(s, str) else str(s, encoding)
</t>
<t tx="ekr.20190219000246.1"></t>
<t tx="ekr.20190306072725.1">@language rest
@wrap

Added "repo_dir" kwarg to GitDiffController.__init__.

@language python
</t>
<t tx="ekr.20190306082736.1">@ignore
@nosearch
HEAD=402525ec2</t>
<t tx="ekr.20190306082736.10">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -1,7 +1,7 @@
-def __init__ (self, c):
+def __init__ (self, c, repo_dir=None):
     '''Ctor for the GitDiffController class.'''
     self.c = c
     self.file_node = None
     self.old_dir = g.os_path_abspath('.')
-    self.repo_dir = None
+    self.repo_dir = repo_dir
     self.root = None
@language python
</t>
<t tx="ekr.20190306082736.11">def __init__ (self, c):
    '''Ctor for the GitDiffController class.'''
    self.c = c
    self.file_node = None
    self.old_dir = g.os_path_abspath('.')
    self.repo_dir = None
    self.root = None
</t>
<t tx="ekr.20190306082736.2">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -510,12 +510,12 @@
     '''A class to do git diffs.'''
     #@+others
     #@+node:ekr.20170806094320.4: *3* gdc.__init__ &amp; helper
-    def __init__ (self, c):
+    def __init__ (self, c, repo_dir=None):
         '''Ctor for the GitDiffController class.'''
         self.c = c
         self.file_node = None
         self.old_dir = g.os_path_abspath('.')
-        self.repo_dir = None
+        self.repo_dir = repo_dir
         self.root = None
     #@+node:ekr.20180510095544.1: *3* gdc.Entries...
     #@+node:ekr.20180506064102.10: *4* gdc.diff_two_branches
@language python
</t>
<t tx="ekr.20190306082736.9"></t>
<t tx="ekr.20190306083111.1"></t>
<t tx="ekr.20190306083224.1"></t>
<t tx="ekr.20190306105229.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1032

@language python
</t>
<t tx="ekr.20190306142950.1">def get_files_in_directory(directory, kinds=None, recursive=True):
    '''
    Return a list of all files of the given file extensions in the directory.
    Default kinds: ['*.py'].
    '''
    files, sep = [], os.path.sep
    if not g.os.path.exists(directory):
        g.es_print('does not exist', directory)
        return files
    try:
        if kinds:
            kinds = [z if z.startswith('*') else '*'+z for z in kinds]
        else:
            kinds = ['*.py']
        if recursive:
            # Works for all versions of Python.
            import fnmatch
            for root, dirnames, filenames in os.walk(directory):
                for kind in kinds:
                    for filename in fnmatch.filter(filenames, kind):
                        files.append(os.path.join(root, filename))
        else:
            for kind in kinds:
                files.extend(glob.glob(directory + sep + kind))
        return list(set(sorted(files)))
    except Exception:
        g.es_exception()
        return []
</t>
<t tx="ekr.20190316153545.1">@language rest
@wrap

https://github.com/leo-editor/leo-editor/issues/1096

- Email to Almar Klein.

- Change title of main window.

- Create **pyzo shims** for menus, config.

- Make pyzo tool panes for outline, body panes, log pane &amp; sub-panes, and VR pane.

- Modify pyzo shutdown logic:
  g.app.forgetOpenFile(c.fileName(), force=True)

@language python
</t>
<t tx="ekr.20190317082435.1"># import os
# import time
# import leo.core.leoGlobals as g
# from leo.core.leoQt import QtCore, QtGui, QtWidgets

class LeoEmptySplashWidget(QtWidgets.QWidget):
    
    def __init__(self, parent, **kwargs):
        QtWidgets.QWidget.__init__(self, parent)

from pyzo.util import zon
from pyzo.util.zon import isidentifier
</t>
<t tx="ekr.20190317082603.1">'''Run the pyzo test outside of Leo'''
&lt;&lt; easy imports &gt;&gt;
&lt;&lt; class LeoEmptySplashWidget &gt;&gt;
&lt;&lt; class LeoPyzoConfig &gt;&gt;
&lt;&lt; pyzo imports &gt;&gt;
print('\n' + '='*10, 'after top-level imports')
@others
print('\n\n' + '='*10, 'after ALL imports')
if 1:
    app = QtWidgets.QApplication([])
    LeoMainWindow()
    app.exec_()
@path c:\test</t>
<t tx="ekr.20190317082603.10">from pyzo import translate
from pyzo.core import commandline
from pyzo.core.main import loadAppIcons, loadIcons, loadFonts, MainWindow
    # For __init__.
from pyzo.core.main import callLater
    # For _populate
    
from pyzo.core.splash import SplashWidget
    # The big one.

class LeoMainWindow(MainWindow):
    @others
</t>
<t tx="ekr.20190317082603.11">def __init__(self, parent=None, locale=None):
    
    print('LeoMainWindow.__init__: SplashWidget:', repr(SplashWidget))
    
    QtWidgets.QMainWindow.__init__(self, parent)
    
    self._closeflag = 0  # Used during closing/restarting

    # Init window title and application icon
    # Set title to something nice. On Ubuntu 12.10 this text is what
    # is being shown at the fancy title bar (since it's not properly
    # updated)
    self.setMainTitle()
    loadAppIcons()
    self.setWindowIcon(pyzo.icon)

    # Restore window geometry before drawing for the first time,
    # such that the window is in the right place
    self.resize(800, 600) # default size
    self.restoreGeometry()

    # Show splash screen (we need to set our color too)
    w = SplashWidget(self, distro='no distro')
    self.setCentralWidget(w)
    self.setStyleSheet("QMainWindow { background-color: #268bd2;}")

    # Show empty window and disable updates for a while
    self.show()
    self.paintNow()
    self.setUpdatesEnabled(False)

    # Determine timeout for showing splash screen
    splash_timeout = time.time() + 1.0

    # Set locale of main widget, so that qt strings are translated
    # in the right way
    if locale:
        self.setLocale(locale)

    # Store myself
    pyzo.main = self

    # Init dockwidget settings
    self.setTabPosition(QtCore.Qt.AllDockWidgetAreas,QtWidgets.QTabWidget.South)
    self.setDockOptions(
            QtWidgets.QMainWindow.AllowNestedDocks |
            QtWidgets.QMainWindow.AllowTabbedDocks
            #|  QtWidgets.QMainWindow.AnimatedDocks
        )

    # Set window atrributes
    self.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips, True)

    # Load icons and fonts
    loadIcons()
    loadFonts()

    # Set qt style and test success
    self.setQtStyle(None) # None means init!
    
    if 0: ###
        # Hold the splash screen if needed
        while time.time() &lt; splash_timeout:
            QtWidgets.qApp.flush()
            QtWidgets.qApp.processEvents()
            time.sleep(0.05)

    # Populate the window (imports more code)
    self._populate()

    # Revert to normal background, and enable updates
    self.setStyleSheet('')
    self.setUpdatesEnabled(True)

    # Restore window state, force updating, and restore again
    self.restoreState()
    self.paintNow()
    self.restoreState()

    # Present user with wizard if he/she is new.
    if False:  # pyzo.config.state.newUser:
        from pyzo.util.pyzowizard import PyzoWizard
        w = PyzoWizard(self)
        w.show() # Use show() instead of exec_() so the user can interact with pyzo

    # Create new shell config if there is None
    if not pyzo.config.shellConfigs2:
        from pyzo.core.kernelbroker import KernelInfo
        pyzo.config.shellConfigs2.append( KernelInfo() )

    # EKR: Set background.
    if getattr(pyzo.config.settings, 'dark_theme', None):
        bg = getattr(pyzo.config.settings, 'dark_background', '#657b83')
            # Default: solarized base00
        try:
            self.setStyleSheet("background: %s" % bg) 
        except Exception:
            print('oops: MainWindow.__init__')

    # Focus on editor
    e = pyzo.editors.getCurrentEditor()
    if e is not None:
        e.setFocus()

    # Handle any actions
    commandline.handle_cmd_args()
</t>
<t tx="ekr.20190317082603.12">def _populate(self):
    
    print('----- LeoMainWindow._populate')

    # Delayed imports
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager

    # Instantiate tool manager
    pyzo.toolManager = ToolManager()

    # Check to install conda now ...
    #from pyzo.util.bootstrapconda import check_for_conda_env
    #check_for_conda_env()

    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()

    # Create editor stack and make the central widget
    pyzo.editors = EditorTabs(self)
    self.setCentralWidget(pyzo.editors)
        # EKR: QMainWindow.setCentralWidget

    # Create floater for shell
    self._shellDock = dock = QtWidgets.QDockWidget(self)
    if pyzo.config.settings.allowFloatingShell:
        dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
    else:
        dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
    dock.setWindowTitle('Shells')
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)

    # Create shell stack
    pyzo.shells = ShellStackWidget(self)
    dock.setWidget(pyzo.shells)

    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')

    # Create the default shell when returning to the event queue
    callLater(pyzo.shells.addShell)

    # Create statusbar
    if pyzo.config.view.showStatusbar:
        pyzo.status = self.statusBar()
    else:
        pyzo.status = None
        self.setStatusBar(None)

    # Create menu
    from pyzo.core import menu
    pyzo.keyMapper = menu.KeyMapper()
    menu.buildMenus(self.menuBar())

    # Add the context menu to the editor
    pyzo.editors.addContextMenu()
    pyzo.shells.addContextMenu()

    # Load tools
    if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
        pyzo.toolManager.loadTool('pyzosourcestructure')
        pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
    elif pyzo.config.state.loadedTools:
        for toolId in pyzo.config.state.loadedTools:
            pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190317082603.13">firstStyleSheet = True

def setStyleSheet(self, style, *args, **kwargs):
    print('LeoMainWindow.setStyleSheet', style, args, kwargs)
    # A hack: Ignore the first call.
    if self.firstStyleSheet:
        self.firstStyleSheet = False
        return
    QtWidgets.QMainWindow.setStyleSheet(self, style)
    
</t>
<t tx="ekr.20190317082603.14">def closeEvent(self, event):
    """ Override close event handler. """
    import sys
    t1 = time.clock()

    # Are we restaring?
    restarting = time.time() - self._closeflag &lt; 1.0

    # Save settings
    pyzo.saveConfig()
    pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    result = pyzo.editors.closeAll()
    if not result:
        self._closeflag = False
        event.ignore()
        return
    else:
        self._closeflag = True
        
    t2 = time.clock()

    # Proceed with closing shells
    pyzo.localKernelManager.terminateAll()
    for shell in pyzo.shells:
        shell._context.close()
        
    t3 = time.clock()

    # Close tools
    for toolname in pyzo.toolManager.getLoadedTools():
        tool = pyzo.toolManager.getTool(toolname)
        tool.close()
        
    t4 = time.clock()

    # Stop all threads (this should really only be daemon threads)
    import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass
                
    t5 = time.clock()

    if 1: # EKR
        print('===== MainWindow.closeEvent')
        print('stage 1:          %5.2f' % (t2-t1))
        print('stage 2: shells:  %5.2f' % (t3-t2))
        print('stage 3: tools:   %5.2f' % (t4-t3))
        print('stage 4: threads: %5.2f' % (t5-t4))

    # Proceed as normal
    QtWidgets.QMainWindow.closeEvent(self, event)

    # Harder exit to prevent segfault. Not really a solution,
    # but it does the job until Pyside gets fixed.
    if sys.version_info &gt;= (3,3,0) and not restarting:
        if hasattr(os, '_exit'):
            os._exit(0)
</t>
<t tx="ekr.20190317082603.2">import os
import time
import leo.core.leoGlobals as g
assert g
g.cls()
# print('='*10, 'sys.argv', sys.argv)
from leo.core.leoQt import QtCore, QtGui, QtWidgets
    # leoQt now patches QtCore.Signal, just like pyzo.qt does.
</t>
<t tx="ekr.20190317082603.3">class LeoEmptySplashWidget(QtWidgets.QWidget):
    
    def __init__(self, parent, **kwargs):
        QtWidgets.QWidget.__init__(self, parent)
</t>
<t tx="ekr.20190317082603.4">from pyzo.util import zon

from pyzo.util.zon import isidentifier

class LeoPyzoConfig(zon.Dict):
    @others
</t>
<t tx="ekr.20190317082603.5">def __repr__(self):
    identifier_items = []
    nonidentifier_items = []
    for key, val in self.items():
        if isidentifier(key):
            identifier_items.append('%s=%r' % (key, val))
        else:
            nonidentifier_items.append('(%r, %r)' % (key, val))
    if nonidentifier_items:
        return 'Dict([%s], %s)' % (', '.join(nonidentifier_items),
                                   ', '.join(identifier_items))
    else:
        return 'Dict(%s)' % (', '.join(identifier_items))
</t>
<t tx="ekr.20190317082603.6">def __getattribute__(self, key):
    try:
        ### return object.__getattribute__(self, key)
        val = object.__getattribute__(self, key)
        if False and key not in ('advanced', 'shortcuts2', 'settings'):
            # print('===== LeoPyzoConfig 1: %r: %r' % (key, val))
            print('===== LeoPyzoConfig 1: %r' % key)
        return val
    except AttributeError:
        if key in self:
            if False and key not in ('advanced', 'shortcuts2', 'settings'):
                # print('===== LeoPyzoConfig 1: %r: %r' % (key, g.truncate(self[key], 50)))
                print('===== LeoPyzoConfig 2: %r' % key)
            return self[key]
        else:
            raise
</t>
<t tx="ekr.20190317082603.7"># def __setattr__(self, key, val):
    # if key in Dict.__reserved_names__:
        # # Either let OrderedDict do its work, or disallow
        # if key not in Dict.__pure_names__:
            # return _dict.__setattr__(self, key, val)
        # else:
            # raise AttributeError('Reserved name, this key can only ' +
                                 # 'be set via ``d[%r] = X``' % key)
    # else:
        # # if isinstance(val, dict): val = Dict(val) -&gt; no, makes a copy!
        # self[key] = val
</t>
<t tx="ekr.20190317082603.8"># def __dir__(self):
    # names = [k for k in self.keys() if isidentifier(k)]
    # return Dict.__reserved_names__ + names
</t>
<t tx="ekr.20190317082603.9">#
# Use a do-nothing SplashWidget
import pyzo.core.splash
pyzo.core.splash.SplashWidget = LeoEmptySplashWidget
import pyzo
#
# Use a Leonine pyzo.config.
pyzo.config = LeoPyzoConfig()
from pyzo import loadConfig
loadConfig()
    # To be replaced by LeoPyzoConfig.loadConfig.
#
# Monkey patch EditorTabs.loadFile
from pyzo.core.editorTabs import EditorTabs
old_loadFile = EditorTabs.loadFile

def loadFile(self, filename, updateTabs=True):
    g.trace('new loadFile:', filename)
    if filename.endswith('leo'):
        print('new loadFile: ignore .leo file')
        return None
    return old_loadFile(self, filename, updateTabs)
    
g.funcToMethod(loadFile, EditorTabs)
#
# Do the other pyzo imports.
import pyzo.core.main
</t>
<t tx="ekr.20190317083529.1"></t>
<t tx="ekr.20190317084000.1">def createPyzoMainWindow(self):
    '''
    Create the component ivars of the main window.
    Copied/adapted from qt_main.py.
    Called instead of uic.loadUi(ui_description_file, self)
    '''
    # dw = self
    self.leo_ui = self
    self.richTextEdit = g.TracingNullObject(tag='dw.richTextEdit')
    self.stackedWidget = g.TracingNullObject(tag='dw.stackedWidget')
    self.treeWidget = g.TracingNullObject(tag='dw.treeWidget')
    self.tabWidget = g.TracingNullObject(tag='dw.tabWidet')
        ### 
    ### self.setMainWindowOptions()
    LeoPyzoMainWindow()
    ###
        # self.createCentralWidget()
        # main_splitter, secondary_splitter = self.createMainLayout(self.centralwidget)
            # # Creates .verticalLayout
        # if self.bigTree:
            # self.createBodyPane(secondary_splitter)
            # self.createLogPane(secondary_splitter)
            # treeFrame = self.createOutlinePane(main_splitter)
            # main_splitter.addWidget(treeFrame)
            # main_splitter.addWidget(secondary_splitter)
        # else:
            # self.createOutlinePane(secondary_splitter)
            # self.createLogPane(secondary_splitter)
            # self.createBodyPane(main_splitter)
        # self.createMiniBuffer(self.centralwidget)
        # self.createMenuBar()
        # self.createStatusBar(dw)
    # Signals
    ### QtCore.QMetaObject.connectSlotsByName(dw)
    ### return main_splitter, secondary_splitter
</t>
<t tx="ekr.20190317084039.1"></t>
<t tx="ekr.20190317084647.1">if g.pyzo:
    ### from pyzo import translate
    from pyzo.core import commandline
    from pyzo.core.main import loadAppIcons, loadIcons, loadFonts, MainWindow
        # For __init__.
    from pyzo.core.main import callLater
        # For _populate
        
    from pyzo.core.splash import SplashWidget
        # The big one.
    
    class LeoPyzoMainWindow(MainWindow):
        @others
</t>
<t tx="ekr.20190317084647.2">def __init__(self, parent=None, locale=None):
    
    print('LeoPyzoMainWindow.__init__:') # SplashWidget:', repr(SplashWidget))
    
    QtWidgets.QMainWindow.__init__(self, parent)
    
    self._closeflag = 0  # Used during closing/restarting

    # Init window title and application icon
    # Set title to something nice. On Ubuntu 12.10 this text is what
    # is being shown at the fancy title bar (since it's not properly
    # updated)
    self.setMainTitle()
    loadAppIcons()
    self.setWindowIcon(pyzo.icon)

    # Restore window geometry before drawing for the first time,
    # such that the window is in the right place
    self.resize(800, 600) # default size
    self.restoreGeometry()

    # Show splash screen (we need to set our color too)
    w = SplashWidget(self, distro='no distro')
    self.setCentralWidget(w)
    self.setStyleSheet("QMainWindow { background-color: #268bd2;}")

    # Show empty window and disable updates for a while
    self.show()
    self.paintNow()
    self.setUpdatesEnabled(False)

    # Determine timeout for showing splash screen
    splash_timeout = time.time() + 1.0

    # Set locale of main widget, so that qt strings are translated
    # in the right way
    if locale:
        self.setLocale(locale)

    # Store myself
    pyzo.main = self

    # Init dockwidget settings
    self.setTabPosition(QtCore.Qt.AllDockWidgetAreas,QtWidgets.QTabWidget.South)
    self.setDockOptions(
            QtWidgets.QMainWindow.AllowNestedDocks |
            QtWidgets.QMainWindow.AllowTabbedDocks
            #|  QtWidgets.QMainWindow.AnimatedDocks
        )

    # Set window atrributes
    self.setAttribute(QtCore.Qt.WA_AlwaysShowToolTips, True)

    # Load icons and fonts
    loadIcons()
    loadFonts()

    # Set qt style and test success
    self.setQtStyle(None) # None means init!
    
    if 0: ###
        # Hold the splash screen if needed
        while time.time() &lt; splash_timeout:
            QtWidgets.qApp.flush()
            QtWidgets.qApp.processEvents()
            time.sleep(0.05)

    # Populate the window (imports more code)
    self._populate()

    # Revert to normal background, and enable updates
    self.setStyleSheet('')
    self.setUpdatesEnabled(True)

    # Restore window state, force updating, and restore again
    self.restoreState()
    self.paintNow()
    self.restoreState()

    # Present user with wizard if he/she is new.
    if False:  # pyzo.config.state.newUser:
        from pyzo.util.pyzowizard import PyzoWizard
        w = PyzoWizard(self)
        w.show() # Use show() instead of exec_() so the user can interact with pyzo

    # Create new shell config if there is None
    if not pyzo.config.shellConfigs2:
        from pyzo.core.kernelbroker import KernelInfo
        pyzo.config.shellConfigs2.append( KernelInfo() )

    # EKR: Set background.
    if getattr(pyzo.config.settings, 'dark_theme', None):
        bg = getattr(pyzo.config.settings, 'dark_background', '#657b83')
            # Default: solarized base00
        try:
            self.setStyleSheet("background: %s" % bg) 
        except Exception:
            print('oops: MainWindow.__init__')

    # Focus on editor
    e = pyzo.editors.getCurrentEditor()
    if e is not None:
        e.setFocus()

    # Handle any actions
    commandline.handle_cmd_args()
</t>
<t tx="ekr.20190317084647.3">def _populate(self):
    
    print('----- LeoPyzoMainWindow._populate')

    # Delayed imports
    from pyzo.core.editorTabs import EditorTabs
    from pyzo.core.shellStack import ShellStackWidget
    from pyzo.core import codeparser
    from pyzo.core.history import CommandHistory
    from pyzo.tools import ToolManager

    # Instantiate tool manager
    pyzo.toolManager = ToolManager()

    # Check to install conda now ...
    #from pyzo.util.bootstrapconda import check_for_conda_env
    #check_for_conda_env()

    # Instantiate and start source-code parser
    if pyzo.parser is None:
        pyzo.parser = codeparser.Parser()
        pyzo.parser.start()

    # Create editor stack and make the central widget
    pyzo.editors = EditorTabs(self)
    self.setCentralWidget(pyzo.editors)
        # EKR: QMainWindow.setCentralWidget

    # Create floater for shell
    self._shellDock = dock = QtWidgets.QDockWidget(self)
    if pyzo.config.settings.allowFloatingShell:
        dock.setFeatures(dock.DockWidgetMovable | dock.DockWidgetFloatable)
    else:
        dock.setFeatures(dock.DockWidgetMovable)
    dock.setObjectName('shells')
    dock.setWindowTitle('Shells')
    self.addDockWidget(QtCore.Qt.RightDockWidgetArea, dock)

    # Create shell stack
    pyzo.shells = ShellStackWidget(self)
    dock.setWidget(pyzo.shells)

    # Initialize command history
    pyzo.command_history = CommandHistory('command_history.py')

    # Create the default shell when returning to the event queue
    callLater(pyzo.shells.addShell)

    # Create statusbar
    if pyzo.config.view.showStatusbar:
        pyzo.status = self.statusBar()
    else:
        pyzo.status = None
        self.setStatusBar(None)

    # Create menu
    from pyzo.core import menu
    pyzo.keyMapper = menu.KeyMapper()
    menu.buildMenus(self.menuBar())

    # Add the context menu to the editor
    pyzo.editors.addContextMenu()
    pyzo.shells.addContextMenu()

    # Load tools
    if pyzo.config.state.newUser and not pyzo.config.state.loadedTools:
        pyzo.toolManager.loadTool('pyzosourcestructure')
        pyzo.toolManager.loadTool('pyzofilebrowser', 'pyzosourcestructure')
    elif pyzo.config.state.loadedTools:
        for toolId in pyzo.config.state.loadedTools:
            pyzo.toolManager.loadTool(toolId)
</t>
<t tx="ekr.20190317084647.4">firstStyleSheet = True

def setStyleSheet(self, style, *args, **kwargs):
    # print('LeoPyzoMainWindow.setStyleSheet', style, args, kwargs)
    # A hack: Ignore the first call.
    if self.firstStyleSheet:
        self.firstStyleSheet = False
        return
    QtWidgets.QMainWindow.setStyleSheet(self, style)
</t>
<t tx="ekr.20190317084647.5">def closeEvent(self, event):
    """ Override close event handler. """
    import sys
    t1 = time.clock()

    # Are we restaring?
    restarting = time.time() - self._closeflag &lt; 1.0

    # Save settings
    pyzo.saveConfig()
    pyzo.command_history.save()

    # Stop command server
    commandline.stop_our_server()

    # Proceed with closing...
    result = pyzo.editors.closeAll()
    if not result:
        self._closeflag = False
        event.ignore()
        return
    else:
        self._closeflag = True
        
    t2 = time.clock()

    # Proceed with closing shells
    pyzo.localKernelManager.terminateAll()
    for shell in pyzo.shells:
        shell._context.close()
        
    t3 = time.clock()

    # Close tools
    for toolname in pyzo.toolManager.getLoadedTools():
        tool = pyzo.toolManager.getTool(toolname)
        tool.close()
        
    t4 = time.clock()

    # Stop all threads (this should really only be daemon threads)
    import threading
    for thread in threading.enumerate():
        if hasattr(thread, 'stop'):
            try:
                thread.stop(0.1)
            except Exception:
                pass
                
    t5 = time.clock()

    if 1: # EKR
        print('===== LeoPyzoMainWindow.closeEvent')
        print('stage 1:          %5.2f' % (t2-t1))
        print('stage 2: shells:  %5.2f' % (t3-t2))
        print('stage 3: tools:   %5.2f' % (t4-t3))
        print('stage 4: threads: %5.2f' % (t5-t4))

    # Proceed as normal
    QtWidgets.QMainWindow.closeEvent(self, event)

    # Harder exit to prevent segfault. Not really a solution,
    # but it does the job until Pyside gets fixed.
    if sys.version_info &gt;= (3,3,0) and not restarting:
        if hasattr(os, '_exit'):
            os._exit(0)
</t>
<t tx="ekr.20190319022339.1"></t>
<t tx="ekr.20190319024244.1">@language rest
@wrap

Leo starts up with only one main window. All changes marked with g.pyzo:

- DynamicWindow is an Object, not a QMainWindow.
- Disabled some code in dw.createPyzoWindow.
- Disabled dw.setMainWindowOptions.

The following changes are experimental:
- Set dw.leo_master to a g.TracingNullObject.
- Disabled c.frame.top logic.
- Disabled LeoQtFrame.deiconify
- Removed most code in TabbedFrameFactory.createFrame.

The various frame ratios will probably go away:
- Disabled the LeoQtFrame ratio and secondary_ratio properties.
- Disabled qtFrame.resizePanesToRatio.
- Disabled dw.setGeometry.

All of the free_layout plugin will probably go away:
- Disabled FreeLayoutController.get_top_splitter.
</t>
<t tx="ekr.20190319150024.1">@language rest

https://github.com/leo-editor/leo-editor/issues/568

First:
- c.config.getString('pygments-style-name', default='default')
- Use a callback to test whether a section ref is undefined.
  Generate Comment.Leo.SectionRef or Comment.Leo.UndefinedSectionRef.
  
- Allow lookups of Leo names in style files.

Improve mainloop:
- Use get_lexer_by_name to instantiate lexers.
  Test self.language.
- Add lexer dict.
- Remove hard imports.
- Detect @language x.

Difficult?: Ask pygments people?
- Create Leonine lexers dynamically. 
- Create Leonine styles dynamically.
  
Later:
- Add copyrights &amp; acknowledgements (in devel) for pyzo, yoton, npyscreen, Jupyter/qtconsole.

Maybe:
- Support legacy syntax-coloring settings?
  If not, clean the code: remove all/most init code.
- Change states when switching nodes?
  Probably not: the call to rehighlight probably clears everything.

Open Questions:
- Should the colorizer and highlighter code be unified?
  It won't be done in 5.8.  It *might* be done in 6.0
- Should the code be part of 5.8?
- What about legacy syntax-coloring settings?

@language python
@nosearch
</t>
<t tx="ekr.20190319150835.1">g.cls()
from pygments.lexers import PythonLexer
code = p.b # 'print "Hello World"'
for token in PythonLexer().get_tokens(code):
    kind, val = token
    print('%35r %r' % (kind, val))
</t>
<t tx="ekr.20190319151056.1"></t>
<t tx="ekr.20190319151826.1">class PygmentsColorizer(BaseColorizer):
    '''
    This class adapts pygments tokens to QSyntaxHighlighter.
    '''
    # This is c.frame.body.colorizer

    @others
</t>
<t tx="ekr.20190319151826.10">def configure_hard_tab_width(self):
    '''Set the width of a hard tab.
    The stated default is 40, but apparently it must be set explicitly.
    '''
    c, widget, wrapper = self.c, self.widget, self.wrapper
    # For some reason, the size is not accurate.
    if isinstance(widget, QtWidgets.QTextEdit):
        font = wrapper.widget.currentFont()
        info = QtGui.QFontInfo(font)
        size = info.pointSizeF()
        pixels_per_point = 1.0 # 0.9
        hard_tab_width = abs(int(pixels_per_point * size * c.tab_width))
        wrapper.widget.setTabStopWidth(hard_tab_width)
    else:
        # To do: configure the QScintilla widget.
        pass
</t>
<t tx="ekr.20190319151826.11">def configure_tags(self):
    '''Configure all tags.'''
    c = self.c
    wrapper = self.wrapper
    isQt = g.app.gui.guiName().startswith('qt')
    if wrapper and hasattr(wrapper, 'start_tag_configure'):
        wrapper.start_tag_configure()
    # Get the default body font.
    defaultBodyfont = self.fonts.get('default_body_font')
    if not defaultBodyfont:
        defaultBodyfont = c.config.getFontFromParams(
            "body_text_font_family", "body_text_font_size",
            "body_text_font_slant", "body_text_font_weight",
            c.config.defaultBodyFontSize)
        self.fonts['default_body_font'] = defaultBodyfont
    # Configure fonts.
    keys = list(self.default_font_dict.keys()); keys.sort()
    for key in keys:
        option_name = self.default_font_dict[key]
        # First, look for the language-specific setting, then the general setting.
        for name in ('%s_%s' % (self.language, option_name), (option_name)):
            font = self.fonts.get(name)
            if font:
                wrapper.tag_configure(key, font=font)
                break
            else:
                family = c.config.get(name + '_family', 'family')
                size = c.config.get(name + '_size', 'size')
                slant = c.config.get(name + '_slant', 'slant')
                weight = c.config.get(name + '_weight', 'weight')
                if family or slant or weight or size:
                    family = family or g.app.config.defaultFontFamily
                    size = size or c.config.defaultBodyFontSize
                    slant = slant or 'roman'
                    weight = weight or 'normal'
                    font = g.app.gui.getFontFromParams(family, size, slant, weight)
                    # Save a reference to the font so it 'sticks'.
                    self.fonts[key] = font
                    wrapper.tag_configure(key, font=font)
                    break
        else: # Neither the general setting nor the language-specific setting exists.
            if list(self.fonts.keys()): # Restore the default font.
                self.fonts[key] = font # Essential
                wrapper.tag_configure(key, font=defaultBodyfont)
        if isQt and key == 'url' and font:
            font.setUnderline(True)
    keys = sorted(self.default_colors_dict.keys())
    for name in keys:
        option_name, default_color = self.default_colors_dict[name]
        color = (
            c.config.getColor('%s_%s' % (self.language, option_name)) or
            c.config.getColor(option_name) or
            default_color)
        # Must use foreground, not fg.
        try:
            wrapper.tag_configure(name, foreground=color)
        except Exception: # Recover after a user error.
            g.es_exception()
            wrapper.tag_configure(name, foreground=default_color)
    ### g.printObj(wrapper.configDict, tag='configDict')
    # underline=var doesn't seem to work.
    if 0: # self.use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
        wrapper.tag_configure("link", underline=1) # defined
        wrapper.tag_configure("name", underline=0) # undefined
    else:
        wrapper.tag_configure("link", underline=0)
        if self.underline_undefined:
            wrapper.tag_configure("name", underline=1)
        else:
            wrapper.tag_configure("name", underline=0)
    self.configure_variable_tags()
    try:
        wrapper.end_tag_configure()
    except AttributeError:
        pass
</t>
<t tx="ekr.20190319151826.12">def configure_variable_tags(self):
    c = self.c
    wrapper = self.wrapper
    for name, option_name, default_color in (
        # ("blank", "show_invisibles_space_background_color", "Gray90"),
        # ("tab", "show_invisibles_tab_background_color", "Gray80"),
        ("elide", None, "yellow"),
    ):
        if self.showInvisibles:
            color = c.config.getColor(option_name) if option_name else default_color
        else:
            option_name, default_color = self.default_colors_dict.get(name, (None, None),)
            color = c.config.getColor(option_name) if option_name else ''
        try:
            wrapper.tag_configure(name, background=color)
        except Exception: # A user error.
            wrapper.tag_configure(name, background=default_color)
    # Special case:
    if not self.showInvisibles:
        wrapper.tag_configure("elide", elide="1")
</t>
<t tx="ekr.20190319151826.13">def init(self, p):
    '''Init the colorizer, but *not* state. p is for tracing only.'''
    #
    # These *must* be recomputed.
    self.initialStateNumber = self.setInitialStateNumber()
    #
    # Fix #389. Do *not* change these.
        # self.nextState = 1 # Dont use 0.
        # self.stateDict = {}
        # self.stateNameDict = {}
        # self.restartDict = {}
    self.init_mode(self.language)
    self.clearState()
    # Used by matchers.
    self.prev = None
    # Must be done to support per-language @font/@color settings.
    self.configure_tags()
    self.configure_hard_tab_width() # 2011/10/04
</t>
<t tx="ekr.20190319151826.14">def init_all_state(self, v):
    '''Completely init all state data.'''
    assert self.language, g.callers(8)
    self.old_v = v
    self.n2languageDict = {-1: self.language}
    self.nextState = 1 # Dont use 0.
    self.restartDict = {}
    self.stateDict = {}
    self.stateNameDict = {}
</t>
<t tx="ekr.20190319151826.15">def init_mode(self, name):
    '''Name may be a language name or a delegate name.'''
    if not name:
        return False
    language, rulesetName = self.nameToRulesetName(name)
    bunch = self.modes.get(rulesetName)
    if bunch:
        if bunch.language == 'unknown-language':
            return False
        else:
            self.initModeFromBunch(bunch)
            self.language = language # 2011/05/30
            return True
    else:
        # Bug fix: 2008/2/10: Don't try to import a non-existent language.
        path = g.os_path_join(g.app.loadDir, '..', 'modes')
        fn = g.os_path_join(path, '%s.py' % (language))
        if g.os_path_exists(fn):
            mode = g.importFromPath(moduleName=language, path=path)
        else:
            mode = None
        return self.init_mode_from_module(name, mode)
</t>
<t tx="ekr.20190319151826.16">def init_mode_from_module(self, name, mode):
    '''Name may be a language name or a delegate name.
       Mode is a python module or class containing all
       coloring rule attributes for the mode.
    '''
    language, rulesetName = self.nameToRulesetName(name)
    if mode:
        # A hack to give modes/forth.py access to c.
        if hasattr(mode, 'pre_init_mode'):
            mode.pre_init_mode(self.c)
    else:
        # Create a dummy bunch to limit recursion.
        self.modes[rulesetName] = self.modeBunch = g.Bunch(
            attributesDict={},
            defaultColor=None,
            keywordsDict={},
            language='unknown-language',
            mode=mode,
            properties={},
            rulesDict={},
            rulesetName=rulesetName,
            word_chars=self.word_chars, # 2011/05/21
        )
        self.rulesetName = rulesetName
        self.language = 'unknown-language'
        return False
    self.language = language
    self.rulesetName = rulesetName
    self.properties = getattr(mode, 'properties', None) or {}
    self.keywordsDict = mode.keywordsDictDict.get(rulesetName, {}) if hasattr(mode, 'keywordsDictDict') else {}
    self.setKeywords()
    self.attributesDict = mode.attributesDictDict.get(rulesetName) if hasattr(mode, 'attributesDictDict') else {}
    self.setModeAttributes()
    self.rulesDict = mode.rulesDictDict.get(rulesetName) if hasattr(mode, 'rulesDictDict') else {}
    ### self.addLeoRules(self.rulesDict)
    self.defaultColor = 'null'
    self.mode = mode
    self.modes[rulesetName] = self.modeBunch = g.Bunch(
        attributesDict=self.attributesDict,
        defaultColor=self.defaultColor,
        keywordsDict=self.keywordsDict,
        language = self.language,
        mode=self.mode,
        properties=self.properties,
        rulesDict=self.rulesDict,
        rulesetName=self.rulesetName,
        word_chars=self.word_chars, # 2011/05/21
    )
    # Do this after 'officially' initing the mode, to limit recursion.
    ### self.addImportedRules(mode, self.rulesDict, rulesetName)
    self.updateDelimsTables()
    self.language = language
    
    ###
        # initialDelegate = self.properties.get('initialModeDelegate')
        # if initialDelegate:
            # # Replace the original mode by the delegate mode.
            # self.init_mode(initialDelegate)
            # language2, rulesetName2 = self.nameToRulesetName(initialDelegate)
            # self.modes[rulesetName] = self.modes.get(rulesetName2)
            # self.language = language2 # 2017/01/31
        # else:
            # self.language = language # 2017/01/31
    return True
</t>
<t tx="ekr.20190319151826.17">def nameToRulesetName(self, name):
    '''
    Compute language and rulesetName from name, which is either a language
    name or a delegate name.
    '''
    if not name:
        return ''
    i = name.find('::')
    if i == -1:
        language = name
        # New in Leo 5.0: allow delegated language names.
        language = g.app.delegate_language_dict.get(language, language)
        rulesetName = '%s_main' % (language)
    else:
        language = name[: i]
        delegate = name[i + 2:]
        rulesetName = self.munge('%s_%s' % (language, delegate))
    return language, rulesetName
</t>
<t tx="ekr.20190319151826.18">def setKeywords(self):
    '''Initialize the keywords for the present language.

     Set self.word_chars ivar to string.letters + string.digits
     plus any other character appearing in any keyword.
     '''
    # Add any new user keywords to leoKeywordsDict.
    d = self.keywordsDict
    keys = list(d.keys())
    for s in g.globalDirectiveList:
        key = '@' + s
        if key not in keys:
            d[key] = 'leokeyword'
    # Create a temporary chars list.  It will be converted to a dict later.
    chars = [g.toUnicode(ch) for ch in (string.ascii_letters + string.digits)]
    for key in list(d.keys()):
        for ch in key:
            if ch not in chars:
                chars.append(g.toUnicode(ch))
    # jEdit2Py now does this check, so this isn't really needed.
    # But it is needed for forth.py.
    for ch in (' ', '\t'):
        if ch in chars:
            # g.es_print('removing %s from word_chars' % (repr(ch)))
            chars.remove(ch)
    # Convert chars to a dict for faster access.
    self.word_chars = {}
    for z in chars:
        self.word_chars[z] = z
</t>
<t tx="ekr.20190319151826.19">def setModeAttributes(self):
    '''Set the ivars from self.attributesDict,
    converting 'true'/'false' to True and False.'''
    d = self.attributesDict
    aList = (
        ('default', 'null'),
        ('digit_re', ''),
        ('escape', ''), # New in Leo 4.4.2.
        ('highlight_digits', True),
        ('ignore_case', True),
        ('no_word_sep', ''),
    )
    for key, default in aList:
        val = d.get(key, default)
        if val in ('true', 'True'): val = True
        if val in ('false', 'False'): val = False
        setattr(self, key, val)
</t>
<t tx="ekr.20190319151826.2"></t>
<t tx="ekr.20190319151826.20">def initModeFromBunch(self, bunch):
    self.modeBunch = bunch
    self.attributesDict = bunch.attributesDict
    self.setModeAttributes()
    self.defaultColor = bunch.defaultColor
    self.keywordsDict = bunch.keywordsDict
    self.language = bunch.language
    self.mode = bunch.mode
    self.properties = bunch.properties
    self.rulesDict = bunch.rulesDict
    self.rulesetName = bunch.rulesetName
    self.word_chars = bunch.word_chars # 2011/05/21
</t>
<t tx="ekr.20190319151826.21">def updateDelimsTables(self):
    '''Update g.app.language_delims_dict if no entry for the language exists.'''
    d = self.properties
    lineComment = d.get('lineComment')
    startComment = d.get('commentStart')
    endComment = d.get('commentEnd')
    if lineComment and startComment and endComment:
        delims = '%s %s %s' % (lineComment, startComment, endComment)
    elif startComment and endComment:
        delims = '%s %s' % (startComment, endComment)
    elif lineComment:
        delims = '%s' % lineComment
    else:
        delims = None
    if delims:
        d = g.app.language_delims_dict
        if not d.get(self.language):
            d[self.language] = delims
</t>
<t tx="ekr.20190319151826.22">def munge(self, s):
    '''Munge a mode name so that it is a valid python id.'''
    valid = string.ascii_letters + string.digits + '_'
    return ''.join([ch.lower() if ch in valid else '_' for ch in s])
</t>
<t tx="ekr.20190319151826.23"></t>
<t tx="ekr.20190319151826.24">@nocolor-node
@

The following jEdit matcher methods return the length of the matched text if the
match succeeds, and zero otherwise. In most cases, these methods colorize all
the matched text.

The following arguments affect matching:

- at_line_start         True: sequence must start the line.
- at_whitespace_end     True: sequence must be first non-whitespace text of the line.
- at_word_start         True: sequence must start a word.
- hash_char             The first character that must match in a regular expression.
- no_escape:            True: ignore an 'end' string if it is preceded by
                        the ruleset's escape character.
- no_line_break         True: the match will not succeed across line breaks.
- no_word_break:        True: the match will not cross word breaks.

The following arguments affect coloring when a match succeeds:

- delegate              A ruleset name. The matched text will be colored recursively
                        by the indicated ruleset.
- exclude_match         If True, the actual text that matched will not be colored.
- kind                  The color tag to be applied to colored text.
</t>
<t tx="ekr.20190319151826.25">def dump(self, s):
    if s.find('\n') == -1:
        return s
    else:
        return '\n' + s + '\n'
</t>
<t tx="ekr.20190319151826.26"></t>
<t tx="ekr.20190319151826.27">def match_at_color(self, s, i):
    if self.trace_leo_matches:
        g.trace()
    # Only matches at start of line.
    if i == 0 and g.match_word(s, 0, '@color'):
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enable coloring of *this* line.
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
            # Now required. Sets state.
        return len('@color')
    else:
        return 0
</t>
<t tx="ekr.20190319151826.28">def restartColor(self, s):
    '''Change all lines up to the next color directive.'''
    if g.match_word(s, 0, '@killcolor'):
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
        self.setRestart(self.restartKillColor)
        return -len(s) # Continue to suppress coloring.
    elif g.match_word(s, 0, '@nocolor-node'):
        self.setRestart(self.restartNoColorNode)
        return -len(s) # Continue to suppress coloring.
    elif g.match_word(s, 0, '@nocolor'):
        self.setRestart(self.restartNoColor)
        return -len(s) # Continue to suppress coloring.
    else:
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enables coloring of *this* line.
        return 0 # Allow colorizing!
</t>
<t tx="ekr.20190319151826.29">def match_at_killcolor(self, s, i):

    # Only matches at start of line.
    if i == 0 and g.match_word(s, i, '@killcolor'):
        self.setRestart(self.restartKillColor)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20190319151826.3">def __init__(self, c, widget, wrapper):
    '''Ctor for JEditColorizer class.'''
    BaseColorizer.__init__(self,c)
    self.widget = widget
    self.wrapper = wrapper
    # This assert is not true when using multiple body editors
        # assert(wrapper == self.c.frame.body.wrapper)
    self.enabled = True
        # Per-node enable/disable flag.
        # Set by updateSyntaxColorer, used by jEdit colorizer.
    self.full_recolor_count = 0 # For unit testing.
    self.language = 'python' # set by scanLanguageDirectives.
    self.showInvisibles = False
    # Step 2: create the highlighter.
    if isinstance(widget, QtWidgets.QTextEdit):
        self.highlighter = LeoHighlighter(c,
            colorizer = self,
            document = widget.document(),
        )
    else:
        self.highlighter = None
    if widget:
        # #503: widget may be None during unit tests.
        widget.leo_colorizer = self
    # State data used by recolor and helpers...
    # init() properly sets these for each language.
    self.actualColorDict = {} # Used only by setTag.
    self.hyperCount = 0
    # State dicts, etc.
    self.after_doc_language = None
    self.initialStateNumber = -1
    self.old_v = None
    self.nextState = 1 # Dont use 0.
    self.n2languageDict = {-1: c.target_language}
    self.restartDict = {} # Keys are state numbers, values are restart functions.
    self.stateDict = {} # Keys are state numbers, values state names.
    self.stateNameDict = {} # Keys are state names, values are state numbers.
    # Attributes dict ivars: defaults are as shown...
    self.default = 'null'
    self.digit_re = ''
    self.escape = ''
    self.highlight_digits = True
    self.ignore_case = True
    self.no_word_sep = ''
    # Debugging...
    self.allow_mark_prev = True
    self.n_setTag = 0
    self.tagCount = 0
    self.trace_leo_matches = False
    self.trace_match_flag = False
    # Profiling...
    self.recolorCount = 0 # Total calls to recolor
    self.stateCount = 0 # Total calls to setCurrentState
    self.totalStates = 0
    self.maxStateNumber = 0
    self.totalKeywordsCalls = 0
    self.totalLeoKeywordsCalls = 0
    # Mode data...
    self.defaultRulesList = []
    self.importedRulesets = {}
    self.initLanguage = None
    self.prev = None # The previous token.
    self.fonts = {} # Keys are config names.  Values are actual fonts.
    self.keywords = {} # Keys are keywords, values are 0..5.
        # Keys are state ints, values are language names.
    self.modes = {} # Keys are languages, values are modes.
    self.mode = None # The mode object for the present language.
    self.modeBunch = None # A bunch fully describing a mode.
    self.modeStack = []
    self.rulesDict = {}
    # self.defineAndExtendForthWords()
    self.word_chars = {} # Inited by init_keywords().
    self.tags = [
        # 8 Leo-specific tags.
        "blank", # show_invisibles_space_color
        "docpart",
        "leokeyword",
        "link",
        "name",
        "namebrackets",
        "tab", # show_invisibles_space_color
        "url",
        # jEdit tags.
        'comment1', 'comment2', 'comment3', 'comment4',
        # default, # exists, but never generated.
        'function',
        'keyword1', 'keyword2', 'keyword3', 'keyword4',
        'label', 'literal1', 'literal2', 'literal3', 'literal4',
        'markup', 'operator',
        'trailing_whitespace',
    ]
    self.reloadSettings()
    self.defineLeoKeywordsDict()
    self.defineDefaultColorsDict()
    self.defineDefaultFontDict()
</t>
<t tx="ekr.20190319151826.30">def restartKillColor(self, s):
    self.setRestart(self.restartKillColor)
    return len(s) + 1
</t>
<t tx="ekr.20190319151826.31">def match_at_language(self, s, i):
    '''Match Leo's @language directive.'''
    # Only matches at start of line.
    if i != 0: return 0
    if g.match_word(s, i, '@language'):
        old_name = self.language
        j = g.skip_ws(s, i + len('@language'))
        k = g.skip_c_id(s, j)
        name = s[j: k]
        ok = self.init_mode(name)
        if ok:
            self.colorRangeWithTag(s, i, k, 'leokeyword')
            if name != old_name:
                # Solves the recoloring problem!
                n = self.setInitialStateNumber()
                self.setState(n)
        return k - i
    else:
        return 0
</t>
<t tx="ekr.20190319151826.32">def match_at_nocolor(self, s, i):

    if self.trace_leo_matches:
        g.trace(i, repr(s))
    # Only matches at start of line.
    if i == 0 and not g.match(s, i, '@nocolor-') and g.match_word(s, i, '@nocolor'):
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20190319151826.33">def restartNoColor(self, s):
    if self.trace_leo_matches:
        g.trace(repr(s))
    if g.match_word(s, 0, '@color'):
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enables coloring of *this* line.
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
        return len('@color')
    else:
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
</t>
<t tx="ekr.20190319151826.34">def match_at_nocolor_node(self, s, i):

    # Only matches at start of line.
    if i == 0 and g.match_word(s, i, '@nocolor-node'):
        self.setRestart(self.restartNoColorNode)
        return len(s) # Match everything.
    else:
        return 0
</t>
<t tx="ekr.20190319151826.35">def restartNoColorNode(self, s):
    self.setRestart(self.restartNoColorNode)
    return len(s) + 1
</t>
<t tx="ekr.20190319151826.36">def match_at_wrap(self, s, i):
    '''Match Leo's @wrap directive.'''
    c = self.c
    # Only matches at start of line.
    seq = '@wrap'
    if i == 0 and g.match_word(s, i, seq):
        j = i + len(seq)
        k = g.skip_ws(s, j)
        self.colorRangeWithTag(s, i, k, 'leokeyword')
        c.frame.setWrap(c.p, force=True)
        return k - i
    else:
        return 0
</t>
<t tx="ekr.20190319151826.37">def match_blanks(self, s, i):
    if 1: # Use Qt code to show invisibles.
        return 0
    else: # Old code...
        if not self.showInvisibles:
            return 0
        j = i; n = len(s)
        while j &lt; n and s[j] == ' ':
            j += 1
        if j &gt; i:
            self.colorRangeWithTag(s, i, j, 'blank')
            return j - i
        else:
            return 0
</t>
<t tx="ekr.20190319151826.38">def match_doc_part(self, s, i):
    '''
    Colorize Leo's @ and @ doc constructs.
    Matches only at the start of the line.
    '''
    if i != 0:
        return 0
    elif g.match_word(s, i, '@doc'):
        j = i + 4
    elif g.match(s, i, '@') and (i + 1 &gt;= len(s) or s[i + 1] in (' ', '\t', '\n')):
        j = i + 1
    else:
        return 0
    c = self.c
    self.colorRangeWithTag(s, 0, j, 'leokeyword')
    # New in Leo 5.5: optionally colorize doc parts using reStructuredText
    if c.config.getBool('color-doc-parts-as-rest'):
        # Switch langauges.
        self.after_doc_language = self.language
        self.language = 'rest'
        self.clearState()
        self.init(c.p)
        # Restart.
        self.setRestart(self.restartDocPart)
        # Do *not* color the text here!
        return j
    else:
        self.clearState()
        self.setRestart(self.restartDocPart)
        self.colorRangeWithTag(s, j, len(s), 'docpart')
        return len(s)
</t>
<t tx="ekr.20190319151826.39">def restartDocPart(self, s):
    '''
    Restarter for @ and @ contructs.
    Continue until an @c, @code or @language at the start of the line.
    '''
    for tag in ('@c', '@code', '@language'):
        if g.match_word(s, 0, tag):
            if tag == '@language':
                return self.match_at_language(s, 0)
            else:
                j = len(tag)
                self.colorRangeWithTag(s, 0, j, 'leokeyword') # 'docpart')
                # Switch languages.
                self.language = self.after_doc_language
                self.clearState()
                self.init(self.c.p)
                self.after_doc_language = None
                return j
    # Color the next line.
    self.setRestart(self.restartDocPart)
    if self.c.config.getBool('color-doc-parts-as-rest'):
        # Do *not* colorize the text here.
        return 0
    else:
        self.colorRangeWithTag(s, 0, len(s), 'docpart')
        return len(s)
</t>
<t tx="ekr.20190319151826.4">def defineLeoKeywordsDict(self):
    self.leoKeywordsDict = {}
    for key in g.globalDirectiveList:
        self.leoKeywordsDict[key] = 'leokeyword'
</t>
<t tx="ekr.20190319151826.40">image_url = re.compile(r'^\s*&lt;\s*img\s+.*src=\"(.*)\".*&gt;\s*$')

def match_image(self, s, i):
    '''Matcher for &lt;img...&gt;'''
    m = self.image_url.match(s,i)
    if m:
        self.image_src = src = m.group(1)
        j = len(src)
        doc = self.highlighter.document()
        block_n = self.currentBlockNumber()
        text_block = doc.findBlockByNumber(block_n)
        g.trace('block_n: %2s %s' % (block_n, repr(s)))
        g.trace('block text: %s' % repr(text_block.text()))
            # How to get the cursor of the colorized line.
                # body = self.c.frame.body
                # s = body.wrapper.getAllText()
                # wrapper.delete(0, j)
                # cursor.insertHtml(src)
        return j
    else:
        return 0
</t>
<t tx="ekr.20190319151826.41">def match_leo_keywords(self, s, i):
    '''Succeed if s[i:] is a Leo keyword.'''
    self.totalLeoKeywordsCalls += 1
    if s[i] != '@':
        return 0
    # fail if something besides whitespace precedes the word on the line.
    i2 = i - 1
    while i2 &gt;= 0:
        ch = s[i2]
        if ch == '\n':
            break
        elif ch in (' ', '\t'):
            i2 -= 1
        else:
            return 0
    # Get the word as quickly as possible.
    j = i + 1
    while j &lt; len(s) and s[j] in self.word_chars:
        j += 1
    word = s[i + 1: j] # entries in leoKeywordsDict do not start with '@'.
    if j &lt; len(s) and s[j] not in (' ', '\t', '\n'):
        return 0 # Fail, but allow a rescan, as in objective_c.
    if self.leoKeywordsDict.get(word):
        kind = 'leokeyword'
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i + 1 # Bug fix: skip the last character.
        self.trace_match(kind, s, i, j)
        return result
    else:
        # 2010/10/20: also check the keywords dict here.
        # This allows for objective_c keywords starting with '@'
        # This will not slow down Leo, because it is called
        # for things that look like Leo directives.
        word = '@' + word
        kind = self.keywordsDict.get(word)
        if kind:
            self.colorRangeWithTag(s, i, j, kind)
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            return j - i
        else:
            # Bug fix: allow rescan.  Affects @language patch.
            return 0
            # Wrong: return -(j - i + 1)
</t>
<t tx="ekr.20190319151826.42">def match_section_ref(self, s, i):
    if self.trace_leo_matches:
        g.trace()
    p = self.c.p
    if not g.match(s, i, '&lt;&lt;'):
        return 0
    k = g.find_on_line(s, i + 2, '&gt;&gt;')
    if k == -1:
        return 0
    else:
        j = k + 2
        self.colorRangeWithTag(s, i, i + 2, 'namebrackets')
        ref = g.findReference(s[i: j], p)
        if ref:
            if self.use_hyperlinks:
                &lt;&lt; set the hyperlink &gt;&gt;
            else:
                self.colorRangeWithTag(s, i + 2, k, 'link')
        else:
            self.colorRangeWithTag(s, i + 2, k, 'name')
        self.colorRangeWithTag(s, k, j, 'namebrackets')
        return j - i
</t>
<t tx="ekr.20190319151826.43"># Set the bindings to VNode callbacks.
tagName = "hyper" + str(self.hyperCount)
self.hyperCount += 1
ref.tagName = tagName
</t>
<t tx="ekr.20190319151826.44">def match_tabs(self, s, i):
    if 1: # Use Qt code to show invisibles.
        return 0
    else: # Old code...
        if not self.showInvisibles:
            return 0
        if self.trace_leo_matches: g.trace()
        j = i; n = len(s)
        while j &lt; n and s[j] == '\t':
            j += 1
        if j &gt; i:
            self.colorRangeWithTag(s, i, j, 'tab')
            return j - i
        else:
            return 0
</t>
<t tx="ekr.20190319151826.45">def match_trailing_ws(self, s, i):
    """match trailing whitespace"""
    j = i; n = len(s)
    while j &lt; n and s[j] in ' \t':
        j += 1
    if j &gt; i and j == n:
        self.colorRangeWithTag(s, i, j, 'trailing_whitespace')
        return j - i
    else:
        return 0
</t>
<t tx="ekr.20190319151826.46">def match_unl(self, s, i):
    if g.match(s.lower(), i, 'unl://'):
        j = len(s)
        self.colorRangeWithTag(s, i, j, 'url')
        return j
    else:
        return 0
</t>
<t tx="ekr.20190319151826.47"># Fix bug 893230: URL coloring does not work for many Internet protocols.
# Added support for: gopher, mailto, news, nntp, prospero, telnet, wais
url_regex_f = re.compile(r"""(file|ftp)://[^\s'"]+[\w=/]""")
url_regex_g = re.compile(r"""gopher://[^\s'"]+[\w=/]""")
url_regex_h = re.compile(r"""(http|https)://[^\s'"]+[\w=/]""")
url_regex_m = re.compile(r"""mailto://[^\s'"]+[\w=/]""")
url_regex_n = re.compile(r"""(news|nntp)://[^\s'"]+[\w=/]""")
url_regex_p = re.compile(r"""prospero://[^\s'"]+[\w=/]""")
url_regex_t = re.compile(r"""telnet://[^\s'"]+[\w=/]""")
url_regex_w = re.compile(r"""wais://[^\s'"]+[\w=/]""")
kinds = '(file|ftp|gopher|http|https|mailto|news|nntp|prospero|telnet|wais)'
url_regex = re.compile(r"""%s://[^\s'"]+[\w=/]""" % (kinds))

def match_any_url(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex)

def match_url_f(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_f)

def match_url_g(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_g)

def match_url_h(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_h)

def match_url_m(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_m)

def match_url_n(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_n)

def match_url_p(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_p)

def match_url_t(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_t)

def match_url_w(self, s, i):
    return self.match_compiled_regexp(s, i, kind='url', regexp=self.url_regex_w)
</t>
<t tx="ekr.20190319151826.48">def match_compiled_regexp(self, s, i, kind, regexp, delegate=''):
    '''Succeed if the compiled regular expression regexp matches at s[i:].'''
    n = self.match_compiled_regexp_helper(s, i, regexp)
    if n &gt; 0:
        j = i + n
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return n
    else:
        return 0
</t>
<t tx="ekr.20190319151826.49">def match_compiled_regexp_helper(self, s, i, regex):
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = regex.match(s, i) # re_obj.search(s,i)
    if mo is None:
        return 0
    start, end = mo.start(), mo.end()
    if start != i:
        return 0
    return end - start
</t>
<t tx="ekr.20190319151826.5">@nobeautify

def defineDefaultColorsDict (self):

    # These defaults are sure to exist.
    self.default_colors_dict = {

        # Used in Leo rules...

        # tag name      :( option name,                  default color),
        'blank'         :('show_invisibles_space_color', '#E5E5E5'), # gray90
        'docpart'       :('doc_part_color',              'red'),
        'leokeyword'    :('leo_keyword_color',           'blue'),
        'link'          :('section_name_color',          'red'),
        'name'          :('undefined_section_name_color','red'),
        'namebrackets'  :('section_name_brackets_color', 'blue'),
        'tab'           :('show_invisibles_tab_color',   '#CCCCCC'), # gray80
        'url'           :('url_color',                   'purple'),

        # Used by the old colorizer: to be removed.

        # 'bracketRange'   :('bracket_range_color',     'orange'), # Forth.
        # 'comment'        :('comment_color',           'red'),
        # 'cwebName'       :('cweb_section_name_color', 'red'),
        # 'keyword'        :('keyword_color',           'blue'),
        # 'latexBackground':('latex_background_color',  'white'),
        # 'pp'             :('directive_color',         'blue'),
        # 'string'         :('string_color',            '#00aa00'), # Used by IDLE.

        # jEdit tags.
        # tag name  :( option name,     default color),
        'comment1'  :('comment1_color', 'red'),
        'comment2'  :('comment2_color', 'red'),
        'comment3'  :('comment3_color', 'red'),
        'comment4'  :('comment4_color', 'red'),
        'function'  :('function_color', 'black'),
        'keyword1'  :('keyword1_color', 'blue'),
        'keyword2'  :('keyword2_color', 'blue'),
        'keyword3'  :('keyword3_color', 'blue'),
        'keyword4'  :('keyword4_color', 'blue'),
        'keyword5'  :('keyword5_color', 'blue'),
        'label'     :('label_color',    'black'),
        'literal1'  :('literal1_color', '#00aa00'),
        'literal2'  :('literal2_color', '#00aa00'),
        'literal3'  :('literal3_color', '#00aa00'),
        'literal4'  :('literal4_color', '#00aa00'),
        'markup'    :('markup_color',   'red'),
        'null'      :('null_color',     None), #'black'),
        'operator'  :('operator_color', 'black'), # 2014/09/17
        'trailing_whitespace': ('trailing_whitespace_color', '#808080'),
    }
</t>
<t tx="ekr.20190319151826.50">def match_eol_span(self, s, i,
    kind=None, seq='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False
):
    '''Succeed if seq matches s[i:]'''
    if at_line_start and i != 0 and s[i - 1] != '\n':
        return 0
    if at_whitespace_end and i != g.skip_ws(s, 0):
        return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars:
        return 0
    if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i + len(seq)] in self.word_chars:
        return 0
    if g.match(s, i, seq):
        j = len(s)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return j # (was j-1) With a delegate, this could clear state.
    else:
        return 0
</t>
<t tx="ekr.20190319151826.51">def match_eol_span_regexp(self, s, i,
    kind='', regexp='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False
):
    '''Succeed if the regular expression regex matches s[i:].'''
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    n = self.match_regexp_helper(s, i, regexp)
    if n &gt; 0:
        j = len(s)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
        return j - i
    else:
        return 0
</t>
<t tx="ekr.20190319151826.52"># def match_everything (self,s,i,kind=None,delegate='',exclude_match=False):
    # '''Match the entire rest of the string.'''
    # j = len(s)
    # self.colorRangeWithTag(s,i,j,kind,delegate=delegate)
    # return j
</t>
<t tx="ekr.20190319151826.53"># This is a time-critical method.

def match_keywords(self, s, i):
    '''
    Succeed if s[i:] is a keyword.
    Returning -len(word) for failure greatly reduces the number of times this
    method is called.
    '''
    self.totalKeywordsCalls += 1
    # We must be at the start of a word.
    if i &gt; 0 and s[i - 1] in self.word_chars:
        return 0
    # Get the word as quickly as possible.
    j = i; n = len(s)
    chars = self.word_chars
    # A kludge just for Haskell:
    if self.language in ('haskell','clojure'):
        chars["'"] = "'"
    while j &lt; n and s[j] in chars:
        j += 1
    word = s[i: j]
    # Fix part of #585: A kludge for css.
    if self.language == 'css' and word.endswith(':'):
        j -= 1
        word = word[:-1]
    if not word:
        g.trace('can not happen', repr(s[i: max(j, i + 1)]), repr(s[i: i + 10]), g.callers())
        return 0
    if self.ignore_case: word = word.lower()
    kind = self.keywordsDict.get(word)
    if kind:
        self.colorRangeWithTag(s, i, j, kind)
        self.prev = (i, j, kind)
        result = j - i
        self.trace_match(kind, s, i, j)
        return result
    else:
        return -len(word) # An important new optimization.
</t>
<t tx="ekr.20190319151826.54">def match_line(self, s, i, kind=None, delegate='', exclude_match=False):
    '''Match the rest of the line.'''
    j = g.skip_to_end_of_line(s, i)
    self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
    return j - i
</t>
<t tx="ekr.20190319151826.55">def match_mark_following(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Succeed if s[i:] matches pattern.'''
    if not self.allow_mark_prev: return 0
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(pattern) + 1 &lt; len(s) and s[i + len(pattern)] in self.word_chars:
        return 0 # 7/5/2008
    if g.match(s, i, pattern):
        j = i + len(pattern)
        # self.colorRangeWithTag(s,i,j,kind,exclude_match=exclude_match)
        k = self.getNextToken(s, j)
        # 2011/05/31: Do not match *anything* unless there is a token following.
        if k &gt; j:
            self.colorRangeWithTag(s, i, j, kind, exclude_match=exclude_match)
            self.colorRangeWithTag(s, j, k, kind, exclude_match=False)
            j = k
            self.prev = (i, j, kind)
            self.trace_match(kind, s, i, j)
            return j - i
        else:
            return 0
    else:
        return 0
</t>
<t tx="ekr.20190319151826.56">def getNextToken(self, s, i):
    '''Return the index of the end of the next token for match_mark_following.

    The jEdit docs are not clear about what a 'token' is, but experiments with jEdit
    show that token means a word, as defined by word_chars.'''
    # 2011/05/31: Might we extend the concept of token?
    # If s[i] is not a word char, should we return just it?
    i0 = i
    while i &lt; len(s) and s[i].isspace():
        i += 1
    i1 = i
    while i &lt; len(s) and s[i] in self.word_chars:
        i += 1
    if i == i1:
        return i0
    else:
        # 2011/05/31: was i+1
        return min(len(s), i)
</t>
<t tx="ekr.20190319151826.57">def match_mark_previous(self, s, i,
    kind='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Return the length of a matched SEQ or 0 if no match.

    'at_line_start':    True: sequence must start the line.
    'at_whitespace_end':True: sequence must be first non-whitespace text of the line.
    'at_word_start':    True: sequence must start a word.'''
    # This match was causing most of the syntax-color problems.
    return 0 # 2009/6/23
</t>
<t tx="ekr.20190319151826.58">def match_regexp_helper(self, s, i, pattern):
    '''Return the length of the matching text if seq (a regular expression) matches the present position.'''
    try:
        flags = re.MULTILINE
        if self.ignore_case: flags |= re.IGNORECASE
        re_obj = re.compile(pattern, flags)
    except Exception:
        # Do not call g.es here!
        g.trace('Invalid regular expression: %s' % (pattern))
        return 0
    # Match succeeds or fails more quickly than search.
    self.match_obj = mo = re_obj.match(s, i) # re_obj.search(s,i)
    if mo is None:
        return 0
    else:
        start, end = mo.start(), mo.end()
        if start != i: # Bug fix 2007-12-18: no match at i
            return 0
        return end - start
</t>
<t tx="ekr.20190319151826.59">def match_seq(self, s, i,
    kind='', seq='',
    at_line_start=False,
    at_whitespace_end=False,
    at_word_start=False,
    delegate=''
):
    '''Succeed if s[:] mathces seq.'''
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: # 7/5/2008
        j = i
    if at_word_start and i + len(seq) + 1 &lt; len(s) and s[i + len(seq)] in self.word_chars:
        j = i # 7/5/2008
    elif g.match(s, i, seq):
        j = i + len(seq)
        self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j)
    else:
        j = i
    return j - i
</t>
<t tx="ekr.20190319151826.6">@nobeautify

def defineDefaultFontDict (self):

    self.default_font_dict = {

        # Used in Leo rules...

            # tag name      : option name
            'blank'         :'show_invisibles_space_font', # 2011/10/24.
            'docpart'       :'doc_part_font',
            'leokeyword'    :'leo_keyword_font',
            'link'          :'section_name_font',
            'name'          :'undefined_section_name_font',
            'namebrackets'  :'section_name_brackets_font',
            'tab'           : 'show_invisibles_tab_font', # 2011/10/24.
            'url'           : 'url_font',

        # Used by old colorizer.

            # 'bracketRange'   :'bracketRange_font', # Forth.
            # 'comment'       :'comment_font',
            # 'cwebName'      :'cweb_section_name_font',
            # 'keyword'       :'keyword_font',
            # 'latexBackground':'latex_background_font',
            # 'pp'            :'directive_font',
            # 'string'        :'string_font',

         # jEdit tags.

             # tag name     : option name
            'comment1'      :'comment1_font',
            'comment2'      :'comment2_font',
            'comment3'      :'comment3_font',
            'comment4'      :'comment4_font',
            #'default'       :'default_font',
            'function'      :'function_font',
            'keyword1'      :'keyword1_font',
            'keyword2'      :'keyword2_font',
            'keyword3'      :'keyword3_font',
            'keyword4'      :'keyword4_font',
            'keyword5'      :'keyword5_font',
            'label'         :'label_font',
            'literal1'      :'literal1_font',
            'literal2'      :'literal2_font',
            'literal3'      :'literal3_font',
            'literal4'      :'literal4_font',
            'markup'        :'markup_font',
            # 'nocolor' This tag is used, but never generates code.
            'null'          :'null_font',
            'operator'      :'operator_font',
            'trailing_whitespace' :'trailing_whitespace_font',
    }
</t>
<t tx="ekr.20190319151826.60">def match_seq_regexp(self, s, i,
    kind='', regexp='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate=''
):
    '''Succeed if the regular expression regexp matches at s[i:].'''
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0
    n = self.match_regexp_helper(s, i, regexp)
    j = i + n
    assert(j - i == n)
    self.colorRangeWithTag(s, i, j, kind, delegate=delegate)
    self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    return j - i
</t>
<t tx="ekr.20190319151826.61">def match_span(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False
):
    '''Succeed if s[i:] starts with 'begin' and contains a following 'end'.'''
    dots = False # A flag that we are using dots as a continuation.
    if i &gt;= len(s):
        return 0
    if at_line_start and i != 0 and s[i - 1] != '\n':
        j = i
    elif at_whitespace_end and i != g.skip_ws(s, 0):
        j = i
    elif at_word_start and i &gt; 0 and s[i - 1] in self.word_chars:
        j = i
    elif at_word_start and i + len(begin) + 1 &lt; len(s) and s[i + len(begin)] in self.word_chars:
        j = i
    elif not g.match(s, i, begin):
        j = i
    else:
        # We have matched the start of the span.
        j = self.match_span_helper(s, i + len(begin), end,
            no_escape, no_line_break, no_word_break=no_word_break)
        if j == -1:
            j = i # A real failure.
        else:
            # A hack to handle continued strings. Should work for most languages.
            # Prepend "dots" to the kind, as a flag to setTag.
            dots = j &gt; len(s) and begin in "'\"" and end in "'\"" and kind.startswith('literal')
            dots = dots and self.language not in ('lisp', 'elisp')
            if dots:
                kind = 'dots'+kind
            # A match
            i2 = i + len(begin); j2 = j + len(end)
            if delegate:
                self.colorRangeWithTag(s, i, i2, kind, delegate=None, exclude_match=exclude_match)
                self.colorRangeWithTag(s, i2, j, kind, delegate=delegate, exclude_match=exclude_match)
                self.colorRangeWithTag(s, j, j2, kind, delegate=None, exclude_match=exclude_match)
            else:
                self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
            j = j2
            self.prev = (i, j, kind)
    self.trace_match(kind, s, i, j)
    # New in Leo 5.5: don't recolor everything after continued strings.
    if j &gt; len(s) and not dots:
        j = len(s) + 1

        def span(s):
            # Note: bindings are frozen by this def.
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keyword args.
            delegate=delegate, end=end,
            exclude_match=exclude_match,
            kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    return j - i # Correct, whatever j is.
</t>
<t tx="ekr.20190319151826.62">def match_span_helper(self, s, i, pattern, no_escape, no_line_break, no_word_break):
    '''
    Return n &gt;= 0 if s[i] ends with a non-escaped 'end' string.
    '''
    esc = self.escape
    while 1:
        j = s.find(pattern, i)
        if j == -1:
            # Match to end of text if not found and no_line_break is False
            if no_line_break:
                return -1
            else:
                return len(s) + 1
        elif no_word_break and j &gt; 0 and s[j - 1] in self.word_chars:
            return -1 # New in Leo 4.5.
        elif no_line_break and '\n' in s[i: j]:
            return -1
        elif esc and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k &gt;= 0 and s[j - k] == esc:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                assert s[j - 1] == esc
                i += 1 # 2013/08/26: just advance past the *one* escaped character.
            else:
                return j
        else:
            return j
</t>
<t tx="ekr.20190319151826.63">def restart_match_span(self, s,
    delegate, end, exclude_match, kind,
    no_escape, no_line_break, no_word_break
):
    '''Remain in this state until 'end' is seen.'''
    i = 0
    j = self.match_span_helper(s, i, end, no_escape, no_line_break, no_word_break)
    if j == -1:
        j2 = len(s) + 1
    elif j &gt; len(s):
        j2 = j
    else:
        j2 = j + len(end)
    if delegate:
        self.colorRangeWithTag(s, i, j, kind,
            delegate=delegate, exclude_match=exclude_match)
        self.colorRangeWithTag(s, j, j2, kind,
            delegate=None, exclude_match=exclude_match)
    else: # avoid having to merge ranges in addTagsToList.
        self.colorRangeWithTag(s, i, j2, kind,
            delegate=None, exclude_match=exclude_match)
    j = j2
    self.trace_match(kind, s, i, j)
    if j &gt; len(s):

        def span(s):
            return self.restart_match_span(s,
                # Positional args, in alpha order
                delegate, end, exclude_match, kind,
                no_escape, no_line_break, no_word_break)

        self.setRestart(span,
            # These must be keywords args.
            delegate=delegate, end=end, kind=kind,
            no_escape=no_escape,
            no_line_break=no_line_break,
            no_word_break=no_word_break)
    else:
        self.clearState()
    return j # Return the new i, *not* the length of the match.
</t>
<t tx="ekr.20190319151826.64">def match_span_regexp(self, s, i,
    kind='', begin='', end='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    delegate='', exclude_match=False,
    no_escape=False, no_line_break=False, no_word_break=False,
):
    '''Succeed if s[i:] starts with 'begin' (a regular expression) and
    contains a following 'end'.
    '''
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0 # 7/5/2008
    if at_word_start and i + len(begin) + 1 &lt; len(s) and s[i + len(begin)] in self.word_chars:
        return 0 # 7/5/2008
    n = self.match_regexp_helper(s, i, begin)
    # We may have to allow $n here, in which case we must use a regex object?
    if n &gt; 0:
        j = i + n
        j2 = s.find(end, j)
        if j2 == -1: return 0
        if self.escape and not no_escape:
            # Only an odd number of escapes is a 'real' escape.
            escapes = 0; k = 1
            while j - k &gt;= 0 and s[j - k] == self.escape:
                escapes += 1; k += 1
            if (escapes % 2) == 1:
                # An escaped end **aborts the entire match**:
                # there is no way to 'restart' the regex.
                return 0
        i2 = j2 - len(end)
        if delegate:
            self.colorRangeWithTag(s, i, j, kind, delegate=None, exclude_match=exclude_match)
            self.colorRangeWithTag(s, j, i2, kind, delegate=delegate, exclude_match=False)
            self.colorRangeWithTag(s, i2, j2, kind, delegate=None, exclude_match=exclude_match)
        else: # avoid having to merge ranges in addTagsToList.
            self.colorRangeWithTag(s, i, j2, kind, delegate=None, exclude_match=exclude_match)
        self.prev = (i, j, kind)
        self.trace_match(kind, s, i, j2)
        return j2 - i
    else: return 0
</t>
<t tx="ekr.20190319151826.65">def match_wiki_pattern(self, s, i, pattern):
    '''Show or hide a regex pattern managed by the wikiview plugin.'''
    m = pattern.match(s,i)
    if m:
        n = len(m.group(0))
        self.colorRangeWithTag(s, i, i + n, 'url')
        return n
    else:
        return 0
</t>
<t tx="ekr.20190319151826.66">def match_word_and_regexp(self, s, i,
    kind1='', word='',
    kind2='', pattern='',
    at_line_start=False, at_whitespace_end=False, at_word_start=False,
    exclude_match=False
):
    '''Succeed if s[i:] matches pattern.'''
    if not self.allow_mark_prev: return 0
    if at_line_start and i != 0 and s[i - 1] != '\n': return 0
    if at_whitespace_end and i != g.skip_ws(s, 0): return 0
    if at_word_start and i &gt; 0 and s[i - 1] in self.word_chars: return 0
    if at_word_start and i + len(word) + 1 &lt; len(s) and s[i + len(word)] in self.word_chars:
        j = i
    if not g.match(s, i, word):
        return 0
    j = i + len(word)
    n = self.match_regexp_helper(s, j, pattern)
    if n == 0:
        return 0
    self.colorRangeWithTag(s, i, j, kind1, exclude_match=exclude_match)
    k = j + n
    self.colorRangeWithTag(s, j, k, kind2, exclude_match=False)
    self.prev = (j, k, kind2)
    self.trace_match(kind1, s, i, j)
    self.trace_match(kind2, s, j, k)
    return k - i
</t>
<t tx="ekr.20190319151826.67">def skip_line(self, s, i):
    if self.escape:
        escape = self.escape + '\n'
        n = len(escape)
        while i &lt; len(s):
            j = g.skip_line(s, i)
            if not g.match(s, j - n, escape):
                return j
            i = j
        return i
    else:
        return g.skip_line(s, i)
            # Include the newline so we don't get a flash at the end of the line.
</t>
<t tx="ekr.20190319151826.68">def trace_match(self, kind, s, i, j):

    if j != i and self.trace_match_flag:
        g.trace(kind, i, j, g.callers(2), self.dump(s[i: j]))
</t>
<t tx="ekr.20190319151826.69"></t>
<t tx="ekr.20190319151826.7">def reloadSettings(self):
    c = self.c
    self.showInvisibles = c.config.getBool("show-invisibles-by-default")
    self.underline_undefined = c.config.getBool("underline-undefined-section-names")
    self.use_hyperlinks = c.config.getBool("use-hyperlinks")
    # There were in setFontFromConfig.
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant", "body_text_font_weight",
        c.config.defaultBodyFontSize)
    self.color_tags_list = []
</t>
<t tx="ekr.20190319151826.70">def clearState(self):
    '''
    Create a *language-specific* default state.
    This properly forces a full recoloring when @language changes.
    '''
    n = self.initialStateNumber
    self.setState(n)
    return n
</t>
<t tx="ekr.20190319151826.71">def computeState(self, f, keys):
    '''
    Compute the state name associated with f and all the keys.
    Return a unique int n representing that state.
    '''
    # Abbreviate arg names.
    d = {
        'delegate': '=&gt;',
        'end': 'end',
        'at_line_start': 'start',
        'at_whitespace_end': 'ws-end',
        'exclude_match': '!match',
        'no_escape': '!esc',
        'no_line_break': '!lbrk',
        'no_word_break': '!wbrk',
    }
    result = [self.languageTag(self.language)]
    if not self.rulesetName.endswith('_main'):
        result.append(self.rulesetName)
    if f:
        result.append(f.__name__)
    for key in sorted(keys):
        keyVal = keys.get(key)
        val = d.get(key)
        if val is None:
            val = keys.get(key)
            result.append('%s=%s' % (key, val))
        elif keyVal is True:
            result.append('%s' % val)
        elif keyVal is False:
            pass
        elif keyVal not in (None, ''):
            result.append('%s=%s' % (key, keyVal))
    state = ';'.join(result).lower()
    table = (
        ('kind=', ''),
        ('literal', 'lit'),
        ('restart', '@'),
    )
    for pattern, s in table:
        state = state.replace(pattern, s)
    n = self.stateNameToStateNumber(f, state)
    return n
</t>
<t tx="ekr.20190319151826.72">def currentBlockNumber(self):
    block = self.highlighter.currentBlock()
    return block.blockNumber() if block and block.isValid() else -1

def currentState(self):
    return self.highlighter.currentBlockState()

def prevState(self):
    return self.highlighter.previousBlockState()

def setState(self, n):
    self.highlighter.setCurrentBlockState(n)
    return n
</t>
<t tx="ekr.20190319151826.73">def inColorState(self):
    '''True if the *current* state is enabled.'''
    n = self.currentState()
    state = self.stateDict.get(n, 'no-state')
    enabled = (
        not state.endswith('@nocolor') and
        not state.endswith('@nocolor-node') and
        not state.endswith('@killcolor'))
    return enabled


</t>
<t tx="ekr.20190319151826.74">def setRestart(self, f, **keys):
    n = self.computeState(f, keys)
    self.setState(n)
    return n

</t>
<t tx="ekr.20190319151826.75">def showState(self, n):
    state = self.stateDict.get(n, 'no-state')
    return '%2s:%s' % (n, state)

def showCurrentState(self):
    n = self.currentState()
    return self.showState(n)

def showPrevState(self):
    n = self.prevState()
    return self.showState(n)
</t>
<t tx="ekr.20190319151826.76">def stateNameToStateNumber(self, f, stateName):
    '''
    stateDict:     Keys are state numbers, values state names.
    stateNameDict: Keys are state names, values are state numbers.
    restartDict:   Keys are state numbers, values are restart functions
    '''
    n = self.stateNameDict.get(stateName)
    if n is None:
        n = self.nextState
        self.stateNameDict[stateName] = n
        self.stateDict[n] = stateName
        self.restartDict[n] = f
        self.nextState += 1
        self.n2languageDict [n] = self.language
    return n
</t>
<t tx="ekr.20190319151826.77">def colorRangeWithTag(self, s, i, j, tag, delegate='', exclude_match=False):
    '''Actually colorize the selected range.

    This is called whenever a pattern matcher succeed.'''
    trace = 'coloring' in g.app.debug
        # A superb trace: enable this first to see what gets colored.
    if not self.inColorState():
        # Do *not* check x.flag here. It won't work.
        if trace: g.trace('not in color state')
        return
    if delegate:
        if trace:
            if len(repr(s[i: j])) &lt;= 20:
                s2 = repr(s[i: j])
            else:
                s2 = repr(s[i: i + 17 - 2] + '...')
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (delegate, tag)), i, j, s2, g.callers(2)))
        self.modeStack.append(self.modeBunch)
        self.init_mode(delegate)
        while 0 &lt;= i &lt; j and i &lt; len(s):
            progress = i
            assert j &gt;= 0, j
            for f in self.rulesDict.get(s[i], []):
                n = f(self, s, i)
                if n is None:
                    g.trace('Can not happen: delegate matcher returns None')
                elif n &gt; 0:
                    i += n; break
            else:
                # Use the default chars for everything else.
                # Use the *delegate's* default characters if possible.
                default_tag = self.attributesDict.get('default')
                self.setTag(default_tag or tag, s, i, i + 1)
                i += 1
            assert i &gt; progress
        bunch = self.modeStack.pop()
        self.initModeFromBunch(bunch)
    elif not exclude_match:
        if trace:
            s2 = repr(s[i: j]) if len(repr(s[i: j])) &lt;= 20 else repr(s[i: i + 17 - 2] + '...')
            g.trace('%25s %3s %3s %-20s %s' % (
                ('%s.%s' % (self.language, tag)), i, j, s2, g.callers(2)))
        self.setTag(tag, s, i, j)
    if tag != 'url':
        # Allow UNL's and URL's *everywhere*.
        j = min(j, len(s))
        while i &lt; j:
            ch = s[i].lower()
            if ch == 'u':
                n = self.match_unl(s, i)
                i += max(1, n)
            elif ch in 'fh': # file|ftp|http|https
                n = self.match_any_url(s, i)
                i += max(1, n)
            else:
                i += 1
</t>
<t tx="ekr.20190319151826.78">lexer_dict = {}
    # Keys are language names, values are instantiated lexers.
state_s_dict = {}
    # Keys are strings, values are ints.
state_n_dict = {}
    # For tracing only.
    # Keys are ints, values are strings.
state_index = 1

def mainLoop(self, s):
    '''Colorize a *single* line s'''
    trace = False and g.pygments and not g.unitTesting
    highlighter = self.highlighter
    if not getattr(self, '_lexer', None):
        self._lexer = Lexer() ### To be generalized.
        # g.trace('===== new lexer:', self._lexer)
        # g.printObj(dir(self._lexer))
    lexer = self._lexer
    # g.printObj(lexer.tokens ['root'])
    if trace:
        print('\npyg_c.mainLoop: count: %s line: %r' % (self.recolorCount, s))
        prev_state = highlighter.previousBlockState()
        prev_state_s = self.state_n_dict.get(prev_state, "&lt;no state&gt;")
        print('prev state: %r: %s' % (prev_state, prev_state_s))
    #
    # Lex the text using Pygments.
    #
    # Based on code copyright (c) Jupyter Development Team.
    # Distributed under the terms of the Modified BSD License.
    stack_ivar = '_saved_state_stack'
    prev_data = highlighter.currentBlock().previous().userData()
    if prev_data is not None:
        # if trace: print('prev data:', prev_data)
        setattr(lexer, stack_ivar, prev_data.syntax_stack)
    elif hasattr(self._lexer, stack_ivar):
        delattr(self._lexer, stack_ivar)
    index = 0
    for token, text in self._lexer.get_tokens(s):
        length = len(text)
        # if trace: print('%25r %r' % (repr(token).lstrip('Token.'), text))
        format = highlighter._get_format(token)
        highlighter.setFormat(index, length, format)
        index += length
    stack = getattr(self._lexer, stack_ivar, None)
    if stack:
        data = PygmentsBlockUserData(syntax_stack=stack)
        ### if trace: print('new data:', data)
        highlighter.currentBlock().setUserData(data)
        # Clean up for the next go-round.
        delattr(self._lexer, stack_ivar)
    #
    # New code by EKR.
    state_s = '%s; %r' % (self.language, stack)
    state_n = self.state_s_dict.get(state_s)
    if state_n is None:
        state_n = self.state_index
        self.state_index += 1
        self.state_s_dict [state_s] = state_n
        self.state_n_dict [state_n] = state_s
    highlighter.setCurrentBlockState(state_n)
</t>
<t tx="ekr.20190319151826.79">def recolor(self, s):
    '''
    PygmentsColorizer.recolor: Recolor a *single* line, s.
    QSyntaxHighligher calls this method repeatedly and automatically.
    '''
    trace = False and g.pygments and not g.unitTesting
    p = self.c.p
    self.recolorCount += 1
    ### block_n = self.currentBlockNumber()
    ### n = self.prevState()
    if trace:
        print('')
        g.trace(repr(s), '\n')
    if p.v != self.old_v:
        self.updateSyntaxColorer(p)
            # Force a full recolor
            # sets self.language and self.enabled.
        assert self.language
        ### self.init_all_state(p.v)
        ### self.init(p)
    ###
        # else:
            # new_language = self.n2languageDict.get(n)
            # if new_language != self.language:
                # self.language = new_language
                    # self.init(p)
        # if block_n == 0:
            # n = self.initBlock0()
        # n = self.setState(n) # Required.
        # Always color the line, even if colorizing is disabled.
        # if s is not None:
            # self.mainLoop(n, s)
    if s:
        self.mainLoop(s)
</t>
<t tx="ekr.20190319151826.8">def addImportedRules(self, mode, rulesDict, rulesetName):
    '''Append any imported rules at the end of the rulesets specified in mode.importDict'''
    if self.importedRulesets.get(rulesetName):
        return
    else:
        self.importedRulesets[rulesetName] = True
    names = mode.importDict.get(rulesetName, []) if hasattr(mode, 'importDict') else []
    for name in names:
        savedBunch = self.modeBunch
        ok = self.init_mode(name)
        if ok:
            rulesDict2 = self.rulesDict
            for key in rulesDict2.keys():
                aList = self.rulesDict.get(key, [])
                aList2 = rulesDict2.get(key)
                if aList2:
                    # Don't add the standard rules again.
                    rules = [z for z in aList2 if z not in aList]
                    if rules:
                        aList.extend(rules)
                        self.rulesDict[key] = aList
        self.initModeFromBunch(savedBunch)
</t>
<t tx="ekr.20190319151826.80">def initBlock0 (self):
    '''
    Init *local* ivars when handling block 0.
    This prevents endless recalculation of the proper default state.
    '''
    if self.enabled:
        n = self.setInitialStateNumber()
    else:
        n = self.setRestart(self.restartNoColor)
    return n
</t>
<t tx="ekr.20190319151826.81">def setInitialStateNumber(self):
    '''
    Init the initialStateNumber ivar for clearState()
    This saves a lot of work.

    Called from init() and initBlock0.
    '''
    state = self.languageTag(self.language)
    n = self.stateNameToStateNumber(None, state)
    self.initialStateNumber = n
    self.blankStateNumber = self.stateNameToStateNumber(None,state+';blank')
    return n
</t>
<t tx="ekr.20190319151826.82">def languageTag(self, name):
    '''
    Return the standardized form of the language name.
    Doing this consistently prevents subtle bugs.
    '''
    if name:
        table = (
            ('markdown', 'md'),
            ('python', 'py'),
            ('javascript', 'js'),
        )
        for pattern, s in table:
            name = name.replace(pattern, s)
        return name
    else:
        return 'no-language'
</t>
<t tx="ekr.20190319151826.83">def set_wikiview_patterns(self, leadins, patterns):
    '''
    Init the colorizer so it will *skip* all patterns.
    The wikiview plugin calls this method.
    '''
    d = self.rulesDict
    for leadins_list, pattern in zip(leadins, patterns):
        for ch in leadins_list:

            def wiki_rule(self, s, i, pattern=pattern):
                '''Bind pattern and leadin for jedit.match_wiki_pattern.'''
                return self.match_wiki_pattern(s, i, pattern)

            aList = d.get(ch, [])
            if wiki_rule not in aList:
                aList.insert(0, wiki_rule)
                d [ch] = aList
    self.rulesDict = d
</t>
<t tx="ekr.20190319151826.84">def setTag(self, tag, s, i, j):
    '''Set the tag in the highlighter.'''
    self.n_setTag += 1
    if i == j:
        return
    wrapper = self.wrapper # A QTextEditWrapper
    tag = tag.lower() # 2011/10/28
    # A hack to allow continuation dots on any tag.
    dots = tag.startswith('dots')
    if dots:
        tag = tag[len('dots'):]
    colorName = wrapper.configDict.get(tag)
    # Munge the color name.
    if not colorName:
        return
    if colorName[-1].isdigit() and colorName[0] != '#':
        colorName = colorName[: -1]
    # Get the actual color.
    color = self.actualColorDict.get(colorName)
    if not color:
        color = QtGui.QColor(colorName)
        if color.isValid():
            self.actualColorDict[colorName] = color
        else:
            return g.trace('unknown color name', colorName, g.callers())
    underline = wrapper.configUnderlineDict.get(tag)
    format = QtGui.QTextCharFormat()
    font = self.fonts.get(tag)
    if font:
        format.setFont(font)
    if tag in ('blank', 'tab'):
        if tag == 'tab' or colorName == 'black':
            format.setFontUnderline(True)
        if colorName != 'black':
            format.setBackground(color)
    elif underline:
        format.setForeground(color)
        format.setUnderlineStyle(format.SingleUnderline)
        format.setFontUnderline(True)
    elif dots or tag == 'trailing_whitespace':
        format.setForeground(color)
        format.setUnderlineStyle(format.DotLine)
    else:
        format.setForeground(color)
        format.setUnderlineStyle(format.NoUnderline)
    self.tagCount += 1
    self.highlighter.setFormat(i, j - i, format)
</t>
<t tx="ekr.20190319151826.9">def addLeoRules(self, theDict):
    '''Put Leo-specific rules to theList.'''
    # pylint: disable=no-member
    # Python 2 uses rule.im_func. Python 3 uses rule.__func__.
    ###
        # table = [
            # # Rules added at front are added in **reverse** order.
            # ('@', self.match_leo_keywords, True), # Called after all other Leo matchers.
                # # Debatable: Leo keywords override langauge keywords.
            # ('@', self.match_at_color, True),
            # ('@', self.match_at_killcolor, True),
            # ('@', self.match_at_language, True), # 2011/01/17
            # ('@', self.match_at_nocolor, True),
            # ('@', self.match_at_nocolor_node, True),
            # ('@', self.match_at_wrap, True), # 2015/06/22
            # ('@', self.match_doc_part, True),
            # ('f', self.match_url_f, True),
            # ('g', self.match_url_g, True),
            # ('h', self.match_url_h, True),
            # ('m', self.match_url_m, True),
            # ('n', self.match_url_n, True),
            # ('p', self.match_url_p, True),
            # ('t', self.match_url_t, True),
            # ('u', self.match_unl, True),
            # ('w', self.match_url_w, True),
            # # ('&lt;', self.match_image, True),
            # ('&lt;', self.match_section_ref, True), # Called **first**.
            # # Rules added at back are added in normal order.
            # (' ', self.match_blanks, False),
            # ('\t', self.match_tabs, False),
        # ]
        # if self.c.config.getBool("color-trailing-whitespace"):
            # table += [
                # (' ', self.match_trailing_ws, True),
                # ('\t', self.match_trailing_ws, True),
            # ]
        # for ch, rule, atFront, in table:
            # # Replace the bound method by an unbound method.
            # if g.isPython3:
                # rule = rule.__func__
            # else:
                # rule = rule.im_func
            # theList = theDict.get(ch, [])
            # if rule not in theList:
                # if atFront:
                    # theList.insert(0, rule)
                # else:
                    # theList.append(rule)
                # theDict[ch] = theList
</t>
<t tx="ekr.20190319185726.1">configDict:
{
                blank:'#E5E5E5',
             comment1:'#d33682',
             comment2:'#d33682',
             comment3:'#d33682',
             comment4:'#d33682',
              docpart:'#dc322f',
             function:'black',
             keyword1:'#268bd2',
             keyword2:'#268bd2',
             keyword3:'#268bd2',
             keyword4:'#268bd2',
             keyword5:'blue',
                label:'red',
           leokeyword:'#84c805',
                 link:'#dc322f',
             literal1:'#84c805',
             literal2:'#84c805',
             literal3:'#84c805',
             literal4:'#84c805',
               markup:'#268bd2',
                 name:'red',
         namebrackets:'#268bd2',
                 null:'#6c71c4',
             operator:'#6c71c4',
                  tab:'#CCCCCC',
  trailing_whitespace:'black',
                  url:'purple'
}</t>
<t tx="ekr.20190319192254.1"></t>
<t tx="ekr.20190320062624.10">###
# def set_style_sheet(self, stylesheet):
    # """
    # Sets a CSS stylesheet. The classes in the stylesheet should
    # correspond to those generated by:

        # pygmentize -S &lt;style&gt; -f html

    # Note that 'set_style' and 'set_style_sheet' completely override each
    # other, i.e. they cannot be used in conjunction.
    # """
    # self._document.setDefaultStyleSheet(stylesheet)
    # self._style = None
    # self._clear_caches()
</t>
<t tx="ekr.20190320062624.11">def _clear_caches(self):
    """ Clear caches for brushes and formats.
    """
    self._brushes = {}
    self._formats = {}
</t>
<t tx="ekr.20190320062624.12">def _get_format(self, token):
    """ Returns a QTextCharFormat for token or None.
    """
    if token in self._formats:
        return self._formats[token]
    if self._style is None:
        g.trace('**** no _style ***')
        result = self._get_format_from_document(token, self._document)
    else:
        result = self._get_format_from_style(token, self._style)
    self._formats[token] = result
    return result
</t>
<t tx="ekr.20190320062624.13">def _get_format_from_document(self, token, document):
    """ Returns a QTextCharFormat for token by
    """
    code, html = next(self._formatter._format_lines([(token, u'dummy')]))
    self._document.setHtml(html)
    format = QtGui.QTextCursor(self._document).charFormat()
    g.trace(format) ###
    return format
</t>
<t tx="ekr.20190320062624.14">def _get_format_from_style(self, token, style):
    """ Returns a QTextCharFormat for token by reading a Pygments style.
    """
    result = QtGui.QTextCharFormat()
    for key, value in style.style_for_token(token).items():
        if value:
            if key == 'color':
                result.setForeground(self._get_brush(value))
            elif key == 'bgcolor':
                result.setBackground(self._get_brush(value))
            elif key == 'bold':
                result.setFontWeight(QtGui.QFont.Bold)
            elif key == 'italic':
                result.setFontItalic(True)
            elif key == 'underline':
                result.setUnderlineStyle(
                    QtGui.QTextCharFormat.SingleUnderline)
            elif key == 'sans':
                result.setFontStyleHint(QtGui.QFont.SansSerif)
            elif key == 'roman':
                result.setFontStyleHint(QtGui.QFont.Times)
            elif key == 'mono':
                result.setFontStyleHint(QtGui.QFont.TypeWriter)
    return result
</t>
<t tx="ekr.20190320062624.15">def _get_brush(self, color):
    """ Returns a brush for the color.
    """
    result = self._brushes.get(color)
    if result is None:
        qcolor = self._get_color(color)
        result = QtGui.QBrush(qcolor)
        self._brushes[color] = result
    return result
</t>
<t tx="ekr.20190320062624.16">def _get_color(self, color):
    """ Returns a QColor built from a Pygments color string.
    """
    qcolor = QtGui.QColor()
    qcolor.setRgb(
        int(color[:2], base=16),
        int(color[2:4], base=16),
        int(color[4:6], base=16))
    return qcolor
</t>
<t tx="ekr.20190320062624.3"># Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

class PygmentsBlockUserData(QtGui.QTextBlockUserData):
    """ Storage for the user data associated with each line."""

    syntax_stack = ('root',)

    def __init__(self, **kwds):
        for key, value in kwds.items():
            setattr(self, key, value)
        QtGui.QTextBlockUserData.__init__(self)

    def __repr__(self):
        attrs = ['syntax_stack']
        kwds = ', '.join([
            '%s=%r' % (attr, getattr(self, attr))
                for attr in attrs
        ])
        return 'PygmentsBlockUserData(%s)' % kwds
</t>
<t tx="ekr.20190320062624.6"># Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

class PygmentsHighlighter(QtGui.QSyntaxHighlighter):
    """ Syntax highlighter that uses Pygments for parsing. """

    @others
</t>
<t tx="ekr.20190320062624.7">def __init__(self, parent, lexer=None):
    
    super(PygmentsHighlighter, self).__init__(parent)
    self._document = self.document()
    ### self._formatter = HtmlFormatter(nowrap=True)
    self.set_style('default')
    if lexer is not None:
        self._lexer = lexer
    elif g.isPython3:
        self._lexer = Python3Lexer()
    else:
        self._lexer = PythonLexer()
</t>
<t tx="ekr.20190320062624.8"># QSyntaxHighlighter interface

def highlightBlock(self, string):
    """ Highlight a block of text.
    """
    prev_data = self.currentBlock().previous().userData()
    if prev_data is not None:
        self._lexer._saved_state_stack = prev_data.syntax_stack
    elif hasattr(self._lexer, '_saved_state_stack'):
        del self._lexer._saved_state_stack
    #
    # Lex the text using Pygments
    index = 0
    for token, text in self._lexer.get_tokens(string):
        length = len(text)
        self.setFormat(index, length, self._get_format(token))
        index += length

    if hasattr(self._lexer, '_saved_state_stack'):
        data = PygmentsBlockUserData(
            syntax_stack=self._lexer._saved_state_stack)
        self.currentBlock().setUserData(data)
        # Clean up for the next go-round.
        del self._lexer._saved_state_stack

</t>
<t tx="ekr.20190320062624.9">def set_style(self, style):
    """ Sets the style to the specified Pygments style.
    """
    ###if isinstance(style, string_types):
    if g.isString(style):
        style = get_style_by_name(style)
    self._style = style
    self._clear_caches()
</t>
<t tx="ekr.20190320063234.1"># Protected interface
</t>
<t tx="ekr.20190320084740.1">def restartNoColor(self, s):
    if self.trace_leo_matches:
        g.trace(repr(s))
    if g.match_word(s, 0, '@color'):
        n = self.setRestart(self.restartColor)
        self.setState(n) # Enables coloring of *this* line.
        self.colorRangeWithTag(s, 0, len('@color'), 'leokeyword')
        return len('@color')
    else:
        self.setRestart(self.restartNoColor)
        return len(s) # Match everything.
</t>
<t tx="ekr.20190320153605.1">def _get_format(self, token):
    """ Returns a QTextCharFormat for token or None.
    """
    if token in self._formats:
        return self._formats[token]
    if self._style is None:
        result = self._get_format_from_document(token, self._document)
    else:
        result = self._get_format_from_style(token, self._style)
    result = self._get_format_from_style(token, self._style)
    self._formats[token] = result
    return result
</t>
<t tx="ekr.20190320153716.1">def _get_format_from_style(self, token, style):
    """ Returns a QTextCharFormat for token by reading a Pygments style.
    """
    result = QtGui.QTextCharFormat()
    for key, value in style.style_for_token(token).items():
        if value:
            if key == 'color':
                result.setForeground(self._get_brush(value))
            elif key == 'bgcolor':
                result.setBackground(self._get_brush(value))
            elif key == 'bold':
                result.setFontWeight(QtGui.QFont.Bold)
            elif key == 'italic':
                result.setFontItalic(True)
            elif key == 'underline':
                result.setUnderlineStyle(
                    QtGui.QTextCharFormat.SingleUnderline)
            elif key == 'sans':
                result.setFontStyleHint(QtGui.QFont.SansSerif)
            elif key == 'roman':
                result.setFontStyleHint(QtGui.QFont.Times)
            elif key == 'mono':
                result.setFontStyleHint(QtGui.QFont.TypeWriter)
    return result
</t>
<t tx="ekr.20190320153958.1">def setStyle(self, style):
    """ Sets the style to the specified Pygments style.
    """
    if g.isString(style):
        style = get_style_by_name(style)
    self._style = style
    self._clear_caches()
</t>
<t tx="ekr.20190320154014.1">if g.pygments:
    #
    # All code in this tree is based on PygmentsHighlighter.
    #
    # Copyright (c) Jupyter Development Team.
    # Distributed under the terms of the Modified BSD License.
    @others
</t>
<t tx="ekr.20190320154604.1">def _clear_caches(self):
    """ Clear caches for brushes and formats.
    """
    self._brushes = {}
    self._formats = {}
</t>
<t tx="ekr.20190320154752.1">def _get_brush(self, color):
    """ Returns a brush for the color.
    """
    result = self._brushes.get(color)
    if result is None:
        qcolor = self._get_color(color)
        result = QtGui.QBrush(qcolor)
        self._brushes[color] = result
    return result

def _get_color(self, color):
    """ Returns a QColor built from a Pygments color string.
    """
    qcolor = QtGui.QColor()
    qcolor.setRgb(int(color[:2], base=16),
                  int(color[2:4], base=16),
                  int(color[4:6], base=16))
    return qcolor
</t>
<t tx="ekr.20190320161623.1"></t>
<t tx="ekr.20190320162831.1">def _get_format_from_document(self, token, document):
    """ Returns a QTextCharFormat for token by
    """
    ### These lines cause unbounded recursion.
        # code, html = next(self._formatter._format_lines([(token, u'dummy')]))
        # self._document.setHtml(html)
    format = QtGui.QTextCursor(self._document).charFormat()
    return format
</t>
<t tx="ekr.20190321002423.1">format_dict = {
    'Keyword': 'keyword1',
    'Keyword.Namespace': 'keyword1',
    'Literal.String.Doc': 'literal1',
        # A **full** docstring.
    'Literal.String.Interpol': 'literal1',
    'Literal.String.Single': 'literal1',
    'Comment.Single': 'comment1',
    # 'xt': 'blank',
    'Operator': 'operator',
}

def mainLoop(self, n, s):
    '''Colorize a *single* line s, starting in state n.'''
    trace = False and g.pygments and not g.unitTesting
    highlighter = self.highlighter
    if trace:
        print('')
        g.trace('state:%s line: %s' % (n, s))
    #
    # Does not handle continued tokens.
    i = 0
    for kind, val in self._lexer.get_tokens(text=s):
        j = i + len(val)
        kind = repr(kind).lstrip('Token.')
        tag = self.format_dict.get(kind)
        if tag:
            if trace and kind not in ('xt', 'Name', 'Operator', 'Punctuation'):
                print('%30r %3s %3s %r' % (kind, i, j, val))
            self.setTag(tag, s, i, j)
        i = j
</t>
<t tx="ekr.20190321004028.1"></t>
<t tx="ekr.20190321104134.1">from pygments.style import Style
from pygments.token import Comment, Keyword, Name, String
    # Error, Number, Operator, Generic
from leo.core.leoColor import leo_color_database

class LeonineStyle(Style):
    default_style = ""
    table = (
        (Comment, 'firebrick3'),
        (Keyword, 'blue'),
        (Name, 'white'),
        # (Name.Function, '#0f0'),
        # (Name.Class, 'bold #0f0'),
        (String, '#00aa00'),
    )
    styles = {key: leo_color_database.get(val, val) for (key,val) in table}
    g.printObj(styles, tag='styles')
</t>
<t tx="ekr.20190321104651.1">@tabwidth -4
g.cls()
from leo.core.leoColor import leo_color_database as d
table = (
    # leoSettings.leo: Colors for Leo constructs.
    ('doc-part-color', 'firebrick3'),
    ('leo-keyword-color', '#00aa00'),
    ('section-name-color', 'red'),
    ('show-invisibles-space-color', '#E5E5E5'),
    ('show-invisibles-tab-color', '#CCCCCC'),
    ('undefined-section-name-color', 'red'),
    ('url-color', 'purple'),
    # jEdit colors.
    ('comment1-color', 'firebrick3'),
    ('comment2-color', 'firebrick3'),
    ('comment3-color', 'plum3'),
    ('comment4-color', 'orchid1'),
    ('keyword1-color', 'blue'),
    ('keyword2-color', 'blue'),
    ('keyword3-color', 'blue'),
    ('keyword4-color', 'blue'),
    ('label-color', 'red'),
    ('literal1-color', '#00aa00'),
    ('literal2-color', '#00aa00'),
    ('literal3-color', '#00aa00'),
    ('literal4-color', '#00aa00'),
    ('markup-color', 'blue'),
    ('operator-color', 'None'),
    )
for doc, name in table:
    print('%30s %10s %s' % (doc, name, d.get(name, name)))
</t>
<t tx="ekr.20190321112916.1">g.cls()
from pygments.style import Style
from pygments.token import string_to_tokentype
from leo.core.leoColor import leo_color_database

# Simulate what c.config.getData would return.
config = (
    'comment, firebrick3',
    'keyword, blue',
    'Name, white',
    'String, #00aa00',
    # 'huh???, whatever',
)

@others

class LeonineStyle(Style):
    default_style = ""
    table = []
    for line in config:
        name, color = line.split(',')
        name = name.capitalize()
        color = color.strip()
        color = leo_color_database.get(color, color)
        if is_valid_color(color):
            try:
                token = string_to_tokentype(name)
                table.append([token, color])
            except Exception:
                print('unknown token', repr(name))
        else:
            print('invalid color: %r for style: %r' % (color, name))
    styles = dict(table)
    g.printObj(styles, tag='styles dict')
</t>
<t tx="ekr.20190321120119.1">def is_valid_color(s):
    '''Return True if s is a valid Qt color string.'''
    if not s.startswith('#'):
        return False
    try:
        int(s[1:], 16)
        return True
    except ValueError:
        return False
</t>
<t tx="ekr.20190321124036.1"></t>
<t tx="ekr.20190321130021.1">###
    # from pygments.token import Comment, Keyword, Name, String\
        # Error, Number, Operator, Generic
    # from pygments.style import Style
# from pygments.util import add_metaclass
# from pygments.style import StyleMeta
import pygments.token as token_module
from leo.core.leoColor import leo_color_database
# Use the Leonine style.
### @add_metaclass(StyleMeta)

class LeonineStyle(object):
    default_style = ""
    table = (
        (token_module.Comment, 'firebrick3'),
        (token_module.Keyword, 'blue'),
        (token_module.Name, 'white'),
        # (token_module.Name.Function, '#0f0'),
        # (token_module.Name.Class, 'bold #0f0'),
        (token_module.String, '#00aa00'),
    )
    styles = {key: leo_color_database.get(val, val).strip('#') for (key,val) in table}
    _styles = styles ### a hack.
    g.printObj(styles, tag='LeonineStyle.styles')
    
    @others  # hack: just copy the methods from StyleMeta.
</t>
<t tx="ekr.20190321130235.2"># def __new__(mcs, name, bases, dct):
    # obj = type.__new__(mcs, name, bases, dct)
    # for token in STANDARD_TYPES:
        # if token not in obj.styles:
            # obj.styles[token] = ''

    # def colorformat(text):
        # if text in ansicolors:
            # return text
        # if text[0:1] == '#':
            # col = text[1:]
            # if len(col) == 6:
                # return col
            # elif len(col) == 3:
                # return col[0]*2 + col[1]*2 + col[2]*2
        # elif text == '':
            # return ''
        # assert False, "wrong color format %r" % text

    # _styles = obj._styles = {}

    # for ttype in obj.styles:
        # for token in ttype.split():
            # if token in _styles:
                # continue
            # ndef = _styles.get(token.parent, None)
            # styledefs = obj.styles.get(token, '').split()
            # if not ndef or token is None:
                # ndef = ['', 0, 0, 0, '', '', 0, 0, 0]
            # elif 'noinherit' in styledefs and token is not Token:
                # ndef = _styles[Token][:]
            # else:
                # ndef = ndef[:]
            # _styles[token] = ndef
            # for styledef in obj.styles.get(token, '').split():
                # if styledef == 'noinherit':
                    # pass
                # elif styledef == 'bold':
                    # ndef[1] = 1
                # elif styledef == 'nobold':
                    # ndef[1] = 0
                # elif styledef == 'italic':
                    # ndef[2] = 1
                # elif styledef == 'noitalic':
                    # ndef[2] = 0
                # elif styledef == 'underline':
                    # ndef[3] = 1
                # elif styledef == 'nounderline':
                    # ndef[3] = 0
                # elif styledef[:3] == 'bg:':
                    # ndef[4] = colorformat(styledef[3:])
                # elif styledef[:7] == 'border:':
                    # ndef[5] = colorformat(styledef[7:])
                # elif styledef == 'roman':
                    # ndef[6] = 1
                # elif styledef == 'sans':
                    # ndef[7] = 1
                # elif styledef == 'mono':
                    # ndef[8] = 1
                # else:
                    # ndef[0] = colorformat(styledef)

    # return obj

</t>
<t tx="ekr.20190321130235.3">def style_for_token(cls, token):
    try:
        t = cls._styles[token]
        ### color = t[0]
        color = t ### A big hack.
    except KeyError:
        color = None
    ansicolor = bgansicolor = None
    ###
        # if color.startswith('#ansi'):
            # ansicolor = color
            # color = _ansimap[color]
    ### bgcolor = t[4]
    ###
        # if bgcolor.startswith('#ansi'):
            # bgansicolor = bgcolor
            # bgcolor = _ansimap[bgcolor]

    return {
        'color':        color or None,
        'bold':         None, ### bool(t[1]),
        'italic':       None, ### bool(t[2]),
        'underline':    None, ### bool(t[3]),
        'bgcolor':      None, ### bgcolor or None,
        'border':       None, ### t[5] or None,
        'roman':        None, ### bool(t[6]) or None,
        'sans':         None, ### bool(t[7]) or None,
        'mono':         None, ### bool(t[8]) or None,
        'ansicolor':    ansicolor,
        'bgansicolor':  bgansicolor,
    }

</t>
<t tx="ekr.20190321130235.4">def list_styles(cls):
    return list(cls)

</t>
<t tx="ekr.20190321130235.5">def styles_token(cls, ttype):
    return ttype in cls._styles

</t>
<t tx="ekr.20190321130235.6">def __iter__(cls):
    for token in cls._styles:
        yield token, cls.style_for_token(token)

</t>
<t tx="ekr.20190321130235.7">def __len__(cls):
    return len(cls._styles)


</t>
<t tx="ekr.20190321170917.1">def patch_leo_styles(self, name, style):

    g.trace('style:', name, style)
    # g.printObj(style.list_styles(), tag='list_styles()')
    # g.printObj(dir(style), tag='style for %s' % name)
    leo_d = {
        'Comment': 'firebrick3',
        'Keyword': 'blue',
        'Name': 'white',
        # Name.Function: '#0f0',
        # Name.Class, 'bold #0f0',
        'String': '#00aa00',
    }
    style_d = {
        'color':        None,
        'bold':         None, ### bool(t[1]),
        'italic':       None, ### bool(t[2]),
        'underline':    None, ### bool(t[3]),
        'bgcolor':      None, ### bgcolor or None,
        'border':       None, ### t[5] or None,
        'roman':        None, ### bool(t[6]) or None,
        'sans':         None, ### bool(t[7]) or None,
        'mono':         None, ### bool(t[8]) or None,
        'ansicolor':    None,
        'bgansicolor':  None,
    }
    assert style_d
    if 0:
        for key in style.styles:
            key2 = repr(key).lstrip('Token.')
            if key2 in leo_d:
                val = leo_d.get(key2)
                g.trace('patch:', key, val)
                style.styles[key] = val
            else:
                style.styles[key] = ''
    if 0: # works, but won't be live.
        for data in style.list_styles():
            o, d = data
            g.printObj(d, tag='data.d')
    if 1:
        d = style.styles
        for key in d:
            g.printObj(d.get(key), tag=key)
    g.printObj(style._styles, tag='style._styles for %s' % name)
    # g.printObj(style.styles,  tag=' style.styles for %s' % name)</t>
<t tx="ekr.20190321182604.1"># These are the colors used in leo/themes/EKRDark.leo</t>
<t tx="ekr.20190321182604.10">@language md
&lt;style&gt;
div#bg {background:#3b0000}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.11">@language md
&lt;style&gt;
div#bg {background:#93a1a1}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.12">@language md
&lt;style&gt;
div#bg {background:#eee8d5}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.13">@language md
&lt;style&gt;
div#bg {background:#fdf6e3}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.14">@language md

&lt;!-- Not an official solarized color. --&gt;
&lt;!-- Same as dark-base-03 --&gt;

&lt;style&gt;
div#bg {background:#000005}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.15">@language md
&lt;style&gt;
div#bg {background:#268bd2}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.16">@language md
&lt;style&gt;
div#bg {background:#2aa198}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.17">@language md
&lt;style&gt;
div#bg {background:#859900}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.18">@language md
&lt;style&gt;
div#bg {background:#d33682}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.19">@language md
&lt;style&gt;
div#bg {background:#dc322f}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.2"></t>
<t tx="ekr.20190321182604.20">@language md
&lt;style&gt;
div#bg {background:#cb4b16}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.21">@language md
&lt;style&gt;
div#bg {background:#6c71c4}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.22">@language md

&lt;!-- Not an official solarized color. Same as solorarized-base3 --&gt;

&lt;style&gt;
div#bg {background:#fdf6e3}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.23">@language md
&lt;style&gt;
div#bg {background:#b58900}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.24"></t>
<t tx="ekr.20190321182604.25">@language md
&lt;style&gt;
div#bg {background:LightSteelBlue}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.26">@language md
&lt;style&gt;
div#bg {background:#00AA00}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.27">@language md
&lt;style&gt;
div#bg {background:LightYellow}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.28">Use a light color, not black!

@text-foreground
@solarized-white = #fdf6e3 
</t>
<t tx="ekr.20190321182604.29"></t>
<t tx="ekr.20190321182604.3">@language md
&lt;style&gt;
div#bg {background:#fdffdd}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.30"></t>
<t tx="ekr.20190321182604.31">Was @solarized-red

Terry: #dc322f</t>
<t tx="ekr.20190321182604.32"></t>
<t tx="ekr.20190321182604.33"></t>
<t tx="ekr.20190321182604.34"></t>
<t tx="ekr.20190321182604.35"></t>
<t tx="ekr.20190321182604.36"></t>
<t tx="ekr.20190321182604.37"></t>
<t tx="ekr.20190321182604.38"></t>
<t tx="ekr.20190321182604.39">Was @solarized-red
Terry: #268bd2</t>
<t tx="ekr.20190321182604.4">@language md
&lt;style&gt;
div#bg {background:#657b83}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.40"># Not an official solarized color: same as solorarized-base3</t>
<t tx="ekr.20190321182604.41"></t>
<t tx="ekr.20190321182604.42" lineYOffset="4b002e">These settings must exist because they are *not* used in the css.</t>
<t tx="ekr.20190321182604.43">These @color names map directly to the constants defined in each .py file in the leo/modes folder.

There is a script to generate these .py files directly from the jEdit .xml syntax coloring files.

These names can't be changed.  Leo's colorizing code leoColorizer.py uses these names to init various data structures.  The names are bound (in the modes/*.py files) to arguments to the pattern matches in leoColorizer.py.

Check the .py file in leo/modes for your langauge to see which names are actually used.
</t>
<t tx="ekr.20190321182604.44">#84c805: good enough.

#94e507: better, but a tad too bright.

#80cb07: too bright

#859900: real solarized green. Bad hue</t>
<t tx="ekr.20190321182604.45"></t>
<t tx="ekr.20190321182604.46"></t>
<t tx="ekr.20190321182604.47"></t>
<t tx="ekr.20190321182604.48">&lt;!-- Solarized blue: #268bd2 --&gt;

@language md
&lt;style&gt;
div#bg {background:#268bd2}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.49">was blue

Solarized blue      #268bd2</t>
<t tx="ekr.20190321182604.5">@language md
&lt;style&gt;
div#bg {background:#586e75}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.50">was blue

Solarized blue      #268bd2</t>
<t tx="ekr.20190321182604.51">was blue

Solarized blue      #268bd2</t>
<t tx="ekr.20190321182604.52">&lt;!-- #00aa00 (Idle comment green) --&gt;

&lt;!-- Solarize green      #859900 --&gt;

@language md
&lt;style&gt;
div#bg {background:#859900}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.53"></t>
<t tx="ekr.20190321182604.54"></t>
<t tx="ekr.20190321182604.55"></t>
<t tx="ekr.20190321182604.56">&lt;!-- was black --&gt;

@language md
&lt;style&gt;
div#bg {background:#268bd2}

&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.57">&lt;!-- was firebrick3 --&gt;
&lt;!-- magenta   #d33682 --&gt;

@language md
&lt;style&gt;
div#bg {background:#d33682}

&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.58"></t>
<t tx="ekr.20190321182604.59"></t>
<t tx="ekr.20190321182604.6">@language md
&lt;style&gt;
div#bg {background:#073642}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.60"></t>
<t tx="ekr.20190321182604.61"></t>
<t tx="ekr.20190321182604.62"># New: solarized-blue
</t>
<t tx="ekr.20190321182604.63"></t>
<t tx="ekr.20190321182604.64"></t>
<t tx="ekr.20190321182604.65">The color of text in doc parts.

firebrick3
</t>
<t tx="ekr.20190321182604.66">#80cb07
The color of Leo keywords such as @ignore, @color, etc.

#00aa00
</t>
<t tx="ekr.20190321182604.67">The color of name in &lt; &lt; name &gt; &gt; when name is defined.

red

</t>
<t tx="ekr.20190321182604.68">The background color that represents spaces when Show Invisibles mode is in effect.

gray80: #CCCCCC
gray90: #E5E5E5
</t>
<t tx="ekr.20190321182604.69">The foreground color that represents tabs when Show Invisibles mode is in effect.

gray80: #CCCCCC
gray90: #E5E5E5
</t>
<t tx="ekr.20190321182604.7">@language md
&lt;style&gt;
div#bg {background:#000005}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.70">The color of name in &lt;&lt; name &gt;&gt; when name is undefined.
</t>
<t tx="ekr.20190321182604.71">purple
</t>
<t tx="ekr.20190321182604.72"></t>
<t tx="ekr.20190321182604.73"># +</t>
<t tx="ekr.20190321182604.74"># -</t>
<t tx="ekr.20190321182604.75"># @@</t>
<t tx="ekr.20190321182604.76"># +++</t>
<t tx="ekr.20190321182604.77"># ---</t>
<t tx="ekr.20190321182604.78"></t>
<t tx="ekr.20190321182604.79">&lt;!-- Background color of log text. --&gt;

@language md
&lt;style&gt;
div#bg {background:#000005}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.8">@language md
&lt;style&gt;
div#bg {background:#000059}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.80">&lt;!-- Foreground color of log text. --&gt;

@language md
&lt;style&gt;
div#bg {background:#ffffff}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.81">@language md
&lt;style&gt;
div#bg {background:#000005}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.82">@language md
&lt;style&gt;
div#bg {background:#073642}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.83">@language md
&lt;style&gt;
div#bg {background:#fdffdd}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.84">@language md
&lt;style&gt;
div#bg {background:#eee8d5}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.85">Most widgets are colored in their css nodes.

Only colors appearing in several places are given here.</t>
<t tx="ekr.20190321182604.86">@language md
&lt;style&gt;
div#bg {background:#000005}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321182604.9">@language md
&lt;style&gt;
div#bg {background:#003b00}
&lt;/style&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
&lt;div id="bg"&gt;&lt;/div&gt;&lt;br&gt;
</t>
<t tx="ekr.20190321205442.1">@doc this is a docpart
Second line of docpart.
@c

@ Another doc part.
@c

g.cls()
from pygments.lexer import inherit
from pygments.lexers import Python3Lexer
from pygments.token import Comment

&lt;&lt; section reference &gt;&gt;

leo_tokens = {
    'root': [
       (r'\&lt;\&lt;.*\&gt;\&gt;', Comment.Leo.SectionRef),
       (r'(@doc|@)(\s+|\n)(.|\n)*?^@c', Comment.Leo.DocPart),
            # (.|\n)*? is a non-greedy match.
       inherit,
    ],
}

class LeoPython3Lexer(Python3Lexer):
    tokens = leo_tokens

lexer = LeoPython3Lexer()
for token, text in lexer.get_tokens(p.b):
    kind = repr(token).lstrip('Token.')
    if 'Leo' in kind:
        print('%30r %r' % (kind, text))
    </t>
<t tx="ekr.20190321205811.1"># Test.</t>
<t tx="ekr.20190322040433.1">@ignore
@nosearch
HEAD=0ff672b0a</t>
<t tx="ekr.20190322040433.10">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -16,6 +16,7 @@
         # g.trace('===== new lexer:', self._lexer)
         # g.printObj(dir(self._lexer))
     lexer = self._lexer
+    # g.printObj(lexer.tokens ['root'])
     if trace:
         print('\npyg_c.mainLoop: count: %s line: %r' % (self.recolorCount, s))
         prev_state = highlighter.previousBlockState()
@language python
</t>
<t tx="ekr.20190322040433.11">lexer_dict = {}
    # Keys are language names, values are instantiated lexers.
state_s_dict = {}
    # Keys are strings, values are ints.
state_n_dict = {}
    # For tracing only.
    # Keys are ints, values are strings.
state_index = 1

def mainLoop(self, s):
    '''Colorize a *single* line s'''
    trace = False and g.pygments and not g.unitTesting
    highlighter = self.highlighter
    if not getattr(self, '_lexer', None):
        self._lexer = Lexer() ### To be generalized.
        # g.trace('===== new lexer:', self._lexer)
        # g.printObj(dir(self._lexer))
    lexer = self._lexer
    if trace:
        print('\npyg_c.mainLoop: count: %s line: %r' % (self.recolorCount, s))
        prev_state = highlighter.previousBlockState()
        prev_state_s = self.state_n_dict.get(prev_state, "&lt;no state&gt;")
        print('prev state: %r: %s' % (prev_state, prev_state_s))
    #
    # Lex the text using Pygments.
    #
    # Based on code copyright (c) Jupyter Development Team.
    # Distributed under the terms of the Modified BSD License.
    stack_ivar = '_saved_state_stack'
    prev_data = highlighter.currentBlock().previous().userData()
    if prev_data is not None:
        # if trace: print('prev data:', prev_data)
        setattr(lexer, stack_ivar, prev_data.syntax_stack)
    elif hasattr(self._lexer, stack_ivar):
        delattr(self._lexer, stack_ivar)
    index = 0
    for token, text in self._lexer.get_tokens(s):
        length = len(text)
        # if trace: print('%25r %r' % (repr(token).lstrip('Token.'), text))
        format = highlighter._get_format(token)
        highlighter.setFormat(index, length, format)
        index += length
    stack = getattr(self._lexer, stack_ivar, None)
    if stack:
        data = PygmentsBlockUserData(syntax_stack=stack)
        ### if trace: print('new data:', data)
        highlighter.currentBlock().setUserData(data)
        # Clean up for the next go-round.
        delattr(self._lexer, stack_ivar)
    #
    # New code by EKR.
    state_s = '%s; %r' % (self.language, stack)
    state_n = self.state_s_dict.get(state_s)
    if state_n is None:
        state_n = self.state_index
        self.state_index += 1
        self.state_s_dict [state_s] = state_n
        self.state_n_dict [state_n] = state_s
    highlighter.setCurrentBlockState(state_n)
</t>
<t tx="ekr.20190322040433.2">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -2961,6 +2961,7 @@
             # g.trace('===== new lexer:', self._lexer)
             # g.printObj(dir(self._lexer))
         lexer = self._lexer
+        # g.printObj(lexer.tokens ['root'])
         if trace:
             print('\npyg_c.mainLoop: count: %s line: %r' % (self.recolorCount, s))
             prev_state = highlighter.previousBlockState()
@language python
</t>
<t tx="ekr.20190322040433.9"></t>
<t tx="tbrown.20110621120042.22914">def get_top_splitter(self):
    '''Return the top splitter of c.frame.top.'''
    # Careful: we could be unit testing.
    f = self.c.frame
    if hasattr(f, 'top') and f.top:
        return f.top.findChild(NestedSplitter).top()
    else:
        return None
</t>
<t tx="tbrown.20111011094944.27031">def tab_callback(self):
    '''Called when user hits tab on an item in the QListWidget.'''
    c = self.leo_c
    w = c.k.autoCompleter.w or c.frame.body.wrapper # 2014/09/19
    if w is None: return
    # Replace the tail of the prefix with the completion.
    # completion = g.u(self.currentItem().text())
    prefix = c.k.autoCompleter.get_autocompleter_prefix()
    parts = prefix.split('.')
    if len(parts) &lt; 2:
        return
    i = j = w.getInsertPoint()
    s = w.getAllText()
    while(0 &lt;= i &lt; len(s) and s[i] != '.'):
        i -= 1
    i += 1
    if j &gt; i:
        w.delete(i, j)
    w.setInsertPoint(i)
    c.k.autoCompleter.compute_completion_list()
</t>
<t tx="tbrown.20130411145310.18855">def wheelEvent(self, event):
    '''Handle a wheel event.'''
    if QtCore.Qt.ControlModifier &amp; event.modifiers():
        d = {'c': self.leo_c}
        if isQt5:
            point = event.angleDelta()
            delta = point.y() or point.x()
        else:
            delta = event.delta()
        if delta &lt; 0:
            zoom_out(d)
        else:
            zoom_in(d)
        event.accept()
        return
    QtWidgets.QTextBrowser.wheelEvent(self, event)
</t>
<t tx="tbrown.20150807090639.1">def declutter_node(self, c, p, item):
    """declutter_node - change the appearance of a node

    :param commander c: commander containing node
    :param position p: position of node
    :param QWidgetItem item: tree node widget item
    """
    if self.declutter_patterns is None:
        self.declutter_patterns = []
        warned = False
        lines = c.config.getData("tree-declutter-patterns")
        for line in lines:
            try:
                cmd, arg = line.split(None, 1)
            except ValueError:
                # Allow empty arg, and guard against user errors.
                cmd = line.strip()
                arg = ''
            if cmd.startswith('#'):
                pass
            elif cmd == 'RULE':
                self.declutter_patterns.append((re.compile(arg), []))
            else:
                if self.declutter_patterns:
                    self.declutter_patterns[-1][1].append((cmd, arg))
                elif not warned:
                    warned = True
                    g.log('Declutter patterns must start with RULE*',
                        color='error')
    text = str(item.text(0)) if g.isPython3 else g.u(item.text(0))
    new_icons = []
    for pattern, cmds in self.declutter_patterns:
        for func in (pattern.match, pattern.search):
            m = func(text)
            if m:
                for cmd, arg in cmds:
                    if self.declutter_replace(arg, cmd, item, m, pattern, text):
                        pass
                    else:
                        self.declutter_style(arg, c, cmd, item, new_icons)
                break # Don't try pattern.search if pattern.match succeeds.
    com = c.editCommands
    allIcons = com.getIconList(p)
    icons = [i for i in allIcons if 'visualIcon' not in i]
    if len(allIcons) != len(icons) or new_icons:
        for icon in new_icons:
            com.appendImageDictToList(
                icons, icon, 2, on='vnode', visualIcon='1'
            )
        com.setIconList(p, icons, False)
</t>
<t tx="tbrown.20170707150713.1">def match_trailing_ws(self, s, i):
    """match trailing whitespace"""
    j = i; n = len(s)
    while j &lt; n and s[j] in ' \t':
        j += 1
    if j &gt; i and j == n:
        self.colorRangeWithTag(s, i, j, 'trailing_whitespace')
        return j - i
    else:
        return 0
</t>
<t tx="tbrown.20171028115438.1">import leo.core.leoGlobals as g

try:
    # this can fix an issue with Qt Web views in Ubuntu
    from OpenGL import GL
    assert GL # To keep pyflakes happy.
except Exception:
    # but not need to stop if it doesn't work
    pass

import os

from collections import defaultdict

# pylint: disable=no-name-in-module
if g.isPython3:
    StringTypes = str
else:
    from types import StringTypes

from leo.core.leoQt import QtCore, QtWidgets, QtConst # QtGui
if QtCore is not None:
    from leo.plugins.editpane.clicky_splitter import ClickySplitter

if g.isPython3:
    from importlib import import_module

import leo.core.signal_manager as sig

</t>
<t tx="tbrown.20171028115438.26">def load_modules(self):
    """load_modules - load modules to find widgets
    """
    module_dir = os.path.dirname(__file__)
    names = [os.path.splitext(i) for i in os.listdir(module_dir)
             if os.path.isfile(os.path.join(module_dir, i))]
    # FIXME: sort 'plain' to start of list for devel.
    names.sort(key=lambda x: (not x[0].startswith('plain'), x[0]))
    modules = []
    for name in [i[0] for i in names if i[1].lower() == '.py']:
        try:
            if g.isPython3:
                modules.append(import_module('leo.plugins.editpane.'+name))
            else:
                try:
                    exec ( "import %s" % name )  # parens for Python 3 syntax
                    modules.append(locals()[name])
                except Exception:
                    pass
            DBG("Loaded module: %s" % name)
        except ImportError as err:
            DBG("Module not loaded (unmet dependencies?): %s" % name)

    for module in modules:
        for key in dir(module):
            value = getattr(module, key)
            if hasattr(value, 'lep_type') and value not in self.widget_classes:
                if module not in self.modules:
                    self.modules.append(module)
                self.widget_classes.append(value)
                self.widget_for[value.lep_type].append(value)
</t>
<t tx="ville.20090311195550.1">def filter_b(self, regex, flags=re.IGNORECASE):
    """ Find all the nodes in PosList self where body matches regex
    one or more times.

    """
    pat = re.compile(regex, flags)
    res = PosList()
    for p in self:
        m = re.finditer(pat, p.b)
        t1, t2 = itertools.tee(m, 2)
        try:
            if g.isPython3:
                t1.__next__()
            else:
                t1.next()
            pc = p.copy()
            pc.matchiter = t2
            res.append(pc)
        except StopIteration:
            pass
    return res
</t>
<t tx="ville.20090311200059.1">def find_b(self, regex, flags=re.IGNORECASE | re.MULTILINE):
    """ Return list (a PosList) of all nodes whose body matches regex
    one or more times.

    """
    c = self
    pat = re.compile(regex, flags)
    res = leoNodes.PosList()
    for p in c.all_positions():
        m = re.finditer(pat, p.b)
        t1, t2 = itertools.tee(m, 2)
        try:
            if g.isPython3:
                t1.__next__()
            else:
                t1.next()
        except StopIteration:
            continue
        pc = p.copy()
        pc.matchiter = t2
        res.append(pc)
    return res
</t>
<t tx="vitalije.20170703115609.1">def editRecentFiles(self, c):
    '''
    Dump recentFiles into new node appended as lastTopLevel, selects it and
    request focus in body.

    NOTE: command write-edited-recent-files assume that headline of this
    node is not changed by user.
    '''
    rf = self
    nl = '\n' if g.isPython3 else g.u('\n')
    p1 = c.lastTopLevel().insertAfter()
    p1.h = self.edit_headline
    p1.b = nl.join(rf.recentFiles)
    c.redraw()
    c.selectPosition(p1)
    c.redraw()
    c.bodyWantsFocusNow()
    g.es('edit list and run write-rff to save recentFiles')
</t>
<t tx="vitalije.20170705075107.1">def decodePosition(self, s):
    '''Creates position from its string representation encoded by fc.encodePosition.'''
    fc = self
    if not s:
        return fc.c.rootPosition()
    sep = g.u('&lt;-&gt;')
    comma = g.u(',')
    stack = [x.split(comma) for x in s.split(sep)]
    stack = [(fc.gnxDict[x], int(y)) for x,y in stack]
    v, ci = stack[-1]
    p = leoNodes.Position(v, ci, stack[:-1])
    return p
</t>
<t tx="vitalije.20170705075117.1">def encodePosition(self, p):
    '''New schema for encoding current position hopefully simplier one.'''
    jn = g.u('&lt;-&gt;')
    mk = g.u('%s,%s')
    res = [mk%(x.gnx, y) for x,y in p.stack]
    res.append(mk%(p.gnx, p._childIndex))
    return jn.join(res)
</t>
<t tx="vitalije.20170708161511.1">def handleInputShortcut(self, event, stroke):
    c, k, p = self.c, self, self.c.p
    k.clearState()
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        assert m # edit-shortcut was invoked on a malformed body line
        sel = g.u('%s %s\n')%(m.group(0), stroke.s)
        udata = c.undoer.beforeChangeNodeContents(p)
        w.setSelectionAreas(before, sel, after)
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        w.onBodyChanged('change shortcut')
        cmdname = m.group(0).rstrip('= ')
        k.editShortcut_do_bind_helper(stroke, cmdname)
        return
    elif p.h.startswith(('@command', '@button')):
        udata = c.undoer.beforeChangeNodeContents(p)
        cmd = p.h.split(g.u('@key'),1)[0]
        p.h = g.u('%s @key=%s')%(cmd, stroke.s)
        c.undoer.afterChangeNodeContents(p, 'change shortcut', udata)
        try:
            cmdname = cmd.split(' ', 1)[1].strip()
            k.editShortcut_do_bind_helper(stroke, cmdname)
        except IndexError:
            pass
        return
    else:
        # this should never happen
        g.error('not in settings node shortcut')
</t>
<t tx="vitalije.20170709151653.1">_cmd_handle_input_pattern = re.compile(g.u('[A-Za-z0-9_\\-]+\\s*='))

def isInShortcutBodyLine(self):
    k = self; c = k.c; p = c.p
    if p.h.startswith(('@shortcuts', '@mode')):
        # line of text in body
        w = c.frame.body
        before, sel, after = w.getInsertLines()
        m = k._cmd_handle_input_pattern.search(sel)
        return bool(m)
    return p.h.startswith(('@command', '@button'))
</t>
<t tx="vitalije.20170709151658.1">def isEditShortcutSensible(self):
    k = self; c = k.c; p = c.p
    return p.h.startswith(('@command', '@button')) or k.isInShortcutBodyLine()
</t>
<t tx="vitalije.20170709202924.1">def editShortcut_do_bind_helper(self, stroke, cmdname):
    k = self; c = k.c
    cmdfunc = c.commandsDict.get(cmdname)
    if cmdfunc:
        k.bindKey('all', stroke, cmdfunc, cmdname)
        g.es('bound', stroke, 'to command', cmdname)
</t>
<t tx="vitalije.20170716201700.3">def __init__(self, root):
    """
    Init the SqlitePickleShare class.
    root: The directory that contains the data. Created if it doesn't exist.
    """
    self.root = abspath(expanduser(root))
    if not isdir(self.root) and not g.unitTesting:
        self._makedirs(self.root)
    dbfile = ':memory:' if g.unitTesting else join(root, 'cache.sqlite')
    self.conn = sqlite3.connect(dbfile, isolation_level=None)
    self.init_dbtables(self.conn)
    self.cache = {}
        # Keys are normalized file names.
        # Values are tuples (obj, orig_mod_time)

    def loadz(data):
        if data:
            try:
                val = pickle.loads(zlib.decompress(data))
            except (ValueError, TypeError):
                g.es("Unpickling error - Python 3 data accessed from Python 2?")
                return None
            return val
        else:
            return None

    def dumpz(val):
        try:
            # use Python 2's highest protocol, 2, if possible
            data = pickle.dumps(val, protocol=2)
        except Exception:
            # but use best available if that doesn't work (unlikely)
            data = pickle.dumps(val, pickle.HIGHEST_PROTOCOL)
        return sqlite3.Binary(zlib.compress(data))

    self.loader = loadz
    self.dumper = dumpz
    if g.isPython3:
        self.reset_protocol_in_values()
</t>
</tnodes>
</leo_file>
