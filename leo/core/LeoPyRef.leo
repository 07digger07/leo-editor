<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20051031040240"><vh>Startup</vh>
<v t="ekr.20080412053100.5"><vh>@settings</vh>
<v t="ekr.20140920064112.17946"><vh>@int fts_max_hits = 100</vh></v>
<v t="ekr.20140919093158.17876"><vh>@int max-pre-loaded-body-chars = 0</vh></v>
<v t="ekr.20140916101314.19538"><vh>@string target_language = python</vh></v>
<v t="ekr.20140902155015.18674"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20131111060930.18010"><vh>@shortcuts</vh></v>
<v t="ekr.20131121084830.16362"><vh>@button toggle-debug</vh></v>
</v>
<v t="ekr.20140103105930.16446"><vh>@views</vh>
<v t="ekr.20140102162014.16438"><vh>@view added strip_comments keyword arg to two config.getData methods</vh></v>
</v>
<v t="ekr.20140808103117.18035"><vh>@persistence</vh>
<v t="ekr.20140808103117.18036"><vh>@data:@auto ../test/qtui_generate.py</vh>
<v t="ekr.20141010071140.31027"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18038"><vh>@data:@auto ../plugins/qt_main.py</vh>
<v t="ekr.20141010071140.31028"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18040"><vh>@data:@auto ../plugins/qt_main.ui</vh>
<v t="ekr.20141010071140.31029"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18042"><vh>@data:@auto ../plugins/qt_quicksearch.py</vh>
<v t="ekr.20141010071140.31030"><vh>@gnxs</vh></v>
</v>
<v t="ekr.20140808103117.18044"><vh>@data:@auto ../plugins/qt_quicksearch.ui</vh>
<v t="ekr.20141010071140.31031"><vh>@gnxs</vh></v>
</v>
</v>
<v t="ekr.20140923085942.17943"><vh>Recent scripts</vh>
<v t="ekr.20140905060158.18560"><vh>Script: change body.x to body.wrapper.x</vh>
<v t="ekr.20140905060158.18561"><vh>test</vh></v>
</v>
<v t="ekr.20140918124632.19450"><vh>Script: print Qt color names</vh></v>
</v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@file ../doc/leoNotes.txt</vh></v>
</v>
<v t="ekr.20100120072650.6088"><vh>Projects</vh>
<v t="ekr.20100120072650.6089"><vh>@file ../doc/leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20100119205347.6015"><vh>@file ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20140903025053.18625"><vh>Recent code</vh>
<v t="ekr.20140913054442.17860"><vh>class StyleSheetManager</vh>
<v t="ekr.20140912110338.19371"><vh>ssm.__init__</vh></v>
<v t="ekr.20110605121601.18176"><vh>ssm.default_style_sheet</vh></v>
<v t="ekr.20140915062551.19510"><vh>ssm.expand_css_constants &amp; helpers</vh>
<v t="tbrown.20131120093739.27085"><vh>ssm.find_constants_referenced</vh></v>
<v t="tbrown.20130411121812.28335"><vh>ssm.find_constants_defined (no longer used)</vh></v>
</v>
<v t="ekr.20140916170549.19551"><vh>ssm.get_data</vh></v>
<v t="ekr.20140913054442.19390"><vh>ssm.get_master_widget</vh></v>
<v t="ekr.20140912110338.19365"><vh>ssm.get_stylesheet &amp; helpers</vh>
<v t="ekr.20140912110338.19368"><vh>ssm.find_themes</vh></v>
<v t="ekr.20140912110338.19367"><vh>ssm.get_last_style_sheet</vh></v>
<v t="ekr.20140912110338.19366"><vh>ssm.get_last_theme</vh></v>
</v>
<v t="ekr.20140916170549.19552"><vh>ssm.get_style_sheet_from_settings</vh></v>
<v t="ekr.20140912110338.19372"><vh>ssm.munge</vh></v>
<v t="ekr.20140915194122.19476"><vh>ssm.print_style_sheet</vh></v>
<v t="ekr.20140912110338.19370"><vh>ssm.reload_style_sheets</vh></v>
<v t="ekr.20140913054442.19391"><vh>ssm.set selected_style_sheet</vh></v>
<v t="ekr.20110605121601.18175"><vh>ssm.set_style_sheets</vh></v>
</v>
<v t="ekr.20140816165728.18940"><vh>class GetArg</vh>
<v t="ekr.20140818052417.18241"><vh>ga.birth</vh>
<v t="ekr.20140816165728.18952"><vh>ga.__init__</vh></v>
</v>
<v t="ekr.20140817110228.18321"><vh>ga.compute_tab_list</vh></v>
<v t="ekr.20140816165728.18965"><vh>ga.do_back_space (entry)</vh></v>
<v t="ekr.20140817110228.18323"><vh>ga.do_tab (entry) &amp; helpers</vh>
<v t="ekr.20140818145250.18235"><vh>ga.do_tab_callback</vh></v>
<v t="ekr.20140819050118.18317"><vh>ga.do_tab_cycling</vh></v>
<v t="ekr.20140819050118.18318"><vh>ga.reset_tab_cycling</vh></v>
</v>
<v t="ekr.20140816165728.18958"><vh>ga.extend/get/set_label</vh></v>
<v t="ekr.20140816165728.18941"><vh>ga.get_arg (entry) &amp; helpers</vh>
<v t="ekr.20140822051549.18299"><vh>&lt;&lt; ga.get_arg docstring &gt;&gt;</vh></v>
<v t="ekr.20140816165728.18955"><vh>ga.do_char</vh></v>
<v t="ekr.20140817110228.18316"><vh>ga.do_end</vh></v>
<v t="ekr.20140817110228.18317"><vh>ga.do_state_zero</vh></v>
<v t="ekr.20140818103808.18234"><vh>ga.should_end</vh></v>
<v t="ekr.20140818103808.18235"><vh>ga.trace_state</vh></v>
</v>
<v t="ekr.20140818074502.18222"><vh>ga.get_command</vh></v>
<v t="ekr.20140818085719.18227"><vh>ga.get_minibuffer_command_name</vh></v>
<v t="ekr.20140818074502.18221"><vh>ga.is_command</vh></v>
<v t="ekr.20140816165728.18959"><vh>ga.show_tab_list</vh></v>
</v>
<v t="ekr.20061031131434.112"><vh>callAltXFunction</vh></v>
<v t="ekr.20141012064706.18240"><vh>Bug 35</vh>
<v t="ekr.20031218072017.1991"><vh>class NodeIndices</vh>
<v t="ekr.20031218072017.1992"><vh>NodeIndices.__init__</vh></v>
<v t="ekr.20031218072017.1994"><vh>ni.get/setDefaultId</vh></v>
<v t="ekr.20031218072017.1995"><vh>ni.getNewIndex</vh></v>
<v t="ekr.20031218072017.1997"><vh>ni.scanGnx</vh></v>
<v t="ekr.20031218072017.1998"><vh>ni.setTimeStamp</vh></v>
<v t="ekr.20031218072017.1999"><vh>ni.toString</vh></v>
</v>
<v t="ekr.20031218072017.1553"><vh>fc.getLeoFile &amp; helpers</vh>
<v t="ekr.20090526081836.5841"><vh>fc.getLeoFileHelper</vh></v>
<v t="ekr.20100205060712.8314"><vh>fc.handleNodeConflicts &amp; helper</vh>
<v t="ekr.20100701112151.5959"><vh>getDiff</vh></v>
</v>
<v t="ekr.20100124110832.6212"><vh>fc.propegateDirtyNodes</vh></v>
<v t="ekr.20120212220616.10537"><vh>fc.readExternalFiles</vh></v>
<v t="ekr.20141012064706.18242"><vh>fc.setMaxNodeIndex</vh></v>
<v t="ekr.20031218072017.1554"><vh>fc.warnOnReadOnlyFiles</vh></v>
</v>
</v>
<v t="ekr.20131016032805.16721"><vh>g.execute_shell_commands</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20140902032918.18591"><vh> About this file</vh>
<v t="ekr.20140831085423.18639"><vh>&lt;&lt; about widgets and wrappers &gt;&gt;</vh></v>
<v t="ekr.20140831085423.18630"><vh>&lt;&lt; terminology &gt;&gt;</vh></v>
<v t="ekr.20140831085423.18631"><vh>&lt;&lt; official ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes</vh>
<v t="ekr.20031218072017.2608"><vh>@file leoApp.py</vh></v>
<v t="ekr.20141012064706.18389"><vh>@file leoAst.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@file leoAtFile.py</vh></v>
<v t="ekr.20070227091955.1"><vh>@file leoBridge.py</vh></v>
<v t="ekr.20100208065621.5894"><vh>@file leoCache.py</vh></v>
<v t="ekr.20070317085508.1"><vh>@file leoChapters.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@file leoColor.py</vh></v>
<v t="ekr.20140827092102.18574"><vh>@file leoColorizer.py</vh></v>
<v t="ekr.20031218072017.2810"><vh>@file leoCommands.py</vh></v>
<v t="ekr.20130925160837.11429"><vh>@file leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@file leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@file leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093" descendentVnodeUnknownAttributes="7d71005506302e31352e3071017d71025808000000616e6e6f7461746571037d710473732e"
marks="ekr.20130111185820.10194,"><vh>@file leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@file leoImport.py</vh></v>
<v t="ekr.20120401063816.10072"><vh>@file leoIPython.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@file leoNodes.py</vh></v>
<v t="ekr.20140821055201.18331"><vh>@file leoPersistence.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@file leoPlugins.py</vh></v>
<v t="ekr.20061024060248.1"><vh>@file leoPymacs.py</vh></v>
<v t="ekr.20140810053602.18074"><vh>@file leoQt.py</vh></v>
<v t="ekr.20140526082700.18440"><vh>@file leoRope.py</vh></v>
<v t="ekr.20090502071837.3"><vh>@file leoRst.py</vh></v>
<v t="ekr.20120420054855.14241" descendentVnodeUnknownAttributes="7d7100285505302e332e3271017d71022858090000007374725f6374696d657103580c000000313331393436303438332e30710458090000007374725f6d74696d657105580d000000313331393436373035302e3438710658090000007374725f6174696d657107580d000000313331393436373035302e34387108755505302e332e3371097d710a2858090000007374725f6374696d65710b580c000000313331393436303438332e30710c58090000007374725f6d74696d65710d580d000000313332303432323639302e3534710e58090000007374725f6174696d65710f580d000000313332303433343235372e33367110755505302e332e3071117d71122858090000007374725f6374696d657113580c000000313331393439313330362e30711458090000007374725f6d74696d657115580d000000313331393439323330312e3532711658090000007374725f6174696d657117580d000000313331393534393339302e38397118755505302e332e3171197d711a2858090000007374725f6374696d65711b580c000000313331393436303438332e30711c58090000007374725f6d74696d65711d580d000000313331393436373033382e3235711e58090000007374725f6174696d65711f580c000000313332303432323637302e397120755505302e332e3471217d71222858090000007374725f6374696d657123580c000000313331393633383634382e30712458090000007374725f6d74696d657125580d000000313331393634313038352e3038712658090000007374725f6174696d657127580c000000313331393634353330362e327128755505302e332e3571297d712a2858090000007374725f6374696d65712b580c000000313331393633383634382e30712c58090000007374725f6d74696d65712d580c000000313331393634313131372e39712e58090000007374725f6174696d65712f580d000000313331393634313435352e3937713075752e"><vh>@file leoSessions.py</vh></v>
<v t="ekr.20080708094444.1"><vh>@file leoShadow.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@file leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@file leoUndo.py</vh></v>
<v t="ekr.20131109170017.16504"><vh>@file leoVim.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@file leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@file leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@file leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@file leoGui.py</vh></v>
<v t="ekr.20061031131434"><vh>@file leoKeys.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@file leoMenu.py</vh></v>
</v>
<v t="ekr.20110605121601.17862"><vh>Qt gui</vh>
<v t="ekr.20120419093256.10048"><vh>@file ../plugins/free_layout.py</vh></v>
<v t="ekr.20110605121601.17954"><vh>@file ../plugins/nested_splitter.py</vh></v>
<v t="ekr.20140919181357.24956"><vh>@file ../plugins/qt_big_text.py</vh></v>
<v t="ekr.20110605121601.17996"><vh>@file ../plugins/qt_commands.py</vh></v>
<v t="ekr.20140907103315.18766"><vh>@file ../plugins/qt_events.py</vh></v>
<v t="ekr.20140907123524.18774"><vh>@file ../plugins/qt_frame.py</vh></v>
<v t="ekr.20140907085654.18699"><vh>@file ../plugins/qt_gui.py</vh></v>
<v t="ekr.20140907103315.18777"><vh>@file ../plugins/qt_idle_time.py</vh></v>
<v t="ekr.20140907123524.18777"><vh>@file ../plugins/qt_quickheadlines.py</vh></v>
<v t="ekr.20140831085423.18598"><vh>@file ../plugins/qt_text.py</vh></v>
<v t="ekr.20140907131341.18707"><vh>@file ../plugins/qt_tree.py</vh></v>
<v t="ekr.20110605121601.18002"><vh>@file ../plugins/qtGui.py</vh></v>
<v t="ekr.20110605121601.18695"><vh>QDesigner files</vh>
<v t="ekr.20110605121601.18696"><vh>@auto ../test/qtui_generate.py</vh></v>
<v t="ekr.20110605121601.18698"><vh>@auto ../plugins/qt_main.py</vh></v>
<v t="ekr.20110605121601.18703"><vh>@auto ../plugins/qt_main.ui</vh></v>
<v t="ekr.20110605121601.18704"><vh>@auto ../plugins/qt_quicksearch.py</vh></v>
<v t="ekr.20110605121601.18709"><vh>@auto ../plugins/qt_quicksearch.ui</vh></v>
</v>
</v>
<v t="ekr.20090802181029.5989"><vh>Startup &amp; external files</vh>
<v t="ekr.20110310091639.14254"><vh>@file ../external/codewise.py</vh></v>
<v t="ekr.20130805134749.12436"><vh>@file ../external/edb.py</vh></v>
<v t="ekr.20120519121124.9919"><vh>@file ../external/leosax.py</vh></v>
<v t="ville.20091010232339.6117"><vh>@file ../external/lproto.py</vh></v>
<v t="ekr.20141010141310.18627"><vh>@file ../external/PythonTidy.py</vh></v>
<v t="ekr.20031218072017.2605"><vh>@file runLeo.py </vh></v>
</v>
<v t="ekr.20080730161153.8"><vh>Testing</vh>
<v t="ekr.20100221142603.5638"><vh>@file ../../pylint-leo.py</vh></v>
<v t="ekr.20080730161153.2"><vh>@file leoBridgeTest.py</vh></v>
<v t="ekr.20080730161153.5"><vh>@file leoDynamicTest.py</vh></v>
<v t="ekr.20051104075904" descendentVnodeUnknownAttributes="7d710055013071017d71025808000000616e6e6f746174657103285808000000616e6e6f7461746571047d710574710673732e"><vh>@file leoTest.py</vh></v>
</v>
<v t="ekr.20090802181029.5988"><vh>Version</vh>
<v t="ekr.20090717092906.12765"><vh>@file leoVersion.py</vh></v>
</v>
</v>
<v t="ekr.20140907201613.18661"><vh>Recent files</vh>
<v t="ekr.20141010141310.18627"></v>
<v t="ekr.20031218072017.2608"></v>
<v t="ekr.20041005105605.1"></v>
<v t="ekr.20031218072017.3018"></v>
<v t="ekr.20061031131434"></v>
<v t="ekr.20031218072017.3320"></v>
</v>
<v t="ekr.20140917180536.19478"><vh>Stashed to-do</vh>
<v t="ekr.20140917154740.17918"><vh>* To do: Leo 5.0a1</vh>
<v t="ekr.20140824043305.18293"><vh>Docs for a1</vh>
<v t="ekr.20140910065834.18124"><vh>Document recent tags work</vh></v>
<v t="ekr.20130806072439.20414"><vh>Document: Cannot open Leo files by double-click in Windows Explorer?</vh>
<v t="ekr.20130806072439.20415"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20416"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20417"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20418"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20419"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20420"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20421"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20422"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20424"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20425"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20426"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
<v t="ekr.20130806072439.20427"><vh>Re: Cannot open Leo files by double-click in Windows Explorer?</vh></v>
</v>
<v t="ekr.20130806072439.20514"><vh>Newbie Leo questions for php projects</vh></v>
<v t="ekr.20130806211959.17359"><vh>User comments</vh>
<v t="ekr.20130807090137.11464"><vh>From Vili</vh></v>
<v t="ekr.20130806211959.17360"><vh>Blog post about how Leo can improve organization of code bases</vh>
<v t="ekr.20130806211959.17363"><vh>Re: Blog post about how Leo can improve organization of code bases</vh></v>
<v t="ekr.20130806211959.17364"><vh>Re: Blog post about how Leo can improve organization of code bases</vh></v>
</v>
<v t="ekr.20130806211959.17365"><vh>Leo as PIM and authoring tool</vh></v>
<v t="ekr.20130806211959.17366"><vh>persistent state with json as a leo abbreviation</vh>
<v t="ekr.20130806211959.17369"><vh>Re: persistent state with json as a leo abbreviation</vh></v>
</v>
<v t="ekr.20130806211959.17370"><vh>why Leo</vh>
<v t="ekr.20130806211959.17371"><vh>Fw: why Leo</vh>
<v t="ekr.20130806211959.17374"><vh>Re: why Leo</vh></v>
</v>
</v>
<v t="ekr.20130806211959.17375"><vh>Fidel's first post</vh></v>
</v>
<v t="ekr.20130806211959.17307"><vh>Help (For FAQ?)</vh>
<v t="ekr.20130807203905.16678"><vh>For Implementors</vh>
<v t="ekr.20130807203905.16679"><vh>Centralizing focus handling (to make debugging easier)</vh></v>
<v t="ekr.20130807203905.16681"><vh>Free "continuous integration" for Leo</vh></v>
<v t="ekr.20130807203905.16684"><vh>Toolkit independent apis</vh></v>
</v>
<v t="ekr.20130806211959.17315"><vh>Background Images in body pane?</vh>
<v t="ekr.20130806211959.17316"><vh>Re: Background Images in body pane?</vh></v>
<v t="ekr.20130806211959.17317"><vh>Re: Background Images in body pane?</vh></v>
<v t="ekr.20130806211959.17318"><vh>Re: Background Images in body pane?</vh></v>
</v>
<v t="ekr.20130806211959.17319"><vh>Best way to synchronize/update myLeoSettings.leo and leoSettings.leo ?</vh></v>
<v t="ekr.20130806211959.17320"><vh>Create Pane For matplotlib chart</vh>
<v t="ekr.20130806211959.17321"><vh>Re: Create Pane For matplotlib chart</vh></v>
<v t="ekr.20130806211959.17323"><vh>Re: Create Pane For matplotlib chart</vh></v>
<v t="ekr.20130806211959.17324"><vh>Re: Create Pane For matplotlib chart</vh></v>
</v>
<v t="ekr.20130806211959.17325"><vh>How to call functions from LeoPyRef.Leo</vh>
<v t="ekr.20130806211959.17326"><vh>Re: How to call functions from LeoPyRef.Leo</vh></v>
<v t="ekr.20130806211959.17327"><vh>Re: How to call functions from LeoPyRef.Leo</vh></v>
<v t="ekr.20130806211959.17328"><vh>Re: How to call functions from LeoPyRef.Leo</vh></v>
<v t="ekr.20130806211959.17329"><vh>Re: How to call functions from LeoPyRef.Leo</vh></v>
<v t="ekr.20130806211959.17330"><vh>Re: How to call functions from LeoPyRef.Leo</vh></v>
</v>
<v t="ekr.20130806211959.17331"><vh>How to make body text insertion at cursor permanent?</vh>
<v t="ekr.20130806211959.17332"><vh>Re: How to make body text insertion at cursor permanent?</vh></v>
<v t="ekr.20130806211959.17333"><vh>Re: How to make body text insertion at cursor permanent?</vh></v>
<v t="ekr.20130806211959.17334"><vh>Re: How to make body text insertion at cursor permanent?</vh></v>
<v t="ekr.20130806211959.17335"><vh>Re: the workflow of write leo scripts?</vh></v>
</v>
<v t="ekr.20130806211959.17336"><vh>How to use leo to make mathematical notes?</vh></v>
<v t="ekr.20130806211959.17337"><vh>Indexing files for full text search</vh></v>
<v t="ekr.20130806211959.17339"><vh>Parameterized template nodes</vh>
<v t="ekr.20130806211959.17340"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806211959.17341"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806211959.17342"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806211959.17343"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806211959.17344"><vh>Re: Parameterized template nodes</vh></v>
<v t="ekr.20130806211959.17345"><vh>Re: Parameterized template nodes</vh></v>
</v>
<v t="ekr.20130806211959.17346"><vh>Terry, how do you create the buttons with dropdown menus?</vh>
<v t="ekr.20130806211959.17347"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
<v t="ekr.20130806211959.17349"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
<v t="ekr.20130806211959.17350"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
<v t="ekr.20130806211959.17351"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
<v t="ekr.20130806211959.17352"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
<v t="ekr.20130806211959.17353"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
<v t="ekr.20130806211959.17355"><vh>Re: Terry, how do you create the buttons with dropdown menus?</vh></v>
</v>
<v t="ekr.20130806211959.17356"><vh>the workflow of write leo scripts?</vh></v>
<v t="ekr.20130806211959.17357"><vh>Tool for diffing Leo files</vh>
<v t="ekr.20130806211959.17358"><vh>Re: Tool for diffing Leo files</vh></v>
</v>
<v t="ekr.20130806072439.20488"><vh>Issue 1 with build 5752 (docutils &amp; rst3)</vh></v>
</v>
<v t="ekr.20140824043305.18294"><vh>Do document</vh>
<v t="ekr.20130807203905.16656"><vh>A beautiful pattern for composing large strings</vh>
<v t="ekr.20130807203905.16657"><vh>Re: A beautiful pattern for composing large strings</vh></v>
<v t="ekr.20130807203905.16659"><vh>Re: A beautiful pattern for composing large strings</vh></v>
<v t="ekr.20130807203905.16660"><vh>Re: A beautiful pattern for composing large strings</vh></v>
<v t="ekr.20130807203905.16662"><vh>Re: A beautiful pattern for composing large strings</vh></v>
<v t="ekr.20130807203905.16663"><vh>Re: A beautiful pattern for composing large strings</vh></v>
</v>
<v t="ekr.20130807203905.16664"><vh>All about clone conflicts</vh>
<v t="ekr.20130807203905.16665"><vh>Re: All about clone conflicts</vh></v>
</v>
<v t="ekr.20130807203905.16668"><vh>Draft: unit-testing tutorial</vh></v>
<v t="ekr.20130807203905.16669"><vh>Tutorials re plugins</vh></v>
</v>
<v t="ekr.20131220065609.16590"><vh>Add docstrings for all commands in leoSessions.py.</vh></v>
</v>
<v t="ekr.20140824043305.18300"><vh>Bugs for a1</vh>
<v t="ekr.20131027064821.18715"><vh>Autocompleter ? usually doesn't work</vh></v>
<v t="ekr.20131004191204.16078"><vh>cycle-all-focus doesn't work</vh></v>
<v t="ekr.20131103054650.16527"><vh>fill-region &amp; format-body can hang</vh></v>
<v t="ekr.20131025044901.17146"><vh>Clone-to-last-node</vh></v>
</v>
<v t="ekr.20141011053251.18205"><vh>Installer for a1</vh>
<v t="ekr.20050328093147.1"><vh>Report: improving installer (old??)</vh></v>
<v t="ekr.20130806072439.20732"><vh>** Runnable Leo in one .zip file w/ virtual machine</vh>
<v t="ekr.20130806072439.20736"><vh>Re: Runnable Leo in one .zip file.</vh></v>
<v t="ekr.20130806072439.20744"><vh>Re: Runnable Leo in one .zip file.</vh></v>
</v>
<v t="ekr.20130807203905.16594"><vh>Wishlist for newbies (Fidel)</vh></v>
<v t="ekr.20130806072439.20650"><vh>Wishlist: brew install leo</vh></v>
<v t="ekr.20130807203905.16596"><vh>PortableFileAssociator</vh></v>
</v>
</v>
<v t="ekr.20141011053251.18205"></v>
<v t="ekr.20141006073719.17938"><vh>** Fix import bugs</vh></v>
<v t="ekr.20140923144655.17926"><vh>** Fix find bugs</vh>
<v t="ekr.20140919052413.17945"><vh>Fix suboutline only find bug</vh>
<v t="ekr.20031218072017.3077"><vh>find.search &amp; helpers</vh>
<v t="ekr.20060526140328"><vh>passedWrapPoint</vh></v>
<v t="ekr.20060526081931"><vh>searchHelper &amp; allies</vh>
<v t="ekr.20060526092203"><vh>regexHelper</vh></v>
<v t="ekr.20060526140744"><vh>backwardsHelper</vh></v>
<v t="ekr.20060526093531"><vh>plainHelper</vh></v>
<v t="ekr.20060526140744.1"><vh>matchWord</vh></v>
<v t="ekr.20070105165924"><vh>replaceBackSlashes</vh></v>
</v>
</v>
</v>
<v t="ekr.20140921180304.17919"><vh>Find command *sometimes* doesn't scroll</vh></v>
</v>
<v t="ekr.20140922124047.19514"><vh>Later...</vh>
<v t="ekr.20140919145841.17947"><vh>** Remove klass hack</vh>
<v t="ekr.20061031131434.28"><vh>compute_completion_list &amp; helper</vh>
<v t="ekr.20110514051607.14524"><vh>get_cached_options</vh></v>
</v>
</v>
<v t="ekr.20140921132351.17921"><vh>** Review all important plugins</vh></v>
<v t="ekr.20140920041848.17923"><vh>** Fix help-for-command and improve docs</vh></v>
<v t="ekr.20140919052413.17946"><vh>** Revise leoBridge docs</vh>
<v t="ekr.20140922043414.17947"><vh>Solution 1</vh>
<v t="ekr.20140921072018.17943"><vh>leo_bridge_test.py (defined in ekr.leo)</vh></v>
</v>
<v t="ekr.20140922043414.17948"><vh>Solution 2 (test)</vh></v>
<v t="ekr.20140922043414.17949"><vh>Solution 0 (already documented)</vh></v>
</v>
<v t="ekr.20140921072018.17937"><vh>** New separate-process commands</vh>
<v t="ekr.20140921072018.17938"><vh>** Settings for at-produce plugin?</vh></v>
</v>
</v>
<v t="ekr.20141012064706.18243"><vh>** Priority 1: bugs affecting stability</vh></v>
<v t="ekr.20141012064706.18244"><vh>** Priority 2: distro projects</vh></v>
<v t="ekr.20141012064706.18245"><vh>** Priority 3: newbie improvements</vh></v>
<v t="ekr.20141012064706.18533"><vh>** Buy two fitbits</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="ekr.20031218072017.1553">def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):
    '''
        Read a .leo file.
        The caller should follow this with a call to c.redraw().
    '''
    fc,c = self,self.c
    c.setChanged(False) # May be set when reading @file nodes.
    fc.warnOnReadOnlyFiles(fileName)
    fc.checking = False
    fc.mFileName = c.mFileName
    fc.initReadIvars()
    try:
        c.loading = True # disable c.changed
        ok = True if silent else g.app.checkForOpenFile(c,fileName)
        if ok:
            ok = fc.getLeoFileHelper(theFile,fileName,silent)
                # Read the .leo file and create the outline.
            g.app.rememberOpenFile(fileName)
                # Remember the open file.
        else:
            fc.mFileName = c.mFileName = None
                # Bug fix. Clear the fileName so forgetOpenFile doesn't remove it.
        if ok:
            fc.resolveTnodeLists()
                # Do this before reading external files.
            c.setFileTimeStamp(fileName)
            if readAtFileNodesFlag:
                # Redraw before reading the @file nodes so the screen isn't blank.
                # This is important for big files like LeoPy.leo.
                c.redraw()
                fc.readExternalFiles(fileName)
            if c.config.getBool('check_outline_after_read'):
                c.checkOutline(event=None,verbose=True,unittest=False,full=True)
            fc.setMaxNodeIndex()
                # Fix bug https://github.com/leo-editor/leo-editor/issues/35
    finally:
        c.loading = False # reenable c.changed
        theFile.close()
            # Fix bug https://bugs.launchpad.net/leo-editor/+bug/1208942
            # Leo holding directory/file handles after file close?
    if c.changed:
        fc.propegateDirtyNodes()
    c.setChanged(c.changed) # Refresh the changed marker.
    fc.initReadIvars()
    return ok, c.frame.ratio
</t>
<t tx="ekr.20031218072017.1554">def warnOnReadOnlyFiles (self,fileName):

    # os.access may not exist on all platforms.

    try:
        self.read_only = not os.access(fileName,os.W_OK)
    except AttributeError:
        self.read_only = False
    except UnicodeError:
        self.read_only = False

    if self.read_only and not g.unitTesting:
        g.error("read only:",fileName)
</t>
<t tx="ekr.20031218072017.1991"># Indices are Python dicts containing 'id','loc','time' and 'n' keys.

class NodeIndices (object):

    """A class to implement global node indices (gnx's)."""

    @others
</t>
<t tx="ekr.20031218072017.1992">def __init__ (self,id_):

    """ctor for NodeIndices class"""

    self.userId = id_
    self.defaultId = id_
    self.lastIndex = 0
    self.timeString = '' # Set by setTimeStamp.

    # A Major simplification: Only assign the timestamp once.
    self.setTimeStamp()
    self.lastIndex = 0
</t>
<t tx="ekr.20031218072017.1994"># These are used by the FileCommands read/write code.

def getDefaultId (self):
    """Return the id to be used by default in all gnx's"""
    return self.defaultId

def setDefaultId (self,theId):
    """Set the id to be used by default in all gnx's"""
    self.defaultId = theId
</t>
<t tx="ekr.20031218072017.1995">def getNewIndex (self):
    '''Create a new gnx.'''
    self.lastIndex += 1
    d = (self.userId,self.timeString,self.lastIndex)
    # new gnxs:
    return g.toUnicode("%s.%s.%d" % d)
    # old gnxs: retain for reference:
    # return d
</t>
<t tx="ekr.20031218072017.1997">def scanGnx (self,s,i=0):
    """Create a gnx from its string representation."""
    if not g.isString(s):
        g.error("scanGnx: unexpected index type:",type(s),'',s)
        return None,None,None
    s = s.strip()
    theId,t,n = None,None,None
    i,theId = g.skip_to_char(s,i,'.')
    if g.match(s,i,'.'):
        i,t = g.skip_to_char(s,i+1,'.')
        if g.match(s,i,'.'):
            i,n = g.skip_to_char(s,i+1,'.')
    # Use self.defaultId for missing id entries.
    if theId == None or len(theId) == 0:
        theId = self.defaultId
    # Convert n to int.
    if n:
        try: n = int(n)
        except Exception: pass
    return theId,t,n
</t>
<t tx="ekr.20031218072017.1998">def setTimestamp (self):

    """Set the timestamp string to be used by getNewIndex until further notice"""
    
    trace = False
    prtF = False
    if g.app.db is None:
        g.app.setGlobalDb()
    lastTimeStamp = g.app.db.get('lastTimeStamp', '0')
    if prtF: print('lastTimeStamp={0}'.format(lastTimeStamp))
    newTimeStamp = time.strftime("%Y%m%d%H%M%S", time.localtime())
    if lastTimeStamp &gt;= newTimeStamp:
        if trace: g.trace('Time not increasing={0}'.format(newTimeStamp))
        if prtF: print('Time in Past={0}'.format(newTimeStamp))
        newTimeStamp = (datetime.datetime.strptime(lastTimeStamp,
            "%Y%m%d%H%M%S") + datetime.timedelta(seconds=1)).strftime(
            "%Y%m%d%H%M%S")
    g.app.db['lastTimeStamp'] = newTimeStamp
    self.timeString = newTimeStamp

    if trace: g.trace(newTimeStamp,self.lastIndex,g.callers(4))
    if prtF: print('newTimeStamp={0}'.format(newTimeStamp))

setTimeStamp = setTimestamp
</t>
<t tx="ekr.20031218072017.1999">def toString (self,index):
    '''
    Convert a tuple, string or None to its string representation.
    *Important* the present sax code and earlier versions of Leo
    use various kinds of tuples.  Do *not* change the tuple-related code!
    '''
    if g.isString(index): # new gnxs:
        return g.toUnicode(index)
    elif index is None: # new gnxs:
        return self.getNewIndex() 
    try:
        theId,t,n = index
        if n in (None,0,'',):
            s = "%s.%s" % (theId,t)
        else:
            s = "%s.%s.%d" % (theId,t,n)
    except Exception:
        if not g.app.unitTesting:
            g.trace('unusual gnx',repr(index),g.callers()) 
        try:
            theId,t,n = self.getNewIndex()
            if n in (None,0,'',):
                s = "%s.%s" % (theId,t)
            else:
                s = "%s.%s.%d" % (theId,t,n)
        except Exception:
            s = repr(index)
            g.trace('double exception: returning repr(index)',s)
    return g.toUnicode(s)
</t>
<t tx="ekr.20031218072017.2406" _bklnk="7d71002858010000007971014b0058010000007871024b00580400000074797065710358080000006e6f646552656374710458050000006c696e6b7371055d7106752e">@tabwidth -4
@pagewidth 70

# This file contains almost all of Leo's sources.
# See the "About this file" node for important notes.
</t>
<t tx="ekr.20031218072017.2604">
</t>
<t tx="ekr.20031218072017.3077">def search (self):
    """
    Search s_ctrl for self.find_text with present options.
    Returns (pos, newpos) or (None,None).
    """
    trace = False and not g.unitTesting
    c = self.c
    p = self.p or c.p.copy()
    w = self.s_ctrl
    index = w.getInsertPoint()
    s = w.getAllText()
    if sys.platform.lower().startswith('win'):
        s = s.replace('\r','')
            # Ignore '\r' characters, which may appear in @edit nodes.
            # Fixes this bug: https://groups.google.com/forum/#!topic/leo-editor/yR8eL5cZpi4
            # This hack would be dangerous on MacOs: it uses '\r' instead of '\n' (!)
    if s:
        if trace: g.trace('=====',index,repr(s[max(0,index-10):index+40]))
    else:
        if trace: g.trace('returning: no text',p.h)
        return None,None
    stopindex = 0 if self.reverse else len(s)
    pos,newpos = self.searchHelper(s,index,stopindex,self.find_text)
    if trace: g.trace('pos,newpos',pos,newpos)
    # Bug fix: 2013/11/23.
    if self.in_headline and not self.search_headline:
        if trace: g.trace('not searching headlines')
        return None,None
    if not self.in_headline and not self.search_body:
        if trace: g.trace('not searching bodies')
        return None,None
    if pos == -1:
        if trace: g.trace('Returning: pos is -1')
        return None,None
    if self.passedWrapPoint(p,pos,newpos):
        if trace:
            kind = 'reverse ' if self.reverse else ''
            g.trace("** %swrap done",kind,pos,newpos)
        self.wrapPosition = None # Reset.
        return None,None
    ins = min(pos,newpos) if self.reverse else max(pos,newpos)
    w.setSelectionRange(pos,newpos,insert=ins)
    if trace: g.trace('** returns',pos,newpos)
    return pos,newpos
</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;
</t>
<t tx="ekr.20050328093147.1">@language rest

http://sourceforge.net/forum/message.php?msg_id=3064212
By: djsg  David 

The following applies to Leo 4.3, which is in alpha as I write this. It describes
the LeoSetup routine that I submitted to Edward to solve the "can't find Python"
problem, and which Edward cleaned up for distribution.

I think a few further issues need attention. I noticed them while working on
the "can't find Python" problem, and deferred dealing with them. This appears
to me to be a good time to pick them up.

Before I start work on them, I would like to lay them out for your comment.
Are they pains in the first place? Are my proposals good enough, and do they
make sense?

===== Proposal (General)

While LeoSetup should allow all accounts to share the Python code for core
Leo and its plug-ins, my guess is that we don't want to enforce that, since
Leo is a programmer's tool and the individual programmer will wish to
modify Leo and its pieces for the programmer's use.

===== Issue 1. LeoSetup still thinks Leo's user is an Administrator who owns the whole
machine.

For explanation, let's say that I log on as David to Windows 2000 or Windows
XP and install Leo 4.3. You then log out. You log in as Edward, and click Start,
pick Programs... you have no visible entry for Leo!

The current Setup routine allows no one but David to use Leo on this computer.
To make things worse, when I go to use Leo, I have to log in to Windows using
the account under which I installed it, which has Administrator rights to the
computer. In other words, I can't use Leo without operating the computer in
a mode that leaves it needlessly vulnerable to security violations.

===== Proposal Option 1.

Setup should ask whether to install Leo for everyone or for the installer's
account only. If the answer to that question is "yes," Setup should give
the user a private copy of everything that comes with Leo -- the only
application shared should be the current Python, assuming that it is
installed for all users.

Python.org's installer for Python 2.4 allows the installed Python to work only
for the account that installed it. I found this in December and wrote code to
handle it, which I then commented out since the issue wasn't critical. I can
check a computer with a single-account installation of Python in order to figure
out how a single-account installation of Leo would have to handle the click-to-open
behavior.

===== Issue 2. LeoSetup allows only one copy of Leo on a given computer. 

LeoSetup assumes that you want Leo in C:\Program Files\Leo. The installer can
override that already. LeoSetup also goes to some trouble to set up the usual
click-to-open behavior for .leo files. That behavior is tied to the copy of
Python that was current when I ran LeoSetup, and tied to the copy of Leo that
was installed most recently.

===== Proposal Option 2.

When LeoSetup finds Python installed for that single user, it should ask
whether to install Leo for the installer's account only. If the answer to
that question is "yes," Setup should give the user a private copy of
everything that comes with Leo and use the single-user installation of
Python. Why does this matter. If you need to test your plug-ins with
different versions of Python, this would make that easier.

===== Issue 3. LeoSetup does not run without human intervention. This complicates
deploying Leo in multi-computer sites.

The message box that displays the path of the Python installation found is one
issue. I put it in to allow the installer to cross-check Setup's behavior. Since
nobody has complained about problems with the code I wrote to fix the problem
installing with Python 2.4 and Active Python, Setup need no longer force the
installer to review the message box's contents.

===== Proposal: The message box needs to time out after, say, 15 seconds. 

I last looked at the installer three months ago so I would have to look at the
rest of it for other barriers to automated installation.
</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing
alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.
The base classes for these gui-specific classes are in the node
Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in
leoPy.leo contain all of Leo's Tkinter-specific code. Gui plugins
would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4: Gui-specific classes must implement the 'gui wrapper methods'
specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific
services to Leo's core.

The alternative would be to implement all gui-specific commands
directly in the gui-specific code.  But this would be much more work
than needed.  For example, only a few gui-specific wrappers are needed
to implement all commands that deal with body text.  Implementing each
of these commands 'from scratch' would duplicate a lot of code
unnecessarily. 

Using the gui wrapper methods is a bit messy for two reasons:

1. It requires defining enough wrappers (both in the base gui classes
   and subclasses) so that all gui-specific services needed by Leo's
   core are available.  Adding a wrapper to a gui base class involves
   adding it to all gui-specific subclasses.  It's easy to forget to
   add a wrapper.  The gui base class defines all wrappers as a
   function that just calls oops().  This prints a warning that the
   wrapper should be defined in a subclass. 

2. The original wrappers assumed Tkinter-like indices.  Wrappers that
   were defined later assume Python indices (see Rule 5 below).  The
   newer style wrappers that use Python indices have 'Python' in their
   name.  Having two sets of wrappers is one of the ugliest features
   of the present code.  I find it hard to remember which wrappers
   exist and what exactly they do :-)

Rule 5: Leo's core should use Python indices, not gui-specific
indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to
len(s) (end of text s).  That is, there are exactly len(s) + 1 valid
indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where
text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions
from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column
  index used by Tkinter.
  
- g.convertRowColToPythonIndex does the reverse.

Important: the first Tkinter index is '1.0', not '0.0', but the row
returned by g.convertPythonIndexToRowCol is zero based, so the code
that actually creates Tkinter indices from row/col must add 1 to the
row.  Similar remarks apply when going in the reverse direction. 
</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20060526081931">def searchHelper (self,s,i,j,pattern):
    '''Dispatch the proper search method based on settings.'''
    trace = False and not g.unitTesting
    backwards=self.reverse
    nocase=self.ignore_case
    regexp=self.pattern_match
    word=self.whole_word
    if backwards: i,j = j,i
    if trace: g.trace('entry',i,j,repr(s[min(i,j):max(i,j)]))
    if not s[i:j] or not pattern:
        if trace: g.trace('empty',i,j,'len(s)',len(s),'pattern',pattern)
        return -1,-1
    if regexp:
        pos,newpos = self.regexHelper(s,i,j,pattern,backwards,nocase)
    elif backwards:
        pos,newpos = self.backwardsHelper(s,i,j,pattern,nocase,word)
    else:
        pos,newpos = self.plainHelper(s,i,j,pattern,nocase,word)
    if trace: g.trace('returns',pos,newpos)
    return pos,newpos
</t>
<t tx="ekr.20060526092203">def regexHelper (self,s,i,j,pattern,backwards,nocase):
    trace = False and not g.unitTesting
    re_obj = self.re_obj # Use the pre-compiled object
    if not re_obj:
        g.trace('can not happen: no re_obj')
        return -1,-1
    if backwards:
        # Scan to the last match using search here.
        last_mo = None ; i = 0
        while i &lt; len(s):
            mo = re_obj.search(s,i,j)
            if not mo: break
            i += 1
            last_mo = mo
        mo = last_mo
    else:
        mo = re_obj.search(s,i,j)
    if trace: g.trace('backwards',backwards,'pattern',pattern,
        i,j,'s[i:j]',repr(s[i:j]),
        'mo.start/end',mo and mo.start(),mo and mo.end())
    while mo and 0 &lt;= i &lt;= len(s):
        # Bug fix: 2013/12/27: must be 0 &lt;= i &lt;= len(s)
        if mo.start() == mo.end():
            if backwards:
                # Search backward using match instead of search.
                i -= 1
                while 0 &lt;= i &lt; len(s):
                    mo = re_obj.match(s,i,j)
                    if mo: break
                    i -= 1
            else:
                i += 1 ; mo = re_obj.search(s,i,j)
        else:
            self.match_obj = mo
            return mo.start(),mo.end()
    self.match_obj = None
    return -1,-1
</t>
<t tx="ekr.20060526093531">def plainHelper (self,s,i,j,pattern,nocase,word):
    '''Do a plain search.'''
    trace = False and not g.unitTesting
    if trace: g.trace(i,j,repr(s[i:i+20]))
    if nocase:
        s = s.lower() ; pattern = pattern.lower()
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    if word:
        while 1:
            k = s.find(pattern,i,j)
            # g.trace(k,n)
            if k == -1:
                if trace: g.trace('no match word',i)
                return -1, -1
            elif self.matchWord(s,k,pattern):
                if trace: g.trace('match word',k)
                return k, k + n
            else: i = k + n
    else:
        k = s.find(pattern,i,j)
        if k == -1:
            if trace: g.trace('no match word',i)
            return -1, -1
        else:
            if trace: g.trace('match', k)
            return k, k + n
</t>
<t tx="ekr.20060526140328">def passedWrapPoint(self,p,pos,newpos):
    '''Return True if the search has gone beyond the wrap point.'''
    return (
        self.wrapping and
        self.wrapPosition is not None and
        p == self.wrapPosition and
            (self.reverse and pos &lt; self.wrapPos or
            not self.reverse and newpos &gt; self.wrapPos)
    )
</t>
<t tx="ekr.20060526140744">debugIndices = []

@
rfind(sub [,start [,end]])

Return the highest index in the string where substring sub is found, such that
sub is contained within s[start,end]. Optional arguments start and end are
interpreted as in slice notation. Return -1 on failure.
@c
def backwardsHelper (self,s,i,j,pattern,nocase,word):

    trace = False and not g.unitTesting
    if nocase:
        s = s.lower()
        pattern = pattern.lower()
            # Bug fix: 10/5/06: At last the bug is found!
    pattern = self.replaceBackSlashes(pattern)
    n = len(pattern)
    # 2014/09/18: Put the indices in range.  Indices can get out of range
    # because the search code strips '\r' characters when searching @edit nodes.
    i = max(0,i)
    j = min(len(s),j)
    # Old code:
        # if i &lt; 0 or i &gt; len(s) or j &lt; 0 or j &gt; len(s):
            # g.trace('bad index: i = %s, j = %s' % (i,j))
            # i = 0 ; j = len(s)
    if trace and (s and i == 0 and j == 0):
        g.trace('two zero indices')
    # short circuit the search: helps debugging.
    if s.find(pattern) == -1:
        return -1,-1
    if word:
        while 1:
            k = s.rfind(pattern,i,j)
            if trace: g.trace('**word** %3s %3s %5s -&gt; %s %s' % (
                i,j,'(end)' if j==len(s) else '',k,self.p.h))
            if k == -1: return -1, -1
            if self.matchWord(s,k,pattern):
                return k,k+n
            else:
                j = max(0,k-1)
    else:
        k = s.rfind(pattern,i,j)
        if trace: g.trace('%3s %3s %5s -&gt; %s %s' % (
            i,j,'(end)' if j==len(s) else '',k,self.p.h))
        if k == -1:
            return -1, -1
        else:
            return k,k+n
</t>
<t tx="ekr.20060526140744.1">def matchWord(self,s,i,pattern):
    '''Do a whole-word search.'''
    trace = False and not g.unitTesting
    pattern = self.replaceBackSlashes(pattern)
    if not s or not pattern or not g.match(s,i,pattern):
        if trace: g.trace('empty')
        return False
    pat1,pat2 = pattern[0],pattern[-1]
    n = len(pattern)
    ch1 = 0 &lt;= i-1 &lt; len(s) and s[i-1] or '.'
    ch2 = 0 &lt;= i+n &lt; len(s) and s[i+n] or '.'
    isWordPat1 = g.isWordChar(pat1)
    isWordPat2 = g.isWordChar(pat2)
    isWordCh1 = g.isWordChar(ch1)
    isWordCh2 = g.isWordChar(ch2)
    # g.trace('i',i,'ch1,ch2,pat',repr(ch1),repr(ch2),repr(pattern))
    inWord = isWordPat1 and isWordCh1 or isWordPat2 and isWordCh2
    if trace: g.trace('returns',not inWord)
    return not inWord

</t>
<t tx="ekr.20061031131434.112">def callAltXFunction (self,event):
    '''Call the function whose name is in the minibuffer.'''
    trace = False and not g.unitTesting
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName,tail = k.getMinibufferCommandName()
    if trace: g.trace('command:',commandName,'tail:',tail)
    k.functionTail = tail
    func = c.commandsDict.get(commandName)
    k.newMinibufferWidget = None
    # g.trace(func and func.__name__,'mb_event',event and event.widget.widgetName)
    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        w = event and event.widget
        if hasattr(w,'permanent') and not w.permanent:
            # In a headline that is being edited.
            ### g.es('Can not execute commands from headlines')
            c.endEditing()
            c.bodyWantsFocusNow()
            # Change the event widget so we don't refer to the to-be-deleted headline widget.
            event.w = event.widget = c.frame.body.wrapper.widget
            func(event)
        else:
            c.widgetWantsFocusNow(event and event.widget) # Important, so cut-text works, e.g.
            func(event)
        k.endCommand(commandName)
    else:
        # Show possible completions if the command does not exist.
        if 1: # Useful.
            if trace: g.trace('*** tab completion')
            k.doTabCompletion(list(c.commandsDict.keys()))
        else: # Annoying.
            k.keyboardQuit()
            k.setStatusLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()
</t>
<t tx="ekr.20061031131434.28">def compute_completion_list (self):

    trace = False and not g.unitTesting
    verbose = False
        # True: report hits and misses.
        # False: report misses.

    if self.klass:
        prefix = ''
        # something later on eats the first char, not sure what
        options = ['^'+i for i in self.lookup_methods([str(self.klass)],None)]
        g.es("%s: %d options" % (self.klass, len(options)))
        self.klass = None
    else:
        prefix = self.get_autocompleter_prefix()
        key,options = self.get_cached_options(prefix)
        if options:
            if trace and verbose: g.trace('**prefix hit: %s, %s' % (prefix,key))
        else:
            if trace: g.trace('**prefix miss: %s, %s' % (prefix,key))
            options = self.get_completions(prefix)

    tabList,common_prefix = g.itemsMatchingPrefixInList(
        prefix,options,matchEmptyPrefix=False)

    if not common_prefix:
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            prefix,options,matchEmptyPrefix=True)

    if trace and verbose:
        g.trace('prefix: %s, common: %s, len(tabList): %s' % (
            repr(prefix),repr(common_prefix),len(tabList)))
        # if verbose: g.trace('options[:10]...\n',
            # g.listToString(options[:10],sort=True))

    if tabList:
        self.show_completion_list(common_prefix,prefix,tabList)

    return common_prefix,prefix,tabList
</t>
<t tx="ekr.20070105165924">def replaceBackSlashes (self,s):
    '''Carefully replace backslashes in a search pattern.'''
    # This is NOT the same as:
    # s.replace('\\n','\n').replace('\\t','\t').replace('\\\\','\\')
    # because there is no rescanning.
    i = 0
    while i + 1 &lt; len(s):
        if s[i] == '\\':
            ch = s[i+1]
            if ch == '\\':
                s = s[:i] + s[i+1:] # replace \\ by \
            elif ch == 'n':
                s = s[:i] + '\n' + s[i+2:] # replace the \n by a newline
            elif ch == 't':
                s = s[:i] + '\t' + s[i+2:] # replace \t by a tab
            else:
                i += 1 # Skip the escaped character.
        i += 1
    return s
</t>
<t tx="ekr.20080412053100.5">
























@language python</t>
<t tx="ekr.20080730161153.8"></t>
<t tx="ekr.20090526081836.5841">def getLeoFileHelper(self,theFile,fileName,silent):

    '''Read the .leo file and create the outline.'''

    c,fc = self.c,self
    try:
        ok = True
        v = fc.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            fc.rootVnode = v
        else:
            v = leoNodes.VNode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.Position(v)
            p._linkAsRoot(oldRoot=None)
            fc.rootVnode = v
            # c.setRootPosition()
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            c.alert(fc.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    return ok
</t>
<t tx="ekr.20090802181029.5988"></t>
<t tx="ekr.20090802181029.5989"></t>
<t tx="ekr.20100120072650.6088"></t>
<t tx="ekr.20100124110832.6212">def propegateDirtyNodes (self):

    fc = self ; c = fc.c

    aList = [z.copy() for z in c.all_positions() if z.isDirty()]
    for p in aList:
        p.setAllAncestorAtFileNodesDirty()
</t>
<t tx="ekr.20100205060712.8314">def handleNodeConflicts (self):

    c = self.c
    if not c.nodeConflictList: return

    # Find the last top-level node.
    sib = c.rootPosition()
    while sib.hasNext():
        sib.moveToNext()

    # Create the 'Recovered Nodes' node.
    root = sib.insertAfter()
    root.setHeadString('Recovered Nodes')
    root.expand()

    # For each conflict, create one child and two grandchildren.
    for bunch in c.nodeConflictList:
        tag = bunch.get('tag') or ''
        gnx = bunch.get('gnx') or ''
        fn  = bunch.get('fileName') or ''
        b1,h1 = bunch.get('b_old'),bunch.get('h_old')
        b2,h2 = bunch.get('b_new'),bunch.get('h_new')
        child = root.insertAsLastChild()
        h = 'Recovered node "%s from %s' % (h1,g.shortFileName(fn))
        child.setHeadString(h)
        # child.setBodyString('%s %s' % (tag,gnx))
        line1 = '%s %s\nDiff...\n' % (tag,gnx)
        d = difflib.Differ().compare(g.splitLines(b2),g.splitLines(b1))
        # d = difflib.unified_diff(g.splitLines(b2),g.splitLines(b1))
        diffLines = [z for z in d]
        lines = [line1]
        lines.extend(diffLines)
        # There is less need to show trailing newlines because
        # we don't report changes involving only trailing newlines.
        child.setBodyString(''.join(lines)) # .replace('\n','\\n\n'))
        n1 = child.insertAsNthChild(0)
        n2 = child.insertAsNthChild(1)
        n1.setHeadString('old:'+h1)
        n1.setBodyString(b1)
        n2.setHeadString('new:'+h2)
        n2.setBodyString(b2)

    return root
</t>
<t tx="ekr.20100701112151.5959">def getDiff (self,s1,s2):

    # pylint: disable=E1120
    # E1120:getDiff: No value passed for parameter 'b' in function call

    lines1 = g.splitLines(s1)
    lines2 = g.splitLines(s2)
    diffLines = difflib.Differ.compare(lines1,lines2)
    return diffLines
</t>
<t tx="ekr.20110514051607.14524">def get_cached_options(self,prefix):

    trace = False and not g.unitTesting
    d = self.completionsDict

    # Search the completions Dict for shorter and shorter prefixes.
    i = len(prefix)

    while i &gt; 0:
        key = prefix[:i]
        i -= 1
        # Make sure we report hits only of real objects.
        if key.endswith('.'):
            if trace: g.trace('== period: %s' % (key))
            return key,[]
        options = d.get(key)
        if options:
            if trace: g.trace('== hit: %s len: %s' % (
                key,len(options)))
            return key,options
        else:
            if trace: g.trace('== miss: %s' % (key))

    return None,[]
</t>
<t tx="ekr.20110605121601.17862"># These files are true plugins, but it is more convenient to put them here.</t>
<t tx="ekr.20110605121601.18175">def set_style_sheets(self,all=True,top=None,w=None):
    '''Set the master style sheet for all widgets using config settings.'''
    trace = False
    c = self.c
    if top is None: top=c.frame.top
    selectors = ['qt-gui-plugin-style-sheet']
    if all:
        selectors.append('qt-gui-user-style-sheet')
    sheets = []
    for name in selectors:
        sheet = c.config.getData(name,strip_comments=False)
            # don't strip `#selector_name { ...` type syntax
        if sheet:
            if '\n' in sheet[0]:
                sheet = ''.join(sheet)
            else:
                sheet = '\n'.join(sheet)
        if sheet and sheet.strip():
            sheets.append(sheet)
    if sheets:
        sheet = "\n".join(sheets)
        # store *before* expanding, so later expansions get new zoom
        c.active_stylesheet = sheet
        sheet = self.expand_css_constants(sheet)
        if not sheet: sheet = self.default_style_sheet()
        if w is None:
            w = self.get_master_widget(top)
        if trace: g.trace(w,len(sheet))
        a = w.setStyleSheet(sheet)
    else:
        if trace: g.trace('no style sheet')
</t>
<t tx="ekr.20110605121601.18176">def default_style_sheet (self):
    '''Return a reasonable default style sheet.'''
    # Valid color names: http://www.w3.org/TR/SVG/types.html#ColorKeywords
    g.trace('===== using default style sheet =====')
    return '''\

/* A QWidget: supports only background attributes.*/
QSplitter::handle {
    background-color: #CAE1FF; /* Leo's traditional lightSteelBlue1 */
}
QSplitter {
    border-color: white;
    background-color: white;
    border-width: 3px;
    border-style: solid;
}
QTreeWidget {
    background-color: #ffffec; /* Leo's traditional tree color */
}
QsciScintilla {
    background-color: pink;
}
'''
</t>
<t tx="ekr.20110605121601.18695"></t>
<t tx="ekr.20120212220616.10537">def readExternalFiles(self,fileName):

    c,fc = self.c,self

    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
    recoveryNode = fc.handleNodeConflicts()

    # Do this after reading external files.
    # The descendent nodes won't exist unless we have read the @thin nodes!
    fc.restoreDescendentAttributes()

    fc.setPositionsFromVnodes()
    c.selectVnode(recoveryNode or c.p) # load body pane
</t>
<t tx="ekr.20130806072439.20414">From: Nick_H &lt;nah@plextek.co.uk&gt;

Sorry, this is probably a foolish question, but when I double-click on
any Leo file on my desktop to launch Leo, it simply launches with the
default workbook.leo file open.
I can, of course, open any file via the File|Open dialog, but that's
not so convenient.
The file association contains the following command to execute for the
Open operation:
"C:\\Tools\\Python32\\python.exe" "C:\\Tools\\Leo-4.10-final\\launchLeo.py
%*"

Can you suggest what might be wrong?
Thank you!

Nick

</t>
<t tx="ekr.20130806072439.20415">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

"On Wed, Apr 18, 2012 at 12:20 AM, Matt Wilkie &lt;maphew@gmail.com&gt; wrote:

&gt; the docs have the wrong version, It should match the above:
&gt; http://webpages.charter.net/edreamleo/install.html#installing-leo-on-windows

Good catch.  I think rather than updating this for every release, I'll
try to generalize it a bit so people will understand what is intended.
 The fix will probably be tricky: it's so hard to be clear and general
at the same time.  Otoh, making instructions
Python-and-Leo-version-depenedent is pretty hopeless.
</t>
<t tx="ekr.20130806072439.20416">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt; The file association contains the following command to execute for the
&gt; Open operation:
&gt; "C:\\Tools\\Python32\\python.exe" "C:\\Tools\\Leo-4.10-final\\launchLeo.py
&gt; %*"

it's the trailing %*, use "%1" instead.

You want %*  in a batch file. It passes all command line arguments to
the program being called.

"%1" passes just the file being clicked on, quoted for spaces etc.
When in a batch file %1 passes just the first command line parameter.

It is logical to expect %* to work for click file association as well,
but it doesn't. I don't know why.

</t>
<t tx="ekr.20130806072439.20417">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt; Set up file type association:
&gt;
&gt; C:\\&gt; ftype LeoFile=3DC:\\Python27\\pythonw.exe C:\\apps\\leo\\launchLeo.py =E2=
=80=9C%1=E2=80=B3
&gt; C:\\&gt; assoc .leo=3DLeoFile=20
&gt;
And put this leo.bat in %PATH%:
&gt;
&gt; @start /b "Leo" C:\\Python27\\python.exe C:\\apps\\leo\\launchLeo.py %*
&gt;
Edward (or anyone else with access to bzr, I don't right now (and the last=
=20
time it didn't work anyway ;-): the docs have the wrong version, It should=
=20
match the above:
http://webpages.charter.net/edreamleo/install.html#installing-leo-on-window=
s

=20
-matt=20
</t>
<t tx="ekr.20130806072439.20418">From: Nick_H &lt;nah@plextek.co.uk&gt;

Many thanks to all for these replies!
This is my final "open" string in the Windows file associations:
"C:\\Tools\\Python32\\python.exe" "C:\\Tools\\Leo-4.10-final\\launchLeo.py"=20
--gui=3Dqttabs "%1"
Note that the brackets are needed round the %1 to cater for file paths=20
containing spaces.

Matt, thanks for the extra details about using ftype and assoc. I hadn't=20
realised those existed in Windows. For anyone else reading this, that is an=
=20
alternative to working through the file associations GUI.

Nick

On Saturday, April 14, 2012 4:30:10 PM UTC+1, Matt Wilkie wrote:
&gt;
&gt; &gt; it's the trailing %*, use "%1" instead.
&gt;
&gt; Here is my setup...
&gt;
&gt; Set up file type association:
&gt;
&gt; C:\\&gt; ftype LeoFile=3DC:\\Python27\\pythonw.exe C:\\apps\\leo\\launchLeo.py =E2=
=80=9C%1=E2=80=B3
&gt; C:\\&gt; assoc .leo=3DLeoFile
&gt;
&gt;
&gt; And put this leo.bat in %PATH%:
&gt;
&gt; @start /b "Leo" C:\\Python27\\python.exe C:\\apps\\leo\\launchLeo.py %*
&gt;
&gt; --=20
&gt; -matt
&gt;
&gt;
</t>
<t tx="ekr.20130806072439.20419">From: HansBKK &lt;hansbkk@gmail.com&gt;

On Tuesday, April 17, 2012 1:43:34 AM UTC+7, Matt Wilkie wrote:
&gt;
&gt; &gt; there's a very cool tool called "PortableFileAssociator" that allows you 
&gt; to
&gt; &gt; create a set of windows file associations, icons etc and enable/disable
&gt;
&gt; neat, thanks for the tip.
&gt; oh, looks like it's problematic with portableapps.com suite 'cause of
&gt; high false-positive AV warnings... but maybe the same functionality
&gt; will be incorporated into the PA menu launcher. Cool.
&gt; http://portableapps.com/node/15583?page=4
&gt;

Yes, many cool tools like this use autohotkey, or a certain compiler that 
also gets used for some malware and triggers false positives for some of 
the sloppier a/v packages.

If you want to be safe, get a more balanced picture from one of these:
http://www.virustotal.com/
http://virusscan.jotti.org/en
</t>
<t tx="ekr.20130806072439.20420">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt; it's the trailing %*, use "%1" instead.

Here is my setup...

Set up file type association:

C:\\&gt; ftype LeoFile=3DC:\\Python27\\pythonw.exe C:\\apps\\leo\\launchLeo.py =E2=
=80=9C%1=E2=80=B3
C:\\&gt; assoc .leo=3DLeoFile


And put this leo.bat in %PATH%:

@start /b "Leo" C:\\Python27\\python.exe C:\\apps\\leo\\launchLeo.py %*
</t>
<t tx="ekr.20130806072439.20421">From: Matt Wilkie &lt;maphew@gmail.com&gt;

&gt; there's a very cool tool called "PortableFileAssociator" that allows you to
&gt; create a set of windows file associations, icons etc and enable/disable

neat, thanks for the tip.
oh, looks like it's problematic with portableapps.com suite 'cause of
high false-positive AV warnings... but maybe the same functionality
will be incorporated into the PA menu launcher. Cool.
http://portableapps.com/node/15583?page=4
</t>
<t tx="ekr.20130806072439.20422">From: HansBKK &lt;hansbkk@gmail.com&gt;

Here's my launch batch. Note nothing's actually installed

set HOME=E:\\aasync\\Data\\H_HOME
cd \\aasync\\PortableApps\\leo-editor
start "" "..\\CommonFiles\\Python27\\pythonw.exe" 
"..\\CommonFiles\\Python27\\Lib\\site-packages\\leo-editor4\\launchLeo.py" %*
exit
</t>
<t tx="ekr.20130806072439.20424">From: Eoin &lt;eoinmccarthy@fastmail.fm&gt;

I got the association working on Windows 7 using:

&gt;ftype LeoFile=3D"C:\\Python322\\pythonw.exe" "C:\\Program Files (x86)\\Leo-4.9-final\\launchLeo.py" "%1"
&gt;assoc .leo=3DLeoFile
&gt;regsvr32 /i shell32.dll
</t>
<t tx="ekr.20130806072439.20425">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Fri, Apr 13, 2012 at 5:24 AM, Nick_H &lt;nah@plextek.co.uk&gt; wrote:

&gt; "C:\\Tools\\Python32\\python.exe" "C:\\Tools\\Leo-4.10-final\\launchLeo.py
&gt; %*"
&gt;
&gt; Can you suggest what might be wrong?

The last set of double quotes looks wrong.  Try:

"C:\\Tools\\Python32\\python.exe" "C:\\Tools\\Leo-4.10-final\\launchLeo.py" %*

In this case, none of the double quotes are needed, because the paths
have no embedded blanks, so this also should work:

C:\\Tools\\Python32\\python.exe C:\\Tools\\Leo-4.10-final\\launchLeo.py %*

Finally, unless you have a strong reason not to do so, I would suggest
adding the --gui=qttabs option::

C:\\Tools\\Python32\\python.exe C:\\Tools\\Leo-4.10-final\\launchLeo.py
--gui=qttabs %*
</t>
<t tx="ekr.20130806072439.20426">From: Matt Wilkie &lt;maphew@gmail.com&gt;

I'm glad you got it working.

&gt;&gt;regsvr32 /i shell32.dll

Just note that this command does a lot more than update file
associations, and may undo some other customizations you've done
(default program for camera preview, shortcut wizard behaviour, ...)
Here are some things it does:
http://www.pcworld.com/article/126116/windows_tips_fix_windows_glitches_by_reregistering_your_dlls.html

</t>
<t tx="ekr.20130806072439.20427">From: HansBKK &lt;hansbkk@gmail.com&gt;

This is a bit OT, but: for those like me who work in "portable" mode, 
there's a very cool tool called "PortableFileAssociator" that allows you to 
create a set of windows file associations, icons etc and enable/disable the 
whole profile at one time, without messing with the local system's registry.

Also handy for those not in portable mode, but working on different windows 
boxes and bored with having to tweak each one separately.
</t>
<t tx="ekr.20130806072439.20488">From: Viktor Ransmayr &lt;viktor.ransmayr@gmail.com&gt;

now that you've 'cancelled' the 'leo/extensions/docutils' experiment I 
thought I investigate the status of '@rst' and 'docutils' again.

What I see in my local installation is the following:

&lt;log&gt;

Leo Log Window
Leo 4.11 devel, build 5752, 2013-04-27 11:55:26
Python 3.3.1, qt version 4.8.4
Windows 6, 1, 7601, 2, Service Pack 1
leoID=VR20100603 (in D:\\Users\\Viktor Ransmayr\\.leo)
load dir: D:\\Branches\\leo-editor\\leo\\core
global config dir: D:\\Branches\\leo-editor\\leo\\config
home dir: D:\\Users\\Viktor Ransmayr
reading settings in D:\\Branches\\leo-editor\\leo\\config\\leoSettings.leo
docutils loaded
reading settings in D:\\Users\\Viktor Ransmayr\\.leo\\myLeoSettings.leo
reading settings in D:\\Users\\Viktor Ransmayr\\Documents\\WL2013.leo
reading: D:\\Users\\Viktor Ransmayr\\Documents\\WL2013.leo

saved: WL2013.leo
created directory: D:\\Users\\Viktor Ransmayr\\Documents\\Logs\\2013\\04\\CW17
SilverCity not present so no syntax highlighting
Unexpected docutils exception
Traceback (most recent call last):
  File "D:\\Branches\\leo-editor\\leo\\core\\leoRst.py", line 1891, in 
writeToDocutils
    result = docutils.core.publish_string(source=s,
AttributeError: 'module' object has no attribute 'core'

&lt;/log&gt;

Based on your current understanding: Should the '@rst' command with a 
properly installed 'docutils' package work in a Python 3 environment?

===== EKR

Yes it should, but in my experience installing docutils on Python 3
involves more (on Windows) than just doing setup.py install. I've had to do
the following:

- unpack docutils to a temp folder
- cd the temp folder
- python3 setup.py build
- 2to3 build
- copy the build\\lib\\docutils to your site-customize folder.

Note that you may have to set up a bat file to be able to execute 2to3
easily.

The easy way to see whether docutils is properly installed is to do F1.  If
you see::

*   Welcome to Leo's help system.*

Leo has loaded docutils properly. If you see::

    **Welcome to Leo's help system.**

then Leo could not load docutils.  In that case, Leo uses &lt;pre&gt; to format
help message.

===== lewis &lt;lewisneal@operamail.com&gt;

It may be useful to try the installation method suggested at 
http://docutils.sourceforge.net/README.html#installation
    
The introductory comment "Just double-click install.py. If this doesn't
work, try the following:" convinced me to try the steps 1,2,3 :)

So first I unpack the archive
1. Open a Command Shell, MS-DOS Prompt, or Console
2. cd to location of docutils folder:
3. Install the package:
   &lt;path_to_python.exe&gt;\\python setup.py install
   e.g. at prompt C:\\Python33\\python setup.py install

When installing docutils I've never had to use 'python3 setup.py build' or '2to3 build'.
I'm interested to know if this works for you on the next docutils snapshot.

===== EKR

I've just double-checked.  On  docutils-0.10 python33 setup.py install does
*not* work for me, but the following does work::

- unpack to a temp folder
- cd the temp folder
- python33 setup.py build
- copy temp/build/lib/docutils to python33/Lib/site-customize.

In other words, there is no need for a separate 2to3 step, but for me there
*is* a need to do python setup.py build.  YMMV.

===== Viktor

I have now found a reliable way to create the HTML documentation from my 
log-outline.

From my POV it indicates that there is a problem within 'leoRst.py'

If I have not executed F1 before, I get the one or more of the entries, 
that I have reported previously:

&lt;log-1&gt;

Unexpected docutils exception
Traceback (most recent call last):
  File "D:\\Branches\\leo-editor\\leo\\core\\leoRst.py", line 1891, in 
writeToDocutils
    result = docutils.core.publish_string(source=s,
AttributeError: 'module' object has no attribute 'core'
done

&lt;/log-1&gt;

However of I have explicitely executed F1 *before*, the HTML file(s) get 
created, no matter at which level I call the command 'rst3':

&lt;log-2&gt;

wrote: D:\\Users\\Viktor 
Ransmayr\\Documents\\Logs\\2013\\05\\CW18\\LE-2013-05-01.html
done
wrote: D:\\Users\\Viktor 
Ransmayr\\Documents\\Logs\\2013\\05\\CW18\\LE-2013-05-01.html
done
wrote: D:\\Users\\Viktor 
Ransmayr\\Documents\\Logs\\2013\\05\\CW18\\CW18-Statistics.html
wrote: D:\\Users\\Viktor 
Ransmayr\\Documents\\Logs\\2013\\05\\CW18\\LE-2013-05-dd.html
wrote: D:\\Users\\Viktor 
Ransmayr\\Documents\\Logs\\2013\\05\\CW18\\LE-2013-05-01.html
done

&lt;/log-2&gt;

To make it clear and explicit: When I execute F1 I now get the proper 
output starting with

*Welcome to Leo's help system.*

Hope this helps you finding the root cause of this issue.



</t>
<t tx="ekr.20130806072439.20514">From: Richard &lt;richardjohnlyon@gmail.com&gt;

I am looking into using Leo for a few php projects at work.
I think I have figured out how to use Leo, but was wondering if someone 
could have a look at my small test project and let me know if I am using it 
correctly. (The workbook should be attached, please let me know if there 
are any problems).

I like the idea of Leo, however I get the impression that if I use it 
'wrong' then it will be more of a hindrance than a help.

-----

Just realised that that attachment is useless.

What I have is :
Nodes:
@file foo.php
@file test.php
----- &lt;&lt; includes &gt;&gt;
----- &lt;&lt; Connect to the database &gt;&gt;
----- &lt;&lt; Disconnect from the database &gt;&gt;
----- &lt;&lt; Test echo &gt;&gt;
----- &lt;&lt; External file class test &gt;&gt;

@file foo:
&lt;?php
    class Foo
    {
        public $foo;
        public $bar;
        
        public function foobar()
        {
            echo $foo . $bar;
        }
    }
?&gt;

@file test.php
&lt;?php
    &lt;&lt; includes &gt;&gt;
    &lt;&lt; Connect to the database &gt;&gt;
    &lt;&lt; Test echo &gt;&gt;
    &lt;&lt; Disconnect from the database &gt;&gt;
    &lt;&lt; External file class test &gt;&gt;
?&gt;

&lt;&lt;includes&gt;&gt;:
require('foo.php');

&lt;&lt; Connect to the database &gt;&gt;
echo "Connecting to the database";

&lt;&lt; Test echo &gt;&gt;:
echo "This is a test";

&lt;&lt; Disconnect from the database &gt;&gt;:
echo "Disconnecting from the database";

&lt;&lt; External file class test &gt;&gt;:
$foo = new Foo();

$foo-&gt;foo = "foo";
$foo-&gt;bar = "bar";

$foo-&gt;foobar();

Does this seem right? Or should I be doing something differently?
</t>
<t tx="ekr.20130806072439.20650">From: Winn Dixie &lt;incredible0n3@gmail.com&gt;

Would be stellar to have a brew install leo (for Mac OSX 10.7.X) with
possible built in options to install vim bindings.

http://brew.sh/
Homebrew formulae are simple Ruby scripts:

require "formula"

class Wget &lt; Formula
  homepage "http://www.gnu.org/software/wget/"
  url "http://ftp.gnu.org/gnu/wget/wget-1.15.tar.gz"
  sha1 "f3c925f19dfe5ed386daae4f339175c108c50574"

  def install
    system "./configure", "--prefix=#{prefix}"
    system "make", "install"
  end
end


To install homebrew, paste this in a terminal:

ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"

The script explains what it will do and then pauses before it does it.
There are more installation options here (needed on 10.5).
</t>
<t tx="ekr.20130806072439.20732">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Summary - it's easy to make a .zip file containing Leo and all it's
dependencies.

Inspired by Matt's recipe, using VirtualBox throw away 1GB Windows XP
32 bit machines, I tried the following.

Install Python (installer from python.org) 2.7.2 to 

  C:\Docouments and Settings\someuser\Desktop\leo\python27

Install PyQt (installer from Riverbank) 4.9 into the same folder (it
goes there by default)

Unzip http://www.greygreen.org/leo/leo-editor-latest.zip into

  C:\Docouments and Settings\someuser\Desktop\leo\leo-editor-latest

Make leo.zip from C:\Docouments and Settings\someuser\Desktop\leo

Delete the virtual machine, purging any registry entries etc. created
by the two installers.

On a fresh machine, searched the registry for 'python' just to be sure,
found nothing.

Unzip the .zip file, then

  cd C:\Docouments and Settings\someuser\Desktop\leo
  python27\python.exe leo-editor-latest\launchLeo.py

And Leo opens a blank outline, after asking for an ID, as it's supposed
to.  Didn't test it beyond that.

So, the .zip file contains all Leo needs to run, and obviously
runLeo.bat could be added in the top level to actually launch it.

Of course this is for Windows, so I think it's an improvement over
asking people to install Python and PyQt first, but neither of those
steps was that hard in Windows anyway.

===== EKR

Is this a technique that we could use for official Windows releases?
If so, what exactly would we do?

===== Terry

I guess, perhaps as an all-in-one option with a system integrated
option for those who want to use system python/qt.  Don't know if it
violates and licensing on Python / Qt, everything's being distributed
unaltered, so I wouldn't think so.

So basically you'd give people a large .zip file and tell them to
extract it to a folder and run the batchfile at the top level.  If they
can't do that, they might not be ready for Leo :-)  I guess you could
make it a self-extracting .zip, for that matter.

Also, the daily snapshot could be made this way, seeing once Python and
Qt are installed in the folder the Leo version can just be copied in.

It's not uncommon for FLOSS to be distributed this way, both Blender
and Inkscape use this approach, particularly for recent builds.

===== From: HansBKK &lt;hansbkk@gmail.com&gt;

If something like this **is** done, it should IMO be packaged as an
alternative to the normal installation procedure.

You would definitely get marketing exposure by getting the specs from
PortableApps.com and let them host it there as  "Portable Leo", tracking
the "official" Portable Python (currently 2.7.2) as a dependency, obviously
including QT etc as well. But it would need to be kept up to date. . .

Most Windows users would be better served by following the normal
installation procedure and ending up with a
registry-and-environment-variables-complete install of Python et al which
they can use for other things beyond Leo. Ending up with multiple instances
of Python to maintain is likely to cause more problems.

And the normal Windows install just isn't that hard, really! Improving the
current instructions, by providing a step-by-step "cookbook" with direct
links to the download packages etc might make it a **little** easier (IMO
only for the clueless), but then of course that would be a doc that would
need pretty frequent updates, which if I may be so bold doesn't seem to
happen too quickly on the doc side.
</t>
<t tx="ekr.20130806072439.20736">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Since this topical today, almost a year later, I thought I'd take a run at 
repeating this using Portable Python (http://www.portablepython.com) as a 
base. It didn't work, but I think it should. Maybe someone else knows why. 

I ran the installer for 2.7.3 since 3.2 doesn't include PyQt4. At install 
time I selected only the Python and PyQt4 packages. Then from a fresh 
command shell:

{{{
path=c:\windows;c:\windows\system32
pushd x:\portapy27\App
path=%cd%;%cd%\Scripts;%cd%\Lib\site-packages\PyQt4;%path%
set pythonhome=%cd%
set pythonpath=%cd%\Lib

popd

python --version
Python 2.7.3

python -c "import PyQt4"
:: no error returned, we're good.

python c:\apps\leo-editor-latest\launchLeo.py
Leo requires Qt to be installed.
}}}

oh well.
</t>
<t tx="ekr.20130806072439.20744">From: HansBKK &lt;hansbkk@gmail.com&gt;

&gt; PortableApps version would be FANTASTIC!!

A couple of versions have been posted here already, including Terry's very
simple sequence in the first message of this thread. Of course, we're only
talking about Windows, but note that it works equally well either syncing
with whatever tool (I favor Unison over SSH) or carrying around on an
arbitrary-path'd external device, including flash drives (but they can be
slow).

Here's my more robust (hence more complex) version, xx indicating your 
python version (mine is 27):

Use the normal .MSI, setup.exe etc processes to Install a clean "canonical" 
version of your "python dev stack" to say C:\PythonXX, reboot if needed, 
test thoroughly. Note any new environment variables pointing to your new 
binary locations.

Now create a corresponding PythonXX folder in your "PortableApps" location 
(I put it under "CommonFiles" along with GTK and Java) and copy everything 
from your installed location to the portable one.

You can then use the project-provided tools on the "master" computer to 
keep your binaries updated, and they will see any local Registry entries 
and the environment variables they created and operate normally wrt your 
installed location (e.g. C:\PythonXX).

If you have a local folder sync tool (I use Unison and WinMerge) you can 
add to/remove from/configure your Python environment from either location, 
otherwise just keep your installed location as the "master" and just copy 
the whole stack over each time you do so.

The whole PortableApps tree can then be sync'd/copied to any other 
desktop(s) you like, either over the wire or via an external device, and 
the latter can be carried for use in say an Internet cafe or client-site 
situation.

====================

For use on those other computers, for running in portable mode, I use a
"portable start menu" (PStart) which allows for its own "autolaunch" batch
files, where I set some global environment variables to be used by
app-specific launch batch files, including :

%Path% (I add my batch folder and a general utility/tools folder)
%HOME% (usually "E:\aasync\Data\H_HOME"
and a custom one called %h_pa%, which points to the root of my PortableApps 
parent (usually "D:\aasync\PortableApps")

Then for each environment that requires its own custom settings, I create a 
launch batch file that builds on that base. In the case of Python apps, 
here's an example that opens a CMD console window:

@ECHO OFF
set 
PATH=%PATH%;%h_pa%\CommonFiles\Python27;%h_pa%\CommonFiles\Python27\Lib\site-packages\PyQt4;%h_pa%\CommonFiles\Python27\Lib\idlelib;%h_pa%\CommonFiles\Python27\Scripts;
set PROMPT=$p_python$g
E:
cd \aasync
CMD.exe

I'm not sure which if any of the environment stuff Leo requires, but I 
figure it might as well have the same environment as my Python CLI, since 
I'll be testing shell integration, including iPython. In my leo-win.bat, 
the last three lines above are replaced with:

D:
cd \aasync\PortableApps\leo-editor
start "" "..\CommonFiles\Python27\pythonw.exe" 
"..\CommonFiles\Python27\Lib\site-packages\leo-editor4\launchLeo.py" %*

====================

Note this is more than the minimum you need to just run Leo - you could of 
course simplify it; for example, only set the environment variables Leo 
requires, or you could just set the master computer' installation routines 
to use a single location under PortableApps, but I prefer to keep them 
separate for testing purposes.

I hope you (and others googling this later) find this useful.
</t>
<t tx="ekr.20130806211959.17307">@language rest
</t>
<t tx="ekr.20130806211959.17315">From: tfer &lt;tfetherston@aol.com&gt;

I was wondering if the Qt widget used for body text has a provision for 
background images?

I'm thinking that it might be interesting to have some wallpapers/tiles to 
visually represent various categories of methods, e.g. initors, setters, 
getters, etc.  Maybe ones that hint at the uses of a particular design 
pattern.  Maybe us a uA to control setting?
</t>
<t tx="ekr.20130806211959.17316">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Fri, Jul 13, 2012 at 3:57 PM, tfer &lt;tfetherston@aol.com&gt; wrote:

&gt; I was wondering if the Qt widget used for body text has a provision for
&gt; background images?
&gt;

Sorry for the delay in responding.  Leo's body pane is a QTextBrowser:
http://qt-project.org/doc/qt-4.8/qtextbrowser.html
a subclass of QTextEdit.  QTextBrowser also inherits from QFrame and
QWidget, so there *might* be a way to have a background image "leak"
through the text.
</t>
<t tx="ekr.20130806211959.17317">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

--MP_/NJ5QIult88.7_K/HpvnV2eA

On Wed, 1 May 2013 04:19:52 -0500
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; On Fri, Jul 13, 2012 at 3:57 PM, tfer &lt;tfetherston@aol.com&gt; wrote:
&gt; 
&gt; &gt; I was wondering if the Qt widget used for body text has a provision for
&gt; &gt; background images?
&gt; &gt;
&gt; 
&gt; Sorry for the delay in responding.  Leo's body pane is a QTextBrowser:
&gt; http://qt-project.org/doc/qt-4.8/qtextbrowser.html
&gt; a subclass of QTextEdit.  QTextBrowser also inherits from QFrame and
&gt; QWidget, so there *might* be a way to have a background image "leak"
&gt; through the text.
&gt; 
&gt; Edward
&gt; 

QTextEdit#richTextEdit { background-image: url('/home/tbrown/Desktop/cow2.jpg'); }

in the stylesheet gives the effect attached (i.e. it works).

If you wanted node specific backgrounds Leo would have to start setting
an attribute on the body widget, probably the gnx, so you could do

QTextEdit#richTextEdit[leo_gnx='tbrown.20130430222443.19340'] { 
  background-image: url('/home/tbrown/Desktop/cow2.jpg'); 
}

Cheers -Terry

</t>
<t tx="ekr.20130806211959.17318">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Wed, May 1, 2013 at 8:42 AM, Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt;
&gt;
&gt; QTextEdit#richTextEdit { background-image:
&gt; url('/home/tbrown/Desktop/cow2.jpg'); }
&gt;
&gt; in the stylesheet gives the effect attached (i.e. it works).
&gt;
&gt; If you wanted node specific backgrounds Leo would have to start setting
&gt; an attribute on the body widget, probably the gnx, so you could do
&gt;
&gt; QTextEdit#richTextEdit[leo_gnx='tbrown.20130430222443.19340'] {
&gt;   background-image: url('/home/tbrown/Desktop/cow2.jpg');
&gt; }
&gt;

Wow!  Thanks for this.  LeoUser wrote a version of Leo in Jython (using the
Swing classes), and he claimed that he could watch *movies* in the body
pane :-)

I'll add this to the Leo/To Document list.  Not sure yet how that list is
going to get translated into action.  Still reading Getting Things Done :-)
</t>
<t tx="ekr.20130806211959.17319">From: wgw &lt;wgwinder@gmail.com&gt;

For the moment, I use Meld to compare/update myLeoSettings.leo file. That 
seems a bit error-prone. Is there a better way? By update, I mean that, for 
example, in the bzr copy of LeoSettings.leo, the code_wise node says :

True: use codewise completions.
False: use leo-specific completions.

This setting is no longer used!

But in my (now old) myLeoSettings.leo file it says: 

True: use codewise completions.
False: use leo-specific completions

I want to transfer that updated setting comment to myLeoSettings so that I 
don't have to refer to LeoSetttings.leo when I tweak my installation. 

Another example: the plugins list will change with new plugins or 
eliminated plugins, but those changes won't be noted in the myLeoSettings 
file. So you have to check both settings files to find/enable plugins.

In general, it would seem useful to be able to merge the two leo files 
(like bzr merge?) or somehow make note of differences in the myLeoSettings 
file. 

This is starting to sound complicated.... :) Sorry!

EKR

It is complicated.  One tiny workaround is to delete nodes from
myLeoSettings.leo if and when they become unused.  More generally, you only
have to put nodes in myLeoSettings.leo if they are different from the
defaults.  But you probably already know that :-)

Really, this is a special case of the fundamental problem the Leo
developers have been struggling with:  Leo is great for storing gobs of
data, but not so great at sharing.  As a result, everyone, including Leo's
developers, struggles to remember, access or browse all the great stuff
that is already present.

Requiring tags is no solution: it's hopeless to require volunteers to do
anything :-)  I'm not just making a joke.  Someone who contributes a script
to this Google Group is under no further obligation to somehow be
compatible with *any* other submission rules.  Somehow, it's up to me, or
the other core developers, to find a simple, reliable way of "indexing" the
submissions.  Right now I have no solutions.
</t>
<t tx="ekr.20130806211959.17320">From: felix74 &lt;hjuucy@googlemail.com&gt;

I'm trying to create a interactive chart in a embedded in a new leo pane 
using matplotlib. However, I am not sure about the the best way  to 
implement this. I would appreciate some guidance on this please? The 
questions I would like answered are:
1/ How do I create a new blank pane for embedding a chart as well as other 
QtWidgets.
2/ Can I do this in a script or do I need to work with leo source 

The context for wanting to do this is that I want to create a data 
processing and visualization tool kit in leo. Like Excel but using nodes 
instead of columns. As such I have data in nodes and can create new data 
nodes by applying python functions to data in existing nodes. The thing 
missing is the visualization within a leo pane (I can easily launch a chart 
in it's own window) .
</t>
<t tx="ekr.20130806211959.17321">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Tue, 18 Sep 2012 05:59:59 -0700 (PDT)
felix74 &lt;hjuucy@googlemail.com&gt; wrote:

&gt; Terry,
&gt;  
&gt; Thanks for your help with this it was very helpful and a lot simpler than I 
&gt; feared. I have managed to get a matplotlib graph embedded within a pane in 
&gt; leo as a widget. I now need some help with how to interact with the 
&gt; widget using scripts in leo. I am unsure about the following:
&gt;  
&gt; *1/ How do I expose the widget within th leo python environment?* 

If you were only going to have one and you weren't going to destroy it,
you could just do something simple like c._matplot = self in its
constrictor (assuming c was passed to the constructor).

If you're going to have more than one and they may be destroyed, it
might be simplest to let the free_layout / nested_splitter system manage
them.

ts = c.free_layout.get_top_splitter()
matplotters = ts.findChildren(myMatplotWidget)

should return a list of the widgets of your class in the layout, but
only if they're in the main window, widgets in extra windows opened
from the "Open window" context menu item would be missed, I can add a
find_children() method to complement the find_child() method the
splitters already have to account for this.

Detail: the above is just using Qt's QObject.findChildren(), the
nested_splitter find_child() and (not yet written) find_children()
versions search the extra windows as well.

&gt; Here I have created a self.mat in your MatplotPaneProvider class to make 
&gt; the windget accessible but it doesn't feel like the correct way to do this. 

It should probably provide a fresh myMatplotWidget every time it's
called, so don't construct one in the Provider's init, but in the
ns_provide method.

&gt; from PyQt4 import QtGui
&gt; class MatplotPaneProvider:
&gt; def __init__(self, c):
&gt;      self.c = c
&gt;     * self.mat = myMatplotWidget()*
&gt;      if hasattr(c, 'free_layout'):
[snip]  
&gt; *2/I would also like to make the widget accessible from any script within 
&gt; leo. What's the leo way of doing this?*

See above.

&gt; *3/ If I create more than 1 pane containing these widgest. How do I switch 
&gt; between them in scripts?*

Above again :-)
 
&gt; *4/ Running this script more than once creates multiple items for Add 
&gt; Matplot when pressing the Action button. How do I stop this from happening? 
&gt; I have alrewady tried returning a unique integer in * ns_provider_id *but 
&gt; that did not work.*

The value returned by ns_provider_id should be unique for the provider
class, but constant.  So it can just return "matplotlib provider ver 1"
or something.
</t>
<t tx="ekr.20130806211959.17323">From: felix74 &lt;hjuucy@googlemail.com&gt;




Terry,
 
Thanks for your help with this it was very helpful and a lot simpler than I 
feared. I have managed to get a matplotlib graph embedded within a pane in 
leo as a widget. I now need some help with how to interact with the 
widget using scripts in leo. I am unsure about the following:
 
*1/ How do I expose the widget within th leo python environment?* 
Here I have created a self.mat in your MatplotPaneProvider class to make 
the windget accessible but it doesn't feel like the correct way to do this. 
 
from PyQt4 import QtGui
class MatplotPaneProvider:
def __init__(self, c):
     self.c = c
    * self.mat = myMatplotWidget()*
     if hasattr(c, 'free_layout'):
         splitter = c.free_layout.get_top_splitter()
     if splitter:
         splitter.register_provider(self)
    def ns_provides(self):
         return[('Add matplot', '_add_matplot_pane')]
    def ns_provide(self, id_):
         if id_ == '_add_matplot_pane':
         c = self.c
         return self.mat
 
    def ns_provider_id(self):

# used by register_provider() to unregister previously registered
# providers of the same service
# provider ID is not the same as the service id_ above
return "completely unique value here"

 
*mat = MatplotPaneProvider(c)*
*mat.mat.someMethod()*
*mat.mat.someOtherMethod()*
 
*2/I would also like to make the widget accessible from any script within 
leo. What's the leo way of doing this?*
 
*3/ If I create more than 1 pane containing these widgest. How do I switch 
between them in scripts?*
** 
*4/ Running this script more than once creates multiple items for Add 
Matplot when pressing the Action button. How do I stop this from happening? 
I have alrewady tried returning a unique integer in * ns_provider_id *but 
that did not work.*
 
</t>
<t tx="ekr.20130806211959.17324">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sun, 16 Sep 2012 22:23:18 -0700 (PDT)
felix74 &lt;hjuucy@googlemail.com&gt; wrote:

&gt; I'm trying to create a interactive chart in a embedded in a new leo pane 
&gt; using matplotlib. However, I am not sure about the the best way  to 
&gt; implement this. I would appreciate some guidance on this please? The 
&gt; questions I would like answered are:
&gt; 1/ How do I create a new blank pane for embedding a chart as well as other 
&gt; QtWidgets.
&gt; 2/ Can I do this in a script or do I need to work with leo source 

You can run this script from any body pane:
---cut here---
from PyQt4 import QtGui
class MatplotPaneProvider:
    def __init__(self, c):
        self.c = c
        if hasattr(c, 'free_layout'):
            splitter = c.free_layout.get_top_splitter()
            if splitter:
                splitter.register_provider(self)
    def ns_provides(self):
        return[('Add matplot', '_add_matplot_pane')]
    def ns_provide(self, id_):
        if id_ == '_add_matplot_pane':
            c = self.c
            w = QtGui.QSlider()
            return w
    def ns_provider_id(self):
        # used by register_provider() to unregister previously registered
        # providers of the same service
        # provider ID is not the same as the service id_ above
        return "completely unique value here"

MatplotPaneProvider(c)
---cut here---

Paste just as above and run the script.  Nothing happens.  Right click
on one of the pane dividers and select Insert.  A new pane with a
button 'Action' appears.  Click it, and select "Add matplot" from the
context menu.

Instead of "w = QtGui.QSlider()", you want "w = myMatplotWidget()"
</t>
<t tx="ekr.20130806211959.17325">From: &lt;fidelperez@gmail.com&gt;

I am going through something similar Matt Wilkie went through in this
post&lt;https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/leopyref/leo-editor/pWyd5ae952I/kvxf_H-QBq4J&gt;
.

Basically I can find interesting functions in LeoPyRef.leo but I dont know 
how to access them from my new leo scripts.

I dont get the difference when I have to call them using g.Functionname(), 
c.functionname(), or when those wont do.

How can I call the function "insertIconFromFile"?
How can I know how to call functions found in LeoPyRef.leo?

Thanks!

Ps: When I get that, I will already have a bookmarks importer from 
chrome/mozilla which will also import the icons of the links! x)
I will prepare some more interesting utils (import mindmap, etc) then 
release them together with manuals oriented to noob users.

</t>
<t tx="ekr.20130806211959.17326">From: &lt;fidelperez@gmail.com&gt;

Sounds great!
So, in the search results, will I be able to know how to call that function?
IE, if I find insertIconFromFile, will I be able to know that I can call it
through using c.editCommands.insertIconFromFile?


On Monday, May 20, 2013 3:47:35 PM UTC+2, Terry wrote:
&gt;
&gt; On Mon, 20 May 2013 04:00:59 -0700 (PDT)
&gt; Fidel P=E9rez &lt;fidel...@gmail.com &lt;javascript:&gt;&gt; wrote:
&gt;
&gt; &gt; Ok, in order to print icons, the code is this:
&gt; &gt;
&gt; &gt; c.editCommands.insertIconFromFile(path)
&gt; &gt;
&gt; &gt; Im quoting from this Leo manual&lt;
&gt; http://leoeditor.com/scripting.html#import-objects&gt;,
&gt; &gt; "inserting and deleting icons" section -_-
&gt; &gt;
&gt; &gt; Although I still have a mess on which functions can be called how, and
&gt; &gt; where to find the list of classes that can be called such as
&gt; "editCommands"
&gt; &gt; and the rest that they might exist.
&gt;
&gt; I'm not aware of a general solution to the problem of finding the
&gt; various pieces of Leo's class structure.  Basically there are all these
&gt; classes defined in the source, and instances of these are attached to
&gt; each other in a hierarchical network (with loops).
&gt;
&gt; I've written an introspection function which lists the methods and
&gt; instance variables (and class variables) of an arbitrary object by name
&gt; and by type.  I should release it.  It builds its lists in a Leo
&gt; outline, so you can navigate around that outline and expand nodes by
&gt; introspection as needed.
&gt;
&gt; It occurs to me that the same code could be used to search Leo's
&gt; runtime object hierarchy for you, i.e. you enter 'insertIconFromFile'
&gt; and it recursively searches for it.
&gt;
&gt; Cheers -Terry
&gt;

</t>
<t tx="ekr.20130806211959.17327">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Mon, May 20, 2013 at 8:47 AM, Terry Brown &lt;terry_n_brown@yahoo.com&gt;wrote:

&gt; On Mon, 20 May 2013 04:00:59 -0700 (PDT)
&gt; Fidel P=C3=A9rez &lt;fidelperez@gmail.com&gt; wrote:
&gt;

&gt; Although I still have a mess on which functions can be called how, and
&gt; where to find the list of classes that can be called such as
"editCommands"
&gt; and the rest that they might exist.

I'm not aware of a general solution to the problem of finding the
&gt; various pieces of Leo's class structure.  Basically there are all these
&gt; classes defined in the source, and instances of these are attached to
&gt; each other in a hierarchical network (with loops).
&gt;

I suppose you could say that there is no general solution, but the
situation isn't really all that difficult.

Start with c.  We know what that is:  it is a commander object representing
an open outline.

There are **official ivars** of c, all referring to wrapper classes defined
in leoFrame.py:

c.frame: an instance of leoFrame.
c.frame.tree: an instance of  leoTree.
c.frame.body: an instance of leoBody.
c.frame.log: an instance of leoLog.

The tree, body and log objects have a *ctrl* objects, which are *wrapper*
classes:

c.frame.tree.treeCtrl
c.frame.body.bodyCtrl
c.frame.log.logCtrl

In particular, see
http://leoeditor.com/scripting.html#c-frame-body-bodyctrlfor a
description of the high-level text interface supported by all
high-level text widgets, including the log and body classes.

These wrapper classes have a widget ivar, which is a reference to the
corresponding Qt widget object.  For example::

    import PyQt4.QtGui as QtGui
    w =3D c.frame.body.wrapper.widget
    g.es(w)
    g.es(isinstance(w,QtGui.QTextBrowser)

yields::

    (LeoQTextBrowser) 62418136
    True

As shown, the LeoQTextBrowser class is a real (subclass of) QTextBrowser.

HTH.  I've made a note to discuss official ivars in more detail in the
scripting chapter.
</t>
<t tx="ekr.20130806211959.17328">From: &lt;fidelperez@gmail.com&gt;

Ok, in order to print icons, the code is this:

c.editCommands.insertIconFromFile(path)

Im quoting from this Leo manual&lt;http://leoeditor.com/scripting.html#import-objects&gt;,
"inserting and deleting icons" section -_-

Although I still have a mess on which functions can be called how, and
where to find the list of classes that can be called such as "editCommands"
and the rest that they might exist.
Thanks!

On Sunday, May 19, 2013 12:43:50 PM UTC+2, Fidel P=E9rez wrote:
&gt;
&gt; Hi, I am going through something similar Matt Wilkie went through in this
&gt; post&lt;https://groups.google.com/forum/?fromgroups=3D#!searchin/leo-editor/leopyref/leo-editor/pWyd5ae952I/kvxf_H-QBq4J&gt;
&gt; .
&gt;
&gt; Basically I can find interesting functions in LeoPyRef.leo but I dont know
&gt; how to access them from my new leo scripts.
&gt;
&gt; I dont get the difference when I have to call them using g.Functionname(),
&gt; c.functionname(), or when those wont do.
&gt;
&gt; How can I call the function "insertIconFromFile"?
&gt; How can I know how to call functions found in LeoPyRef.leo?
&gt;
&gt; Thanks!
&gt;
&gt; Pd: When I get that, I will already have a bookmarks importer from
&gt; chrome/mozilla which will also import the icons of the links! x)
&gt; I will prepare some more interesting utils (import mindmap, etc) then
&gt; release them together with manuals oriented to noob users.
&gt;

</t>
<t tx="ekr.20130806211959.17329">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Mon, 20 May 2013 04:00:59 -0700 (PDT) &lt;fidelperez@gmail.com&gt; wrote:

&gt; Ok, in order to print icons, the code is this:
&gt;
&gt; c.editCommands.insertIconFromFile(path)
&gt;
&gt; Im quoting from this Leo manual&lt;http://leoeditor.com/scripting.html#import-objects&gt;,
&gt; "inserting and deleting icons" section -_-
&gt;
&gt; Although I still have a mess on which functions can be called how, and
&gt; where to find the list of classes that can be called such as "editCommands"
&gt; and the rest that they might exist.

I'm not aware of a general solution to the problem of finding the
various pieces of Leo's class structure.  Basically there are all these
classes defined in the source, and instances of these are attached to
each other in a hierarchical network (with loops).

I've written an introspection function which lists the methods and
instance variables (and class variables) of an arbitrary object by name
and by type.  I should release it.  It builds its lists in a Leo
outline, so you can navigate around that outline and expand nodes by
introspection as needed.

It occurs to me that the same code could be used to search Leo's
runtime object hierarchy for you, i.e. you enter 'insertIconFromFile'
and it recursively searches for it.

Cheers -Terry

</t>
<t tx="ekr.20130806211959.17330">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Mon, 20 May 2013 08:47:35 -0500
Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; On Mon, 20 May 2013 04:00:59 -0700 (PDT)
&gt; Fidel P=E9rez &lt;fidelperez@gmail.com&gt; wrote:
&gt;
&gt; &gt; Ok, in order to print icons, the code is this:
&gt; &gt;
&gt; &gt; c.editCommands.insertIconFromFile(path)
&gt; &gt;
&gt; &gt; Im quoting from this Leo manual&lt;http://leoeditor.com/scripting.html#import-objects&gt;,
&gt; &gt; "inserting and deleting icons" section -_-
&gt; &gt;
&gt; &gt; Although I still have a mess on which functions can be called how, and
&gt; &gt; where to find the list of classes that can be called such as "editCommands"
&gt; &gt; and the rest that they might exist.
&gt;
&gt; I'm not aware of a general solution to the problem of finding the
&gt; various pieces of Leo's class structure.  Basically there are all these
&gt; classes defined in the source, and instances of these are attached to
&gt; each other in a hierarchical network (with loops).

I didn't really finish the above para.  The problem is that it's hard
to guess what the names of the attachment points are, and the attaching
is done in a variety of places, sometimes by factory functions which
further obscure linkages.  Not a fault with Leo, just the way programs
work.  So the tool I've written may be the best approach to mapping
Leo's runtime structure. Another thing it could do, try and map 'major'
classes, or at least classes from leo.core.* - i.e. ignore the built in
types.
</t>
<t tx="ekr.20130806211959.17331">From: SegundoBob &lt;bhossley@ieee.org&gt;

This thread gives a recipe for inserting text into the body of a node
at the current cursor:

http://groups.google.com/group/leo-editor/browse_thread/thread/a08d122e0cf59359/60be2b02f3ef3e94

Unfortunately, this recipe has a problem:  When focus is moved away
from and then back to the modified node, the inserted text
disappears.  That is, Leo-Editor seems unaware of the insertion.

The following recipe fixes this problem:

http://pastebin.com/GAc15jRL

Is this recipe the right way to do it or is there a better way?
</t>
<t tx="ekr.20130806211959.17332">From: SegundoBob &lt;bhossley@ieee.org&gt;

I'm sorry no one has suggested a better way to make the changes
permanent.  How does Leo-Editor notice that typing has inserted a few
more characters?  Couldn't the same mechanism be used here?
</t>
<t tx="ekr.20130806211959.17333">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 17 Apr 2013 12:09:52 -0700 (PDT)
SegundoBob &lt;bhossley@ieee.org&gt; wrote:

&gt; This thread gives a recipe for inserting text into the body of a node
&gt; at the current cursor:
&gt; 
&gt; http://groups.google.com/group/leo-editor/browse_thread/thread/a08d122e0cf59359/60be2b02f3ef3e94
&gt; 
&gt; Unfortunately, this recipe has a problem:  When focus is moved away
&gt; from and then back to the modified node, the inserted text
&gt; disappears.  That is, Leo-Editor seems unaware of the insertion.
&gt; 
&gt; The following recipe fixes this problem:
&gt; 
&gt; http://pastebin.com/GAc15jRL
&gt; 
&gt; Is this recipe the right way to do it or is there a better way?

I think that's the way, see also:

https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/insert$20text$20will$20disappear$20after$20insert$20children$20node$20and$20redraw/leo-editor/0haTWrUlNVg/lFU1JkMHrosJ

Depending on your use you might want to
   
    oldins = w.getInsertPoint() 

    ...

    w.setInsertPoint(oldins+len(inserted_text)) 

to get the cursor where you want it afterwards, lots of variations how
the new position might be calculated.

Other possibly useful methods:

    i,j = w.getSelectionRange(sort=True)
    s = w.getSelectedText()  
</t>
<t tx="ekr.20130806211959.17334">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Wed, 17 Apr 2013 16:53:10 -0700 (PDT)
SegundoBob &lt;bhossley@ieee.org&gt; wrote:

&gt; I'm sorry no one has suggested a better way to make the changes
&gt; permanent.  How does Leo-Editor notice that typing has inserted a few
&gt; more characters?  Couldn't the same mechanism be used here?

I don't think Leo constantly updates p.b from w.getAllText(), but just
does it when focus is lost - not sure about that though.

Here's a thought for a higher level interface.

c.get_edit_state() gives you an instance of a LeoEditState class with
these attributes:

  text attributes

  les.all_text
  les.text_before_select
  les.text_after_select
  les.selected_text
  les.text_before_cursor
  les.text_after_cursor

  integer attributes

  les.selection_start
  les.selection_end
  les.cursor_index

then you can either do

c.set_edit_state(les)

which sets the editor text and p.b to les.all_text and sets up
selection and insert position appropriately from the integers,

or c.set_edit_state(les, mode='selection')
or c.set_edit_state(les, mode='cursor')

which assembles things based on the selection or cursor text attributes.

Thoughts?  So long since I wrote any emacs text manipulation stuff I
can't remember the idiom it used.

Cheers -Terry



&gt; On 04/17/2013 12:29 PM, Terry Brown wrote:&gt; I think that's the way,
&gt; see also:
&gt; &gt;
&gt; &gt; https://groups.google.com/forum/?fromgroups=#!searchin/leo-editor/insert$20text$20will$20disappear$20after$20insert$20children$20node$20and$20redraw/leo-editor/0haTWrUlNVg/lFU1JkMHrosJ
&gt; &gt;
&gt; Thanks.  I vaguely remembered this thread, but I couldn't find it.
&gt; 
&gt; &gt; Depending on your use you might want to
&gt; &gt;
&gt; &gt;     oldins = w.getInsertPoint()
&gt; &gt;
&gt; &gt;     ...
&gt; &gt;
&gt; &gt;     w.setInsertPoint(oldins+len(inserted_text))
&gt; 
&gt; http://pastebin.com/GAc15jRL  uses both w.getInsertPoint() and
&gt; w.setInsertPoint()
&gt; 
&gt; &gt;
&gt; &gt; to get the cursor where you want it afterwards, lots of variations how
&gt; &gt; the new position might be calculated.
&gt; &gt;
&gt; &gt; Other possibly useful methods:
&gt; &gt;
&gt; &gt;     i,j = w.getSelectionRange(sort=True)
&gt; &gt;     s = w.getSelectedText()
&gt; 
&gt; Yes, these are very useful.
&gt; 
</t>
<t tx="ekr.20130806211959.17335">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Fri, 12 Apr 2013 10:09:40 +0800
HaveF &lt;iamaplayer@gmail.com&gt; wrote:

&gt; My workflow is like this
&gt; [e.g., I want to select some text in the body and make transform, then
&gt; insert to the body again]:

Your workflow make sense for the general case of doing any arbitrary
thing with Leo.  For the specific case of manipulating text, I think
the API could be improved, or, seeing the existing API make sense for
what it is, we could have additional "easy text manipulation" API.
So long since I used Emacs I can't really remember its model, and if it
would apply here.
</t>
<t tx="ekr.20130806211959.17336">From: &lt;lzyerste@gmail.com&gt;

If I want to use leo to make mathematical notes, how can I type in some
special mathematical sysbols? Or is there a good way to make mathematical
notes using leo?

===== Terry

I use itex2MML with reStructuredText.  So within Leo you're looking at
LaTeX math markup, and you get outputs in PDF and XHTML, with MathML in
the latter.

===== &lt;jose.i.rojas@gmail.com&gt;

I've been doing this for about a year now.  I use the math docutils 
directive.  A custom .XCompose file (for example: 
https://github.com/kragen/xcompose)  also helps.

===== Terry

I think math was added to docutils after I started using itex2mml,
neater to use docutils built in math now I think.

Although having said that, playing with docutils math a bit suggests
itex2mml gives more complete support for both MathMML and perhaps LaTeX
math (with the PDF target).

===== jose

Terry, your setup is probably more flexible, but I haven't had any problems with 
docutils math. It seems to support all the syntax that I've found necessary.

I forgot to mention that the viewrendered plug-in doesn't display math 
correctly.  I'm not sure what the problem is, I remember trying to figure 
it out a while back, but I never got anywhere.  It's not really a big 
problem though, I have scripts to compile nodes to html/pdfs and open them 
in firefox/pdf reader; math works fine that way.

===== From: offray@riseup.net

Is not properly Leo, but is python related, tailored for math and with a
web interface and has leo bindings, check Ipython:

http://ipython.org/

I'm using it for all my math related writing and I think that point the
future of interactive writing in Python. I dream of a body pane on leo
with the features of the pyton qt console.
</t>
<t tx="ekr.20130806211959.17337">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Just pushed leo/external/leoftsindex.py:

Stand alone GUI free index builder for Leo's full text search system::

  python leoftsindex.py &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;...

If &lt;file&gt; does not contain '#' it's assumed to be a .leo file
to index, and is indexed.

If &lt;file&gt; does contain '#' it's assumed to be a .leo file
containing a list of .leo files to index, with the list in
the node indicated by the UNL after the #, e.g.::

   path/to/myfile.leo#Lists--&gt;List of outlines

In the latter case, if the node identified by the UNL has children,
the list of files to scan is built from the first line of the body
of each child node of the identified node (works well with bookmarks.py).
If the node identified by the UNL does not have children, the
node's body is assumed to be a simple text listing of paths to .leo files).

note::
    
    It may be necessary to quote the "file" on the command line,
    as the '#' may be interpreted as a comment delimiter::
        
        python leoftsindex.py "workbook.leo#Links"
</t>
<t tx="ekr.20130806211959.17339">From: Alexandre_Toledo &lt;jalexandretoledo@gmail.com&gt;

As I use Leo to write PL/SQL code, I need to write similar text several
times, changing only small parts of it. It would be great if I could create
a node with the "template" and then clone it everywhere it should be
written, and then providing the parameters to be used in this writing.

Let me try to clarify it. I'd like to create a tree like this:

 +- @file something.sql
           +- Section 1
              + &lt;&lt; Clone &gt;&gt; with Parameters A, B
           +- Section 2
              + &lt;&lt; Clone &gt;&gt; with Parameters C, D

In this tree, both "Clone" nodes would be generated from a template
specified somewhere in the tree, and would have parts of its text replaced
with values "A" and "B" in Section 1, and "C" and "D" in Section 2.

I've searched but couldn't find anything like this, then I've thought of
trying to write a hook to intercept the "save" command, but couldn't think
of a way to pass the parameters; I think the obvious way would be to put
the parameters after the "&lt;&lt; &gt;&gt;", but then all cloned nodes are changed, so
it wouldn't work.

Another alternative would be creating some kind of directive @something,
but I have no idea of how to do that.

Any ideas?
</t>
<t tx="ekr.20130806211959.17340">From: =?UTF-8?Q?Fidel_P=C3=A9rez?= &lt;fidelperez@gmail.com&gt;



Content-Transfer-Encoding: quoted-printable

I know a programming IDE &lt;http://sourceforge.net/projects/doublesvsoop/&gt;which bases its existence in that concept:

You write "code Masks" and whenever you call a piece of code it will ask
only for the parameters, and write the rest of the code. There are already
some languages with most of the masks (all the primary functions and some
complex ones) and its growing.

For instance, if you write:

"window" it will add the window to the code and let you edit the params.

Their functionality would be awesome in Leo and when I know a bit better I
will try to emulate on it.
Sticking to Leo tho since it has a much superior way of managing data.


On Saturday, May 4, 2013 12:48:27 AM UTC+2, Jo=E3o Alexandre Toledo wrote:
&gt;
&gt; Hi,
&gt;
&gt; Sorry for the delay... I'll try it this weekend and see how it works.
&gt;
&gt; Thank you.
&gt;
&gt; Jo=E3o
</t>
<t tx="ekr.20130806211959.17341">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sun, 5 May 2013 16:35:59 -0700 (PDT)
Fidel P=E9rez &lt;fidelperez@gmail.com&gt; wrote:

&gt; I know a programming IDE &lt;http://sourceforge.net/projects/doublesvsoop/&gt;which bases its existence in that concept:
&gt;
&gt; You write "code Masks" and whenever you call a piece of code it will ask
&gt; only for the parameters, and write the rest of the code. There are already
&gt; some languages with most of the masks (all the primary functions and some
&gt; complex ones) and its growing.

I suspect different people have different things in mind when they talk
about templates.

Leo's abbreviation system is already quite advanced when it comes to
filling in skeletons of common code layouts.  I type

  def;;

and I get

  def foo(this, that=3D3):
      """foo - Return
 
      :Parameters:
      - `this`: describe this
      - `that`: &lt;|describe that|&gt;
      """
 
      &lt;|code|&gt;

Two "parameters" are interactively requested, the function name, and
the list of arguments.  The node name is presented as the default for
the function name, and 'self' is included in the list of arguments, so,
assuming the node was already called 'foo', all I type is this, that=3D3.
The layout above is the rst form of the epydoc/sphinx docstring with
formally identified parameters.

The cursor is positioned after Return, where the was an empty &lt;||&gt;
placeholder.  Pressing ,, selects the next placeholder so that typing
replaces it.

There's more, see
https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/5ni2PwfmBz8
and the screencast linked from there
http://www.greygreen.org/tmp/leoabbrev.ogv

Other people, Jacob etc. I think, have been talking about templates
where the input parameters are stored in the outline, allowing for
some of them to be altered and the template generation step re-run.
More like generating a website from data etc.

Cheers -Terry

</t>
<t tx="ekr.20130806211959.17342">From: =?UTF-8?Q?Jo=C3=A3o_Alexandre_Toledo?= &lt;jalexandretoledo@gmail.com&gt;

Hi,

Sorry for the delay... I'll try it this weekend and see how it works.

Thank you.

Jo=E3o

</t>
<t tx="ekr.20130806211959.17343">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

--001a11c27f4813f73804dbad029f

Content-Transfer-Encoding: quoted-printable

On Wed, Nov 21, 2012 at 8:55 AM, Jo=E3o Alexandre Toledo &lt;
jalexandretoledo@gmail.com&gt; wrote:

&gt;
&gt; As I use Leo to write PL/SQL code, I need to write similar text several
&gt; times, changing only small parts of it. It would be great if I could create
&gt; a node with the "template" and then clone it everywhere it should be
&gt; written, and then providing the parameters to be used in this writing.
&gt;

Variants of this seem to be wanted by many people.  Most recently, there is
the thread, "Templates with macro expansions",
https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/nF2lUEUtaUE

Does that do what you want?

Edward

--001a11c27f4813f73804dbad029f

Content-Transfer-Encoding: quoted-printable

&lt;div dir=3D"ltr"&gt;On Wed, Nov 21, 2012 at 8:55 AM, Jo=E3o Alexandre Toledo &lt;span dir=3D"ltr"&gt;&amp;lt;&lt;a href=3D"mailto:jalexandretoledo@gmail.com" target=3D"_blank"&gt;jalexandretoledo@gmail.com&lt;/a&gt;&amp;gt;&lt;/span&gt; wrote:&lt;br&gt;&lt;div class=3D"gmail_extra"&gt;
&lt;div class=3D"gmail_quote"&gt;&lt;blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-left:1px solid rgb(204,204,204);padding-left:1ex"&gt;&lt;br&gt;&lt;div&gt;As I use Leo to write PL/SQL code, I need to write similar text several times, changing only small parts of it. It would be great if I could create a node with the &amp;quot;template&amp;quot; and then clone it everywhere it should be written, and then providing the parameters to be used in this writing.&lt;/div&gt;
&lt;/blockquote&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Variants of this seem to be wanted by many people.=A0 Most recently, there is the thread, &amp;quot;Templates with macro expansions&amp;quot;, &lt;a href=3D"https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/nF2lUEUtaUE"&gt;https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/nF2lUEUtaUE&lt;/a&gt;&lt;br&gt;
&lt;br&gt;&lt;/div&gt;&lt;div&gt;Does that do what you want?&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;Edward&lt;br&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

--001a11c27f4813f73804dbad029f--
</t>
<t tx="ekr.20130806211959.17344">From: =?UTF-8?Q?Fidel_P=C3=A9rez?= &lt;fidelperez@gmail.com&gt;



Content-Transfer-Encoding: quoted-printable

Thank you Terry, that is exactly what I would like meant.

Is there a website where abbreviation files are shared so newcomers can
quickly being to use advanced abbreviations?
Id love to download a python version x)

On Monday, May 6, 2013 5:13:42 AM UTC+2, Terry wrote:
&gt;
&gt; On Sun, 5 May 2013 16:35:59 -0700 (PDT)
&gt; Fidel P=E9rez &lt;fidel...@gmail.com &lt;javascript:&gt;&gt; wrote:
&gt;
&gt; &gt; I know a programming IDE &lt;http://sourceforge.net/projects/doublesvsoop/&gt;which
&gt; bases its existence in that concept:
&gt; &gt;
&gt; &gt; You write "code Masks" and whenever you call a piece of code it will ask
&gt; &gt; only for the parameters, and write the rest of the code. There are
&gt; already
&gt; &gt; some languages with most of the masks (all the primary functions and
&gt; some
&gt; &gt; complex ones) and its growing.
&gt;
&gt; I suspect different people have different things in mind when they talk
&gt; about templates.
&gt;
&gt; Leo's abbreviation system is already quite advanced when it comes to
&gt; filling in skeletons of common code layouts.  I type
&gt;
&gt;   def;;
&gt;
&gt; and I get
&gt;
&gt;   def foo(this, that=3D3):
&gt;       """foo - Return
&gt;  
&gt;       :Parameters:
&gt;       - `this`: &lt;|describe this|&gt;
&gt;       - `that`: &lt;|describe that|&gt;
&gt;       """
&gt;  
&gt;       &lt;|code|&gt;
&gt;
&gt; Two "parameters" are interactively requested, the function name, and
&gt; the list of arguments.  The node name is presented as the default for
&gt; the function name, and 'self' is included in the list of arguments, so,
&gt; assuming the node was already called 'foo', all I type is this, that=3D3.
&gt; The layout above is the rst form of the epydoc/sphinx docstring with
&gt; formally identified parameters.
&gt;
&gt; The cursor is positioned after Return, where the was an empty &lt;||&gt;
&gt; placeholder.  Pressing ,, selects the next placeholder so that typing
&gt; replaces it.
&gt;
&gt; There's more, see
&gt; https://groups.google.com/forum/?fromgroups=3D#!topic/leo-editor/5ni2PwfmBz8
&gt; and the screencast linked from there
&gt; http://www.greygreen.org/tmp/leoabbrev.ogv
&gt;
&gt; Other people, Jacob etc. I think, have been talking about templates
&gt; where the input parameters are stored in the outline, allowing for
&gt; some of them to be altered and the template generation step re-run.
&gt; More like generating a website from data etc.
&gt;
&gt; Cheers -Terry
&gt;
</t>
<t tx="ekr.20130806211959.17345">From: =?UTF-8?Q?Jo=C3=A3o_Alexandre_Toledo?= &lt;jalexandretoledo@gmail.com&gt;



Content-Transfer-Encoding: quoted-printable

Hi,

I've tried it and it's great, I think it will be useful, but it's not what
I was thinking of...

Let me try to explain what I had tougth about... What I would like to do is:

 1. create a new .leo file
 2. add a "template" node (eventually with sub nodes) with some ${schema}
and ${table} macro place holders in its contents
 3. add a @file node to the .leo file
 4. add to this @file node a new one with definitions such as
schema=3DSCHEMA_NAME and table=3DTABLE_NAME
 5. add as a sub node to this last one a clone from the "template" node;
 6. then, when I save everything, the @file would have "SCHEMA_NAME" and
"TABLE_NAME" everywhere a "${schema}" or a "${table}" were in the original
template node.

It would be important that, when I reopen the .leo file later, the macros
in the @file node where shown as ${schema} and ${table}, and not as it's
substituted text.

Now that I've described it, I can't see how it would be done... The
${macro} place holders should be on the contents of the @file node, so
after substitution, how could we recover it?

That's also why the code from Jacob is not what I need (but I'm already
thinking of other uses for it :) ): it will create a text when the button
is pressed, but the generated nodes will be just static text.


Thank you all.

Leo is great!


Jo=E3o


On Friday, May 3, 2013 7:48:27 PM UTC-3, Jo=E3o Alexandre Toledo wrote:
&gt;
&gt; Hi,
&gt;
&gt; Sorry for the delay... I'll try it this weekend and see how it works.
&gt;
&gt; Thank you.
&gt;
&gt; Jo=E3o
</t>
<t tx="ekr.20130806211959.17346">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

I have a note that it was an @rclick node handled by the context_menu.py 
plugin, but I am not able to see code or documentation anywhere.  This 
seems *well* hidden :-)
</t>
<t tx="ekr.20130806211959.17347">From: Kent Tenney &lt;ktenney@gmail.com&gt;

I don't have any visual indication of the existence of @rclick nodes,
it would be nice.

Something I've found useful is adding a @click node like:
@rclick -------------

that separates my entries from the ever present
'Remove Button' and 'Goto Script' entries
</t>
<t tx="ekr.20130806211959.17349">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Apr 11, 2013 at 8:10 PM, Edward K. Ream &lt;edreamleo@gmail.com&gt; wrote:

I prefer a bigger triangle:  =E2=96=BC U=3D25BC: Black Down-Pointing Triangle.

One more thing.  It's reasonable to have the top-level button just be a
placeholder for subsidiary @rclick nodes.  To do that without getting a
warning when clicking the top-level button, set its script to "empty
string".
</t>
<t tx="ekr.20130806211959.17350">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Thu, 11 Apr 2013 00:56:51 -0700 (PDT)
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; I have a note that it was an @rclick node handled by the context_menu.py 
&gt; plugin, but I am not able to see code or documentation anywhere.  This 
&gt; seems *well* hidden :-)

:) It's in the core, not context_menu.py.  It was a long time ago, but
I remember finding the @button code tricky, so I'm not sure if it's an
ideal implementation.  OTOH it hasn't broken for 1-2 years.

Cheers -Terry

</t>
<t tx="ekr.20130806211959.17351">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Apr 11, 2013 at 2:56 AM, Edward K. Ream &lt;edreamleo@gmail.com&gt; wrote:

One more thing.  I can now put an @rclick node under an @button node, and
right-clicking the created top-level button work pretty much as expected.

But I remember that on your machine there was some indicator (a triangle?)
in the top-level button indicating that it had structure.  Is that the
case?  If so, how did you create such buttons?
</t>
<t tx="ekr.20130806211959.17352">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Thu, 11 Apr 2013 13:50:25 -0500
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; On Thu, Apr 11, 2013 at 2:56 AM, Edward K. Ream &lt;edreamleo@gmail.com&gt; wrote:
&gt;
&gt; One more thing.  I can now put an @rclick node under an @button node, and
&gt; right-clicking the created top-level button work pretty much as expected.
&gt;
&gt; But I remember that on your machine there was some indicator (a triangle?)
&gt; in the top-level button indicating that it had structure.  Is that the
&gt; case?  If so, how did you create such buttons?

@settings
   @string mod_scripting_subtext =3D =E2=96=BE
</t>
<t tx="ekr.20130806211959.17353">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Thu, 11 Apr 2013 20:15:33 -0500
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; On Thu, Apr 11, 2013 at 8:10 PM, Edward K. Ream &lt;edreamleo@gmail.com&gt; wrote:
&gt;
&gt; I prefer a bigger triangle:  =E2=96=BC U=3D25BC: Black Down-Pointing Triangle.
&gt;
&gt; One more thing.  It's reasonable to have the top-level button just be a
&gt; placeholder for subsidiary @rclick nodes.  To do that without getting a
&gt; warning when clicking the top-level button, set its script to "empty
&gt; string".

I think you mean set its script to a docstring describing the
functions it groups together for the tooltip hover text :-)
</t>
<t tx="ekr.20130806211959.17355">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thu, Apr 11, 2013 at 7:29 AM, Terry Brown &lt;terry_n_brown@yahoo.com&gt;wrote:

&gt; On Thu, 11 Apr 2013 00:56:51 -0700 (PDT)
&gt; "Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:
&gt;
&gt; &gt; I have a note that it was an @rclick node handled by the context_menu.py
&gt; &gt; plugin, but I am not able to see code or documentation anywhere.  This
&gt; &gt; seems *well* hidden :-)
&gt;
&gt; :) It's in the core, not context_menu.py.  It was a long time ago, but
&gt; I remember finding the @button code tricky, so I'm not sure if it's an
&gt; ideal implementation.  OTOH it hasn't broken for 1-2 years.
&gt;

Thanks.  I could have sworn I searched Leo's core for @rclick.  Must have
been a searching failure :-)  The code is in
qtIconBarClass.setCommandForButton.

I'll add documentation for this, in leoSettings.leo and also in the
customizing Leo chapter.
</t>
<t tx="ekr.20130806211959.17356">From: HaveF &lt;iamaplayer@gmail.com&gt;

I have read the scripting chapter of leo-editor, and already make my daily
life easier with these quick dirty, but useful scripts.

And I just want to know your workflow of writing leo scripts.

My workflow is like this
[e.g., I want to select some text in the body and make transform, then
insert to the body again]:

1. Abstract the action of word.
[in this case, I choose "select" and "insert" as my key words]

2. search the words at http://leoeditor.com/scripting.html see if there is
existing some related topics.
[I have luck to find
i = w.getInsertPoint()              # Return the location of the cursor.
...
i,j = w.getSelectionRange(sort=True)
...
s = w.getSelectedText()             # Return the selected text, if any.
]

3. but I still don't know how to insert the text to body. So I search the
above function names in the scripts.leo to see the code.
[ I find in
scripts.leo#Scripts--&gt;@thin leoScripts.txt--&gt;Text editing scripts--&gt;insert
begin/endUpdate
...
w.insert(i,s1+'\\n\\t\\t\\n'+s2)
...
seems to help
]

4. test the scripts to see if it works, if it doesn't work, go to 3, to
find more example code.

Any suggestion to improve this workflow?
</t>
<t tx="ekr.20130806211959.17357">From: Terry Brown

The script below is a tool for diffing two Leo files. The attached
screenshot illustrates the output for two different revisions of
LeoPyRef.leo.

``- nodename``
    indicates a node which disappeared
``+ nodename``
    a node which is new,
``!v nodename`` followed by ``!^ nodename``
    a node with an unchanged heading but changed content, the first
    linking to the old version, the second linking to the new version

If you have the bookmarks.py plugin active, you can double click nodes
to jump to the original(s).



from leo.core.leoNodes import vnode
if not hasattr(vnode, 'insertAsLastChild'):
    # add insertAsLastChild method to vnodes
    def ialc(self):
        vnode(self.context)._linkAsNthChild(self, len(self.children))
        return self.children[-1]
    vnode.insertAsLastChild = ialc

from_filename = g.app.gui.runOpenFileDialog('From (old) file', [('Leo', '*.leo')])
to_filename = g.app.gui.runOpenFileDialog('To (new) file', [('Leo', '*.leo')])

# from_filename = "/mnt/shuttle/bkup/usr1/2012-07-13/home/tbrown/.leo/.todo.leo"
# to_filename = "/mnt/shuttle/bkup/usr1/2012-07-15/home/tbrown/.leo/.todo.leo"

from_c = g.openWithFileName(from_filename, c)
to_c = g.openWithFileName(to_filename, c)

vf = from_c.hiddenRootNode
vt = to_c.hiddenRootNode

assert from_c != c
assert to_c != c
assert from_c != to_c

nd = c.rootPosition().insertAfter()
nd.copy().back().moveAfter(nd)
nd.h = 'diff @bookmarks'

def text_match(a, b):
    return (a.h == b.h, 
            a.h == b.h and a.b == b.b)
def gnx_match(a, b):
    return (a.h == b.h and a.gnx == b.gnx, 
            a.h == b.h and a.b == b.b and a.gnx == b.gnx)

def diff_trees(vf, vt, path):

    fonly = []  # nodes only in from tree
    tonly = []  # nodes only in to tree
    diffs = []  # nodes which occur in both but have different descendants

    # count number of times each headline occurs as a child of
    # each node being compared
    count_f = {}
    for cf in vf.children:
        count_f[cf.h] = count_f.get(cf.h, 0) + 1
    count_t = {}
    for ct in vt.children:
        count_t[ct.h] = count_t.get(ct.h, 0) + 1

    for cf in vf.children:
        
        for ct in vt.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            
            if body_eq:
                diffs.append(diff_trees(cf, ct, path+[vf.h]))
                
                break
            elif head_eq:
                d = diff_trees(cf, ct, path+[vf.h])
                if d:
                    d.h = '!v '+d.h
                else:
                    d = vnode(nd.v.context)
                    d.h = '!v '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    from_filename, 
                    '--&gt;'.join((path+[vf.h]+[cf.h])[1:]),
                    cf.b
                )
                diffs.append(d)
                d = vnode(nd.v.context)
                d.h = '!^ '+cf.h
                d.b = "file://%s/#%s\\n\\n%s" % (
                    to_filename, 
                    '--&gt;'.join((path+[vt.h]+[ct.h])[1:]),
                    ct.b
                )
                diffs.append(d)
                break
        else:
            fonly.append(cf)
            
    for ct in vt.children:
        
        for cf in vf.children:
            
            if count_f[cf.h] == 1 and count_t[ct.h] == 1:
                equal = text_match
            else:
                equal = gnx_match
            
            head_eq, body_eq = equal(cf, ct)
            if head_eq or body_eq:
                # no need to recurse matches again
                break

        else:
            tonly.append(ct)

    if not any(diffs) and not fonly and not tonly:
        return None
        
    vd = vnode(nd.v.context)
    vd.h = vf.h
    for d in diffs:
        if d:
            vd.children.append(d)
    for f in fonly:
        n = vd.insertAsLastChild()
        n.h = '- '+f.h
        n.b = "file://%s/#%s" % (from_filename, '--&gt;'.join((path+[vf.h]+[f.h])[1:]))
    for t in tonly:
        n = vd.insertAsLastChild()
        n.h = '+ '+t.h
        n.b = "file://%s/#%s" % (to_filename, '--&gt;'.join((path+[vf.h]+[t.h])[1:]))
        
    return vd

v = diff_trees(vf, vt, [])
if v:
    nd.v.children.extend(v.children)  # snip off &lt;hidden root node&gt;

c.bringToFront()
c.redraw()
</t>
<t tx="ekr.20130806211959.17358">From: resi147 &lt;scalet@yebu.de&gt;




Hi Terry,

I tried this one and it seems to be very useful. What I would also like to 
have is a similar (or the same) script,
that does the same on two different nodes of a leo file. I admit, the 
changes should be minimal to be done by
myself, but as I'm not familiar with the internal leo api, I wanted to ask 
for how to best do this changes.

Probably somewhere here
"""
...
vf = from_c.hiddenRootNode 
vt = to_c.hiddenRootNode
...
"""
just to feed in the 2 nodes, Any quick idea how this can be done the best 
way?
</t>
<t tx="ekr.20130806211959.17359"></t>
<t tx="ekr.20130806211959.17360">From: Rickard Lindberg &lt;ricli85@gmail.com&gt;

I wrote a blog post about how Leo can be used to improve the organization 
of our code bases.

If you are interested, you can read it over here: 
http://reflectionsonprogramming.com/2013/02/related-things-are-not-kept-together/

===== From: Randy Kramer &lt;rhkramer@gmail.com&gt;

Very interesting--I'm happy to see someone thinking about how to make 
understanding code bases easier.  (I'm a rather old wannabee programmer, so 
I'm not sure it will ever be of much use to me, nor that I can offer cogent 
comments.)

Are you familiar with the concept of literate programming as espoused by
Donald Knuth and others?

===== Rickard

Yes. I've read about literate programming and also tried it. I found that it
didn't work so well for me for the following reasons (At least that's what I
remember. It was many years since I tried.):

* Focus on text first instead of code made it harder for me to produce
  working code. I sometimes learn how to do something by trying it out and
  then refactor the solution.

* Unless you read the PDF (or whatever the final output is) you loose the
  structure. At least I did. It was just one big file with all kinds of
  things mixed together. An outline structure solves this problem.

===== Randy

If so, did that influence you at all, and, if so how? (Not that I think
literate programming is the way forward, although I like the concept and
have experimented with it--I once wrote a rather large Visual Basic (I
know, what can I say, I was stuck in the Microsoft world at the time)
program using a literate programming approach. I got it working to a
degree, but eventually had to devote more time to other things so never got
it fully up to spec.

===== Rickard

It influenced me mostly in that I started to think about how to best
present programs so that humans can understand them. I'm not sure literate
programming like Knuth uses it is the best way (in particular, I think the
programs are harder to modify), but I also think that a folder with just
source code is not so good either.
</t>
<t tx="ekr.20130806211959.17363">From: Matt Wilkie &lt;maphew@gmail.com&gt;

Nice article Rickard, I think it captures the background problem well.

I'm not sure the images communicate clones effectively -- but don't really
have an alternative suggestion that would be an improvement. It's just
really hard to appreciate how well they work without experiencing them!
</t>
<t tx="ekr.20130806211959.17364">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

On Sun, 24 Feb 2013 03:12:16 -0800 (PST)
Rickard Lindberg &lt;ricli85@gmail.com&gt; wrote:

&gt; I wrote a blog post about how Leo can be used to improve the organization 
&gt; of our code bases.
&gt; 
&gt; If you are interested, you can read it over here: 
&gt; http://reflectionsonprogramming.com/2013/02/related-things-are-not-kept-together/

Interesting - the python web application framework Django is really
tough in that regard, you might simultaneously want to work on python,
html template, css, java-script, url-dispatch, tests, model definitions.
In fact I've just made some updates to the bookmarks display plugin
which make using it effectively smoother, for a mouse user, anyway, to
help with this.  Will push them soon.
</t>
<t tx="ekr.20130806211959.17365">Josef &lt;joe_da@gmx.net&gt;
7/30/12
		
Recently I evaluated docear - a mind-mapping tool for collecting reference
data (written in Java). It automatically extracts bookmarks and annotations
from PDF files, and more, but it's support for authoring is still not up to
the task. I think it would be great if Leo could do some of the tasks
docear is doing.

Leo is primarily a literate programming editor, but also quite good at
organizing bits of information. Dragging a PDF into Leo currently just
creates an url to the PDF. This could be expanded to also extract data
(bookmarks, notes) from the PDF and to sync this data between Leo and the
PDF. This info could be placed in child nodes: bookmarks and notes could
even jump directly to the page in the PDF (although each PDF viewer seems
to have a different syntax for doing that). This would be a great way to
organize data sheets and specifications stemming from external sources.

Combining the above with an improved LaTeX support, one would get a very
powerful research and authoring tool - in my opinion with a much more
convenient interface than docear.

Perhaps it is too much work to duplicate all the work docear is doing. An
alternative may be to sync data somehow between docear and Leo. Docear
stores the data in a freeplane mind-map. Has anyone else thoughts about
this? Offray Vladimir Luna Cárdenas offray@riseup.net via googlegroups.com
	
7/30/12
		
I have been using Leo to write my thesis. I didn't know about Docear, but
my use was in some sense similar. I have a lot of @url links pointint to
the pdfs files and in a subtree I cut and paste the text of the pdf I want
to comment and made the comments inside the tree. These pdf were part of my
bibliographic entries and I'm now writing a .bib file for these, so I can
have in only one Leo tree all my thesis, with all the references to
external files and the annotations and bibtex entries for them. For me the
key point of Leo in academic writing is the tree view plus the clones and
ignore nodes. My thesis can have several layers, the external ones being
the actual writing and the deeper ones the references, texts, images, tools
that enable me to do that writing. Using clones and @rst-no-head directives
I can have the level of granularity of a paragraph, something that is not
possible on traditional word processor which are the writing tool of tools
like docear. This approach have some glitches:

* I still need to do some fine tunning to the LaTeX export for writing the
pdf as I want. I imagine that putting sphinx in the tool chain could change
that.

* I can not get much people of my companions using this advangages, besides
of myself, because of the difficult installation process of Leo in
Windows/Mac and the not so friendly interface for non-programmers. Other
light markup structured text writing programs like Nested[1] are more
easily used and understood despite of not having all the advantages and
flexibility of Leo.

So, in resume, may be the better approach is connecting Leo to Docear, so
you can have the advantages of both in terms of easy multiplataform
installation and friendly interface of the later and programmability,
flexibility and deeper organic structure of the former.

Offray

Terry Brown &lt;terry_n_brown@yahoo.com&gt;


&gt; Recently I evaluated docear - a mind-mapping tool for collecting reference
&gt; data (written in Java). It automatically extracts bookmarks and annotations
&gt; from PDF files, and more, but it's support for authoring is still not up to
&gt; the task. I think it would be great if Leo could do some of the tasks
&gt; docear is doing.
&gt;
&gt; Leo is primarily a literate programming editor, but also quite good at
&gt; organizing bits of information.

I would describe it as an general purpose outline that's very good at
editing code.

&gt; Dragging a PDF into Leo currently just
&gt; creates an url to the PDF. This could be expanded to also extract data
&gt; (bookmarks, notes) from the PDF and to sync this data between Leo and the
&gt; PDF. This info could be placed in child nodes: bookmarks and notes could
&gt; even jump directly to the page in the PDF (although each PDF viewer seems
&gt; to have a different syntax for doing that). This would be a great way to
&gt; organize data sheets and specifications stemming from external sources.

I'm not really sure how notes get embedded in PDFs.  As an aside, there
is also capability for using Leo to manage bookmarks to web pages, with
notes, tags, and snippets.  Look at the mod_http plugin.  It uses a
javascript bookmark button in your browser to communicate with Leo.

&gt; Combining the above with an improved LaTeX support, one would get a very
&gt; powerful research and authoring tool - in my opinion with a much more
&gt; convenient interface than docear.
&gt;
&gt; Perhaps it is too much work to duplicate all the work docear is doing. An
&gt; alternative may be to sync data somehow between docear and Leo. Docear
&gt; stores the data in a freeplane mind-map. Has anyone else thoughts about
&gt; this?

Syncing between the two sounds a little cumbersome to me.  I wonder if
the PDF stuff could be integrated with some sort of BibTeX .bib file
management?

Do you really need the mindmap UI of docear?  I used to use Freemind
which has a very similar interface, but switched to Leo.  I like what
http://cmap.ihmc.us/ does, but it only does idea organization, no
authoring etc.  To me cmaptools is better at idea organizing than
mindmaps.

There is also the backlinks plugin for Leo, which allows arbitrary
networks of links instead of just the directed tree, and graphcanvas,
which allows graph layout of nodes.  There aren't comparable with the
mindmap layouts, but they head in that direction.  Also note Leo's
hidden UI flexibility in the context menus on the pane dividers, you
can open a new window for the graphcanvas plugin, which gives it much
needed screen real estate.

Cheers -Terry

Josef &lt;joe_da@gmx.net&gt;
7/30/12
		
no, I do not need the mindmap stuff at all. I had a look at short look at
cmaptools, and I agree the generalized graph approach seems better than a
standard mindmap. But I am quite happy with the tree view in Leo and as you
already mentioned, this can be extended with backlinks etc. I have used Leo
already to organize reference documents and write documentation (using
Latex).

What I do want is links to a particular page of a PDF - links to just a
file are not enough when you refer to documents with 100+ pages.
Unfortunately this seems to be difficult to achieve in a cross-platform
way, particular when trying to support different PDF viewers. Docear is
solving this (and other compatibility problems) by developing its own
integrated viewer (I do not suggest to do this for Leo).

On second thought, I don't think that extracting the bookmark and
annotation info is really important to me - I would keep that info in the
PDF, anyhow. I would write inside Leo addional notes, and the output text
(in Latex).

Some integration of Bibtex may be a good thing and needs to be thought out
- perhaps by using JabRef for this, or by recycling some pyBibliographer
code, but this is also low on my priority list.

Offray seems to have a very similar use case as I - although I do not write
a thesis, but specifications for scientific instruments. The point about
cross-platform installation ease is also well taken, so I will look into
some inter-operability here (either with docear or cmaptools). I see Leo
mainly as a personal project / information manager: the leo tree is not
easily shared with others, while the files Leo points to with @url, @auto,
@file etc can be shared quite easily. In this I use Leo as *my personal*
view on the project.

Ville Vainio &lt;vivainio@gmail.com&gt;
7/30/12
		
It seems that e.g. w/ foxit reader, you can open selected page from command
line (-n 123). Abstracting this for other pdf readers that support such a
thing should be no problem.
 
On Monday, July 30, 2012 8:08:23 PM UTC+2, Ville M. Vainio wrote:
     
    It seems that e.g. w/ foxit reader, you can open selected page from
    command line (-n 123). Abstracting this for other pdf readers that
    support such a thing should be no problem.
    
Yes, I suppose one could translate from a canonical representation inside
Leo to whatever the tool needs (using @setting). Ideally, one would even
have a choice between opening the new page in a different or in the same
PDF viewer instance as the last page, but few viewers support that (Okular
does - but I don't know any cross-platform solution).
</t>
<t tx="ekr.20130806211959.17366">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

I've added an abbreviation to my myLeoSettings.leo abbreviations:
https://gist.github.com/tbnorth/5530059

It's the abbreviation "persist;;" and when you type that you get:

---cut here---
import json

json_state_file = "cache_info_file.json"
if not os.path.exists(json_state_file):
    json.dump({'cache_items':{}}, open(json_state_file, 'w'))
cache_info = json.load(open(json_state_file))

def main():

    # do stuff with cache_info...

if __name__ == '__main__':

    try:
        main()
    except:
        json.dump(cache_info, open(json_state_file, 'w'))
---cut here---

with appropriate interaction to customize all the parts which, in the
above example, include "cache_", i.e. the filename and the variable
name.

The point is it seems silly to create a module and hence a dependency
for what is barely 4 lines of actual code, but those 4 lines give you
very handy robust persistence, so something like an editor abbreviation
is the obvious way to make the available - nothing Leo specific here,
except that only serious editors have abbreviation like that ;-).
</t>
<t tx="ekr.20130806211959.17369">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;


&gt; How do you use the code inserted by the abbreviation? 

The corrected version is below for reference - I had `except` instead
of `finally` in the first version, so you data was only saved if
something went wrong :-)

It's just a framework for providing a dictionary the contents of which
persist between runs of the program.  I've used it for code that's
making lots of small url requests against a server, to cache the
results so that during development the crash / debug / re-run cycle is
faster because each piece of data is requested only once, ever, not once
every run.  More recently I was using it to store key value pairs of
filenames and a comment on the issue in the file, knowing that
completing the analysis of the issues in the files would take more than
one run of the program which was identifying the issues.

So in the example below, the content of the cache_info dictionary is
persistent, whatever main() does with it is seen next time the
program's run.  Nothing Leo specific except that it's really just an
import statement plus 5 lines of code and doesn't seem worth its own
file, but is more than you want to re-type all the time either, so
ideal for an abbreviation in your favorite editor.

I've added a couple of comments in the version below.

Cheers -Terry

---cut here---
import json

# name for persistent data store
json_state_file = "cache_info_file.json"   
if not os.path.exists(json_state_file):
    # create persistent data store if it doesn't exist
    json.dump({'cache_items':{}}, open(json_state_file, 'w'))
# load persistent data
cache_info = json.load(open(json_state_file))

def main():

    # do stuff with cache_info...

if __name__ == '__main__':

    try:
        main()
    finally:
        # save altered persistent data
        json.dump(cache_info, open(json_state_file, 'w'), indent=4)
---cut here---

</t>
<t tx="ekr.20130806211959.17370">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Because I have two nodes which were originally identical but are now
different and I want to see the differences.

My outline loads a @file called ~/.leo/t/gen which contains a @button
with several @rclick children for commonly used tasks.  So I add a new
one, @rclick diff

  selected = c.getSelectedPositions()
  open('/tmp/a_diff', 'w').write(selected[0].b)
  open('/tmp/b_diff', 'w').write(selected[1].b)
  import os
  os.system("xxdiff /tmp/a_diff /tmp/b_diff &amp;")

which is horrible for a number of reasons but also took only moments
to write.  And now, not only does this Leo session have a visual node
diff capability, but also every future session which loads ~/.leo/t/gen.

When you can go from wanting to having a feature in less time than it
takes to write an email about it - well, that's "why Leo".

(I also have @file ~/.leo/sql and @file ~/.leo/dml for commands for
handling SQL and an XML dialect I use a lot, it's a great way to manage
little snippet functions)
</t>
<t tx="ekr.20130806211959.17371">From: Terry Brown &lt;terry_n_brown@yahoo.com&gt;

Because I have two nodes which were originally identical but are now
different and I want to see the differences.

My outline loads a @file called ~/.leo/t/gen which contains a @button
with several @rclick children for commonly used tasks.  So I add a new
one, @rclick diff

  selected = c.getSelectedPositions()
  open('/tmp/a_diff', 'w').write(selected[0].b)
  open('/tmp/b_diff', 'w').write(selected[1].b)
  import os
  os.system("xxdiff /tmp/a_diff /tmp/b_diff &amp;")

which is horrible for a number of reasons but also took only moments
to write.  And now, not only does this Leo session have a visual node
diff capability, but also every future session which loads ~/.leo/t/gen.

When you can go from wanting to having a feature in less time than it
takes to write an email about it - well, that's "why Leo".

(I also have @file ~/.leo/sql and @file ~/.leo/dml for commands for
handling SQL and an XML dialect I use a lot, it's a great way to manage
little snippet functions)

Cheers -Terry
</t>
<t tx="ekr.20130806211959.17374">From: wgw &lt;wgwinder@gmail.com&gt;

Useful!

For fun (and perhaps of some use), here is a brute compare of trees. I use
meld, which has a great interface.

I think I will set up a pyflakes button as well; I haven't seen it as part
of Leo, though the Leo error python messages are good.

-----------------------

def add_text(nd):
    """recursively add to text"""
    text =3D "\\n\\n&gt;&gt; " + nd.h
    text +=3D "\\n\\n%s" % nd.b
    for child in nd.children():
        text +=3D add_text(child)
    return text

selected =3D c.getSelectedPositions()
open('/tmp/a_diff', 'w').write(add_text(selected[0]).encode("utf-8"))
open('/tmp/b_diff', 'w').write(add_text(selected[1]).encode("utf-8"))
import os
os.system("meld /tmp/a_diff /tmp/b_diff &amp;")

-------------


Le vendredi 1 f=E9vrier 2013 11:08:30 UTC-8, Terry a =E9crit :
&gt;
&gt; Because I have two nodes which were originally identical but are now
&gt; different and I want to see the differences.
&gt;
&gt; My outline loads a @file called ~/.leo/t/gen which contains a @button
&gt; with several @rclick children for commonly used tasks.  So I add a new
&gt; one, @rclick diff
&gt;
&gt;   selected =3D c.getSelectedPositions()
&gt;   open('/tmp/a_diff', 'w').write(selected[0].b)
&gt;   open('/tmp/b_diff', 'w').write(selected[1].b)
&gt;   import os
&gt;   os.system("xxdiff /tmp/a_diff /tmp/b_diff &amp;")
&gt;
&gt; which is horrible for a number of reasons but also took only moments
&gt; to write.  And now, not only does this Leo session have a visual node
&gt; diff capability, but also every future session which loads ~/.leo/t/gen.

&gt;
&gt; When you can go from wanting to having a feature in less time than it
&gt; takes to write an email about it - well, that's "why Leo".
&gt;
&gt; (I also have @file ~/.leo/sql and @file ~/.leo/dml for commands for
&gt; handling SQL and an XML dialect I use a lot, it's a great way to manage=

&gt; little snippet functions)
&gt;
&gt; Cheers -Terry
&gt;

</t>
<t tx="ekr.20130806211959.17375">From: &lt;fidelperez@gmail.com&gt;

This is my first post on this group, as I discovered your software only 
yesterday, but I am already migrating all my data, weblinks, etc, to it. 
Love it.

I found it because I was planning on programming something similar (by far 
more primitive of course), but *luckily* I found it just while I was 
starting with my first steps. What I also mean by this is its a rather 
difficult software to find by non programer users who could also greatly 
benefit from it. Im so glad I found it.

The main reason for me wanting a tool which can track different types of 
information (images, videos, etc), is to make such a program able not only 
to track the information just in the way I like it, but to also operate 
with it avoiding repetitive tasks for me.

Thanks for your software, Im really excited to have found it.
</t>
<t tx="ekr.20130807090137.11464">From: vili &lt;viljem.tisnikar@gmail.com&gt;

Despite I am no programmer, I have been using Leo for some years now
as my "Intelligent PIM" - I organize my (complex) life with Leo.

Many thanks to Edward and others for the great application.
</t>
<t tx="ekr.20130807203905.16594">@language rest

From the thread: "Associate .Leo files to open with Leo when double click"
https://groups.google.com/d/msg/leo-editor/KOXSm8crU1I/qCLYzZCJuc4J

From: &lt;fidelperez@gmail.com&gt;

1. Include a small file within the Quickstart guide which would associate
   files automatically. (Or maybe asking for imput, which can be done
   through a Leo node and this way the user learns about its
   functionality).

2. More buttons or scripts in quick start guide, preferably before the
   "programming" section, so when a new user opens it, he has had the
   opportunity to do Ctrl+B on several scripts (for instance, showing in
   the log the name of all the nodes within the selected one, having some
   subnodes with numbers and doing math on them and showing the result on
   the log pane, and as much "silly" but visual functions as possible so
   the user, by going pressing ctrl+b on each, gets a bigger chance to
   understand what is Leo. In my oppinion some users will just stop in the
   quickguide if they are not presented with such a thing before going to
   docs.leo etc.

3. The description of the plugins is not as accessible as it should be. A
   script for activating them easier, been a week using Leo and still cant
   quite activate, find the descriptions or use them freely... And if each
   plugin or script had an example of use that would be priceless, for
   instance, including them all in quickstart (both scripts, plugins
   branchs) and then the new user could just go through all clicking on the
   examples and just seeing Leo work and show its potential. I know some of
   those are done but as I said, after a week or so I still am very
   confused...

4. Quickstart should be open by default (instead of current Leo workbook)
   at least until the user changes some config and prevents that from
   happening. Is there any "load previous tabs" functionality? (IE open the
   Leo files which where open when it was closed the last time)
</t>
<t tx="ekr.20130807203905.16596">From the thread: Cannot open Leo files by double-click in Windows Explorer?
https://groups.google.com/d/msg/leo-editor/KwrqYGMH20Q/z1uc-99vsnsJ

From: HansBKK &lt;hansbkk@gmail.com&gt;

For those like me who work in "portable" mode, there's a very cool tool
called "PortableFileAssociator" that allows you to create a set of windows
file associations, icons etc and enable/disable the whole profile at one
time, without messing with the local system's registry.

Also handy for those not in portable mode, but working on different windows
boxes and bored with having to tweak each one separately.
</t>
<t tx="ekr.20130807203905.16656">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

I continue to work feverishly on various aspects of static type checking.

That work lead to a discovery that may benefit you.  It's one of the most 
beautiful patterns I've ever created: it allows a program to simply and 
naturally build up huge strings without using any string operations.  
Generating an html file with minimal stress on the gc is an obvious 
application.  You could also say that the pattern creates a Pythonic way of 
using lisp-like algorithms, but more safely than in lisp.

Full details at the stc documentation page::
http://webpages.charter.net/edreamleo/stc/stc.html#a-beautiful-pattern-for-building-large-strings

</t>
<t tx="ekr.20130807203905.16657">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Wednesday, January 2, 2013 10:02:40 AM UTC-6, Edward K. Ream wrote:

ReportTraverser uses this pattern at rev 288.  It is a remarkable 
simplification.
 

&gt; The revised r.div method will be something like::
&gt;
&gt;     def div(self,aList):
&gt;         compute old and new indents
&gt;         return [
&gt;             &lt;div&gt;, with old indent,
&gt;             aList, with new indent,
&gt;             &lt;/div&gt;, with old indent,
&gt;         ]
&gt;

This doesn't work!  aList won't have the proper indentation.  In 
particular, the following won't work::

    [['  ',z] for z in aList],

flatten_list will add the two spaces before the line, that is, before a 
newline. Instead, a hack is needed:

    return [
        div,
        join_list(aList,indent='  '),
        '\\n&lt;/div&gt;'
    ]

The new 'indent' keyword tells flatten_list to add the given indentation 
(two spaces, here), to strings that start with a newline.  The new code in 
flatten_list is::

        for i,item in enumerate(aList):
            if leading:                  yield leading
            for s in flatten_list(item):
                if indent:
                    if s.startswith('\\n'):
                        yield '\\n'+indent+s[1:]
                    else:
                        yield s
                else:
                    yield s
            if sep and i &lt; len(aList)-1: yield sep
            if trailing:                 yield trailing

The point is that the indentation must be "moved behind the newline".

Edward

</t>
<t tx="ekr.20130807203905.16659">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

This seems like a spiritual relative of "rope" data structure:

http://en.wikipedia.org/wiki/Rope_(data_structure)

http://www.sgi.com/tech/stl/Rope.html

===== EKR

Yes, there is a similarity. However, the real beauty of new pattern is the
flatten_list method. It's the combination of the lists and flatten_list
that gives the pattern real power. We've just seen how the 'indent' keyword
hack allows sophisticated processing of the lists. I wouldn't expect more
hacks to be needed, but I've been surprised before ;-)
</t>
<t tx="ekr.20130807203905.16660">On Tue, 1 Jan 2013 17:03:05 -0800 (PST)
"Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:

&gt; Generating an html file with minimal stress on the gc is an obvious 
&gt; application.

Nice.  An HTML specific approach which avoids things like the
r.div_end() construct is the LXML element factory:
http://lxml.de/tutorial.html#the-e-factory

Cheers -Terry

</t>
<t tx="ekr.20130807203905.16662">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Thursday, January 3, 2013 3:28:52 AM UTC-6, Ville M. Vainio wrote:
&gt;
&gt; Yes, it's indeed an interesting pattern. 
&gt;
&gt; It would seem more useful in faster languages than python though; in 
&gt; python, string operations (and gc) are faster in comparison to executing 
&gt; other code, whereas in fast, more static languages (C++, Java, Go) avoiding 
&gt; GC gives you great benefits (I saw 5x perf increase reported for some Go 
&gt; app when eliminating GC).
&gt;

Thanks for these remarks.  I've enjoyed thinking about them.  A few 
responses:

1. This is a smallish pattern--it can't change the world, except insofar as 
something beautiful changes the world.

2. Otoh, the pattern changes the way I think about lisp and lisp-like 
patterns.  That's not nothing. For the first time, it makes list-oriented  
programming pattern completely safe.  It does this because it doesn't 
matter what each component list contains, nor does it matter *at all* what 
the shape of any part of the tree is.  This makes the pattern completely 
flexible.

3. The pattern can be generalized.  The pattern I described uses a tree of 
component strings to describe a (large) resulting string.  But one can 
easily imagine using lists to hold anything at all (of whatever tree shape) 
and then use another version of flatten_list to compose results of other 
types.  Alternatively, rather than composing a result, the analog of 
flatten_list could process the tree of lists in other ways.  So the most 
general version of the pattern is:

A) The tree of lists can contain any data whatever, especially including 
None,
B) The "producers" (visitors) can create subtrees of whatever shape,
C) The analog of flatten_list is free to do anything whatever with the 
resulting tree.

I suspect that these features are what appeal to lisp programmers ;-)

4. I'm not sure whether the pattern is more useful in "faster" languages or 
not.  True, anything that helps a feeble language like C++ will seem useful 
:-)  But points 1-3 above have nothing to do with speed: they just make 
programming simpler, more flexible, more powerful and more fun.

Imo, gc issues are important both in Python and in C++.  For stc, the only 
way to get reproducible timing statistics for tests was to do the following 
before running the test::

    for z in (0,1,2): gc.collect(z)

The ReportTraverser class no longer contains *any* calls to string.join, so 
one could imagine that all strings used in the code would be interned.  The 
generated tree actually contains nothing but *references* to strings, and 
if all strings are interned the references will not themselves cause any 
new strings to be allocated.

Naturally, gc issues are even more important in language like C++ without a 
gc.  Lol.  The preceding paragraph is more important for C++ than in 
Python.  So yes, in this sense I agree with you completely that the pattern 
is more useful for "fast" languages than for Python.

Thanks, Ville, for provoking all these pleasant thoughts :-)
</t>
<t tx="ekr.20130807203905.16663">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

On Tue, Jan 1, 2013 at 9:48 PM, Terry Brown &lt;terry_n_brown@yahoo.com&gt; wrote:

&gt; On Tue, 1 Jan 2013 17:03:05 -0800 (PST)
&gt; "Edward K. Ream" &lt;edreamleo@gmail.com&gt; wrote:
&gt;
&gt; &gt; Generating an html file with minimal stress on the gc is an obvious
&gt; &gt; application.
&gt;
&gt; Nice.  An HTML specific approach which avoids things like the
&gt; r.div_end() construct is the LXML element factory:
&gt; http://lxml.de/tutorial.html#the-e-factory
&gt;

Beautiful.  With the list framework the revised r.div method would be
something like::

    def div(self,aList):
        compute old and new indents
        return [
            &lt;div&gt;, with old indent,
            aList, with new indent,
            &lt;/div&gt;, with old indent,
        ]

An example of the pattern in use::

    return [
        ...
        r.div([
            contents of the div,
        ]),
        ...
    ]

Similarly for span, etc. Thanks for pointing this out.  This is too good to
ignore.  I'll do it soon.
</t>
<t tx="ekr.20130807203905.16664">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

Some people seem to think that it is difficult to understand how Leo
handles "clone wars":  differing values for a cloned nodes that appear
in several external files.  That's not true.  The rule is::

    **The last clone that Leo reads wins.**

That is, for any cloned node C, Leo takes the value of C.h and C.b to
be the values specified by the last copy that Leo reads.

There is only one complication::

    **Leo reads the entire outline before reading any external
files.**

Thus, if C appears in x.leo, y.py and z.py, Leo will choose the value
for C in x.py or y.py, depending on which @&lt;file&gt; node appears later
in the outline.

Notes:

1. Whenever Leo detects multiple values for C when opening an outline, Leo
   creates a "Recovered nodes" tree. This tree contains all the various
   values for C, nicely formatted so that it is easy to determine where the
   differences are.

2. I've just refreshed my memory by looking at the code.  The relevant methods are:

    fc.getLeoFile # Reads the outline, then calls at.readAll to read all external files.
    at.indicateNodeChanged # Adds data to c.nodeConflictList
    cacher.reportChangedClone # Adds data to c.nodeConflictList
    fc.handleNodeConflicts # Creates "Recovered Nodes" node and its children.

3. The present code is the simplest code that could possibly work. There is
no way Leo is going to do AI in order to implement complex rules for which
clones are "more important" than others. Thus, if you use cross-file
clones, it is up to *you* to know these rules and handle any resulting
conflicts. Imo, the "Recovered Nodes" feature is a big step forward for
Leo, and makes it impossible to lose data unless you willfully refuse to
examine the data.
</t>
<t tx="ekr.20130807203905.16665">From: Joon Ro &lt;joonpyro@gmail.com&gt;

Thanks for the explanation. As a matter of fact, I was having hard time 
understanding this. 

I had my source file in a @shadow node, and then I had a backup of that 
file as @file node, which had clones of the nodes of the source @shadow 
file and some other codes that I stashed. 

Whenever I changed the source code externally with leo closed, when I open 
leo, it made recovered nodes. The problem was since @file was placed 
"later" in the outline, leo kept putting the new changes I made to old, 
instead of new.

Now I understand how this works. but I think in multiple external file 
cases, it would make more sense if leo checks the file modification time 
when it makes decision which node is new, instead of just depending on the 
order of files in the outline. In above case, it is natural for me to have 
actual source nodes on the top of the outline and backup nodes on the 
bottom. Please let me know what you think. 
</t>
<t tx="ekr.20130807203905.16668">From: "Edward K. Ream" &lt;edreamleo@gmail.com&gt;

The following is a first draft of a unit-testing tutorial.  It will form 
the basis of a new help-for-unit-testing command, and may also become the 
introduction to Leo unit-testing chapter.

All comments are welcome.  Please let me know if anything is unclear.

-----

Leo makes it easy to create and run unit tests from individual outline 
nodes or trees.

A node whose headline starts with @tests defines a unit test.

The body text of the @test node contains a **self-contained** unit test.

For example, this creates a complete unit test::

    @test fails  (headline)
    assert False (body text)

To run this test, select the @test node and do:
&lt;alt-x&gt;run-selected-unit-tests-locally.
Leo will create and run the unit test automatically.

To see all of Leo's unit testing commands, do:
&lt;alt-x&gt;run&lt;tab&gt;

Leo pre-defines 'c', 'g' and 'p' in unit tests just as in scripts.

For more details about unit testing, see: 
http://leoeditor.com/unitTesting.html

**Notes for Leo developers**

leo/test/unitTest.leo contains all of Leo's own unit tests.

Running all tests is not necessary.  Just select::

    Active Unit Tests

and then do Alt-4 (run-selected-unit-tests-locally).

**Note**: Some tests will likely fail on machines other than EKR's.
You only need to be concerned about unit tests that start failing after you 
make your changes.

</t>
<t tx="ekr.20130807203905.16669">contextmenu
screenshots
todo
valuespace
</t>
<t tx="ekr.20130807203905.16678">@language rest

- Don't read code: use g.trace and g.pdb instead.
- Where the bodies are hidden.
    - self.w in leoEditCommands.py
- Complex code that *can't* be simplified.
- The top 20 methods.  You must understand these *in general*.
    - k.masterKeyHandler.
    - qt.eventFilter.
    
** Add mandatory _kind fields to all g.Bunches.
</t>
<t tx="ekr.20130807203905.16679">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

I am having some problems wrapping my head around how focus behaves
throughout leo.

IMO it would be a good idea to have only one place in Leo where focus is
explicitly set. E.g. g.setFocus(widget). This implementetation would
suffice:

def setFocus(widget):
  widget.setFocus()

Reasoning: it would be handy to add debugging stuff here, to see why my
focus stuff is failing in alt-x go-anywhere handling.

(My guess is treeFocusHelper only understanding focus being either in tree
or body, but no time to explore further now)

===== EKR

In fact, there is only one such place: c.outerUpdate.  The various
xWantsFocus methods simply set ivars, which c.outerUpdate uses to set the
focus when a command completes.

The various xWantsFocusNow methods call c.outerUpdate immediately.  Usually
we don't want to do this, because it could cause screen flash, but
sometimes the immediate update is essential.

I've marked this thread as a topic for implementers.  Such things will form
the basis for documentation for my successors.
</t>
<t tx="ekr.20130807203905.16681">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

--089e0122f80868cb1b04dce55d84
Content-Type: text/plain; charset=ISO-8859-1

Someone may be interested in investigating a free CI system for Leo:

https://travis-ci.org/

This could e.g. create debian packages for daily builds, run unit tests,
check stuff with lint, try compiling with python3 so we (*cough*) wouldn't
have accidental print statements in the source...
</t>
<t tx="ekr.20130807203905.16684">From: "Ville M. Vainio" &lt;vivainio@gmail.com&gt;

Ramblings relevant to Leo, by the PyQt lead developer:

http://www.riverbankcomputing.co.uk/static/Docs/dip/architecture.html#the-realities-of-software-development

esp "The Myth of Toolkit Independence"

===== EKR

Leo's core benefits greatly from toolkit independence, despite some
(usually minor) extra complexity. Obviously, this has not constrained
what plugins can do.

This is pretty much a non-issue for Leo.  The reason is clear enough:
the hundreds of commands defined in Leo's core are mostly
straightforward renditions of emacs text commands.  There, the
constraints of an abstraction layer do not pinch.  Furthermore, using
common gui-level code is a good application of the DRY (Don't Repeat
Yourself) principle, as recent bug fixes in the common code
illustrate.

The code for ensuring that the outline and body text are updated
properly (and in synch!) is much more difficult, but the difficulties
are fundamental: they have almost nothing to do with actual guis.

In short, I think Leo's design uses the best of the gui-dependent and
gui-independent approaches.
</t>
<t tx="ekr.20131004191204.16078"># Use table?
</t>
<t tx="ekr.20131016032805.16721" annotate="7d71002e">def execute_shell_commands(commands,trace = False):
    '''
    Execute each shell command in a separate process.
    Wait for each command to complete, except those starting with '&amp;'
    '''
    if g.isString(commands): commands = [commands]
    for command in commands:
        wait = not command.startswith('&amp;')
        if command.startswith('&amp;'): command = command[1:].strip()
        if trace: print('\n&gt;%s%s\n' % ('' if wait else '&amp;',command))
        proc = subprocess.Popen(command,shell=True)
        if wait: proc.communicate()
</t>
<t tx="ekr.20131025044901.17146"># Don't change selected node!
</t>
<t tx="ekr.20131027064821.18715">https://groups.google.com/forum/#!topic/leo-editor/rTN1S9u74RQ

 ​It works for me, but only in special cases.

The reason the *exact* example above works is that:

a) c.atFileCommands.write is *already* a valid completion and
b) c.atFileCommands.write is *also* a prefix of other at.fileCommands methods.

In that case, ​
 
​auto_completer_state_handler is still active, and the '?' characters works.

Obviously, there are many other situations where you have typed a unique method name, which causes auto_completer_state_handler to exit.  In those more common cases, the '?' character won't work.

There is no quick fix for this.  Probably a new command is needed.
</t>
<t tx="ekr.20131103054650.16527"></t>
<t tx="ekr.20131111060930.18010"># Standard bindings...
# run-selected-unit-tests-externally = Alt-4 
# run-marked-unit-tests-externally = Alt-5
# run-marked-unit-tests-locally = Alt-6
run-selected-unit-tests-locally = Alt-4
do-nothing = Alt-5
run-marked-unit-tests-locally = Alt-6
</t>
<t tx="ekr.20131121084830.16362"># Toggle the settings.
g.app.debug_app = not g.app.debug_app
g.app.debug_widgets = not g.app.debug_widgets
# Report the new settings.
print('g.app.debug_app: %s' % g.app.debug_app)
print('g.app.debug_widgets: %s' % g.app.debug_widgets)
</t>
<t tx="ekr.20131220065609.16590"></t>
<t tx="ekr.20140102162014.16438">unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class LocalConfigManager--&gt;c.config.Getters--&gt;c.config.Getters--&gt;c.config.getData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;class GlobalConfigManager--&gt;gcm.Getters...--&gt;gcm.getData &amp; getOutlineData
unl: Code--&gt;Core classes--&gt;@file leoConfig.py--&gt;&lt;&lt; class ParserBaseClass &gt;&gt;--&gt;kind handlers (ParserBaseClass)--&gt;doData
@language rest
The parser for @data nodes, doData, no longer strips *anything*.</t>
<t tx="ekr.20140103105930.16446"></t>
<t tx="ekr.20140808103117.18035"></t>
<t tx="ekr.20140808103117.18036">gnx: ekr.20110605121601.18696
</t>
<t tx="ekr.20140808103117.18038">gnx: ekr.20110605121601.18698
</t>
<t tx="ekr.20140808103117.18040">gnx: ekr.20110605121601.18703
</t>
<t tx="ekr.20140808103117.18042">gnx: ekr.20110605121601.18704
</t>
<t tx="ekr.20140808103117.18044">gnx: ekr.20110605121601.18709
</t>
<t tx="ekr.20140816165728.18940">class GetArg:
    '''
    A class encapsulating all k.getArg logic.
    
    k.getArg maps to ga.get_arg, which gets arguments in the minibuffer.
    
    For details, see the docstring for ga.get_arg
    '''
    # pylint: disable=no-self-argument
    # The first argument is ga.
    @others
</t>
<t tx="ekr.20140816165728.18941">def get_arg (ga,event,
    returnKind=None,returnState=None,handler=None,
    tabList=[],completion=True,oneCharacter=False,
    stroke=None,useMinibuffer=True
):
    &lt;&lt; ga.get_arg docstring &gt;&gt;
    # pylint: disable=unpacking-non-sequence
    trace = False and not g.app.unitTesting
    c,k = ga.c,ga.k
    state = k.getState('getArg')
    c.check_event(event)
    # Remember these events also.
    if c.macroCommands.recordingMacro and state &gt; 0:
        c.macroCommands.startRecordingMacro(event)
    char = event and event.char or ''
    if state &gt; 0:
        k.setLossage(char,stroke)
    if state == 0:
        ga.do_state_zero(completion,event,handler,oneCharacter,
            returnKind,returnState,tabList,useMinibuffer)
        if trace: ga.trace_state(char,completion,handler,state,stroke)
    else:
        if trace: ga.trace_state(char,completion,handler,state,stroke)
        if char == 'Escape':
            k.keyboardQuit()
        elif ga.should_end(char,stroke):
            ga.do_end(event,char,stroke)
        elif char in('\t','Tab'):
            if trace: g.trace('***tab***')
            ga.do_tab(ga.tabList,ga.arg_completion)
        elif char in ('\b','BackSpace'):
            ga.do_back_space(ga.tabList,ga.arg_completion)
            c.minibufferWantsFocus()
        elif k.isFKey(stroke):
            # Ignore only F-keys. Ignoring all except plain keys would kill unicode searches.
            pass
        else:
            ga.do_char(event,char)
</t>
<t tx="ekr.20140816165728.18952">def __init__(ga,c,prompt='full-command: ',tabName='Completion'):
    '''Ctor for GetArg class.'''
    # Common ivars.
    ga.c = c
    ga.k = c.k
    assert c
    assert c.k
    ga.log = c.frame.log or g.NullObject()
    ga.tabName = tabName
    # State vars.
    ga.after_get_arg_state = None,None,None
    ga.arg_completion = True
    ga.handler = None
    ga.tabList = []
    # Tab cycling ivars...
    ga.cycling_prefix = None
    ga.cycling_index = -1
    ga.cycling_tabList = []
    # The following are k globals.
        # k.arg.
        # k.argSelectedText
        # k.oneCharacterArg
</t>
<t tx="ekr.20140816165728.18955">def do_char (ga,event,char):
    '''Handle a non-special character.'''
    k = ga.k
    k.updateLabel(event)
    # Any plain key resets tab cycling.
    ga.reset_tab_cycling()
</t>
<t tx="ekr.20140816165728.18958"># Not useful because k.entendLabel doesn't handle selected text.
if 0:
    def extend_label(ga,s):
        '''Extend the label by s.'''
        ga.c.k.extendLabel(s,select=False,protect=False)

def get_label(ga):
    '''Return the label, not including the prompt.'''
    return ga.c.k.getLabel(ignorePrompt=True)

def set_label(ga,s):
    '''Set the label after the prompt to s. The prompt never changes.'''
    k = ga.c.k
    # Using k.mb_prefix is simplest.  No ga.ivars need be inited.
    k.setLabel(k.mb_prefix,protect=True)
    k.extendLabel(s or '',select=False,protect=False)
</t>
<t tx="ekr.20140816165728.18959">def show_tab_list (ga,tabList):
    '''Show the tab list in the log tab.'''
    k = ga.k
    ga.log.clearTab(ga.tabName)
    d = k.computeInverseBindingDict()
    data,n = [],0
    for commandName in tabList:
        dataList = d.get(commandName,[('',''),])
        for z in dataList:
            pane,key = z
            s1a = '%s ' % (pane) if pane != 'all:' else ''
            s1b = k.prettyPrintKey(key)
            s1 = s1a + s1b
            s2 = commandName
            data.append((s1,s2),)
            n = max(n,len(s1))
    aList = ['%*s %s' % (-n,s1,s2) for s1,s2 in data]
    g.es('','\n'.join(aList),tabName=ga.tabName)
</t>
<t tx="ekr.20140816165728.18965"># Called from k.fullCommand: with defaultTabList = list(c.commandsDict.keys())

def do_back_space(ga,tabList,completion=True):
    '''Handle a backspace and update the completion list.'''
    trace = False and not g.unitTesting
    # g.trace('completion',completion,tabList)
    c,k = ga.c,ga.k
    ga.tabList = tabList[:] if tabList else []
    # Update the label.
    w = k.w
    i,j = w.getSelectionRange()
    ins = w.getInsertPoint()
    if ins &gt; len(k.mb_prefix):
        # Step 1: actually delete the character.
        i,j = w.getSelectionRange()
        if i == j:
            ins -= 1
            w.delete(ins)
            w.setSelectionRange(ins,ins,insert=ins)
        else:
            ins = i
            w.delete(i,j)
            w.setSelectionRange(i,i,insert=ins)
    if w.getAllText().strip():
        junk,tabList = ga.compute_tab_list(ga.tabList)
        # Do *not* extend the label to the common prefix.
    else:
        tabList = []
    ga.reset_tab_cycling()
    if completion:
        ga.show_tab_list(tabList)
</t>
<t tx="ekr.20140817110228.18316">def do_end(ga,event,char,stroke):
    '''A return or escape has been seen.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    if trace:
        g.trace('char',repr(char),stroke,k.getArgEscapes)
        if ga.after_get_arg_state:
            kind,n,handler = ga.after_get_arg_state
            g.trace('after state',kind,n,handler and handler.__name__ or 'None')
    if char == '\t' and char in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if stroke and stroke in k.getArgEscapes:
        k.getArgEscapeFlag = True
    if k.oneCharacterArg:
        k.arg = char
    else:
        k.arg = ga.get_label()
        if trace: g.trace('k.mb_prefix',k.mb_prefix,'k.arg',k.arg)
    kind,n,handler = ga.after_get_arg_state
    if kind: k.setState(kind,n,handler)
    ga.log.deleteTab('Completion')
    if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
    # pylint: disable=not-callable
    ga.reset_tab_cycling()
    if handler: handler(event)
</t>
<t tx="ekr.20140817110228.18317">def do_state_zero(ga,completion,event,handler,oneCharacter,
    returnKind,returnState,tabList,useMinibuffer
):
    '''Do state 0 processing.'''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    # Set the ga globals...
    ga.after_get_arg_state=returnKind,returnState,handler
    ga.arg_completion = completion
    ga.cycling_prefix = None
    ga.handler = handler
    ga.tabList = tabList[:] if tabList else []
    # Set the k globals...
    k.argSelectedText = c.frame.body.wrapper.getSelectedText()
    k.functionTail = None
    k.oneCharacterArg = oneCharacter
    # Do *not* change the label here!
    # Enter the next state.
    c.widgetWantsFocus(c.frame.body.wrapper)
    k.setState('getArg',1,k.getArg)
    k.afterArgWidget = event and event.widget or c.frame.body.wrapper
    if useMinibuffer: c.minibufferWantsFocus()
</t>
<t tx="ekr.20140817110228.18321"># Called from k.doTabCompletion: with tabList = list(c.commandsDict.keys())

def compute_tab_list(ga,tabList,backspace=False,allow_empty_completion=False):
    '''Compute and show the available completions.'''
    # Support vim-mode commands.
    command = ga.get_label()
    if ga.is_command(command):
        tabList,common_prefix = g.itemsMatchingPrefixInList(command,tabList)
        return common_prefix,tabList
            # note order.
    else:
        # For now, disallow further completions if something follows the command.
        command = ga.get_command(command)
        return command,[command]
</t>
<t tx="ekr.20140817110228.18323"># Used by ga.get_arg and k.fullCommand.

def do_tab(ga,tabList,completion=True):
    '''Handle tab completion when the user hits a tab.'''
    trace = True and not g.unitTesting
    c,k = ga.c,ga.k
    if completion:
        tabList = ga.tabList = tabList[:] if tabList else []
        command = ga.get_label()
        common_prefix,tabList = ga.compute_tab_list(tabList)
        # No tab cycling for completed commands having
        # a 'tab_callback' attribute.
        if len(tabList) == 1:
            # g.trace(ga.cycling_prefix,g.callers(2))
            if ga.do_tab_callback():
                return
            elif ga.cycling_prefix:
                ga.do_tab_cycling(common_prefix,tabList)
            else:
                ga.show_tab_list(tabList)
                if len(common_prefix) &gt; len(command):
                    ga.set_label(common_prefix)
        elif tabList:
            ga.do_tab_cycling(common_prefix,tabList)
    c.minibufferWantsFocus()
</t>
<t tx="ekr.20140818052417.18241"></t>
<t tx="ekr.20140818074502.18221">def is_command(ga,s):
    '''Return False if something, even a blank, follows a command.'''
    if s.startswith(':'):
        if len(s) == 1:
            return True
        elif s[1].isalpha():
            for ch in s[1:]:
                if not ch.isalnum() and ch != '-':
                    return False
            return True
        else:
            # assert not s[1].isalpha()
            # Special case for :! and :% etc.
            return len(s) == 2
    else:
        for ch in s:
            if not ch.isalnum() and ch not in '_-':
                return False
        return True
</t>
<t tx="ekr.20140818074502.18222">def get_command(ga,s):
    '''Return the command part of a minibuffer contents s.'''
    if s.startswith(':'):
        # A vim-like command.
        if len(s) == 1:
            return s
        elif s[1].isalpha():
            command = [':']
            for ch in s[1:]:
                if ch.isalnum() or ch == '-':
                    command.append(ch)
                else: break
            return ''.join(command)
        elif s.startswith(':%s'):
            return s[:3]
        else:
            # Special case for :! and :% etc.
            return s[:2]
    else:
        command = []
        for ch in s:
            if ch.isalnum() or ch in '_-':
                command.append(ch)
            else: break
        return ''.join(command)
</t>
<t tx="ekr.20140818085719.18227">def get_minibuffer_command_name(ga):
    '''Return the command name in the minibuffer.'''
    s = ga.get_label()
    command = ga.get_command(s)
    tail = s[len(command):]
    # g.trace('command:',command,'tail:',tail)
    return command,tail
</t>
<t tx="ekr.20140818103808.18234">def should_end(ga,char,stroke):
    '''Return True if ga.get_arg should return.'''
    k = ga.k
    return (
        char in ('\n','Return',) or
        k.oneCharacterArg or 
        stroke and stroke in k.getArgEscapes or
        char == '\t' and char in k.getArgEscapes
            # The Find Easter Egg.
    )
</t>
<t tx="ekr.20140818103808.18235">def trace_state(ga,char,completion,handler,state,stroke):
    '''Trace the vars and ivars.'''
    k = ga.c.k
    g.trace(
        'state',state,'char',repr(char),'stroke',repr(stroke),
        # 'isPlain',k.isPlainKey(stroke),
        '\n',
        'escapes',k.getArgEscapes,
        'completion',ga.arg_completion,
        'handler',ga.handler and ga.handler.__name__ or 'None',
    )
</t>
<t tx="ekr.20140818145250.18235">def do_tab_callback(ga):
    '''
    If the command-name handler has a tab_callback,
    call handler.tab_callback() and return True.
    '''
    trace = False and not g.unitTesting
    c,k = ga.c,ga.k
    commandName,tail = k.getMinibufferCommandName()
    handler = c.commandsDict.get(commandName)
    if trace: g.trace(commandName,handler and handler.__name__ or 'None')
    if hasattr(handler,'tab_callback'):
        ga.reset_tab_cycling()
        k.functionTail = tail
            # For k.getFileName.
        handler.tab_callback()
        return True
    else:
        return False
</t>
<t tx="ekr.20140819050118.18317">def do_tab_cycling(ga,common_prefix,tabList):
    '''Put the next (or first) completion in the minibuffer.'''
    trace = False and not g.unitTesting
    s = ga.get_label()
    if ga.cycling_prefix:
        if s.startswith(ga.cycling_prefix):
            # The expected case.
            n = ga.cycling_index
            ga.cycling_index = n + 1 if n + 1 &lt; len(ga.cycling_tabList) else 0
            if trace: g.trace('cycle',ga.cycling_index)
            ga.set_label(ga.cycling_tabList[ga.cycling_index])
            ga.show_tab_list(ga.cycling_tabList)
        else:
            # Abort if anything unexpected happens.
            if trace: g.trace('prefix mismatch')
            ga.reset_tab_cycling()
            ga.show_tab_list(tabList)
    elif len(common_prefix) == len(s):
        # Start cycling only when the lengths match is best.
        if trace: g.trace('starting tab cycling')
        ga.cycling_prefix = s
        # Start with the second item if the first is already showing.
        # Otherwise, it takes *two* tabs to change the buffer,
        # which makes it looks like tab cycling doesn't work
        if s == tabList[0] and len(tabList) &gt; 1:
            ga.cycling_index = 1
            ga.set_label(tabList[ga.cycling_index])
        else:
            ga.cycling_index = -1
        ga.cycling_tabList = tabList[:]
        ga.show_tab_list(ga.cycling_tabList)
    else:
        # Never cycle if we can extended the label.
        if trace: g.trace('recompute prefix, extend the label.')
        ga.show_tab_list(tabList)
        if len(common_prefix) &gt; len(s):
            ga.set_label(common_prefix)
</t>
<t tx="ekr.20140819050118.18318">def reset_tab_cycling(ga):
    '''Reset all tab cycling ivars.'''
    ga.cycling_prefix = None
    ga.cycling_index = -1
    ga.cycling_tabList = []
</t>
<t tx="ekr.20140822051549.18299">'''
Accumulate an argument. Enter the given return state when done.

Ctrl-G will abort this processing at any time.

All commands needing user input call k.getArg, which just calls ga.get_arg.

The arguments to ga.get_arg are as follows:
    
event:              The event passed to the command.
    
returnKind=None:    A string.
returnState=None,   An int.
handler=None,       A function.

    When the argument is complete, ga.do_end does::

        if kind: k.setState(kind,n,handler)

tabList=[]:         A list of possible completions.
      
completion=True:    True if completions are enabled.

oneCharacter=False: True if k.arg should be a single character.

stroke=None:        The incoming key stroke.

useMinibuffer=True: True: put focus in the minibuffer while accumulating arguments.
                    False allows sort-lines, for example, to show the selection range.

'''
</t>
<t tx="ekr.20140824043305.18293">* Add all items in the to-be-documented mailbox to docs.
</t>
<t tx="ekr.20140824043305.18294"></t>
<t tx="ekr.20140824043305.18300">All bugs must be fixed for b1.
I'll fix as many bugs as I can for a1.

Fix all git bugs:
https://github.com/leo-editor/leo-editor/labels/bug

- @data qt-scintilla-styles *only* works in leoSetting.leo, not myLeoSettings.leo.

- Vim borders don't work with my standard settings and python3.4 and Qt5
</t>
<t tx="ekr.20140831085423.18630">@language rest

This outline contains all of Leo's core source code.

Leo's code uses the following conventions throughout:

c:  a commander.
ch: a character.
d:  a dialog or a dict.
f:  an open file.
fn: a file name.
g:  the leoGlobals module.
i, j, k: indices into a string.
p:  a Position.
s:  a string.
t:  a text widget.
u:  an undoer.
w:  a gui widget.
v:  a Vnode
z:  a local temp.

In more limited contexts, the following conventions apply:
    
si:     a g.ShortcutInfo object.
ks:     a g.KeyStroke object
stroke: a KeyStroke object.

btw:    leoFrame.BaseTextWrapper
stw:    leoFrame.StringTextWrapper

bqtw:   qt_text.BaseQTextWrapper
lqtb:   qt_text.LeoQTextBrowser
qhlw:   qt_text.QHeadlineWrapper
qmbw:   qt_text.QMinibufferWrapper
qlew:   qt_text.QLineEditWrapper
qsciw:  qt_text.QScintiallaWrapper
qtew:   qt_text.QTextEditWrapper</t>
<t tx="ekr.20140831085423.18631">@language rest

The following are 'official' ivars that will always exist:

c.frame                 The frame containing the log,body,tree, etc.
c.frame.body            The body pane.
c.frame.body.widget     The gui widget for the body pane.
c.frame.body.wrapper    The high level interface for the body widget.
c.frame.iconBar         The icon bar.
c.frame.log             The log pane.
c.frame.log.widget      The gui widget for the log pane.
c.frame.log.wrapper     The high-level inteface for the log pane.
c.frame.tree            The tree pane.

The following ivars no longer exist:

c.frame.body.bodyCtrl   Use c.frame.body.wrapper instead.
c.frame.log.logCtrl     Use c.frame.log.wrapper instead.</t>
<t tx="ekr.20140831085423.18639">@language rest

Here is what you *must know* to understand Leo's core:

1. A **widget** is an actual Qt widget.

Leo's core seldom accesses widgets directly.  Instead...

2. A **wrapper class** defines a standard api that hides the details
   of the underlying gui **text** widgets.

Leo's core uses this api almost exclusively. That is, Leo's core code
treats wrappers *as if* they were only text widgets there are!

There is, however, a back door for (hopefully rare!) special cases.
All wrapper classes define an official "widget" ivar, so core or
plugin code can gain access to the real Qt widget using
wrapper.widget. Searching for wrapper.widget will (or soon will) find
all gui-dependent snippets of code in Leo's core.
</t>
<t tx="ekr.20140902032918.18591">@
&lt;&lt; about widgets and wrappers &gt;&gt;
&lt;&lt; terminology &gt;&gt;
&lt;&lt; official ivars &gt;&gt;
</t>
<t tx="ekr.20140902155015.18674"></t>
<t tx="ekr.20140903025053.18625"></t>
<t tx="ekr.20140905060158.18560">'''
A script to replace body.x with body.wrapper.x for all x in the WrapperAPI.

It is *not undoable* to save massive amounts of memory.
Please run on an already-saved .leo file, and take all other reasonable precautions.

If replace is False, it will just report the changes to be made.
'''
import leo.core.leoFrame as leoFrame
replace = False
aList = sorted([z for z in dir(leoFrame.WrapperAPI) if not z.startswith('__')])
nodes = 0
for p in c.all_unique_positions():
    s = p.b
    nodes += 1
    found = False
    for target in aList:
        i = 0
        pattern = 'body.' + target
        while True:
            i = s.find(pattern,i)
            if i == -1:
                break
            if g.match_word(s,i,pattern):
                if not found:
                    print('In node: %s' % p.h)
                    found = True
                i1,i2 = g.getLine(s,i)
                if replace:
                    j = i + len('body.')
                    s = s[:j] + 'wrapper.' + s[j:]
                    print(s[i1:i2+len('wrapper.')].rstrip())
                    i += len('wrapper.') + len(pattern)
                else:
                    print(s[i1:i2].rstrip())
                    i += len(pattern)
            else:
                i += len(pattern)
    if found and replace:
        p.b = s
print('searched %s nodes' % nodes)
</t>
<t tx="ekr.20140905060158.18561">a = c.frame.body.getInsertPoint()

aBody.getInsertPoint()

if 1:
    c.frame.body.setInsertPoint(0)</t>
<t tx="ekr.20140907201613.18661"></t>
<t tx="ekr.20140910065834.18124"></t>
<t tx="ekr.20140912110338.19365">def get_stylesheet(self):
    '''
    Scan for themes or @data qt-gui-plugin-style-sheet nodes.
    Return the text of the relevant node.
    '''
    themes,theme_name = self.find_themes()
    if themes:
        return self.get_last_theme(themes,theme_name)
    else:
        g.es("No theme found, assuming static stylesheet")
        return self.get_last_style_sheet()
</t>
<t tx="ekr.20140912110338.19366">def get_last_theme(self,themes,theme_name):
    '''Return the stylesheet of the last theme.'''
    g.es("Found theme(s):")
    for name,p in themes:
        g.es('found theme:',name)
    if len(themes) &gt; 1:
        g.es("WARNING: using the *last* theme found")
    theme_p = themes[-1][1]
    unl = theme_p.get_UNL()+'--&gt;'
    seen = 0
    for i in theme_p.subtree_iter():
        # Disable any @data qt-gui-plugin-style-sheet nodes in theme's tree.
        if i.h == '@data qt-gui-plugin-style-sheet':
            i.h = '@@data qt-gui-plugin-style-sheet'
            seen += 1
    if seen == 0:
        g.es("NOTE: Did not find compiled stylesheet for theme")
    elif seen &gt; 1:
        g.es("NOTE: Found multiple compiled stylesheets for theme")
    text = [
        "/*\n  DON'T EDIT THIS, EDIT THE OTHER NODES UNDER "
        "('stylesheet &amp; source')\n  AND RECREATE THIS BY "
        "Alt-X style-reload"
        "\n\n  AUTOMATICALLY GENERATED FROM:\n  %s\n  %s\n*/\n\n"
        % (
            theme_p.get_UNL(with_proto=True),
            datetime.datetime.now().strftime('%Y-%m-%d %H:%M'),
        )]
    for i in theme_p.subtree_iter():
        src = i.get_UNL().replace(unl, '')
        if i.h.startswith('@data '):
            i.h = '@'+i.h
        if ('@ignore' in src) or ('@data' in src):
            continue
        text.append("/*### %s %s*/\n%s\n\n" % (
            src, '#'*(70-len(src)),
            i.b.strip()
        ))
    stylesheet = '\n'.join(text)
    if self.safe:
        g.trace('Stylesheet:\n' % stylesheet)
    else:
        data_p = theme_p.insertAsLastChild()
        data_p.h = '@data qt-gui-plugin-style-sheet'
        data_p.b = stylesheet
        g.es("Stylesheet compiled")
    return stylesheet
</t>
<t tx="ekr.20140912110338.19367">def get_last_style_sheet(self):
    '''Return the body text of the *last* @data qt-gui-plugin-style-sheet node.'''
    sheets = [p.copy() for p in self.settings_p.subtree_iter()
        if p.h == '@data qt-gui-plugin-style-sheet']
    if sheets:
        if len(sheets) &gt; 1:
            g.es("WARNING: found multiple\n'@data qt-gui-plugin-style-sheet' nodes")
            g.es("Using the *last* node found")
        else:
            g.es("Stylesheet found")
        data_p = sheets[-1]
        return data_p.b
    else:
        g.es("No '@data qt-gui-plugin-style-sheet' node")
        # g.es("Typically 'Reload Settings' is used in the Global or Personal "
             # "settings files, 'leoSettings.leo and 'myLeoSettings.leo'")
        return None
</t>
<t tx="ekr.20140912110338.19368">def find_themes(self):
    '''Find all theme-related nodes in the @settings tree.'''
    themes,theme_name = [],'unknown'
    for p in self.settings_p.subtree_iter():
        if p.h.startswith('@string color_theme'):
            theme_name = p.h.split()[-1]
            themes.append((theme_name,p.copy()))
        elif p.h == 'stylesheet &amp; source':
            theme_name = 'unknown'
            themes.append((theme_name,p.copy()))
    return themes,theme_name
</t>
<t tx="ekr.20140912110338.19370">def reload_style_sheets(self):
    '''The main line of the style-reload command.'''
    c = self.c
    lm = g.app.loadManager
    # Reread *all* settings.
    lm.readGlobalSettingsFiles()
    fn = c.shortFileName()
    if fn not in ('leoSettings.leo','myLeoSettings.leo'):
        shortcuts,settings = lm.createSettingsDicts(c,localFlag=True)
        c.config.settingsDict.update(settings)
    # Recompute and apply the stylesheet.
    sheet = self.get_style_sheet_from_settings()
    if sheet:
        w = self.get_master_widget()
        w.setStyleSheet(sheet)
    # c.redraw()
</t>
<t tx="ekr.20140912110338.19371">def __init__(self,c,safe=False):
    '''Ctor the ReloadStyle class.'''
    self.c = c
    self.color_db = leoColor.leo_color_database
    self.safe = safe
    self.settings_p = g.findNodeAnywhere(c,'@settings')
    # This warning is inappropriate in some contexts.
        # if not self.settings_p:
            # g.es("No '@settings' node found in outline.  See:")
            # g.es("http://leoeditor.com/tutorial-basics.html#configuring-leo")
</t>
<t tx="ekr.20140912110338.19372">def munge(self,stylesheet):
    '''
    Return the stylesheet without extra whitespace.

    To avoid false mismatches, this should approximate what Qt does.
    To avoid false matches, this should not munge too much.
    '''
    s = ''.join([s.lstrip().replace('  ',' ').replace(' \n','\n')
        for s in g.splitLines(stylesheet)])
    return s.rstrip()
        # Don't care about ending newline.
</t>
<t tx="ekr.20140913054442.17860">class StyleSheetManager:
    '''A class to manage (reload) Qt style sheets.'''
    @others
</t>
<t tx="ekr.20140913054442.19390">def get_master_widget(self,top=None):
    '''
    Carefully return the master widget.
    For --gui=qttabs, c.frame.top.leo_master is a LeoTabbedTopLevel.
    For --gui=qt,     c.frame.top is a DynamicWindow.
    '''
    if top is None: top = self.c.frame.top
    master = top.leo_master or top
    return master
</t>
<t tx="ekr.20140913054442.19391">def set_selected_style_sheet(self):
    '''For manual testing: update the stylesheet using c.p.b.'''
    if not g.unitTesting:
        c = self.c
        sheet = c.p.b
        sheet = self.expand_css_constants(sheet)
        w = self.get_master_widget(c.frame.top)
        a = w.setStyleSheet(sheet)
</t>
<t tx="ekr.20140915062551.19510">def expand_css_constants(self,sheet,font_size_delta=None):
    '''Expand @ settings into their corresponding constants.'''
    trace = False and not g.unitTesting
    verbose = False
    c = self.c
    if 1:
        constants = []
    else:
        constants = self.find_constants_defined(sheet)
    whine = None
    # whine at the user if they use old style style-sheet comment 
    # definition, but only once
    deltas = c._style_deltas
    # legacy
    if font_size_delta:
        deltas['font-size-body'] = font_size_delta
    if trace: g.trace('c._style_deltas',c._style_deltas)
    for delta in c._style_deltas:
        # adjust @font-size-body by font_size_delta
        # easily extendable to @font-size-*
        val = c.config.getString(delta)
        passes = 10
        while passes and val and val.startswith('@'):
            key = g.app.config.canonicalizeSettingName(val[1:])
            val = c.config.settingsDict.get(key)
            if val:
                val = val.val
            passes -= 1
        if deltas[delta] and (val is not None):
            size = ''.join(i for i in val if i in '01234567890.')
            units = ''.join(i for i in val if i not in '01234567890.')
            size = max(1, int(size) + deltas[delta])
            constants["@"+delta] = "%s%s" % (size, units)
    passes = 10
    to_do = self.find_constants_referenced(sheet)
    changed = True
    while passes and to_do and changed:
        changed = False
        to_do.sort(key=len, reverse=True)
        for const in to_do:
            value = None
            if const in constants:
                # This is about to be removed.
                value = constants[const]
                if const[1:] not in deltas and not whine:
                    whine = ("'%s' from style-sheet comment definition, "
                        "please use regular @string / @color type @settings."
                        % const)
                    g.es(whine)
                    print(whine)
            else:
                key = g.app.config.canonicalizeSettingName(const[1:])
                    # lowercase, without '@','-','_', etc.
                value = c.config.settingsDict.get(key)
                if value is not None:
                    value = '%s /* %s */' % (g.u(value.val),key)
                elif key in self.color_db:
                    value = self.color_db.get(key)
                    value = '%s /* %s */' % (value,key)
                    if trace: g.trace('found color',key,value)
            if value:      
                sheet = re.sub(
                    const+"(?![-A-Za-z0-9_])",  
                    # don't replace shorter constants occuring in larger
                    value,
                    sheet
                )
                changed = True
            else:
                pass
                # tricky, might be an undefined identifier, but it might
                # also be a @foo in a /* comment */, where it's harmless.
                # So rely on whoever calls .setStyleSheet() to do the right thing.
        passes -= 1
        to_do = self.find_constants_referenced(sheet)
    if not passes and to_do:
        g.es("To many iterations of substitution")
    sheet = sheet.replace('\\\n', '')  # join lines ending in \
    if trace and verbose: g.trace('returns...\n',sheet)
    return sheet
</t>
<t tx="ekr.20140915194122.19476">def print_style_sheet(self):
    '''Show the top-level style sheet.'''
    w = self.get_master_widget()
    sheet = w.styleSheet()
    print('style sheet for: %s...\n\n%s' % (w,sheet))
</t>
<t tx="ekr.20140916101314.19538">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20140916170549.19551">def get_data(self,setting):
    '''Return the value of the @data node for the setting.'''
    c = self.c
    return c.config.getData(setting,strip_comments=False,strip_data=False) or []
</t>
<t tx="ekr.20140916170549.19552">def get_style_sheet_from_settings(self):
    '''
    Scan for themes or @data qt-gui-plugin-style-sheet nodes.
    Return the text of the relevant node.
    '''
    if 0: # not ready yet
        c = self.c
        d = c.config.settingsDict
        for key in sorted(d.keys()):
            gs = d.get(key) # A GeneralSetting object.
            if gs.kind == 'string':
                setting = g.toUnicode(gs.setting)
                val = g.toUnicode(gs.val)
                if setting and val and val.startswith('color_theme'):
                    sheet = setting
                    break
    else:
        # No setting found
        aList1 = self.get_data('qt-gui-plugin-style-sheet')
        aList2 = self.get_data('qt-gui-user-style-sheet')
        if aList2: aList1.extend(aList2)
        sheet = ''.join(aList1)
        sheet = self.expand_css_constants(sheet)
    # g.trace(len(sheet))
    return sheet
</t>
<t tx="ekr.20140917154740.17918">@language rest

For a1:

1. Fixing all bugs that could have a major impact on Leo's stability.

For example, issue #35 re duplicate gnx's. I'll review all outstanding bugs
for their effects on stability.

I am dithering about what to do about #28 re large nodes. This must either
become completely solid before a1 or it must be removed entirely from the
5.0 release.

2. Making the install process as easy as possible.

The to-do list contains several good ideas, such as supporting homebrew
install and making Leo a portable app. I'll do as many as possible.

3. Making Leo as easy as possible for newbies.

For example, Fidel made several good suggestions:
https://groups.google.com/d/msg/leo-editor/KOXSm8crU1I/qCLYzZCJuc4J

Fidel suggests quickstart guide should open by default instead of the
user's workbook.

4. Refine the "fit and finish" items as much as possible.

Seemingly small issues such as focus issues are surprisingly important and
difficult to test.

5. Resolving *all* outstanding documentation issues, including summarizing
   many previous conversations. This could take several days.
</t>
<t tx="ekr.20140917180536.19478"></t>
<t tx="ekr.20140918124632.19450"># This script prints the list of known Qt names. Qt seems to ignore case.
from leo.core.leoQt import QtGui
aList = sorted([g.u(z) for z in QtGui.QColor().colorNames()])
print('\n'.join(aList))
</t>
<t tx="ekr.20140919052413.17945">@language rest

https://groups.google.com/d/msg/leo-editor/ujDqUI68Sx4/EwTYCw7O38cJ

In the "Find" tab, check the "suboutline only"

Select an outline, and search for any text on its subtree, for instance
"a". This outline shouldnt have "a" within its text.

Now select another outline (that should have "a" within its text), then
click "Find next" or just do "F3"

It should make the search again, this time within the subtree of the
selected node, but instead, it will give you "not found 'a'"

It will only work if you change the search. So if you want to search for
the same term within another outline, you have to change that twice.

I think this bug also interferes with searches not limited to the
sub-outline, but still wouldn't be able to pinpoint it.


</t>
<t tx="ekr.20140919052413.17946">Do this after the new run-script commands</t>
<t tx="ekr.20140919093158.17876"></t>
<t tx="ekr.20140919145841.17947"></t>
<t tx="ekr.20140920041848.17923">@language rest

1. Improve docstring for bigdash.py:
- Mention global-search command
- Say that the inner "help" command is the way to restore the original
  appearance of the dashboard.

2. Add bigdash to listing of plugins at http://leoeditor.com/plugins.html

3. Fix focus problem with F11 &amp; help-for-command

4. Add modules/plugins to help-for-command.
</t>
<t tx="ekr.20140920064112.17946"></t>
<t tx="ekr.20140921072018.17937">@language rest

run-script-from-bridge
run-script-externally
    * Specify which version of python to use.
    
*** The at_produce plugin now has technology for reporting progress using the IdleTime class.

This technology should become part of g.execute_shell_commands.  New settings will control whether, and how often, to report progress.

*** There will soon be two new functions for running both Leo and non-Leo scripts externally.

- g.run_python_script_externally would simply create an external file containing the script and then run python on that file.

- g.run_leo_script_externally would do something similar using the Leo bridge.

Both functions would be controlled by new settings, including (Kent will be glad) what version of Python.


*** Revise http://leoeditor.com/leoBridge.html

There are several ways to run code externally:

- Using leo.core.leoBridgeTest.
- (When ready) using g.run_leo_script_externally.
- Using the full-blown method that Terry discusses in that chapter.
</t>
<t tx="ekr.20140921072018.17938">* Why not just improve g.execute_shell_commands ?
    - It could report too.
    - And it could use settings too.

- time-between-notifications: 0 means disable notifications.
- Decrease time between calls to idle-time handler.</t>
<t tx="ekr.20140921072018.17943">'''A minimal Leo bridge application'''
# This can not be run locally!
import leo.core.leoBridge as leoBridge
b = leoBridge.controller(
    gui='nullGui',loadPlugins=True,
    silent=False,tracePlugins=True,verbose=False)
g = b.globals()
path = g.os_path_finalize_join(g.app.loadDir,'..','doc','LeoDocs.leo')
assert g.os_path_exists(path)
c = b.openLeoFile(path)
assert c
assert c.rootPosition()
</t>
<t tx="ekr.20140921132351.17921"></t>
<t tx="ekr.20140921180304.17919"></t>
<t tx="ekr.20140922043414.17947"># http://leoeditor.com/leoBridge.html#running-leobridge-from-within-leo

import sys
import subprocess
path = r'c:\Users\edreamleo\test\leo_bridge_test.py'
    ### Create file containing script
assert g.os_path_exists(path)
proc = subprocess.Popen([sys.executable,path])
proc.communicate()
</t>
<t tx="ekr.20140922043414.17948"># From within the bridge, do:
import leo.core.leoTest as leoTest
helper = leoTest.RunTestExternallyHelperClass(c,all=True,marked=False)
helper.runUnitTestLeoFile(
    path='unitTest.leo',
        # The path, relative to leo/test.  The full path will be:
        # g.os_path_finalize_join(g.app.loadDir,'..','test',relative_path)
    gui=None, # Use a Null gui.
    loadPlugins=True,
    readSettings=True,
    silent=True,
    tracePlugins=True,
    verbose=True,
)
</t>
<t tx="ekr.20140922043414.17949">import leo.core.leoBridgeTest as leoBridgeTest

leoBridgeTest.main()</t>
<t tx="ekr.20140922124047.19514"></t>
<t tx="ekr.20140923085942.17943"></t>
<t tx="ekr.20140923144655.17926"></t>
<t tx="ekr.20141006073719.17938"></t>
<t tx="ekr.20141010071140.31027">gnx: ekr.20140225224703.8169
unl: qtui_generate declarations
</t>
<t tx="ekr.20141010071140.31028">gnx: ekr.20140225224703.8170
unl: qt_main declarations
gnx: ekr.20140225224703.8171
unl: class Ui_MainWindow
gnx: ekr.20140902074657.9511
unl: class Ui_MainWindow--&gt;setupUi
gnx: ekr.20140225224703.8173
unl: class Ui_MainWindow--&gt;retranslateUi
</t>
<t tx="ekr.20141010071140.31029"></t>
<t tx="ekr.20141010071140.31030">gnx: ekr.20140225224703.8174
unl: qt_quicksearch declarations
gnx: ekr.20140225224703.8175
unl: class Ui_LeoQuickSearchWidget
gnx: ekr.20140225224703.8176
unl: class Ui_LeoQuickSearchWidget--&gt;setupUi
gnx: ekr.20140225224703.8177
unl: class Ui_LeoQuickSearchWidget--&gt;retranslateUi
</t>
<t tx="ekr.20141010071140.31031"></t>
<t tx="ekr.20141011053251.18205">@language rest

Explore:

- Virtual machines
- PortableFileAssociator
- Homebrew install for Mac.
</t>
<t tx="ekr.20141012064706.18240">https://github.com/leo-editor/leo-editor/issues/35</t>
<t tx="ekr.20141012064706.18242">def setMaxNodeIndex(self):
    '''
        Ensure that g.app.nodeIndices.lastIndex can collide with gnx.
        Fixes bug https://github.com/leo-editor/leo-editor/issues/35
    '''
    trace = False and not g.unitTesting
    if trace:
        import time
        t = time.clock()
    c,ni = self.c,g.app.nodeIndices
    max_n,n,stamp = ni.lastIndex,0,ni.timeString
    for v in c.all_unique_nodes():
        stamp2,id2,n2 = ni.scanGnx(v.fileIndex)
        if stamp == stamp2 and isinstance(n2,(int,long)) and n2 &gt; max_n:
            if trace: g.trace(stamp,n2)
            max_n = n
        n += 1
    ni.lastIndex = max_n
    if trace: g.trace('nodes: %s stamp0: %s max_n %s %4.2f sec.' % (
        n,stamp,max_n,time.clock()-t))
</t>
<t tx="ekr.20141012064706.18243"></t>
<t tx="ekr.20141012064706.18244"></t>
<t tx="ekr.20141012064706.18245"></t>
<t tx="ekr.20141012064706.18533"></t>
<t tx="tbrown.20130411121812.28335">def find_constants_defined(self,text):
    r"""find_constants - Return a dict of constants defined in the supplied text.
    
    NOTE: this supports a legacy way of specifying @&lt;identifiers&gt;, regular
    @string and @color settings should be used instead, so calling this
    wouldn't be needed.  expand_css_constants() issues a warning when
    @&lt;identifiers&gt; are found in the output of this method.
    
    Constants match::
    
        ^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$
        i.e.
        @foo_1-5=a
            @foo_1-5 = a more here

    :Parameters:
    - `text`: text to search
    """
    pattern = re.compile(r"^\s*(@[A-Za-z_][-A-Za-z0-9_]*)\s*=\s*(.*)$")
    ans = {}
    text = text.replace('\\\n', '')  # merge lines ending in \
    for line in text.split('\n'):
        test = pattern.match(line)
        if test:
            ans.update([test.groups()])
    # constants may refer to other constants, de-reference here    
    change = True
    level = 0
    while change and level &lt; 10:
        level += 1
        change = False
        for k in ans:
            # pylint: disable=unnecessary-lambda
            # process longest first so @solarized-base0 is not replaced
            # when it's part of @solarized-base03
            for o in sorted(ans, key=lambda x:len(x), reverse=True):
                if o in ans[k]:
                    change = True
                    ans[k] = ans[k].replace(o, ans[o])
    if level == 10:
        print("Ten levels of recursion processing styles, abandoned.")
        g.es("Ten levels of recursion processing styles, abandoned.")
    return ans
</t>
<t tx="tbrown.20131120093739.27085">def find_constants_referenced(self,text):
    """find_constants - Return a list of constants referenced in the supplied text,
    constants match::
    
        @[A-Za-z_][-A-Za-z0-9_]*
        i.e. @foo_1-5

    :Parameters:
    - `text`: text to search
    """
    return re.findall(r"@[A-Za-z_][-A-Za-z0-9_]*", text)
</t>
</tnodes>
</leo_file>
